<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2945a9bb6561b8c83bea29588d2c37128074144</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\welcome-back-to-cpp-modern-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b6fcb634e1984e8f5e83b2393c1619a4cf559d53</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2c1820c20c225001b992ee0186621cea447d571d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Welcome Back to C++ (Modern C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Welcome Back to C++ (Modern C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ is one of the most widely used programming languages in the world.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Well-written C++ programs are fast and efficient.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The language is more flexible than other languages because you can use it to create a wide range of apps—from fun and exciting games, to high-performance scientific software, to device drivers, embedded programs, and Windows client apps.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more than 20 years, C++ has been used to solve problems like these and many others.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>What you might not know is that an increasing number of C++ programmers have folded up the dowdy C-style programming of yesterday and have donned modern C++ instead.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>One of the original requirements for C++ was backward compatibility with the C language.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Since then, C++ has evolved through several iterations—C with Classes, then the original C++ language specification, and then the many subsequent enhancements.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Because of this heritage, C++ is often referred to as a multi-paradigm programming language.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In C++, you can do purely procedural C-style programming that involves raw pointers, arrays, null-terminated character strings, custom data structures, and other features that may enable great performance but can also spawn bugs and complexity.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because C-style programming is fraught with perils like these, one of the founding goals for C++ was to make programs both type-safe and easier to write, extend, and maintain.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Early on, C++ embraced programming paradigms such as object-oriented programming.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Over the years, features have been added to the language, together with highly-tested standard libraries of data structures and algorithms.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It's these additions that have made the modern C++ style possible.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Modern C++ emphasizes:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Stack-based scope instead of heap or static global scope.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Auto type inference instead of explicit type names.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Smart pointers instead of raw pointers.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>and <ph id="ph1">`std::wstring`</ph> types (see <bpt id="p1">[</bpt><ph id="ph2">\&lt;</ph>string&gt;<ept id="p1">](../standard-library/string.md)</ept>) instead of raw <ph id="ph3">`char[]`</ph> arrays.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Standard template library<ept id="p1">](../standard-library/cpp-standard-library-header-files.md)</ept> (STL) containers like <ph id="ph1">`vector`</ph>, <ph id="ph2">`list`</ph>, and <ph id="ph3">`map`</ph> instead of raw arrays or custom containers.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>vector&gt;<ept id="p1">](../standard-library/vector.md)</ept>, <bpt id="p2">[</bpt><ph id="ph2">\&lt;</ph>list&gt;<ept id="p2">](../standard-library/list.md)</ept>, and <bpt id="p3">[</bpt><ph id="ph3">\&lt;</ph>map&gt;<ept id="p3">](../standard-library/map.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>STL algorithms<ept id="p1">](../standard-library/algorithm.md)</ept> instead of manually coded ones.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Exceptions, to report and handle error conditions.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Lock-free inter-thread communication using STL <ph id="ph1">`std::atomic&lt;&gt;`</ph> (see <bpt id="p1">[</bpt><ph id="ph2">\&lt;</ph>atomic&gt;<ept id="p1">](../standard-library/atomic.md)</ept>) instead of other inter-thread communication mechanisms.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Inline <bpt id="p1">[</bpt>lambda functions<ept id="p1">](../cpp/lambda-expressions-in-cpp.md)</ept> instead of small functions implemented separately.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Range-based for loops to write more robust loops that work with arrays, STL containers, and <ph id="ph1">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> collections in the form <ph id="ph2">`for ( for-range-declaration : expression )`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This is part of the Core Language support.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Range-based for Statement (C++)<ept id="p1">](../cpp/range-based-for-statement-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The C++ language itself has also evolved.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Compare the following code snippets.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This one shows how things used to be in C++:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Here's how the same thing is accomplished in modern C++:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In modern C++, you don't have to use new/delete or explicit exception handling because you can use smart pointers instead.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When you use the <ph id="ph1">`auto`</ph> type deduction and <bpt id="p1">[</bpt>lambda function<ept id="p1">](../cpp/lambda-expressions-in-cpp.md)</ept>, you can write code quicker, tighten it, and understand it better.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>And <ph id="ph1">`for_each`</ph> is cleaner, easier to use, and less prone to unintended errors than a <ph id="ph2">`for`</ph> loop.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can use boilerplate together with minimal lines of code to write your app.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>And you can make that code exception-safe and memory-safe, and have no allocation/deallocation or error codes to deal with.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Modern C++ incorporates two kinds of polymorphism: compile-time, through templates, and run-time, through inheritance and virtualization.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can mix the two kinds of polymorphism to great effect.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The STL template <ph id="ph1">`shared_ptr`</ph> uses internal virtual methods to accomplish its apparently effortless type erasure.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>But don't over-use virtualization for polymorphism when a template is the better choice.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Templates can be very powerful.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If you're coming to C++ from another language, especially from a managed language in which most of the types are reference types and very few are value types, know that C++ classes are value types by default.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>But you can specify them as reference types to enable polymorphic behavior that supports object-oriented programming.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A helpful perspective: value types are more about memory and layout control, reference types are more about base classes and virtual functions to support polymorphism.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, value types are copyable—they each have a copy constructor and a copy assignment operator.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When you specify a reference type, make the class non-copyable—disable the copy constructor and copy assignment operator—and use a virtual destructor, which supports the polymorphism.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Value types are also about the contents, which, when they are copied, give you two independent values that you can modify separately.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>But reference types are about identity—what kind of object it is—and for this reason are sometimes referred to as polymorphic types.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>C++ is experiencing a renaissance because power is king again.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Languages like Java and C# are good when programmer productivity is important, but they show their limitations when power and performance are paramount.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For high efficiency and power, especially on devices that have limited hardware, nothing beats modern C++.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Not only the language is modern, the development tools are, too.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>makes all parts of the development cycle robust and efficient.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It includes Application Lifecycle Management (ALM) tools, IDE enhancements like IntelliSense, tool-friendly mechanisms like XAML, and building, debugging, and many other tools.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The articles in this part of the documentation provide high-level guidelines and best practices for the most important features and techniques for writing modern C++ programs.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Support For C++11/14/17 Features (Modern C++)</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>C++ Type System</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Uniform Initialization and Delegating Constructors</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Object Lifetime And Resource Management</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Objects Own Resources (RAII)</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Smart Pointers</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Pimpl For Compile-Time Encapsulation</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Containers</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>String and I/O Formatting (Modern C++)</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Errors and Exception Handling</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Portability At ABI Boundaries</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For more information, see the StackOverflow article <bpt id="p1">[</bpt>what C++ idioms are deprecated in C++11<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=402836)</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>C++ Language Reference</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>C++ Standard Library</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>