{"nodes":[{"pos":[12,75],"content":"Considerations When Writing Prolog-Epilog Code | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Considerations When Writing Prolog-Epilog Code | Microsoft Docs","pos":[0,63]}]},{"content":"Considerations When Writing Prolog/Epilog Code","pos":[697,743]},{"content":"Microsoft Specific","pos":[746,764]},{"content":"Before writing your own prolog and epilog code sequences, it is important to understand how the stack frame is laid out.","pos":[773,893]},{"content":"It is also useful to know how to use the <bpt id=\"p1\">**</bpt>__LOCAL_SIZE<ept id=\"p1\">**</ept> predefined constant.","pos":[894,972],"source":" It is also useful to know how to use the **__LOCAL_SIZE** predefined constant."},{"pos":[1025,1045],"content":"C Stack Frame Layout"},{"content":"This example shows the standard prolog code that might appear in a 32-bit function:","pos":[1049,1132]},{"content":"The <ph id=\"ph1\">`localbytes`</ph> variable represents the number of bytes needed on the stack for local variables, and the <ph id=\"ph2\">`registers`</ph> variable is a placeholder that represents the list of registers to be saved on the stack.","pos":[1360,1567],"source":"The `localbytes` variable represents the number of bytes needed on the stack for local variables, and the `registers` variable is a placeholder that represents the list of registers to be saved on the stack."},{"content":"After pushing the registers, you can place any other appropriate data on the stack.","pos":[1568,1651]},{"content":"The following is the corresponding epilog code:","pos":[1652,1699]},{"content":"The stack always grows down (from high to low memory addresses).","pos":[1926,1990]},{"content":"The base pointer (<ph id=\"ph1\">`ebp`</ph>) points to the pushed value of <ph id=\"ph2\">`ebp`</ph>.","pos":[1991,2052],"source":" The base pointer (`ebp`) points to the pushed value of `ebp`."},{"content":"The local variables area begins at <ph id=\"ph1\">`ebp-2`</ph>.","pos":[2053,2096],"source":" The local variables area begins at `ebp-2`."},{"content":"To access local variables, calculate an offset from <ph id=\"ph1\">`ebp`</ph> by subtracting the appropriate value from <ph id=\"ph2\">`ebp`</ph>.","pos":[2097,2203],"source":" To access local variables, calculate an offset from `ebp` by subtracting the appropriate value from `ebp`."},{"pos":[2261,2286],"content":"The __LOCAL_SIZE Constant"},{"content":"The compiler provides a constant, <bpt id=\"p1\">**</bpt>__LOCAL_SIZE<ept id=\"p1\">**</ept>, for use in the inline assembler block of function prolog code.","pos":[2290,2404],"source":"The compiler provides a constant, **__LOCAL_SIZE**, for use in the inline assembler block of function prolog code."},{"content":"This constant is used to allocate space for local variables on the stack frame in custom prolog code.","pos":[2405,2506]},{"content":"The compiler determines the value of <bpt id=\"p1\">**</bpt>__LOCAL_SIZE<ept id=\"p1\">**</ept>.","pos":[2513,2567],"source":"The compiler determines the value of **__LOCAL_SIZE**."},{"content":"The value is the total number of bytes of all user-defined local variables and compiler-generated temporary variables.","pos":[2568,2686]},{"content":"<bpt id=\"p1\">**</bpt>__LOCAL_SIZE<ept id=\"p1\">**</ept> can be used only as an immediate operand; it cannot be used in an expression.","pos":[2687,2781],"source":"**__LOCAL_SIZE** can be used only as an immediate operand; it cannot be used in an expression."},{"content":"You must not change or redefine the value of this constant.","pos":[2782,2841]},{"content":"For example:","pos":[2842,2854]},{"pos":[2986,3119],"content":"The following example of a naked function containing custom prolog and epilog sequences uses <bpt id=\"p1\">**</bpt>__LOCAL_SIZE<ept id=\"p1\">**</ept> in the prolog sequence:","source":"The following example of a naked function containing custom prolog and epilog sequences uses **__LOCAL_SIZE** in the prolog sequence:"},{"content":"END Microsoft Specific","pos":[3479,3501]},{"content":"See Also","pos":[3512,3520]},{"content":"Naked Functions","pos":[3525,3540]}],"content":"---\ntitle: \"Considerations When Writing Prolog-Epilog Code | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"layouts, stack frame\"\n  - \"stack frame layout\"\n  - \"__LOCAL_SIZE constant\"\n  - \"stack, stack frame layout\"\nms.assetid: 3b8addec-e809-48e4-b1d0-5bad133bd4b8\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Considerations When Writing Prolog/Epilog Code\n**Microsoft Specific**  \n  \n Before writing your own prolog and epilog code sequences, it is important to understand how the stack frame is laid out. It is also useful to know how to use the **__LOCAL_SIZE** predefined constant.  \n  \n##  <a name=\"_clang_c_stack_frame_layout\"></a> C Stack Frame Layout  \n This example shows the standard prolog code that might appear in a 32-bit function:  \n  \n```  \npush     ebp                 ; Save ebp  \nmov      ebp, esp            ; Set stack frame pointer  \nsub      esp, localbytes     ; Allocate space for locals  \npush     <registers>         ; Save registers  \n```  \n  \n The `localbytes` variable represents the number of bytes needed on the stack for local variables, and the `registers` variable is a placeholder that represents the list of registers to be saved on the stack. After pushing the registers, you can place any other appropriate data on the stack. The following is the corresponding epilog code:  \n  \n```  \npop      <registers>         ; Restore registers  \nmov      esp, ebp            ; Restore stack pointer  \npop      ebp                 ; Restore ebp  \nret                          ; Return from function  \n```  \n  \n The stack always grows down (from high to low memory addresses). The base pointer (`ebp`) points to the pushed value of `ebp`. The local variables area begins at `ebp-2`. To access local variables, calculate an offset from `ebp` by subtracting the appropriate value from `ebp`.  \n  \n##  <a name=\"_clang_the___local_size_constant\"></a> The __LOCAL_SIZE Constant  \n The compiler provides a constant, **__LOCAL_SIZE**, for use in the inline assembler block of function prolog code. This constant is used to allocate space for local variables on the stack frame in custom prolog code.  \n  \n The compiler determines the value of **__LOCAL_SIZE**. The value is the total number of bytes of all user-defined local variables and compiler-generated temporary variables. **__LOCAL_SIZE** can be used only as an immediate operand; it cannot be used in an expression. You must not change or redefine the value of this constant. For example:  \n  \n```  \nmov      eax, __LOCAL_SIZE           ;Immediate operand--Okay  \nmov      eax, [ebp - __LOCAL_SIZE]   ;Error  \n```  \n  \n The following example of a naked function containing custom prolog and epilog sequences uses **__LOCAL_SIZE** in the prolog sequence:  \n  \n```  \n__declspec ( naked ) func()  \n{  \n   int i;  \n   int j;  \n  \n   __asm      /* prolog */  \n      {  \n      push   ebp  \n      mov      ebp, esp  \n      sub      esp, __LOCAL_SIZE  \n      }  \n  \n   /* Function body */  \n  \n   __asm      /* epilog */  \n      {  \n      mov      esp, ebp  \n      pop      ebp  \n      ret  \n      }  \n}     \n```  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Naked Functions](../c-language/naked-functions.md)"}