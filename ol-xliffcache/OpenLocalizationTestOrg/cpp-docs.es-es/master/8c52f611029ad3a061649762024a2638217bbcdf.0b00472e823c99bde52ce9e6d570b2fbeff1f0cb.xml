{"nodes":[{"pos":[12,67],"content":"enum class  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"enum class  (C++ Component Extensions) | Microsoft Docs","pos":[0,55]}]},{"content":"enum class  (C++ Component Extensions)","pos":[559,597]},{"content":"Declares an enumeration at namespace scope, which is a user-defined type consisting of a set of named constants called enumerators.","pos":[598,729]},{"content":"All Runtimes","pos":[738,750]},{"content":"Remarks","pos":[756,763]},{"content":"C++/CX and C++/CLI support <ph id=\"ph1\">`public enum class`</ph> and <ph id=\"ph2\">`private enum class`</ph> which are similar to the standard C++ <ph id=\"ph3\">`enum class`</ph> but with the addition of the accessibility specifier.","pos":[772,948],"source":"C++/CX and C++/CLI support `public enum class` and `private enum class` which are similar to the standard C++ `enum class` but with the addition of the accessibility specifier."},{"content":"Under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, the C++11 <ph id=\"ph1\">`enum class`</ph> type is permitted but will generate warning C4472 which is intended to ensure that you really want the ISO enum type and not the C++/CX and C++/CLI type.","pos":[949,1141],"source":" Under **/clr**, the C++11 `enum class` type is permitted but will generate warning C4472 which is intended to ensure that you really want the ISO enum type and not the C++/CX and C++/CLI type."},{"content":"For more information about the ISO Standard C++ <ph id=\"ph1\">`enum`</ph> keyword, see <bpt id=\"p1\">[</bpt>Enumerations<ept id=\"p1\">](../cpp/enumerations-cpp.md)</ept>.","pos":[1142,1253],"source":" For more information about the ISO Standard C++ `enum` keyword, see [Enumerations](../cpp/enumerations-cpp.md)."},{"content":"Syntax","pos":[1320,1326]},{"content":"Parameters","pos":[1561,1571]},{"content":"access","pos":[1581,1587]},{"content":"The accessibility of the enumeration, which can be <ph id=\"ph1\">`public`</ph> or <ph id=\"ph2\">`private`</ph>.","pos":[1592,1665],"source":" The accessibility of the enumeration, which can be `public` or `private`."},{"content":"enumeration-identifier","pos":[1673,1695]},{"content":"The name of the enumeration.","pos":[1700,1728]},{"content":"underlying-type","pos":[1736,1751]},{"content":"(Optional) The underlying type of the enumeration.","pos":[1756,1806]},{"content":"(Optional.","pos":[1813,1823]},{"content":"only) The underlying type of the enumeration, which can be <ph id=\"ph1\">`bool`</ph>, <ph id=\"ph2\">`char`</ph>, <ph id=\"ph3\">`char16`</ph>, <ph id=\"ph4\">`int16`</ph>, <ph id=\"ph5\">`uint16`</ph>, <ph id=\"ph6\">`int`</ph>, <ph id=\"ph7\">`uint32`</ph>, <ph id=\"ph8\">`int64`</ph>, or <ph id=\"ph9\">`uint64`</ph>.","pos":[1877,2019],"source":" only) The underlying type of the enumeration, which can be `bool`, `char`, `char16`, `int16`, `uint16`, `int`, `uint32`, `int64`, or `uint64`."},{"content":"enumerator-list","pos":[2027,2042]},{"content":"A comma-delimited list of enumerator names.","pos":[2047,2090]},{"content":"The value of each enumerator is a constant expression that is either defined implicitly by the compiler, or explicitly by the notation, <bpt id=\"p1\">*</bpt>enumerator<ept id=\"p1\">*</ept><ph id=\"ph1\">`=`</ph><bpt id=\"p2\">*</bpt>constant-expression<ept id=\"p2\">*</ept>.","pos":[2097,2270],"source":"The value of each enumerator is a constant expression that is either defined implicitly by the compiler, or explicitly by the notation, *enumerator*`=`*constant-expression*."},{"content":"By default, the value of the first enumerator is zero if it is implicitly defined.","pos":[2271,2353]},{"content":"The value of each subsequent implicitly-defined enumerator is the value of the previous enumerator + 1.","pos":[2354,2457]},{"content":"var","pos":[2465,2468]},{"content":"(Optional) The name of a variable of the enumeration type.","pos":[2473,2531]},{"content":"Remarks","pos":[2540,2547]},{"pos":[2556,2669],"content":"For more information, and examples, see <bpt id=\"p1\">[</bpt>Enums<ept id=\"p1\">](http://msdn.microsoft.com/%20library/windows/apps/hh755820.aspx)</ept>.","source":"For more information, and examples, see [Enums](http://msdn.microsoft.com/%20library/windows/apps/hh755820.aspx)."},{"content":"Note that the compiler emits error messages if the constant expression that defines the value of an enumerator cannot be represented by the <bpt id=\"p1\">*</bpt>underlying-type<ept id=\"p1\">*</ept>.","pos":[2676,2834],"source":"Note that the compiler emits error messages if the constant expression that defines the value of an enumerator cannot be represented by the *underlying-type*."},{"content":"However, the compiler does not report an error for a value that is inappropriate for the underlying type.","pos":[2836,2941]},{"content":"For example:","pos":[2942,2954]},{"pos":[2964,3133],"content":"If <bpt id=\"p1\">*</bpt>underlying-type<ept id=\"p1\">*</ept> is numeric, and an enumerator specifies the maximum value for that type, the value of the next implicitly defined enumeratoin cannot be represented.","source":"If *underlying-type* is numeric, and an enumerator specifies the maximum value for that type, the value of the next implicitly defined enumeratoin cannot be represented."},{"pos":[3143,3287],"content":"If <bpt id=\"p1\">*</bpt>underlying-type<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`bool`</ph>, and more than two enumerators are implicitly defined, the enumerators after the first two cannot be represented.","source":"If *underlying-type* is `bool`, and more than two enumerators are implicitly defined, the enumerators after the first two cannot be represented."},{"content":"If <bpt id=\"p1\">*</bpt>underlying-type<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`char16`</ph>, and the enumeration value ranges from 0xD800 through 0xDFFF, the value can be represented.","pos":[3297,3421],"source":"If *underlying-type* is `char16`, and the enumeration value ranges from 0xD800 through 0xDFFF, the value can be represented."},{"content":"However, the value logically incorrect because it represents half a Unicode surrogate pair and should not appear in isolation.","pos":[3422,3548]},{"content":"Requirements","pos":[3558,3570]},{"pos":[3574,3598],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Syntax","pos":[3684,3690]},{"content":"Parameters","pos":[3856,3866]},{"content":"The accessibility of the enum.","pos":[3887,3917]},{"content":"Can be either <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`private`</ph>.","pos":[3919,3957],"source":"  Can be either **public** or `private`."},{"content":"A comma-separated list of the identifiers (enumerators) in the enumeration.","pos":[3985,4060]},{"content":"The name of the enumeration.","pos":[4077,4105]},{"content":"Anonymous managed enumerations are not allowed.","pos":[4107,4154]},{"content":"(optional)","pos":[4168,4178]},{"content":"The underlying type of the <bpt id=\"p1\">*</bpt>identifiers<ept id=\"p1\">*</ept>.","pos":[4182,4223],"source":" The underlying type of the *identifiers*."},{"content":"This can be any scalar type, such as signed or unsigned versions of int, short, or long.","pos":[4225,4313]},{"content":"or <ph id=\"ph1\">`char`</ph> is also allowed.","pos":[4322,4348],"source":" or `char` is also allowed."},{"content":"(optional)","pos":[4361,4371]},{"content":"The name of a variable of the enumeration type.","pos":[4375,4422]},{"content":"Remarks","pos":[4431,4438]},{"pos":[4447,4510],"content":"<bpt id=\"p1\">**</bpt>enum class<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>enum struct<ept id=\"p2\">**</ept> are equivalent declarations.","source":"**enum class** and **enum struct** are equivalent declarations."},{"content":"There are two types of enums: managed or C++/CX and standard.","pos":[4517,4578]},{"content":"A managed or C++/CX enum might be defined as follows,","pos":[4585,4638]},{"content":"and is semantically equivalent to:","pos":[4700,4734]},{"content":"A standard enum might be defined as follows:","pos":[4854,4898]},{"content":"and is semantically equivalent to:","pos":[4949,4983]},{"content":"Managed enumerator names (<bpt id=\"p1\">*</bpt>identifiers<ept id=\"p1\">*</ept>) are not injected into the scope where the enumeration is defined; all references to the enumerators must be fully qualified (<bpt id=\"p2\">*</bpt>name<ept id=\"p2\">*</ept><ph id=\"ph1\">`::`</ph><bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept>).","pos":[5064,5254],"source":"Managed enumerator names (*identifiers*) are not injected into the scope where the enumeration is defined; all references to the enumerators must be fully qualified (*name*`::`*identifier*)."},{"content":"For this reason, you cannot define an anonymous managed enum.","pos":[5256,5317]},{"content":"The enumerators of a standard enum are strongly injected into the enclosing scope.","pos":[5324,5406]},{"content":"That is, if there is another symbol with the same name as an enumerator in the enclosing scope, the compiler will generate an error.","pos":[5408,5540]},{"content":"In Visual C++ 2002 and Visual C++ 2003, enumerators were weakly injected (visible in the enclosing scope unless there was another identifier with the same name).","pos":[5547,5708]},{"content":"If a standard C++ enum is defined (without <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`struct`</ph>), compiling with <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> will cause the enumeration to be compiled as a managed enum.","pos":[5715,5866],"source":"If a standard C++ enum is defined (without **class** or `struct`), compiling with **/clr** will cause the enumeration to be compiled as a managed enum."},{"content":"The enumeration still has the semantics of an unmanaged enumeration.","pos":[5868,5936]},{"content":"Note, the compiler injects an attribute, <ph id=\"ph1\">`Microsoft::VisualC::NativeEnumAttribute`</ph>, which the Visual C++ compiler recognizes, to identify a programmer's intent for the enum to be a native enum.","pos":[5938,6131],"source":"  Note, the compiler injects an attribute, `Microsoft::VisualC::NativeEnumAttribute`, which the Visual C++ compiler recognizes, to identify a programmer's intent for the enum to be a native enum."},{"content":"Other compilers will simply see the standard enum as a managed enum.","pos":[6133,6201]},{"content":"A named, standard enum compiled with /clr will be visible in the assembly as a managed enum, and can be consumed by any other managed compiler.","pos":[6208,6351]},{"content":"However, an unnamed standard enum will not be publicly visible from the assembly.","pos":[6354,6435]},{"content":"In Visual C++ 2002 and Visual C++ 2003, a standard enum used as the type in a function parameter:","pos":[6442,6539]},{"content":"would emit the following in MSIL for the function signature:","pos":[6727,6787]},{"content":"However, in current versions of the compiler, the standard enum is emitted as a managed enum with a [NativeEnumAttribute] and the following in MSIL for the function signature:","pos":[6826,7001]},{"pos":[7035,7139],"content":"For more information about native enums, see <bpt id=\"p1\">[</bpt>C++ Enumeration Declarations<ept id=\"p1\">](../cpp/enumerations-cpp.md)</ept>.","source":"For more information about native enums, see [C++ Enumeration Declarations](../cpp/enumerations-cpp.md)."},{"content":"For more information on CLR enums, see:","pos":[7146,7185]},{"content":"Underlying Type of an Enum","pos":[7196,7222]},{"content":"Requirements","pos":[7290,7302]},{"pos":[7306,7331],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[7341,7349]},{"content":"Example","pos":[7355,7362]},{"content":"desc","pos":[7371,7375]},{"content":"Output","pos":[7998,8004]},{"content":"See Also","pos":[8112,8120]},{"content":"Component Extensions for Runtime Platforms","pos":[8125,8167]}],"content":"---\ntitle: \"enum class  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8010fa8c-bad6-45b4-8214-b4db64d7ffe1\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# enum class  (C++ Component Extensions)\nDeclares an enumeration at namespace scope, which is a user-defined type consisting of a set of named constants called enumerators.  \n  \n## All Runtimes  \n **Remarks**  \n  \n C++/CX and C++/CLI support `public enum class` and `private enum class` which are similar to the standard C++ `enum class` but with the addition of the accessibility specifier. Under **/clr**, the C++11 `enum class` type is permitted but will generate warning C4472 which is intended to ensure that you really want the ISO enum type and not the C++/CX and C++/CLI type. For more information about the ISO Standard C++ `enum` keyword, see [Enumerations](../cpp/enumerations-cpp.md).  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Syntax**  \n  \n```  \n  \n      access  \n      enum class  \n      enumeration-identifier  \n      [:underlying-type] { enumerator-list } [var];  \naccessenum structenumeration-identifier[:underlying-type] { enumerator-list } [var];  \n```  \n  \n **Parameters**  \n  \n *access*  \n The accessibility of the enumeration, which can be `public` or `private`.  \n  \n *enumeration-identifier*  \n The name of the enumeration.  \n  \n *underlying-type*  \n (Optional) The underlying type of the enumeration.  \n  \n (Optional. [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] only) The underlying type of the enumeration, which can be `bool`, `char`, `char16`, `int16`, `uint16`, `int`, `uint32`, `int64`, or `uint64`.  \n  \n *enumerator-list*  \n A comma-delimited list of enumerator names.  \n  \n The value of each enumerator is a constant expression that is either defined implicitly by the compiler, or explicitly by the notation, *enumerator*`=`*constant-expression*. By default, the value of the first enumerator is zero if it is implicitly defined. The value of each subsequent implicitly-defined enumerator is the value of the previous enumerator + 1.  \n  \n *var*  \n (Optional) The name of a variable of the enumeration type.  \n  \n **Remarks**  \n  \n For more information, and examples, see [Enums](http://msdn.microsoft.com/%20library/windows/apps/hh755820.aspx).  \n  \n Note that the compiler emits error messages if the constant expression that defines the value of an enumerator cannot be represented by the *underlying-type*.  However, the compiler does not report an error for a value that is inappropriate for the underlying type. For example:  \n  \n-   If *underlying-type* is numeric, and an enumerator specifies the maximum value for that type, the value of the next implicitly defined enumeratoin cannot be represented.  \n  \n-   If *underlying-type* is `bool`, and more than two enumerators are implicitly defined, the enumerators after the first two cannot be represented.  \n  \n-   If *underlying-type* is `char16`, and the enumeration value ranges from 0xD800 through 0xDFFF, the value can be represented. However, the value logically incorrect because it represents half a Unicode surrogate pair and should not appear in isolation.  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Syntax**  \n  \n```  \n  \n      access  \n      enum class  \n      name [:type] { enumerator-list } var;  \naccessenum structname [:type] { enumerator-list } var;  \n```  \n  \n **Parameters**  \n  \n `access`  \n The accessibility of the enum.  Can be either **public** or `private`.  \n  \n `enumerator-list`  \n A comma-separated list of the identifiers (enumerators) in the enumeration.  \n  \n `name`  \n The name of the enumeration.  Anonymous managed enumerations are not allowed.  \n  \n `type` (optional)  \n The underlying type of the *identifiers*.  This can be any scalar type, such as signed or unsigned versions of int, short, or long.  `bool` or `char` is also allowed.  \n  \n `var` (optional)  \n The name of a variable of the enumeration type.  \n  \n **Remarks**  \n  \n **enum class** and **enum struct** are equivalent declarations.  \n  \n There are two types of enums: managed or C++/CX and standard.  \n  \n A managed or C++/CX enum might be defined as follows,  \n  \n```cpp  \npublic enum class day {sun, mon };  \n```  \n  \n and is semantically equivalent to:  \n  \n```cpp  \nref class day {  \npublic:  \n   static const int sun = 0;  \n   static const int mon = 1;  \n};  \n```  \n  \n A standard enum might be defined as follows:  \n  \n```cpp  \nenum day2 { sun, mon };  \n```  \n  \n and is semantically equivalent to:  \n  \n```cpp  \nstatic const int sun = 0;  \nstatic const int mon = 1;  \n```  \n  \n Managed enumerator names (*identifiers*) are not injected into the scope where the enumeration is defined; all references to the enumerators must be fully qualified (*name*`::`*identifier*).  For this reason, you cannot define an anonymous managed enum.  \n  \n The enumerators of a standard enum are strongly injected into the enclosing scope.  That is, if there is another symbol with the same name as an enumerator in the enclosing scope, the compiler will generate an error.  \n  \n In Visual C++ 2002 and Visual C++ 2003, enumerators were weakly injected (visible in the enclosing scope unless there was another identifier with the same name).  \n  \n If a standard C++ enum is defined (without **class** or `struct`), compiling with **/clr** will cause the enumeration to be compiled as a managed enum.  The enumeration still has the semantics of an unmanaged enumeration.  Note, the compiler injects an attribute, `Microsoft::VisualC::NativeEnumAttribute`, which the Visual C++ compiler recognizes, to identify a programmer's intent for the enum to be a native enum.  Other compilers will simply see the standard enum as a managed enum.  \n  \n A named, standard enum compiled with /clr will be visible in the assembly as a managed enum, and can be consumed by any other managed compiler.   However, an unnamed standard enum will not be publicly visible from the assembly.  \n  \n In Visual C++ 2002 and Visual C++ 2003, a standard enum used as the type in a function parameter:  \n  \n```cpp  \n// mcppv2_enum.cpp  \n// compile with: /clr  \nenum E { a, b };  \nvoid f(E) {System::Console::WriteLine(\"hi\");}  \n  \nint main() {  \n   E myi = b;  \n   f(myi);  \n}  \n```  \n  \n would emit the following in MSIL for the function signature:  \n  \n```  \nvoid f(int32);  \n```  \n  \n However, in current versions of the compiler, the standard enum is emitted as a managed enum with a [NativeEnumAttribute] and the following in MSIL for the function signature:  \n  \n```  \nvoid f(E)  \n```  \n  \n For more information about native enums, see [C++ Enumeration Declarations](../cpp/enumerations-cpp.md).  \n  \n For more information on CLR enums, see:  \n  \n-   [Underlying Type of an Enum](../dotnet/how-to-define-and-consume-enums-in-cpp-cli.md)  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n desc  \n  \n```cpp  \n// mcppv2_enum_2.cpp  \n// compile with: /clr  \n// managed enum  \npublic enum class m { a, b };  \n  \n// standard enum  \npublic enum n { c, d };  \n  \n// unnamed, standard enum  \npublic enum { e, f } o;  \n  \nint main()   \n{  \n   // consume managed enum  \n   m mym = m::b;  \n   System::Console::WriteLine(\"no automatic conversion to int: {0}\", mym);  \n   System::Console::WriteLine(\"convert to int: {0}\", (int)mym);  \n  \n   // consume standard enum  \n   n myn = d;  \n   System::Console::WriteLine(myn);  \n  \n   // consume standard, unnamed enum  \n   o = f;  \n   System::Console::WriteLine(o);  \n}   \n```  \n  \n **Output**  \n  \n```Output  \nno automatic conversion to int: b  \n  \nconvert to int: 1  \n  \n1  \n  \n1  \n  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}