{"nodes":[{"pos":[12,49],"content":"&lt;shared_mutex&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>shared_mutex<ph id=\"ph2\">&amp;gt;</ph> | Microsoft Docs","pos":[0,37],"source":"&lt;shared_mutex&gt; | Microsoft Docs"}]},{"pos":[2609,2629],"content":"&lt;shared_mutex&gt;","linkify":"&lt;shared_mutex&gt;","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>shared_mutex<ph id=\"ph2\">&amp;gt;</ph>","pos":[0,20],"source":"&lt;shared_mutex&gt;"}]},{"content":"The &lt;shared_mutex&gt; header provides synchronization primitives for protection of shared data that can be accessed by multiple threads.","pos":[2630,2763],"source":"The <shared_mutex> header provides synchronization primitives for protection of shared data that can be accessed by multiple threads."},{"content":"In addition to the exclusive access control provided by mutex classes, the shared mutex classes also allow shared ownership by multiple threads for non-exclusive access.","pos":[2764,2933]},{"content":"Shared mutexes can be used to control resources that can be read by several threads without causing a race condition, but must be written exclusively by a single thread.","pos":[2934,3103]},{"pos":[3110,3289],"content":"The header &lt;shared_mutex&gt; defines the classes <ph id=\"ph1\">`shared_mutex`</ph> and <ph id=\"ph2\">`shared_timed_mutex`</ph>, the template class <ph id=\"ph3\">`shared_lock`</ph>, and the template function <ph id=\"ph4\">`swap`</ph> for shared mutex support.","source":"The header <shared_mutex> defines the classes `shared_mutex` and `shared_timed_mutex`, the template class `shared_lock`, and the template function `swap` for shared mutex support."},{"content":"Classes","pos":[3296,3303]},{"content":"Description","pos":[3304,3315]},{"pos":[3356,3432],"content":"<bpt id=\"p1\">[</bpt>shared_mutex Class<ept id=\"p1\">](../standard-library/shared-mutex.md#class_shared_mutex)</ept>","source":"[shared_mutex Class](../standard-library/shared-mutex.md#class_shared_mutex)"},{"content":"A shared mutex type that can be locked exclusively by one agent or shared non-exclusively by multiple agents.","pos":[3433,3542]},{"pos":[3547,3635],"content":"<bpt id=\"p1\">[</bpt>shared_timed_mutex Class<ept id=\"p1\">](../standard-library/shared-mutex.md#class_shared_timed_mutex)</ept>","source":"[shared_timed_mutex Class](../standard-library/shared-mutex.md#class_shared_timed_mutex)"},{"content":"A shared timed mutex type that can be locked exclusively by one agent or shared non-exclusively by multiple agents.","pos":[3636,3751]},{"pos":[3756,3830],"content":"<bpt id=\"p1\">[</bpt>shared_lock Class<ept id=\"p1\">](../standard-library/shared-mutex.md#class_shared_lock)</ept>","source":"[shared_lock Class](../standard-library/shared-mutex.md#class_shared_lock)"},{"content":"A template class that wraps a shared mutex to support timed lock operations and non-exclusive sharing by multiple agents.","pos":[3831,3952]},{"content":"Functions","pos":[3960,3969]},{"content":"Description","pos":[3970,3981]},{"pos":[4024,4090],"content":"<bpt id=\"p1\">[</bpt>swap Function<ept id=\"p1\">](../standard-library/shared-mutex.md#function_swap)</ept>","source":"[swap Function](../standard-library/shared-mutex.md#function_swap)"},{"content":"Swaps the content of the shared mutex objects referenced by the function parameters.","pos":[4091,4175]},{"pos":[4185,4191],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[4431,4438],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"An instance of the class <ph id=\"ph1\">`shared_mutex`</ph> is a <bpt id=\"p1\">*</bpt>shared mutex type<ept id=\"p1\">*</ept>, a type that controls the shared ownership of a mutex within a scope.","pos":[4442,4576],"source":"An instance of the class `shared_mutex` is a *shared mutex type*, a type that controls the shared ownership of a mutex within a scope."},{"content":"A shared mutex type meets all the requirements of a mutex type, as well as members to support shared non-exclusive ownership.","pos":[4577,4702]},{"pos":[4709,4815],"content":"A shared mutex type supports the additional methods <ph id=\"ph1\">`lock_shared`</ph>, <ph id=\"ph2\">`unlock_shared`</ph>, and <ph id=\"ph3\">`try_lock_shared`</ph>:","source":"A shared mutex type supports the additional methods `lock_shared`, `unlock_shared`, and `try_lock_shared`:"},{"pos":[4825,4931],"content":"The <ph id=\"ph1\">`lock_shared`</ph> method blocks the calling thread until the thread obtains shared ownership of the mutex.","source":"The `lock_shared` method blocks the calling thread until the thread obtains shared ownership of the mutex."},{"pos":[4941,5034],"content":"The <ph id=\"ph1\">`unlock_shared`</ph> method releases shared ownership of the mutex held by the calling thread.","source":"The `unlock_shared` method releases shared ownership of the mutex held by the calling thread."},{"content":"The <ph id=\"ph1\">`try_lock_shared`</ph> method tries to obtain shared ownership of the mutex without blocking.","pos":[5044,5136],"source":"The `try_lock_shared` method tries to obtain shared ownership of the mutex without blocking."},{"content":"Its return type is convertible to <ph id=\"ph1\">`bool`</ph> and is <ph id=\"ph2\">`true`</ph> if the method obtains ownership, but is otherwise <ph id=\"ph3\">`false`</ph>.","pos":[5137,5250],"source":" Its return type is convertible to `bool` and is `true` if the method obtains ownership, but is otherwise `false`."},{"pos":[5257,5406],"content":"The class <ph id=\"ph1\">`shared_timed_mutex`</ph> is a <bpt id=\"p1\">*</bpt>shared timed mutex type<ept id=\"p1\">*</ept>, a type that meets the requirements of both a shared mutex type and a timed mutex type.","source":"The class `shared_timed_mutex` is a *shared timed mutex type*, a type that meets the requirements of both a shared mutex type and a timed mutex type."},{"pos":[5413,5521],"content":"A shared timed mutex type supports the additional methods <ph id=\"ph1\">`try_lock_shared_for`</ph> and <ph id=\"ph2\">`try_lock_shared_until`</ph>:","source":"A shared timed mutex type supports the additional methods `try_lock_shared_for` and `try_lock_shared_until`:"},{"content":"The <ph id=\"ph1\">`try_lock_shared_for`</ph> method attempts to obtain shared ownership of the mutex until the duration specified by the parameter has passed.","pos":[5531,5670],"source":"The `try_lock_shared_for` method attempts to obtain shared ownership of the mutex until the duration specified by the parameter has passed."},{"content":"If the duration is not positive, the method is equivalent to <ph id=\"ph1\">`try_lock_shared`</ph>.","pos":[5671,5750],"source":" If the duration is not positive, the method is equivalent to `try_lock_shared`."},{"content":"The method does not return within the duration specified unless shared ownership is obtained.","pos":[5751,5844]},{"content":"Its return value is <ph id=\"ph1\">`true`</ph> if the method obtains ownership, but is otherwise <ph id=\"ph2\">`false`</ph>.","pos":[5845,5930],"source":" Its return value is `true` if the method obtains ownership, but is otherwise `false`."},{"content":"The <ph id=\"ph1\">`try_lock_shared_until`</ph> method attempts to obtain shared ownership of the mutex until the specified absolute time has passed.","pos":[5940,6069],"source":"The `try_lock_shared_until` method attempts to obtain shared ownership of the mutex until the specified absolute time has passed."},{"content":"If the specified time has already passed, the method is equivalent to <ph id=\"ph1\">`try_lock_shared`</ph>.","pos":[6070,6158],"source":" If the specified time has already passed, the method is equivalent to `try_lock_shared`."},{"content":"The method does not return before the time specified unless shared ownership is obtained.","pos":[6159,6248]},{"content":"Its return value is <ph id=\"ph1\">`true`</ph> if the method obtains ownership, but is otherwise <ph id=\"ph2\">`false`</ph>.","pos":[6249,6334],"source":" Its return value is `true` if the method obtains ownership, but is otherwise `false`."},{"content":"The <ph id=\"ph1\">`shared_lock`</ph> template class extends support for timed locking and transfer of ownership to a shared mutex.","pos":[6341,6452],"source":"The `shared_lock` template class extends support for timed locking and transfer of ownership to a shared mutex."},{"content":"Ownership of the mutex may be obtained at or after construction, and may be transferred to another <ph id=\"ph1\">`shared_lock`</ph> object.","pos":[6453,6573],"source":" Ownership of the mutex may be obtained at or after construction, and may be transferred to another `shared_lock` object."},{"content":"Objects of type <ph id=\"ph1\">`shared_lock`</ph> can be moved, but not copied.","pos":[6574,6633],"source":" Objects of type `shared_lock` can be moved, but not copied."},{"pos":[6641,6919],"content":"[!WARNING]\n The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in <shared_mutex> should not be used with any ConcRT types or functions.","leadings":["","> "],"nodes":[{"content":" The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in <shared_mutex> should not be used with any ConcRT types or functions.","pos":[11,276],"nodes":[{"content":"The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP).","pos":[1,174]},{"content":"The types defined in &lt;shared_mutex&gt; should not be used with any ConcRT types or functions.","pos":[175,265],"source":" The types defined in <shared_mutex> should not be used with any ConcRT types or functions."}]}]},{"pos":[6928,6935],"content":"Classes","linkify":"Classes","nodes":[{"content":"Classes","pos":[0,7]}]},{"pos":[6946,6998],"content":"<bpt id=\"p1\">&lt;a name=\"class_shared_mutex\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> shared_mutex Class","linkify":"<a name=\"class_shared_mutex\"></a> shared_mutex Class","source":"<a name=\"class_shared_mutex\"></a> shared_mutex Class"},{"pos":[7002,7088],"content":"Class <ph id=\"ph1\">`shared_mutex`</ph> implements a non-recursive mutex with shared ownership semantics.","source":"Class `shared_mutex` implements a non-recursive mutex with shared ownership semantics."},{"pos":[7094,7600],"content":"class shared_mutex { public: shared_mutex(); ~shared_mutex(); shared_mutex(const shared_mutex&amp;) = delete; shared_mutex&amp; operator=(const shared_mutex&amp;) = delete; // Exclusive ownership void lock(); // blocking bool try_lock(); void unlock(); // Shared ownership void lock_shared(); // blocking bool try_lock_shared(); void unlock_shared(); // Getters typedef void** native_handle_type; // implementation defined native_handle_type native_handle(); };","source":"class shared_mutex {\n   public:\n   shared_mutex();\n   ~shared_mutex();\n   shared_mutex(const shared_mutex&) = delete;\n   shared_mutex& operator=(const shared_mutex&) = delete;\n   // Exclusive ownership\n   void lock();\n   // blocking\n   bool try_lock();\n   void unlock();\n   // Shared ownership\n   void lock_shared();\n   // blocking\n   bool try_lock_shared();\n   void unlock_shared();\n   // Getters\n   typedef void** native_handle_type; // implementation defined\n   native_handle_type native_handle();\n   };"},{"pos":[7611,7675],"content":"<bpt id=\"p1\">&lt;a name=\"class_shared_timed_mutex\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> shared_timed_mutex Class","linkify":"<a name=\"class_shared_timed_mutex\"></a> shared_timed_mutex Class","source":"<a name=\"class_shared_timed_mutex\"></a> shared_timed_mutex Class"},{"pos":[7679,7821],"content":"Class <ph id=\"ph1\">`shared_timed_mutex`</ph> implements a non-recursive mutex with shared ownership semantics that meets the requirements of a timed mutex type.","source":"Class `shared_timed_mutex` implements a non-recursive mutex with shared ownership semantics that meets the requirements of a timed mutex type."},{"content":"class shared_timed_mutex { public: shared_timed_mutex(); ~shared_timed_mutex(); shared_timed_mutex(const shared_timed_mutex&amp;) = delete; shared_timed_mutex&amp; operator=(const shared_timed_mutex&amp;) = delete; // Exclusive ownership void lock(); // blocking bool try_lock(); template <ph id=\"ph1\">\\&lt;</ph>class Rep, class Period&gt;","pos":[7827,8160],"source":"class shared_timed_mutex {\n   public:\n   shared_timed_mutex();\n   ~shared_timed_mutex();\n   shared_timed_mutex(const shared_timed_mutex&) = delete;\n   shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n   // Exclusive ownership\n   void lock();\n   // blocking\n   bool try_lock();\n   template \\<class Rep, class Period>"},{"content":"bool try_lock_for(const chrono::duration<ph id=\"ph1\">\\&lt;</ph>Rep, Period&gt;&amp; rel_time); template <ph id=\"ph2\">\\&lt;</ph>class Clock, class Duration&gt;","pos":[8166,8275],"source":"   bool try_lock_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>"},{"content":"bool try_lock_until(const chrono::time_point<ph id=\"ph1\">\\&lt;</ph>Clock, Duration&gt;&amp; abs_time); void unlock(); // Shared ownership void lock_shared(); // blocking bool try_lock_shared(); template <ph id=\"ph2\">\\&lt;</ph>class Rep, class Period&gt;","pos":[8281,8500],"source":"   bool try_lock_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock();\n   // Shared ownership\n   void lock_shared();\n   // blocking\n   bool try_lock_shared();\n   template \\<class Rep, class Period>"},{"content":"bool try_lock_shared_for(const chrono::duration<ph id=\"ph1\">\\&lt;</ph>Rep, Period&gt;&amp; rel_time); template <ph id=\"ph2\">\\&lt;</ph>class Clock, class Duration&gt;","pos":[8506,8622],"source":"   bool try_lock_shared_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>"},{"content":"bool try_lock_shared_until(const chrono::time_point<ph id=\"ph1\">\\&lt;</ph>Clock, Duration&gt;&amp; abs_time); void unlock_shared(); };","pos":[8628,8740],"source":"   bool try_lock_shared_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock_shared();\n   };"},{"pos":[8751,8801],"content":"<bpt id=\"p1\">&lt;a name=\"class_shared_lock\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> shared_lock Class","linkify":"<a name=\"class_shared_lock\"></a> shared_lock Class","source":"<a name=\"class_shared_lock\"></a> shared_lock Class"},{"content":"Template class <ph id=\"ph1\">`shared_lock`</ph> controls the shared ownership of a shared mutex object within a scope.","pos":[8805,8904],"source":"Template class `shared_lock` controls the shared ownership of a shared mutex object within a scope."},{"content":"The template parameter must be a shared mutex type.","pos":[8905,8956]},{"content":"class shared_lock { public: typedef Mutex mutex_type; shared_lock() noexcept; explicit shared_lock(mutex_type&amp; m); // blocking shared_lock(mutex_type&amp; m, defer_lock_t) noexcept; shared_lock(mutex_type&amp; m, try_to_lock_t); shared_lock(mutex_type&amp; m, adopt_lock_t); template <ph id=\"ph1\">\\&lt;</ph>class Clock, class Duration&gt;","pos":[8962,9291],"source":"class shared_lock {\n   public:\n   typedef Mutex mutex_type;\n   shared_lock() noexcept;\n   explicit shared_lock(mutex_type& m);\n   // blocking\n   shared_lock(mutex_type& m, defer_lock_t) noexcept;\n   shared_lock(mutex_type& m, try_to_lock_t);\n   shared_lock(mutex_type& m, adopt_lock_t);\n   template \\<class Clock, class Duration>"},{"content":"shared_lock(mutex_type&amp; m, const chrono::time_point<ph id=\"ph1\">\\&lt;</ph>Clock, Duration&gt;&amp; abs_time); template <ph id=\"ph2\">\\&lt;</ph>class Rep, class Period&gt;","pos":[9297,9420],"source":"   shared_lock(mutex_type& m,\n   const chrono::time_point\\<Clock, Duration>& abs_time);\n   template \\<class Rep, class Period>"},{"content":"shared_lock(mutex_type&amp; m, const chrono::duration<ph id=\"ph1\">\\&lt;</ph>Rep, Period&gt;&amp; rel_time); ~shared_lock(); shared_lock(shared_lock const&amp;) = delete; shared_lock&amp; operator=(shared_lock const&amp;) = delete; shared_lock(shared_lock&amp;&amp; u) noexcept; shared_lock&amp; operator=(shared_lock&amp;&amp; u) noexcept; void lock(); // blocking bool try_lock(); template <ph id=\"ph2\">\\&lt;</ph>class Rep, class Period&gt;","pos":[9426,9809],"source":"   shared_lock(mutex_type& m,\n   const chrono::duration\\<Rep, Period>& rel_time);\n   ~shared_lock();\n   shared_lock(shared_lock const&) = delete;\n   shared_lock& operator=(shared_lock const&) = delete;\n   shared_lock(shared_lock&& u) noexcept;\n   shared_lock& operator=(shared_lock&& u) noexcept;\n   void lock();\n   // blocking\n   bool try_lock();\n   template \\<class Rep, class Period>"},{"content":"bool try_lock_for(const chrono::duration<ph id=\"ph1\">\\&lt;</ph>Rep, Period&gt;&amp; rel_time); template <ph id=\"ph2\">\\&lt;</ph>class Clock, class Duration&gt;","pos":[9815,9924],"source":"   bool try_lock_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>"},{"content":"bool try_lock_until(const chrono::time_point<ph id=\"ph1\">\\&lt;</ph>Clock, Duration&gt;&amp; abs_time); void unlock(); // Setters void swap(shared_lock&amp; u) noexcept; mutex_type<bpt id=\"p1\">*</bpt> release() noexcept; // Getters bool owns_lock() const noexcept; explicit operator bool () const noexcept; mutex_type<ept id=\"p1\">*</ept> mutex() const noexcept; private: mutex_type* pm; // exposition only bool owns; // exposition only };","pos":[9930,10333],"source":"   bool try_lock_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock();\n   // Setters\n   void swap(shared_lock& u) noexcept;\n   mutex_type* release() noexcept;\n   // Getters\n   bool owns_lock() const noexcept;\n   explicit operator bool () const noexcept;\n   mutex_type* mutex() const noexcept;\n   private:\n   mutex_type* pm; // exposition only\n   bool owns; // exposition only\n   };"},{"pos":[10342,10351],"content":"Functions","linkify":"Functions","nodes":[{"content":"Functions","pos":[0,9]}]},{"pos":[10362,10404],"content":"<bpt id=\"p1\">&lt;a name=\"function_swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> swap Function","linkify":"<a name=\"function_swap\"></a> swap Function","source":"<a name=\"function_swap\"></a> swap Function"},{"pos":[10408,10440],"content":"Swaps the <ph id=\"ph1\">`shared_lock`</ph> objects.","source":"Swaps the `shared_lock` objects."},{"content":"Exchanges the content of two <ph id=\"ph1\">`shared_lock`</ph> objects.","pos":[10552,10603],"source":"Exchanges the content of two `shared_lock` objects."},{"content":"Effectively the same as <ph id=\"ph1\">`x``.swap(``y``)`</ph>.","pos":[10604,10646],"source":" Effectively the same as `x``.swap(``y``)`."},{"pos":[10655,10667],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[10671,10697],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> &lt;shared_mutex&gt;","source":"**Header:** <shared_mutex>"},{"pos":[10704,10722],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[10731,10739],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Header Files Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-header-files.md)</ept><ph id=\"ph1\"> </ph>","pos":[10743,10826],"source":"[Header Files Reference](../standard-library/cpp-standard-library-header-files.md) "},{"content":"<bpt id=\"p1\"> [</bpt><ph id=\"ph1\">\\&lt;</ph>mutex&gt;<ept id=\"p1\">](../standard-library/mutex.md)</ept>","pos":[10829,10870],"source":" [\\<mutex>](../standard-library/mutex.md)"}],"content":"---\ntitle: \"&lt;shared_mutex&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"<shared_mutex>\"\n  - \"shared_mutex/std::swap\"\n  - \"shared_mutex/std::shared_lock\"\n  - \"shared_mutex/std::shared_lock::shared_lock\"\n  - \"shared_mutex/std::shared_lock::operator=\"\n  - \"shared_mutex/std::shared_lock::operator =\"\n  - \"shared_mutex/std::shared_lock::lock\"\n  - \"shared_mutex/std::shared_lock::try_lock\"\n  - \"shared_mutex/std::shared_lock::try_lock_for\"\n  - \"shared_mutex/std::shared_lock::try_lock_until\"\n  - \"shared_mutex/std::shared_lock::unlock\"\n  - \"shared_mutex/std::shared_lock::swap\"\n  - \"shared_mutex/std::shared_lock::release\"\n  - \"shared_mutex/std::shared_lock::owns_lock\"\n  - \"shared_mutex/std::shared_lock::operator bool\"\n  - \"shared_mutex/std::shared_lock::mutex\"\n  - \"shared_mutex/std::shared_mutex\"\n  - \"shared_mutex/std::shared_mutex::native_handle_type\"\n  - \"shared_mutex/std::shared_mutex::shared_mutex\"\n  - \"shared_mutex/std::shared_mutex::operator=\"\n  - \"shared_mutex/std::shared_mutex::operator =\"\n  - \"shared_mutex/std::shared_mutex::lock\"\n  - \"shared_mutex/std::shared_mutex::try_lock\"\n  - \"shared_mutex/std::shared_mutex::unlock\"\n  - \"shared_mutex/std::shared_mutex::lock_shared\"\n  - \"shared_mutex/std::shared_mutex::try_lock_shared\"\n  - \"shared_mutex/std::shared_mutex::unlock_shared\"\n  - \"shared_mutex/std::shared_mutex::native_handle\"\n  - \"shared_mutex/std::shared_timed_mutex\"\n  - \"shared_mutex/std::shared_timed_mutex::shared_timed_mutex\"\n  - \"shared_mutex/std::shared_timed_mutex::operator=\"\n  - \"shared_mutex/std::shared_timed_mutex::operator =\"\n  - \"shared_mutex/std::shared_timed_mutex::lock\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock_for\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock_until\"\n  - \"shared_mutex/std::shared_timed_mutex::unlock\"\n  - \"shared_mutex/std::shared_timed_mutex::lock_shared\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock_shared\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock_shared_for\"\n  - \"shared_mutex/std::shared_timed_mutex::try_lock_shared_until\"\n  - \"shared_mutex/std::shared_timed_mutex::unlock_shared\"\ndev_langs: \n  - \"C++\"\nms.assetid: 0b37a97d-ee5d-4050-b29f-09db9f76beb3\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;shared_mutex&gt;\nThe <shared_mutex> header provides synchronization primitives for protection of shared data that can be accessed by multiple threads. In addition to the exclusive access control provided by mutex classes, the shared mutex classes also allow shared ownership by multiple threads for non-exclusive access. Shared mutexes can be used to control resources that can be read by several threads without causing a race condition, but must be written exclusively by a single thread.  \n  \n The header <shared_mutex> defines the classes `shared_mutex` and `shared_timed_mutex`, the template class `shared_lock`, and the template function `swap` for shared mutex support.  \n  \n|Classes|Description|  \n|-------------|-----------------|  \n|[shared_mutex Class](../standard-library/shared-mutex.md#class_shared_mutex)|A shared mutex type that can be locked exclusively by one agent or shared non-exclusively by multiple agents.|  \n|[shared_timed_mutex Class](../standard-library/shared-mutex.md#class_shared_timed_mutex)|A shared timed mutex type that can be locked exclusively by one agent or shared non-exclusively by multiple agents.|  \n|[shared_lock Class](../standard-library/shared-mutex.md#class_shared_lock)|A template class that wraps a shared mutex to support timed lock operations and non-exclusive sharing by multiple agents.|  \n  \n|Functions|Description|  \n|---------------|-----------------|  \n|[swap Function](../standard-library/shared-mutex.md#function_swap)|Swaps the content of the shared mutex objects referenced by the function parameters.|  \n  \n## Syntax  \n  \n```cpp\nnamespace std {\n    class shared_mutex;\n    class shared_timed_mutex;\n    template <class Mutex>  \nclass shared_lock;\n    template <class Mutex>  \nvoid swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;\n}\n```  \n  \n## Remarks  \n An instance of the class `shared_mutex` is a *shared mutex type*, a type that controls the shared ownership of a mutex within a scope. A shared mutex type meets all the requirements of a mutex type, as well as members to support shared non-exclusive ownership.  \n  \n A shared mutex type supports the additional methods `lock_shared`, `unlock_shared`, and `try_lock_shared`:  \n  \n-   The `lock_shared` method blocks the calling thread until the thread obtains shared ownership of the mutex.  \n  \n-   The `unlock_shared` method releases shared ownership of the mutex held by the calling thread.  \n  \n-   The `try_lock_shared` method tries to obtain shared ownership of the mutex without blocking. Its return type is convertible to `bool` and is `true` if the method obtains ownership, but is otherwise `false`.  \n  \n The class `shared_timed_mutex` is a *shared timed mutex type*, a type that meets the requirements of both a shared mutex type and a timed mutex type.  \n  \n A shared timed mutex type supports the additional methods `try_lock_shared_for` and `try_lock_shared_until`:  \n  \n-   The `try_lock_shared_for` method attempts to obtain shared ownership of the mutex until the duration specified by the parameter has passed. If the duration is not positive, the method is equivalent to `try_lock_shared`. The method does not return within the duration specified unless shared ownership is obtained. Its return value is `true` if the method obtains ownership, but is otherwise `false`.  \n  \n-   The `try_lock_shared_until` method attempts to obtain shared ownership of the mutex until the specified absolute time has passed. If the specified time has already passed, the method is equivalent to `try_lock_shared`. The method does not return before the time specified unless shared ownership is obtained. Its return value is `true` if the method obtains ownership, but is otherwise `false`.  \n  \n The `shared_lock` template class extends support for timed locking and transfer of ownership to a shared mutex. Ownership of the mutex may be obtained at or after construction, and may be transferred to another `shared_lock` object. Objects of type `shared_lock` can be moved, but not copied.  \n  \n> [!WARNING]\n>  The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in <shared_mutex> should not be used with any ConcRT types or functions.  \n  \n## Classes  \n  \n###  <a name=\"class_shared_mutex\"></a> shared_mutex Class  \n Class `shared_mutex` implements a non-recursive mutex with shared ownership semantics.  \n  \nclass shared_mutex {\n   public:\n   shared_mutex();\n   ~shared_mutex();\n   shared_mutex(const shared_mutex&) = delete;\n   shared_mutex& operator=(const shared_mutex&) = delete;\n   // Exclusive ownership\n   void lock();\n   // blocking\n   bool try_lock();\n   void unlock();\n   // Shared ownership\n   void lock_shared();\n   // blocking\n   bool try_lock_shared();\n   void unlock_shared();\n   // Getters\n   typedef void** native_handle_type; // implementation defined\n   native_handle_type native_handle();\n   };  \n  \n###  <a name=\"class_shared_timed_mutex\"></a> shared_timed_mutex Class  \n Class `shared_timed_mutex` implements a non-recursive mutex with shared ownership semantics that meets the requirements of a timed mutex type.  \n  \nclass shared_timed_mutex {\n   public:\n   shared_timed_mutex();\n   ~shared_timed_mutex();\n   shared_timed_mutex(const shared_timed_mutex&) = delete;\n   shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n   // Exclusive ownership\n   void lock();\n   // blocking\n   bool try_lock();\n   template \\<class Rep, class Period>  \n   bool try_lock_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>  \n   bool try_lock_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock();\n   // Shared ownership\n   void lock_shared();\n   // blocking\n   bool try_lock_shared();\n   template \\<class Rep, class Period>  \n   bool try_lock_shared_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>  \n   bool try_lock_shared_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock_shared();\n   };  \n  \n###  <a name=\"class_shared_lock\"></a> shared_lock Class  \n Template class `shared_lock` controls the shared ownership of a shared mutex object within a scope. The template parameter must be a shared mutex type.  \n  \nclass shared_lock {\n   public:\n   typedef Mutex mutex_type;\n   shared_lock() noexcept;\n   explicit shared_lock(mutex_type& m);\n   // blocking\n   shared_lock(mutex_type& m, defer_lock_t) noexcept;\n   shared_lock(mutex_type& m, try_to_lock_t);\n   shared_lock(mutex_type& m, adopt_lock_t);\n   template \\<class Clock, class Duration>  \n   shared_lock(mutex_type& m,\n   const chrono::time_point\\<Clock, Duration>& abs_time);\n   template \\<class Rep, class Period>  \n   shared_lock(mutex_type& m,\n   const chrono::duration\\<Rep, Period>& rel_time);\n   ~shared_lock();\n   shared_lock(shared_lock const&) = delete;\n   shared_lock& operator=(shared_lock const&) = delete;\n   shared_lock(shared_lock&& u) noexcept;\n   shared_lock& operator=(shared_lock&& u) noexcept;\n   void lock();\n   // blocking\n   bool try_lock();\n   template \\<class Rep, class Period>  \n   bool try_lock_for(const chrono::duration\\<Rep, Period>& rel_time);\n   template \\<class Clock, class Duration>  \n   bool try_lock_until(const chrono::time_point\\<Clock, Duration>& abs_time);\n   void unlock();\n   // Setters\n   void swap(shared_lock& u) noexcept;\n   mutex_type* release() noexcept;\n   // Getters\n   bool owns_lock() const noexcept;\n   explicit operator bool () const noexcept;\n   mutex_type* mutex() const noexcept;\n   private:\n   mutex_type* pm; // exposition only\n   bool owns; // exposition only\n   };  \n  \n## Functions  \n  \n###  <a name=\"function_swap\"></a> swap Function  \n Swaps the `shared_lock` objects.  \n  \n```cpp\ntemplate <class Mutex>\nvoid swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;\n```  \n  \n Exchanges the content of two `shared_lock` objects. Effectively the same as `x``.swap(``y``)`.  \n  \n## Requirements  \n **Header:** <shared_mutex>  \n  \n **Namespace:** std  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [\\<mutex>](../standard-library/mutex.md)\n\n\n\n"}