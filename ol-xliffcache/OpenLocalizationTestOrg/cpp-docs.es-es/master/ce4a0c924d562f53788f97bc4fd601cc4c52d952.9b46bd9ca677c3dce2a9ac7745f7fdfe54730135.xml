{"nodes":[{"pos":[12,45],"content":"Namespaces (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Namespaces (C++) | Microsoft Docs","pos":[0,33]}]},{"content":"Namespaces (C++)","pos":[727,743]},{"content":"A namespace is a declarative region that provides a scope to the identifiers (the names of types, functions, variables, etc) inside it.","pos":[744,879]},{"content":"Namespaces are used to organize code into logical groups and to prevent name collisions that can occur especially when your code base includes multiple libraries.","pos":[880,1042]},{"content":"All identifiers at namespace scope are visible to one another without qualification.","pos":[1043,1127]},{"content":"Identifiers outside the namespace can access the members by using the fully qualified name for each identifier, for example <ph id=\"ph1\">`std::vector&lt;std::string&gt; vec;`</ph>, or else by a <bpt id=\"p1\">[</bpt>using Declaration<ept id=\"p1\">](../cpp/using-declaration.md)</ept> for a single identifier (<ph id=\"ph2\">`using std::string`</ph>), or a <bpt id=\"p2\">[</bpt>using Directive<ept id=\"p2\">](../cpp/namespaces-cpp.md#using_directives)</ept> for all the identifiers in the namespace (<ph id=\"ph3\">`using namespace std;`</ph>).","pos":[1128,1526],"source":" Identifiers outside the namespace can access the members by using the fully qualified name for each identifier, for example `std::vector<std::string> vec;`, or else by a [using Declaration](../cpp/using-declaration.md) for a single identifier (`using std::string`), or a [using Directive](../cpp/namespaces-cpp.md#using_directives) for all the identifiers in the namespace (`using namespace std;`)."},{"content":"Code in header files should always use the fully qualified namespace name.","pos":[1527,1601]},{"content":"The following example shows a namespace declaration and three ways that code outside the namespace can accesses their members.","pos":[1608,1734]},{"content":"Use the fully qualified name:","pos":[1919,1948]},{"content":"Use a using declaration to bring one identifier into scope:","pos":[2054,2113]},{"content":"Use a using directive to bring everything in the namespace into scope:","pos":[2224,2294]},{"pos":[2445,2461],"content":"using directives"},{"content":"The <ph id=\"ph1\">`using`</ph> directive allows all the names in a <bpt id=\"p1\">**</bpt>namespace<ept id=\"p1\">**</ept> to be used without the <bpt id=\"p2\">*</bpt>namespace-name<ept id=\"p2\">*</ept> as an explicit qualifier.","pos":[2465,2592],"source":"The `using` directive allows all the names in a **namespace** to be used without the *namespace-name* as an explicit qualifier."},{"content":"Use a using directive in an implementation file (i.e. *.cpp) if you are using several different identifiers in a namespace; if you are just using one or two identifiers, then consider a using declaration to only bring those identifiers into scope and not all the identifiers in the namespace.","pos":[2593,2885]},{"content":"If a local variable has the same name as a namespace variable, the namespace variable is hidden.","pos":[2886,2982]},{"content":"It is an error to have a namespace variable with the same name as a global variable.","pos":[2983,3067]},{"pos":[3075,3202],"content":"[!NOTE]\n A using directive can be placed at the top of a .cpp file (at file scope), or inside a class or function definition.","leadings":["","> "],"nodes":[{"content":"A using directive can be placed at the top of a .cpp file (at file scope), or inside a class or function definition.","pos":[9,125]}]},{"content":"In general, avoid putting using directives in header files (*.h) because any file that includes that header will bring everything in the namespace into scope, which can cause name hiding and name collision problems that are very difficult to debug.","pos":[3213,3461]},{"content":"Always use fully qualified names in a header file.","pos":[3462,3512]},{"content":"If those names get too long, you can use a namespace alias to shorten them.","pos":[3513,3588]},{"content":"(See below.)","pos":[3589,3601]},{"content":"Declaring namespaces and namespace members","pos":[3610,3652]},{"content":"Typically, you declare a namespace in a header file.","pos":[3656,3708]},{"content":"If your function implementations are in a separate file, then qualify the function names, as in this example.","pos":[3709,3818]},{"content":"Function implementations in contosodata.cpp should use the fully qualified name, even if you place a using directive at the top of the file:","pos":[3953,4093]},{"content":"A namespace can be declared in multiple blocks in a single file, and in multiple files.","pos":[4338,4425]},{"content":"The compiler joins the parts together during preprocessing and the resulting namespace contains all the members declared in all the parts.","pos":[4426,4564]},{"content":"An example of this is the std namespace which is declared in each of the header files in the standard library.","pos":[4565,4675]},{"content":"Members of a named namespace can be defined outside the namespace in which they are declared by explicit qualification of the name being defined.","pos":[4682,4827]},{"content":"However, the definition must appear after the point of declaration in a namespace that encloses the declaration's namespace.","pos":[4828,4952]},{"content":"For example:","pos":[4953,4965]},{"content":"This error can occur when namespace members are declared across multiple header files, and you have not included those headers in the correct order.","pos":[5251,5399]},{"content":"The global namespace","pos":[5408,5428]},{"content":"If an identifier is not declared in an explicit namespace, it is part of the implicit global namespace.","pos":[5432,5535]},{"content":"In general, try to avoid making declarations at global scope when possible, except for the entry point <bpt id=\"p1\">[</bpt>main Function<ept id=\"p1\">](../c-language/main-function-and-program-execution.md)</ept>, which is required to be in the global namespace.","pos":[5536,5758],"source":" In general, try to avoid making declarations at global scope when possible, except for the entry point [main Function](../c-language/main-function-and-program-execution.md), which is required to be in the global namespace."},{"content":"To explicitly qualify a global identifier, use the scope resolution operator with no name, as in <ph id=\"ph1\">`::SomeFunction(x);`</ph>.","pos":[5759,5877],"source":" To explicitly qualify a global identifier, use the scope resolution operator with no name, as in `::SomeFunction(x);`."},{"content":"This will differentiate the identifier from anything with the same name in any other namespace, and it will also help to make your code easier for others to understand.","pos":[5878,6046]},{"content":"The std namespace","pos":[6055,6072]},{"pos":[6076,6191],"content":"All C++ standard library types and functions are declared in the <ph id=\"ph1\">`std`</ph> namespace or namespaces nested inside <ph id=\"ph2\">`std`</ph>.","source":"All C++ standard library types and functions are declared in the `std` namespace or namespaces nested inside `std`."},{"content":"Nested namespaces","pos":[6200,6217]},{"content":"Namespaces may be nested.","pos":[6221,6246]},{"content":"An ordinary nested namespace has unqualified access to its parentâ€™s members, but the parent members do not have unqualified access to the nested namespace (unless it is declared as inline), as shown in the following example:","pos":[6247,6471]},{"content":"Ordinary nested namespaces can be used to encapsulate internal implementation details that are not part of the public interface of the parent namespace.","pos":[6744,6896]},{"content":"Inline namespaces (C++ 11)","pos":[6905,6931]},{"content":"In contrast to an ordinary nested namespace, members of an inline namespace are treated as members of the parent namespace.","pos":[6935,7058]},{"content":"This characteristic enables argument dependent lookup on overloaded functions to work on functions that have overloads in a parent and a nested inline namespace.","pos":[7059,7220]},{"content":"It also enables you to declare a specialization in a parent namespace for a template that is declared in the inline namespace.","pos":[7221,7347]},{"content":"The following example shows how external code binds to the inline namespace by default:","pos":[7348,7435]},{"content":"The following example shows how you can declare a specialization in a parent of a template that is declared in an inline namespace:","pos":[7996,8127]},{"content":"You can use inline namespaces as a versioning mechanism to manage changes to the public interface of a library.","pos":[8375,8486]},{"content":"For example, you can create a single parent namespace, and encapsulate each version of the interface in its own namespace nested inside the parent.","pos":[8487,8634]},{"content":"The namespace that holds the most recent or preferred version is qualified as inline, and is therefore exposed as if it were a direct member of the parent namespace.","pos":[8635,8800]},{"content":"Client code that invokes the Parent::Class will automatically bind to the new code.","pos":[8801,8884]},{"content":"Clients that prefer to use the older version can still access it by using the fully qualified path to the nested namespace that has that code.","pos":[8885,9027]},{"content":"The inline keyword must be applied to the first declaration of the namespace in a compilation unit.","pos":[9034,9133]},{"content":"The following example shows two versions of an interface, each in a nested namespace.","pos":[9140,9225]},{"content":"The <ph id=\"ph1\">`v_20`</ph> namespace has some modification from the <ph id=\"ph2\">`v_10`</ph> interface and is marked as inline.","pos":[9226,9319],"source":" The `v_20` namespace has some modification from the `v_10` interface and is marked as inline."},{"content":"Client code that uses the new library and calls <ph id=\"ph1\">`Contoso::Funcs::Add`</ph> will invoke the v_20 version.","pos":[9320,9419],"source":" Client code that uses the new library and calls `Contoso::Funcs::Add` will invoke the v_20 version."},{"content":"Code that attempts to call <ph id=\"ph1\">`Contoso::Funcs::Divide`</ph> will now get a compile time error.","pos":[9420,9506],"source":" Code that attempts to call `Contoso::Funcs::Divide` will now get a compile time error."},{"content":"If they really need that function, they can still access the <ph id=\"ph1\">`v_10`</ph> version by explicitly calling <ph id=\"ph2\">`Contoso::v_10::Funcs::Divide`</ph>.","pos":[9507,9636],"source":" If they really need that function, they can still access the `v_10` version by explicitly calling `Contoso::v_10::Funcs::Divide`."},{"pos":[10391,10408],"content":"Namespace aliases"},{"content":"Namespace names need to be unique, which means that often they should not be too short.","pos":[10412,10499]},{"content":"If the length of a name makes code difficult to read, or is tedious to type in a header file where using directives canâ€™t be used, then you can make a namespace alias which serves as an abbreviation for the actual name.","pos":[10500,10719]},{"content":"For example:","pos":[10720,10732]},{"content":"anonymous or unnamed namespaces","pos":[10897,10928]},{"content":"You can create an explicit namespace but not give it a name:","pos":[10932,10992]},{"content":"This is called an unnamed or anonymous namespace and it is useful when you want to make variable declarations invisible to code in other files (i.e. give them internal linkage) without having to create a named namespace.","pos":[11058,11278]},{"content":"All code in the same file can see the identifiers in an unnamed namespace but the identifiers, along with the namespace itself, are not visible outside that fileâ€”or more precisely outside the translation unit.","pos":[11279,11488]},{"content":"See Also","pos":[11497,11505]},{"content":"Declarations and Definitions","pos":[11510,11538]}],"content":"---\ntitle: \"Namespaces (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"namespace_CPP\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"namespaces [C++], C++\"\n  - \"namespaces [C++]\"\n  - \"namespaces [C++], global\"\n  - \"global namespace\"\n  - \"Visual C++, namespaces\"\nms.assetid: d1a5a9ab-1cad-47e6-a82d-385bb77f4188\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Namespaces (C++)\nA namespace is a declarative region that provides a scope to the identifiers (the names of types, functions, variables, etc) inside it. Namespaces are used to organize code into logical groups and to prevent name collisions that can occur especially when your code base includes multiple libraries. All identifiers at namespace scope are visible to one another without qualification. Identifiers outside the namespace can access the members by using the fully qualified name for each identifier, for example `std::vector<std::string> vec;`, or else by a [using Declaration](../cpp/using-declaration.md) for a single identifier (`using std::string`), or a [using Directive](../cpp/namespaces-cpp.md#using_directives) for all the identifiers in the namespace (`using namespace std;`). Code in header files should always use the fully qualified namespace name.  \n  \n The following example shows a namespace declaration and three ways that code outside the namespace can accesses their members.  \n  \n```cpp  \nnamespace ContosoData  \n{      \n    class ObjectManager   \n    {  \n    public:  \n        void DoSomething() {}  \n    };  \n    void Func(ObjectManager) {}  \n}  \n```  \n  \n Use the fully qualified name:  \n  \n```cpp  \nContosoData::ObjectManager mgr;  \nmgr.DoSomething();  \nContosoData::Func(mgr);  \n```  \n  \n Use a using declaration to bring one identifier into scope:  \n  \n```cpp  \nusing WidgetsUnlimited::ObjectManager;  \nObjectManager mgr;  \nmgr.DoSomething();  \n  \n```  \n  \n Use a using directive to bring everything in the namespace into scope:  \n  \n```cpp  \nusing namespace WidgetsUnlimited;  \nObjectManager mgr;  \nmgr.DoSomething();  \nFunc(mgr);  \n  \n```  \n  \n## <a id=\"using_directives\"></a> using directives  \n The `using` directive allows all the names in a **namespace** to be used without the *namespace-name* as an explicit qualifier. Use a using directive in an implementation file (i.e. *.cpp) if you are using several different identifiers in a namespace; if you are just using one or two identifiers, then consider a using declaration to only bring those identifiers into scope and not all the identifiers in the namespace. If a local variable has the same name as a namespace variable, the namespace variable is hidden. It is an error to have a namespace variable with the same name as a global variable.  \n  \n> [!NOTE]\n>  A using directive can be placed at the top of a .cpp file (at file scope), or inside a class or function definition.  \n>   \n>  In general, avoid putting using directives in header files (*.h) because any file that includes that header will bring everything in the namespace into scope, which can cause name hiding and name collision problems that are very difficult to debug. Always use fully qualified names in a header file. If those names get too long, you can use a namespace alias to shorten them. (See below.)  \n  \n## Declaring namespaces and namespace members  \n Typically, you declare a namespace in a header file. If your function implementations are in a separate file, then qualify the function names, as in this example.  \n  \n```cpp  \n//contosoData.h   \n#pragma once  \nnamespace ContosoDataServer  \n{  \n    void Foo();  \n    int Bar();  \n  \n}  \n```  \n  \n Function implementations in contosodata.cpp should use the fully qualified name, even if you place a using directive at the top of the file:  \n  \n```cpp  \n#include \"contosodata.h\"  \nusing namespace ContosoDataServer;   \n  \nvoid ContosoDataServer::Foo()  \n{  \n   //no qualification because using directive above  \n   Bar();   \n}  \n  \nint ContosoDataServer::Bar(){return 0;}  \n```  \n  \n A namespace can be declared in multiple blocks in a single file, and in multiple files. The compiler joins the parts together during preprocessing and the resulting namespace contains all the members declared in all the parts. An example of this is the std namespace which is declared in each of the header files in the standard library.  \n  \n Members of a named namespace can be defined outside the namespace in which they are declared by explicit qualification of the name being defined. However, the definition must appear after the point of declaration in a namespace that encloses the declaration's namespace. For example:  \n  \n```cpp  \n// defining_namespace_members.cpp  \n// C2039 expected  \nnamespace V {  \n        void f();  \n    }  \n  \n    void V::f() { }        // ok  \n    void V::g() { }        // C2039, g() is not yet a member of V  \n  \n    namespace V {  \n        void g();  \n    }  \n}  \n```  \n  \n This error can occur when namespace members are declared across multiple header files, and you have not included those headers in the correct order.  \n  \n## The global namespace  \n If an identifier is not declared in an explicit namespace, it is part of the implicit global namespace. In general, try to avoid making declarations at global scope when possible, except for the entry point [main Function](../c-language/main-function-and-program-execution.md), which is required to be in the global namespace. To explicitly qualify a global identifier, use the scope resolution operator with no name, as in `::SomeFunction(x);`. This will differentiate the identifier from anything with the same name in any other namespace, and it will also help to make your code easier for others to understand.  \n  \n## The std namespace  \n All C++ standard library types and functions are declared in the `std` namespace or namespaces nested inside `std`.  \n  \n## Nested namespaces  \n Namespaces may be nested. An ordinary nested namespace has unqualified access to its parentâ€™s members, but the parent members do not have unqualified access to the nested namespace (unless it is declared as inline), as shown in the following example:  \n  \n```cpp  \nnamespace ContosoDataServer  \n{  \n    void Foo();   \n  \n    namespace Details  \n    {  \n        int CountImpl;  \n        void Ban() { return Foo(); }  \n    }  \n  \n    int Bar(){...};  \n    int Baz(int i) { return Details::CountImpl; }      \n  \n}  \n```  \n  \n Ordinary nested namespaces can be used to encapsulate internal implementation details that are not part of the public interface of the parent namespace.  \n  \n## Inline namespaces (C++ 11)  \n In contrast to an ordinary nested namespace, members of an inline namespace are treated as members of the parent namespace. This characteristic enables argument dependent lookup on overloaded functions to work on functions that have overloads in a parent and a nested inline namespace. It also enables you to declare a specialization in a parent namespace for a template that is declared in the inline namespace. The following example shows how external code binds to the inline namespace by default:  \n  \n```cpp  \n//Header.h  \n#include <string>  \n  \nnamespace Test  \n{  \n    namespace old_ns  \n    {  \n        std::string Func() { return std::string(\"Hello from old\"); }  \n    }  \n  \n    inline namespace new_ns  \n    {  \n        std::string Func() { return std::string(\"Hello from new\"); }  \n    }  \n}  \n  \n#include \"header.h\"  \n#include <string>  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace Test;  \n    using namespace std;  \n  \n    string s = Func();  \n    std::cout << s << std::endl; // \"Hello from new\"  \n    return 0;  \n}  \n```  \n  \n The following example shows how you can declare a specialization in a parent of a template that is declared in an inline namespace:  \n  \n```cpp  \nnamespace Parent  \n{  \n    inline namespace new_ns  \n    {  \n         template <typename T>  \n         struct C  \n         {  \n             T member;  \n         };  \n    }  \n     template<>  \n     class C<int> {};  \n}  \n  \n```  \n  \n You can use inline namespaces as a versioning mechanism to manage changes to the public interface of a library. For example, you can create a single parent namespace, and encapsulate each version of the interface in its own namespace nested inside the parent. The namespace that holds the most recent or preferred version is qualified as inline, and is therefore exposed as if it were a direct member of the parent namespace. Client code that invokes the Parent::Class will automatically bind to the new code. Clients that prefer to use the older version can still access it by using the fully qualified path to the nested namespace that has that code.  \n  \n The inline keyword must be applied to the first declaration of the namespace in a compilation unit.  \n  \n The following example shows two versions of an interface, each in a nested namespace. The `v_20` namespace has some modification from the `v_10` interface and is marked as inline. Client code that uses the new library and calls `Contoso::Funcs::Add` will invoke the v_20 version. Code that attempts to call `Contoso::Funcs::Divide` will now get a compile time error. If they really need that function, they can still access the `v_10` version by explicitly calling `Contoso::v_10::Funcs::Divide`.  \n  \n```cpp  \nnamespace Contoso  \n{  \n    namespace v_10  \n    {  \n        template <typename T>  \n        class Funcs  \n        {  \n        public:  \n            Funcs(void);  \n            T Add(T a, T b);  \n            T Subtract(T a, T b);  \n            T Multiply(T a, T b);  \n            T Divide(T a, T b);  \n        };  \n    }  \n  \n    inline namespace v_20  \n    {  \n        template <typename T>  \n        class Funcs  \n        {  \n        public:  \n            Funcs(void);  \n            T Add(T a, T b);  \n            T Subtract(T a, T b);  \n            T Multiply(T a, T b);  \n            std::vector<double> Log(double);  \n            T Accumulate(std::vector<T> nums);  \n      };  \n    }  \n}  \n  \n```  \n  \n## <a id=\"namespace_aliases\"></a> Namespace aliases  \n Namespace names need to be unique, which means that often they should not be too short. If the length of a name makes code difficult to read, or is tedious to type in a header file where using directives canâ€™t be used, then you can make a namespace alias which serves as an abbreviation for the actual name. For example:  \n  \n```cpp  \nnamespace a_very_long_namespace_name { class Foo {}; }  \nnamespace AVLNN = a_very_long_namespace_name;  \nvoid Bar(AVLNN::Foo foo){ }  \n  \n```  \n  \n## anonymous or unnamed namespaces  \n You can create an explicit namespace but not give it a name:  \n  \n```cpp  \nnamespace  \n{  \n    int MyFunc(){}  \n}  \n```  \n  \n This is called an unnamed or anonymous namespace and it is useful when you want to make variable declarations invisible to code in other files (i.e. give them internal linkage) without having to create a named namespace. All code in the same file can see the identifiers in an unnamed namespace but the identifiers, along with the namespace itself, are not visible outside that fileâ€”or more precisely outside the translation unit.  \n  \n## See Also  \n [Declarations and Definitions](declarations-and-definitions-cpp.md)\n"}