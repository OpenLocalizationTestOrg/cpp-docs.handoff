{"nodes":[{"pos":[12,38],"content":"Iterators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Iterators | Microsoft Docs","pos":[0,26]}]},{"content":"Iterators","pos":[617,626]},{"content":"An iterator is an object that can iterate over elements in an STL container and provide access to individual elements.","pos":[627,745]},{"content":"The STL containers all provide iterators so that algorithms can access their elements in a standard way without having to be concerned with the type of container the elements are stored in.","pos":[746,935]},{"content":"You can use iterators explicitly using member and global functions such as begin() and end() and operators such as ++ and -- to move forward or backward.","pos":[942,1095]},{"content":"You can also use iterators implicitly with a range-for loop or (for some iterator types) the subscript operator [].","pos":[1096,1211]},{"content":"In the STL, the beginning of a sequence or range is the first element.","pos":[1218,1288]},{"content":"The end of a sequence or range is always defined as one past the last element.","pos":[1289,1367]},{"content":"The global functions begin and end return iterators to a specified container.","pos":[1368,1445]},{"content":"The typical explicit iterator loop over all elements in a container looks like this:","pos":[1446,1530]},{"content":"The same thing can be accomplished more simply with a range-for loop:","pos":[1715,1784]},{"content":"There are five categories of iterators.","pos":[1887,1926]},{"content":"In order of increasing power, the categories are:","pos":[1927,1976]},{"content":"<bpt id=\"p1\">**</bpt>Output<ept id=\"p1\">**</ept>.","pos":[1984,1995],"source":"**Output**."},{"content":"An output iterator <ph id=\"ph1\">`X`</ph> can iterate forward over a sequence by using the ++ operator, and can write an element only once, by using the * operator.","pos":[1996,2141],"source":" An output iterator `X` can iterate forward over a sequence by using the ++ operator, and can write an element only once, by using the * operator."},{"content":"<bpt id=\"p1\">**</bpt>Input<ept id=\"p1\">**</ept>.","pos":[2149,2159],"source":"**Input**."},{"content":"An input iterator <ph id=\"ph1\">`X`</ph> can iterate forward over a sequence by using the ++ operator, and can read an element any number of times by using the * operator.","pos":[2160,2312],"source":" An input iterator `X` can iterate forward over a sequence by using the ++ operator, and can read an element any number of times by using the * operator."},{"content":"You can compare input iterators by using the ++ and != operators.","pos":[2313,2378]},{"content":"After you increment any copy of an input iterator, none of the other copies can safely be compared, dereferenced, or incremented thereafter.","pos":[2379,2519]},{"content":"<bpt id=\"p1\">**</bpt>Forward<ept id=\"p1\">**</ept>.","pos":[2527,2539],"source":"**Forward**."},{"content":"A forward iterator <ph id=\"ph1\">`X`</ph> can iterate forward over a sequence using the ++ operator and can read any element or write non-const elements any number of times by using the * operator.","pos":[2540,2718],"source":" A forward iterator `X` can iterate forward over a sequence using the ++ operator and can read any element or write non-const elements any number of times by using the * operator."},{"content":"You can access element members by using the -&gt; operator and compare forward iterators by using the == and != operators.","pos":[2719,2838],"source":" You can access element members by using the -> operator and compare forward iterators by using the == and != operators."},{"content":"You can make multiple copies of a forward iterator, each of which can be dereferenced and incremented independently.","pos":[2839,2955]},{"content":"A forward iterator that is initialized without reference to any container is called a null forward iterator.","pos":[2956,3064]},{"content":"Null forward iterators always compare equal.","pos":[3065,3109]},{"content":"Bidirectional.","pos":[3119,3133]},{"content":"A bidirectional iterator <ph id=\"ph1\">`X`</ph> can take the place of a forward iterator.","pos":[3134,3204],"source":" A bidirectional iterator `X` can take the place of a forward iterator."},{"content":"You can, however, also decrement a bidirectional iterator, as in --<ph id=\"ph1\">`X`</ph>, <ph id=\"ph2\">`X`</ph>--, or (<ph id=\"ph3\">`V`</ph> = *<ph id=\"ph4\">`X`</ph>--).","pos":[3205,3302],"source":" You can, however, also decrement a bidirectional iterator, as in --`X`, `X`--, or (`V` = *`X`--)."},{"content":"You can access element members and compare bidirectional iterators in the same way as forward iterators.","pos":[3303,3407]},{"content":"<bpt id=\"p1\">**</bpt>Random access<ept id=\"p1\">**</ept>.","pos":[3415,3433],"source":"**Random access**."},{"content":"A random-access iterator <ph id=\"ph1\">`X`</ph> can take the place of a bidirectional iterator.","pos":[3434,3510],"source":" A random-access iterator `X` can take the place of a bidirectional iterator."},{"content":"With a random access iterator you can use the subscript operator [] to access elements.","pos":[3511,3598]},{"content":"You can use the +, -, += and -= operators to move forward or backward a specified number of elements and to calculate the distance between iterators.","pos":[3599,3748]},{"content":"You can compare bidirectional iterators by using ==, !=, <ph id=\"ph1\">\\&lt;</ph>, &gt;, <ph id=\"ph2\">\\&lt;</ph>=, and &gt;=.","pos":[3749,3825],"source":" You can compare bidirectional iterators by using ==, !=, \\<, >, \\<=, and >=."},{"content":"All iterators can be assigned or copied.","pos":[3832,3872]},{"content":"They are assumed to be lightweight objects and are often passed and returned by value, not by reference.","pos":[3873,3977]},{"content":"Note also that none of the operations previously described can throw an exception when performed on a valid iterator.","pos":[3978,4095]},{"content":"The hierarchy of iterator categories can be summarized by showing three sequences.","pos":[4102,4184]},{"content":"For write-only access to a sequence, you can use any of:","pos":[4185,4241]},{"content":"The right arrow means \"can be replaced by.\"","pos":[4362,4405]},{"content":"Any algorithm that calls for an output iterator should work nicely with a forward iterator, for example, but <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> the other way around.","pos":[4406,4542],"source":" Any algorithm that calls for an output iterator should work nicely with a forward iterator, for example, but *not* the other way around."},{"content":"For read-only access to a sequence, you can use any of:","pos":[4549,4604]},{"content":"An input iterator is the weakest of all categories, in this case.","pos":[4724,4789]},{"content":"Finally, for read/write access to a sequence, you can use any of:","pos":[4796,4861]},{"content":"An object pointer can always serve as a random-access iterator, so it can serve as any category of iterator if it supports the proper read/write access to the sequence it designates.","pos":[4960,5142]},{"content":"An iterator <ph id=\"ph1\">`Iterator`</ph> other than an object pointer must also define the member types required by the specialization <ph id=\"ph2\">`iterator_traits&lt;Iterator&gt;`</ph>.","pos":[5149,5294],"source":"An iterator `Iterator` other than an object pointer must also define the member types required by the specialization `iterator_traits<Iterator>`."},{"content":"Note that these requirements can be met by deriving <ph id=\"ph1\">`Iterator`</ph> from the public base class <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](../standard-library/iterator-struct.md)</ept>.","pos":[5295,5436],"source":" Note that these requirements can be met by deriving `Iterator` from the public base class [iterator](../standard-library/iterator-struct.md)."},{"content":"It is important to understand the promises and limitations of each iterator category to see how iterators are used by containers and algorithms in the STL.","pos":[5443,5598]},{"pos":[5606,5801],"content":"[!NOTE]\n You can avoid using iterators explicitly by using range-for loops. For more information, see [Loops (Modern C++)](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da).","leadings":["","> "],"nodes":[{"content":" You can avoid using iterators explicitly by using range-for loops. For more information, see [Loops (Modern C++)](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da).","pos":[8,193],"nodes":[{"content":"You can avoid using iterators explicitly by using range-for loops.","pos":[1,67]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Loops (Modern C++)<ept id=\"p1\">](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da)</ept>.","pos":[68,185],"source":" For more information, see [Loops (Modern C++)](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da)."}]}]},{"content":"now offers checked iterators and debug iterators to ensure that you do not overwrite the bounds of your container.","pos":[5859,5973]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> and <bpt id=\"p2\">[</bpt>Debug Iterator Support<ept id=\"p2\">](../standard-library/debug-iterator-support.md)</ept>.","pos":[5974,6138],"source":" For more information, see [Checked Iterators](../standard-library/checked-iterators.md) and [Debug Iterator Support](../standard-library/debug-iterator-support.md)."},{"content":"See Also","pos":[6147,6155]},{"content":"C++ Standard Library Reference","pos":[6160,6190]},{"content":"Thread Safety in the C++ Standard Library","pos":[6252,6293]}],"content":"---\ntitle: \"Iterators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"iterator conventions\"\n  - \"Standard C++ Library, iterator conventions\"\nms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Iterators\nAn iterator is an object that can iterate over elements in an STL container and provide access to individual elements. The STL containers all provide iterators so that algorithms can access their elements in a standard way without having to be concerned with the type of container the elements are stored in.  \n  \n You can use iterators explicitly using member and global functions such as begin() and end() and operators such as ++ and -- to move forward or backward. You can also use iterators implicitly with a range-for loop or (for some iterator types) the subscript operator [].  \n  \n In the STL, the beginning of a sequence or range is the first element. The end of a sequence or range is always defined as one past the last element. The global functions begin and end return iterators to a specified container. The typical explicit iterator loop over all elements in a container looks like this:  \n  \n```  \n \nvector<int> vec{ 0,1,2,3,4 };  \nfor (auto it = begin(vec);\n\nit != end(vec);\n\nit++)  \n{  // Access element using dereference operator\n    cout <<*it <<\" \";  \n}  \n```  \n  \n The same thing can be accomplished more simply with a range-for loop:  \n  \n```  \nfor (auto num : vec)  \n {  // no deference operator\n    cout <<num <<\" \";  \n }  \n```  \n  \n There are five categories of iterators. In order of increasing power, the categories are:  \n  \n- **Output**. An output iterator `X` can iterate forward over a sequence by using the ++ operator, and can write an element only once, by using the * operator.  \n  \n- **Input**. An input iterator `X` can iterate forward over a sequence by using the ++ operator, and can read an element any number of times by using the * operator. You can compare input iterators by using the ++ and != operators. After you increment any copy of an input iterator, none of the other copies can safely be compared, dereferenced, or incremented thereafter.  \n  \n- **Forward**. A forward iterator `X` can iterate forward over a sequence using the ++ operator and can read any element or write non-const elements any number of times by using the * operator. You can access element members by using the -> operator and compare forward iterators by using the == and != operators. You can make multiple copies of a forward iterator, each of which can be dereferenced and incremented independently. A forward iterator that is initialized without reference to any container is called a null forward iterator. Null forward iterators always compare equal.  \n  \n-   Bidirectional. A bidirectional iterator `X` can take the place of a forward iterator. You can, however, also decrement a bidirectional iterator, as in --`X`, `X`--, or (`V` = *`X`--). You can access element members and compare bidirectional iterators in the same way as forward iterators.  \n  \n- **Random access**. A random-access iterator `X` can take the place of a bidirectional iterator. With a random access iterator you can use the subscript operator [] to access elements. You can use the +, -, += and -= operators to move forward or backward a specified number of elements and to calculate the distance between iterators. You can compare bidirectional iterators by using ==, !=, \\<, >, \\<=, and >=.  \n  \n All iterators can be assigned or copied. They are assumed to be lightweight objects and are often passed and returned by value, not by reference. Note also that none of the operations previously described can throw an exception when performed on a valid iterator.  \n  \n The hierarchy of iterator categories can be summarized by showing three sequences. For write-only access to a sequence, you can use any of:  \n  \n```  \noutput iterator  \n -> forward iterator  \n -> bidirectional iterator  \n -> random-access iterator  \n```  \n  \n The right arrow means \"can be replaced by.\" Any algorithm that calls for an output iterator should work nicely with a forward iterator, for example, but *not* the other way around.  \n  \n For read-only access to a sequence, you can use any of:  \n  \n```  \ninput iterator  \n -> forward iterator  \n -> bidirectional iterator  \n -> random-access iterator  \n```  \n  \n An input iterator is the weakest of all categories, in this case.  \n  \n Finally, for read/write access to a sequence, you can use any of:  \n  \n```  \nforward iterator  \n -> bidirectional iterator  \n -> random-access iterator  \n```  \n  \n An object pointer can always serve as a random-access iterator, so it can serve as any category of iterator if it supports the proper read/write access to the sequence it designates.  \n  \n An iterator `Iterator` other than an object pointer must also define the member types required by the specialization `iterator_traits<Iterator>`. Note that these requirements can be met by deriving `Iterator` from the public base class [iterator](../standard-library/iterator-struct.md).  \n  \n It is important to understand the promises and limitations of each iterator category to see how iterators are used by containers and algorithms in the STL.  \n  \n> [!NOTE]\n>  You can avoid using iterators explicitly by using range-for loops. For more information, see [Loops (Modern C++)](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da).  \n  \n [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] now offers checked iterators and debug iterators to ensure that you do not overwrite the bounds of your container. For more information, see [Checked Iterators](../standard-library/checked-iterators.md) and [Debug Iterator Support](../standard-library/debug-iterator-support.md).  \n  \n## See Also  \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}