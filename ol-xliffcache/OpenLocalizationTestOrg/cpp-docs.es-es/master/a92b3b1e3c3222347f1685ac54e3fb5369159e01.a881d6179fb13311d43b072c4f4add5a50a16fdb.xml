{"nodes":[{"pos":[12,75],"content":"Explicit Overrides  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Explicit Overrides  (C++ Component Extensions) | Microsoft Docs","pos":[0,63]}]},{"content":"Explicit Overrides  (C++ Component Extensions)","pos":[622,668]},{"content":"This topic discusses how to explicitly override a member of a base class or interface.","pos":[669,755]},{"content":"A named (explicit) override should only be used to override a method with a derived method that has a different name.","pos":[756,873]},{"content":"All Runtimes","pos":[882,894]},{"content":"Syntax","pos":[900,906]},{"content":"Parameters","pos":[1123,1133]},{"content":"overriding-function-declarator","pos":[1143,1173]},{"content":"The return type, name, and argument list of the overriding function.","pos":[1178,1246]},{"content":"Note that the overriding function does not have to have the same name as the function being overridden.","pos":[1248,1351]},{"content":"type","pos":[1359,1363]},{"content":"The base type that contains a function to override.","pos":[1368,1419]},{"content":"function","pos":[1427,1435]},{"content":"A comma-delimited list of one or more function names to override.","pos":[1440,1505]},{"content":"overriding-function-definition","pos":[1513,1543]},{"content":"The function body statements that define the overriding function.","pos":[1548,1613]},{"content":"Remarks","pos":[1622,1629]},{"content":"Use explicit overrides to create an alias for a method signature, or to provide different implementations for methods witht the same signature.","pos":[1638,1781]},{"pos":[1788,1966],"content":"For information about modifying the behavior of inherited types and inherited type members, see <bpt id=\"p1\">[</bpt>Override Specifiers<ept id=\"p1\">](../windows/override-specifiers-cpp-component-extensions.md)</ept>.","source":"For information about modifying the behavior of inherited types and inherited type members, see [Override Specifiers](../windows/override-specifiers-cpp-component-extensions.md)."},{"content":"Requirements","pos":[2037,2049]},{"pos":[2053,2077],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Remarks","pos":[2163,2170]},{"pos":[2179,2336],"content":"For information about explicit overrides in native code or code compiled with <bpt id=\"p1\">**</bpt>/clr:oldSyntax<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>Explicit Overrides<ept id=\"p2\">](../cpp/explicit-overrides-cpp.md)</ept>.","source":"For information about explicit overrides in native code or code compiled with **/clr:oldSyntax**, see [Explicit Overrides](../cpp/explicit-overrides-cpp.md)."},{"content":"Requirements","pos":[2346,2358]},{"pos":[2362,2387],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[2397,2405]},{"content":"Example","pos":[2411,2418]},{"content":"The following code example shows a simple, implicit override and implementation of a member in a base interface, not using explicit overrides.","pos":[2427,2569]},{"content":"Output","pos":[2901,2907]},{"content":"Example","pos":[2964,2971]},{"content":"The following code example shows how to implement all interface members with a common signature, using explicit override syntax.","pos":[2980,3108]},{"content":"Output","pos":[3562,3568]},{"content":"Example","pos":[3670,3677]},{"content":"The following code example shows how a function override can have a different name from the function it is implementing.","pos":[3686,3806]},{"content":"Output","pos":[4122,4128]},{"content":"Example","pos":[4167,4174]},{"content":"The following code example shows an explicit interface implementation that implements a type safe collection.","pos":[4183,4292]},{"content":"See Also","pos":[4697,4705]},{"content":"Component Extensions for Runtime Platforms","pos":[4710,4752]}],"content":"---\ntitle: \"Explicit Overrides  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"overriding, override [C++]\"\nms.assetid: 4ec3eaf5-163b-4df8-8f16-7a2ec04c3d0f\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Explicit Overrides  (C++ Component Extensions)\nThis topic discusses how to explicitly override a member of a base class or interface. A named (explicit) override should only be used to override a method with a derived method that has a different name.  \n  \n## All Runtimes  \n **Syntax**  \n  \n```  \n  \n      overriding-function-declarator = type::function [,type::function] { overriding-function-definition }  \noverriding-function-declarator = function { overriding-function-definition }  \n```  \n  \n **Parameters**  \n  \n *overriding-function-declarator*  \n The return type, name, and argument list of the overriding function.  Note that the overriding function does not have to have the same name as the function being overridden.  \n  \n *type*  \n The base type that contains a function to override.  \n  \n *function*  \n A comma-delimited list of one or more function names to override.  \n  \n *overriding-function-definition*  \n The function body statements that define the overriding function.  \n  \n **Remarks**  \n  \n Use explicit overrides to create an alias for a method signature, or to provide different implementations for methods witht the same signature.  \n  \n For information about modifying the behavior of inherited types and inherited type members, see [Override Specifiers](../windows/override-specifiers-cpp-component-extensions.md).  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Remarks**  \n  \n For information about explicit overrides in native code or code compiled with **/clr:oldSyntax**, see [Explicit Overrides](../cpp/explicit-overrides-cpp.md).  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code example shows a simple, implicit override and implementation of a member in a base interface, not using explicit overrides.  \n  \n```  \n// explicit_override_1.cpp  \n// compile with: /clr  \ninterface struct I1 {  \n   virtual void f();  \n};  \n  \nref class X : public I1 {  \npublic:  \n   virtual void f() {  \n      System::Console::WriteLine(\"X::f override of I1::f\");  \n   }  \n};  \n  \nint main() {  \n   I1 ^ MyI = gcnew X;  \n   MyI -> f();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nX::f override of I1::f  \n```  \n  \n **Example**  \n  \n The following code example shows how to implement all interface members with a common signature, using explicit override syntax.  \n  \n```  \n  \n// explicit_override_2.cpp  \n// compile with: /clr  \ninterface struct I1 {  \n   virtual void f();  \n};  \n  \ninterface struct I2 {  \n   virtual void f();  \n};  \n  \nref struct X : public I1, I2 {  \n   virtual void f() = I1::f, I2::f {  \n      System::Console::WriteLine(\"X::f override of I1::f and I2::f\");  \n   }  \n};  \n  \nint main() {  \n   I1 ^ MyI = gcnew X;  \n   I2 ^ MyI2 = gcnew X;  \n   MyI -> f();  \n   MyI2 -> f();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nX::f override of I1::f and I2::f  \nX::f override of I1::f and I2::f  \n```  \n  \n **Example**  \n  \n The following code example shows how a function override can have a different name from the function it is implementing.  \n  \n```  \n// explicit_override_3.cpp  \n// compile with: /clr  \ninterface struct I1 {  \n   virtual void f();  \n};  \n  \nref class X : public I1 {  \npublic:  \n   virtual void g() = I1::f {  \n      System::Console::WriteLine(\"X::g\");  \n   }  \n};  \n  \nint main() {  \n   I1 ^ a = gcnew X;  \n   a->f();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nX::g  \n```  \n  \n **Example**  \n  \n The following code example shows an explicit interface implementation that implements a type safe collection.  \n  \n```  \n// explicit_override_4.cpp  \n// compile with: /clr /LD  \nusing namespace System;  \nref class R : ICloneable {  \n   int X;  \n  \n   virtual Object^ C() sealed = ICloneable::Clone {  \n      return this->Clone();  \n   }  \n  \npublic:  \n   R() : X(0) {}  \n   R(int x) : X(x) {}  \n  \n   virtual R^ Clone() {  \n      R^ r = gcnew R;  \n      r->X = this->X;  \n      return r;  \n   }  \n};  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}