{"nodes":[{"pos":[12,74],"content":"Exception Handling in the Concurrency Runtime | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exception Handling in the Concurrency Runtime | Microsoft Docs","pos":[0,62]}]},{"content":"Exception Handling in the Concurrency Runtime","pos":[902,947]},{"content":"The Concurrency Runtime uses C++ exception handling to communicate many kinds of errors.","pos":[948,1036]},{"content":"These errors include invalid use of the runtime, runtime errors such as failure to acquire a resource, and errors that occur in work functions that you provide to tasks and task groups.","pos":[1037,1222]},{"content":"When a task or task group throws an exception, the runtime holds that exception and marshals it to the context that waits for the task or task group to finish.","pos":[1223,1382]},{"content":"For components such as lightweight tasks and agents, the runtime does not manage exceptions for you.","pos":[1383,1483]},{"content":"In these cases, you must implement your own exception-handling mechanism.","pos":[1484,1557]},{"content":"This topic describes how the runtime handles exceptions that are thrown by tasks, task groups, lightweight tasks, and asynchronous agents, and how to respond to exceptions in your applications.","pos":[1558,1751]},{"content":"Key Points","pos":[1760,1770]},{"content":"When a task or task group throws an exception, the runtime holds that exception and marshals it to the context that waits for the task or task group to finish.","pos":[1780,1939]},{"content":"When possible, surround every call to <bpt id=\"p1\">[</bpt>concurrency::task::get<ept id=\"p1\">](reference/task-class.md#get)</ept> and <bpt id=\"p2\">[</bpt>concurrency::task::wait<ept id=\"p2\">](reference/task-class.md#wait)</ept> with a <ph id=\"ph1\">`try`/`catch`</ph> block to handle errors that you can recover from.","pos":[1949,2171],"source":"When possible, surround every call to [concurrency::task::get](reference/task-class.md#get) and [concurrency::task::wait](reference/task-class.md#wait) with a `try`/`catch` block to handle errors that you can recover from."},{"content":"The runtime terminates the app if a task throws an exception and that exception is not caught by the task, one of its continuations, or the main app.","pos":[2172,2321]},{"content":"A task-based continuation always runs; it does not matter whether the antecedent task completed successfully, threw an exception, or was canceled.","pos":[2331,2477]},{"content":"A value-based continuation does not run if the antecedent task throws or cancels.","pos":[2478,2559]},{"content":"Because task-based continuations always run, consider whether to add a task-based continuation at the end of your continuation chain.","pos":[2569,2702]},{"content":"This can help guarantee that your code observes all exceptions.","pos":[2703,2766]},{"pos":[2776,2974],"content":"The runtime throws <bpt id=\"p1\">[</bpt>concurrency::task_canceled<ept id=\"p1\">](../../parallel/concrt/reference/task-canceled-class.md)</ept> when you call <bpt id=\"p2\">[</bpt>concurrency::task::get<ept id=\"p2\">](reference/task-class.md#get)</ept> and that task is canceled.","source":"The runtime throws [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) when you call [concurrency::task::get](reference/task-class.md#get) and that task is canceled."},{"content":"The runtime does not manage exceptions for lightweight tasks and agents.","pos":[2985,3057]},{"pos":[3086,3102],"content":"In this Document"},{"content":"Tasks and Continuations","pos":[3111,3134]},{"content":"Task Groups and Parallel Algorithms","pos":[3152,3187]},{"content":"Exceptions Thrown by the Runtime","pos":[3211,3243]},{"content":"Multiple Exceptions","pos":[3263,3282]},{"content":"Cancellation","pos":[3303,3315]},{"content":"Lightweight Tasks","pos":[3340,3357]},{"content":"Asynchronous Agents","pos":[3374,3393]},{"pos":[3434,3457],"content":"Tasks and Continuations"},{"content":"This section describes how the runtime handles exceptions that are thrown by <bpt id=\"p1\">[</bpt>concurrency::task<ept id=\"p1\">](../../parallel/concrt/reference/task-class.md)</ept> objects and their continuations.","pos":[3461,3637],"source":"This section describes how the runtime handles exceptions that are thrown by [concurrency::task](../../parallel/concrt/reference/task-class.md) objects and their continuations."},{"content":"For more information about the task and continuation model, see <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.","pos":[3638,3784],"source":" For more information about the task and continuation model, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)."},{"content":"When you throw an exception in the body of a work function that you pass to a <ph id=\"ph1\">`task`</ph> object, the runtime stores that exception and marshals it to the context that calls <bpt id=\"p1\">[</bpt>concurrency::task::get<ept id=\"p1\">](reference/task-class.md#get)</ept> or <bpt id=\"p2\">[</bpt>concurrency::task::wait<ept id=\"p2\">](reference/task-class.md#wait)</ept>.","pos":[3791,4073],"source":"When you throw an exception in the body of a work function that you pass to a `task` object, the runtime stores that exception and marshals it to the context that calls [concurrency::task::get](reference/task-class.md#get) or [concurrency::task::wait](reference/task-class.md#wait)."},{"content":"The document <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept> describes task-based versus value-based continuations, but to summarize, a value-based continuation takes a parameter of type <ph id=\"ph1\">`T`</ph> and a task-based continuation takes a parameter of type <ph id=\"ph2\">`task&lt;T&gt;`</ph>.","pos":[4074,4365],"source":" The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes task-based versus value-based continuations, but to summarize, a value-based continuation takes a parameter of type `T` and a task-based continuation takes a parameter of type `task<T>`."},{"content":"If a task that throws has one or more value-based continuations, those continuations are not scheduled to run.","pos":[4366,4476]},{"content":"The following example illustrates this behavior:","pos":[4477,4525]},{"pos":[4544,4560],"content":"concrt-eh-task#1"},{"content":"A task-based continuation enables you to handle any exception that is thrown by the antecedent task.","pos":[4660,4760]},{"content":"A task-based continuation always runs; it does not matter whether the task completed successfully, threw an exception, or was canceled.","pos":[4761,4896]},{"content":"When a task throws an exception, its task-based continuations are scheduled to run.","pos":[4897,4980]},{"content":"The following example shows a task that always throws.","pos":[4981,5035]},{"content":"The task has two continuations; one is value-based and the other is task-based.","pos":[5036,5115]},{"content":"The task-based exception always runs, and therefore can catch the exception that is thrown by the antecedent task.","pos":[5116,5230]},{"content":"When the example waits for both continuations to finish, the exception is thrown again because the task exception is always thrown when <ph id=\"ph1\">`task::get`</ph> or <ph id=\"ph2\">`task::wait`</ph> is called.","pos":[5231,5405],"source":" When the example waits for both continuations to finish, the exception is thrown again because the task exception is always thrown when `task::get` or `task::wait` is called."},{"pos":[5423,5448],"content":"concrt-eh-continuations#1"},{"content":"We recommend that you use task-based continuations to catch exceptions that you are able to handle.","pos":[5548,5647]},{"content":"Because task-based continuations always run, consider whether to add a task-based continuation at the end of your continuation chain.","pos":[5648,5781]},{"content":"This can help guarantee that your code observes all exceptions.","pos":[5782,5845]},{"content":"The following example shows a basic value-based continuation chain.","pos":[5846,5913]},{"content":"The third task in the chain throws, and therefore any value-based continuations that follow it are not run.","pos":[5914,6021]},{"content":"However, the final continuation is task-based, and therefore always runs.","pos":[6022,6095]},{"content":"This final continuation handles the exception that is thrown by the third task.","pos":[6096,6175]},{"content":"We recommend that you catch the most specific exceptions that you can.","pos":[6182,6252]},{"content":"You can omit this final task-based continuation if you don’t have specific exceptions to catch.","pos":[6253,6348]},{"content":"Any exception will remain unhandled and can terminate the app.","pos":[6349,6411]},{"pos":[6429,6451],"content":"concrt-eh-task-chain#1"},{"pos":[6552,6991],"content":"[!TIP]\n You can use the [concurrency::task_completion_event::set_exception](../../parallel/concrt/reference/task-completion-event-class.md) method to associate an exception with a task completion event. The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes the [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class in greater detail.","leadings":["","> "],"nodes":[{"content":" You can use the [concurrency::task_completion_event::set_exception](../../parallel/concrt/reference/task-completion-event-class.md) method to associate an exception with a task completion event. The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes the [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class in greater detail.","pos":[7,437],"nodes":[{"content":"You can use the <bpt id=\"p1\">[</bpt>concurrency::task_completion_event::set_exception<ept id=\"p1\">](../../parallel/concrt/reference/task-completion-event-class.md)</ept> method to associate an exception with a task completion event.","pos":[1,195],"source":" You can use the [concurrency::task_completion_event::set_exception](../../parallel/concrt/reference/task-completion-event-class.md) method to associate an exception with a task completion event."},{"content":"The document <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept> describes the <bpt id=\"p2\">[</bpt>concurrency::task_completion_event<ept id=\"p2\">](../../parallel/concrt/reference/task-completion-event-class.md)</ept> class in greater detail.","pos":[196,430],"source":" The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes the [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class in greater detail."}]}]},{"content":"<bpt id=\"p1\">[</bpt>concurrency::task_canceled<ept id=\"p1\">](../../parallel/concrt/reference/task-canceled-class.md)</ept> is an important runtime exception type that relates to <ph id=\"ph1\">`task`</ph>.","pos":[6999,7146],"source":"[concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) is an important runtime exception type that relates to `task`."},{"content":"The runtime throws <ph id=\"ph1\">`task_canceled`</ph> when you call <ph id=\"ph2\">`task::get`</ph> and that task is canceled.","pos":[7147,7234],"source":" The runtime throws `task_canceled` when you call `task::get` and that task is canceled."},{"content":"(Conversely, <ph id=\"ph1\">`task::wait`</ph> returns <bpt id=\"p1\">[</bpt>task_status::canceled<ept id=\"p1\">](reference/concurrency-namespace-enums.md#task_group_status)</ept> and does not throw.) You can catch and handle this exception from a task-based continuation or when you call <ph id=\"ph2\">`task::get`</ph>.","pos":[7235,7474],"source":" (Conversely, `task::wait` returns [task_status::canceled](reference/concurrency-namespace-enums.md#task_group_status) and does not throw.) You can catch and handle this exception from a task-based continuation or when you call `task::get`."},{"content":"For more information about task cancellation, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept>.","pos":[7475,7579],"source":" For more information about task cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md)."},{"pos":[7588,7760],"content":"[!CAUTION]\n Never throw `task_canceled` from your code. Call [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) instead.","leadings":["","> "],"nodes":[{"content":" Never throw `task_canceled` from your code. Call [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) instead.","pos":[11,170],"nodes":[{"content":"Never throw <ph id=\"ph1\">`task_canceled`</ph> from your code.","pos":[1,44],"source":" Never throw `task_canceled` from your code."},{"content":"Call <bpt id=\"p1\">[</bpt>concurrency::cancel_current_task<ept id=\"p1\">](reference/concurrency-namespace-functions.md#cancel_current_task)</ept> instead.","pos":[45,159],"source":" Call [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) instead."}]}]},{"content":"The runtime terminates the app if a task throws an exception and that exception is not caught by the task, one of its continuations, or the main app.","pos":[7767,7916]},{"content":"If your application crashes, you can configure Visual Studio to break when C++ exceptions are thrown.","pos":[7917,8018]},{"content":"After you diagnose the location of the unhandled exception, use a task-based continuation to handle it.","pos":[8019,8122]},{"pos":[8129,8267],"content":"The section <bpt id=\"p1\">[</bpt>Exceptions Thrown by the Runtime<ept id=\"p1\">](#runtime)</ept> in this document describes how to work with runtime exceptions in greater detail.","source":"The section [Exceptions Thrown by the Runtime](#runtime) in this document describes how to work with runtime exceptions in greater detail."},{"pos":[8274,8287],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[8324,8359],"content":"Task Groups and Parallel Algorithms"},{"content":"This section describes how the runtime handles exceptions that are thrown by task groups.","pos":[8364,8453]},{"content":"This section also applies to parallel algorithms such as <bpt id=\"p1\">[</bpt>concurrency::parallel_for<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for)</ept>, because these algorithms build on task groups.","pos":[8454,8645],"source":" This section also applies to parallel algorithms such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), because these algorithms build on task groups."},{"pos":[8653,9096],"content":"[!CAUTION]\n Make sure that you understand the effects that exceptions have on dependent tasks. For recommended practices about how to use exception handling with tasks or parallel algorithms, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library topic.","leadings":["","> "],"nodes":[{"content":" Make sure that you understand the effects that exceptions have on dependent tasks. For recommended practices about how to use exception handling with tasks or parallel algorithms, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library topic.","pos":[11,441],"nodes":[{"content":"Make sure that you understand the effects that exceptions have on dependent tasks.","pos":[1,83]},{"content":"For recommended practices about how to use exception handling with tasks or parallel algorithms, see the <bpt id=\"p1\">[</bpt>Understand how Cancellation and Exception Handling Affect Object Destruction<ept id=\"p1\">](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction)</ept> section in the Best Practices in the Parallel Patterns Library topic.","pos":[84,430],"source":" For recommended practices about how to use exception handling with tasks or parallel algorithms, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library topic."}]}]},{"content":"For more information about task groups, see <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.","pos":[9103,9229],"source":"For more information about task groups, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)."},{"content":"For more information about parallel algorithms, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[9230,9350],"source":" For more information about parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"content":"When you throw an exception in the body of a work function that you pass to a <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> or <bpt id=\"p2\">[</bpt>concurrency::structured_task_group<ept id=\"p2\">](../../parallel/concrt/reference/structured-task-group-class.md)</ept> object, the runtime stores that exception and marshals it to the context that calls <bpt id=\"p3\">[</bpt>concurrency::task_group::wait<ept id=\"p3\">](reference/task-group-class.md#wait)</ept>, <bpt id=\"p4\">[</bpt>concurrency::structured_task_group::wait<ept id=\"p4\">](reference/structured-task-group-class.md#wait)</ept>, <bpt id=\"p5\">[</bpt>concurrency::task_group::run_and_wait<ept id=\"p5\">](reference/task-group-class.md#run_and_wait)</ept>, or <bpt id=\"p6\">[</bpt>concurrency::structured_task_group::run_and_wait<ept id=\"p6\">](reference/structured-task-group-class.md#run_and_wait)</ept>.","pos":[9355,10032],"source":"When you throw an exception in the body of a work function that you pass to a [concurrency::task_group](reference/task-group-class.md) or [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) object, the runtime stores that exception and marshals it to the context that calls [concurrency::task_group::wait](reference/task-group-class.md#wait), [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait), [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait), or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait)."},{"content":"The runtime also stops all active tasks that are in the task group (including those in child task groups) and discards any tasks that have not yet started.","pos":[10033,10188]},{"content":"The following example shows the basic structure of a work function that throws an exception.","pos":[10196,10288]},{"content":"The example uses a <ph id=\"ph1\">`task_group`</ph> object to print the values of two <ph id=\"ph2\">`point`</ph> objects in parallel.","pos":[10289,10383],"source":" The example uses a `task_group` object to print the values of two `point` objects in parallel."},{"content":"The <ph id=\"ph1\">`print_point`</ph> work function prints the values of a <ph id=\"ph2\">`point`</ph> object to the console.","pos":[10384,10469],"source":" The `print_point` work function prints the values of a `point` object to the console."},{"content":"The work function throws an exception if the input value is <ph id=\"ph1\">`NULL`</ph>.","pos":[10470,10537],"source":" The work function throws an exception if the input value is `NULL`."},{"content":"The runtime stores this exception and marshals it to the context that calls <ph id=\"ph1\">`task_group::wait`</ph>.","pos":[10538,10633],"source":" The runtime stores this exception and marshals it to the context that calls `task_group::wait`."},{"pos":[10651,10673],"content":"concrt-eh-task-group#1"},{"content":"This example produces the following output.","pos":[10773,10816]},{"pos":[10893,11115],"content":"For a complete example that uses exception handling in a task group, see <bpt id=\"p1\">[</bpt>How to: Use Exception Handling to Break from a Parallel Loop<ept id=\"p1\">](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md)</ept>.","source":"For a complete example that uses exception handling in a task group, see [How to: Use Exception Handling to Break from a Parallel Loop](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md)."},{"pos":[11122,11135],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[11168,11200],"content":"Exceptions Thrown by the Runtime"},{"content":"An exception can result from a call to the runtime.","pos":[11204,11255]},{"content":"Most exception types, except for <bpt id=\"p1\">[</bpt>concurrency::task_canceled<ept id=\"p1\">](../../parallel/concrt/reference/task-canceled-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::operation_timed_out<ept id=\"p2\">](../../parallel/concrt/reference/operation-timed-out-class.md)</ept>, indicate a programming error.","pos":[11256,11505],"source":" Most exception types, except for [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) and [concurrency::operation_timed_out](../../parallel/concrt/reference/operation-timed-out-class.md), indicate a programming error."},{"content":"These errors are typically unrecoverable, and therefore should not be caught or handled by application code.","pos":[11506,11614]},{"content":"We suggest that you only catch or handle unrecoverable errors in your application code when you need to diagnose programming errors.","pos":[11615,11747]},{"content":"However, understanding the exception types that are defined by the runtime can help you diagnose programming errors.","pos":[11748,11864]},{"content":"The exception handling mechanism is the same for exceptions that are thrown by the runtime as exceptions that are thrown by work functions.","pos":[11871,12010]},{"content":"For example, the <bpt id=\"p1\">[</bpt>concurrency::receive<ept id=\"p1\">](reference/concurrency-namespace-functions.md#receive)</ept> function throws <ph id=\"ph1\">`operation_timed_out`</ph> when it does not receive a message in the specified time period.","pos":[12011,12207],"source":" For example, the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function throws `operation_timed_out` when it does not receive a message in the specified time period."},{"content":"If <ph id=\"ph1\">`receive`</ph> throws an exception in a work function that you pass to a task group, the runtime stores that exception and marshals it to the context that calls <ph id=\"ph2\">`task_group::wait`</ph>, <ph id=\"ph3\">`structured_task_group::wait`</ph>, <ph id=\"ph4\">`task_group::run_and_wait`</ph>, or <ph id=\"ph5\">`structured_task_group::run_and_wait`</ph>.","pos":[12208,12487],"source":" If `receive` throws an exception in a work function that you pass to a task group, the runtime stores that exception and marshals it to the context that calls `task_group::wait`, `structured_task_group::wait`, `task_group::run_and_wait`, or `structured_task_group::run_and_wait`."},{"content":"The following example uses the <bpt id=\"p1\">[</bpt>concurrency::parallel_invoke<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm to run two tasks in parallel.","pos":[12494,12657],"source":"The following example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to run two tasks in parallel."},{"content":"The first task waits five seconds and then sends a message to a message buffer.","pos":[12658,12737]},{"content":"The second task uses the <ph id=\"ph1\">`receive`</ph> function to wait three seconds to receive a message from the same message buffer.","pos":[12738,12854],"source":" The second task uses the `receive` function to wait three seconds to receive a message from the same message buffer."},{"content":"The <ph id=\"ph1\">`receive`</ph> function throws <ph id=\"ph2\">`operation_timed_out`</ph> if it does not receive the message in the time period.","pos":[12855,12961],"source":" The `receive` function throws `operation_timed_out` if it does not receive the message in the time period."},{"pos":[12979,12999],"content":"concrt-eh-time-out#1"},{"content":"This example produces the following output.","pos":[13099,13142]},{"content":"To prevent abnormal termination of your application, make sure that your code handles exceptions when it calls into the runtime.","pos":[13197,13325]},{"content":"Also handle exceptions when you call into external code that uses the Concurrency Runtime, for example, a third-party library.","pos":[13326,13452]},{"pos":[13459,13472],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[13506,13525],"content":"Multiple Exceptions"},{"content":"If a task or parallel algorithm receives multiple exceptions, the runtime marshals only one of those exceptions to the calling context.","pos":[13529,13664]},{"content":"The runtime does not guarantee which exception it marshals.","pos":[13665,13724]},{"content":"The following example uses the <ph id=\"ph1\">`parallel_for`</ph> algorithm to print numbers to the console.","pos":[13731,13819],"source":"The following example uses the `parallel_for` algorithm to print numbers to the console."},{"content":"It throws an exception if the input value is less than some minimum value or greater than some maximum value.","pos":[13820,13929]},{"content":"In this example, multiple work functions can throw an exception.","pos":[13930,13994]},{"pos":[14012,14032],"content":"concrt-eh-multiple#1"},{"content":"The following shows sample output for this example.","pos":[14132,14183]},{"pos":[14281,14294],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[14332,14344],"content":"Cancellation"},{"content":"Not all exceptions indicate an error.","pos":[14348,14385]},{"content":"For example, a search algorithm might use exception handling to stop its associated task when it finds the result.","pos":[14386,14500]},{"content":"For more information about how to use cancellation mechanisms in your code, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](../../parallel/concrt/cancellation-in-the-ppl.md)</ept>.","pos":[14501,14657],"source":" For more information about how to use cancellation mechanisms in your code, see [Cancellation in the PPL](../../parallel/concrt/cancellation-in-the-ppl.md)."},{"pos":[14664,14677],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[14707,14724],"content":"Lightweight Tasks"},{"content":"A lightweight task is a task that you schedule directly from a <bpt id=\"p1\">[</bpt>concurrency::Scheduler<ept id=\"p1\">](../../parallel/concrt/reference/scheduler-class.md)</ept> object.","pos":[14728,14875],"source":"A lightweight task is a task that you schedule directly from a [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) object."},{"content":"Lightweight tasks carry less overhead than ordinary tasks.","pos":[14876,14934]},{"content":"However, the runtime does not catch exceptions that are thrown by lightweight tasks.","pos":[14935,15019]},{"content":"Instead, the exception is caught by the unhandled exception handler, which by default terminates the process.","pos":[15020,15129]},{"content":"Therefore, use an appropriate error-handling mechanism in your application.","pos":[15130,15205]},{"content":"For more information about lightweight tasks, see <bpt id=\"p1\">[</bpt>Task Scheduler<ept id=\"p1\">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.","pos":[15206,15334],"source":" For more information about lightweight tasks, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md)."},{"pos":[15341,15354],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[15386,15405],"content":"Asynchronous Agents"},{"content":"Like lightweight tasks, the runtime does not manage exceptions that are thrown by asynchronous agents.","pos":[15409,15511]},{"content":"The following example shows one way to handle exceptions in a class that derives from <bpt id=\"p1\">[</bpt>concurrency::agent<ept id=\"p1\">](../../parallel/concrt/reference/agent-class.md)</ept>.","pos":[15518,15673],"source":"The following example shows one way to handle exceptions in a class that derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md)."},{"content":"This example defines the <ph id=\"ph1\">`points_agent`</ph> class.","pos":[15674,15720],"source":" This example defines the `points_agent` class."},{"content":"The <ph id=\"ph1\">`points_agent::run`</ph> method reads <ph id=\"ph2\">`point`</ph> objects from the message buffer and prints them to the console.","pos":[15721,15829],"source":" The `points_agent::run` method reads `point` objects from the message buffer and prints them to the console."},{"content":"The <ph id=\"ph1\">`run`</ph> method throws an exception if it receives a <ph id=\"ph2\">`NULL`</ph> pointer.","pos":[15830,15899],"source":" The `run` method throws an exception if it receives a `NULL` pointer."},{"content":"The <ph id=\"ph1\">`run`</ph> method surrounds all work in a <ph id=\"ph2\">`try`-`catch`</ph> block.","pos":[15906,15967],"source":"The `run` method surrounds all work in a `try`-`catch` block."},{"content":"The <ph id=\"ph1\">`catch`</ph> block stores the exception in a message buffer.","pos":[15968,16027],"source":" The `catch` block stores the exception in a message buffer."},{"content":"The application checks whether the agent encountered an error by reading from this buffer after the agent finishes.","pos":[16028,16143]},{"pos":[16161,16179],"content":"concrt-eh-agents#1"},{"content":"This example produces the following output.","pos":[16279,16322]},{"content":"Because the <ph id=\"ph1\">`try`-`catch`</ph> block exists outside the <ph id=\"ph2\">`while`</ph> loop, the agent ends processing when it encounters the first error.","pos":[16463,16589],"source":"Because the `try`-`catch` block exists outside the `while` loop, the agent ends processing when it encounters the first error."},{"content":"If the <ph id=\"ph1\">`try`-`catch`</ph> block was inside the <ph id=\"ph2\">`while`</ph> loop, the agent would continue after an error occurs.","pos":[16590,16693],"source":" If the `try`-`catch` block was inside the `while` loop, the agent would continue after an error occurs."},{"content":"This example stores exceptions in a message buffer so that another component can monitor the agent for errors as it runs.","pos":[16700,16821]},{"content":"This example uses a <bpt id=\"p1\">[</bpt>concurrency::single_assignment<ept id=\"p1\">](../../parallel/concrt/reference/single-assignment-class.md)</ept> object to store the error.","pos":[16822,16961],"source":" This example uses a [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) object to store the error."},{"content":"In the case where an agent handles multiple exceptions, the <ph id=\"ph1\">`single_assignment`</ph> class stores only the first message that is passed to it.","pos":[16962,17099],"source":" In the case where an agent handles multiple exceptions, the `single_assignment` class stores only the first message that is passed to it."},{"content":"To store only the last exception, use the <bpt id=\"p1\">[</bpt>concurrency::overwrite_buffer<ept id=\"p1\">](../../parallel/concrt/reference/overwrite-buffer-class.md)</ept> class.","pos":[17100,17239],"source":" To store only the last exception, use the [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) class."},{"content":"To store all exceptions, use the <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept> class.","pos":[17240,17348],"source":" To store all exceptions, use the [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) class."},{"content":"For more information about these message blocks, see <bpt id=\"p1\">[</bpt>Asynchronous Message Blocks<ept id=\"p1\">](../../parallel/concrt/asynchronous-message-blocks.md)</ept>.","pos":[17349,17486],"source":" For more information about these message blocks, see [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)."},{"pos":[17493,17613],"content":"For more information about asynchronous agents, see <bpt id=\"p1\">[</bpt>Asynchronous Agents<ept id=\"p1\">](../../parallel/concrt/asynchronous-agents.md)</ept>.","source":"For more information about asynchronous agents, see [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)."},{"pos":[17620,17633],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[17666,17673],"content":"Summary"},{"pos":[17677,17690],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"See Also","pos":[17699,17707]},{"content":"Concurrency Runtime","pos":[17712,17731]},{"content":"Task Parallelism","pos":[17784,17800]},{"content":"Parallel Algorithms","pos":[17870,17889]},{"content":"Cancellation in the PPL","pos":[17942,17965]},{"content":"Task Scheduler","pos":[18000,18014]},{"content":"Asynchronous Agents","pos":[18082,18101]}],"content":"---\ntitle: \"Exception Handling in the Concurrency Runtime | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"lightweight tasks, exception handling [Concurrency Runtime]\"\n  - \"exception handling [Concurrency Runtime]\"\n  - \"structured task groups, exception handling [Concurrency Runtime]\"\n  - \"agents, exception handling [Concurrency Runtime]\"\n  - \"task groups, exception handling [Concurrency Runtime]\"\nms.assetid: 4d1494fb-3089-4f4b-8cfb-712aa67d7a7a\ncaps.latest.revision: 29\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Exception Handling in the Concurrency Runtime\nThe Concurrency Runtime uses C++ exception handling to communicate many kinds of errors. These errors include invalid use of the runtime, runtime errors such as failure to acquire a resource, and errors that occur in work functions that you provide to tasks and task groups. When a task or task group throws an exception, the runtime holds that exception and marshals it to the context that waits for the task or task group to finish. For components such as lightweight tasks and agents, the runtime does not manage exceptions for you. In these cases, you must implement your own exception-handling mechanism. This topic describes how the runtime handles exceptions that are thrown by tasks, task groups, lightweight tasks, and asynchronous agents, and how to respond to exceptions in your applications.  \n  \n## Key Points  \n  \n-   When a task or task group throws an exception, the runtime holds that exception and marshals it to the context that waits for the task or task group to finish.  \n  \n-   When possible, surround every call to [concurrency::task::get](reference/task-class.md#get) and [concurrency::task::wait](reference/task-class.md#wait) with a `try`/`catch` block to handle errors that you can recover from. The runtime terminates the app if a task throws an exception and that exception is not caught by the task, one of its continuations, or the main app.  \n  \n-   A task-based continuation always runs; it does not matter whether the antecedent task completed successfully, threw an exception, or was canceled. A value-based continuation does not run if the antecedent task throws or cancels.  \n  \n-   Because task-based continuations always run, consider whether to add a task-based continuation at the end of your continuation chain. This can help guarantee that your code observes all exceptions.  \n  \n-   The runtime throws [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) when you call [concurrency::task::get](reference/task-class.md#get) and that task is canceled.  \n\n  \n-   The runtime does not manage exceptions for lightweight tasks and agents.  \n  \n##  <a name=\"top\"></a> In this Document  \n  \n- [Tasks and Continuations](#tasks)  \n  \n- [Task Groups and Parallel Algorithms](#task_groups)  \n  \n- [Exceptions Thrown by the Runtime](#runtime)  \n  \n- [Multiple Exceptions](#multiple)  \n  \n- [Cancellation](#cancellation)  \n  \n- [Lightweight Tasks](#lwts)  \n  \n- [Asynchronous Agents](#agents)  \n  \n##  <a name=\"tasks\"></a> Tasks and Continuations  \n This section describes how the runtime handles exceptions that are thrown by [concurrency::task](../../parallel/concrt/reference/task-class.md) objects and their continuations. For more information about the task and continuation model, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md).  \n  \n When you throw an exception in the body of a work function that you pass to a `task` object, the runtime stores that exception and marshals it to the context that calls [concurrency::task::get](reference/task-class.md#get) or [concurrency::task::wait](reference/task-class.md#wait). The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes task-based versus value-based continuations, but to summarize, a value-based continuation takes a parameter of type `T` and a task-based continuation takes a parameter of type `task<T>`. If a task that throws has one or more value-based continuations, those continuations are not scheduled to run. The following example illustrates this behavior:  \n\n  \n [!code-cpp[concrt-eh-task#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_1.cpp)]  \n  \n A task-based continuation enables you to handle any exception that is thrown by the antecedent task. A task-based continuation always runs; it does not matter whether the task completed successfully, threw an exception, or was canceled. When a task throws an exception, its task-based continuations are scheduled to run. The following example shows a task that always throws. The task has two continuations; one is value-based and the other is task-based. The task-based exception always runs, and therefore can catch the exception that is thrown by the antecedent task. When the example waits for both continuations to finish, the exception is thrown again because the task exception is always thrown when `task::get` or `task::wait` is called.  \n  \n [!code-cpp[concrt-eh-continuations#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_2.cpp)]  \n  \n We recommend that you use task-based continuations to catch exceptions that you are able to handle. Because task-based continuations always run, consider whether to add a task-based continuation at the end of your continuation chain. This can help guarantee that your code observes all exceptions. The following example shows a basic value-based continuation chain. The third task in the chain throws, and therefore any value-based continuations that follow it are not run. However, the final continuation is task-based, and therefore always runs. This final continuation handles the exception that is thrown by the third task.  \n  \n We recommend that you catch the most specific exceptions that you can. You can omit this final task-based continuation if you don’t have specific exceptions to catch. Any exception will remain unhandled and can terminate the app.  \n  \n [!code-cpp[concrt-eh-task-chain#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_3.cpp)]  \n  \n> [!TIP]\n>  You can use the [concurrency::task_completion_event::set_exception](../../parallel/concrt/reference/task-completion-event-class.md) method to associate an exception with a task completion event. The document [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md) describes the [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class in greater detail.  \n  \n\n [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) is an important runtime exception type that relates to `task`. The runtime throws `task_canceled` when you call `task::get` and that task is canceled. (Conversely, `task::wait` returns [task_status::canceled](reference/concurrency-namespace-enums.md#task_group_status) and does not throw.) You can catch and handle this exception from a task-based continuation or when you call `task::get`. For more information about task cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md).  \n\n  \n> [!CAUTION]\n>  Never throw `task_canceled` from your code. Call [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) instead.  \n  \n The runtime terminates the app if a task throws an exception and that exception is not caught by the task, one of its continuations, or the main app. If your application crashes, you can configure Visual Studio to break when C++ exceptions are thrown. After you diagnose the location of the unhandled exception, use a task-based continuation to handle it.  \n  \n The section [Exceptions Thrown by the Runtime](#runtime) in this document describes how to work with runtime exceptions in greater detail.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"task_groups\"></a> Task Groups and Parallel Algorithms  \n\n This section describes how the runtime handles exceptions that are thrown by task groups. This section also applies to parallel algorithms such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), because these algorithms build on task groups.  \n  \n> [!CAUTION]\n>  Make sure that you understand the effects that exceptions have on dependent tasks. For recommended practices about how to use exception handling with tasks or parallel algorithms, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library topic.  \n  \n For more information about task groups, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md). For more information about parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n\n When you throw an exception in the body of a work function that you pass to a [concurrency::task_group](reference/task-group-class.md) or [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) object, the runtime stores that exception and marshals it to the context that calls [concurrency::task_group::wait](reference/task-group-class.md#wait), [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait), [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait), or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait). The runtime also stops all active tasks that are in the task group (including those in child task groups) and discards any tasks that have not yet started.  \n\n  \n The following example shows the basic structure of a work function that throws an exception. The example uses a `task_group` object to print the values of two `point` objects in parallel. The `print_point` work function prints the values of a `point` object to the console. The work function throws an exception if the input value is `NULL`. The runtime stores this exception and marshals it to the context that calls `task_group::wait`.  \n  \n [!code-cpp[concrt-eh-task-group#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_4.cpp)]  \n  \n This example produces the following output.  \n  \n```Output  \nX = 15, Y = 30Caught exception: point is NULL.  \n```  \n  \n For a complete example that uses exception handling in a task group, see [How to: Use Exception Handling to Break from a Parallel Loop](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"runtime\"></a> Exceptions Thrown by the Runtime  \n An exception can result from a call to the runtime. Most exception types, except for [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) and [concurrency::operation_timed_out](../../parallel/concrt/reference/operation-timed-out-class.md), indicate a programming error. These errors are typically unrecoverable, and therefore should not be caught or handled by application code. We suggest that you only catch or handle unrecoverable errors in your application code when you need to diagnose programming errors. However, understanding the exception types that are defined by the runtime can help you diagnose programming errors.  \n  \n The exception handling mechanism is the same for exceptions that are thrown by the runtime as exceptions that are thrown by work functions. For example, the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function throws `operation_timed_out` when it does not receive a message in the specified time period. If `receive` throws an exception in a work function that you pass to a task group, the runtime stores that exception and marshals it to the context that calls `task_group::wait`, `structured_task_group::wait`, `task_group::run_and_wait`, or `structured_task_group::run_and_wait`.  \n  \n The following example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to run two tasks in parallel. The first task waits five seconds and then sends a message to a message buffer. The second task uses the `receive` function to wait three seconds to receive a message from the same message buffer. The `receive` function throws `operation_timed_out` if it does not receive the message in the time period.  \n  \n [!code-cpp[concrt-eh-time-out#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_5.cpp)]  \n  \n This example produces the following output.  \n  \n```Output  \nThe operation timed out.  \n```  \n  \n To prevent abnormal termination of your application, make sure that your code handles exceptions when it calls into the runtime. Also handle exceptions when you call into external code that uses the Concurrency Runtime, for example, a third-party library.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"multiple\"></a> Multiple Exceptions  \n If a task or parallel algorithm receives multiple exceptions, the runtime marshals only one of those exceptions to the calling context. The runtime does not guarantee which exception it marshals.  \n  \n The following example uses the `parallel_for` algorithm to print numbers to the console. It throws an exception if the input value is less than some minimum value or greater than some maximum value. In this example, multiple work functions can throw an exception.  \n  \n [!code-cpp[concrt-eh-multiple#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_6.cpp)]  \n  \n The following shows sample output for this example.  \n  \n```Output  \n8293104567Caught exception: -5: the value is less than the minimum.  \n```  \n  \n [[Top](#top)]  \n  \n##  <a name=\"cancellation\"></a> Cancellation  \n Not all exceptions indicate an error. For example, a search algorithm might use exception handling to stop its associated task when it finds the result. For more information about how to use cancellation mechanisms in your code, see [Cancellation in the PPL](../../parallel/concrt/cancellation-in-the-ppl.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"lwts\"></a> Lightweight Tasks  \n A lightweight task is a task that you schedule directly from a [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) object. Lightweight tasks carry less overhead than ordinary tasks. However, the runtime does not catch exceptions that are thrown by lightweight tasks. Instead, the exception is caught by the unhandled exception handler, which by default terminates the process. Therefore, use an appropriate error-handling mechanism in your application. For more information about lightweight tasks, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"agents\"></a> Asynchronous Agents  \n Like lightweight tasks, the runtime does not manage exceptions that are thrown by asynchronous agents.  \n  \n The following example shows one way to handle exceptions in a class that derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md). This example defines the `points_agent` class. The `points_agent::run` method reads `point` objects from the message buffer and prints them to the console. The `run` method throws an exception if it receives a `NULL` pointer.  \n  \n The `run` method surrounds all work in a `try`-`catch` block. The `catch` block stores the exception in a message buffer. The application checks whether the agent encountered an error by reading from this buffer after the agent finishes.  \n  \n [!code-cpp[concrt-eh-agents#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_7.cpp)]  \n  \n This example produces the following output.  \n  \n```Output  \nX: 10 Y: 20  \nX: 20 Y: 30  \nerror occurred in agent: point must not be NULL  \nthe status of the agent is: done  \n```  \n  \n Because the `try`-`catch` block exists outside the `while` loop, the agent ends processing when it encounters the first error. If the `try`-`catch` block was inside the `while` loop, the agent would continue after an error occurs.  \n  \n This example stores exceptions in a message buffer so that another component can monitor the agent for errors as it runs. This example uses a [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) object to store the error. In the case where an agent handles multiple exceptions, the `single_assignment` class stores only the first message that is passed to it. To store only the last exception, use the [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) class. To store all exceptions, use the [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) class. For more information about these message blocks, see [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md).  \n  \n For more information about asynchronous agents, see [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"summary\"></a> Summary  \n [[Top](#top)]  \n  \n## See Also  \n [Concurrency Runtime](../../parallel/concrt/concurrency-runtime.md)   \n [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)   \n [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)   \n [Cancellation in the PPL](cancellation-in-the-ppl.md)   \n [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md)   \n [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)\n\n"}