{"nodes":[{"pos":[12,48],"content":"sizeof Operator (C) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"sizeof Operator (C) | Microsoft Docs","pos":[0,36]}]},{"content":"sizeof Operator (C)","pos":[607,626]},{"content":"The <ph id=\"ph1\">`sizeof`</ph> operator gives the amount of storage, in bytes, required to store an object of the type of the operand.","pos":[627,743],"source":"The `sizeof` operator gives the amount of storage, in bytes, required to store an object of the type of the operand."},{"content":"This operator allows you to avoid specifying machine-dependent data sizes in your programs.","pos":[744,835]},{"content":"Syntax","pos":[844,850]},{"content":"Remarks","pos":[932,939]},{"content":"The operand is either an identifier that is a <bpt id=\"p1\">*</bpt>unary-expression<ept id=\"p1\">*</ept>, or a type-cast expression (that is, a type specifier enclosed in parentheses).","pos":[943,1087],"source":"The operand is either an identifier that is a *unary-expression*, or a type-cast expression (that is, a type specifier enclosed in parentheses)."},{"content":"The <bpt id=\"p1\">*</bpt>unary-expression<ept id=\"p1\">*</ept> cannot represent a bit-field object, an incomplete type, or a function designator.","pos":[1088,1193],"source":" The *unary-expression* cannot represent a bit-field object, an incomplete type, or a function designator."},{"content":"The result is an unsigned integral constant.","pos":[1194,1238]},{"content":"The standard header STDDEF.H defines this type as <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>.","pos":[1239,1300],"source":" The standard header STDDEF.H defines this type as **size_t**."},{"pos":[1307,1483],"content":"When you apply the <ph id=\"ph1\">`sizeof`</ph> operator to an array identifier, the result is the size of the entire array rather than the size of the pointer represented by the array identifier.","source":"When you apply the `sizeof` operator to an array identifier, the result is the size of the entire array rather than the size of the pointer represented by the array identifier."},{"content":"When you apply the <ph id=\"ph1\">`sizeof`</ph> operator to a structure or union type name, or to an identifier of structure or union type, the result is the number of bytes in the structure or union, including internal and trailing padding.","pos":[1490,1711],"source":"When you apply the `sizeof` operator to a structure or union type name, or to an identifier of structure or union type, the result is the number of bytes in the structure or union, including internal and trailing padding."},{"content":"This size may include internal and trailing padding used to align the members of the structure or union on memory boundaries.","pos":[1712,1837]},{"content":"Thus, the result may not correspond to the size calculated by adding up the storage requirements of the individual members.","pos":[1838,1961]},{"pos":[1968,2098],"content":"If an unsized array is the last element of a structure, the <ph id=\"ph1\">`sizeof`</ph> operator returns the size of the structure without the array.","source":"If an unsized array is the last element of a structure, the `sizeof` operator returns the size of the structure without the array."},{"content":"This example uses the <ph id=\"ph1\">`sizeof`</ph> operator to pass the size of an <ph id=\"ph2\">`int`</ph>, which varies among machines, as an argument to a run-time function named <ph id=\"ph3\">`calloc`</ph>.","pos":[2159,2311],"source":"This example uses the `sizeof` operator to pass the size of an `int`, which varies among machines, as an argument to a run-time function named `calloc`."},{"content":"The value returned by the function is stored in <ph id=\"ph1\">`buffer`</ph>.","pos":[2312,2369],"source":" The value returned by the function is stored in `buffer`."},{"content":"In this example, <ph id=\"ph1\">`strings`</ph> is an array of pointers to <ph id=\"ph2\">`char`</ph>.","pos":[2606,2667],"source":"In this example, `strings` is an array of pointers to `char`."},{"content":"The number of pointers is the number of elements in the array, but is not specified.","pos":[2668,2752]},{"content":"It is easy to determine the number of pointers by using the <ph id=\"ph1\">`sizeof`</ph> operator to calculate the number of elements in the array.","pos":[2753,2880],"source":" It is easy to determine the number of pointers by using the `sizeof` operator to calculate the number of elements in the array."},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> integer value <ph id=\"ph1\">`string_no`</ph> is initialized to this number.","pos":[2881,2951],"source":" The **const** integer value `string_no` is initialized to this number."},{"content":"Because it is a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> value, <ph id=\"ph1\">`string_no`</ph> cannot be modified.","pos":[2952,3016],"source":" Because it is a **const** value, `string_no` cannot be modified."},{"content":"See Also","pos":[3025,3033]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[3038,3090]}],"content":"---\ntitle: \"sizeof Operator (C) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"sizeof\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"sizeof operator\"\nms.assetid: 70826d03-3451-41e4-bebb-a820ae66d53f\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# sizeof Operator (C)\nThe `sizeof` operator gives the amount of storage, in bytes, required to store an object of the type of the operand. This operator allows you to avoid specifying machine-dependent data sizes in your programs.  \n  \n## Syntax  \n  \n```  \n  \n      sizeof unary-expression  \nsizeof ( type-name )  \n```  \n  \n## Remarks  \n The operand is either an identifier that is a *unary-expression*, or a type-cast expression (that is, a type specifier enclosed in parentheses). The *unary-expression* cannot represent a bit-field object, an incomplete type, or a function designator. The result is an unsigned integral constant. The standard header STDDEF.H defines this type as **size_t**.  \n  \n When you apply the `sizeof` operator to an array identifier, the result is the size of the entire array rather than the size of the pointer represented by the array identifier.  \n  \n When you apply the `sizeof` operator to a structure or union type name, or to an identifier of structure or union type, the result is the number of bytes in the structure or union, including internal and trailing padding. This size may include internal and trailing padding used to align the members of the structure or union on memory boundaries. Thus, the result may not correspond to the size calculated by adding up the storage requirements of the individual members.  \n  \n If an unsized array is the last element of a structure, the `sizeof` operator returns the size of the structure without the array.  \n  \n```  \nbuffer = calloc(100, sizeof (int) );  \n```  \n  \n This example uses the `sizeof` operator to pass the size of an `int`, which varies among machines, as an argument to a run-time function named `calloc`. The value returned by the function is stored in `buffer`.  \n  \n```  \nstatic char *strings[] ={  \n          \"this is string one\",  \n          \"this is string two\",  \n          \"this is string three\",  \n         };  \nconst int string_no = ( sizeof strings ) / ( sizeof strings[0] );   \n```  \n  \n In this example, `strings` is an array of pointers to `char`. The number of pointers is the number of elements in the array, but is not specified. It is easy to determine the number of pointers by using the `sizeof` operator to calculate the number of elements in the array. The **const** integer value `string_no` is initialized to this number. Because it is a **const** value, `string_no` cannot be modified.  \n  \n## See Also  \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity)\n\n"}