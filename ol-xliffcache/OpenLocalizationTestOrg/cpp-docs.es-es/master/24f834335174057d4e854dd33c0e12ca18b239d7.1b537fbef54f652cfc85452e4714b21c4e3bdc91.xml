{"nodes":[{"pos":[12,85],"content":"Storage-Class Specifiers for External-Level Declarations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Storage-Class Specifiers for External-Level Declarations | Microsoft Docs","pos":[0,73]}]},{"content":"Storage-Class Specifiers for External-Level Declarations","pos":[1064,1120]},{"content":"External variables are variables at file scope.","pos":[1121,1168]},{"content":"They are defined outside any function, and they are potentially available to many functions.","pos":[1169,1261]},{"content":"Functions can only be defined at the external level and, therefore, cannot be nested.","pos":[1262,1347]},{"content":"By default, all references to external variables and functions of the same name are references to the same object, which means they have \"external linkage.\"","pos":[1348,1504]},{"content":"(You can use the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword to override this.","pos":[1505,1558],"source":" (You can use the **static** keyword to override this."},{"content":"See information later in this section for more details on <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>.)","pos":[1559,1629],"source":" See information later in this section for more details on **static**.)"},{"content":"Variable declarations at the external level are either definitions of variables (\"defining declarations\"), or references to variables defined elsewhere (\"referencing declarations\").","pos":[1636,1817]},{"content":"An external variable declaration that also initializes the variable (implicitly or explicitly) is a defining declaration of the variable.","pos":[1824,1961]},{"content":"A definition at the external level can take several forms:","pos":[1962,2020]},{"content":"A variable that you declare with the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> storage-class specifier.","pos":[2030,2102],"source":"A variable that you declare with the **static** storage-class specifier."},{"content":"You can explicitly initialize the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> variable with a constant expression, as described in <bpt id=\"p2\">[</bpt>Initialization<ept id=\"p2\">](../c-language/initialization.md)</ept>.","pos":[2103,2251],"source":" You can explicitly initialize the **static** variable with a constant expression, as described in [Initialization](../c-language/initialization.md)."},{"content":"If you omit the initializer, the variable is initialized to 0 by default.","pos":[2252,2325]},{"content":"For example, these two statements are both considered definitions of the variable <ph id=\"ph1\">`k`</ph>.","pos":[2326,2412],"source":" For example, these two statements are both considered definitions of the variable `k`."},{"content":"A variable that you explicitly initialize at the external level.","pos":[2490,2554]},{"content":"For example, <ph id=\"ph1\">`int j = 3;`</ph> is a definition of the variable <ph id=\"ph2\">`j`</ph>.","pos":[2555,2617],"source":" For example, `int j = 3;` is a definition of the variable `j`."},{"content":"In variable declarations at the external level (that is, outside all functions), you can use the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`extern`</ph> storage-class specifier or omit the storage-class specifier entirely.","pos":[2624,2813],"source":"In variable declarations at the external level (that is, outside all functions), you can use the **static** or `extern` storage-class specifier or omit the storage-class specifier entirely."},{"content":"You cannot use the <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>storage-class-specifier<ept id=\"p3\">*</ept> terminals at the external level.","pos":[2814,2917],"source":" You cannot use the **auto** and **register** *storage-class-specifier* terminals at the external level."},{"content":"Once a variable is defined at the external level, it is visible throughout the rest of the translation unit.","pos":[2924,3032]},{"content":"The variable is not visible prior to its declaration in the same source file.","pos":[3033,3110]},{"content":"Also, it is not visible in other source files of the program, unless a referencing declaration makes it visible, as described below.","pos":[3111,3243]},{"pos":[3250,3291],"content":"The rules relating to <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> include:","source":"The rules relating to **static** include:"},{"content":"Variables declared outside all blocks without the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword always retain their values throughout the program.","pos":[3301,3420],"source":"Variables declared outside all blocks without the **static** keyword always retain their values throughout the program."},{"content":"To restrict their access to a particular translation unit, you must use the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[3421,3516],"source":" To restrict their access to a particular translation unit, you must use the **static** keyword."},{"content":"This gives them \"internal linkage.\"","pos":[3517,3552]},{"content":"To make them global to an entire program, omit the explicit storage class or use the keyword <ph id=\"ph1\">`extern`</ph> (see the rules in the next list).","pos":[3553,3688],"source":" To make them global to an entire program, omit the explicit storage class or use the keyword `extern` (see the rules in the next list)."},{"content":"This gives them \"external linkage.\"","pos":[3689,3724]},{"content":"Internal and external linkage are also discussed in <bpt id=\"p1\">[</bpt>Linkage<ept id=\"p1\">](../c-language/linkage.md)</ept>.","pos":[3725,3813],"source":" Internal and external linkage are also discussed in [Linkage](../c-language/linkage.md)."},{"content":"You can define a variable at the external level only once within a program.","pos":[3823,3898]},{"content":"You can define another variable with the same name and the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> storage-class specifier in a different translation unit.","pos":[3899,4025],"source":" You can define another variable with the same name and the **static** storage-class specifier in a different translation unit."},{"content":"Since each <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> definition is visible only within its own translation unit, no conflict occurs.","pos":[4026,4127],"source":" Since each **static** definition is visible only within its own translation unit, no conflict occurs."},{"content":"This provides a useful way to hide identifier names that must be shared among functions of a single translation unit, but not visible to other translation units.","pos":[4128,4289]},{"content":"The <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> storage-class specifier can apply to functions as well.","pos":[4299,4369],"source":"The **static** storage-class specifier can apply to functions as well."},{"content":"If you declare a function <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>, its name is invisible outside of the file in which it is declared.","pos":[4370,4474],"source":" If you declare a function **static**, its name is invisible outside of the file in which it is declared."},{"pos":[4481,4514],"content":"The rules for using <ph id=\"ph1\">`extern`</ph> are:","source":"The rules for using `extern` are:"},{"content":"The <ph id=\"ph1\">`extern`</ph> storage-class specifier declares a reference to a variable defined elsewhere.","pos":[4524,4614],"source":"The `extern` storage-class specifier declares a reference to a variable defined elsewhere."},{"content":"You can use an <ph id=\"ph1\">`extern`</ph> declaration to make a definition in another source file visible, or to make a variable visible prior to its definition in the same source file.","pos":[4615,4782],"source":" You can use an `extern` declaration to make a definition in another source file visible, or to make a variable visible prior to its definition in the same source file."},{"content":"Once you have declared a reference to the variable at the external level, the variable is visible throughout the remainder of the translation unit in which the declared reference occurs.","pos":[4783,4969]},{"content":"For an <ph id=\"ph1\">`extern`</ph> reference to be valid, the variable it refers to must be defined once, and only once, at the external level.","pos":[4979,5103],"source":"For an `extern` reference to be valid, the variable it refers to must be defined once, and only once, at the external level."},{"content":"This definition (without the <ph id=\"ph1\">`extern`</ph> storage class) can be in any of the translation units that make up the program.","pos":[5104,5221],"source":" This definition (without the `extern` storage class) can be in any of the translation units that make up the program."},{"content":"Example","pos":[5230,5237]},{"content":"The example below illustrates external declarations:","pos":[5241,5293]},{"content":"The two source files in this example contain a total of three external declarations of <ph id=\"ph1\">`i`</ph>.","pos":[6294,6385],"source":"The two source files in this example contain a total of three external declarations of `i`."},{"content":"Only one declaration is a \"defining declaration.\"","pos":[6386,6435]},{"content":"That declaration,","pos":[6436,6453]},{"content":"defines the global variable <ph id=\"ph1\">`i`</ph> and initializes it with initial value 3.","pos":[6488,6560],"source":"defines the global variable `i` and initializes it with initial value 3."},{"content":"The \"referencing\" declaration of <ph id=\"ph1\">`i`</ph> at the top of the first source file using <ph id=\"ph2\">`extern`</ph> makes the global variable visible prior to its defining declaration in the file.","pos":[6561,6729],"source":" The \"referencing\" declaration of `i` at the top of the first source file using `extern` makes the global variable visible prior to its defining declaration in the file."},{"content":"The referencing declaration of <ph id=\"ph1\">`i`</ph> in the second source file also makes the variable visible in that source file.","pos":[6730,6843],"source":" The referencing declaration of `i` in the second source file also makes the variable visible in that source file."},{"content":"If a defining instance for a variable is not provided in the translation unit, the compiler assumes there is an","pos":[6844,6955]},{"content":"referencing declaration and that a defining reference","pos":[6993,7046]},{"content":"appears in another translation unit of the program.","pos":[7081,7132]},{"content":"All three functions, <ph id=\"ph1\">`main`</ph>, <ph id=\"ph2\">`next`</ph>, and <ph id=\"ph3\">`other`</ph>, perform the same task: they increase <ph id=\"ph4\">`i`</ph> and print it.","pos":[7139,7243],"source":"All three functions, `main`, `next`, and `other`, perform the same task: they increase `i` and print it."},{"content":"The values 4, 5, and 6 are printed.","pos":[7244,7279]},{"content":"If the variable <ph id=\"ph1\">`i`</ph> had not been initialized, it would have been set to 0 automatically.","pos":[7286,7374],"source":"If the variable `i` had not been initialized, it would have been set to 0 automatically."},{"content":"In this case, the values 1, 2, and 3 would have been printed.","pos":[7375,7436]},{"content":"See <bpt id=\"p1\">[</bpt>Initialization<ept id=\"p1\">](../c-language/initialization.md)</ept> for information about variable initialization.","pos":[7437,7537],"source":" See [Initialization](../c-language/initialization.md) for information about variable initialization."},{"content":"See Also","pos":[7546,7554]},{"content":"C Storage Classes","pos":[7559,7576]}],"content":"---\ntitle: \"Storage-Class Specifiers for External-Level Declarations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"external definitions\"\n  - \"linkage [C++], external\"\n  - \"external linkage, variable declarations\"\n  - \"declaring variables, external variables\"\n  - \"declarations [C++], external\"\n  - \"declarations [C++], specifiers\"\n  - \"external declarations\"\n  - \"static variables, external declarations\"\n  - \"variables, visibility\"\n  - \"external linkage, storage-class specifiers\"\n  - \"referencing declarations\"\n  - \"visibility, variables\"\n  - \"static storage class specifiers\"\nms.assetid: b76b623a-80ec-4d5d-859b-6cef422657ee\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Storage-Class Specifiers for External-Level Declarations\nExternal variables are variables at file scope. They are defined outside any function, and they are potentially available to many functions. Functions can only be defined at the external level and, therefore, cannot be nested. By default, all references to external variables and functions of the same name are references to the same object, which means they have \"external linkage.\" (You can use the **static** keyword to override this. See information later in this section for more details on **static**.)  \n  \n Variable declarations at the external level are either definitions of variables (\"defining declarations\"), or references to variables defined elsewhere (\"referencing declarations\").  \n  \n An external variable declaration that also initializes the variable (implicitly or explicitly) is a defining declaration of the variable. A definition at the external level can take several forms:  \n  \n-   A variable that you declare with the **static** storage-class specifier. You can explicitly initialize the **static** variable with a constant expression, as described in [Initialization](../c-language/initialization.md). If you omit the initializer, the variable is initialized to 0 by default. For example, these two statements are both considered definitions of the variable `k`.  \n  \n    ```  \n    static int k = 16;  \n    static int k;  \n    ```  \n  \n-   A variable that you explicitly initialize at the external level. For example, `int j = 3;` is a definition of the variable `j`.  \n  \n In variable declarations at the external level (that is, outside all functions), you can use the **static** or `extern` storage-class specifier or omit the storage-class specifier entirely. You cannot use the **auto** and **register** *storage-class-specifier* terminals at the external level.  \n  \n Once a variable is defined at the external level, it is visible throughout the rest of the translation unit. The variable is not visible prior to its declaration in the same source file. Also, it is not visible in other source files of the program, unless a referencing declaration makes it visible, as described below.  \n  \n The rules relating to **static** include:  \n  \n-   Variables declared outside all blocks without the **static** keyword always retain their values throughout the program. To restrict their access to a particular translation unit, you must use the **static** keyword. This gives them \"internal linkage.\" To make them global to an entire program, omit the explicit storage class or use the keyword `extern` (see the rules in the next list). This gives them \"external linkage.\" Internal and external linkage are also discussed in [Linkage](../c-language/linkage.md).  \n  \n-   You can define a variable at the external level only once within a program. You can define another variable with the same name and the **static** storage-class specifier in a different translation unit. Since each **static** definition is visible only within its own translation unit, no conflict occurs. This provides a useful way to hide identifier names that must be shared among functions of a single translation unit, but not visible to other translation units.  \n  \n-   The **static** storage-class specifier can apply to functions as well. If you declare a function **static**, its name is invisible outside of the file in which it is declared.  \n  \n The rules for using `extern` are:  \n  \n-   The `extern` storage-class specifier declares a reference to a variable defined elsewhere. You can use an `extern` declaration to make a definition in another source file visible, or to make a variable visible prior to its definition in the same source file. Once you have declared a reference to the variable at the external level, the variable is visible throughout the remainder of the translation unit in which the declared reference occurs.  \n  \n-   For an `extern` reference to be valid, the variable it refers to must be defined once, and only once, at the external level. This definition (without the `extern` storage class) can be in any of the translation units that make up the program.  \n  \n## Example  \n The example below illustrates external declarations:  \n  \n```  \n/******************************************************************  \n                      SOURCE FILE ONE   \n*******************************************************************/  \n#include <stdio.h>  \n  \nextern int i;                // Reference to i, defined below   \nvoid next( void );           // Function prototype              \n  \nint main()  \n{  \n    i++;  \n    printf_s( \"%d\\n\", i );   // i equals 4   \n    next();  \n}  \n  \nint i = 3;                  // Definition of i  \n  \nvoid next( void )  \n{  \n    i++;  \n    printf_s( \"%d\\n\", i );  // i equals 5  \n    other();  \n}  \n  \n/******************************************************************  \n                      SOURCE FILE TWO   \n*******************************************************************/  \n#include <stdio.h>  \n  \nextern int i;              // Reference to i in   \n                           // first source file   \nvoid other( void )  \n{  \n    i++;  \n    printf_s( \"%d\\n\", i ); // i equals 6   \n}  \n```  \n  \n The two source files in this example contain a total of three external declarations of `i`. Only one declaration is a \"defining declaration.\" That declaration,  \n  \n```  \nint i = 3;  \n```  \n  \n defines the global variable `i` and initializes it with initial value 3. The \"referencing\" declaration of `i` at the top of the first source file using `extern` makes the global variable visible prior to its defining declaration in the file. The referencing declaration of `i` in the second source file also makes the variable visible in that source file. If a defining instance for a variable is not provided in the translation unit, the compiler assumes there is an  \n  \n```  \nextern int x;  \n```  \n  \n referencing declaration and that a defining reference  \n  \n```  \nint x = 0;  \n```  \n  \n appears in another translation unit of the program.  \n  \n All three functions, `main`, `next`, and `other`, perform the same task: they increase `i` and print it. The values 4, 5, and 6 are printed.  \n  \n If the variable `i` had not been initialized, it would have been set to 0 automatically. In this case, the values 1, 2, and 3 would have been printed. See [Initialization](../c-language/initialization.md) for information about variable initialization.  \n  \n## See Also  \n [C Storage Classes](../c-language/c-storage-classes.md)"}