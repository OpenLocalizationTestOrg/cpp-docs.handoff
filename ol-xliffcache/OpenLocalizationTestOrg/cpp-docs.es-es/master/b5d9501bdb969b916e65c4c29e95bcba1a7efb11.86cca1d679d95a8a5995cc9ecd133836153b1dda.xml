{"nodes":[{"pos":[12,89],"content":"Comparing Synchronization Data Structures to the Windows API | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Comparing Synchronization Data Structures to the Windows API | Microsoft Docs","pos":[0,77]}]},{"content":"Comparing Synchronization Data Structures to the Windows API","pos":[708,768]},{"content":"This topic compares the behavior of the synchronization data structures that are provided by the Concurrency Runtime to those provided by the Windows API.","pos":[769,923]},{"content":"The synchronization data structures that are provided by the Concurrency Runtime follow the <bpt id=\"p1\">*</bpt>cooperative threading model<ept id=\"p1\">*</ept>.","pos":[930,1052],"source":"The synchronization data structures that are provided by the Concurrency Runtime follow the *cooperative threading model*."},{"content":"In the cooperative threading model, synchronization primitives explicitly yield their processing resources to other threads.","pos":[1053,1177]},{"content":"This differs from the <bpt id=\"p1\">*</bpt>preemptive threading model<ept id=\"p1\">*</ept>, where processing resources are transferred to other threads by the controlling scheduler or operating system.","pos":[1178,1339],"source":" This differs from the *preemptive threading model*, where processing resources are transferred to other threads by the controlling scheduler or operating system."},{"content":"critical_section","pos":[1348,1364]},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::critical_section<ept id=\"p1\">](../../parallel/concrt/reference/critical-section-class.md)</ept> class resembles the Windows <ph id=\"ph1\">`CRITICAL_SECTION`</ph> structure because it can be used only by the threads of one process.","pos":[1368,1578],"source":"The [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md) class resembles the Windows `CRITICAL_SECTION` structure because it can be used only by the threads of one process."},{"content":"For more information about critical sections in the Windows API, see <bpt id=\"p1\">[</bpt>Critical Section Objects<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682530)</ept>.","pos":[1579,1735],"source":" For more information about critical sections in the Windows API, see [Critical Section Objects](http://msdn.microsoft.com/library/windows/desktop/ms682530)."},{"content":"reader_writer_lock","pos":[1744,1762]},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::reader_writer_lock<ept id=\"p1\">](../../parallel/concrt/reference/reader-writer-lock-class.md)</ept> class resembles Windows slim reader/writer (SRW) locks.","pos":[1766,1920],"source":"The [concurrency::reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) class resembles Windows slim reader/writer (SRW) locks."},{"content":"The following table explains the similarities and differences.","pos":[1921,1983]},{"content":"Feature","pos":[1990,1997]},{"content":"SRW lock","pos":[2019,2027]},{"content":"Non-reentrant","pos":[2092,2105]},{"content":"Yes","pos":[2106,2109]},{"content":"Yes","pos":[2110,2113]},{"content":"Can promote a reader to a writer (upgrade support)","pos":[2118,2168]},{"content":"No","pos":[2169,2171]},{"content":"No","pos":[2172,2174]},{"content":"Can demote a writer to a reader (downgrade support)","pos":[2179,2230]},{"content":"No","pos":[2231,2233]},{"content":"No","pos":[2234,2236]},{"content":"Write-preference lock","pos":[2241,2262]},{"content":"Yes","pos":[2263,2266]},{"content":"No","pos":[2267,2269]},{"content":"FIFO access to writers","pos":[2274,2296]},{"content":"Yes","pos":[2297,2300]},{"content":"No","pos":[2301,2303]},{"pos":[2311,2466],"content":"For more information about SRW locks, see <bpt id=\"p1\">[</bpt>Slim Reader/Writer (SRW) Locks<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa904937)</ept> in the Platform SDK.","source":"For more information about SRW locks, see [Slim Reader/Writer (SRW) Locks](http://msdn.microsoft.com/library/windows/desktop/aa904937) in the Platform SDK."},{"content":"event","pos":[2475,2480]},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::event<ept id=\"p1\">](../../parallel/concrt/reference/event-class.md)</ept> class resembles an unnamed, Windows manual-reset event.","pos":[2484,2612],"source":"The [concurrency::event](../../parallel/concrt/reference/event-class.md) class resembles an unnamed, Windows manual-reset event."},{"content":"However, an <ph id=\"ph1\">`event`</ph> object behaves cooperatively, whereas a Windows event behaves preemptively.","pos":[2613,2708],"source":" However, an `event` object behaves cooperatively, whereas a Windows event behaves preemptively."},{"content":"For more information about Windows events, see <bpt id=\"p1\">[</bpt>Event Objects<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682655)</ept>.","pos":[2709,2832],"source":" For more information about Windows events, see [Event Objects](http://msdn.microsoft.com/library/windows/desktop/ms682655)."},{"content":"Example","pos":[2841,2848]},{"content":"Description","pos":[2858,2869]},{"content":"To better understand the difference between the <ph id=\"ph1\">`event`</ph> class and Windows events, consider the following example.","pos":[2873,2986],"source":"To better understand the difference between the `event` class and Windows events, consider the following example."},{"content":"This example enables the scheduler to create at most two simultaneous tasks and then calls two similar functions that use the <ph id=\"ph1\">`event`</ph> class and a Windows manual-reset event.","pos":[2987,3160],"source":" This example enables the scheduler to create at most two simultaneous tasks and then calls two similar functions that use the `event` class and a Windows manual-reset event."},{"content":"Each function first creates several tasks that wait for a shared event to become signaled.","pos":[3161,3251]},{"content":"Each function then yields to the running tasks and then signals the event.","pos":[3252,3326]},{"content":"Each function then waits for the signaled event.","pos":[3327,3375]},{"content":"Code","pos":[3385,3389]},{"pos":[3404,3429],"content":"concrt-event-comparison#1"},{"content":"Comments","pos":[3547,3555]},{"content":"This example produces the following sample output:","pos":[3559,3609]},{"content":"Because the <ph id=\"ph1\">`event`</ph> class behaves cooperatively, the scheduler can reallocate processing resources to another context when an event is waiting to enter the signaled state.","pos":[4485,4656],"source":"Because the `event` class behaves cooperatively, the scheduler can reallocate processing resources to another context when an event is waiting to enter the signaled state."},{"content":"Therefore, more work is accomplished by the version that uses the <ph id=\"ph1\">`event`</ph> class.","pos":[4657,4737],"source":" Therefore, more work is accomplished by the version that uses the `event` class."},{"content":"In the version that uses Windows events, each waiting task must enter the signaled state before the next task is started.","pos":[4738,4859]},{"pos":[4866,4986],"content":"For more information about tasks, see <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.","source":"For more information about tasks, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)."},{"content":"See Also","pos":[4995,5003]},{"content":"Synchronization Data Structures","pos":[5008,5039]}],"content":"---\ntitle: \"Comparing Synchronization Data Structures to the Windows API | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"synchronization data structures, compared to Windows API\"\n  - \"event class, example\"\nms.assetid: 8b0b1a3a-ef80-408c-91fa-93e6af920b4e\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Comparing Synchronization Data Structures to the Windows API\nThis topic compares the behavior of the synchronization data structures that are provided by the Concurrency Runtime to those provided by the Windows API.  \n  \n The synchronization data structures that are provided by the Concurrency Runtime follow the *cooperative threading model*. In the cooperative threading model, synchronization primitives explicitly yield their processing resources to other threads. This differs from the *preemptive threading model*, where processing resources are transferred to other threads by the controlling scheduler or operating system.  \n  \n## critical_section  \n The [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md) class resembles the Windows `CRITICAL_SECTION` structure because it can be used only by the threads of one process. For more information about critical sections in the Windows API, see [Critical Section Objects](http://msdn.microsoft.com/library/windows/desktop/ms682530).  \n  \n## reader_writer_lock  \n The [concurrency::reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) class resembles Windows slim reader/writer (SRW) locks. The following table explains the similarities and differences.  \n  \n|Feature|`reader_writer_lock`|SRW lock|  \n|-------------|--------------------------|--------------|  \n|Non-reentrant|Yes|Yes|  \n|Can promote a reader to a writer (upgrade support)|No|No|  \n|Can demote a writer to a reader (downgrade support)|No|No|  \n|Write-preference lock|Yes|No|  \n|FIFO access to writers|Yes|No|  \n  \n For more information about SRW locks, see [Slim Reader/Writer (SRW) Locks](http://msdn.microsoft.com/library/windows/desktop/aa904937) in the Platform SDK.  \n  \n## event  \n The [concurrency::event](../../parallel/concrt/reference/event-class.md) class resembles an unnamed, Windows manual-reset event. However, an `event` object behaves cooperatively, whereas a Windows event behaves preemptively. For more information about Windows events, see [Event Objects](http://msdn.microsoft.com/library/windows/desktop/ms682655).  \n  \n## Example  \n  \n### Description  \n To better understand the difference between the `event` class and Windows events, consider the following example. This example enables the scheduler to create at most two simultaneous tasks and then calls two similar functions that use the `event` class and a Windows manual-reset event. Each function first creates several tasks that wait for a shared event to become signaled. Each function then yields to the running tasks and then signals the event. Each function then waits for the signaled event.  \n  \n### Code  \n [!code-cpp[concrt-event-comparison#1](../../parallel/concrt/codesnippet/cpp/comparing-synchronization-data-structures-to-the-windows-api_1.cpp)]  \n  \n### Comments  \n This example produces the following sample output:  \n  \n```Output  \nCooperative event:  \n    Context 0: waiting on an event.  \n    Context 1: waiting on an event.  \n    Context 2: waiting on an event.  \n    Context 3: waiting on an event.  \n    Context 4: waiting on an event.  \n    Setting the event.  \n    Context 5: received the event.  \n    Context 6: received the event.  \n    Context 7: received the event.  \n    Context 8: received the event.  \n    Context 9: received the event.  \nWindows event:  \n    Context 10: waiting on an event.  \n    Context 11: waiting on an event.  \n    Setting the event.  \n    Context 12: received the event.  \n    Context 14: waiting on an event.  \n    Context 15: received the event.  \n    Context 16: waiting on an event.  \n    Context 17: received the event.  \n    Context 18: waiting on an event.  \n    Context 19: received the event.  \n    Context 13: received the event.  \n```  \n  \n Because the `event` class behaves cooperatively, the scheduler can reallocate processing resources to another context when an event is waiting to enter the signaled state. Therefore, more work is accomplished by the version that uses the `event` class. In the version that uses Windows events, each waiting task must enter the signaled state before the next task is started.  \n  \n For more information about tasks, see [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md).  \n  \n## See Also  \n [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md)\n"}