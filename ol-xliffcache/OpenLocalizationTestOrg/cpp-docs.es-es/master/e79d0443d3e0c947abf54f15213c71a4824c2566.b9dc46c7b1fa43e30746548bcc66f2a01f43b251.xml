{"nodes":[{"pos":[12,61],"content":"Compiler Warning (Level 1) C4789 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Warning (Level 1) C4789 | Microsoft Docs","pos":[0,49]}]},{"pos":[610,642],"content":"Compiler Warning (Level 1) C4789","linkify":"Compiler Warning (Level 1) C4789","nodes":[{"content":"Compiler Warning (Level 1) C4789","pos":[0,32]}]},{"content":"buffer 'identifier' of size N bytes will be overrun; M bytes will be written starting at offset L","pos":[643,740]},{"content":"Warns about buffer overrun when specific C run-time (CRT) functions are used, parameters are passed, and assignments are performed, such that the data sizes are known at compile time.","pos":[747,930]},{"content":"This warning is for situations that might elude typical data-size mismatch detection.","pos":[931,1016]},{"content":"The warning appears when data, whose length is known at compile time, is copied and put into a data block whose size is known at compile time to be too small for the data.","pos":[1023,1194]},{"content":"The copy must be done by using the intrinsic form of one of the following CRT functions:","pos":[1195,1283]},{"pos":[1293,1360],"content":"<bpt id=\"p1\">[</bpt>strcpy<ept id=\"p1\">](../../c-runtime-library/reference/strcpy-wcscpy-mbscpy.md)</ept>","source":"[strcpy](../../c-runtime-library/reference/strcpy-wcscpy-mbscpy.md)"},{"pos":[1370,1431],"content":"<bpt id=\"p1\">[</bpt>memset<ept id=\"p1\">](../../c-runtime-library/reference/memset-wmemset.md)</ept>","source":"[memset](../../c-runtime-library/reference/memset-wmemset.md)"},{"pos":[1441,1566],"content":"<bpt id=\"p1\">[</bpt>memcpy<ept id=\"p1\">](../../c-runtime-library/reference/memcpy-wmemcpy.md)</ept>, <bpt id=\"p2\">[</bpt>wmemcpy<ept id=\"p2\">](../../c-runtime-library/reference/memcpy-wmemcpy.md)</ept>","source":"[memcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md), [wmemcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md)"},{"content":"The warning also appears when a parameter datatype is mismatched by using a cast, and then a copy assignment from an lvalue reference is attempted.","pos":[1573,1720]},{"content":"Visual C++ might generate this warning for a code path that does not ever execute.","pos":[1727,1809]},{"content":"You can temporarily disable the warning by using <ph id=\"ph1\">`#pragma`</ph>, as shown in this example:","pos":[1810,1895],"source":" You can temporarily disable the warning by using `#pragma`, as shown in this example:"},{"content":"This keeps Visual C++ from generating the warning for that specific block of code.","pos":[2049,2131]},{"content":"The <ph id=\"ph1\">`#pragma(push)`</ph> preserves the existing state before <ph id=\"ph2\">`#pragma warning(disable: 4789)`</ph> changes it.","pos":[2132,2232],"source":" The `#pragma(push)` preserves the existing state before `#pragma warning(disable: 4789)` changes it."},{"content":"The <ph id=\"ph1\">`#pragma(pop)`</ph> restores the pushed state, and removes the effects of the <ph id=\"ph2\">`#pragma warning(disable:4789)`</ph>.","pos":[2233,2342],"source":" The `#pragma(pop)` restores the pushed state, and removes the effects of the `#pragma warning(disable:4789)`."},{"content":"For more information about the C++ preprocessor directive <ph id=\"ph1\">`#pragma`</ph>, see <bpt id=\"p1\">[</bpt>warning<ept id=\"p1\">](../../preprocessor/warning.md)</ept> and <bpt id=\"p2\">[</bpt>Pragma Directives and the __Pragma Keyword<ept id=\"p2\">](../../preprocessor/pragma-directives-and-the-pragma-keyword.md)</ept>.","pos":[2343,2570],"source":" For more information about the C++ preprocessor directive `#pragma`, see [warning](../../preprocessor/warning.md) and [Pragma Directives and the __Pragma Keyword](../../preprocessor/pragma-directives-and-the-pragma-keyword.md)."},{"pos":[2579,2586],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample generates C4789.","pos":[2590,2627]},{"pos":[2982,2989],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample also generates C4789.","pos":[2993,3035]}],"content":"---\ntitle: \"Compiler Warning (Level 1) C4789 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C4789\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C4789\"\nms.assetid: 5800c301-5afb-4af0-85c1-ceb54d775234\ncaps.latest.revision: 18\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Warning (Level 1) C4789\nbuffer 'identifier' of size N bytes will be overrun; M bytes will be written starting at offset L  \n  \n Warns about buffer overrun when specific C run-time (CRT) functions are used, parameters are passed, and assignments are performed, such that the data sizes are known at compile time. This warning is for situations that might elude typical data-size mismatch detection.  \n  \n The warning appears when data, whose length is known at compile time, is copied and put into a data block whose size is known at compile time to be too small for the data. The copy must be done by using the intrinsic form of one of the following CRT functions:  \n  \n-   [strcpy](../../c-runtime-library/reference/strcpy-wcscpy-mbscpy.md)  \n  \n-   [memset](../../c-runtime-library/reference/memset-wmemset.md)  \n  \n-   [memcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md), [wmemcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md)  \n  \n The warning also appears when a parameter datatype is mismatched by using a cast, and then a copy assignment from an lvalue reference is attempted.  \n  \n Visual C++ might generate this warning for a code path that does not ever execute. You can temporarily disable the warning by using `#pragma`, as shown in this example:  \n  \n `#pragma(push)`  \n  \n `#pragma warning ( disable : 4789 )`  \n  \n `// unused code that generates compiler warning C4789`  \n  \n `#pragma(pop)`  \n  \n This keeps Visual C++ from generating the warning for that specific block of code. The `#pragma(push)` preserves the existing state before `#pragma warning(disable: 4789)` changes it. The `#pragma(pop)` restores the pushed state, and removes the effects of the `#pragma warning(disable:4789)`. For more information about the C++ preprocessor directive `#pragma`, see [warning](../../preprocessor/warning.md) and [Pragma Directives and the __Pragma Keyword](../../preprocessor/pragma-directives-and-the-pragma-keyword.md).  \n  \n## Example  \n The following sample generates C4789.  \n  \n```  \n// C4789.cpp  \n// compile with: /Oi /W1 /c  \n#include <string.h>  \n#include <stdio.h>  \n  \nint main()   \n{  \n    char a[20];  \n    strcpy(a, \"0000000000000000000000000\\n\");   // C4789  \n  \n    char buf2[20];  \n    memset(buf2, 'a', 21);   // C4789  \n  \n    char c;  \n    wchar_t w = 0;  \n    memcpy(&c, &w, sizeof(wchar_t));  \n}  \n```  \n  \n## Example  \n The following sample also generates C4789.  \n  \n```  \n// C4789b.cpp  \n// compile with: /W1 /O2 /c  \n// processor: x86  \nshort G;  \n  \nvoid main()  \n{  \n   int * p = (int *)&G;   \n   *p = 3;   // C4789 - writes an int through a pointer to short  \n}   \n```"}