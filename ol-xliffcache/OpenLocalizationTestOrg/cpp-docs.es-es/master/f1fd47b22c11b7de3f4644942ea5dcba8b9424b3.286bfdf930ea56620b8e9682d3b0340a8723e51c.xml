{"nodes":[{"pos":[12,51],"content":"File System Navigation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"File System Navigation | Microsoft Docs","pos":[0,39]}]},{"pos":[558,580],"content":"File System Navigation","linkify":"File System Navigation","nodes":[{"content":"File System Navigation","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">\\&lt;</ph>filesystem&gt; header implements the C++ File System Technical Specification ISO/IEC TS 18822:2015 (Final draft: <bpt id=\"p1\">[</bpt>ISO/IEC JTC 1/SC 22/WG 21 N4100<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf)</ept>) and has types and functions that enable you to write platform-independent code for navigating the file system.","pos":[581,909],"source":"The \\<filesystem> header implements the C++ File System Technical Specification ISO/IEC TS 18822:2015 (Final draft: [ISO/IEC JTC 1/SC 22/WG 21 N4100](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf)) and has types and functions that enable you to write platform-independent code for navigating the file system."},{"content":"Because it is cross-platform, it contains APIs that are not relevant for Windows systems.","pos":[910,999]},{"content":"For example, this means that <ph id=\"ph1\">`is_fifo(const path&amp;)`</ph> always returns <ph id=\"ph2\">`false`</ph> on Windows.","pos":[1000,1086],"source":" For example, this means that `is_fifo(const path&)` always returns `false` on Windows."},{"content":"The header is based on a draft Technical Specification that was not voted into the C++17 standard as of Visual Studio 2015 RTM.","pos":[1087,1214]},{"content":"Its members are found in the <ph id=\"ph1\">`std::experimental::filesystem`</ph> namespace.","pos":[1215,1286],"source":" Its members are found in the `std::experimental::filesystem` namespace."},{"pos":[1295,1303],"content":"Overview","linkify":"Overview","nodes":[{"content":"Overview","pos":[0,8]}]},{"content":"Use the <ph id=\"ph1\">\\&lt;</ph>filesystem&gt; APIs for the following tasks:","pos":[1307,1358],"source":"Use the \\<filesystem> APIs for the following tasks:"},{"content":"iterate over files and directories under a specified path","pos":[1368,1425]},{"content":"get information about files including the time created, size, extension, and root directory","pos":[1435,1526]},{"content":"compose, decompose, and compare paths","pos":[1536,1573]},{"content":"create, copy and delete directories","pos":[1583,1618]},{"content":"copy and delete files","pos":[1628,1649]},{"pos":[1656,1791],"content":"For more information about File IO using the Standard Library, see <bpt id=\"p1\">[</bpt>iostream Programming<ept id=\"p1\">](../standard-library/iostream-programming.md)</ept>.","source":"For more information about File IO using the Standard Library, see [iostream Programming](../standard-library/iostream-programming.md)."},{"pos":[1800,1805],"content":"Paths","linkify":"Paths","nodes":[{"content":"Paths","pos":[0,5]}]},{"pos":[1815,1847],"content":"Constructing and composing paths","linkify":"Constructing and composing paths","nodes":[{"content":"Constructing and composing paths","pos":[0,32]}]},{"content":"Paths in Windows (since XP) are stored natively in Unicode.","pos":[1851,1910]},{"content":"The <bpt id=\"p1\">[</bpt>path<ept id=\"p1\">](../standard-library/path-class.md)</ept> class automatically performs all necessary string conversions.","pos":[1911,2019],"source":" The [path](../standard-library/path-class.md) class automatically performs all necessary string conversions."},{"content":"It accepts arguments of both wide and narrow character arrays, as well as <ph id=\"ph1\">`std::string`</ph> and <ph id=\"ph2\">`std::wstring`</ph> types formatted as UTF8 or UTF16.","pos":[2020,2160],"source":" It accepts arguments of both wide and narrow character arrays, as well as `std::string` and `std::wstring` types formatted as UTF8 or UTF16."},{"content":"The <ph id=\"ph1\">`path`</ph> class also automatically normalizes path separators.","pos":[2161,2224],"source":" The `path` class also automatically normalizes path separators."},{"content":"You can use a single forward slash as a directory separator in constructor arguments.","pos":[2225,2310]},{"content":"This enables you to use the same strings to store paths in both Windows and UNIX environments:","pos":[2311,2405]},{"content":"To concatenate two paths, you can use the overloaded <ph id=\"ph1\">`/`</ph> and <ph id=\"ph2\">`/=`</ph> operators, which are analogous to the <ph id=\"ph3\">`+`</ph> and <ph id=\"ph4\">`+=`</ph> operators on <ph id=\"ph5\">`std::string`</ph> and <ph id=\"ph6\">`std::wstring`</ph>.","pos":[2655,2818],"source":"To concatenate two paths, you can use the overloaded `/` and `/=` operators, which are analogous to the `+` and `+=` operators on `std::string` and `std::wstring`."},{"content":"The <ph id=\"ph1\">`path`</ph> object will conveniently supply the separators if you don’t.","pos":[2819,2890],"source":" The `path` object will conveniently supply the separators if you don’t."},{"pos":[3058,3073],"content":"Examining paths","linkify":"Examining paths","nodes":[{"content":"Examining paths","pos":[0,15]}]},{"content":"The path class has several methods that return information about various parts of the path itself, as distinct from the file system entity it might refer to.","pos":[3077,3234]},{"content":"You can get the root, the relative path, the file name, the file extension, and more.","pos":[3235,3320]},{"content":"You can iterate over a path object to examine all the folders in the hierarchy.","pos":[3321,3400]},{"content":"The following example shows how to iterate over a path (not the directory it refers to), and to retrieve information about its parts.","pos":[3401,3534]},{"content":"The code produces this output:","pos":[5029,5059]},{"pos":[5542,5557],"content":"Comparing paths","linkify":"Comparing paths","nodes":[{"content":"Comparing paths","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">`path`</ph> class overloads the same comparison operators as <ph id=\"ph2\">`std::string`</ph> and <ph id=\"ph3\">`std::wstring`</ph>.","pos":[5561,5654],"source":"The `path` class overloads the same comparison operators as `std::string` and `std::wstring`."},{"content":"When you compare two paths, you are performing a string comparison after the separators have been normalized.","pos":[5655,5764]},{"content":"If a trailing slash (or backslash) is missing it is not added and affects the comparison.","pos":[5765,5854]},{"content":"The following example demonstrates how path values compare:","pos":[5855,5914]},{"content":"To run this code, paste it into the full example above and uncomment the line that calls it in main.","pos":[6971,7071]},{"pos":[7081,7121],"content":"Converting between path and string types","linkify":"Converting between path and string types","nodes":[{"content":"Converting between path and string types","pos":[0,40]}]},{"content":"A <ph id=\"ph1\">`path`</ph> object is implicitly convertible to <ph id=\"ph2\">`std::wstring`</ph> or <ph id=\"ph3\">`std::string`</ph>.","pos":[7125,7202],"source":"A `path` object is implicitly convertible to `std::wstring` or `std::string`."},{"content":"This means you can pass a path to functions such as <bpt id=\"p1\">[</bpt>wofstream::open<ept id=\"p1\">](../standard-library/basic-ofstream-class.md#basic_ofstream__open)</ept>, as shown in this example:","pos":[7203,7365],"source":" This means you can pass a path to functions such as [wofstream::open](../standard-library/basic-ofstream-class.md#basic_ofstream__open), as shown in this example:"},{"pos":[7619,7650],"content":"Iterating directories and files","linkify":"Iterating directories and files","nodes":[{"content":"Iterating directories and files","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">\\&lt;</ph>filesystem&gt; header provides the <bpt id=\"p1\">[</bpt>directory_iterator<ept id=\"p1\">](../standard-library/directory-iterator-class.md)</ept> type to iterate over single directories, and the <bpt id=\"p2\">[</bpt>recursive_directory_iterator<ept id=\"p2\">](../standard-library/recursive-directory-iterator-class.md)</ept> class to iterate recursively over a directory and its subdirectories.","pos":[7654,7970],"source":"The \\<filesystem> header provides the [directory_iterator](../standard-library/directory-iterator-class.md) type to iterate over single directories, and the [recursive_directory_iterator](../standard-library/recursive-directory-iterator-class.md) class to iterate recursively over a directory and its subdirectories."},{"content":"After you construct an iterator by passing it a <ph id=\"ph1\">`path`</ph> object, the iterator points to the first directory_entry in the path.","pos":[7971,8095],"source":" After you construct an iterator by passing it a `path` object, the iterator points to the first directory_entry in the path."},{"content":"Create the end iterator by calling the default constructor.","pos":[8096,8155]},{"content":"When iterating through a directory, there are several kinds of items you might encounter, including but not limited to directories, files, symbolic links, and socket files.","pos":[8162,8334]},{"content":"The <ph id=\"ph1\">`directory_iterator`</ph> returns its items as <bpt id=\"p1\">[</bpt>directory_entry<ept id=\"p1\">](../standard-library/directory-entry-class.md)</ept>","pos":[8335,8444],"source":" The `directory_iterator` returns its items as [directory_entry](../standard-library/directory-entry-class.md)"}],"content":"---\ntitle: \"File System Navigation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: f7cc5f5e-a541-4e00-87c7-a3769ef6096d\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# File System Navigation\nThe \\<filesystem> header implements the C++ File System Technical Specification ISO/IEC TS 18822:2015 (Final draft: [ISO/IEC JTC 1/SC 22/WG 21 N4100](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf)) and has types and functions that enable you to write platform-independent code for navigating the file system. Because it is cross-platform, it contains APIs that are not relevant for Windows systems. For example, this means that `is_fifo(const path&)` always returns `false` on Windows. The header is based on a draft Technical Specification that was not voted into the C++17 standard as of Visual Studio 2015 RTM. Its members are found in the `std::experimental::filesystem` namespace.  \n  \n## Overview  \n Use the \\<filesystem> APIs for the following tasks:  \n  \n-   iterate over files and directories under a specified path  \n  \n-   get information about files including the time created, size, extension, and root directory  \n  \n-   compose, decompose, and compare paths  \n  \n-   create, copy and delete directories  \n  \n-   copy and delete files  \n  \n For more information about File IO using the Standard Library, see [iostream Programming](../standard-library/iostream-programming.md).  \n  \n## Paths  \n  \n### Constructing and composing paths  \n Paths in Windows (since XP) are stored natively in Unicode. The [path](../standard-library/path-class.md) class automatically performs all necessary string conversions. It accepts arguments of both wide and narrow character arrays, as well as `std::string` and `std::wstring` types formatted as UTF8 or UTF16. The `path` class also automatically normalizes path separators. You can use a single forward slash as a directory separator in constructor arguments. This enables you to use the same strings to store paths in both Windows and UNIX environments:  \n  \n```cpp  \npath pathToDisplay(L\"/FileSystemTest/SubDir3\");\n\n// OK!  \npath pathToDisplay2(L\"\\\\FileSystemTest\\\\SubDir3\");\n\n// Still OK as always  \npath pathToDisplay3(LR\"(\\FileSystemTest\\SubDir3)\");\n\n// Raw string literals are OK, too.  \n```  \n  \n To concatenate two paths, you can use the overloaded `/` and `/=` operators, which are analogous to the `+` and `+=` operators on `std::string` and `std::wstring`. The `path` object will conveniently supply the separators if you don’t.  \n  \n```cpp  \npath myRoot(\"C:/FileSystemTest\");\n\n// no trailing separator, no problem!  \nmyRoot /= path(\"SubDirRoot\");\n\n// C:/FileSystemTest/SubDirRoot  \n```  \n  \n### Examining paths  \n The path class has several methods that return information about various parts of the path itself, as distinct from the file system entity it might refer to. You can get the root, the relative path, the file name, the file extension, and more. You can iterate over a path object to examine all the folders in the hierarchy. The following example shows how to iterate over a path (not the directory it refers to), and to retrieve information about its parts.  \n  \n```cpp  \n  \n#include <string>  \n#include <iostream>  \n#include <sstream>  \n#include <filesystem>  \n  \nusing namespace std;  \nusing namespace std::experimental::filesystem;  \n  \nwstring  DisplayPathInfo()  \n{  \n    // This path may or may not refer to an existing file. We are   \n    // examining this path string, not file system objects.  \n    path pathToDisplay(L\"C:/FileSystemTest/SubDir3/SubDirLevel2/File2.txt \");  \n  \n    wostringstream wos;  \n    int i = 0;  \n    wos << L\"Displaying path info for: \" << pathToDisplay << endl;  \n    for (path::iterator itr = pathToDisplay.begin(); itr != pathToDisplay.end(); ++itr)  \n    {  \n        wos << L\"path part: \" << i++ << L\" = \" << *itr << endl;  \n    }  \n  \n    wos << L\"root_name() = \" << pathToDisplay.root_name() << endl  \n        << L\"root_path() = \" << pathToDisplay.root_path() << endl  \n        << L\"relative_path() = \" << pathToDisplay.relative_path() << endl  \n        << L\"parent_path() = \" << pathToDisplay.parent_path() << endl  \n        << L\"filename() = \" << pathToDisplay.filename() << endl  \n        << L\"stem() = \" << pathToDisplay.stem() << endl  \n        << L\"extension() = \" << pathToDisplay.extension() << endl;  \n  \n    return wos.str();  \n}  \n  \nvoid main(int argc, char* argv[])  \n{  \n    wcout << DisplayPathInfo() << endl;  \n    // wcout << ComparePaths() << endl; // see following example  \n    wcout << endl << L\"Press Enter to exit\" << endl;  \n    wstring input;  \n    getline(wcin, input);  \n}  \n```  \n  \n The code produces this output:  \n  \n```cpp  \nDisplaying path info for: C:\\FileSystemTest\\SubDir3\\SubDirLevel2\\File2.txt  \npath part: 0 = C:  \npath part: 1 = \\  \npath part: 2 = FileSystemTest  \npath part: 3 = SubDir3  \npath part: 4 = SubDirLevel2  \npath part: 5 = File2.txt  \nroot_name() = C:  \nroot_path() = C:\\  \nrelative_path() = FileSystemTest\\SubDir3\\SubDirLevel2\\File2.txt  \nparent_path() = C:\\FileSystemTest\\SubDir3\\SubDirLevel2  \nfilename() = File2.txt  \nstem() = File2  \nextension() = .txt  \n```  \n  \n### Comparing paths  \n The `path` class overloads the same comparison operators as `std::string` and `std::wstring`. When you compare two paths, you are performing a string comparison after the separators have been normalized. If a trailing slash (or backslash) is missing it is not added and affects the comparison. The following example demonstrates how path values compare:  \n  \n```cpp  \n \nwstring ComparePaths()  \n{  \n    path p0(L\"C:/Documents\");\n\n// no trailing separator  \n    path p1(L\"C:/Documents/\");\n\n//p0 <p1  \n    path p2(L\"C:/Documents/2013/\");\n\n// p1 <p2      \n    path p3(L\"C:/Documents/2013/Reports/\");\n\n// p2 <p3  \n    path p4(L\"C:/Documents/2014/\");\n// p3 <p4   \n    path p5(L\"D:/Documents/2013/Reports/\");\n\n// p4 <p5  \n \n    wostringstream wos;  \n    wos <<boolalpha <<\n    p0.wstring() <<L\" <\" <<p1.wstring() <<L\": \" <<(p0 <p1) <<endl <<\n    p1.wstring() <<L\" <\" <<p2.wstring() <<L\": \" <<(p1 <p2) <<endl <<\n    p2.wstring() <<L\" <\" <<p3.wstring() <<L\": \" <<(p2 <p3) <<endl <<\n    p3.wstring() <<L\" <\" <<p4.wstring() <<L\": \" <<(p3 <p4) <<endl <<\n    p4.wstring() <<L\" <\" <<p5.wstring() <<L\": \" <<(p4 <p5) <<endl;  \n    return wos.str();\n\n}  \n/* Output:  \nC:\\Documents <C:\\Documents\\: true  \nC:\\Documents\\ <C:\\Documents\\2013\\: true  \nC:\\Documents\\2013\\ <C:\\Documents\\2013\\Reports\\: true  \nC:\\Documents\\2013\\Reports\\ <C:\\Documents\\2014\\: true  \nC:\\Documents\\2014\\ <D:\\Documents\\2013\\Reports\\: true  \n*/  \n```  \n  \n To run this code, paste it into the full example above and uncomment the line that calls it in main.  \n  \n### Converting between path and string types  \n A `path` object is implicitly convertible to `std::wstring` or `std::string`. This means you can pass a path to functions such as [wofstream::open](../standard-library/basic-ofstream-class.md#basic_ofstream__open), as shown in this example:  \n  \n```cpp  \nwchar_t* p = L\"C:/test\";  \n    path filePath(p);\n\n    filePath /= L\"NewFile.txt\";  \n // Open, write to, and close the file.  \n    wofstream myFile;  \n    myFile.open(filePath);\n\n myFile <<L\"Lorem ipsum...\";  \n    myFile.close \n```  \n  \n## Iterating directories and files  \n The \\<filesystem> header provides the [directory_iterator](../standard-library/directory-iterator-class.md) type to iterate over single directories, and the [recursive_directory_iterator](../standard-library/recursive-directory-iterator-class.md) class to iterate recursively over a directory and its subdirectories. After you construct an iterator by passing it a `path` object, the iterator points to the first directory_entry in the path. Create the end iterator by calling the default constructor.  \n  \n When iterating through a directory, there are several kinds of items you might encounter, including but not limited to directories, files, symbolic links, and socket files. The `directory_iterator` returns its items as [directory_entry](../standard-library/directory-entry-class.md)\n"}