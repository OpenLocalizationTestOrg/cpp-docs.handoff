{"nodes":[{"pos":[12,95],"content":"How to: Use the Context Class to Implement a Cooperative Semaphore | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use the Context Class to Implement a Cooperative Semaphore | Microsoft Docs","pos":[0,83]}]},{"content":"How to: Use the Context Class to Implement a Cooperative Semaphore","pos":[685,751]},{"content":"This topic shows how to use the concurrency::Context class to implement a cooperative semaphore class.","pos":[752,854]},{"content":"The <ph id=\"ph1\">`Context`</ph> class lets you block or yield the current execution context.","pos":[861,935],"source":"The `Context` class lets you block or yield the current execution context."},{"content":"Blocking or yielding the current context is useful when the current context cannot proceed because a resource is not available.","pos":[936,1063]},{"content":"A <bpt id=\"p1\">*</bpt>semaphore<ept id=\"p1\">*</ept> is an example of one situation where the current execution context must wait for a resource to become available.","pos":[1064,1190],"source":" A *semaphore* is an example of one situation where the current execution context must wait for a resource to become available."},{"content":"A semaphore, like a critical section object, is a synchronization object that enables code in one context to have exclusive access to a resource.","pos":[1191,1336]},{"content":"However, unlike a critical section object, a semaphore enables more than one context to access the resource concurrently.","pos":[1337,1458]},{"content":"If the maximum number of contexts holds a semaphore lock, each additional context must wait for another context to release the lock.","pos":[1459,1591]},{"content":"To implement the semaphore class","pos":[1601,1633]},{"content":"Declare a class that is named <ph id=\"ph1\">`semaphore`</ph>.","pos":[1643,1685],"source":"Declare a class that is named `semaphore`."},{"content":"Add <ph id=\"ph1\">`public`</ph> and <ph id=\"ph2\">`private`</ph> sections to this class.","pos":[1686,1736],"source":" Add `public` and `private` sections to this class."},{"pos":[1754,1784],"content":"concrt-cooperative-semaphore#1"},{"pos":[1907,2234],"content":"In the <ph id=\"ph1\">`private`</ph> section of the <ph id=\"ph2\">`semaphore`</ph> class, declare a <bpt id=\"p1\">[</bpt>std::atomic<ept id=\"p1\">](../../standard-library/atomic-structure.md)</ept> variable that holds the semaphore count and a <bpt id=\"p2\">[</bpt>concurrency::concurrent_queue<ept id=\"p2\">](../../parallel/concrt/reference/concurrent-queue-class.md)</ept> object that holds the contexts that must wait to acquire the semaphore.","source":"In the `private` section of the `semaphore` class, declare a [std::atomic](../../standard-library/atomic-structure.md) variable that holds the semaphore count and a [concurrency::concurrent_queue](../../parallel/concrt/reference/concurrent-queue-class.md) object that holds the contexts that must wait to acquire the semaphore."},{"pos":[2252,2282],"content":"concrt-cooperative-semaphore#2"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`semaphore`</ph> class, implement the constructor.","pos":[2405,2481],"source":"In the `public` section of the `semaphore` class, implement the constructor."},{"content":"The constructor takes a <ph id=\"ph1\">`long long`</ph> value that specifies the maximum number of contexts that can concurrently hold the lock.","pos":[2482,2606],"source":" The constructor takes a `long long` value that specifies the maximum number of contexts that can concurrently hold the lock."},{"pos":[2624,2654],"content":"concrt-cooperative-semaphore#3"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`semaphore`</ph> class, implement the <ph id=\"ph3\">`acquire`</ph> method.","pos":[2775,2856],"source":"In the `public` section of the `semaphore` class, implement the `acquire` method."},{"content":"This method decrements the semaphore count as an atomic operation.","pos":[2857,2923]},{"content":"If the semaphore count becomes negative, add the current context to the end of the wait queue and call the <bpt id=\"p1\">[</bpt>concurrency::Context::Block<ept id=\"p1\">](reference/context-class.md#block)</ept> method to block the current context.","pos":[2924,3131],"source":" If the semaphore count becomes negative, add the current context to the end of the wait queue and call the [concurrency::Context::Block](reference/context-class.md#block) method to block the current context."},{"pos":[3149,3179],"content":"concrt-cooperative-semaphore#4"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`semaphore`</ph> class, implement the <ph id=\"ph3\">`release`</ph> method.","pos":[3302,3383],"source":"In the `public` section of the `semaphore` class, implement the `release` method."},{"content":"This method increments the semaphore count as an atomic operation.","pos":[3384,3450]},{"content":"If the semaphore count is negative before the increment operation, there is at least one context that is waiting for the lock.","pos":[3451,3577]},{"content":"In this case, unblock the context that is at the front of the wait queue.","pos":[3578,3651]},{"pos":[3669,3699],"content":"concrt-cooperative-semaphore#5"},{"content":"Example","pos":[3821,3828]},{"pos":[3832,4010],"content":"The <ph id=\"ph1\">`semaphore`</ph> class in this example behaves cooperatively because the <ph id=\"ph2\">`Context::Block`</ph> and <ph id=\"ph3\">`Context::Yield`</ph> methods yield execution so that the runtime can perform other tasks.","source":"The `semaphore` class in this example behaves cooperatively because the `Context::Block` and `Context::Yield` methods yield execution so that the runtime can perform other tasks."},{"content":"The <ph id=\"ph1\">`acquire`</ph> method decrements the counter, but it might not finish adding the context to the wait queue before another context calls the <ph id=\"ph2\">`release`</ph> method.","pos":[4017,4173],"source":"The `acquire` method decrements the counter, but it might not finish adding the context to the wait queue before another context calls the `release` method."},{"content":"To account for this, the <ph id=\"ph1\">`release`</ph> method uses a spin loop that calls the <bpt id=\"p1\">[</bpt>concurrency::Context::Yield<ept id=\"p1\">](reference/context-class.md#yield)</ept> method to wait for the <ph id=\"ph2\">`acquire`</ph> method to finish adding the context.","pos":[4174,4381],"source":" To account for this, the `release` method uses a spin loop that calls the [concurrency::Context::Yield](reference/context-class.md#yield) method to wait for the `acquire` method to finish adding the context."},{"content":"The <ph id=\"ph1\">`release`</ph> method can call the <ph id=\"ph2\">`Context::Unblock`</ph> method before the <ph id=\"ph3\">`acquire`</ph> method calls the <ph id=\"ph4\">`Context::Block`</ph> method.","pos":[4388,4510],"source":"The `release` method can call the `Context::Unblock` method before the `acquire` method calls the `Context::Block` method."},{"content":"You do not have to protect against this race condition because the runtime allows for these methods to be called in any order.","pos":[4511,4637]},{"content":"If the <ph id=\"ph1\">`release`</ph> method calls <ph id=\"ph2\">`Context::Unblock`</ph> before the <ph id=\"ph3\">`acquire`</ph> method calls <ph id=\"ph4\">`Context::Block`</ph> for the same context, that context remains unblocked.","pos":[4638,4791],"source":" If the `release` method calls `Context::Unblock` before the `acquire` method calls `Context::Block` for the same context, that context remains unblocked."},{"content":"The runtime only requires that each call to <ph id=\"ph1\">`Context::Block`</ph> is matched with a corresponding call to <ph id=\"ph2\">`Context::Unblock`</ph>.","pos":[4792,4912],"source":" The runtime only requires that each call to `Context::Block` is matched with a corresponding call to `Context::Unblock`."},{"content":"The following example shows the complete <ph id=\"ph1\">`semaphore`</ph> class.","pos":[4919,4978],"source":"The following example shows the complete `semaphore` class."},{"content":"The <ph id=\"ph1\">`wmain`</ph> function shows basic usage of this class.","pos":[4979,5032],"source":" The `wmain` function shows basic usage of this class."},{"content":"The <ph id=\"ph1\">`wmain`</ph> function uses the <bpt id=\"p1\">[</bpt>concurrency::parallel_for<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for)</ept> algorithm to create several tasks that require access to the semaphore.","pos":[5033,5221],"source":" The `wmain` function uses the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm to create several tasks that require access to the semaphore."},{"content":"Because three threads can hold the lock at any time, some tasks must wait for another task to finish and release the lock.","pos":[5222,5344]},{"pos":[5362,5392],"content":"concrt-cooperative-semaphore#6"},{"content":"This example produces the following sample output.","pos":[5512,5562]},{"content":"For more information about the <ph id=\"ph1\">`concurrent_queue`</ph> class, see <bpt id=\"p1\">[</bpt>Parallel Containers and Objects<ept id=\"p1\">](../../parallel/concrt/parallel-containers-and-objects.md)</ept>.","pos":[5840,5993],"source":"For more information about the `concurrent_queue` class, see [Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md)."},{"content":"For more information about the <ph id=\"ph1\">`parallel_for`</ph> algorithm, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[5994,6123],"source":" For more information about the `parallel_for` algorithm, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"content":"Compiling the Code","pos":[6132,6150]},{"pos":[6154,6357],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`cooperative-semaphore.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `cooperative-semaphore.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc cooperative-semaphore.cpp","pos":[6366,6404]},{"content":"Robust Programming","pos":[6415,6433]},{"content":"You can use the <bpt id=\"p1\">*</bpt>Resource Acquisition Is Initialization<ept id=\"p1\">*</ept> (RAII) pattern to limit access to a <ph id=\"ph1\">`semaphore`</ph> object to a given scope.","pos":[6437,6566],"source":"You can use the *Resource Acquisition Is Initialization* (RAII) pattern to limit access to a `semaphore` object to a given scope."},{"content":"Under the RAII pattern, a data structure is allocated on the stack.","pos":[6567,6634]},{"content":"That data structure initializes or acquires a resource when it is created and destroys or releases that resource when the data structure is destroyed.","pos":[6635,6785]},{"content":"The RAII pattern guarantees that the destructor is called before the enclosing scope exits.","pos":[6786,6877]},{"content":"Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple <ph id=\"ph1\">`return`</ph> statements.","pos":[6878,7008],"source":" Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple `return` statements."},{"content":"The following example defines a class that is named <ph id=\"ph1\">`scoped_lock`</ph>, which is defined in the <ph id=\"ph2\">`public`</ph> section of the <ph id=\"ph3\">`semaphore`</ph> class.","pos":[7015,7148],"source":"The following example defines a class that is named `scoped_lock`, which is defined in the `public` section of the `semaphore` class."},{"content":"The <ph id=\"ph1\">`scoped_lock`</ph> class resembles the <bpt id=\"p1\">[</bpt>concurrency::critical_section::scoped_lock<ept id=\"p1\">](reference/critical-section-class.md#critical_section__scoped_lock_class)</ept> and <bpt id=\"p2\">[</bpt>concurrency::reader_writer_lock::scoped_lock<ept id=\"p2\">](reference/reader-writer-lock-class.md#scoped_lock_class)</ept> classes.","pos":[7149,7421],"source":" The `scoped_lock` class resembles the [concurrency::critical_section::scoped_lock](reference/critical-section-class.md#critical_section__scoped_lock_class) and [concurrency::reader_writer_lock::scoped_lock](reference/reader-writer-lock-class.md#scoped_lock_class) classes."},{"content":"The constructor of the <ph id=\"ph1\">`semaphore::scoped_lock`</ph> class acquires access to the given <ph id=\"ph2\">`semaphore`</ph> object and the destructor releases access to that object.","pos":[7422,7574],"source":" The constructor of the `semaphore::scoped_lock` class acquires access to the given `semaphore` object and the destructor releases access to that object."},{"content":"concrt-cooperative-semaphore#7","pos":[7592,7622]},{"content":"The following example modifies the body of the work function that is passed to the <ph id=\"ph1\">`parallel_for`</ph> algorithm so that it uses RAII to ensure that the semaphore is released before the function returns.","pos":[7741,7939],"source":" The following example modifies the body of the work function that is passed to the `parallel_for` algorithm so that it uses RAII to ensure that the semaphore is released before the function returns."},{"content":"This technique ensures that the work function is exception-safe.","pos":[7940,8004]},{"pos":[8022,8052],"content":"concrt-cooperative-semaphore#8"},{"content":"See Also","pos":[8174,8182]},{"content":"Contexts","pos":[8187,8195]},{"content":"Parallel Containers and Objects","pos":[8237,8268]}],"content":"---\ntitle: \"How to: Use the Context Class to Implement a Cooperative Semaphore | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"cooperative semaphore implementing\"\n  - \"context class\"\nms.assetid: 22f4b9c0-ca22-4a68-90ba-39e99ea76696\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Use the Context Class to Implement a Cooperative Semaphore\nThis topic shows how to use the concurrency::Context class to implement a cooperative semaphore class.  \n  \n The `Context` class lets you block or yield the current execution context. Blocking or yielding the current context is useful when the current context cannot proceed because a resource is not available. A *semaphore* is an example of one situation where the current execution context must wait for a resource to become available. A semaphore, like a critical section object, is a synchronization object that enables code in one context to have exclusive access to a resource. However, unlike a critical section object, a semaphore enables more than one context to access the resource concurrently. If the maximum number of contexts holds a semaphore lock, each additional context must wait for another context to release the lock.  \n  \n### To implement the semaphore class  \n  \n1.  Declare a class that is named `semaphore`. Add `public` and `private` sections to this class.  \n  \n [!code-cpp[concrt-cooperative-semaphore#1](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_1.cpp)]  \n  \n2.  In the `private` section of the `semaphore` class, declare a [std::atomic](../../standard-library/atomic-structure.md) variable that holds the semaphore count and a [concurrency::concurrent_queue](../../parallel/concrt/reference/concurrent-queue-class.md) object that holds the contexts that must wait to acquire the semaphore.  \n  \n [!code-cpp[concrt-cooperative-semaphore#2](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_2.cpp)]  \n  \n3.  In the `public` section of the `semaphore` class, implement the constructor. The constructor takes a `long long` value that specifies the maximum number of contexts that can concurrently hold the lock.  \n  \n [!code-cpp[concrt-cooperative-semaphore#3](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_3.cpp)]  \n\n4.  In the `public` section of the `semaphore` class, implement the `acquire` method. This method decrements the semaphore count as an atomic operation. If the semaphore count becomes negative, add the current context to the end of the wait queue and call the [concurrency::Context::Block](reference/context-class.md#block) method to block the current context.  \n  \n [!code-cpp[concrt-cooperative-semaphore#4](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_4.cpp)]  \n  \n5.  In the `public` section of the `semaphore` class, implement the `release` method. This method increments the semaphore count as an atomic operation. If the semaphore count is negative before the increment operation, there is at least one context that is waiting for the lock. In this case, unblock the context that is at the front of the wait queue.  \n  \n [!code-cpp[concrt-cooperative-semaphore#5](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_5.cpp)]  \n  \n## Example  \n The `semaphore` class in this example behaves cooperatively because the `Context::Block` and `Context::Yield` methods yield execution so that the runtime can perform other tasks.  \n  \n The `acquire` method decrements the counter, but it might not finish adding the context to the wait queue before another context calls the `release` method. To account for this, the `release` method uses a spin loop that calls the [concurrency::Context::Yield](reference/context-class.md#yield) method to wait for the `acquire` method to finish adding the context.  \n  \n The `release` method can call the `Context::Unblock` method before the `acquire` method calls the `Context::Block` method. You do not have to protect against this race condition because the runtime allows for these methods to be called in any order. If the `release` method calls `Context::Unblock` before the `acquire` method calls `Context::Block` for the same context, that context remains unblocked. The runtime only requires that each call to `Context::Block` is matched with a corresponding call to `Context::Unblock`.  \n  \n The following example shows the complete `semaphore` class. The `wmain` function shows basic usage of this class. The `wmain` function uses the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm to create several tasks that require access to the semaphore. Because three threads can hold the lock at any time, some tasks must wait for another task to finish and release the lock.  \n  \n [!code-cpp[concrt-cooperative-semaphore#6](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_6.cpp)]  \n  \n This example produces the following sample output.  \n  \n```Output  \nIn loop iteration 5...  \nIn loop iteration 0...  \nIn loop iteration 6...  \nIn loop iteration 1...  \nIn loop iteration 2...  \nIn loop iteration 7...  \nIn loop iteration 3...  \nIn loop iteration 8...  \nIn loop iteration 9...  \nIn loop iteration 4...  \n```  \n  \n For more information about the `concurrent_queue` class, see [Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md). For more information about the `parallel_for` algorithm, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `cooperative-semaphore.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc cooperative-semaphore.cpp**  \n  \n## Robust Programming  \n You can use the *Resource Acquisition Is Initialization* (RAII) pattern to limit access to a `semaphore` object to a given scope. Under the RAII pattern, a data structure is allocated on the stack. That data structure initializes or acquires a resource when it is created and destroys or releases that resource when the data structure is destroyed. The RAII pattern guarantees that the destructor is called before the enclosing scope exits. Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple `return` statements.  \n  \n The following example defines a class that is named `scoped_lock`, which is defined in the `public` section of the `semaphore` class. The `scoped_lock` class resembles the [concurrency::critical_section::scoped_lock](reference/critical-section-class.md#critical_section__scoped_lock_class) and [concurrency::reader_writer_lock::scoped_lock](reference/reader-writer-lock-class.md#scoped_lock_class) classes. The constructor of the `semaphore::scoped_lock` class acquires access to the given `semaphore` object and the destructor releases access to that object.  \n  \n [!code-cpp[concrt-cooperative-semaphore#7](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_7.cpp)]    \n The following example modifies the body of the work function that is passed to the `parallel_for` algorithm so that it uses RAII to ensure that the semaphore is released before the function returns. This technique ensures that the work function is exception-safe.  \n  \n [!code-cpp[concrt-cooperative-semaphore#8](../../parallel/concrt/codesnippet/cpp/how-to-use-the-context-class-to-implement-a-cooperative-semaphore_8.cpp)]  \n  \n## See Also  \n [Contexts](../../parallel/concrt/contexts.md)   \n [Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md)\n\n"}