{"nodes":[{"pos":[12,48],"content":"Support for Unicode | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Support for Unicode | Microsoft Docs","pos":[0,36]}]},{"content":"Support for Unicode","pos":[810,829]},{"content":"Unicode is a specification for supporting all character sets, including those that cannot be represented in just one byte.","pos":[830,952]},{"content":"If you are programming for an international market, we recommend that you use either Unicode or <bpt id=\"p1\">[</bpt>multibyte character sets<ept id=\"p1\">](../text/support-for-multibyte-character-sets-mbcss.md)</ept> (MBCSs), or enable your program so you can build it for either by changing a switch.","pos":[953,1215],"source":" If you are programming for an international market, we recommend that you use either Unicode or [multibyte character sets](../text/support-for-multibyte-character-sets-mbcss.md) (MBCSs), or enable your program so you can build it for either by changing a switch."},{"content":"A wide character is a 2-byte multilingual character code.","pos":[1222,1279]},{"content":"Most characters used in modern computing worldwide, including technical symbols and special publishing characters, can be represented according to the Unicode specification as a wide character.","pos":[1280,1473]},{"content":"Characters that cannot be represented in just one wide character can be represented in a Unicode pair by using the Unicode surrogate feature.","pos":[1474,1615]},{"content":"Because every wide character is represented in a fixed size of 16 bits, using wide characters simplifies programming with international character sets.","pos":[1616,1767]},{"content":"A wide-character string is represented as a <bpt id=\"p1\">**</bpt>wchar_t[]<ept id=\"p1\">**</ept> array and is pointed to by a <ph id=\"ph1\">`wchar_t*`</ph> pointer.","pos":[1774,1880],"source":"A wide-character string is represented as a **wchar_t[]** array and is pointed to by a `wchar_t*` pointer."},{"content":"Any ASCII character can be represented as a wide character by prefixing the letter L to the character.","pos":[1881,1983]},{"content":"For example, L'\\0' is the terminating wide (16-bit) <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> character.","pos":[1984,2055],"source":" For example, L'\\0' is the terminating wide (16-bit) **NULL** character."},{"content":"Similarly, any ASCII string literal can be represented as a wide-character string literal by prefixing the letter L to the ASCII literal (L\"Hello\").","pos":[2056,2204]},{"content":"Generally, wide characters take more space in memory than multibyte characters but are faster to process.","pos":[2211,2316]},{"content":"In addition, only one locale can be represented at a time in multibyte encoding, whereas all character sets in the world are represented simultaneously by the Unicode representation.","pos":[2317,2499]},{"content":"The MFC framework is Unicode-enabled throughout, and MFC accomplishes Unicode enabling by using portable macros, as shown in the following table.","pos":[2506,2651]},{"content":"Portable Data Types in MFC","pos":[2661,2687]},{"content":"Non-portable data type","pos":[2694,2716]},{"content":"Replaced by this macro","pos":[2717,2739]},{"pos":[2814,2824],"content":"_<bpt id=\"p1\">**</bpt>TCHAR<ept id=\"p1\">**</ept>","source":"_**TCHAR**"},{"pos":[2829,2868],"content":"<bpt id=\"p1\">**</bpt>char<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>LPSTR (Win32 data type)<ept id=\"p2\">**</ept>","source":"**char\\***, **LPSTR (Win32 data type)**"},{"content":"const char<ph id=\"ph1\">\\*</ph>, LPCSTR (Win32 data type)","pos":[2884,2922],"source":"const char\\*, LPCSTR (Win32 data type)"},{"content":"Class <ph id=\"ph1\">`CString`</ph> uses <bpt id=\"p1\">**</bpt>_TCHAR<ept id=\"p1\">**</ept> as its base and provides constructors and operators for easy conversions.","pos":[2942,3047],"source":"Class `CString` uses **_TCHAR** as its base and provides constructors and operators for easy conversions."},{"content":"Most string operations for Unicode can be written by using the same logic used for handling the Windows ANSI character set, except that the basic unit of operation is a 16-bit character instead of an 8-bit byte.","pos":[3048,3259]},{"content":"Unlike working with multibyte character sets, you do not have to (and should not) treat a Unicode character as if it were two distinct bytes.","pos":[3260,3401]},{"content":"What do you want to do?","pos":[3410,3433]},{"content":"Install Unicode support via MFC","pos":[3444,3475]},{"content":"Enable Unicode in my program","pos":[3513,3541]},{"content":"Enable both Unicode and MBCS in my program","pos":[3588,3630]},{"content":"Use Unicode to create an internationalized program","pos":[3686,3736]},{"content":"Learn the benefits of Unicode, including how using Unicode makes my program more efficient on Windows 2000","pos":[3788,3894]},{"content":"Use wmain so I can pass wide-character arguments to my program","pos":[3956,4018]},{"content":"See a summary of Unicode programming","pos":[4066,4102]},{"content":"Learn about generic-text mappings for byte-width portability","pos":[4154,4214]},{"content":"See Also","pos":[4269,4277]},{"content":"Text and Strings","pos":[4282,4298]},{"content":"Support for Using wmain","pos":[4348,4371]}],"content":"---\ntitle: \"Support for Unicode | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"globalization [C++], character sets\"\n  - \"portable data types [MFC]\"\n  - \"Unicode [C++]\"\n  - \"wide characters [C++], about wide characters\"\n  - \"character sets [C++], Unicode\"\n  - \"localization [C++], character sets\"\n  - \"Unicode [C++], installing support\"\nms.assetid: 180f1d10-8543-4f79-85ce-293d3cb443bb\ncaps.latest.revision: 10\nauthor: \"ghogen\"\nms.author: \"ghogen\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Support for Unicode\nUnicode is a specification for supporting all character sets, including those that cannot be represented in just one byte. If you are programming for an international market, we recommend that you use either Unicode or [multibyte character sets](../text/support-for-multibyte-character-sets-mbcss.md) (MBCSs), or enable your program so you can build it for either by changing a switch.  \n  \n A wide character is a 2-byte multilingual character code. Most characters used in modern computing worldwide, including technical symbols and special publishing characters, can be represented according to the Unicode specification as a wide character. Characters that cannot be represented in just one wide character can be represented in a Unicode pair by using the Unicode surrogate feature. Because every wide character is represented in a fixed size of 16 bits, using wide characters simplifies programming with international character sets.  \n  \n A wide-character string is represented as a **wchar_t[]** array and is pointed to by a `wchar_t*` pointer. Any ASCII character can be represented as a wide character by prefixing the letter L to the character. For example, L'\\0' is the terminating wide (16-bit) **NULL** character. Similarly, any ASCII string literal can be represented as a wide-character string literal by prefixing the letter L to the ASCII literal (L\"Hello\").  \n  \n Generally, wide characters take more space in memory than multibyte characters but are faster to process. In addition, only one locale can be represented at a time in multibyte encoding, whereas all character sets in the world are represented simultaneously by the Unicode representation.  \n  \n The MFC framework is Unicode-enabled throughout, and MFC accomplishes Unicode enabling by using portable macros, as shown in the following table.  \n  \n### Portable Data Types in MFC  \n  \n|Non-portable data type|Replaced by this macro|  \n|-----------------------------|----------------------------|  \n|`char`|_**TCHAR**|  \n|**char\\***, **LPSTR (Win32 data type)**|`LPTSTR`|  \n|**const char\\*, LPCSTR (Win32 data type)**|`LPCTSTR`|  \n  \n Class `CString` uses **_TCHAR** as its base and provides constructors and operators for easy conversions. Most string operations for Unicode can be written by using the same logic used for handling the Windows ANSI character set, except that the basic unit of operation is a 16-bit character instead of an 8-bit byte. Unlike working with multibyte character sets, you do not have to (and should not) treat a Unicode character as if it were two distinct bytes.  \n  \n## What do you want to do?  \n  \n-   [Install Unicode support via MFC](../mfc/unicode-in-mfc.md)  \n  \n-   [Enable Unicode in my program](../text/international-enabling.md)  \n  \n-   [Enable both Unicode and MBCS in my program](../text/internationalization-strategies.md)  \n  \n-   [Use Unicode to create an internationalized program](../text/unicode-programming-summary.md)  \n  \n-   [Learn the benefits of Unicode, including how using Unicode makes my program more efficient on Windows 2000](../text/benefits-of-character-set-portability.md)  \n  \n-   [Use wmain so I can pass wide-character arguments to my program](../text/support-for-using-wmain.md)  \n  \n-   [See a summary of Unicode programming](../text/unicode-programming-summary.md)  \n  \n-   [Learn about generic-text mappings for byte-width portability](../text/generic-text-mappings-in-tchar-h.md)  \n  \n## See Also  \n [Text and Strings](../text/text-and-strings-in-visual-cpp.md)   \n [Support for Using wmain](../text/support-for-using-wmain.md)"}