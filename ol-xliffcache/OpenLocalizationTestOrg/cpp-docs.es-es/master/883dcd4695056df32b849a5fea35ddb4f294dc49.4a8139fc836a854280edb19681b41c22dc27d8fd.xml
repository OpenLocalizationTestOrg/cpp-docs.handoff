{"nodes":[{"pos":[12,73],"content":"Performance Considerations for Interop (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Performance Considerations for Interop (C++) | Microsoft Docs","pos":[0,61]}]},{"content":"Performance Considerations for Interop (C++)","pos":[852,896]},{"content":"This topic provides guidelines for reducing the effect of managed/unmanaged interop transitions on run-time performance.","pos":[897,1017]},{"content":"Visual C++ supports the same interoperability mechanisms as other .NET languages such as Visual Basic and C# (P/Invoke), but it also provides interop support that is specific to Visual C++ (C++ interop).","pos":[1024,1227]},{"content":"For performance-critical applications, it is important to understand the performance implications of each interop technique.","pos":[1228,1352]},{"content":"Regardless of the interop technique used, special transition sequences, called thunks, are required each time a managed function calls an unmanaged function and vice versa.","pos":[1359,1531]},{"content":"These thunks are inserted automatically by the Visual C++ compiler, but it is important to keep in mind that cumulatively, these transitions can be expensive in terms of performance.","pos":[1532,1714]},{"content":"Reducing Transitions","pos":[1723,1743]},{"content":"One way to avoid or reduce the cost of interop thunks is to refactor the interfaces involved to minimize managed/unmanaged transitions.","pos":[1747,1882]},{"content":"Dramatic performance improvements can be made by targeting chatty interfaces, which are those that involved frequent calls across the managed/unmanaged boundary.","pos":[1883,2044]},{"content":"A managed function that calls an unmanaged function in a tight loop, for example, is a good candidate for refactoring.","pos":[2045,2163]},{"content":"If the loop itself is moved to the unmanaged side, or if a managed alternative to the unmanaged call is created (perhaps be queuing data on the managed side and then marshaling it to the unmanaged API all at once after the loop), the number of transitions can be reduced significantly.","pos":[2164,2449]},{"content":"P/Invoke vs. C++ Interop","pos":[2458,2482]},{"content":"For .NET languages, such as Visual Basic and C#, the prescribed method for interoperating with native components is P/Invoke.","pos":[2486,2611]},{"content":"Because P/Invoke is supported by the .NET Framework, Visual C++ supports it as well, but Visual C++ also provides its own interoperability support, which is referred to as C++ Interop.","pos":[2612,2796]},{"content":"C++ Interop is preferred over P/Invoke because P/Invoke is not type-safe.","pos":[2797,2870]},{"content":"As a result, errors are primarily reported at run time, but C++ Interop also has performance advantages over P/Invoke.","pos":[2871,2989]},{"content":"Both techniques require several things to happen whenever a managed function calls an unmanaged function:","pos":[2996,3101]},{"content":"The function call arguments are marshaled from CLR to native types.","pos":[3111,3178]},{"content":"A managed-to-unmanaged thunk is executed.","pos":[3188,3229]},{"content":"The unmanaged function is called (using the native versions of the arguments).","pos":[3239,3317]},{"content":"An unmanaged-to-managed thunk is executed.","pos":[3327,3369]},{"content":"The return type and any \"out\" or \"in,out\" arguments are marshaled from native to CLR types.","pos":[3379,3470]},{"content":"The managed/unmanaged thunks are necessary for interop to work at all, but the data marshaling that is required depends on the data types involved, the function signature, and how the data will be used.","pos":[3477,3679]},{"content":"The data marshaling performed by C++ Interop is the simplest possible form: the parameters are simply copied across the managed/unmanaged boundary in a bitwise fashion; no transformation is performed at all.","pos":[3686,3893]},{"content":"For P/Invoke, this is only true if all parameters are simple, blittable types.","pos":[3894,3972]},{"content":"Otherwise, P/Invoke performs very robust steps to convert each managed parameter to an appropriate native type, and vice versa if the arguments are marked as \"out\", or \"in,out\".","pos":[3973,4150]},{"content":"In other words, C++ Interop uses the fastest possible method of data marshaling, whereas P/Invoke uses the most robust method.","pos":[4157,4283]},{"content":"This means that C++ Interop (in a fashion typical for C++) provides optimal performance by default, and the programmer is responsible for addressing cases where this behavior is not safe or appropriate.","pos":[4284,4486]},{"content":"C++ Interop therefore requires that data marshaling must be provided explicitly, but the advantage is that the programmer is free to decide what is appropriate, given the nature of the data, and how it is to be used.","pos":[4493,4709]},{"content":"Furthermore, although the behavior of P/Invoke data marshaling can be modified at customized to a degree, C++ Interop allows data marshaling to be customized on a call-by-call basis.","pos":[4710,4892]},{"content":"This is not possible with P/Invoke.","pos":[4893,4928]},{"pos":[4935,5067],"content":"For more information about C++ Interop, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>.","source":"For more information about C++ Interop, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)."},{"content":"See Also","pos":[5076,5084]},{"content":"Mixed (Native and Managed) Assemblies","pos":[5089,5126]}],"content":"---\ntitle: \"Performance Considerations for Interop (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"/clr compiler option [C++], interop performance considerations\"\n  - \"platform invoke [C++], interoperability\"\n  - \"interop [C++], performance consideraitons\"\n  - \"mixed assemblies [C++], performance considerations\"\n  - \"interoperability [C++], performance considerations\"\nms.assetid: bb9a282e-c3f8-40eb-a2fa-45d80d578932\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Performance Considerations for Interop (C++)\nThis topic provides guidelines for reducing the effect of managed/unmanaged interop transitions on run-time performance.  \n  \n Visual C++ supports the same interoperability mechanisms as other .NET languages such as Visual Basic and C# (P/Invoke), but it also provides interop support that is specific to Visual C++ (C++ interop). For performance-critical applications, it is important to understand the performance implications of each interop technique.  \n  \n Regardless of the interop technique used, special transition sequences, called thunks, are required each time a managed function calls an unmanaged function and vice versa. These thunks are inserted automatically by the Visual C++ compiler, but it is important to keep in mind that cumulatively, these transitions can be expensive in terms of performance.  \n  \n## Reducing Transitions  \n One way to avoid or reduce the cost of interop thunks is to refactor the interfaces involved to minimize managed/unmanaged transitions. Dramatic performance improvements can be made by targeting chatty interfaces, which are those that involved frequent calls across the managed/unmanaged boundary. A managed function that calls an unmanaged function in a tight loop, for example, is a good candidate for refactoring. If the loop itself is moved to the unmanaged side, or if a managed alternative to the unmanaged call is created (perhaps be queuing data on the managed side and then marshaling it to the unmanaged API all at once after the loop), the number of transitions can be reduced significantly.  \n  \n## P/Invoke vs. C++ Interop  \n For .NET languages, such as Visual Basic and C#, the prescribed method for interoperating with native components is P/Invoke. Because P/Invoke is supported by the .NET Framework, Visual C++ supports it as well, but Visual C++ also provides its own interoperability support, which is referred to as C++ Interop. C++ Interop is preferred over P/Invoke because P/Invoke is not type-safe. As a result, errors are primarily reported at run time, but C++ Interop also has performance advantages over P/Invoke.  \n  \n Both techniques require several things to happen whenever a managed function calls an unmanaged function:  \n  \n-   The function call arguments are marshaled from CLR to native types.  \n  \n-   A managed-to-unmanaged thunk is executed.  \n  \n-   The unmanaged function is called (using the native versions of the arguments).  \n  \n-   An unmanaged-to-managed thunk is executed.  \n  \n-   The return type and any \"out\" or \"in,out\" arguments are marshaled from native to CLR types.  \n  \n The managed/unmanaged thunks are necessary for interop to work at all, but the data marshaling that is required depends on the data types involved, the function signature, and how the data will be used.  \n  \n The data marshaling performed by C++ Interop is the simplest possible form: the parameters are simply copied across the managed/unmanaged boundary in a bitwise fashion; no transformation is performed at all. For P/Invoke, this is only true if all parameters are simple, blittable types. Otherwise, P/Invoke performs very robust steps to convert each managed parameter to an appropriate native type, and vice versa if the arguments are marked as \"out\", or \"in,out\".  \n  \n In other words, C++ Interop uses the fastest possible method of data marshaling, whereas P/Invoke uses the most robust method. This means that C++ Interop (in a fashion typical for C++) provides optimal performance by default, and the programmer is responsible for addressing cases where this behavior is not safe or appropriate.  \n  \n C++ Interop therefore requires that data marshaling must be provided explicitly, but the advantage is that the programmer is free to decide what is appropriate, given the nature of the data, and how it is to be used. Furthermore, although the behavior of P/Invoke data marshaling can be modified at customized to a degree, C++ Interop allows data marshaling to be customized on a call-by-call basis. This is not possible with P/Invoke.  \n  \n For more information about C++ Interop, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).  \n  \n## See Also  \n [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md)"}