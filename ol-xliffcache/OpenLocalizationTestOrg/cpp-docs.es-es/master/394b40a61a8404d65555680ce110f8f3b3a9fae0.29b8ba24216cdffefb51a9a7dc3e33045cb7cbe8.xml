{"nodes":[{"pos":[12,62],"content":"random_access_iterator_tag Struct | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"random_access_iterator_tag Struct | Microsoft Docs","pos":[0,50]}]},{"content":"random_access_iterator_tag Struct","pos":[813,846]},{"pos":[847,959],"content":"A class that provides a return type for <bpt id=\"p1\">**</bpt>iterator_category<ept id=\"p1\">**</ept> function that represents a random-access iterator.","source":"A class that provides a return type for **iterator_category** function that represents a random-access iterator."},{"content":"Syntax","pos":[968,974]},{"content":"Remarks","pos":[1073,1080]},{"content":"The category tag classes are used as compile tags for algorithm selection.","pos":[1084,1158]},{"content":"The template function needs to find the most specific category of its iterator argument so that it can use the most efficient algorithm at compile time.","pos":[1159,1311]},{"content":"For every iterator of type <ph id=\"ph1\">`Iterator`</ph>, <ph id=\"ph2\">`iterator_traits`&lt; `Iterator`&gt; </ph><bpt id=\"p1\">**</bpt>::iterator_category<ept id=\"p1\">**</ept> must be defined to be the most specific category tag that describes the iterator's behavior.","pos":[1312,1498],"source":" For every iterator of type `Iterator`, `iterator_traits`< `Iterator`> **::iterator_category** must be defined to be the most specific category tag that describes the iterator's behavior."},{"pos":[1505,1655],"content":"The type is the same as <bpt id=\"p1\">**</bpt>iterator<ept id=\"p1\">**</ept><ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p2\">**</bpt>Iter<ept id=\"p2\">**</ept><ph id=\"ph2\">&gt; </ph><bpt id=\"p3\">**</bpt>::iterator_category<ept id=\"p3\">**</ept> when <bpt id=\"p4\">**</bpt>Iter<ept id=\"p4\">**</ept> describes an object that can serve as a random-access iterator.","source":"The type is the same as **iterator**\\< **Iter**> **::iterator_category** when **Iter** describes an object that can serve as a random-access iterator."},{"content":"Example","pos":[1664,1671]},{"content":"Sample Output","pos":[3338,3351]},{"content":"The following output is for x86.","pos":[3355,3387]},{"content":"Requirements","pos":[3797,3809]},{"pos":[3813,3836],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>iterator&gt;","source":"**Header:** \\<iterator>"},{"pos":[3843,3861],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"content":"See Also","pos":[3870,3878]},{"content":"bidirectional_iterator_tag Struct","pos":[3883,3916]},{"content":"Thread Safety in the C++ Standard Library","pos":[3981,4022]},{"content":"C++ Standard Library Reference","pos":[4095,4125]}],"content":"---\ntitle: \"random_access_iterator_tag Struct | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"xutility/std::random_access_iterator_tag\"\n  - \"random_access_iterator_tag\"\n  - \"std.random_access_iterator_tag\"\n  - \"std::random_access_iterator_tag\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"random_access_iterator_tag class\"\n  - \"random_access_iterator_tag struct\"\nms.assetid: 59f5b741-c5b4-459c-ad0a-3b67cddeea23\ncaps.latest.revision: 23\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# random_access_iterator_tag Struct\nA class that provides a return type for **iterator_category** function that represents a random-access iterator.  \n  \n## Syntax  \n  \n```\nstruct random_access_iterator_tag    : public bidirectional_iterator_tag {};\n```  \n  \n## Remarks  \n The category tag classes are used as compile tags for algorithm selection. The template function needs to find the most specific category of its iterator argument so that it can use the most efficient algorithm at compile time. For every iterator of type `Iterator`, `iterator_traits`< `Iterator`> **::iterator_category** must be defined to be the most specific category tag that describes the iterator's behavior.  \n  \n The type is the same as **iterator**\\< **Iter**> **::iterator_category** when **Iter** describes an object that can serve as a random-access iterator.  \n  \n## Example  \n  \n```cpp  \n// iterator_rait.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <vector>  \n#include <iostream>  \n#include <list>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   vector<int> vi;  \n   vector<char> vc;  \n   list<char> lc;  \n   iterator_traits<vector<int>:: iterator>::iterator_category cati;  \n   iterator_traits<vector<char>:: iterator>::iterator_category catc;  \n   iterator_traits<list<char>:: iterator>::iterator_category catlc;  \n  \n   // These are both random-access iterators  \n   cout << \"The type of iterator for vector<int> is \"  \n       << \"identified by the tag:\\n \"   \n       << typeid ( cati ).name( ) << endl;  \n   cout << \"The type of iterator for vector<char> is \"  \n       << \"identified by the tag:\\n \"   \n       << typeid ( catc ).name( ) << endl;  \n   if ( typeid ( cati ) == typeid( catc ) )  \n      cout << \"The iterators are the same.\" << endl << endl;  \n   else  \n      cout << \"The iterators are not the same.\" << endl << endl;  \n  \n   // But the list iterator is bidirectinal, not random access  \n   cout << \"The type of iterator for list<char> is \"  \n       << \"identified by the tag:\\n \"   \n       << typeid (catlc).name( ) << endl;  \n  \n   // cout << ( typeid ( vi.begin( ) ) == typeid( vc.begin( ) ) ) << endl;  \n   if ( typeid ( vi.begin( ) ) == typeid( vc.begin( ) ) )  \n      cout << \"The iterators are the same.\" << endl;  \n   else  \n      cout << \"The iterators are not the same.\" << endl;  \n   // A random-access iterator is a bidirectional iterator.  \n   cout << ( void* ) dynamic_cast< iterator_traits<list<char>:: iterator>  \n          ::iterator_category* > ( &catc ) << endl;  \n}  \n```  \n  \n## Sample Output  \n The following output is for x86.  \n  \n```\nThe type of iterator for vector<int> is identified by the tag:\n    struct std::random_access_iterator_tag\nThe type of iterator for vector<char> is identified by the tag:\n    struct std::random_access_iterator_tag\nThe iterators are the same.\n\nThe type of iterator for list<char> is identified by the tag:\n    struct std::bidirectional_iterator_tag\nThe iterators are not the same.\n0012FF3B\n```  \n  \n## Requirements  \n **Header:** \\<iterator>  \n  \n **Namespace:** std  \n  \n## See Also  \n [bidirectional_iterator_tag Struct](../standard-library/bidirectional-iterator-tag-struct.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n\n\n"}