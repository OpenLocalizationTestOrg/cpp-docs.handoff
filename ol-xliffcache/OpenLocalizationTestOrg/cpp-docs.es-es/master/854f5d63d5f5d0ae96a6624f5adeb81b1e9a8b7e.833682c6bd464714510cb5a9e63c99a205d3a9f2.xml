{"nodes":[{"pos":[12,49],"content":"regex_iterator Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"regex_iterator Class | Microsoft Docs","pos":[0,37]}]},{"pos":[680,700],"content":"regex_iterator Class","linkify":"regex_iterator Class","nodes":[{"content":"regex_iterator Class","pos":[0,20]}]},{"content":"Iterator class for matches.","pos":[701,728]},{"pos":[737,743],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1784,1794],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for submatches.","pos":[1809,1842]},{"content":"The type of elements to match.","pos":[1859,1889]},{"content":"Traits class for elements.","pos":[1910,1936]},{"pos":[1945,1952],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes a constant forward iterator object.","pos":[1956,2020]},{"content":"It extracts objects of type <ph id=\"ph1\">`match_results&lt;BidIt&gt;`</ph> by repeatedly applying its regular expression object <ph id=\"ph2\">`*pregex`</ph> to the character sequence defined by the iterator range <ph id=\"ph3\">`[begin, end)`</ph>.","pos":[2021,2206],"source":" It extracts objects of type `match_results<BidIt>` by repeatedly applying its regular expression object `*pregex` to the character sequence defined by the iterator range `[begin, end)`."},{"pos":[2215,2223],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"See the following topics for examples on regular expressions:","pos":[2227,2288]},{"pos":[2296,2379],"content":"<bpt id=\"p1\">[</bpt>regex_match Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_match_function)</ept>","source":"[regex_match Function](../standard-library/regex-functions.md#regex_match_function)"},{"pos":[2387,2474],"content":"<bpt id=\"p1\">[</bpt>regex_replace Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_replace_function)</ept>","source":"[regex_replace Function](../standard-library/regex-functions.md#regex_replace_function)"},{"pos":[2482,2567],"content":"<bpt id=\"p1\">[</bpt>regex_search Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_search_function)</ept>","source":"[regex_search Function](../standard-library/regex-functions.md#regex_search_function)"},{"pos":[2575,2644],"content":"<bpt id=\"p1\">[</bpt>swap Function<ept id=\"p1\">](../standard-library/regex-functions.md#swap_function)</ept>","source":"[swap Function](../standard-library/regex-functions.md#swap_function)"},{"pos":[2653,2665],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2669,2689],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[2696,2714],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2724,2803],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__difference_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::difference_type","linkify":"<a name=\"regex_iterator__difference_type\"></a>  regex_iterator::difference_type","source":"<a name=\"regex_iterator__difference_type\"></a>  regex_iterator::difference_type"},{"content":"The type of an iterator difference.","pos":[2807,2842]},{"pos":[2909,2916],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2920,2963],"content":"The type is a synonym for <ph id=\"ph1\">`std::ptrdiff_t`</ph>.","source":"The type is a synonym for `std::ptrdiff_t`."},{"pos":[2973,2980],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3947,4030],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__iterator_category\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::iterator_category","linkify":"<a name=\"regex_iterator__iterator_category\"></a>  regex_iterator::iterator_category","source":"<a name=\"regex_iterator__iterator_category\"></a>  regex_iterator::iterator_category"},{"content":"The type of the iterator category.","pos":[4034,4068]},{"pos":[4148,4155],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[4159,4213],"content":"The type is a synonym for <ph id=\"ph1\">`std::forward_iterator_tag`</ph>.","source":"The type is a synonym for `std::forward_iterator_tag`."},{"pos":[4223,4230],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5199,5270],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__operator_neq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::operator!=","linkify":"<a name=\"regex_iterator__operator_neq\"></a>  regex_iterator::operator!=","source":"<a name=\"regex_iterator__operator_neq\"></a>  regex_iterator::operator!="},{"content":"Compares iterators for inequality.","pos":[5274,5308]},{"pos":[5379,5389],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator to compare to.","pos":[5404,5431]},{"pos":[5441,5448],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5452,5500],"content":"The member function returns <ph id=\"ph1\">`!(*this == right)`</ph>.","source":"The member function returns `!(*this == right)`."},{"pos":[5510,5517],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6480,6551],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__operator_star\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::operator*","linkify":"<a name=\"regex_iterator__operator_star\"></a>  regex_iterator::operator*","source":"<a name=\"regex_iterator__operator_star\"></a>  regex_iterator::operator*"},{"content":"Accesses the designated match.","pos":[6555,6585]},{"pos":[6651,6658],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6662,6715],"content":"The member function returns the stored value <ph id=\"ph1\">`match`</ph>.","source":"The member function returns the stored value `match`."},{"pos":[6725,6732],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7697,7772],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__operator_add_add\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::operator++","linkify":"<a name=\"regex_iterator__operator_add_add\"></a>  regex_iterator::operator++","source":"<a name=\"regex_iterator__operator_add_add\"></a>  regex_iterator::operator++"},{"content":"Increments the iterator.","pos":[7776,7800]},{"pos":[7889,7896],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If the current match has no characters the first operator calls <ph id=\"ph1\">`regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail | regex_constants::match_not_null)`</ph>; otherwise it advances the stored value <ph id=\"ph2\">`begin`</ph> to point to the first character after the current match then calls <ph id=\"ph3\">`regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail)`</ph>.","pos":[7900,8285],"source":"If the current match has no characters the first operator calls `regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail | regex_constants::match_not_null)`; otherwise it advances the stored value `begin` to point to the first character after the current match then calls `regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail)`."},{"content":"In either case, if the search fails the operator sets the object to an end-of-sequence iterator.","pos":[8286,8382]},{"content":"The operator returns the object.","pos":[8383,8415]},{"content":"The second operator makes a copy of the object, increments the object, then returns the copy.","pos":[8422,8515]},{"pos":[8525,8532],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9496,9565],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::operator=","linkify":"<a name=\"regex_iterator__operator_eq\"></a>  regex_iterator::operator=","source":"<a name=\"regex_iterator__operator_eq\"></a>  regex_iterator::operator="},{"content":"Compares iterators for equality.","pos":[9569,9601]},{"pos":[9672,9682],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator to compare to.","pos":[9697,9724]},{"pos":[9734,9741],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns true if <ph id=\"ph1\">`*this`</ph> and <ph id=\"ph2\">`right`</ph> are both end-of-sequence iterators or if neither is an end-of-sequence iterator and <ph id=\"ph3\">`begin == right.begin`</ph>, <ph id=\"ph4\">`end == right.end`</ph>, <ph id=\"ph5\">`pregex == right.pregex`</ph>, and <ph id=\"ph6\">`flags == right.flags`</ph>.","pos":[9745,9982],"source":"The member function returns true if `*this` and `right` are both end-of-sequence iterators or if neither is an end-of-sequence iterator and `begin == right.begin`, `end == right.end`, `pregex == right.pregex`, and `flags == right.flags`."},{"content":"Otherwise it returns false.","pos":[9983,10010]},{"pos":[10020,10027],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10990,11065],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__operator-_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::operator-<ph id=\"ph1\">&amp;gt;</ph>","linkify":"<a name=\"regex_iterator__operator-_gt_\"></a>  regex_iterator::operator-&gt;","source":"<a name=\"regex_iterator__operator-_gt_\"></a>  regex_iterator::operator-&gt;"},{"content":"Accesses the designated match.","pos":[11069,11099]},{"pos":[11167,11174],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11178,11246],"content":"The member function returns the address of the stored value <ph id=\"ph1\">`match`</ph>.","source":"The member function returns the address of the stored value `match`."},{"pos":[11256,11263],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12229,12292],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__pointer\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::pointer","linkify":"<a name=\"regex_iterator__pointer\"></a>  regex_iterator::pointer","source":"<a name=\"regex_iterator__pointer\"></a>  regex_iterator::pointer"},{"content":"The type of a pointer to a match.","pos":[12296,12329]},{"pos":[12395,12402],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12406,12497],"content":"The type is a synonym for <ph id=\"ph1\">`match_results&lt;BidIt&gt;*`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `match_results<BidIt>*`, where `BidIt` is the template parameter."},{"pos":[12507,12514],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13473,13540],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__reference\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::reference","linkify":"<a name=\"regex_iterator__reference\"></a>  regex_iterator::reference","source":"<a name=\"regex_iterator__reference\"></a>  regex_iterator::reference"},{"content":"The type of a reference to a match.","pos":[13544,13579]},{"pos":[13647,13654],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[13658,13749],"content":"The type is a synonym for <ph id=\"ph1\">`match_results&lt;BidIt&gt;&amp;`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `match_results<BidIt>&`, where `BidIt` is the template parameter."},{"pos":[13759,13766],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14727,14804],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__regex_iterator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::regex_iterator","linkify":"<a name=\"regex_iterator__regex_iterator\"></a>  regex_iterator::regex_iterator","source":"<a name=\"regex_iterator__regex_iterator\"></a>  regex_iterator::regex_iterator"},{"content":"Constructs the iterator.","pos":[14808,14832]},{"pos":[15022,15032],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to match.","pos":[15047,15078]},{"content":"End of sequence to match.","pos":[15095,15120]},{"content":"Regular expression for matches.","pos":[15135,15166]},{"content":"Flags for matches.","pos":[15180,15198]},{"pos":[15208,15215],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first constructor constructs an end-of-sequence iterator.","pos":[15219,15280]},{"content":"The second constructor initializes the stored value <ph id=\"ph1\">`begin`</ph> with <ph id=\"ph2\">`first`</ph>, the stored value <ph id=\"ph3\">`end`</ph> with <ph id=\"ph4\">`last`</ph>, the stored value <ph id=\"ph5\">`pregex`</ph> with <ph id=\"ph6\">`&amp;re`</ph>, and the stored value <ph id=\"ph7\">`flags`</ph> with <ph id=\"ph8\">`f`</ph>.","pos":[15281,15467],"source":" The second constructor initializes the stored value `begin` with `first`, the stored value `end` with `last`, the stored value `pregex` with `&re`, and the stored value `flags` with `f`."},{"content":"It then calls <ph id=\"ph1\">`regex_search(begin, end, match, *pregex, flags)`</ph>.","pos":[15468,15532],"source":" It then calls `regex_search(begin, end, match, *pregex, flags)`."},{"content":"If the search fails, the constructor sets the object to an end-of-sequence iterator.","pos":[15533,15617]},{"pos":[15627,15634],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16595,16664],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__regex_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::regex_type","linkify":"<a name=\"regex_iterator__regex_type\"></a>  regex_iterator::regex_type","source":"<a name=\"regex_iterator__regex_type\"></a>  regex_iterator::regex_type"},{"content":"The type of the regular expression to match.","pos":[16668,16712]},{"pos":[16787,16794],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[16798,16857],"content":"The typedef is a synonym for <ph id=\"ph1\">`basic_regex&lt;Elem, RXtraits&gt;`</ph>.","source":"The typedef is a synonym for `basic_regex<Elem, RXtraits>`."},{"pos":[16867,16874],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17836,17905],"content":"<bpt id=\"p1\">&lt;a name=\"regex_iterator__value_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_iterator::value_type","linkify":"<a name=\"regex_iterator__value_type\"></a>  regex_iterator::value_type","source":"<a name=\"regex_iterator__value_type\"></a>  regex_iterator::value_type"},{"content":"The type of a match.","pos":[17909,17929]},{"pos":[17997,18004],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18008,18098],"content":"The type is a synonym for <ph id=\"ph1\">`match_results&lt;BidIt&gt;`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `match_results<BidIt>`, where `BidIt` is the template parameter."},{"pos":[18108,18115],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19076,19084],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept><ph id=\"ph2\"> </ph>","pos":[19088,19129],"source":"[\\<regex>](../standard-library/regex.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_iterator<ept id=\"p1\">](../standard-library/regex-iterator-class.md)</ept>","pos":[19132,19194],"source":" [regex_iterator](../standard-library/regex-iterator-class.md)"}],"content":"---\ntitle: \"regex_iterator Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::tr1::regex_iterator\"\n  - \"std.tr1.regex_iterator\"\n  - \"regex_iterator\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regex_iterator class [TR1]\"\nms.assetid: 0cfd8fd0-5a95-4f3c-bf8e-6ef028c423d3\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# regex_iterator Class\nIterator class for matches.  \n  \n## Syntax  \n```\nclass regex_iterator {  \n   public:  \n   typedef basic_regex<Elem, RXtraits>  \n   regex_type;  \n   typedef match_results<BidIt> value_type;  \n   typedef std::forward_iterator_tag iterator_category;  \n   typedef std::ptrdiff_t difference_type;  \n   typedef const match_results<BidIt>* pointer;  \n   typedef const match_results<BidIt>& reference;  \n   regex_iterator();\n   regex_iterator(BidIt first, BidIt last,  \n   const regex_type& re,  \n   regex_constants::match_flag_type f = regex_constants::match_default);\n   bool operator==(const regex_iterator& right);\n   bool operator!=(const regex_iterator& right);\n   const match_results<BidIt>& operator*();\n   const match_results<BidIt> * operator->();\n   regex_iterator& operator++();\n   regex_iterator& operator++(int);\n   BidIt begin;\n   // exposition only  \n   BidIt end;\n   // exposition only  \n   regex_type *pregex;     // exposition only  \n   regex_constants::match_flag_type flags; // exposition only  \n   match_results<BidIt> match;\n   // exposition only  \n   };  \n```  \n#### Parameters  \n `BidIt`  \n The iterator type for submatches.  \n  \n `Elem`  \n The type of elements to match.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n## Remarks  \n The template class describes a constant forward iterator object. It extracts objects of type `match_results<BidIt>` by repeatedly applying its regular expression object `*pregex` to the character sequence defined by the iterator range `[begin, end)`.  \n  \n## Examples  \n See the following topics for examples on regular expressions:  \n  \n- [regex_match Function](../standard-library/regex-functions.md#regex_match_function)  \n  \n- [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function)  \n  \n- [regex_search Function](../standard-library/regex-functions.md#regex_search_function)  \n  \n- [swap Function](../standard-library/regex-functions.md#swap_function)  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"regex_iterator__difference_type\"></a>  regex_iterator::difference_type  \n The type of an iterator difference.  \n  \n```  \ntypedef std::ptrdiff_t difference_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `std::ptrdiff_t`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_difference_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__iterator_category\"></a>  regex_iterator::iterator_category  \n The type of the iterator category.  \n  \n```  \ntypedef std::forward_iterator_tag iterator_category;  \n```  \n  \n### Remarks  \n The type is a synonym for `std::forward_iterator_tag`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_iterator_category.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__operator_neq\"></a>  regex_iterator::operator!=  \n Compares iterators for inequality.  \n  \n```  \nbool operator!=(const regex_iterator& right);\n```  \n  \n### Parameters  \n `right`  \n The iterator to compare to.  \n  \n### Remarks  \n The member function returns `!(*this == right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_operator_ne.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__operator_star\"></a>  regex_iterator::operator*  \n Accesses the designated match.  \n  \n```  \nconst match_results<BidIt>& operator*();\n```  \n  \n### Remarks  \n The member function returns the stored value `match`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_operator_star.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__operator_add_add\"></a>  regex_iterator::operator++  \n Increments the iterator.  \n  \n```  \nregex_iterator& operator++();\n\nregex_iterator& operator++(int);\n```  \n  \n### Remarks  \n If the current match has no characters the first operator calls `regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail | regex_constants::match_not_null)`; otherwise it advances the stored value `begin` to point to the first character after the current match then calls `regex_search(begin, end, match, *pregex, flags | regex_constants::match_prev_avail)`. In either case, if the search fails the operator sets the object to an end-of-sequence iterator. The operator returns the object.  \n  \n The second operator makes a copy of the object, increments the object, then returns the copy.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_operator_inc.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__operator_eq\"></a>  regex_iterator::operator=  \n Compares iterators for equality.  \n  \n```  \nbool operator==(const regex_iterator& right);\n```  \n  \n### Parameters  \n `right`  \n The iterator to compare to.  \n  \n### Remarks  \n The member function returns true if `*this` and `right` are both end-of-sequence iterators or if neither is an end-of-sequence iterator and `begin == right.begin`, `end == right.end`, `pregex == right.pregex`, and `flags == right.flags`. Otherwise it returns false.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_operator_as.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__operator-_gt_\"></a>  regex_iterator::operator-&gt;  \n Accesses the designated match.  \n  \n```  \nconst match_results<BidIt> * operator->();\n```  \n  \n### Remarks  \n The member function returns the address of the stored value `match`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_operator_arrow.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__pointer\"></a>  regex_iterator::pointer  \n The type of a pointer to a match.  \n  \n```  \ntypedef match_results<BidIt> *pointer;  \n```  \n  \n### Remarks  \n The type is a synonym for `match_results<BidIt>*`, where `BidIt` is the template parameter.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_pointer.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__reference\"></a>  regex_iterator::reference  \n The type of a reference to a match.  \n  \n```  \ntypedef match_results<BidIt>& reference;  \n```  \n  \n### Remarks  \n The type is a synonym for `match_results<BidIt>&`, where `BidIt` is the template parameter.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_reference.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__regex_iterator\"></a>  regex_iterator::regex_iterator  \n Constructs the iterator.  \n  \n```  \nregex_iterator();\n\nregex_iterator(BidIt first,\n    BidIt last,  \n    const regex_type& re,\n    regex_constants::match_flag_type f = regex_constants::match_default);\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to match.  \n  \n `last`  \n End of sequence to match.  \n  \n `re`  \n Regular expression for matches.  \n  \n `f`  \n Flags for matches.  \n  \n### Remarks  \n The first constructor constructs an end-of-sequence iterator. The second constructor initializes the stored value `begin` with `first`, the stored value `end` with `last`, the stored value `pregex` with `&re`, and the stored value `flags` with `f`. It then calls `regex_search(begin, end, match, *pregex, flags)`. If the search fails, the constructor sets the object to an end-of-sequence iterator.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_construct.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__regex_type\"></a>  regex_iterator::regex_type  \n The type of the regular expression to match.  \n  \n```  \ntypedef basic_regex<Elem, RXtraits> regex_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for `basic_regex<Elem, RXtraits>`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_regex_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n##  <a name=\"regex_iterator__value_type\"></a>  regex_iterator::value_type  \n The type of a match.  \n  \n```  \ntypedef match_results<BidIt> value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `match_results<BidIt>`, where `BidIt` is the template parameter.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_iterator_value_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"axayaz\";   \n    Myiter::regex_type rx(\"a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == a  \nmatch == a  \nmatch == a  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)   \n [regex_iterator](../standard-library/regex-iterator-class.md)\n\n"}