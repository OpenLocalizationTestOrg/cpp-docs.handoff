{"nodes":[{"pos":[12,42],"content":"CSocket Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CSocket Class | Microsoft Docs","pos":[0,30]}]},{"pos":[665,678],"content":"CSocket Class","linkify":"CSocket Class","nodes":[{"content":"CSocket Class","pos":[0,13]}]},{"pos":[679,845],"content":"Derives from <ph id=\"ph1\">`CAsyncSocket`</ph>, inherits its encapsulation of the Windows Sockets API, and represents a higher level of abstraction than that of a <ph id=\"ph2\">`CAsyncSocket`</ph> object.","source":"Derives from `CAsyncSocket`, inherits its encapsulation of the Windows Sockets API, and represents a higher level of abstraction than that of a `CAsyncSocket` object."},{"pos":[854,860],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[922,929],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[939,958],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[965,969]},{"content":"Description","pos":[970,981]},{"pos":[1019,1056],"content":"<bpt id=\"p1\">[</bpt>CSocket::CSocket<ept id=\"p1\">](#csocket__csocket)</ept>","source":"[CSocket::CSocket](#csocket__csocket)"},{"pos":[1057,1087],"content":"Constructs a <ph id=\"ph1\">`CSocket`</ph> object.","source":"Constructs a `CSocket` object."},{"pos":[1098,1112],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1119,1123]},{"content":"Description","pos":[1124,1135]},{"pos":[1173,1208],"content":"<bpt id=\"p1\">[</bpt>CSocket::Attach<ept id=\"p1\">](#csocket__attach)</ept>","source":"[CSocket::Attach](#csocket__attach)"},{"pos":[1209,1260],"content":"Attaches a <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle to a <ph id=\"ph1\">`CSocket`</ph> object.","source":"Attaches a **SOCKET** handle to a `CSocket` object."},{"pos":[1265,1324],"content":"<bpt id=\"p1\">[</bpt>CSocket::CancelBlockingCall<ept id=\"p1\">](#csocket__cancelblockingcall)</ept>","source":"[CSocket::CancelBlockingCall](#csocket__cancelblockingcall)"},{"content":"Cancels a blocking call that is currently in progress.","pos":[1325,1379]},{"pos":[1384,1419],"content":"<bpt id=\"p1\">[</bpt>CSocket::Create<ept id=\"p1\">](#csocket__create)</ept>","source":"[CSocket::Create](#csocket__create)"},{"content":"Creates a socket.","pos":[1420,1437]},{"pos":[1442,1485],"content":"<bpt id=\"p1\">[</bpt>CSocket::FromHandle<ept id=\"p1\">](#csocket__fromhandle)</ept>","source":"[CSocket::FromHandle](#csocket__fromhandle)"},{"pos":[1486,1553],"content":"Returns a pointer to a <ph id=\"ph1\">`CSocket`</ph> object, given a <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle.","source":"Returns a pointer to a `CSocket` object, given a **SOCKET** handle."},{"pos":[1558,1601],"content":"<bpt id=\"p1\">[</bpt>CSocket::IsBlocking<ept id=\"p1\">](#csocket__isblocking)</ept>","source":"[CSocket::IsBlocking](#csocket__isblocking)"},{"content":"Determines whether a blocking call is in progress.","pos":[1602,1652]},{"pos":[1663,1680],"content":"Protected Methods","linkify":"Protected Methods","nodes":[{"content":"Protected Methods","pos":[0,17]}]},{"content":"Name","pos":[1687,1691]},{"content":"Description","pos":[1692,1703]},{"pos":[1741,1796],"content":"<bpt id=\"p1\">[</bpt>CSocket::OnMessagePending<ept id=\"p1\">](#csocket__onmessagepending)</ept>","source":"[CSocket::OnMessagePending](#csocket__onmessagepending)"},{"content":"Called to process pending messages while waiting for a blocking call to complete.","pos":[1797,1878]},{"pos":[1888,1895],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1899,2001],"content":"<ph id=\"ph1\">`CSocket`</ph> works with classes <ph id=\"ph2\">`CSocketFile`</ph> and <ph id=\"ph3\">`CArchive`</ph> to manage the sending and receiving of data.","source":"`CSocket` works with classes `CSocketFile` and `CArchive` to manage the sending and receiving of data."},{"content":"A <ph id=\"ph1\">`CSocket`</ph> object also provides blocking, which is essential to the synchronous operation of <ph id=\"ph2\">`CArchive`</ph>.","pos":[2008,2113],"source":"A `CSocket` object also provides blocking, which is essential to the synchronous operation of `CArchive`."},{"content":"Blocking functions, such as <ph id=\"ph1\">`Receive`</ph>, <ph id=\"ph2\">`Send`</ph>, <ph id=\"ph3\">`ReceiveFrom`</ph>, <ph id=\"ph4\">`SendTo`</ph>, and <ph id=\"ph5\">`Accept`</ph> (all inherited from <ph id=\"ph6\">`CAsyncSocket`</ph>), do not return a <ph id=\"ph7\">`WSAEWOULDBLOCK`</ph> error in <ph id=\"ph8\">`CSocket`</ph>.","pos":[2114,2288],"source":" Blocking functions, such as `Receive`, `Send`, `ReceiveFrom`, `SendTo`, and `Accept` (all inherited from `CAsyncSocket`), do not return a `WSAEWOULDBLOCK` error in `CSocket`."},{"content":"Instead, these functions wait until the operation completes.","pos":[2289,2349]},{"content":"Additionally, the original call will terminate with the error <ph id=\"ph1\">`WSAEINTR`</ph> if <ph id=\"ph2\">`CancelBlockingCall`</ph> is called while one of these functions is blocking.","pos":[2350,2498],"source":" Additionally, the original call will terminate with the error `WSAEINTR` if `CancelBlockingCall` is called while one of these functions is blocking."},{"content":"To use a <ph id=\"ph1\">`CSocket`</ph> object, call the constructor, then call <ph id=\"ph2\">`Create`</ph> to create the underlying <ph id=\"ph3\">`SOCKET`</ph> handle (type <ph id=\"ph4\">`SOCKET`</ph>).","pos":[2505,2630],"source":"To use a `CSocket` object, call the constructor, then call `Create` to create the underlying `SOCKET` handle (type `SOCKET`)."},{"content":"The default parameters of <ph id=\"ph1\">`Create`</ph> create a stream socket, but if you are not using the socket with a <ph id=\"ph2\">`CArchive`</ph> object, you can specify a parameter to create a datagram socket instead, or bind to a specific port to create a server socket.","pos":[2631,2870],"source":" The default parameters of `Create` create a stream socket, but if you are not using the socket with a `CArchive` object, you can specify a parameter to create a datagram socket instead, or bind to a specific port to create a server socket."},{"content":"Connect to a client socket using <ph id=\"ph1\">`Connect`</ph> on the client side and <ph id=\"ph2\">`Accept`</ph> on the server side.","pos":[2871,2965],"source":" Connect to a client socket using `Connect` on the client side and `Accept` on the server side."},{"content":"Then create a <ph id=\"ph1\">`CSocketFile`</ph> object and associate it to the <ph id=\"ph2\">`CSocket`</ph> object in the <ph id=\"ph3\">`CSocketFile`</ph> constructor.","pos":[2966,3075],"source":" Then create a `CSocketFile` object and associate it to the `CSocket` object in the `CSocketFile` constructor."},{"content":"Next, create a <ph id=\"ph1\">`CArchive`</ph> object for sending and one for receiving data (as needed), then associate them with the <ph id=\"ph2\">`CSocketFile`</ph> object in the <ph id=\"ph3\">`CArchive`</ph> constructor.","pos":[3076,3241],"source":" Next, create a `CArchive` object for sending and one for receiving data (as needed), then associate them with the `CSocketFile` object in the `CArchive` constructor."},{"content":"When communications are complete, destroy the <ph id=\"ph1\">`CArchive`</ph>, <ph id=\"ph2\">`CSocketFile`</ph>, and <ph id=\"ph3\">`CSocket`</ph> objects.","pos":[3242,3337],"source":" When communications are complete, destroy the `CArchive`, `CSocketFile`, and `CSocket` objects."},{"content":"The <ph id=\"ph1\">`SOCKET`</ph> data type is described in the article <bpt id=\"p1\">[</bpt>Windows Sockets: Background<ept id=\"p1\">](../../mfc/windows-sockets-background.md)</ept>.","pos":[3338,3460],"source":" The `SOCKET` data type is described in the article [Windows Sockets: Background](../../mfc/windows-sockets-background.md)."},{"content":"When you use <ph id=\"ph1\">`CArchive`</ph> with <ph id=\"ph2\">`CSocketFile`</ph> and <ph id=\"ph3\">`CSocket`</ph>, you might encounter a situation where <ph id=\"ph4\">`CSocket::Receive`</ph> enters a loop (by <ph id=\"ph5\">`PumpMessages(FD_READ)`</ph>) waiting for the requested amount of bytes.","pos":[3467,3667],"source":"When you use `CArchive` with `CSocketFile` and `CSocket`, you might encounter a situation where `CSocket::Receive` enters a loop (by `PumpMessages(FD_READ)`) waiting for the requested amount of bytes."},{"content":"This is because Windows sockets allow only one recv call per FD_READ notification, but <ph id=\"ph1\">`CSocketFile`</ph> and <ph id=\"ph2\">`CSocket`</ph> allow multiple recv calls per FD_READ.","pos":[3668,3821],"source":" This is because Windows sockets allow only one recv call per FD_READ notification, but `CSocketFile` and `CSocket` allow multiple recv calls per FD_READ."},{"content":"If you get an FD_READ when there is no data to read, the application hangs.","pos":[3822,3897]},{"content":"If you never get another FD_READ, the application stops communicating over the socket.","pos":[3898,3984]},{"content":"You can resolve this problem as follows.","pos":[3991,4031]},{"content":"In the <ph id=\"ph1\">`OnReceive`</ph> method of your socket class, call <ph id=\"ph2\">`CAsyncSocket::IOCtl(FIONREAD, ...)`</ph> before you call the <ph id=\"ph3\">`Serialize`</ph> method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes).","pos":[4032,4347],"source":" In the `OnReceive` method of your socket class, call `CAsyncSocket::IOCtl(FIONREAD, ...)` before you call the `Serialize` method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes)."},{"content":"If the size of the available data is less than needed, wait for all the data to be received and only then start the read operation.","pos":[4348,4479]},{"content":"In the following example, <ph id=\"ph1\">`m_dwExpected`</ph> is the approximate number of bytes that the user expects to receive.","pos":[4486,4595],"source":"In the following example, `m_dwExpected` is the approximate number of bytes that the user expects to receive."},{"content":"It is assumed that you declare it elsewhere in your code.","pos":[4596,4653]},{"pos":[4660,4751],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCSocketThread#4<ept id=\"p2\">](../../mfc/reference/codesnippet/cpp/csocket-class_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCSocketThread#4](../../mfc/reference/codesnippet/cpp/csocket-class_1.cpp)]"},{"pos":[4759,5018],"content":"[!NOTE]\n When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.","leadings":["","> "],"nodes":[{"content":" When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.","pos":[8,257],"nodes":[{"content":"When using MFC sockets in secondary threads in a statically linked MFC application, you must call <ph id=\"ph1\">`AfxSocketInit`</ph> in each thread that uses sockets to initialize the socket libraries.","pos":[1,183],"source":" When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries."},{"content":"By default, <ph id=\"ph1\">`AfxSocketInit`</ph> is called only in the primary thread.","pos":[184,249],"source":" By default, `AfxSocketInit` is called only in the primary thread."}]}]},{"pos":[5025,5545],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets in MFC<ept id=\"p1\">](../../mfc/windows-sockets-in-mfc.md)</ept>, <bpt id=\"p2\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p2\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>, <bpt id=\"p3\">[</bpt>Windows Sockets: How Sockets with Archives Work<ept id=\"p3\">](../../mfc/windows-sockets-how-sockets-with-archives-work.md)</ept>, <bpt id=\"p4\">[</bpt>Windows Sockets: Sequence of Operations<ept id=\"p4\">](../../mfc/windows-sockets-sequence-of-operations.md)</ept>, <bpt id=\"p5\">[</bpt>Windows Sockets: Example of Sockets Using Archives<ept id=\"p5\">](../../mfc/windows-sockets-example-of-sockets-using-archives.md)</ept>.","source":"For more information, see [Windows Sockets in MFC](../../mfc/windows-sockets-in-mfc.md), [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md), [Windows Sockets: How Sockets with Archives Work](../../mfc/windows-sockets-how-sockets-with-archives-work.md), [Windows Sockets: Sequence of Operations](../../mfc/windows-sockets-sequence-of-operations.md), [Windows Sockets: Example of Sockets Using Archives](../../mfc/windows-sockets-example-of-sockets-using-archives.md)."},{"pos":[5554,5575],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[5579,5626],"content":"<bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>","source":"[CObject](../../mfc/reference/cobject-class.md)"},{"pos":[5633,5690],"content":"<bpt id=\"p1\">[</bpt>CAsyncSocket<ept id=\"p1\">](../../mfc/reference/casyncsocket-class.md)</ept>","source":"[CAsyncSocket](../../mfc/reference/casyncsocket-class.md)"},{"pos":[5715,5727],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5731,5752],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxsock.h","source":"**Header:** afxsock.h"},{"pos":[5762,5809],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__attach\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::Attach","linkify":"<a name=\"csocket__attach\"></a>  CSocket::Attach","source":"<a name=\"csocket__attach\"></a>  CSocket::Attach"},{"pos":[5813,5892],"content":"Call this member function to attach the <ph id=\"ph1\">`hSocket`</ph> handle to a <ph id=\"ph2\">`CSocket`</ph> object.","source":"Call this member function to attach the `hSocket` handle to a `CSocket` object."},{"pos":[5946,5956],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains a handle to a socket.","pos":[5973,6003]},{"pos":[6013,6025],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function is successful.","pos":[6029,6067]},{"pos":[6077,6084],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6088,6227],"content":"The <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle is stored in the object's <bpt id=\"p2\">[</bpt>m_hSocket<ept id=\"p2\">](../../mfc/reference/casyncsocket-class.md#casyncsocket__m_hsocket)</ept> data member.","source":"The **SOCKET** handle is stored in the object's [m_hSocket](../../mfc/reference/casyncsocket-class.md#casyncsocket__m_hsocket) data member."},{"pos":[6234,6365],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[6375,6382],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6386,6475],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCSocketThread#1<ept id=\"p2\">](../../mfc/reference/codesnippet/cpp/csocket-class_2.h)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCSocketThread#1](../../mfc/reference/codesnippet/cpp/csocket-class_2.h)]"},{"pos":[6482,6573],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCSocketThread#2<ept id=\"p2\">](../../mfc/reference/codesnippet/cpp/csocket-class_3.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCSocketThread#2](../../mfc/reference/codesnippet/cpp/csocket-class_3.cpp)]"},{"pos":[6580,6671],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCSocketThread#3<ept id=\"p2\">](../../mfc/reference/codesnippet/cpp/csocket-class_4.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCSocketThread#3](../../mfc/reference/codesnippet/cpp/csocket-class_4.cpp)]"},{"pos":[6681,6752],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__cancelblockingcall\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::CancelBlockingCall","linkify":"<a name=\"csocket__cancelblockingcall\"></a>  CSocket::CancelBlockingCall","source":"<a name=\"csocket__cancelblockingcall\"></a>  CSocket::CancelBlockingCall"},{"content":"Call this member function to cancel a blocking call currently in progress.","pos":[6756,6830]},{"pos":[6882,6889],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This function cancels any outstanding blocking operation for this socket.","pos":[6893,6966]},{"content":"The original blocking call will terminate as soon as possible with the error <bpt id=\"p1\">**</bpt>WSAEINTR<ept id=\"p1\">**</ept>.","pos":[6967,7057],"source":" The original blocking call will terminate as soon as possible with the error **WSAEINTR**."},{"content":"In the case of a blocking <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> operation, the Windows Sockets implementation will terminate the blocking call as soon as possible, but it may not be possible for the socket resources to be released until the connection has completed (and then been reset) or timed out.","pos":[7064,7339],"source":"In the case of a blocking **Connect** operation, the Windows Sockets implementation will terminate the blocking call as soon as possible, but it may not be possible for the socket resources to be released until the connection has completed (and then been reset) or timed out."},{"content":"This is likely to be noticeable only if the application immediately tries to open a new socket (if no sockets are available), or to connect to the same peer.","pos":[7340,7497]},{"content":"Canceling any operation other than <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> can leave the socket in an indeterminate state.","pos":[7504,7597],"source":"Canceling any operation other than **Accept** can leave the socket in an indeterminate state."},{"content":"If an application cancels a blocking operation on a socket, the only operation that the application can depend on being able to perform on the socket is a call to <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept>, although other operations may work on some Windows Sockets implementations.","pos":[7598,7847],"source":" If an application cancels a blocking operation on a socket, the only operation that the application can depend on being able to perform on the socket is a call to **Close**, although other operations may work on some Windows Sockets implementations."},{"content":"If you desire maximum portability for your application, you must be careful not to depend on performing operations after a cancel.","pos":[7848,7978]},{"pos":[7985,8116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[8126,8173],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__create\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::Create","linkify":"<a name=\"csocket__create\"></a>  CSocket::Create","source":"<a name=\"csocket__create\"></a>  CSocket::Create"},{"pos":[8177,8291],"content":"Call the <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> member function after constructing a socket object to create the Windows socket and attach it.","source":"Call the **Create** member function after constructing a socket object to create the Windows socket and attach it."},{"pos":[8433,8443],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A particular port to be used with the socket, or 0 if you want MFC to select a port.","pos":[8464,8548]},{"content":"<bpt id=\"p1\"> **</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>SOCK_DGRAM<ept id=\"p2\">**</ept>.","pos":[8571,8606],"source":" **SOCK_STREAM** or **SOCK_DGRAM**."},{"content":"A pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\".","pos":[8636,8752]},{"content":"Passing the <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> string for this parameter indicates the <bpt id=\"p2\">**</bpt>CSocket<ept id=\"p2\">**</ept> instance should listen for client activity on all network interfaces.","pos":[8753,8895],"source":" Passing the **NULL** string for this parameter indicates the **CSocket** instance should listen for client activity on all network interfaces."},{"pos":[8905,8917],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[8921,9042],"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <ph id=\"ph1\">`GetLastError`</ph>.","source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling `GetLastError`."},{"pos":[9052,9059],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> then calls <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept> to bind the socket to the specified address.","pos":[9063,9138],"source":"**Create** then calls **Bind** to bind the socket to the specified address."},{"content":"The following socket types are supported:","pos":[9139,9180]},{"content":"<bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> Provides sequenced, reliable, two-way, connection-based byte streams.","pos":[9188,9273],"source":"**SOCK_STREAM** Provides sequenced, reliable, two-way, connection-based byte streams."},{"content":"Uses Transmission Control Protocol (TCP) for the Internet address family.","pos":[9274,9347]},{"content":"<bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.","pos":[9355,9479],"source":"**SOCK_DGRAM** Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length."},{"content":"Uses User Datagram Protocol (UDP) for the Internet address family.","pos":[9480,9546]},{"content":"To use this option, you must not use the socket with a <ph id=\"ph1\">`CArchive`</ph> object.","pos":[9547,9620],"source":" To use this option, you must not use the socket with a `CArchive` object."},{"pos":[9632,9938],"content":"[!NOTE]\nThe **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.","leadings":["","    >  "],"nodes":[{"content":"The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.","pos":[8,299],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> member function takes a reference to a new, empty <ph id=\"ph1\">`CSocket`</ph> object as its parameter.","pos":[0,99],"source":"The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter."},{"content":"You must construct this object before you call <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept>.","pos":[100,158],"source":" You must construct this object before you call **Accept**."},{"content":"Keep in mind that if this socket object goes out of scope, the connection closes.","pos":[159,240]},{"content":"Do not call <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> for this new socket object.","pos":[241,291],"source":" Do not call **Create** for this new socket object."}]}]},{"pos":[9945,10303],"content":"For more information about stream and datagram sockets, see the articles <bpt id=\"p1\">[</bpt>Windows Sockets: Background<ept id=\"p1\">](../../mfc/windows-sockets-background.md)</ept>, <bpt id=\"p2\">[</bpt>Windows Sockets: Ports and Socket Addresses<ept id=\"p2\">](../../mfc/windows-sockets-ports-and-socket-addresses.md)</ept>, and <bpt id=\"p3\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p3\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information about stream and datagram sockets, see the articles [Windows Sockets: Background](../../mfc/windows-sockets-background.md), [Windows Sockets: Ports and Socket Addresses](../../mfc/windows-sockets-ports-and-socket-addresses.md), and [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[10313,10362],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__csocket\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::CSocket","linkify":"<a name=\"csocket__csocket\"></a>  CSocket::CSocket","source":"<a name=\"csocket__csocket\"></a>  CSocket::CSocket"},{"pos":[10366,10396],"content":"Constructs a <ph id=\"ph1\">`CSocket`</ph> object.","source":"Constructs a `CSocket` object."},{"pos":[10432,10439],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[10443,10508],"content":"After construction, you must call the <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> member function.","source":"After construction, you must call the **Create** member function."},{"pos":[10515,10646],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[10656,10711],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__fromhandle\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::FromHandle","linkify":"<a name=\"csocket__fromhandle\"></a>  CSocket::FromHandle","source":"<a name=\"csocket__fromhandle\"></a>  CSocket::FromHandle"},{"pos":[10715,10755],"content":"Returns a pointer to a <ph id=\"ph1\">`CSocket`</ph> object.","source":"Returns a pointer to a `CSocket` object."},{"pos":[10831,10841],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains a handle to a socket.","pos":[10858,10888]},{"pos":[10898,10910],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[10914,11013],"content":"A pointer to a <ph id=\"ph1\">`CSocket`</ph> object, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if there is no <ph id=\"ph2\">`CSocket`</ph> object attached to <ph id=\"ph3\">`hSocket`</ph>.","source":"A pointer to a `CSocket` object, or **NULL** if there is no `CSocket` object attached to `hSocket`."},{"pos":[11023,11030],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11034,11195],"content":"When given a <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle, if a <ph id=\"ph1\">`CSocket`</ph> object is not attached to the handle, the member function returns <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept> and does not create a temporary object.","source":"When given a **SOCKET** handle, if a `CSocket` object is not attached to the handle, the member function returns **NULL** and does not create a temporary object."},{"pos":[11202,11333],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[11343,11398],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__isblocking\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::IsBlocking","linkify":"<a name=\"csocket__isblocking\"></a>  CSocket::IsBlocking","source":"<a name=\"csocket__isblocking\"></a>  CSocket::IsBlocking"},{"content":"Call this member function to determine if a blocking call is in progress.","pos":[11402,11475]},{"pos":[11519,11531],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the socket is blocking; otherwise 0.","pos":[11535,11582]},{"pos":[11592,11599],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11603,11734],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[11744,11811],"content":"<bpt id=\"p1\">&lt;a name=\"csocket__onmessagepending\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSocket::OnMessagePending","linkify":"<a name=\"csocket__onmessagepending\"></a>  CSocket::OnMessagePending","source":"<a name=\"csocket__onmessagepending\"></a>  CSocket::OnMessagePending"},{"content":"Override this member function to look for particular messages from Windows and respond to them in your socket.","pos":[11815,11925]},{"pos":[11983,11995],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the message was handled; otherwise 0.","pos":[11999,12047]},{"pos":[12057,12064],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This is an advanced overridable.","pos":[12068,12100]},{"content":"The framework calls <ph id=\"ph1\">`OnMessagePending`</ph> while the socket is pumping Windows messages to give you an opportunity to deal with messages of interest to your application.","pos":[12107,12272],"source":"The framework calls `OnMessagePending` while the socket is pumping Windows messages to give you an opportunity to deal with messages of interest to your application."},{"content":"For examples of how you might use <ph id=\"ph1\">`OnMessagePending`</ph>, see the article <bpt id=\"p1\">[</bpt>Windows Sockets: Deriving from Socket Classes<ept id=\"p1\">](../../mfc/windows-sockets-deriving-from-socket-classes.md)</ept>.","pos":[12273,12450],"source":" For examples of how you might use `OnMessagePending`, see the article [Windows Sockets: Deriving from Socket Classes](../../mfc/windows-sockets-deriving-from-socket-classes.md)."},{"pos":[12457,12588],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[12597,12605],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>CAsyncSocket Class<ept id=\"p1\">](../../mfc/reference/casyncsocket-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[12609,12673],"source":"[CAsyncSocket Class](../../mfc/reference/casyncsocket-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept><ph id=\"ph1\"> </ph>","pos":[12676,12725],"source":" [Hierarchy Chart](../../mfc/hierarchy-chart.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CAsyncSocket Class<ept id=\"p1\">](../../mfc/reference/casyncsocket-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[12728,12793],"source":" [CAsyncSocket Class](../../mfc/reference/casyncsocket-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CSocketFile Class<ept id=\"p1\">](../../mfc/reference/csocketfile-class.md)</ept>","pos":[12796,12858],"source":" [CSocketFile Class](../../mfc/reference/csocketfile-class.md)"}],"content":"---\ntitle: \"CSocket Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CSocket\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"WinSock CSocket class\"\n  - \"CSocket class\"\n  - \"SOCKET handle\"\n  - \"sockets classes\"\nms.assetid: 7f23c081-d24d-42e3-b511-8053ca53d729\ncaps.latest.revision: 30\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CSocket Class\nDerives from `CAsyncSocket`, inherits its encapsulation of the Windows Sockets API, and represents a higher level of abstraction than that of a `CAsyncSocket` object.  \n  \n## Syntax  \n  \n```  \nclass CSocket : public CAsyncSocket  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CSocket::CSocket](#csocket__csocket)|Constructs a `CSocket` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CSocket::Attach](#csocket__attach)|Attaches a **SOCKET** handle to a `CSocket` object.|  \n|[CSocket::CancelBlockingCall](#csocket__cancelblockingcall)|Cancels a blocking call that is currently in progress.|  \n|[CSocket::Create](#csocket__create)|Creates a socket.|  \n|[CSocket::FromHandle](#csocket__fromhandle)|Returns a pointer to a `CSocket` object, given a **SOCKET** handle.|  \n|[CSocket::IsBlocking](#csocket__isblocking)|Determines whether a blocking call is in progress.|  \n  \n### Protected Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CSocket::OnMessagePending](#csocket__onmessagepending)|Called to process pending messages while waiting for a blocking call to complete.|  \n  \n## Remarks  \n `CSocket` works with classes `CSocketFile` and `CArchive` to manage the sending and receiving of data.  \n  \n A `CSocket` object also provides blocking, which is essential to the synchronous operation of `CArchive`. Blocking functions, such as `Receive`, `Send`, `ReceiveFrom`, `SendTo`, and `Accept` (all inherited from `CAsyncSocket`), do not return a `WSAEWOULDBLOCK` error in `CSocket`. Instead, these functions wait until the operation completes. Additionally, the original call will terminate with the error `WSAEINTR` if `CancelBlockingCall` is called while one of these functions is blocking.  \n  \n To use a `CSocket` object, call the constructor, then call `Create` to create the underlying `SOCKET` handle (type `SOCKET`). The default parameters of `Create` create a stream socket, but if you are not using the socket with a `CArchive` object, you can specify a parameter to create a datagram socket instead, or bind to a specific port to create a server socket. Connect to a client socket using `Connect` on the client side and `Accept` on the server side. Then create a `CSocketFile` object and associate it to the `CSocket` object in the `CSocketFile` constructor. Next, create a `CArchive` object for sending and one for receiving data (as needed), then associate them with the `CSocketFile` object in the `CArchive` constructor. When communications are complete, destroy the `CArchive`, `CSocketFile`, and `CSocket` objects. The `SOCKET` data type is described in the article [Windows Sockets: Background](../../mfc/windows-sockets-background.md).  \n  \n When you use `CArchive` with `CSocketFile` and `CSocket`, you might encounter a situation where `CSocket::Receive` enters a loop (by `PumpMessages(FD_READ)`) waiting for the requested amount of bytes. This is because Windows sockets allow only one recv call per FD_READ notification, but `CSocketFile` and `CSocket` allow multiple recv calls per FD_READ. If you get an FD_READ when there is no data to read, the application hangs. If you never get another FD_READ, the application stops communicating over the socket.  \n  \n You can resolve this problem as follows. In the `OnReceive` method of your socket class, call `CAsyncSocket::IOCtl(FIONREAD, ...)` before you call the `Serialize` method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes). If the size of the available data is less than needed, wait for all the data to be received and only then start the read operation.  \n  \n In the following example, `m_dwExpected` is the approximate number of bytes that the user expects to receive. It is assumed that you declare it elsewhere in your code.  \n  \n [!code-cpp[NVC_MFCSocketThread#4](../../mfc/reference/codesnippet/cpp/csocket-class_1.cpp)]  \n  \n> [!NOTE]\n>  When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.  \n  \n For more information, see [Windows Sockets in MFC](../../mfc/windows-sockets-in-mfc.md), [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md), [Windows Sockets: How Sockets with Archives Work](../../mfc/windows-sockets-how-sockets-with-archives-work.md), [Windows Sockets: Sequence of Operations](../../mfc/windows-sockets-sequence-of-operations.md), [Windows Sockets: Example of Sockets Using Archives](../../mfc/windows-sockets-example-of-sockets-using-archives.md).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n [CAsyncSocket](../../mfc/reference/casyncsocket-class.md)  \n  \n `CSocket`  \n  \n## Requirements  \n **Header:** afxsock.h  \n  \n##  <a name=\"csocket__attach\"></a>  CSocket::Attach  \n Call this member function to attach the `hSocket` handle to a `CSocket` object.  \n  \n```  \nBOOL Attach(SOCKET hSocket);\n```  \n  \n### Parameters  \n `hSocket`  \n Contains a handle to a socket.  \n  \n### Return Value  \n Nonzero if the function is successful.  \n  \n### Remarks  \n The **SOCKET** handle is stored in the object's [m_hSocket](../../mfc/reference/casyncsocket-class.md#casyncsocket__m_hsocket) data member.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCSocketThread#1](../../mfc/reference/codesnippet/cpp/csocket-class_2.h)]  \n  \n [!code-cpp[NVC_MFCSocketThread#2](../../mfc/reference/codesnippet/cpp/csocket-class_3.cpp)]  \n  \n [!code-cpp[NVC_MFCSocketThread#3](../../mfc/reference/codesnippet/cpp/csocket-class_4.cpp)]  \n  \n##  <a name=\"csocket__cancelblockingcall\"></a>  CSocket::CancelBlockingCall  \n Call this member function to cancel a blocking call currently in progress.  \n  \n```  \nvoid CancelBlockingCall();\n```  \n  \n### Remarks  \n This function cancels any outstanding blocking operation for this socket. The original blocking call will terminate as soon as possible with the error **WSAEINTR**.  \n  \n In the case of a blocking **Connect** operation, the Windows Sockets implementation will terminate the blocking call as soon as possible, but it may not be possible for the socket resources to be released until the connection has completed (and then been reset) or timed out. This is likely to be noticeable only if the application immediately tries to open a new socket (if no sockets are available), or to connect to the same peer.  \n  \n Canceling any operation other than **Accept** can leave the socket in an indeterminate state. If an application cancels a blocking operation on a socket, the only operation that the application can depend on being able to perform on the socket is a call to **Close**, although other operations may work on some Windows Sockets implementations. If you desire maximum portability for your application, you must be careful not to depend on performing operations after a cancel.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"csocket__create\"></a>  CSocket::Create  \n Call the **Create** member function after constructing a socket object to create the Windows socket and attach it.  \n  \n```  \nBOOL Create(\n    UINT nSocketPort = 0,  \n    int nSocketType = SOCK_STREAM,  \n    LPCTSTR lpszSocketAddress = NULL);\n```  \n  \n### Parameters  \n `nSocketPort`  \n A particular port to be used with the socket, or 0 if you want MFC to select a port.  \n  \n `nSocketType`  \n **SOCK_STREAM** or **SOCK_DGRAM**.  \n  \n `lpszSocketAddress`  \n A pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\". Passing the **NULL** string for this parameter indicates the **CSocket** instance should listen for client activity on all network interfaces.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling `GetLastError`.  \n  \n### Remarks  \n **Create** then calls **Bind** to bind the socket to the specified address. The following socket types are supported:  \n  \n- **SOCK_STREAM** Provides sequenced, reliable, two-way, connection-based byte streams. Uses Transmission Control Protocol (TCP) for the Internet address family.  \n  \n- **SOCK_DGRAM** Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. Uses User Datagram Protocol (UDP) for the Internet address family. To use this option, you must not use the socket with a `CArchive` object.  \n  \n    > [!NOTE]\n    >  The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.  \n  \n For more information about stream and datagram sockets, see the articles [Windows Sockets: Background](../../mfc/windows-sockets-background.md), [Windows Sockets: Ports and Socket Addresses](../../mfc/windows-sockets-ports-and-socket-addresses.md), and [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"csocket__csocket\"></a>  CSocket::CSocket  \n Constructs a `CSocket` object.  \n  \n```  \nCSocket();\n```  \n  \n### Remarks  \n After construction, you must call the **Create** member function.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"csocket__fromhandle\"></a>  CSocket::FromHandle  \n Returns a pointer to a `CSocket` object.  \n  \n```  \nstatic CSocket* PASCAL FromHandle(SOCKET hSocket);\n```  \n  \n### Parameters  \n `hSocket`  \n Contains a handle to a socket.  \n  \n### Return Value  \n A pointer to a `CSocket` object, or **NULL** if there is no `CSocket` object attached to `hSocket`.  \n  \n### Remarks  \n When given a **SOCKET** handle, if a `CSocket` object is not attached to the handle, the member function returns **NULL** and does not create a temporary object.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"csocket__isblocking\"></a>  CSocket::IsBlocking  \n Call this member function to determine if a blocking call is in progress.  \n  \n```  \nBOOL IsBlocking();\n```  \n  \n### Return Value  \n Nonzero if the socket is blocking; otherwise 0.  \n  \n### Remarks  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"csocket__onmessagepending\"></a>  CSocket::OnMessagePending  \n Override this member function to look for particular messages from Windows and respond to them in your socket.  \n  \n```  \nvirtual BOOL OnMessagePending();\n```  \n  \n### Return Value  \n Nonzero if the message was handled; otherwise 0.  \n  \n### Remarks  \n This is an advanced overridable.  \n  \n The framework calls `OnMessagePending` while the socket is pumping Windows messages to give you an opportunity to deal with messages of interest to your application. For examples of how you might use `OnMessagePending`, see the article [Windows Sockets: Deriving from Socket Classes](../../mfc/windows-sockets-deriving-from-socket-classes.md).  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n## See Also  \n [CAsyncSocket Class](../../mfc/reference/casyncsocket-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CAsyncSocket Class](../../mfc/reference/casyncsocket-class.md)   \n [CSocketFile Class](../../mfc/reference/csocketfile-class.md)\n"}