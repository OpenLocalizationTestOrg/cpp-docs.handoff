{"nodes":[{"pos":[12,56],"content":"A.17   Using Nestable Locks | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"A.17   Using Nestable Locks | Microsoft Docs","pos":[0,44]}]},{"content":"A.17   Using Nestable Locks","pos":[536,563]},{"pos":[564,782],"content":"The following example (for <bpt id=\"p1\">[</bpt>Section 3.2<ept id=\"p1\">](../../parallel/openmp/3-2-lock-functions.md)</ept> on page 41) demonstrates how a nestable lock can be used to synchronize updates both to a whole structure and to one of its members.","source":"The following example (for [Section 3.2](../../parallel/openmp/3-2-lock-functions.md) on page 41) demonstrates how a nestable lock can be used to synchronize updates both to a whole structure and to one of its members."}],"content":"---\ntitle: \"A.17   Using Nestable Locks | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8ef386ed-ddc4-4d40-80aa-cc39f0fb5e4b\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# A.17   Using Nestable Locks\nThe following example (for [Section 3.2](../../parallel/openmp/3-2-lock-functions.md) on page 41) demonstrates how a nestable lock can be used to synchronize updates both to a whole structure and to one of its members.  \n  \n```  \n#include <omp.h>  \ntypedef struct {int a,b; omp_nest_lock_t lck;} pair;  \n  \nvoid incr_a(pair *p, int a)  \n{  \n    // Called only from incr_pair, no need to lock.  \n    p->a += a;  \n}  \n  \nvoid incr_b(pair *p, int b)  \n{  \n    // Called both from incr_pair and elsewhere,  \n    // so need a nestable lock.  \n  \n    omp_set_nest_lock(&p->lck);  \n    p->b += b;  \n    omp_unset_nest_lock(&p->lck);  \n}  \n  \nvoid incr_pair(pair *p, int a, int b)  \n{  \n    omp_set_nest_lock(&p->lck);  \n    incr_a(p, a);  \n    incr_b(p, b);  \n    omp_unset_nest_lock(&p->lck);  \n}  \n  \nvoid f(pair *p)  \n{  \n    extern int work1(), work2(), work3();  \n    #pragma omp parallel sections  \n    {  \n        #pragma omp section  \n            incr_pair(p, work1(), work2());  \n        #pragma omp section  \n            incr_b(p, work3());  \n    }  \n}  \n```"}