{"nodes":[{"pos":[12,51],"content":"interior_ptr (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"interior_ptr (C++-CLI) | Microsoft Docs","pos":[0,39]}]},{"content":"interior_ptr (C++/CLI)","pos":[691,713]},{"content":"An <bpt id=\"p1\">*</bpt>interior pointer<ept id=\"p1\">*</ept> declares a pointer to inside a reference type, but not to the object itself.","pos":[714,812],"source":"An *interior pointer* declares a pointer to inside a reference type, but not to the object itself."},{"content":"An interior pointer can point to a reference handle, value type, boxed type handle, member of a managed type, or to an element of a managed array.","pos":[813,959]},{"content":"All Runtimes","pos":[968,980]},{"content":"(There are no remarks for this language feature that apply to all runtimes.)","pos":[984,1060]},{"content":"Windows Runtime","pos":[1069,1084]},{"content":"(There are no remarks for this language feature that apply to only the Windows Runtime.)","pos":[1088,1176]},{"content":"Requirements","pos":[1186,1198]},{"pos":[1202,1226],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[1235,1258]},{"content":"The following syntax example demonstrates an interior pointer.","pos":[1262,1324]},{"content":"Syntax","pos":[1334,1340]},{"content":"Parameters","pos":[1427,1437]},{"content":"cv_qualifier","pos":[1442,1454]},{"content":"<bpt id=\"p1\"> **</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> qualifiers.","pos":[1458,1494],"source":" **const** or `volatile` qualifiers."},{"content":"type","pos":[1502,1506]},{"content":"The type of <bpt id=\"p1\">*</bpt>initializer<ept id=\"p1\">*</ept>.","pos":[1511,1537],"source":" The type of *initializer*."},{"content":"var","pos":[1545,1548]},{"content":"The name of the <ph id=\"ph1\">`interior_ptr`</ph> variable.","pos":[1553,1593],"source":" The name of the `interior_ptr` variable."},{"content":"initializer","pos":[1601,1612]},{"content":"A member of a reference type, element of a managed array, or any other object that you can assign to a native pointer.","pos":[1617,1735]},{"content":"Remarks","pos":[1745,1752]},{"content":"A native pointer is not able to track an item as its location changes on the managed heap, which results from the garbage collector moving instances of an object.","pos":[1756,1918]},{"content":"In order for a pointer to correctly refer to the instance, the runtime needs to update the pointer to the newly positioned object.","pos":[1919,2049]},{"content":"An <ph id=\"ph1\">`interior_ptr`</ph> represents a superset of the functionality of a native pointer.","pos":[2056,2137],"source":"An `interior_ptr` represents a superset of the functionality of a native pointer."},{"content":"Therefore, anything that can be assigned to a native pointer can also be assigned to an <ph id=\"ph1\">`interior_ptr`</ph>.","pos":[2139,2242],"source":"  Therefore, anything that can be assigned to a native pointer can also be assigned to an `interior_ptr`."},{"content":"An interior pointer is permitted to perform the same set of operations as native pointers, including comparison and pointer arithmetic.","pos":[2244,2379]},{"content":"An interior pointer can only be declared on the stack.","pos":[2386,2440]},{"content":"An interior pointer cannot be declared as a member of a class.","pos":[2442,2504]},{"content":"Since interior pointers exist only on the stack, taking the address of an interior pointer yields an unmanaged pointer.","pos":[2511,2630]},{"pos":[2652,2741],"content":"has an implicit conversion to <ph id=\"ph1\">`bool`</ph>, which allows for its use in conditional statements.","source":" has an implicit conversion to `bool`, which allows for its use in conditional statements."},{"pos":[2748,2926],"content":"For information on how to declare an interior pointer that points into an object that cannot be moved on the garbage-collected heap, see <bpt id=\"p1\">[</bpt>pin_ptr<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept>.","source":"For information on how to declare an interior pointer that points into an object that cannot be moved on the garbage-collected heap, see [pin_ptr](../windows/pin-ptr-cpp-cli.md)."},{"content":"is in the cli namespace.","pos":[2948,2972]},{"content":"See <bpt id=\"p1\">[</bpt>Platform, default, and cli Namespaces<ept id=\"p1\">](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md)</ept> for more information.","pos":[2974,3115],"source":"  See [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md) for more information."},{"content":"For more information on interior pointers, see","pos":[3122,3168]},{"content":"How to: Declare and Use Interior Pointers and Managed Arrays (C++/CLI)","pos":[3179,3249]},{"content":"How to: Declare Value Types with the interior_ptr Keyword (C++/CLI)","pos":[3344,3411]},{"content":"How to: Overload Functions with Interior Pointers and Native Pointers (C++/CLI)","pos":[3503,3582]},{"content":"How to: Declare Interior Pointers with the const Keyword (C++/CLI)","pos":[3686,3752]},{"content":"Requirements","pos":[3842,3854]},{"pos":[3858,3883],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[3893,3901]},{"content":"Example","pos":[3907,3914]},{"content":"The following sample shows how to declare and use an interior pointer into a reference type.","pos":[3923,4015]},{"content":"Output","pos":[4537,4543]},{"content":"See Also","pos":[4587,4595]},{"content":"Component Extensions for Runtime Platforms","pos":[4600,4642]}],"content":"---\ntitle: \"interior_ptr (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"stdcli::language::interior_ptr\"\n  - \"interior_ptr_cpp\"\n  - \"interior_ptr\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interior_ptr keyword [C++]\"\nms.assetid: 25160f74-569e-492d-9e3c-67ece7486baa\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# interior_ptr (C++/CLI)\nAn *interior pointer* declares a pointer to inside a reference type, but not to the object itself. An interior pointer can point to a reference handle, value type, boxed type handle, member of a managed type, or to an element of a managed array.  \n  \n## All Runtimes  \n (There are no remarks for this language feature that apply to all runtimes.)  \n  \n## Windows Runtime  \n (There are no remarks for this language feature that apply to only the Windows Runtime.)  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n The following syntax example demonstrates an interior pointer.  \n  \n### Syntax  \n  \n```cpp  \ncli::interior_ptr<cv_qualifier type> var = &initializer;  \n```  \n  \n### Parameters  \n *cv_qualifier*  \n **const** or `volatile` qualifiers.  \n  \n *type*  \n The type of *initializer*.  \n  \n *var*  \n The name of the `interior_ptr` variable.  \n  \n *initializer*  \n A member of a reference type, element of a managed array, or any other object that you can assign to a native pointer.  \n  \n### Remarks  \n A native pointer is not able to track an item as its location changes on the managed heap, which results from the garbage collector moving instances of an object. In order for a pointer to correctly refer to the instance, the runtime needs to update the pointer to the newly positioned object.  \n  \n An `interior_ptr` represents a superset of the functionality of a native pointer.  Therefore, anything that can be assigned to a native pointer can also be assigned to an `interior_ptr`.  An interior pointer is permitted to perform the same set of operations as native pointers, including comparison and pointer arithmetic.  \n  \n An interior pointer can only be declared on the stack.  An interior pointer cannot be declared as a member of a class.  \n  \n Since interior pointers exist only on the stack, taking the address of an interior pointer yields an unmanaged pointer.  \n  \n `interior_ptr` has an implicit conversion to `bool`, which allows for its use in conditional statements.  \n  \n For information on how to declare an interior pointer that points into an object that cannot be moved on the garbage-collected heap, see [pin_ptr](../windows/pin-ptr-cpp-cli.md).  \n  \n `interior_ptr` is in the cli namespace.  See [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md) for more information.  \n  \n For more information on interior pointers, see  \n  \n-   [How to: Declare and Use Interior Pointers and Managed Arrays (C++/CLI)](../windows/how-to-declare-and-use-interior-pointers-and-managed-arrays-cpp-cli.md)  \n  \n-   [How to: Declare Value Types with the interior_ptr Keyword (C++/CLI)](../windows/how-to-declare-value-types-with-the-interior-ptr-keyword-cpp-cli.md)  \n  \n-   [How to: Overload Functions with Interior Pointers and Native Pointers (C++/CLI)](../windows/how-to-overload-functions-with-interior-pointers-and-native-pointers-cpp-cli.md)  \n  \n-   [How to: Declare Interior Pointers with the const Keyword (C++/CLI)](../windows/how-to-declare-interior-pointers-with-the-const-keyword-cpp-cli.md)  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following sample shows how to declare and use an interior pointer into a reference type.  \n  \n```cpp  \n// interior_ptr.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class MyClass {  \npublic:  \n   int data;  \n};  \n  \nint main() {  \n   MyClass ^ h_MyClass = gcnew MyClass;  \n   h_MyClass->data = 1;  \n   Console::WriteLine(h_MyClass->data);  \n  \n   interior_ptr<int> p = &(h_MyClass->data);  \n   *p = 2;  \n   Console::WriteLine(h_MyClass->data);  \n  \n   // alternatively  \n   interior_ptr<MyClass ^> p2 = &h_MyClass;  \n   (*p2)->data = 3;  \n   Console::WriteLine((*p2)->data);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n1  \n2  \n3  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}