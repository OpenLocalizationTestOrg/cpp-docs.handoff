{"nodes":[{"pos":[12,80],"content":"Using Explicit PInvoke in C++ (DllImport Attribute) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using Explicit PInvoke in C++ (DllImport Attribute) | Microsoft Docs","pos":[0,68]}]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[787,838]},{"content":"The .NET Framework provides explicit Platform Invoke (or PInvoke) features with the <ph id=\"ph1\">`Dllimport`</ph> attribute to allow managed applications to call unmanaged functions packaged inside DLLs.","pos":[839,1024],"source":"The .NET Framework provides explicit Platform Invoke (or PInvoke) features with the `Dllimport` attribute to allow managed applications to call unmanaged functions packaged inside DLLs."},{"content":"Explicit PInvoke is required for situations where unmanaged APIs are packaged as DLLs and the source code is not available.","pos":[1025,1148]},{"content":"Calling Win32 functions, for example, requires PInvoke.","pos":[1149,1204]},{"content":"Otherwise, use implicit P{Invoke; see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept> for more information.","pos":[1205,1352],"source":" Otherwise, use implicit P{Invoke; see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md) for more information."},{"content":"PInvoke works by using &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;.","pos":[1359,1439],"source":"PInvoke works by using <xref:System.Runtime.InteropServices.DllImportAttribute>."},{"content":"This attribute, which takes the name of the DLL as its first argument, is placed before a function declaration for each DLL entry point that will be used.","pos":[1440,1594]},{"content":"The signature of the function must match the name of a function exported by the DLL (but some type conversion can be performed implicitly by defining the <ph id=\"ph1\">`DllImport`</ph> declarations in terms of managed types.)","pos":[1595,1801],"source":" The signature of the function must match the name of a function exported by the DLL (but some type conversion can be performed implicitly by defining the `DllImport` declarations in terms of managed types.)"},{"content":"The result is a managed entry point for each native DLL function that contains the necessary transition code (or thunk) and simple data conversions.","pos":[1808,1956]},{"content":"Managed functions can then call into the DLL through these entry points.","pos":[1957,2029]},{"content":"The code inserted into a module as the result of PInvoke is entirely managed and explicit PInvoke is supported for <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>/clr:safe<ept id=\"p3\">**</ept> compilations.","pos":[2030,2201],"source":" The code inserted into a module as the result of PInvoke is entirely managed and explicit PInvoke is supported for **/clr**, **/clr:pure**, and **/clr:safe** compilations."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Pure and Verifiable Code (C++/CLI)<ept id=\"p1\">](../dotnet/pure-and-verifiable-code-cpp-cli.md)</ept>.","pos":[2202,2312],"source":" For more information, see [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md)."},{"content":"In This Section","pos":[2321,2336]},{"content":"Calling Native Functions from Managed Code","pos":[2347,2389]},{"content":"How to: Call Native DLLs from Managed Code Using PInvoke","pos":[2458,2514]},{"content":"How to: Marshal Strings Using PInvoke","pos":[2596,2633]},{"content":"How to: Marshal Structures Using PInvoke","pos":[2696,2736]},{"content":"How to: Marshal Arrays Using PInvoke","pos":[2802,2838]},{"content":"How to: Marshal Function Pointers Using PInvoke","pos":[2900,2947]},{"content":"How to: Marshal Embedded Pointers Using PInvoke","pos":[3020,3067]},{"content":"See Also","pos":[3138,3146]},{"content":"Calling Native Functions from Managed Code","pos":[3151,3193]}],"content":"---\ntitle: \"Using Explicit PInvoke in C++ (DllImport Attribute) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"marshaling [C++], platform invoke\"\n  - \"C++ Interop, platform invoke\"\n  - \"interop [C++], platform invoke\"\n  - \"platform invoke [C++], marshaling in C++\"\n  - \"data marshaling [C++], platform invoke\"\nms.assetid: 18e5218c-6916-48a1-a127-f66e22ef15fc\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using Explicit PInvoke in C++ (DllImport Attribute)\nThe .NET Framework provides explicit Platform Invoke (or PInvoke) features with the `Dllimport` attribute to allow managed applications to call unmanaged functions packaged inside DLLs. Explicit PInvoke is required for situations where unmanaged APIs are packaged as DLLs and the source code is not available. Calling Win32 functions, for example, requires PInvoke. Otherwise, use implicit P{Invoke; see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md) for more information.  \n  \n PInvoke works by using <xref:System.Runtime.InteropServices.DllImportAttribute>. This attribute, which takes the name of the DLL as its first argument, is placed before a function declaration for each DLL entry point that will be used. The signature of the function must match the name of a function exported by the DLL (but some type conversion can be performed implicitly by defining the `DllImport` declarations in terms of managed types.)  \n  \n The result is a managed entry point for each native DLL function that contains the necessary transition code (or thunk) and simple data conversions. Managed functions can then call into the DLL through these entry points. The code inserted into a module as the result of PInvoke is entirely managed and explicit PInvoke is supported for **/clr**, **/clr:pure**, and **/clr:safe** compilations. For more information, see [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md).  \n  \n## In This Section  \n  \n-   [Calling Native Functions from Managed Code](../dotnet/calling-native-functions-from-managed-code.md)  \n  \n-   [How to: Call Native DLLs from Managed Code Using PInvoke](../dotnet/how-to-call-native-dlls-from-managed-code-using-pinvoke.md)  \n  \n-   [How to: Marshal Strings Using PInvoke](../dotnet/how-to-marshal-strings-using-pinvoke.md)  \n  \n-   [How to: Marshal Structures Using PInvoke](../dotnet/how-to-marshal-structures-using-pinvoke.md)  \n  \n-   [How to: Marshal Arrays Using PInvoke](../dotnet/how-to-marshal-arrays-using-pinvoke.md)  \n  \n-   [How to: Marshal Function Pointers Using PInvoke](../dotnet/how-to-marshal-function-pointers-using-pinvoke.md)  \n  \n-   [How to: Marshal Embedded Pointers Using PInvoke](../dotnet/how-to-marshal-embedded-pointers-using-pinvoke.md)  \n  \n## See Also  \n [Calling Native Functions from Managed Code](../dotnet/calling-native-functions-from-managed-code.md)"}