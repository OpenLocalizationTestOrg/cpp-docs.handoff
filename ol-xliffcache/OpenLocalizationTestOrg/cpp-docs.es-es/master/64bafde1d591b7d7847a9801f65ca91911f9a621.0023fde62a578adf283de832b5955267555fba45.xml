{"nodes":[{"pos":[12,49],"content":"try-except Statement | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"try-except Statement | Microsoft Docs","pos":[0,37]}]},{"content":"try-except Statement","pos":[1242,1262]},{"content":"Microsoft Specific","pos":[1265,1283]},{"content":"The following syntax describes a try-except statement:","pos":[1292,1346]},{"content":"Syntax","pos":[1355,1361]},{"content":"Remarks","pos":[1497,1504]},{"content":"The <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement is a Microsoft extension to the C and C++ languages that enables target applications to gain control when events that normally terminate program execution occur.","pos":[1508,1698],"source":"The **try-except** statement is a Microsoft extension to the C and C++ languages that enables target applications to gain control when events that normally terminate program execution occur."},{"content":"Such events are called exceptions, and the mechanism that deals with exceptions is called structured exception handling.","pos":[1699,1819]},{"pos":[1826,1916],"content":"For related information, see the <bpt id=\"p1\">[</bpt>try-finally statement<ept id=\"p1\">](../cpp/try-finally-statement.md)</ept>.","source":"For related information, see the [try-finally statement](../cpp/try-finally-statement.md)."},{"content":"Exceptions can be either hardware-based or software-based.","pos":[1923,1981]},{"content":"Even when applications cannot completely recover from hardware or software exceptions, structured exception handling makes it possible to display error information and trap the internal state of the application to help diagnose the problem.","pos":[1982,2222]},{"content":"This is especially useful for intermittent problems that cannot be reproduced easily.","pos":[2223,2308]},{"pos":[2316,2799],"content":"[!NOTE]\n Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).","leadings":["","> "],"nodes":[{"content":" Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).","pos":[8,481],"nodes":[{"content":"Structured exception handling works with Win32 for both C and C++ source files.","pos":[1,80]},{"content":"However, it is not specifically designed for C++.","pos":[81,130]},{"content":"You can ensure that your code is more portable by using C++ exception handling.","pos":[131,210]},{"content":"Also, C++ exception handling is more flexible, in that it can handle exceptions of any type.","pos":[211,303]},{"content":"For C++ programs, it is recommended that you use the C++ exception-handling mechanism (<bpt id=\"p1\">[</bpt>try, catch, and throw<ept id=\"p1\">](../cpp/try-throw-and-catch-statements-cpp.md)</ept> statements).","pos":[304,473],"source":" For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements)."}]}]},{"content":"The compound statement after the <ph id=\"ph1\">`__try`</ph> clause is the body or guarded section.","pos":[2806,2885],"source":"The compound statement after the `__try` clause is the body or guarded section."},{"content":"The compound statement after the <ph id=\"ph1\">`__except`</ph> clause is the exception handler.","pos":[2886,2962],"source":" The compound statement after the `__except` clause is the exception handler."},{"content":"The handler specifies a set of actions to be taken if an exception is raised during execution of the body of the guarded section.","pos":[2963,3092]},{"content":"Execution proceeds as follows:","pos":[3093,3123]},{"content":"The guarded section is executed.","pos":[3133,3165]},{"pos":[3175,3304],"content":"If no exception occurs during execution of the guarded section, execution continues at the statement after the <ph id=\"ph1\">`__except`</ph> clause.","source":"If no exception occurs during execution of the guarded section, execution continues at the statement after the `__except` clause."},{"content":"If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the <ph id=\"ph1\">`__except`</ph> <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> (called the <bpt id=\"p2\">*</bpt>filter<ept id=\"p2\">*</ept> expression) is evaluated and the value determines how the exception is handled.","pos":[3314,3550],"source":"If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the `__except` *expression* (called the *filter* expression) is evaluated and the value determines how the exception is handled."},{"content":"There are three values:","pos":[3551,3574]},{"content":"<bpt id=\"p1\">**</bpt>EXCEPTION_CONTINUE_EXECUTION (–1)<ept id=\"p1\">**</ept> Exception is dismissed.","pos":[3585,3646],"source":"**EXCEPTION_CONTINUE_EXECUTION (–1)** Exception is dismissed."},{"content":"Continue execution at the point where the exception occurred.","pos":[3647,3708]},{"content":"<bpt id=\"p1\">**</bpt>EXCEPTION_CONTINUE_SEARCH (0)<ept id=\"p1\">**</ept> Exception is not recognized.","pos":[3719,3781],"source":"**EXCEPTION_CONTINUE_SEARCH (0)** Exception is not recognized."},{"content":"Continue to search up the stack for a handler, first for containing <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statements, then for handlers with the next highest precedence.","pos":[3782,3928],"source":" Continue to search up the stack for a handler, first for containing **try-except** statements, then for handlers with the next highest precedence."},{"content":"<bpt id=\"p1\">**</bpt>EXCEPTION_EXECUTE_HANDLER (1)<ept id=\"p1\">**</ept> Exception is recognized.","pos":[3939,3997],"source":"**EXCEPTION_EXECUTE_HANDLER (1)** Exception is recognized."},{"content":"Transfer control to the exception handler by executing the <ph id=\"ph1\">`__except`</ph> compound statement, then continue execution after the <ph id=\"ph2\">`__except`</ph> block.","pos":[3998,4139],"source":" Transfer control to the exception handler by executing the `__except` compound statement, then continue execution after the `__except` block."},{"content":"Because the __<bpt id=\"p1\">**</bpt>except<ept id=\"p1\">**</ept> expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator.","pos":[4146,4306],"source":"Because the __**except** expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator."},{"content":"If more extensive processing is required, the expression can call a routine that returns one of the three values listed above.","pos":[4307,4433]},{"content":"Each application can have its own exception handler.","pos":[4440,4492]},{"content":"It is not valid to jump into a <ph id=\"ph1\">`__try`</ph> statement, but valid to jump out of one.","pos":[4499,4578],"source":"It is not valid to jump into a `__try` statement, but valid to jump out of one."},{"content":"The exception handler is not called if a process is terminated in the middle of executing a <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement.","pos":[4579,4696],"source":" The exception handler is not called if a process is terminated in the middle of executing a **try-except** statement."},{"content":"For more information, see Knowledge Base article Q315937 : HOW TO: Trap Stack Overflow in a Visual C++ Application.","pos":[4703,4818]},{"content":"The __leave Keyword","pos":[4827,4846]},{"content":"The <ph id=\"ph1\">`__leave`</ph> keyword is valid only within the guarded section of a <ph id=\"ph2\">`try-except`</ph> statement, and its effect is to jump to the end of the guarded section.","pos":[4850,5002],"source":"The `__leave` keyword is valid only within the guarded section of a `try-except` statement, and its effect is to jump to the end of the guarded section."},{"content":"Execution continues at the first statement after the exception handler.","pos":[5003,5074]},{"content":"A <ph id=\"ph1\">`goto`</ph> statement can also jump out of the guarded section, and it does not degrade performance as it does in a <ph id=\"ph2\">`try-finally`</ph> statement because stack unwinding does not occur.","pos":[5081,5257],"source":"A `goto` statement can also jump out of the guarded section, and it does not degrade performance as it does in a `try-finally` statement because stack unwinding does not occur."},{"content":"However, we recommend that you use the <ph id=\"ph1\">`__leave`</ph> keyword rather than a <ph id=\"ph2\">`goto`</ph> statement because you are less likely to make a programming mistake if the guarded section is large or complex.","pos":[5258,5447],"source":" However, we recommend that you use the `__leave` keyword rather than a `goto` statement because you are less likely to make a programming mistake if the guarded section is large or complex."},{"content":"Structured Exception Handling Intrinsic Functions","pos":[5457,5506]},{"pos":[5510,5687],"content":"Structured exception handling provides two intrinsic functions that are available to use with the <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement: <bpt id=\"p2\">**</bpt>GetExceptionCode<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>GetExceptionInformation<ept id=\"p3\">**</ept>.","source":"Structured exception handling provides two intrinsic functions that are available to use with the **try-except** statement: **GetExceptionCode** and **GetExceptionInformation**."},{"pos":[5694,5768],"content":"<bpt id=\"p1\">**</bpt>GetExceptionCode<ept id=\"p1\">**</ept> returns the code (a 32-bit integer) of the exception.","source":"**GetExceptionCode** returns the code (a 32-bit integer) of the exception."},{"content":"The intrinsic function <bpt id=\"p1\">**</bpt>GetExceptionInformation<ept id=\"p1\">**</ept> returns a pointer to a structure containing additional information about the exception.","pos":[5775,5913],"source":"The intrinsic function **GetExceptionInformation** returns a pointer to a structure containing additional information about the exception."},{"content":"Through this pointer, you can access the machine state that existed at the time of a hardware exception.","pos":[5914,6018]},{"content":"The structure is as follows:","pos":[6019,6047]},{"pos":[6176,6274],"content":"The pointer types _<bpt id=\"p1\">**</bpt>EXCEPTION_RECORD<ept id=\"p1\">**</ept> and <ph id=\"ph1\">\\_</ph><bpt id=\"p2\">**</bpt>CONTEXT<ept id=\"p2\">**</ept> are defined in the include file EXCPT.H.","source":"The pointer types _**EXCEPTION_RECORD** and \\_**CONTEXT** are defined in the include file EXCPT.H."},{"content":"You can use <bpt id=\"p1\">**</bpt>GetExceptionCode<ept id=\"p1\">**</ept> within the exception handler.","pos":[6281,6343],"source":"You can use **GetExceptionCode** within the exception handler."},{"content":"However, you can use <bpt id=\"p1\">**</bpt>GetExceptionInformation<ept id=\"p1\">**</ept> only within the exception filter expression.","pos":[6344,6437],"source":" However, you can use **GetExceptionInformation** only within the exception filter expression."},{"content":"The information it points to is generally on the stack and is no longer available when control is transferred to the exception handler.","pos":[6438,6573]},{"content":"The intrinsic function <bpt id=\"p1\">**</bpt>AbnormalTermination<ept id=\"p1\">**</ept> is available within a termination handler.","pos":[6580,6669],"source":"The intrinsic function **AbnormalTermination** is available within a termination handler."},{"content":"It returns 0 if the body of the <ph id=\"ph1\">`try-finally`</ph> statement terminates sequentially.","pos":[6670,6750],"source":" It returns 0 if the body of the `try-finally` statement terminates sequentially."},{"content":"In all other cases, it returns 1.","pos":[6751,6784]},{"content":"EXCPT.H defines some alternate names for these intrinsics:","pos":[6791,6849]},{"pos":[6856,6909],"content":"<bpt id=\"p1\">**</bpt>GetExceptionCode<ept id=\"p1\">**</ept> is equivalent to _exception_code","source":"**GetExceptionCode** is equivalent to _exception_code"},{"pos":[6916,6976],"content":"<bpt id=\"p1\">**</bpt>GetExceptionInformation<ept id=\"p1\">**</ept> is equivalent to _exception_info","source":"**GetExceptionInformation** is equivalent to _exception_info"},{"pos":[6983,7045],"content":"<bpt id=\"p1\">**</bpt>AbnormalTermination<ept id=\"p1\">**</ept> is equivalent to _abnormal_termination","source":"**AbnormalTermination** is equivalent to _abnormal_termination"},{"content":"Example","pos":[7054,7061]},{"content":"Output","pos":[8180,8186]},{"content":"END Microsoft Specific","pos":[8340,8362]},{"content":"See Also","pos":[8373,8381]},{"content":"Writing an Exception Handler","pos":[8386,8414]},{"content":"Structured Exception Handling (C/C++)","pos":[8461,8498]},{"content":"Keywords","pos":[8552,8560]}],"content":"---\ntitle: \"try-except Statement | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"_abnormal_termination_cpp\"\n  - \"_exception_code_cpp\"\n  - \"EXCEPTION_CONTINUE_SEARCH\"\n  - \"_exception_info\"\n  - \"__except\"\n  - \"EXCEPTION_CONTINUE_EXECUTION\"\n  - \"_exception_code\"\n  - \"__except_cpp\"\n  - \"_exception_info_cpp\"\n  - \"EXCEPTION_EXECUTE_HANDLER\"\n  - \"_abnormal_termination\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__try keyword [C++]\"\n  - \"EXCEPTION_CONTINUE_EXECUTION macro\"\n  - \"EXCEPTION_CONTINUE_SEARCH macro\"\n  - \"EXCEPTION_EXECUTE_HANDLER macro\"\n  - \"GetExceptionCode function\"\n  - \"try-catch keyword [C++], try-except keyword [C++]\"\n  - \"_exception_code keyword [C++]\"\n  - \"try-except keyword [C++]\"\n  - \"_exception_info keyword [C++]\"\n  - \"_abnormal_termination keyword [C++]\"\nms.assetid: 30d60071-ea49-4bfb-a8e6-7a420de66381\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# try-except Statement\n**Microsoft Specific**  \n  \n The following syntax describes a try-except statement:  \n  \n## Syntax  \n  \n```  \n  \n      __try   \n{  \n   // guarded code  \n}  \n__except ( expression )  \n{  \n   // exception handler code  \n}  \n```  \n  \n## Remarks  \n The **try-except** statement is a Microsoft extension to the C and C++ languages that enables target applications to gain control when events that normally terminate program execution occur. Such events are called exceptions, and the mechanism that deals with exceptions is called structured exception handling.  \n  \n For related information, see the [try-finally statement](../cpp/try-finally-statement.md).  \n  \n Exceptions can be either hardware-based or software-based. Even when applications cannot completely recover from hardware or software exceptions, structured exception handling makes it possible to display error information and trap the internal state of the application to help diagnose the problem. This is especially useful for intermittent problems that cannot be reproduced easily.  \n  \n> [!NOTE]\n>  Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).  \n  \n The compound statement after the `__try` clause is the body or guarded section. The compound statement after the `__except` clause is the exception handler. The handler specifies a set of actions to be taken if an exception is raised during execution of the body of the guarded section. Execution proceeds as follows:  \n  \n1.  The guarded section is executed.  \n  \n2.  If no exception occurs during execution of the guarded section, execution continues at the statement after the `__except` clause.  \n  \n3.  If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the `__except` *expression* (called the *filter* expression) is evaluated and the value determines how the exception is handled. There are three values:  \n  \n     **EXCEPTION_CONTINUE_EXECUTION (–1)** Exception is dismissed. Continue execution at the point where the exception occurred.  \n  \n     **EXCEPTION_CONTINUE_SEARCH (0)** Exception is not recognized. Continue to search up the stack for a handler, first for containing **try-except** statements, then for handlers with the next highest precedence.  \n  \n     **EXCEPTION_EXECUTE_HANDLER (1)** Exception is recognized. Transfer control to the exception handler by executing the `__except` compound statement, then continue execution after the `__except` block.  \n  \n Because the __**except** expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator. If more extensive processing is required, the expression can call a routine that returns one of the three values listed above.  \n  \n Each application can have its own exception handler.  \n  \n It is not valid to jump into a `__try` statement, but valid to jump out of one. The exception handler is not called if a process is terminated in the middle of executing a **try-except** statement.  \n  \n For more information, see Knowledge Base article Q315937 : HOW TO: Trap Stack Overflow in a Visual C++ Application.  \n  \n## The __leave Keyword  \n The `__leave` keyword is valid only within the guarded section of a `try-except` statement, and its effect is to jump to the end of the guarded section. Execution continues at the first statement after the exception handler.  \n  \n A `goto` statement can also jump out of the guarded section, and it does not degrade performance as it does in a `try-finally` statement because stack unwinding does not occur. However, we recommend that you use the `__leave` keyword rather than a `goto` statement because you are less likely to make a programming mistake if the guarded section is large or complex.  \n  \n### Structured Exception Handling Intrinsic Functions  \n Structured exception handling provides two intrinsic functions that are available to use with the **try-except** statement: **GetExceptionCode** and **GetExceptionInformation**.  \n  \n **GetExceptionCode** returns the code (a 32-bit integer) of the exception.  \n  \n The intrinsic function **GetExceptionInformation** returns a pointer to a structure containing additional information about the exception. Through this pointer, you can access the machine state that existed at the time of a hardware exception. The structure is as follows:  \n  \n```  \nstruct _EXCEPTION_POINTERS {  \n      EXCEPTION_RECORD *ExceptionRecord,  \n      CONTEXT *ContextRecord }  \n```  \n  \n The pointer types _**EXCEPTION_RECORD** and \\_**CONTEXT** are defined in the include file EXCPT.H.  \n  \n You can use **GetExceptionCode** within the exception handler. However, you can use **GetExceptionInformation** only within the exception filter expression. The information it points to is generally on the stack and is no longer available when control is transferred to the exception handler.  \n  \n The intrinsic function **AbnormalTermination** is available within a termination handler. It returns 0 if the body of the `try-finally` statement terminates sequentially. In all other cases, it returns 1.  \n  \n EXCPT.H defines some alternate names for these intrinsics:  \n  \n **GetExceptionCode** is equivalent to _exception_code  \n  \n **GetExceptionInformation** is equivalent to _exception_info  \n  \n **AbnormalTermination** is equivalent to _abnormal_termination  \n  \n## Example  \n `// exceptions_try_except_Statement.cpp`  \n  \n `// Example of try-except and try-finally statements`  \n  \n `#include <stdio.h>`  \n  \n `#include <windows.h> // for EXCEPTION_ACCESS_VIOLATION`  \n  \n `#include <excpt.h>`  \n  \n `int filter(unsigned int code, struct _EXCEPTION_POINTERS *ep) {`  \n  \n `puts(\"in filter.\");`  \n  \n `if (code == EXCEPTION_ACCESS_VIOLATION) {`  \n  \n `puts(\"caught AV as expected.\");`  \n  \n `return EXCEPTION_EXECUTE_HANDLER;`  \n  \n `}`  \n  \n `else {`  \n  \n `puts(\"didn't catch AV, unexpected.\");`  \n  \n `return EXCEPTION_CONTINUE_SEARCH;`  \n  \n `};`  \n  \n `}`  \n  \n `int main()`  \n  \n `{`  \n  \n `int* p = 0x00000000;   // pointer to NULL`  \n  \n `puts(\"hello\");`  \n  \n `__try{`  \n  \n `puts(\"in try\");`  \n  \n `__try{`  \n  \n `puts(\"in try\");`  \n  \n `*p = 13;    // causes an access violation exception;`  \n  \n `}__finally{`  \n  \n `puts(\"in finally. termination: \");`  \n  \n `puts(AbnormalTermination() ? \"\\tabnormal\" : \"\\tnormal\");`  \n  \n `}`  \n  \n `}__except(filter(GetExceptionCode(), GetExceptionInformation())){`  \n  \n `puts(\"in except\");`  \n  \n `}`  \n  \n `puts(\"world\");`  \n  \n `}`  \n  \n## Output  \n  \n```  \nhello  \nin try  \nin try  \nin filter.  \ncaught AV as expected.  \nin finally. termination:  \n        abnormal  \nin except  \nworld  \n```  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Writing an Exception Handler](../cpp/writing-an-exception-handler.md)   \n [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)   \n [Keywords](../cpp/keywords-cpp.md)"}