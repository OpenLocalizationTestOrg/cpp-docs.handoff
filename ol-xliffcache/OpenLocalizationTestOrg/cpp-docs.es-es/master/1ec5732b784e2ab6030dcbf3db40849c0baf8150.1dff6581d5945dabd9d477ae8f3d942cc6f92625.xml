{"nodes":[{"pos":[12,67],"content":"String and I-O Formatting (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"String and I-O Formatting (Modern C++) | Microsoft Docs","pos":[0,55]}]},{"content":"String and I/O Formatting (Modern C++)","pos":[548,586]},{"content":"C++ <bpt id=\"p1\">[</bpt>iostreams<ept id=\"p1\">](../standard-library/iostream.md)</ept> are capable of formatted string I/O.","pos":[587,672],"source":"C++ [iostreams](../standard-library/iostream.md) are capable of formatted string I/O."},{"content":"For example, the following code shows how to set cout to format an integer to output in hexadecimal, first saving off the current state and re-setting afterwards, because once state formatting is passed to cout, it stays that way until changed, not just for the one line of code.","pos":[673,952]},{"content":"This can be entirely too cumbersome in many cases.","pos":[1534,1584]},{"content":"As an alternative, you can use Boost.Format from the Boost C++ libraries, even though it’s nonstandard.","pos":[1585,1688]},{"content":"You can download any Boost library from the <bpt id=\"p1\">[</bpt>Boost<ept id=\"p1\">](http://www.boost.org/)</ept> website.","pos":[1689,1772],"source":" You can download any Boost library from the [Boost](http://www.boost.org/) website."},{"content":"Some advantages of Boost.Format are:","pos":[1779,1815]},{"content":"Safe: Type-safe, and throws an exception for errors—for example, the specification of too few or too many items.","pos":[1825,1937]},{"content":"Extensible: Works for any type that can be streamed.","pos":[1947,1999]},{"content":"Convenient: Standard Posix and similar format strings.","pos":[2009,2063]},{"content":"Although Boost.Format is built on C++ <bpt id=\"p1\">[</bpt>iostreams<ept id=\"p1\">](../standard-library/iostream-programming.md)</ept>, which are safe and extensible, they aren't performance-optimized.","pos":[2070,2231],"source":"Although Boost.Format is built on C++ [iostreams](../standard-library/iostream-programming.md), which are safe and extensible, they aren't performance-optimized."},{"content":"When you require performance optimization, consider C <bpt id=\"p1\">[</bpt>printf<ept id=\"p1\">](../c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l.md)</ept> and <bpt id=\"p2\">[</bpt>sprintf<ept id=\"p2\">](../c-runtime-library/reference/sprintf-sprintf-l-swprintf-swprintf-l-swprintf-l.md)</ept>, which are fast and easy to use.","pos":[2232,2494],"source":" When you require performance optimization, consider C [printf](../c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l.md) and [sprintf](../c-runtime-library/reference/sprintf-sprintf-l-swprintf-swprintf-l-swprintf-l.md), which are fast and easy to use."},{"content":"However, they are not extensible or safe from vulnerabilities.","pos":[2495,2557]},{"content":"(Safe versions exist, but they incur a slight performance penalty.","pos":[2558,2624]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>printf_s, _printf_s_l, wprintf_s, _wprintf_s_l<ept id=\"p1\">](../c-runtime-library/reference/printf-s-printf-s-l-wprintf-s-wprintf-s-l.md)</ept> and <bpt id=\"p2\">[</bpt>sprintf_s, _sprintf_s_l, swprintf_s, _swprintf_s_l<ept id=\"p2\">](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md)</ept>).","pos":[2625,2916],"source":" For more information, see [printf_s, _printf_s_l, wprintf_s, _wprintf_s_l](../c-runtime-library/reference/printf-s-printf-s-l-wprintf-s-wprintf-s-l.md) and [sprintf_s, _sprintf_s_l, swprintf_s, _swprintf_s_l](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md))."},{"content":"The following code demonstrates some of the Boost formatting features.","pos":[2923,2993]},{"content":"See Also","pos":[3401,3409]},{"content":"Welcome Back to C++","pos":[3414,3433]},{"content":"C++ Language Reference","pos":[3482,3504]},{"content":"C++ Standard Library","pos":[3545,3565]},{"content":"iostream&gt;","pos":[3629,3638],"source":"iostream>"},{"content":"limits&gt;","pos":[3680,3687],"source":"limits>"},{"content":"iomanip&gt;","pos":[3727,3735],"source":"iomanip>"}],"content":"---\ntitle: \"String and I-O Formatting (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 3954e8de-a59b-4175-89c9-4ee842ab89ed\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# String and I/O Formatting (Modern C++)\nC++ [iostreams](../standard-library/iostream.md) are capable of formatted string I/O. For example, the following code shows how to set cout to format an integer to output in hexadecimal, first saving off the current state and re-setting afterwards, because once state formatting is passed to cout, it stays that way until changed, not just for the one line of code.  \n  \n```fortran  \n#include <iostream>  \n#include <iomanip>  \n  \nusing namespace std;  \n  \nint main()   \n{  \n    ios state(nullptr);  \n  \n    cout << \"The answer in decimal is: \" << 42 << endl;  \n  \n    state.copyfmt(cout); // save current formatting  \n    cout << \"In hex: 0x\" // now load up a bunch of formatting modifiers  \n        << hex   \n        << uppercase   \n        << setw(8)   \n        << setfill('0')   \n        << 42            // the actual value we wanted to print out  \n        << endl;  \n    cout.copyfmt(state); // restore previous formatting  \n}  \n  \n```  \n  \n This can be entirely too cumbersome in many cases. As an alternative, you can use Boost.Format from the Boost C++ libraries, even though it’s nonstandard. You can download any Boost library from the [Boost](http://www.boost.org/) website.  \n  \n Some advantages of Boost.Format are:  \n  \n-   Safe: Type-safe, and throws an exception for errors—for example, the specification of too few or too many items.  \n  \n-   Extensible: Works for any type that can be streamed.  \n  \n-   Convenient: Standard Posix and similar format strings.  \n  \n Although Boost.Format is built on C++ [iostreams](../standard-library/iostream-programming.md), which are safe and extensible, they aren't performance-optimized. When you require performance optimization, consider C [printf](../c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l.md) and [sprintf](../c-runtime-library/reference/sprintf-sprintf-l-swprintf-swprintf-l-swprintf-l.md), which are fast and easy to use. However, they are not extensible or safe from vulnerabilities. (Safe versions exist, but they incur a slight performance penalty. For more information, see [printf_s, _printf_s_l, wprintf_s, _wprintf_s_l](../c-runtime-library/reference/printf-s-printf-s-l-wprintf-s-wprintf-s-l.md) and [sprintf_s, _sprintf_s_l, swprintf_s, _swprintf_s_l](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md)).  \n  \n The following code demonstrates some of the Boost formatting features.  \n  \n```cpp  \n    string s = str( format(\"%2% %2% %1%\\n\") % \"world\" % \"hello\" );  \n    // s contains \"hello hello world\"    \n  \n    for( auto i = 0; i < names.size(); ++i )  \n        cout << format(\"%1% %2% %|40t|%3%\\n\") % first[i] % last[i] % tel[i];  \n    // Georges Benjamin Clemenceau             +33 (0) 123 456 789  \n    // Jean de Lattre de Tassigny              +33 (0) 987 654 321  \n  \n```  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)   \n [\\<iostream>](../standard-library/iostream.md)   \n [\\<limits>](../standard-library/limits.md)   \n [\\<iomanip>](../standard-library/iomanip.md)"}