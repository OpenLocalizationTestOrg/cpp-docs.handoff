{"nodes":[{"pos":[12,47],"content":"ew Operator (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ew Operator (C++) | Microsoft Docs","pos":[0,34]}]},{"content":"new Operator (C++)","pos":[585,603]},{"pos":[604,750],"content":"Allocates memory for an object or array of objects of <bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> from the free store and returns a suitably typed, nonzero pointer to the object.","source":"Allocates memory for an object or array of objects of *type-name* from the free store and returns a suitably typed, nonzero pointer to the object."},{"pos":[758,986],"content":"[!NOTE]\n Microsoft C++ Component Extensions provides support for the `new` keyword to add vtable slot entries. For more information, see [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)","leadings":["","> "],"nodes":[{"content":" Microsoft C++ Component Extensions provides support for the `new` keyword to add vtable slot entries. For more information, see [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)","pos":[8,226],"nodes":[{"content":"Microsoft C++ Component Extensions provides support for the <ph id=\"ph1\">`new`</ph> keyword to add vtable slot entries.","pos":[1,102],"source":" Microsoft C++ Component Extensions provides support for the `new` keyword to add vtable slot entries."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>new (new slot in vtable)<ept id=\"p1\">](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)</ept>","pos":[103,218],"source":" For more information, see [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)"}]}]},{"content":"Syntax","pos":[995,1001]},{"content":"Remarks","pos":[1135,1142]},{"content":"If unsuccessful, <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> returns zero or throws an exception; see <bpt id=\"p2\">[</bpt>The new and delete Operators<ept id=\"p2\">](../cpp/new-and-delete-operators.md)</ept> for more information.","pos":[1146,1300],"source":"If unsuccessful, **new** returns zero or throws an exception; see [The new and delete Operators](../cpp/new-and-delete-operators.md) for more information."},{"content":"You can change this default behavior by writing a custom exception-handling routine and calling the <bpt id=\"p1\">[</bpt>_set_new_handler<ept id=\"p1\">](../c-runtime-library/reference/set-new-handler.md)</ept> run-time library function with your function name as its argument.","pos":[1301,1537],"source":" You can change this default behavior by writing a custom exception-handling routine and calling the [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) run-time library function with your function name as its argument."},{"pos":[1544,1674],"content":"For information on how to create an object on the managed heap, see <bpt id=\"p1\">[</bpt>gcnew<ept id=\"p1\">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept>.","source":"For information on how to create an object on the managed heap, see [gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md)."},{"pos":[1681,1810],"content":"When <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> is used to allocate memory for a C++ class object, the object's constructor is called after the memory is allocated.","source":"When **new** is used to allocate memory for a C++ class object, the object's constructor is called after the memory is allocated."},{"pos":[1817,1935],"content":"Use the <bpt id=\"p1\">[</bpt>delete<ept id=\"p1\">](../cpp/delete-operator-cpp.md)</ept> operator to deallocate the memory allocated with the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator.","source":"Use the [delete](../cpp/delete-operator-cpp.md) operator to deallocate the memory allocated with the **new** operator."},{"content":"The following example allocates and then frees a two-dimensional array of characters of size <ph id=\"ph1\">`dim`</ph> by 10.","pos":[1942,2047],"source":"The following example allocates and then frees a two-dimensional array of characters of size `dim` by 10."},{"content":"When allocating a multidimensional array, all dimensions except the first must be constant expressions that evaluate to positive values; the leftmost array dimension can be any expression that evaluates to a positive value.","pos":[2048,2271]},{"content":"When allocating an array using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator, the first dimension can be zero — the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator returns a unique pointer.","pos":[2272,2405],"source":" When allocating an array using the **new** operator, the first dimension can be zero — the **new** operator returns a unique pointer."},{"content":"The <bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> cannot contain <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`volatile`</ph>, class declarations, or enumeration declarations.","pos":[2487,2589],"source":"The *type-name* cannot contain **const**, `volatile`, class declarations, or enumeration declarations."},{"content":"Therefore, the following expression is illegal:","pos":[2590,2637]},{"pos":[2705,2789],"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator does not allocate reference types because they are not objects.","source":"The **new** operator does not allocate reference types because they are not objects."},{"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator cannot be used to allocate a function, but it can be used to allocate pointers to functions.","pos":[2796,2909],"source":"The **new** operator cannot be used to allocate a function, but it can be used to allocate pointers to functions."},{"content":"The following example allocates and then frees an array of seven pointers to functions that return integers.","pos":[2910,3018]},{"pos":[3091,3459],"content":"If you use the operator <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> without any extra arguments, and compile with the <bpt id=\"p2\">[</bpt>/GX<ept id=\"p2\">](../build/reference/gx-enable-exception-handling.md)</ept>, <bpt id=\"p3\">[</bpt>/EHa<ept id=\"p3\">](../build/reference/eh-exception-handling-model.md)</ept>, or <bpt id=\"p4\">[</bpt>/EHs<ept id=\"p4\">](../build/reference/eh-exception-handling-model.md)</ept> option, the compiler will generate code to call operator <bpt id=\"p5\">**</bpt>delete<ept id=\"p5\">**</ept> if the constructor throws an exception.","source":"If you use the operator **new** without any extra arguments, and compile with the [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md), or [/EHs](../build/reference/eh-exception-handling-model.md) option, the compiler will generate code to call operator **delete** if the constructor throws an exception."},{"pos":[3466,3527],"content":"The following list describes the grammar elements of <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>:","source":"The following list describes the grammar elements of **new**:"},{"content":"placement","pos":[3535,3544]},{"content":"Provides a way of passing additional arguments if you overload <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","pos":[3549,3620],"source":" Provides a way of passing additional arguments if you overload **new**."},{"content":"type-name","pos":[3628,3637]},{"content":"Specifies type to be allocated; it can be either a built-in or user-defined type.","pos":[3642,3723]},{"content":"If the type specification is complicated, it can be surrounded by parentheses to force the order of binding.","pos":[3724,3832]},{"content":"initializer","pos":[3840,3851]},{"content":"Provides a value for the initialized object.","pos":[3856,3900]},{"content":"Initializers cannot be specified for arrays.","pos":[3901,3945]},{"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator will create arrays of objects only if the class has a default constructor.","pos":[3946,4041],"source":" The **new** operator will create arrays of objects only if the class has a default constructor."},{"content":"Example","pos":[4050,4057]},{"pos":[4061,4167],"content":"The following code example allocates a character array and an object of class <ph id=\"ph1\">`CName`</ph> and then frees them.","source":"The following code example allocates a character array and an object of class `CName` and then frees them."},{"content":"Example","pos":[5087,5094]},{"content":"If you use the placement new form of the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator, the form with arguments in addition to the size of the allocation, the compiler does not support a placement form of the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operator if the constructor throws an exception.","pos":[5098,5337],"source":"If you use the placement new form of the **new** operator, the form with arguments in addition to the size of the allocation, the compiler does not support a placement form of the **delete** operator if the constructor throws an exception."},{"content":"For example:","pos":[5338,5350]},{"content":"Initializing object allocated with new","pos":[6170,6208]},{"content":"An optional <bpt id=\"p1\">*</bpt>initializer<ept id=\"p1\">*</ept> field is included in the grammar for the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator.","pos":[6212,6296],"source":"An optional *initializer* field is included in the grammar for the **new** operator."},{"content":"This allows new objects to be initialized with user-defined constructors.","pos":[6297,6370]},{"content":"For more information about how initialization is done, see <bpt id=\"p1\">[</bpt>Initializers<ept id=\"p1\">](../cpp/initializers.md)</ept>.","pos":[6371,6469],"source":" For more information about how initialization is done, see [Initializers](../cpp/initializers.md)."},{"content":"The following example illustrates how to use an initialization expression with the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator:","pos":[6470,6570],"source":" The following example illustrates how to use an initialization expression with the **new** operator:"},{"content":"In this example, the object <ph id=\"ph1\">`CheckingAcct`</ph> is allocated using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator, but no default initialization is specified.","pos":[7068,7195],"source":"In this example, the object `CheckingAcct` is allocated using the **new** operator, but no default initialization is specified."},{"content":"Therefore, the default constructor for the class, <ph id=\"ph1\">`Acct()`</ph>, is called.","pos":[7196,7266],"source":" Therefore, the default constructor for the class, `Acct()`, is called."},{"content":"Then the object <ph id=\"ph1\">`SavingsAcct`</ph> is allocated the same way, except that it is explicitly initialized to 34.98.","pos":[7267,7374],"source":" Then the object `SavingsAcct` is allocated the same way, except that it is explicitly initialized to 34.98."},{"content":"Because 34.98 is of type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>, the constructor that takes an argument of that type is called to handle the initialization.","pos":[7375,7503],"source":" Because 34.98 is of type **double**, the constructor that takes an argument of that type is called to handle the initialization."},{"content":"Finally, the nonclass type <ph id=\"ph1\">`HowMuch`</ph> is initialized to 43.0.","pos":[7504,7564],"source":" Finally, the nonclass type `HowMuch` is initialized to 43.0."},{"pos":[7571,7759],"content":"If an object is of a class type and that class has constructors (as in the preceding example), the object can be initialized by the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator only if one of these conditions is met:","source":"If an object is of a class type and that class has constructors (as in the preceding example), the object can be initialized by the **new** operator only if one of these conditions is met:"},{"content":"The arguments provided in the initializer agree with those of a constructor.","pos":[7769,7845]},{"content":"The class has a default constructor (a constructor that can be called with no arguments).","pos":[7855,7944]},{"pos":[7951,8284],"content":"Access control and ambiguity control are performed on <ph id=\"ph1\">`operator new`</ph> and on the constructors according to the rules set forth in <bpt id=\"p1\">[</bpt>Ambiguity<ept id=\"p1\">](http://msdn.microsoft.com/en-us/0b399cab-40a7-4e79-9278-05f40139a0e1)</ept> and <bpt id=\"p2\">[</bpt>Initialization Using Special Member Functions<ept id=\"p2\">](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca)</ept>.","source":"Access control and ambiguity control are performed on `operator new` and on the constructors according to the rules set forth in [Ambiguity](http://msdn.microsoft.com/en-us/0b399cab-40a7-4e79-9278-05f40139a0e1) and [Initialization Using Special Member Functions](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca)."},{"content":"No explicit per-element initialization can be done when allocating arrays using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator; only the default constructor, if present, is called.","pos":[8291,8445],"source":"No explicit per-element initialization can be done when allocating arrays using the **new** operator; only the default constructor, if present, is called."},{"content":"See <bpt id=\"p1\">[</bpt>Default Arguments<ept id=\"p1\">](../cpp/default-arguments.md)</ept> for more information.","pos":[8446,8520],"source":" See [Default Arguments](../cpp/default-arguments.md) for more information."},{"content":"If the memory allocation fails (<ph id=\"ph1\">`operator new`</ph> returns a value of 0), no initialization is performed.","pos":[8527,8628],"source":"If the memory allocation fails (`operator new` returns a value of 0), no initialization is performed."},{"content":"This protects against attempts to initialize data that does not exist.","pos":[8629,8699]},{"content":"As with function calls, the order in which initialized expressions are evaluated is not defined.","pos":[8706,8802]},{"content":"Furthermore, you should not rely on these expressions being completely evaluated before the memory allocation is performed.","pos":[8803,8926]},{"content":"If the memory allocation fails and the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator returns zero, some expressions in the initializer may not be completely evaluated.","pos":[8927,9065],"source":" If the memory allocation fails and the **new** operator returns zero, some expressions in the initializer may not be completely evaluated."},{"content":"Lifetime of objects allocated with new","pos":[9074,9112]},{"content":"Objects allocated with the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator are not destroyed when the scope in which they are defined is exited.","pos":[9116,9229],"source":"Objects allocated with the **new** operator are not destroyed when the scope in which they are defined is exited."},{"content":"Because the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator returns a pointer to the objects it allocates, the program must define a pointer with suitable scope to access those objects.","pos":[9230,9384],"source":" Because the **new** operator returns a pointer to the objects it allocates, the program must define a pointer with suitable scope to access those objects."},{"content":"For example:","pos":[9385,9397]},{"pos":[9996,10098],"content":"Once the pointer <ph id=\"ph1\">`AnotherArray`</ph> goes out of scope in the example, the object can no longer be deleted.","source":"Once the pointer `AnotherArray` goes out of scope in the example, the object can no longer be deleted."},{"content":"How new works","pos":[10107,10120]},{"pos":[10124,10221],"content":"The <bpt id=\"p1\">*</bpt>allocation-expression<ept id=\"p1\">*</ept> — the expression containing the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator — does three things:","source":"The *allocation-expression* — the expression containing the **new** operator — does three things:"},{"content":"Locates and reserves storage for the object or objects to be allocated.","pos":[10231,10302]},{"content":"When this stage is complete, the correct amount of storage is allocated, but it is not yet an object.","pos":[10303,10404]},{"content":"Initializes the object(s).","pos":[10414,10440]},{"content":"Once initialization is complete, enough information is present for the allocated storage to be an object.","pos":[10441,10546]},{"content":"Returns a pointer to the object(s) of a pointer type derived from <bpt id=\"p1\">*</bpt>new-type-name<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>type-name<ept id=\"p2\">*</ept>.","pos":[10556,10653],"source":"Returns a pointer to the object(s) of a pointer type derived from *new-type-name* or *type-name*."},{"content":"The program uses this pointer to access the newly allocated object.","pos":[10654,10721]},{"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator invokes the function <ph id=\"ph1\">`operator new`</ph>.","pos":[10728,10785],"source":"The **new** operator invokes the function `operator new`."},{"content":"For arrays of any type, and for objects that are not of <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`struct`</ph>, or <bpt id=\"p2\">**</bpt>union<ept id=\"p2\">**</ept> types, a global function, <bpt id=\"p3\">**</bpt>::operator new<ept id=\"p3\">**</ept>, is called to allocate storage.","pos":[10786,10952],"source":" For arrays of any type, and for objects that are not of **class**, `struct`, or **union** types, a global function, **::operator new**, is called to allocate storage."},{"content":"Class-type objects can define their own <ph id=\"ph1\">`operator new`</ph> static member function on a per-class basis.","pos":[10953,11052],"source":" Class-type objects can define their own `operator new` static member function on a per-class basis."},{"content":"When the compiler encounters the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator to allocate an object of type <ph id=\"ph1\">`type`</ph>, it issues a call to <ph id=\"ph2\">`type`</ph><bpt id=\"p2\">**</bpt>::operator new( sizeof(<ept id=\"p2\">**</ept> <ph id=\"ph3\">`type`</ph> <bpt id=\"p3\">**</bpt>) )<ept id=\"p3\">**</ept> or, if no user-defined <ph id=\"ph4\">`operator new`</ph> is defined, <bpt id=\"p4\">**</bpt>::operator new( sizeof(<ept id=\"p4\">**</ept> <ph id=\"ph5\">`type`</ph> <bpt id=\"p5\">**</bpt>) )<ept id=\"p5\">**</ept>.","pos":[11059,11309],"source":"When the compiler encounters the **new** operator to allocate an object of type `type`, it issues a call to `type`**::operator new( sizeof(** `type` **) )** or, if no user-defined `operator new` is defined, **::operator new( sizeof(** `type` **) )**."},{"content":"Therefore, the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator can allocate the correct amount of memory for the object.","pos":[11310,11399],"source":" Therefore, the **new** operator can allocate the correct amount of memory for the object."},{"pos":[11407,11586],"content":"[!NOTE]\n The argument to `operator new` is of type **size_t**. This type is defined in DIRECT.H, MALLOC.H, MEMORY.H, SEARCH.H, STDDEF.H, STDIO.H, STDLIB.H, STRING.H, and TIME.H.","leadings":["","> "],"nodes":[{"content":" The argument to `operator new` is of type **size_t**. This type is defined in DIRECT.H, MALLOC.H, MEMORY.H, SEARCH.H, STDDEF.H, STDIO.H, STDLIB.H, STRING.H, and TIME.H.","pos":[8,177],"nodes":[{"content":"The argument to <ph id=\"ph1\">`operator new`</ph> is of type <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>.","pos":[1,54],"source":" The argument to `operator new` is of type **size_t**."},{"content":"This type is defined in DIRECT.H, MALLOC.H, MEMORY.H, SEARCH.H, STDDEF.H, STDIO.H, STDLIB.H, STRING.H, and TIME.H.","pos":[55,169]}]}]},{"content":"An option in the grammar allows specification of <bpt id=\"p1\">*</bpt>placement<ept id=\"p1\">*</ept> (see the Grammar for <bpt id=\"p2\">[</bpt>new Operator<ept id=\"p2\">](../cpp/new-operator-cpp.md)</ept>).","pos":[11593,11719],"source":"An option in the grammar allows specification of *placement* (see the Grammar for [new Operator](../cpp/new-operator-cpp.md))."},{"content":"The <bpt id=\"p1\">*</bpt>placement<ept id=\"p1\">*</ept> parameter can be used only for user-defined implementations of <ph id=\"ph1\">`operator new`</ph>; it allows extra information to be passed to <ph id=\"ph2\">`operator new`</ph>.","pos":[11720,11874],"source":" The *placement* parameter can be used only for user-defined implementations of `operator new`; it allows extra information to be passed to `operator new`."},{"content":"An expression with a <bpt id=\"p1\">*</bpt>placement<ept id=\"p1\">*</ept> field such as <ph id=\"ph1\">`T *TObject = new ( 0x0040 ) T;`</ph> is translated to <ph id=\"ph2\">`T *TObject = T::operator new( sizeof( T ), 0x0040 );`</ph> if class T has member operator new, otherwise to <ph id=\"ph3\">`T *TObject = ::operator new( sizeof( T ), 0x0040 );`</ph>.","pos":[11875,12130],"source":" An expression with a *placement* field such as `T *TObject = new ( 0x0040 ) T;` is translated to `T *TObject = T::operator new( sizeof( T ), 0x0040 );` if class T has member operator new, otherwise to `T *TObject = ::operator new( sizeof( T ), 0x0040 );`."},{"pos":[12137,12269],"content":"The original intention of the <bpt id=\"p1\">*</bpt>placement<ept id=\"p1\">*</ept> field was to allow hardware-dependent objects to be allocated at user-specified addresses.","source":"The original intention of the *placement* field was to allow hardware-dependent objects to be allocated at user-specified addresses."},{"pos":[12277,12462],"content":"[!NOTE]\n Although the preceding example shows only one argument in the *placement* field, there is no restriction on how many extra arguments can be passed to `operator new` this way.","leadings":["","> "],"nodes":[{"content":"Although the preceding example shows only one argument in the <bpt id=\"p1\">*</bpt>placement<ept id=\"p1\">*</ept> field, there is no restriction on how many extra arguments can be passed to <ph id=\"ph1\">`operator new`</ph> this way.","pos":[9,183],"source":" Although the preceding example shows only one argument in the *placement* field, there is no restriction on how many extra arguments can be passed to `operator new` this way."}]},{"pos":[12469,12595],"content":"Even when <ph id=\"ph1\">`operator new`</ph> has been defined for a class type, the global operator can be used by using the form of this example:","source":"Even when `operator new` has been defined for a class type, the global operator can be used by using the form of this example:"},{"pos":[12646,12725],"content":"The scope-resolution operator (<ph id=\"ph1\">`::`</ph>) forces use of the global <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator.","source":"The scope-resolution operator (`::`) forces use of the global **new** operator."},{"content":"See Also","pos":[12734,12742]},{"content":"Expressions with Unary Operators","pos":[12747,12779]},{"content":"Keywords","pos":[12830,12838]},{"content":"new and delete operators","pos":[12869,12893]}],"content":"---\ntitle: \"new Operator (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"new keyword [C++]\"\nms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# new Operator (C++)\nAllocates memory for an object or array of objects of *type-name* from the free store and returns a suitably typed, nonzero pointer to the object.  \n  \n> [!NOTE]\n>  Microsoft C++ Component Extensions provides support for the `new` keyword to add vtable slot entries. For more information, see [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)  \n  \n## Syntax  \n  \n```  \n[::] new [placement] new-type-name [new-initializer]  \n[::] new [placement] ( type-name ) [new-initializer]  \n```  \n  \n## Remarks  \n If unsuccessful, **new** returns zero or throws an exception; see [The new and delete Operators](../cpp/new-and-delete-operators.md) for more information. You can change this default behavior by writing a custom exception-handling routine and calling the [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) run-time library function with your function name as its argument.  \n  \n For information on how to create an object on the managed heap, see [gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md).  \n  \n When **new** is used to allocate memory for a C++ class object, the object's constructor is called after the memory is allocated.  \n  \n Use the [delete](../cpp/delete-operator-cpp.md) operator to deallocate the memory allocated with the **new** operator.  \n  \n The following example allocates and then frees a two-dimensional array of characters of size `dim` by 10. When allocating a multidimensional array, all dimensions except the first must be constant expressions that evaluate to positive values; the leftmost array dimension can be any expression that evaluates to a positive value. When allocating an array using the **new** operator, the first dimension can be zero — the **new** operator returns a unique pointer.  \n  \n```  \nchar (*pchar)[10] = new char[dim][10];  \ndelete [] pchar;  \n```  \n  \n The *type-name* cannot contain **const**, `volatile`, class declarations, or enumeration declarations. Therefore, the following expression is illegal:  \n  \n```  \nvolatile char *vch = new volatile char[20];  \n```  \n  \n The **new** operator does not allocate reference types because they are not objects.  \n  \n The **new** operator cannot be used to allocate a function, but it can be used to allocate pointers to functions. The following example allocates and then frees an array of seven pointers to functions that return integers.  \n  \n```  \nint (**p) () = new (int (*[7]) ());  \ndelete *p;  \n```  \n  \n If you use the operator **new** without any extra arguments, and compile with the [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md), or [/EHs](../build/reference/eh-exception-handling-model.md) option, the compiler will generate code to call operator **delete** if the constructor throws an exception.  \n  \n The following list describes the grammar elements of **new**:  \n  \n *placement*  \n Provides a way of passing additional arguments if you overload **new**.  \n  \n *type-name*  \n Specifies type to be allocated; it can be either a built-in or user-defined type. If the type specification is complicated, it can be surrounded by parentheses to force the order of binding.  \n  \n *initializer*  \n Provides a value for the initialized object. Initializers cannot be specified for arrays. The **new** operator will create arrays of objects only if the class has a default constructor.  \n  \n## Example  \n The following code example allocates a character array and an object of class `CName` and then frees them.  \n  \n```  \n// expre_new_Operator.cpp  \n// compile with: /EHsc  \n#include <string.h>  \n  \nclass CName {  \npublic:  \n   enum {  \n      sizeOfBuffer = 256  \n   };  \n  \n   char m_szFirst[sizeOfBuffer];  \n   char m_szLast[sizeOfBuffer];  \n  \npublic:  \n   void SetName(char* pszFirst, char* pszLast) {  \n     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);  \n     strcpy_s(m_szLast, sizeOfBuffer, pszLast);  \n   }  \n  \n};  \n  \nint main() {  \n   // Allocate memory for the array  \n   char* pCharArray = new char[CName::sizeOfBuffer];  \n   strcpy_s(pCharArray, CName::sizeOfBuffer, \"Array of characters\");  \n  \n   // Deallocate memory for the array  \n   delete [] pCharArray;             \n   pCharArray = NULL;  \n  \n   // Allocate memory for the object  \n   CName* pName = new CName;  \n   pName->SetName(\"Firstname\", \"Lastname\");  \n  \n   // Deallocate memory for the object  \n   delete pName;  \n   pName = NULL;  \n}  \n```  \n  \n## Example  \n If you use the placement new form of the **new** operator, the form with arguments in addition to the size of the allocation, the compiler does not support a placement form of the **delete** operator if the constructor throws an exception. For example:  \n  \n```  \n// expre_new_Operator2.cpp  \n// C2660 expected  \nclass A {  \npublic:  \n   A(int) { throw \"Fail!\"; }  \n};  \nvoid F(void) {  \n   try {  \n      // heap memory pointed to by pa1 will be deallocated  \n      // by calling ::operator delete(void*).  \n      A* pa1 = new A(10);  \n   } catch (...) {  \n   }  \n   try {  \n      // This will call ::operator new(size_t, char*, int).  \n      // When A::A(int) does a throw, we should call  \n      // ::operator delete(void*, char*, int) to deallocate  \n      // the memory pointed to by pa2.  Since  \n      // ::operator delete(void*, char*, int) has not been implemented,  \n      // memory will be leaked when the deallocation cannot occur.  \n  \n      A* pa2 = new(__FILE__, __LINE__) A(20);  \n   } catch (...) {  \n   }  \n}  \n  \nint main() {  \n   A a;  \n}  \n```  \n  \n## Initializing object allocated with new  \n An optional *initializer* field is included in the grammar for the **new** operator. This allows new objects to be initialized with user-defined constructors. For more information about how initialization is done, see [Initializers](../cpp/initializers.md). The following example illustrates how to use an initialization expression with the **new** operator:  \n  \n```  \n// expre_Initializing_Objects_Allocated_with_new.cpp  \nclass Acct  \n{  \npublic:  \n    // Define default constructor and a constructor that accepts  \n    //  an initial balance.  \n    Acct() { balance = 0.0; }  \n    Acct( double init_balance ) { balance = init_balance; }  \nprivate:  \n    double balance;  \n};  \n  \nint main()  \n{  \n    Acct *CheckingAcct = new Acct;  \n    Acct *SavingsAcct = new Acct ( 34.98 );  \n    double *HowMuch = new double ( 43.0 );  \n    // ...  \n}  \n```  \n  \n In this example, the object `CheckingAcct` is allocated using the **new** operator, but no default initialization is specified. Therefore, the default constructor for the class, `Acct()`, is called. Then the object `SavingsAcct` is allocated the same way, except that it is explicitly initialized to 34.98. Because 34.98 is of type **double**, the constructor that takes an argument of that type is called to handle the initialization. Finally, the nonclass type `HowMuch` is initialized to 43.0.  \n  \n If an object is of a class type and that class has constructors (as in the preceding example), the object can be initialized by the **new** operator only if one of these conditions is met:  \n  \n-   The arguments provided in the initializer agree with those of a constructor.  \n  \n-   The class has a default constructor (a constructor that can be called with no arguments).  \n  \n Access control and ambiguity control are performed on `operator new` and on the constructors according to the rules set forth in [Ambiguity](http://msdn.microsoft.com/en-us/0b399cab-40a7-4e79-9278-05f40139a0e1) and [Initialization Using Special Member Functions](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca).  \n  \n No explicit per-element initialization can be done when allocating arrays using the **new** operator; only the default constructor, if present, is called. See [Default Arguments](../cpp/default-arguments.md) for more information.  \n  \n If the memory allocation fails (`operator new` returns a value of 0), no initialization is performed. This protects against attempts to initialize data that does not exist.  \n  \n As with function calls, the order in which initialized expressions are evaluated is not defined. Furthermore, you should not rely on these expressions being completely evaluated before the memory allocation is performed. If the memory allocation fails and the **new** operator returns zero, some expressions in the initializer may not be completely evaluated.  \n  \n## Lifetime of objects allocated with new  \n Objects allocated with the **new** operator are not destroyed when the scope in which they are defined is exited. Because the **new** operator returns a pointer to the objects it allocates, the program must define a pointer with suitable scope to access those objects. For example:  \n  \n```  \n// expre_Lifetime_of_Objects_Allocated_with_new.cpp  \n// C2541 expected  \nint main()  \n{  \n    // Use new operator to allocate an array of 20 characters.  \n    char *AnArray = new char[20];  \n  \n    for( int i = 0; i < 20; ++i )  \n    {  \n        // On the first iteration of the loop, allocate  \n        //  another array of 20 characters.  \n        if( i == 0 )  \n        {  \n            char *AnotherArray = new char[20];  \n        }  \n    }  \n  \n    delete [] AnotherArray; // Error: pointer out of scope.  \n    delete [] AnArray;      // OK: pointer still in scope.  \n}  \n```  \n  \n Once the pointer `AnotherArray` goes out of scope in the example, the object can no longer be deleted.  \n  \n## How new works  \n The *allocation-expression* — the expression containing the **new** operator — does three things:  \n  \n-   Locates and reserves storage for the object or objects to be allocated. When this stage is complete, the correct amount of storage is allocated, but it is not yet an object.  \n  \n-   Initializes the object(s). Once initialization is complete, enough information is present for the allocated storage to be an object.  \n  \n-   Returns a pointer to the object(s) of a pointer type derived from *new-type-name* or *type-name*. The program uses this pointer to access the newly allocated object.  \n  \n The **new** operator invokes the function `operator new`. For arrays of any type, and for objects that are not of **class**, `struct`, or **union** types, a global function, **::operator new**, is called to allocate storage. Class-type objects can define their own `operator new` static member function on a per-class basis.  \n  \n When the compiler encounters the **new** operator to allocate an object of type `type`, it issues a call to `type`**::operator new( sizeof(** `type` **) )** or, if no user-defined `operator new` is defined, **::operator new( sizeof(** `type` **) )**. Therefore, the **new** operator can allocate the correct amount of memory for the object.  \n  \n> [!NOTE]\n>  The argument to `operator new` is of type **size_t**. This type is defined in DIRECT.H, MALLOC.H, MEMORY.H, SEARCH.H, STDDEF.H, STDIO.H, STDLIB.H, STRING.H, and TIME.H.  \n  \n An option in the grammar allows specification of *placement* (see the Grammar for [new Operator](../cpp/new-operator-cpp.md)). The *placement* parameter can be used only for user-defined implementations of `operator new`; it allows extra information to be passed to `operator new`. An expression with a *placement* field such as `T *TObject = new ( 0x0040 ) T;` is translated to `T *TObject = T::operator new( sizeof( T ), 0x0040 );` if class T has member operator new, otherwise to `T *TObject = ::operator new( sizeof( T ), 0x0040 );`.  \n  \n The original intention of the *placement* field was to allow hardware-dependent objects to be allocated at user-specified addresses.  \n  \n> [!NOTE]\n>  Although the preceding example shows only one argument in the *placement* field, there is no restriction on how many extra arguments can be passed to `operator new` this way.  \n  \n Even when `operator new` has been defined for a class type, the global operator can be used by using the form of this example:  \n  \n```  \nT *TObject =::new TObject;  \n```  \n  \n The scope-resolution operator (`::`) forces use of the global **new** operator.  \n  \n## See Also  \n [Expressions with Unary Operators](../cpp/expressions-with-unary-operators.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [new and delete operators](../cpp/new-and-delete-operators.md)"}