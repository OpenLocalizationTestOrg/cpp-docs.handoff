{"nodes":[{"pos":[12,48],"content":"Subscript Operator: | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Subscript Operator: | Microsoft Docs","pos":[0,36]}]},{"content":"Subscript Operator:","pos":[692,711]},{"content":"Syntax","pos":[715,721]},{"content":"Remarks","pos":[784,791]},{"pos":[795,927],"content":"A postfix expression (which can also be a primary expression) followed by the subscript operator, <bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept>, specifies array indexing.","source":"A postfix expression (which can also be a primary expression) followed by the subscript operator, **[ ]**, specifies array indexing."},{"pos":[934,1032],"content":"For information about managed arrays, see <bpt id=\"p1\">[</bpt>Arrays<ept id=\"p1\">](../windows/arrays-cpp-component-extensions.md)</ept>.","source":"For information about managed arrays, see [Arrays](../windows/arrays-cpp-component-extensions.md)."},{"content":"Usually, the value represented by <bpt id=\"p1\">*</bpt>postfix-expression<ept id=\"p1\">*</ept> is a pointer value, such as an array identifier, and <bpt id=\"p2\">*</bpt>expression<ept id=\"p2\">*</ept> is an integral value (including enumerated types).","pos":[1039,1210],"source":"Usually, the value represented by *postfix-expression* is a pointer value, such as an array identifier, and *expression* is an integral value (including enumerated types)."},{"content":"However, all that is required syntactically is that one of the expressions be of pointer type and the other be of integral type.","pos":[1211,1339]},{"content":"Thus the integral value could be in the <bpt id=\"p1\">*</bpt>postfix-expression<ept id=\"p1\">*</ept> position and the pointer value could be in the brackets in the <bpt id=\"p2\">*</bpt>expression<ept id=\"p2\">*</ept> or subscript position.","pos":[1340,1499],"source":" Thus the integral value could be in the *postfix-expression* position and the pointer value could be in the brackets in the *expression* or subscript position."},{"content":"Consider the following code fragment:","pos":[1500,1537]},{"content":"In the preceding example, the expression <ph id=\"ph1\">`nArray[2]`</ph> is identical to <ph id=\"ph2\">`2[nArray]`</ph>.","pos":[1704,1785],"source":"In the preceding example, the expression `nArray[2]` is identical to `2[nArray]`."},{"content":"The reason is that the result of a subscript expression <bpt id=\"p1\">*</bpt>e1<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt>[<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>e2<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt>]<ept id=\"p4\">**</ept> is given by:","pos":[1786,1875],"source":" The reason is that the result of a subscript expression *e1***[** *e2* **]** is given by:"},{"pos":[1882,1923],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>( (<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>e2<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt><ph id=\"ph2\">+</ph><ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>(<ept id=\"p5\">**</ept><bpt id=\"p6\">*</bpt>e1<ept id=\"p6\">*</ept><bpt id=\"p7\">**</bpt>) )<ept id=\"p7\">**</ept>","source":"**\\*( (** *e2* **)** *+* **(***e1***) )**"},{"content":"The address yielded by the expression is not <bpt id=\"p1\">*</bpt>e2<ept id=\"p1\">*</ept> bytes from the address <bpt id=\"p2\">*</bpt>e1<ept id=\"p2\">*</ept>.","pos":[1930,2008],"source":"The address yielded by the expression is not *e2* bytes from the address *e1*."},{"content":"Rather, the address is scaled to yield the next object in the array <bpt id=\"p1\">*</bpt>e2<ept id=\"p1\">*</ept>.","pos":[2009,2082],"source":" Rather, the address is scaled to yield the next object in the array *e2*."},{"content":"For example:","pos":[2083,2095]},{"content":"The addresses of <ph id=\"ph1\">`aDb[0]`</ph> and <ph id=\"ph2\">`aDb[1]`</ph> are 8 bytes apart — the size of an object of type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","pos":[2135,2235],"source":"The addresses of `aDb[0]` and `aDb[1]` are 8 bytes apart — the size of an object of type **double**."},{"content":"This scaling according to object type is done automatically by the C++ language and is defined in <bpt id=\"p1\">[</bpt>Additive Operators<ept id=\"p1\">](../cpp/additive-operators-plus-and.md)</ept> where addition and subtraction of operands of pointer type is discussed.","pos":[2236,2466],"source":" This scaling according to object type is done automatically by the C++ language and is defined in [Additive Operators](../cpp/additive-operators-plus-and.md) where addition and subtraction of operands of pointer type is discussed."},{"content":"A subscript expression can also have multiple subscripts, as follows:","pos":[2473,2542]},{"pos":[2549,2609],"content":"<bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>[<ept id=\"p2\">**</ept><bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept><bpt id=\"p4\">**</bpt>] [<ept id=\"p4\">**</ept><bpt id=\"p5\">*</bpt>expression3<ept id=\"p5\">*</ept><bpt id=\"p6\">**</bpt>]<ept id=\"p6\">**</ept>...","source":"*expression1* **[***expression2***] [***expression3***]**..."},{"content":"Subscript expressions associate from left to right.","pos":[2616,2667]},{"content":"The leftmost subscript expression, <bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt>[<ept id=\"p2\">**</ept><bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept><bpt id=\"p4\">**</bpt>]<ept id=\"p4\">**</ept>, is evaluated first.","pos":[2668,2760],"source":" The leftmost subscript expression, *expression1***[***expression2***]**, is evaluated first."},{"content":"The address that results from adding <bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>expression2<ept id=\"p2\">*</ept> forms a pointer expression; then <bpt id=\"p3\">*</bpt>expression3<ept id=\"p3\">*</ept> is added to this pointer expression to form a new pointer expression, and so on until the last subscript expression has been added.","pos":[2761,3008],"source":" The address that results from adding *expression1* and *expression2* forms a pointer expression; then *expression3* is added to this pointer expression to form a new pointer expression, and so on until the last subscript expression has been added."},{"content":"The indirection operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>) is applied after the last subscripted expression is evaluated, unless the final pointer value addresses an array type.","pos":[3009,3161],"source":" The indirection operator (**\\***) is applied after the last subscripted expression is evaluated, unless the final pointer value addresses an array type."},{"content":"Expressions with multiple subscripts refer to elements of multidimensional arrays.","pos":[3168,3250]},{"content":"A multidimensional array is an array whose elements are arrays.","pos":[3251,3314]},{"content":"For example, the first element of a three-dimensional array is an array with two dimensions.","pos":[3315,3407]},{"content":"The following example declares and initializes a simple two-dimensional array of characters:","pos":[3408,3500]},{"content":"Positive and negative subscripts","pos":[3892,3924]},{"content":"The first element of an array is element 0.","pos":[3928,3971]},{"content":"The range of a C++ array is from <bpt id=\"p1\">*</bpt>array<ept id=\"p1\">*</ept>[0] to <bpt id=\"p2\">*</bpt>array<ept id=\"p2\">*</ept>[<bpt id=\"p3\">*</bpt>size<ept id=\"p3\">*</ept> – 1].","pos":[3972,4039],"source":" The range of a C++ array is from *array*[0] to *array*[*size* – 1]."},{"content":"However, C++ supports positive and negative subscripts.","pos":[4040,4095]},{"content":"Negative subscripts must fall within array boundaries; if they do not, the results are unpredictable.","pos":[4096,4197]},{"content":"The following code shows positive and negative array subscripts:","pos":[4198,4262]},{"content":"The negative subscript in the lasta line can produce a run-time error because it points an address 256 bytes lower in memory than the origin of the array.","pos":[4700,4854]},{"content":"The pointer <ph id=\"ph1\">`midArray`</ph> is initialized to the middle of <ph id=\"ph2\">`intArray`</ph>; it is therefore possible to use both positive and negative array indices on it.","pos":[4855,5001],"source":" The pointer `midArray` is initialized to the middle of `intArray`; it is therefore possible to use both positive and negative array indices on it."},{"content":"Array subscript errors do not generate compile-time errors, but they yield unpredictable results.","pos":[5002,5099]},{"content":"The subscript operator is commutative.","pos":[5106,5144]},{"content":"Therefore, the expressions <bpt id=\"p1\">*</bpt>array<ept id=\"p1\">*</ept>[<bpt id=\"p2\">*</bpt>index<ept id=\"p2\">*</ept>] and <bpt id=\"p3\">*</bpt>array<ept id=\"p3\">*</ept>[<bpt id=\"p4\">*</bpt>array<ept id=\"p4\">*</ept>] are guaranteed to be equivalent as long as the subscript operator is not overloaded (see <bpt id=\"p5\">[</bpt>Overloaded Operators<ept id=\"p5\">](../cpp/operator-overloading.md)</ept>).","pos":[5145,5355],"source":" Therefore, the expressions *array*[*index*] and *array*[*array*] are guaranteed to be equivalent as long as the subscript operator is not overloaded (see [Overloaded Operators](../cpp/operator-overloading.md))."},{"content":"The first form is the most common coding practice, but either works.","pos":[5356,5424]},{"content":"See Also","pos":[5433,5441]},{"content":"Postfix Expressions","pos":[5446,5465]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[5503,5555]},{"content":"Arrays","pos":[5625,5631]},{"content":"One-Dimensional Arrays","pos":[5660,5682]},{"content":"Multidimensional Arrays","pos":[5730,5753]}],"content":"---\ntitle: \"Subscript Operator: | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"[]\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"operators [C++], subscript\"\n  - \"postfix operators\"\n  - \"[] operator\"\n  - \"subscript operator, syntax\"\nms.assetid: 69c31494-52da-4dd0-8bbe-6ccbfd50f197\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Subscript Operator:\n## Syntax  \n  \n```  \n  \npostfix-expression [ expression ]  \n```  \n  \n## Remarks  \n A postfix expression (which can also be a primary expression) followed by the subscript operator, **[ ]**, specifies array indexing.  \n  \n For information about managed arrays, see [Arrays](../windows/arrays-cpp-component-extensions.md).  \n  \n Usually, the value represented by *postfix-expression* is a pointer value, such as an array identifier, and *expression* is an integral value (including enumerated types). However, all that is required syntactically is that one of the expressions be of pointer type and the other be of integral type. Thus the integral value could be in the *postfix-expression* position and the pointer value could be in the brackets in the *expression* or subscript position. Consider the following code fragment:  \n  \n```  \nint nArray[5] = { 0, 1, 2, 3, 4 };  \ncout << nArray[2] << endl;            // prints \"2\"  \ncout << 2[nArray] << endl;            // prints \"2\"  \n```  \n  \n In the preceding example, the expression `nArray[2]` is identical to `2[nArray]`. The reason is that the result of a subscript expression *e1***[** *e2* **]** is given by:  \n  \n **\\*( (** *e2* **)** *+* **(***e1***) )**  \n  \n The address yielded by the expression is not *e2* bytes from the address *e1*. Rather, the address is scaled to yield the next object in the array *e2*. For example:  \n  \n```  \ndouble aDbl[2];  \n```  \n  \n The addresses of `aDb[0]` and `aDb[1]` are 8 bytes apart — the size of an object of type **double**. This scaling according to object type is done automatically by the C++ language and is defined in [Additive Operators](../cpp/additive-operators-plus-and.md) where addition and subtraction of operands of pointer type is discussed.  \n  \n A subscript expression can also have multiple subscripts, as follows:  \n  \n *expression1* **[***expression2***] [***expression3***]**...  \n  \n Subscript expressions associate from left to right. The leftmost subscript expression, *expression1***[***expression2***]**, is evaluated first. The address that results from adding *expression1* and *expression2* forms a pointer expression; then *expression3* is added to this pointer expression to form a new pointer expression, and so on until the last subscript expression has been added. The indirection operator (**\\***) is applied after the last subscripted expression is evaluated, unless the final pointer value addresses an array type.  \n  \n Expressions with multiple subscripts refer to elements of multidimensional arrays. A multidimensional array is an array whose elements are arrays. For example, the first element of a three-dimensional array is an array with two dimensions. The following example declares and initializes a simple two-dimensional array of characters:  \n  \n```  \n// expre_Subscript_Operator.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \n#define MAX_ROWS 2  \n#define MAX_COLS 2  \n  \nint main() {  \n   char c[ MAX_ROWS ][ MAX_COLS ] = { { 'a', 'b' }, { 'c', 'd' } };  \n   for ( int i = 0; i < MAX_ROWS; i++ )  \n      for ( int j = 0; j < MAX_COLS; j++ )  \n         cout << c[ i ][ j ] << endl;  \n}  \n```  \n  \n## Positive and negative subscripts  \n The first element of an array is element 0. The range of a C++ array is from *array*[0] to *array*[*size* – 1]. However, C++ supports positive and negative subscripts. Negative subscripts must fall within array boundaries; if they do not, the results are unpredictable. The following code shows positive and negative array subscripts:  \n  \n```  \n#include <iostream>  \nusing namespace std;  \n  \nint main() {  \n    int intArray[1024];  \n    for (int i = 0, j = 0; i < 1024; i++)  \n    {  \n        intArray[i] = j++;  \n    }  \n  \n    cout << intArray[512] << endl;// 512  \n  \n    int *midArray = &intArray[512];  // pointer to the middle of the array  \n  \n    cout << midArray[-256] << endl;   // 256  \n  \n    cout << intArray[-256] << endl; // unpredictable  \n}  \n```  \n  \n The negative subscript in the lasta line can produce a run-time error because it points an address 256 bytes lower in memory than the origin of the array. The pointer `midArray` is initialized to the middle of `intArray`; it is therefore possible to use both positive and negative array indices on it. Array subscript errors do not generate compile-time errors, but they yield unpredictable results.  \n  \n The subscript operator is commutative. Therefore, the expressions *array*[*index*] and *array*[*array*] are guaranteed to be equivalent as long as the subscript operator is not overloaded (see [Overloaded Operators](../cpp/operator-overloading.md)). The first form is the most common coding practice, but either works.  \n  \n## See Also  \n [Postfix Expressions](../cpp/postfix-expressions.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Arrays](../cpp/arrays-cpp.md)   \n [One-Dimensional Arrays](../c-language/one-dimensional-arrays.md)   \n [Multidimensional Arrays](../c-language/multidimensional-arrays-c.md)"}