{"nodes":[{"pos":[12,72],"content":"Walkthrough: Using join to Prevent Deadlock | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Walkthrough: Using join to Prevent Deadlock | Microsoft Docs","pos":[0,60]}]},{"content":"Walkthrough: Using join to Prevent Deadlock","pos":[767,810]},{"content":"This topic uses the dining philosophers problem to illustrate how to use the <bpt id=\"p1\">[</bpt>concurrency::join<ept id=\"p1\">](../../parallel/concrt/reference/join-class.md)</ept> class to prevent deadlock in your application.","pos":[811,1001],"source":"This topic uses the dining philosophers problem to illustrate how to use the [concurrency::join](../../parallel/concrt/reference/join-class.md) class to prevent deadlock in your application."},{"content":"In a software application, <bpt id=\"p1\">*</bpt>deadlock<ept id=\"p1\">*</ept> occurs when two or more processes each hold a resource and mutually wait for another process to release some other resource.","pos":[1002,1164],"source":" In a software application, *deadlock* occurs when two or more processes each hold a resource and mutually wait for another process to release some other resource."},{"content":"The dining philosophers problem is a specific example of the general set of problems that may occur when a set of resources is shared among multiple concurrent processes.","pos":[1171,1341]},{"content":"Prerequisites","pos":[1350,1363]},{"content":"Read the following topics before you start this walkthrough:","pos":[1367,1427]},{"content":"Asynchronous Agents","pos":[1436,1455]},{"content":"Walkthrough: Creating an Agent-Based Application","pos":[1511,1559]},{"content":"Asynchronous Message Blocks","pos":[1643,1670]},{"content":"Message Passing Functions","pos":[1734,1759]},{"content":"Synchronization Data Structures","pos":[1821,1852]},{"pos":[1940,1948],"content":"Sections"},{"content":"This walkthrough contains the following sections:","pos":[1952,2001]},{"content":"The Dining Philosophers Problem","pos":[2010,2041]},{"content":"A Naïve Implementation","pos":[2061,2083]},{"content":"Using join to Prevent Deadlock","pos":[2104,2134]},{"pos":[2179,2210],"content":"The Dining Philosophers Problem"},{"content":"The dining philosophers problem illustrates how deadlock occurs in an application.","pos":[2214,2296]},{"content":"In this problem, five philosophers sit at a round table.","pos":[2297,2353]},{"content":"Every philosopher alternates between thinking and eating.","pos":[2354,2411]},{"content":"Every philosopher must share a chopstick with the neighbor to the left and another chopstick with the neighbor to the right.","pos":[2412,2536]},{"content":"The following illustration shows this layout.","pos":[2537,2582]},{"content":"The Dining Philosophers Problem","pos":[2591,2622]},{"content":"To eat, a philosopher must hold two chopsticks.","pos":[2719,2766]},{"content":"If every philosopher holds just one chopstick and is waiting for another one, then no philosopher can eat and all starve.","pos":[2767,2888]},{"pos":[2895,2908],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[2942,2964],"content":"A Naïve Implementation"},{"content":"The following example shows a naïve implementation of the dining philosophers problem.","pos":[2968,3054]},{"content":"The <ph id=\"ph1\">`philosopher`</ph> class, which derives from <bpt id=\"p1\">[</bpt>concurrency::agent<ept id=\"p1\">](../../parallel/concrt/reference/agent-class.md)</ept>, enables each philosopher to act independently.","pos":[3055,3215],"source":" The `philosopher` class, which derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md), enables each philosopher to act independently."},{"content":"The example uses a shared array of <bpt id=\"p1\">[</bpt>concurrency::critical_section<ept id=\"p1\">](../../parallel/concrt/reference/critical-section-class.md)</ept> objects to give each <ph id=\"ph1\">`philosopher`</ph> object exclusive access to a pair of chopsticks.","pos":[3216,3425],"source":" The example uses a shared array of [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md) objects to give each `philosopher` object exclusive access to a pair of chopsticks."},{"content":"To relate the implementation to the illustration, the <ph id=\"ph1\">`philosopher`</ph> class represents one philosopher.","pos":[3432,3533],"source":"To relate the implementation to the illustration, the `philosopher` class represents one philosopher."},{"content":"An <ph id=\"ph1\">`int`</ph> variable represents each chopstick.","pos":[3534,3578],"source":" An `int` variable represents each chopstick."},{"content":"The <ph id=\"ph1\">`critical_section`</ph> objects serve as holders on which the chopsticks rest.","pos":[3579,3656],"source":" The `critical_section` objects serve as holders on which the chopsticks rest."},{"content":"The <ph id=\"ph1\">`run`</ph> method simulates the life of the philosopher.","pos":[3657,3712],"source":" The `run` method simulates the life of the philosopher."},{"content":"The <ph id=\"ph1\">`think`</ph> method simulates the act of thinking and the <ph id=\"ph2\">`eat`</ph> method simulates the act of eating.","pos":[3713,3811],"source":" The `think` method simulates the act of thinking and the `eat` method simulates the act of eating."},{"content":"A <ph id=\"ph1\">`philosopher`</ph> object locks both <ph id=\"ph2\">`critical_section`</ph> objects to simulate the removal of the chopsticks from the holders before it calls the <ph id=\"ph3\">`eat`</ph> method.","pos":[3818,3971],"source":"A `philosopher` object locks both `critical_section` objects to simulate the removal of the chopsticks from the holders before it calls the `eat` method."},{"content":"After the call to <ph id=\"ph1\">`eat`</ph>, the <ph id=\"ph2\">`philosopher`</ph> object returns the chopsticks to the holders by setting the <ph id=\"ph3\">`critical_section`</ph> objects back to the unlocked state.","pos":[3972,4129],"source":" After the call to `eat`, the `philosopher` object returns the chopsticks to the holders by setting the `critical_section` objects back to the unlocked state."},{"content":"The <ph id=\"ph1\">`pickup_chopsticks`</ph> method illustrates where deadlock can occur.","pos":[4136,4204],"source":"The `pickup_chopsticks` method illustrates where deadlock can occur."},{"content":"If every <ph id=\"ph1\">`philosopher`</ph> object gains access to one of the locks, then no <ph id=\"ph2\">`philosopher`</ph> object can continue because the other lock is controlled by another <ph id=\"ph3\">`philosopher`</ph> object.","pos":[4205,4380],"source":" If every `philosopher` object gains access to one of the locks, then no `philosopher` object can continue because the other lock is controlled by another `philosopher` object."},{"content":"Example","pos":[4389,4396]},{"content":"Description","pos":[4406,4417]},{"content":"Code","pos":[4427,4431]},{"pos":[4446,4476],"content":"concrt-philosophers-deadlock#1"},{"content":"Compiling the Code","pos":[4575,4593]},{"pos":[4597,4800],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`philosophers-deadlock.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `philosophers-deadlock.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc philosophers-deadlock.cpp","pos":[4809,4847]},{"pos":[4856,4869],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[4903,4933],"content":"Using join to Prevent Deadlock"},{"content":"This section shows how to use message buffers and message-passing functions to eliminate the chance of deadlock.","pos":[4937,5049]},{"content":"To relate this example to the earlier one, the <ph id=\"ph1\">`philosopher`</ph> class replaces each <ph id=\"ph2\">`critical_section`</ph> object by using a <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept> object and a <ph id=\"ph3\">`join`</ph> object.","pos":[5056,5270],"source":"To relate this example to the earlier one, the `philosopher` class replaces each `critical_section` object by using a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object and a `join` object."},{"content":"The <ph id=\"ph1\">`join`</ph> object serves as an arbiter that provides the chopsticks to the philosopher.","pos":[5271,5358],"source":" The `join` object serves as an arbiter that provides the chopsticks to the philosopher."},{"content":"This example uses the <ph id=\"ph1\">`unbounded_buffer`</ph> class because when a target receives a message from an <ph id=\"ph2\">`unbounded_buffer`</ph> object, the message is removed from the message queue.","pos":[5365,5534],"source":"This example uses the `unbounded_buffer` class because when a target receives a message from an `unbounded_buffer` object, the message is removed from the message queue."},{"content":"This enables an <ph id=\"ph1\">`unbounded_buffer`</ph> object that holds a message to indicate that the chopstick is available.","pos":[5535,5642],"source":" This enables an `unbounded_buffer` object that holds a message to indicate that the chopstick is available."},{"content":"An <ph id=\"ph1\">`unbounded_buffer`</ph> object that holds no message indicates that the chopstick is being used.","pos":[5643,5737],"source":" An `unbounded_buffer` object that holds no message indicates that the chopstick is being used."},{"content":"This example uses a non-greedy <ph id=\"ph1\">`join`</ph> object because a non-greedy join gives each <ph id=\"ph2\">`philosopher`</ph> object access to both chopsticks only when both <ph id=\"ph3\">`unbounded_buffer`</ph> objects contain a message.","pos":[5744,5933],"source":"This example uses a non-greedy `join` object because a non-greedy join gives each `philosopher` object access to both chopsticks only when both `unbounded_buffer` objects contain a message."},{"content":"A greedy join would not prevent deadlock because a greedy join accepts messages as soon as they become available.","pos":[5934,6047]},{"content":"Deadlock can occur if all greedy <ph id=\"ph1\">`join`</ph> objects receive one of the messages but wait forever for the other to become available.","pos":[6048,6175],"source":" Deadlock can occur if all greedy `join` objects receive one of the messages but wait forever for the other to become available."},{"pos":[6182,6388],"content":"For more information about greedy and non-greedy joins, and the differences between the various message buffer types, see <bpt id=\"p1\">[</bpt>Asynchronous Message Blocks<ept id=\"p1\">](../../parallel/concrt/asynchronous-message-blocks.md)</ept>.","source":"For more information about greedy and non-greedy joins, and the differences between the various message buffer types, see [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)."},{"content":"To prevent deadlock in this example","pos":[6399,6434]},{"content":"Remove the following code from the example.","pos":[6444,6487]},{"pos":[6505,6535],"content":"concrt-philosophers-deadlock#2"},{"pos":[6635,6741],"content":"Change the type of the <ph id=\"ph1\">`_left`</ph> and <ph id=\"ph2\">`_right`</ph> data members of the <ph id=\"ph3\">`philosopher`</ph> class to <ph id=\"ph4\">`unbounded_buffer`</ph>.","source":"Change the type of the `_left` and `_right` data members of the `philosopher` class to `unbounded_buffer`."},{"pos":[6759,6785],"content":"concrt-philosophers-join#2"},{"pos":[6885,6975],"content":"Modify the <ph id=\"ph1\">`philosopher`</ph> constructor to take <ph id=\"ph2\">`unbounded_buffer`</ph> objects as its parameters.","source":"Modify the `philosopher` constructor to take `unbounded_buffer` objects as its parameters."},{"pos":[6993,7019],"content":"concrt-philosophers-join#3"},{"pos":[7119,7256],"content":"Modify the <ph id=\"ph1\">`pickup_chopsticks`</ph> method to use a non-greedy <ph id=\"ph2\">`join`</ph> object to receive messages from the message buffers for both chopsticks.","source":"Modify the `pickup_chopsticks` method to use a non-greedy `join` object to receive messages from the message buffers for both chopsticks."},{"pos":[7274,7300],"content":"concrt-philosophers-join#4"},{"pos":[7400,7539],"content":"Modify the <ph id=\"ph1\">`putdown_chopsticks`</ph> method to release access to the chopsticks by sending a message to the message buffers for both chopsticks.","source":"Modify the `putdown_chopsticks` method to release access to the chopsticks by sending a message to the message buffers for both chopsticks."},{"pos":[7557,7583],"content":"concrt-philosophers-join#5"},{"pos":[7683,7822],"content":"Modify the <ph id=\"ph1\">`run`</ph> method to hold the results of the <ph id=\"ph2\">`pickup_chopsticks`</ph> method and to pass those results to the <ph id=\"ph3\">`putdown_chopsticks`</ph> method.","source":"Modify the `run` method to hold the results of the `pickup_chopsticks` method and to pass those results to the `putdown_chopsticks` method."},{"pos":[7840,7866],"content":"concrt-philosophers-join#6"},{"pos":[7966,8114],"content":"Modify the declaration of the <ph id=\"ph1\">`chopsticks`</ph> variable in the <ph id=\"ph2\">`wmain`</ph> function to be an array of <ph id=\"ph3\">`unbounded_buffer`</ph> objects that each hold one message.","source":"Modify the declaration of the `chopsticks` variable in the `wmain` function to be an array of `unbounded_buffer` objects that each hold one message."},{"pos":[8132,8158],"content":"concrt-philosophers-join#7"},{"content":"Example","pos":[8257,8264]},{"content":"Description","pos":[8274,8285]},{"pos":[8289,8401],"content":"The following shows the completed example that uses non-greedy <ph id=\"ph1\">`join`</ph> objects to eliminate the risk of deadlock.","source":"The following shows the completed example that uses non-greedy `join` objects to eliminate the risk of deadlock."},{"content":"Code","pos":[8411,8415]},{"pos":[8430,8456],"content":"concrt-philosophers-join#1"},{"content":"Comments","pos":[8556,8564]},{"content":"This example produces the following output.","pos":[8568,8611]},{"content":"Compiling the Code","pos":[8763,8781]},{"pos":[8785,8984],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`philosophers-join.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `philosophers-join.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc philosophers-join.cpp","pos":[8993,9027]},{"pos":[9036,9049],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"See Also","pos":[9058,9066]},{"content":"Concurrency Runtime Walkthroughs","pos":[9071,9103]},{"content":"Asynchronous Agents Library","pos":[9169,9196]},{"content":"Asynchronous Agents","pos":[9257,9276]},{"content":"Asynchronous Message Blocks","pos":[9329,9356]},{"content":"Message Passing Functions","pos":[9417,9442]},{"content":"Synchronization Data Structures","pos":[9501,9532]}],"content":"---\ntitle: \"Walkthrough: Using join to Prevent Deadlock | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"preventing deadlock with joins [Concurrency Runtime]\"\n  - \"deadlock, preventing [Concurrency Runtime]\"\n  - \"non-greedy joins, example\"\n  - \"join class, example\"\nms.assetid: d791f697-bb93-463e-84bd-5df1651b7446\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Walkthrough: Using join to Prevent Deadlock\nThis topic uses the dining philosophers problem to illustrate how to use the [concurrency::join](../../parallel/concrt/reference/join-class.md) class to prevent deadlock in your application. In a software application, *deadlock* occurs when two or more processes each hold a resource and mutually wait for another process to release some other resource.  \n  \n The dining philosophers problem is a specific example of the general set of problems that may occur when a set of resources is shared among multiple concurrent processes.  \n  \n## Prerequisites  \n Read the following topics before you start this walkthrough:  \n  \n- [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)  \n  \n- [Walkthrough: Creating an Agent-Based Application](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md)  \n  \n- [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)  \n  \n- [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)  \n  \n- [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md)  \n  \n##  <a name=\"top\"></a> Sections  \n This walkthrough contains the following sections:  \n  \n- [The Dining Philosophers Problem](#problem)  \n  \n- [A Naïve Implementation](#deadlock)  \n  \n- [Using join to Prevent Deadlock](#solution)  \n  \n##  <a name=\"problem\"></a> The Dining Philosophers Problem  \n The dining philosophers problem illustrates how deadlock occurs in an application. In this problem, five philosophers sit at a round table. Every philosopher alternates between thinking and eating. Every philosopher must share a chopstick with the neighbor to the left and another chopstick with the neighbor to the right. The following illustration shows this layout.  \n  \n ![The Dining Philosophers Problem](../../parallel/concrt/media/dining_philosophersproblem.png \"dining_philosophersproblem\")  \n  \n To eat, a philosopher must hold two chopsticks. If every philosopher holds just one chopstick and is waiting for another one, then no philosopher can eat and all starve.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"deadlock\"></a> A Naïve Implementation  \n The following example shows a naïve implementation of the dining philosophers problem. The `philosopher` class, which derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md), enables each philosopher to act independently. The example uses a shared array of [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md) objects to give each `philosopher` object exclusive access to a pair of chopsticks.  \n  \n To relate the implementation to the illustration, the `philosopher` class represents one philosopher. An `int` variable represents each chopstick. The `critical_section` objects serve as holders on which the chopsticks rest. The `run` method simulates the life of the philosopher. The `think` method simulates the act of thinking and the `eat` method simulates the act of eating.  \n  \n A `philosopher` object locks both `critical_section` objects to simulate the removal of the chopsticks from the holders before it calls the `eat` method. After the call to `eat`, the `philosopher` object returns the chopsticks to the holders by setting the `critical_section` objects back to the unlocked state.  \n  \n The `pickup_chopsticks` method illustrates where deadlock can occur. If every `philosopher` object gains access to one of the locks, then no `philosopher` object can continue because the other lock is controlled by another `philosopher` object.  \n  \n## Example  \n  \n### Description  \n  \n### Code  \n [!code-cpp[concrt-philosophers-deadlock#1](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_1.cpp)]  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `philosophers-deadlock.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc philosophers-deadlock.cpp**  \n  \n [[Top](#top)]  \n  \n##  <a name=\"solution\"></a> Using join to Prevent Deadlock  \n This section shows how to use message buffers and message-passing functions to eliminate the chance of deadlock.  \n  \n To relate this example to the earlier one, the `philosopher` class replaces each `critical_section` object by using a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object and a `join` object. The `join` object serves as an arbiter that provides the chopsticks to the philosopher.  \n  \n This example uses the `unbounded_buffer` class because when a target receives a message from an `unbounded_buffer` object, the message is removed from the message queue. This enables an `unbounded_buffer` object that holds a message to indicate that the chopstick is available. An `unbounded_buffer` object that holds no message indicates that the chopstick is being used.  \n  \n This example uses a non-greedy `join` object because a non-greedy join gives each `philosopher` object access to both chopsticks only when both `unbounded_buffer` objects contain a message. A greedy join would not prevent deadlock because a greedy join accepts messages as soon as they become available. Deadlock can occur if all greedy `join` objects receive one of the messages but wait forever for the other to become available.  \n  \n For more information about greedy and non-greedy joins, and the differences between the various message buffer types, see [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md).  \n  \n#### To prevent deadlock in this example  \n  \n1.  Remove the following code from the example.  \n  \n [!code-cpp[concrt-philosophers-deadlock#2](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_2.cpp)]  \n  \n2.  Change the type of the `_left` and `_right` data members of the `philosopher` class to `unbounded_buffer`.  \n  \n [!code-cpp[concrt-philosophers-join#2](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_3.cpp)]  \n  \n3.  Modify the `philosopher` constructor to take `unbounded_buffer` objects as its parameters.  \n  \n [!code-cpp[concrt-philosophers-join#3](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_4.cpp)]  \n  \n4.  Modify the `pickup_chopsticks` method to use a non-greedy `join` object to receive messages from the message buffers for both chopsticks.  \n  \n [!code-cpp[concrt-philosophers-join#4](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_5.cpp)]  \n  \n5.  Modify the `putdown_chopsticks` method to release access to the chopsticks by sending a message to the message buffers for both chopsticks.  \n  \n [!code-cpp[concrt-philosophers-join#5](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_6.cpp)]  \n  \n6.  Modify the `run` method to hold the results of the `pickup_chopsticks` method and to pass those results to the `putdown_chopsticks` method.  \n  \n [!code-cpp[concrt-philosophers-join#6](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_7.cpp)]  \n  \n7.  Modify the declaration of the `chopsticks` variable in the `wmain` function to be an array of `unbounded_buffer` objects that each hold one message.  \n  \n [!code-cpp[concrt-philosophers-join#7](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_8.cpp)]  \n  \n## Example  \n  \n### Description  \n The following shows the completed example that uses non-greedy `join` objects to eliminate the risk of deadlock.  \n  \n### Code  \n [!code-cpp[concrt-philosophers-join#1](../../parallel/concrt/codesnippet/cpp/walkthrough-using-join-to-prevent-deadlock_9.cpp)]  \n  \n### Comments  \n This example produces the following output.  \n  \n```Output  \naristotle ate 50 times.  \ndescartes ate 50 times.  \nhobbes ate 50 times.  \nsocrates ate 50 times.  \nplato ate 50 times.  \n```  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `philosophers-join.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc philosophers-join.cpp**  \n  \n [[Top](#top)]  \n  \n## See Also  \n [Concurrency Runtime Walkthroughs](../../parallel/concrt/concurrency-runtime-walkthroughs.md)   \n [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md)   \n [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)   \n [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)   \n [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)   \n [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md)\n"}