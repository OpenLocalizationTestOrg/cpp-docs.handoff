{"nodes":[{"pos":[12,39],"content":"path Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"path Class | Microsoft Docs","pos":[0,27]}]},{"content":"path Class","pos":[587,597]},{"content":"The <bpt id=\"p1\">**</bpt>path<ept id=\"p1\">**</ept> class stores an object of type string_type, called myname here for the purposes of exposition, suitable for use as a pathname.","pos":[598,737],"source":"The **path** class stores an object of type string_type, called myname here for the purposes of exposition, suitable for use as a pathname."},{"content":"string_type is a synonym for basic_string&lt;value_type&gt;, where value_type is a synonym for char under Windows or wchar_t under Posix.","pos":[738,869],"source":" string_type is a synonym for basic_string<value_type>, where value_type is a synonym for char under Windows or wchar_t under Posix."},{"pos":[876,999],"content":"For more information, and code examples, see <bpt id=\"p1\">[</bpt>File System Navigation (C++)<ept id=\"p1\">](../standard-library/file-system-navigation.md)</ept>.","source":"For more information, and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md)."},{"content":"Syntax","pos":[1008,1014]},{"content":"path::append","pos":[1052,1064]},{"content":"The member functions append the specified sequence to mypath, converted and inserting a preferred_separator as needed.","pos":[1210,1328]},{"content":"path::assign","pos":[1337,1349]},{"content":"The member functions replace mypath with the specified sequence, converted as needed.","pos":[1495,1580]},{"content":"path::begin","pos":[1589,1600]},{"content":"Returns a path::iterator designating the first path element in the pathname, if present.","pos":[1646,1734]},{"content":"path::c_str","pos":[1743,1754]},{"content":"Returns a pointer to the first character in mypath.","pos":[1821,1872]},{"content":"path::clear","pos":[1881,1892]},{"content":"The member function executes mypath.clear()","pos":[1939,1982]},{"content":"path::compare","pos":[1991,2004]},{"content":"The first function returns mypath.compare(pval.native()).","pos":[2162,2219]},{"content":"The second function returns mypath.compare(str).","pos":[2220,2268]},{"content":"The third function returns mypath.compare(ptr).","pos":[2269,2316]},{"content":"path::concat","pos":[2325,2337]},{"content":"The member functions append the specified sequence to mypath, converted (but not inserting a separator) as needed.","pos":[2483,2597]},{"content":"path::const_iterator","pos":[2606,2626]},{"content":"The type is a synonym for iterator.","pos":[2683,2718]},{"content":"path::empty","pos":[2727,2738]},{"content":"Returns mypath.empty().","pos":[2791,2814]},{"content":"path::end","pos":[2823,2832]},{"content":"Returns an end-of-sequence iterator of type iterator.","pos":[2876,2929]},{"content":"path::extension","pos":[2938,2953]},{"content":"Returns the suffix of filename() X such that:","pos":[2999,3044]},{"content":"If X == path(\".\") &amp;#124;&amp;#124; X == path(\"..\") or if X contains no dot, the suffix is empty.","pos":[3051,3143],"source":"If X == path(\".\") &#124;&#124; X == path(\"..\") or if X contains no dot, the suffix is empty."},{"content":"Otherwise, the suffix begins with (and includes) the rightmost dot.","pos":[3150,3217]},{"content":"path::filename","pos":[3226,3240]},{"content":"Returns the root directory component of myname, specifically <ph id=\"ph1\">`empty()  path() : *--end()`</ph>.","pos":[3285,3375],"source":"Returns the root directory component of myname, specifically `empty()  path() : *--end()`."},{"content":"The component may be empty.","pos":[3376,3403]},{"content":"path::generic_string","pos":[3412,3432]},{"pos":[3678,3791],"content":"Returns <ph id=\"ph1\">`this-&gt;string&lt;Elem, Traits, Alloc&gt;(_Al)`</ph> with (under Windows) any backslash converted to a forward slash.","source":"Returns `this->string<Elem, Traits, Alloc>(_Al)` with (under Windows) any backslash converted to a forward slash."},{"content":"path::generic_u16string","pos":[3800,3823]},{"content":"Returns u16string() with (under Windows) any backslash converted to a forward slash.","pos":[3882,3966]},{"content":"path::generic_u32string","pos":[3975,3998]},{"content":"Returns u32string() with (under Windows) any backslash converted to a forward slash.","pos":[4057,4141]},{"content":"path::generic_u8string","pos":[4150,4172]},{"content":"Returns u8string() with (under Windows) any backslash converted to a forward slash.","pos":[4227,4310]},{"content":"path::generic_wstring","pos":[4319,4340]},{"content":"Returns wstring() with (under Windows) any backslash converted to a forward slash.","pos":[4395,4477]},{"content":"path::has_extension","pos":[4486,4505]},{"content":"Returns !extension().empty().","pos":[4555,4584]},{"content":"path::has_filename","pos":[4593,4611]},{"content":"Returns !filename().empty().","pos":[4660,4688]},{"content":"path::has_parent_path","pos":[4697,4718]},{"content":"Returns !parent_path().empty().","pos":[4772,4803]},{"content":"path::has_relative_path","pos":[4812,4835]},{"content":"Returns !relative_path().empty().","pos":[4889,4922]},{"content":"path::has_root_directory","pos":[4931,4955]},{"content":"Returns !root_directory().empty().","pos":[5010,5044]},{"content":"path::has_root_name","pos":[5053,5072]},{"content":"Returns !root_name().empty().","pos":[5122,5151]},{"content":"path::has_root_path","pos":[5160,5179]},{"content":"Returns !root_path().empty().","pos":[5229,5258]},{"content":"path::has_stem","pos":[5267,5281]},{"content":"Returns !stem().empty().","pos":[5326,5350]},{"content":"path::is_absolute","pos":[5359,5376]},{"content":"For Windows, the function returns has_root_name() &amp;&amp; has_root_directory().","pos":[5424,5498],"source":"For Windows, the function returns has_root_name() && has_root_directory()."},{"content":"For Posix, the function returns has_root_directory().","pos":[5499,5552]},{"content":"path::is_relative","pos":[5561,5578]},{"content":"Returns !is_absolute().","pos":[5626,5649]},{"content":"path::iterator","pos":[5658,5672]},{"content":"class iterator","pos":[5678,5692]},{"content":"{// bidirectional iterator for path","pos":[5698,5733]},{"content":"typedef bidirectional_iterator_tag iterator_category;","pos":[5739,5792]},{"content":"typedef path_type value_type;","pos":[5798,5827]},{"content":"typedef ptrdiff_t difference_type;","pos":[5833,5867]},{"content":"typedef const value_type *pointer;","pos":[5873,5907]},{"content":"typedef const value_type&amp; reference;","pos":[5913,5949],"source":"typedef const value_type& reference;"},{"content":".....","pos":[5955,5960]},{"content":"};","pos":[5966,5968]},{"content":"The class describes a bidirectional constant iterator that designates the path components of myname in the sequence:","pos":[5975,6091]},{"content":"the root name, if present","pos":[6101,6126]},{"content":"the root directory, if present","pos":[6136,6166]},{"content":"the remaining directory elements of the parent path, if present, ending withthe filename, if present","pos":[6176,6276]},{"content":"For pval an object of type path:","pos":[6299,6331]},{"content":"path::iterator X = pval.begin() designates the first path element in the pathname, if present.","pos":[6341,6435]},{"content":"X == pval.end() is true when X points just past the end of the sequence of components.","pos":[6445,6531]},{"content":"*X returns a string that matches the current component","pos":[6540,6594]},{"content":"++X designates the next component in the sequence, if present.","pos":[6604,6666]},{"content":"--X designates the preceding component in the sequence, if present.","pos":[6676,6743]},{"content":"Altering myname invalidates all iterators designating elements in myname.","pos":[6753,6826]},{"content":"path::make_preferred","pos":[6835,6855]},{"content":"The member function converts each separator to a preferred_separator as needed.","pos":[6901,6980]},{"content":"path::native","pos":[6989,7001]},{"content":"Returns myname.","pos":[7069,7084]},{"content":"path::operator=","pos":[7093,7108]},{"content":"The first member operator copies right.myname to myname.","pos":[7274,7330]},{"content":"The second member operator moves right.myname to myname.","pos":[7331,7387]},{"content":"The third member operator behaves the same as *this = path(source).","pos":[7388,7455]},{"content":"path::operator+=","pos":[7464,7480]},{"content":"The member functions behave the same as the following corresponding expressions:","pos":[7781,7861]},{"content":"concat(right);","pos":[7871,7885]},{"content":"concat(path(str));","pos":[7895,7913]},{"content":"concat(ptr);","pos":[7923,7935]},{"content":"concat(string_type(1, elem));","pos":[7945,7974]},{"content":"concat(source);","pos":[7984,7999]},{"content":"concat(path(basic_string<ph id=\"ph1\">\\&lt;</ph>Elem&gt;(1, elem)));","pos":[8009,8052],"source":"concat(path(basic_string\\<Elem>(1, elem)));"},{"content":"path::operator/=","pos":[8061,8077]},{"content":"The member functions behave the same as the following corresponding expressions:","pos":[8203,8283]},{"content":"append(right);","pos":[8293,8307]},{"content":"append(source);","pos":[8317,8332]},{"content":"path::operator string_type","pos":[8341,8367]},{"content":"```  operator string_type() const;","pos":[8373,8407]},{"content":"path parent_path() const;","pos":[8491,8516]},{"content":"path();","pos":[8888,8895]},{"content":"path(const path&amp; right);","pos":[8897,8921],"source":"path(const path& right);"},{"content":"path(path&amp;&amp; right) noexcept;","pos":[8923,8951],"source":"path(path&& right) noexcept;"},{"content":"template","pos":[8954,8962]},{"content":"path(const Source&amp; source);","pos":[8980,9007],"source":"path(const Source& source);"},{"content":"template","pos":[9009,9017]},{"content":"path(const Source&amp; source, const locale&amp; loc);","pos":[9035,9081],"source":"path(const Source& source, const locale& loc);"},{"content":"template","pos":[9083,9091]},{"content":"path(InIt first, InIt last);","pos":[9107,9135]},{"content":"template","pos":[9137,9145]},{"content":"path(InIt first, InIt last, const locale&amp; loc);","pos":[9161,9208],"source":"path(InIt first, InIt last, const locale& loc);"},{"content":"if _WIN32_C_LIB","pos":[9942,9957]},{"content":"static constexpr value_type preferred_separator == L'<ph id=\"ph1\">\\\\</ph>';","pos":[9960,10017],"source":"static constexpr value_type preferred_separator == L'\\\\';"},{"content":"else // assume Posix","pos":[10021,10041]},{"content":"static constexpr value_type preferred_separator == '/';","pos":[10044,10099]},{"content":"endif // filesystem model now defined","pos":[10103,10140]},{"content":"path relative_path() const;","pos":[10407,10434]},{"content":"path&amp; remove_filename();","pos":[10694,10718],"source":"path& remove_filename();"},{"content":"path&amp; replace_extension(const path&amp; newext = path());","pos":[10766,10819],"source":"path& replace_extension(const path& newext = path());"},{"content":"path&amp; replace_filename(const path&amp; pval);","pos":[11099,11140],"source":"path& replace_filename(const path& pval);"},{"content":"remove_filename();","pos":[11192,11210]},{"pos":[11212,11244],"content":"<bpt id=\"p1\">*</bpt>this /= pval; return (<ept id=\"p1\">*</ept>this);","source":"*this /= pval;  \nreturn (*this);"},{"content":"path root_directory() const;","pos":[11289,11317]},{"content":"path root_name() const;","pos":[11439,11462]},{"content":"path root_path() const;","pos":[11581,11604]},{"content":"path stem() const;","pos":[11761,11779]},{"content":"template &lt;class Elem, class Traits = char_traits<ph id=\"ph1\">&lt;Elem&gt;</ph>, class Alloc = allocator","pos":[11969,12048],"source":"template <class Elem, class Traits = char_traits<Elem>, class Alloc = allocator"},{"content":"basic_string&lt;Elem, Traits, Alloc&gt; string(const Alloc&amp; al = Alloc()) const; string string() const;","pos":[12058,12156],"source":"basic_string<Elem, Traits, Alloc> string(const Alloc& al = Alloc()) const; \nstring string() const;"},{"content":"typedef basic_string&lt;value_type&gt; string_type;","pos":[12713,12758],"source":"typedef basic_string<value_type> string_type;"},{"content":"void swap(path&amp; right) noexcept;","pos":[12853,12885],"source":"void swap(path& right) noexcept;"},{"content":"u16string u16string() const;","pos":[12970,12998]},{"content":"u32string u32string() const;","pos":[13167,13195]},{"content":"string u8string() const;","pos":[13363,13387]},{"content":"if _WIN32_C_LIB","pos":[13558,13573]},{"content":"typedef wchar_t value_type;","pos":[13576,13603]},{"content":"else // assume Posix","pos":[13607,13627]},{"content":"typedef char value_type;","pos":[13630,13654]},{"content":"endif // filesystem model now defined","pos":[13658,13695]},{"content":"wstring wstring() const;","pos":[13816,13840]}],"content":"---\ntitle: \"path Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"filesystem/std::experimental::filesystem::path\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8a1227ca-aeb2-4e0e-84aa-86e34e4f4fe8\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# path Class\nThe **path** class stores an object of type string_type, called myname here for the purposes of exposition, suitable for use as a pathname. string_type is a synonym for basic_string<value_type>, where value_type is a synonym for char under Windows or wchar_t under Posix.  \n  \n For more information, and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md).  \n  \n## Syntax  \n  \n```  \nclass path;  \n```  \n  \n## path::append  \n  \n```  \ntemplate <class Source>  \npath& append(const Source& source);\n\ntemplate <class InIt>  \npath& append(InIt first, InIt last);\n```  \n  \n The member functions append the specified sequence to mypath, converted and inserting a preferred_separator as needed.  \n  \n## path::assign  \n  \n```  \ntemplate <class Source>  \npath& assign(const Source& source);\n\ntemplate <class InIt>  \npath& assign(InIt first, InIt last);\n```  \n  \n The member functions replace mypath with the specified sequence, converted as needed.  \n  \n## path::begin  \n  \n```  \niterator begin() const;\n```  \n  \n Returns a path::iterator designating the first path element in the pathname, if present.  \n  \n## path::c_str  \n  \n```  \nconst value_type& *c_str() const noexcept;  \n```  \n  \n Returns a pointer to the first character in mypath.  \n  \n## path::clear  \n  \n```  \nvoid clear() noexcept;  \n```  \n  \n The member function executes mypath.clear()  \n  \n## path::compare  \n  \n```  \nint compare(const path& pval) const noexcept;  \nint compare(const string_type& str) const;\n\n \nint compare(const value_type *ptr) const;\n```  \n  \n The first function returns mypath.compare(pval.native()). The second function returns mypath.compare(str). The third function returns mypath.compare(ptr).  \n  \n## path::concat  \n  \n```  \ntemplate <class Source>  \npath& concat(const Source& source);\n\ntemplate <class InIt>  \npath& concat(InIt first, InIt last);\n```  \n  \n The member functions append the specified sequence to mypath, converted (but not inserting a separator) as needed.  \n  \n## path::const_iterator  \n  \n```  \ntypedef iterator const_iterator;  \n```  \n  \n The type is a synonym for iterator.  \n  \n## path::empty  \n  \n```  \nbool empty() const noexcept;  \n```  \n  \n Returns mypath.empty().  \n  \n## path::end  \n  \n```  \niterator end() const;\n```  \n  \n Returns an end-of-sequence iterator of type iterator.  \n  \n## path::extension  \n  \n```  \npath extension() const;\n```  \n  \n Returns the suffix of filename() X such that:  \n  \n If X == path(\".\") &#124;&#124; X == path(\"..\") or if X contains no dot, the suffix is empty.  \n  \n Otherwise, the suffix begins with (and includes) the rightmost dot.  \n  \n## path::filename  \n  \n```  \npath filename() const;\n```  \n  \n Returns the root directory component of myname, specifically `empty()  path() : *--end()`. The component may be empty.  \n  \n## path::generic_string  \n  \n```  \ntemplate <class Elem,  \n    class Traits = char_traits<Elem>,  \n    class Alloc = allocator<Elem>>  \nbasic_string<Elem, Traits, Alloc>  \n    generic_string(const Alloc& al = Alloc()) const;\n\n \nstring generic_string() const;\n```  \n  \n Returns `this->string<Elem, Traits, Alloc>(_Al)` with (under Windows) any backslash converted to a forward slash.  \n  \n## path::generic_u16string  \n  \n```  \nu16string generic_u16string() const;\n```  \n  \n Returns u16string() with (under Windows) any backslash converted to a forward slash.  \n  \n## path::generic_u32string  \n  \n```  \nu32string generic_u32string() const;\n```  \n  \n Returns u32string() with (under Windows) any backslash converted to a forward slash.  \n  \n## path::generic_u8string  \n  \n```  \nstring generic_u8string() const;\n```  \n  \n Returns u8string() with (under Windows) any backslash converted to a forward slash.  \n  \n## path::generic_wstring  \n  \n```  \nwstring generic_wstring() const;\n```  \n  \n Returns wstring() with (under Windows) any backslash converted to a forward slash.  \n  \n## path::has_extension  \n  \n```  \nbool has_extension() const;\n```  \n  \n Returns !extension().empty().  \n  \n## path::has_filename  \n  \n```  \nbool has_filename() const;\n```  \n  \n Returns !filename().empty().  \n  \n## path::has_parent_path  \n  \n```  \n \nbool has_parent_path() const;\n```  \n  \n Returns !parent_path().empty().  \n  \n## path::has_relative_path  \n  \n```  \nbool has_relative_path() const;\n```  \n  \n Returns !relative_path().empty().  \n  \n## path::has_root_directory  \n  \n```  \nbool has_root_directory() const;\n```  \n  \n Returns !root_directory().empty().  \n  \n## path::has_root_name  \n  \n```  \nbool has_root_name() const;\n```  \n  \n Returns !root_name().empty().  \n  \n## path::has_root_path  \n  \n```  \nbool has_root_path() const;\n```  \n  \n Returns !root_path().empty().  \n  \n## path::has_stem  \n  \n```  \nbool has_stem() const;\n```  \n  \n Returns !stem().empty().  \n  \n## path::is_absolute  \n  \n```  \nbool is_absolute() const;\n```  \n  \n For Windows, the function returns has_root_name() && has_root_directory(). For Posix, the function returns has_root_directory().  \n  \n## path::is_relative  \n  \n```  \nbool is_relative() const;\n```  \n  \n Returns !is_absolute().  \n  \n## path::iterator  \n  \nclass iterator  \n   {// bidirectional iterator for path  \n   typedef bidirectional_iterator_tag iterator_category;  \n   typedef path_type value_type;  \n   typedef ptrdiff_t difference_type;  \n   typedef const value_type *pointer;  \n   typedef const value_type& reference;  \n   .....  \n   };  \n  \n The class describes a bidirectional constant iterator that designates the path components of myname in the sequence:  \n  \n1.  the root name, if present  \n  \n2.  the root directory, if present  \n  \n3.  the remaining directory elements of the parent path, if present, ending withthe filename, if present  \n  \n4.  \n  \n5.  \n  \n For pval an object of type path:  \n  \n1.  path::iterator X = pval.begin() designates the first path element in the pathname, if present.  \n  \n2.  X == pval.end() is true when X points just past the end of the sequence of components.  \n  \n3. *X returns a string that matches the current component  \n  \n4.  ++X designates the next component in the sequence, if present.  \n  \n5.  --X designates the preceding component in the sequence, if present.  \n  \n6.  Altering myname invalidates all iterators designating elements in myname.  \n  \n## path::make_preferred  \n  \n```  \npath& make_preferred();\n```  \n  \n The member function converts each separator to a preferred_separator as needed.  \n  \n## path::native  \n  \n```  \nconst string_type& native() const noexcept;  \n```  \n  \n Returns myname.  \n  \n## path::operator=  \n  \n```  \npath& operator=(const path& right);\n\npath& operator=(path&& right) noexcept;  \ntemplate <class Source>  \npath& operator=(const Source& source);\n```  \n  \n The first member operator copies right.myname to myname. The second member operator moves right.myname to myname. The third member operator behaves the same as *this = path(source).  \n  \n## path::operator+=  \n  \n```  \npath& operator+=(const path& right);\n\npath& operator+=(const string_type& str);\n\npath& operator+=(const value_type *ptr);\n\npath& operator+=(value_type elem);\n\ntemplate <class Source>  \npath& operator+=(const Source& source);\n\ntemplate <class Elem>  \npath& operator+=(Elem elem);\n```  \n  \n The member functions behave the same as the following corresponding expressions:  \n  \n1.  concat(right);  \n  \n2.  concat(path(str));  \n  \n3.  concat(ptr);  \n  \n4.  concat(string_type(1, elem));  \n  \n5.  concat(source);  \n  \n6.  concat(path(basic_string\\<Elem>(1, elem)));  \n  \n## path::operator/=  \n  \n```  \npath& operator/=(const path& right);\n\ntemplate <class Source>  \npath& operator/=(const Source& source);\n```  \n  \n The member functions behave the same as the following corresponding expressions:  \n  \n1.  append(right);  \n  \n2.  append(source);  \n  \n## path::operator string_type  \n  \n```  operator string_type() const;\n```  \n  \n The member operator returns myname.  \n  \n## path::parent_path  \n  \n```  \npath parent_path() const;\n```  \n  \n Returns the parent path component of myname, specifically the prefix of myname after removing filename().native() and any immediately preceding directory separators. (Equally, if begin() != end(), it is the combining of all elements in the range [begin(), --end()) by successively applying operator/=.) The component may be empty.  \n  \n## path::path  \n  \n```  \npath();\n\npath(const path& right);\n\npath(path&& right) noexcept;  \ntemplate <class Source>  \npath(const Source& source);\n\ntemplate <class Source>  \npath(const Source& source, const locale& loc);\n\ntemplate <class InIt>  \npath(InIt first, InIt last);\n\ntemplate <class InIt>  \npath(InIt first, InIt last, const locale& loc);\n```  \n  \n The constructors all construct myname in various ways:  \n  \n For path() it is myname().  \n  \n For path(const path& right) it is myname(right.myname).  \n  \n For path(path&& right) it is myname(right.myname).  \n  \n For template\\<class Source> path(const Source& source) it is myname(source).  \n  \n For template\\<class Source> path(const Source& source, const locale& loc) it is myname(source), obtaining any needed codecvt facets from loc.  \n  \n For template\\<class InIt> path(InIt first, InIt last) it is myname(first, last).  \n  \n For template\\<class InIt> path(InIt first, InIt last, const locale& loc) it is myname(first, last), obtaining any needed codecvt facets from loc.  \n  \n## path::preferred_separator  \n  \n```  \n#if _WIN32_C_LIB  \nstatic constexpr value_type preferred_separator == L'\\\\';  \n#else // assume Posix  \nstatic constexpr value_type preferred_separator == '/';  \n#endif // filesystem model now defined  \n```  \n  \n The constant object gives the preferred character for separating path components, depending on the host operating system. Note that it is equally permissible in most contexts under Windows to use L'/' in its place.  \n  \n## path::relative_path  \n  \n```  \npath relative_path() const;\n```  \n  \n Returns the relative path component of myname, specifically the suffix of myname after removing root_path().native() and any immediately subsequent redundant directory separators. The component may be empty.  \n  \n## path::remove_filename  \n  \n```  \npath& remove_filename();\n```  \n  \n## path::replace_extension  \n  \n```  \npath& replace_extension(const path& newext = path());\n```  \n  \n The member function first removes the suffix extension().native() from myname. Then if !newext.empty() && newext[0] != dot (where dot is *path(\".\").c_str()), then dot is appended to myname. Then newext is appended to myname.  \n  \n## path::replace_filename  \n  \n```  \n \npath& replace_filename(const path& pval);\n```  \n  \n The member function executes:  \n  \n```  \nremove_filename();\n\n*this /= pval;  \nreturn (*this);\n```  \n  \n## path::root_directory  \n  \n```  \npath root_directory() const;\n```  \n  \n Returns the root directory component of myname. The component may be empty.  \n  \n## path::root_name  \n  \n```  \npath root_name() const;\n```  \n  \n Returns the root name component of myname. The component may be empty.  \n  \n## path::root_path  \n  \n```  \n \npath root_path() const;\n```  \n  \n Returns the root path component of myname, specifically root_name() / root_directory. The component may be empty.  \n  \n## path::stem  \n  \n```  \n \npath stem() const;\n```  \n  \n Returns the stem component of myname, specifically filename().native() with any trailing extension().native() removed. The component may be empty.  \n  \n## path::string  \n  \n```  \ntemplate <class Elem, class Traits = char_traits<Elem>, class Alloc = allocator<Elem>>  \nbasic_string<Elem, Traits, Alloc> string(const Alloc& al = Alloc()) const; \nstring string() const;\n```  \n  \n The first (template) member function converts the sequence stored in mypath the same way as:  \n  \n1.  string() for string\\<char, Traits, Alloc>()  \n  \n2.  wstring() for string\\<wchar_t, Traits, Alloc>()  \n  \n3.  u16string() for string\\<char16_t, Traits, Alloc>()  \n  \n4.  u32string() for string\\<char32_t, Traits, Alloc>()  \n  \n The second member function converts the sequence stored in mypath to the encoding favored by the host system for a char sequence and returns it stored in an object of type string.  \n  \n## path::string_type  \n  \n```  \ntypedef basic_string<value_type> string_type;  \n```  \n  \n The type is a synonym for basic_string<value_type>.  \n  \n## path::swap  \n  \n```  \nvoid swap(path& right) noexcept;  \n```  \n  \n Executes swap(mypath, right.mypath).  \n  \n## path::u16string  \n  \n```  \nu16string u16string() const;\n```  \n  \n The member function converts the sequence stored in mypath to UTF-16 and returns it stored in an object of type u16string.  \n  \n## path::u32string  \n  \n```  \nu32string u32string() const;\n```  \n  \n The member function converts the sequence stored in mypath to UTF-32 and returns it stored in an object of type u32string.  \n  \n## path::u8string  \n  \n```  \nstring u8string() const;\n```  \n  \n The member function converts the sequence stored in mypath to UTF-8 and returns it stored in an object of type u8string.  \n  \n## path::value_type  \n  \n```  \n \n#if _WIN32_C_LIB  \ntypedef wchar_t value_type;  \n#else // assume Posix  \ntypedef char value_type;  \n#endif // filesystem model now defined  \n```  \n  \n The type describes the path elements favored by the host operating system.  \n  \n## path::wstring  \n  \n```  \nwstring wstring() const;\n```  \n  \n Converts the sequence stored in mypath to the encoding favored by the host system for a wchar_t sequence and returns it stored in an object of type wstring.  \n  \n## Requirements  \n **Header:** filesystem  \n  \n **Namespace:** std::experimental::filesystem\n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)\n\n"}