{"nodes":[{"pos":[12,50],"content":"Byte and Wide Streams | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Byte and Wide Streams | Microsoft Docs","pos":[0,38]}]},{"content":"Byte and Wide Streams","pos":[640,661]},{"content":"A byte stream treats a file as a sequence of bytes.","pos":[662,713]},{"content":"Within the program, the stream is the identical sequence of bytes.","pos":[714,780]},{"content":"By contrast, a wide stream treats a file as a sequence of generalized multibyte characters, which can have a broad range of encoding rules.","pos":[787,926]},{"content":"(Text and binary files are still read and written as previously described.) Within the program, the stream looks like the corresponding sequence of wide characters.","pos":[927,1091]},{"content":"Conversions between the two representations occur within the Standard C Library.","pos":[1092,1172]},{"content":"The conversion rules can, in principle, be altered by a call to <bpt id=\"p1\">[</bpt>setlocale<ept id=\"p1\">](../c-runtime-library/reference/setlocale-wsetlocale.md)</ept> that alters the category <ph id=\"ph1\">`LC_CTYPE`</ph>.","pos":[1173,1341],"source":" The conversion rules can, in principle, be altered by a call to [setlocale](../c-runtime-library/reference/setlocale-wsetlocale.md) that alters the category `LC_CTYPE`."},{"content":"Each wide stream determines its conversion rules at the time it becomes wide oriented, and retains these rules even if the category <ph id=\"ph1\">`LC_CTYPE`</ph> subsequently changes.","pos":[1342,1506],"source":" Each wide stream determines its conversion rules at the time it becomes wide oriented, and retains these rules even if the category `LC_CTYPE` subsequently changes."},{"content":"Positioning within a wide stream suffers the same limitations as for text steams.","pos":[1513,1594]},{"content":"Moreover, the file-position indicator may well have to deal with a state-dependent encoding.","pos":[1595,1687]},{"content":"Typically, it includes both a byte offset within the stream and an object of type <ph id=\"ph1\">`mbstate_t`</ph>.","pos":[1688,1782],"source":" Typically, it includes both a byte offset within the stream and an object of type `mbstate_t`."},{"content":"Thus, the only reliable way to obtain a file position within a wide stream is by calling <bpt id=\"p1\">[</bpt>fgetpos<ept id=\"p1\">](../c-runtime-library/reference/fgetpos.md)</ept>, and the only reliable way to restore a position obtained this way is by calling <bpt id=\"p2\">[</bpt>fsetpos<ept id=\"p2\">](../c-runtime-library/reference/fsetpos.md)</ept>.","pos":[1783,2059],"source":" Thus, the only reliable way to obtain a file position within a wide stream is by calling [fgetpos](../c-runtime-library/reference/fgetpos.md), and the only reliable way to restore a position obtained this way is by calling [fsetpos](../c-runtime-library/reference/fsetpos.md)."},{"content":"See Also","pos":[2068,2076]},{"content":"Files and Streams","pos":[2081,2098]},{"content":"setlocale, _wsetlocale","pos":[2148,2170]}],"content":"---\ntitle: \"Byte and Wide Streams | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"Byte and Wide Streams\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"byte streams\"\n  - \"wide streams\"\nms.assetid: 61ef0587-4cbc-4eb8-aae5-4c298dbbc6f9\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Byte and Wide Streams\nA byte stream treats a file as a sequence of bytes. Within the program, the stream is the identical sequence of bytes.  \n  \n By contrast, a wide stream treats a file as a sequence of generalized multibyte characters, which can have a broad range of encoding rules. (Text and binary files are still read and written as previously described.) Within the program, the stream looks like the corresponding sequence of wide characters. Conversions between the two representations occur within the Standard C Library. The conversion rules can, in principle, be altered by a call to [setlocale](../c-runtime-library/reference/setlocale-wsetlocale.md) that alters the category `LC_CTYPE`. Each wide stream determines its conversion rules at the time it becomes wide oriented, and retains these rules even if the category `LC_CTYPE` subsequently changes.  \n  \n Positioning within a wide stream suffers the same limitations as for text steams. Moreover, the file-position indicator may well have to deal with a state-dependent encoding. Typically, it includes both a byte offset within the stream and an object of type `mbstate_t`. Thus, the only reliable way to obtain a file position within a wide stream is by calling [fgetpos](../c-runtime-library/reference/fgetpos.md), and the only reliable way to restore a position obtained this way is by calling [fsetpos](../c-runtime-library/reference/fsetpos.md).  \n  \n## See Also  \n [Files and Streams](../c-runtime-library/files-and-streams.md)   \n [setlocale, _wsetlocale](../c-runtime-library/reference/setlocale-wsetlocale.md)"}