{"nodes":[{"pos":[12,74],"content":"_interlockedbittestandset Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_interlockedbittestandset Intrinsic Functions | Microsoft Docs","pos":[0,62]}]},{"content":"_interlockedbittestandset Intrinsic Functions","pos":[1127,1172]},{"content":"Microsoft Specific","pos":[1175,1193]},{"pos":[1202,1321],"content":"Generate an instruction which examines bit <ph id=\"ph1\">`b`</ph> of the address <ph id=\"ph2\">`a`</ph> and returns its current value before setting it to 1.","source":"Generate an instruction which examines bit `b` of the address `a` and returns its current value before setting it to 1."},{"content":"Syntax","pos":[1330,1336]},{"content":"Parameters","pos":[2107,2117]},{"content":"[in]","pos":[2121,2125]},{"content":"A pointer to the memory to examine.","pos":[2133,2168]},{"content":"[in]","pos":[2175,2179]},{"content":"The bit position to test.","pos":[2187,2212]},{"content":"Return Value","pos":[2221,2233]},{"pos":[2237,2291],"content":"The value of the bit at position <ph id=\"ph1\">`b`</ph> before it is set.","source":"The value of the bit at position `b` before it is set."},{"content":"Requirements","pos":[2300,2312]},{"content":"Intrinsic","pos":[2319,2328]},{"content":"Architecture","pos":[2329,2341]},{"content":"Header","pos":[2342,2348]},{"pos":[2433,2442],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[2509,2518],"source":"intrin.h>"},{"pos":[2554,2587],"content":", <ph id=\"ph1\">`_interlockedbittestandset_nf`</ph>,","source":", `_interlockedbittestandset_nf`, "},{"content":"ARM","pos":[2620,2623]},{"content":"intrin.h&gt;","pos":[2626,2635],"source":"intrin.h>"},{"pos":[2678,2679],"content":","},{"pos":[2719,2723],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[2790,2802],"source":"immintrin.h>"},{"content":"intrin.h&gt;","pos":[2903,2912],"source":"intrin.h>"},{"pos":[2957,2958],"content":","},{"content":"immintrin.h&gt;","pos":[3066,3078],"source":"immintrin.h>"},{"content":"Remarks","pos":[3088,3095]},{"content":"On x86 and <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph> processors, these intrinsics use the <ph id=\"ph2\">`lock bts`</ph> instruction to read and set the specified bit to 1.","pos":[3099,3273],"source":"On x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] processors, these intrinsics use the `lock bts` instruction to read and set the specified bit to 1."},{"content":"The operation is atomic.","pos":[3274,3298]},{"content":"On ARM processors, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes for acquire and release semantics, such as at the beginning and end of a critical section.","pos":[3305,3465],"source":"On ARM processors, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The ARM intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[3466,3550],"source":" The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"content":"On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[3557,3802],"source":"On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on processors that do not support HLE, the hint is ignored.","pos":[3803,3893]},{"content":"These routines are only available as intrinsics.","pos":[3900,3948]},{"content":"END Microsoft Specific","pos":[3957,3979]},{"content":"See Also","pos":[3988,3996]},{"content":"Compiler Intrinsics","pos":[4001,4020]},{"content":"Conflicts with the x86 Compiler","pos":[4065,4096]}],"content":"---\ntitle: \"_interlockedbittestandset Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_interlockedbittestandset_cpp\"\n  - \"_interlockedbittestandset_HLEAcquire\"\n  - \"_interlockedbittestandset64\"\n  - \"_interlockedbittestandset\"\n  - \"_interlockedbittestandset_rel\"\n  - \"_interlockedbittestandset64_HLEAcquire\"\n  - \"_interlockedbittestandset_HLERelease\"\n  - \"_interlockedbittestandset_acq\"\n  - \"_interlockedbittestandset_nf\"\n  - \"_interlockedbittestandset64_cpp\"\n  - \"_interlockedbittestandset64_HLERelease\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_interlockedbittestandset intrinsic\"\n  - \"_interlockedbittestandset64 intrinsic\"\n  - \"lock_bts instruction\"\nms.assetid: b1b7e334-53ea-48cf-ba60-5fa3ef51a1fc\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _interlockedbittestandset Intrinsic Functions\n**Microsoft Specific**  \n  \n Generate an instruction which examines bit `b` of the address `a` and returns its current value before setting it to 1.  \n  \n## Syntax  \n  \n```  \nunsigned char _interlockedbittestandset(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset_acq(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset_HLEAcquire(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset_HLERelease(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset_nf(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset_rel(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandset64(  \n   __int64 *a,  \n   __int64 b  \n);  \nunsigned char _interlockedbittestandset64_HLEAcquire(  \n   __int64 *a,  \n   __int64 b  \n);  \nunsigned char _interlockedbittestandset64_HLERelease(  \n   __int64 *a,  \n   __int64 b  \n);  \n```  \n  \n#### Parameters  \n [in] `a`  \n A pointer to the memory to examine.  \n  \n [in] `b`  \n The bit position to test.  \n  \n## Return Value  \n The value of the bit at position `b` before it is set.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_interlockedbittestandset`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_interlockedbittestandset_acq`, `_interlockedbittestandset_nf`, `_interlockedbittestandset_rel`|ARM|\\<intrin.h>|  \n|`_interlockedbittestandset_HLEAcquire`, `_interlockedbittestandset_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n|`_interlockedbittestandset64`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_interlockedbittestandset64_HLEAcquire`, `_interlockedbittestandset64_HLERelease`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n On x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] processors, these intrinsics use the `lock bts` instruction to read and set the specified bit to 1. The operation is atomic.  \n  \n On ARM processors, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section. The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on processors that do not support HLE, the hint is ignored.  \n  \n These routines are only available as intrinsics.  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}