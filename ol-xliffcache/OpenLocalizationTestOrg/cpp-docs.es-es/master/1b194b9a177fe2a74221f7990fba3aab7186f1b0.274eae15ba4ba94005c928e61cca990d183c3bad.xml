{"nodes":[{"pos":[12,41],"content":"C Bit Fields | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C Bit Fields | Microsoft Docs","pos":[0,29]}]},{"content":"C Bit Fields","pos":[585,597]},{"content":"In addition to declarators for members of a structure or union, a structure declarator can also be a specified number of bits, called a \"bit field.\"","pos":[598,746]},{"content":"Its length is set off from the declarator for the field name by a colon.","pos":[747,819]},{"content":"A bit field is interpreted as an integral type.","pos":[820,867]},{"content":"Syntax","pos":[876,882]},{"content":"<bpt id=\"p1\">*</bpt>struct-declarator<ept id=\"p1\">*</ept>:","pos":[886,906],"source":"*struct-declarator*:"},{"content":"declarator","pos":[911,921]},{"pos":[929,987],"content":"<bpt id=\"p1\">*</bpt>type-specifier declarator<ept id=\"p1\">*</ept> opt<bpt id=\"p2\">**</bpt>:<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>constant-expression<ept id=\"p3\">*</ept>","source":"*type-specifier declarator* opt**:** *constant-expression*"},{"content":"The <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> specifies the width of the field in bits.","pos":[994,1061],"source":"The *constant-expression* specifies the width of the field in bits."},{"content":"The <bpt id=\"p1\">*</bpt>type-specifier<ept id=\"p1\">*</ept> for the <ph id=\"ph1\">`declarator`</ph> must be <ph id=\"ph2\">`unsigned int`</ph>, <bpt id=\"p2\">**</bpt>signed int<ept id=\"p2\">**</ept>, or <ph id=\"ph3\">`int`</ph>, and the <bpt id=\"p3\">*</bpt>constant-expression<ept id=\"p3\">*</ept> must be a nonnegative integer value.","pos":[1062,1220],"source":" The *type-specifier* for the `declarator` must be `unsigned int`, **signed int**, or `int`, and the *constant-expression* must be a nonnegative integer value."},{"content":"If the value is zero, the declaration has no <ph id=\"ph1\">`declarator`</ph>.","pos":[1221,1279],"source":" If the value is zero, the declaration has no `declarator`."},{"content":"Arrays of bit fields, pointers to bit fields, and functions returning bit fields are not allowed.","pos":[1280,1377]},{"content":"The optional <ph id=\"ph1\">`declarator`</ph> names the bit field.","pos":[1378,1424],"source":" The optional `declarator` names the bit field."},{"content":"Bit fields can only be declared as part of a structure.","pos":[1425,1480]},{"content":"The address-of operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p1\">**</ept>) cannot be applied to bit-field components.","pos":[1481,1555],"source":" The address-of operator (**&**) cannot be applied to bit-field components."},{"content":"Unnamed bit fields cannot be referenced, and their contents at run time are unpredictable.","pos":[1562,1652]},{"content":"They can be used as \"dummy\" fields, for alignment purposes.","pos":[1653,1712]},{"content":"An unnamed bit field whose width is specified as 0 guarantees that storage for the member following it in the <bpt id=\"p1\">*</bpt>struct-declaration-list<ept id=\"p1\">*</ept> begins on an <ph id=\"ph1\">`int`</ph> boundary.","pos":[1713,1877],"source":" An unnamed bit field whose width is specified as 0 guarantees that storage for the member following it in the *struct-declaration-list* begins on an `int` boundary."},{"content":"Bit fields must also be long enough to contain the bit pattern.","pos":[1884,1947]},{"content":"For example, these two statements are not legal:","pos":[1948,1996]},{"pos":[2090,2164],"content":"This example defines a two-dimensional array of structures named <ph id=\"ph1\">`screen`</ph>.","source":"This example defines a two-dimensional array of structures named `screen`."},{"content":"The array contains 2,000 elements.","pos":[2351,2385]},{"content":"Each element is an individual structure containing four bit-field members: <ph id=\"ph1\">`icon`</ph>, <ph id=\"ph2\">`color`</ph>, <ph id=\"ph3\">`underline`</ph>, and <ph id=\"ph4\">`blink`</ph>.","pos":[2386,2503],"source":" Each element is an individual structure containing four bit-field members: `icon`, `color`, `underline`, and `blink`."},{"content":"The size of each structure is two bytes.","pos":[2504,2544]},{"content":"Bit fields have the same semantics as the integer type.","pos":[2551,2606]},{"content":"This means a bit field is used in expressions in exactly the same way as a variable of the same base type would be used, regardless of how many bits are in the bit field.","pos":[2607,2777]},{"content":"Microsoft Specific","pos":[2786,2804]},{"content":"Bit fields defined as <ph id=\"ph1\">`int`</ph> are treated as signed.","pos":[2813,2863],"source":"Bit fields defined as `int` are treated as signed."},{"content":"A Microsoft extension to the ANSI C standard allows <ph id=\"ph1\">`char`</ph> and <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> types (both <bpt id=\"p2\">**</bpt>signed<ept id=\"p2\">**</ept> and <ph id=\"ph2\">`unsigned`</ph>) for bit fields.","pos":[2864,2990],"source":" A Microsoft extension to the ANSI C standard allows `char` and **long** types (both **signed** and `unsigned`) for bit fields."},{"content":"Unnamed bit fields with base type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>short<ept id=\"p2\">**</ept>, or <ph id=\"ph1\">`char`</ph> (<bpt id=\"p3\">**</bpt>signed<ept id=\"p3\">**</ept> or <ph id=\"ph2\">`unsigned`</ph>) force alignment to a boundary appropriate to the base type.","pos":[2991,3142],"source":" Unnamed bit fields with base type **long**, **short**, or `char` (**signed** or `unsigned`) force alignment to a boundary appropriate to the base type."},{"content":"Bit fields are allocated within an integer from least-significant to most-significant bit.","pos":[3149,3239]},{"content":"In the following code","pos":[3240,3261]},{"content":"the bits would be arranged as follows:","pos":[3488,3526]},{"pos":[3588,3775],"content":"Since the 8086 family of processors stores the low byte of integer values before the high byte, the integer <ph id=\"ph1\">`0x01F2`</ph> above would be stored in physical memory as <ph id=\"ph2\">`0xF2`</ph> followed by <ph id=\"ph3\">`0x01`</ph>.","source":"Since the 8086 family of processors stores the low byte of integer values before the high byte, the integer `0x01F2` above would be stored in physical memory as `0xF2` followed by `0x01`."},{"content":"END Microsoft Specific","pos":[3784,3806]},{"content":"See Also","pos":[3817,3825]},{"content":"Structure Declarations","pos":[3830,3852]}],"content":"---\ntitle: \"C Bit Fields | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"bitfields\"\n  - \"bit fields\"\nms.assetid: 9faf74c4-7fd5-4b44-ad18-04485193d06e\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# C Bit Fields\nIn addition to declarators for members of a structure or union, a structure declarator can also be a specified number of bits, called a \"bit field.\" Its length is set off from the declarator for the field name by a colon. A bit field is interpreted as an integral type.  \n  \n## Syntax  \n *struct-declarator*:  \n *declarator*  \n  \n *type-specifier declarator* opt**:** *constant-expression*  \n  \n The *constant-expression* specifies the width of the field in bits. The *type-specifier* for the `declarator` must be `unsigned int`, **signed int**, or `int`, and the *constant-expression* must be a nonnegative integer value. If the value is zero, the declaration has no `declarator`. Arrays of bit fields, pointers to bit fields, and functions returning bit fields are not allowed. The optional `declarator` names the bit field. Bit fields can only be declared as part of a structure. The address-of operator (**&**) cannot be applied to bit-field components.  \n  \n Unnamed bit fields cannot be referenced, and their contents at run time are unpredictable. They can be used as \"dummy\" fields, for alignment purposes. An unnamed bit field whose width is specified as 0 guarantees that storage for the member following it in the *struct-declaration-list* begins on an `int` boundary.  \n  \n Bit fields must also be long enough to contain the bit pattern. For example, these two statements are not legal:  \n  \n```  \nshort a:17;        /* Illegal! */  \nint long y:33;     /* Illegal! */  \n```  \n  \n This example defines a two-dimensional array of structures named `screen`.  \n  \n```  \nstruct   \n{  \n    unsigned short icon : 8;  \n    unsigned short color : 4;  \n    unsigned short underline : 1;  \n    unsigned short blink : 1;  \n} screen[25][80];  \n```  \n  \n The array contains 2,000 elements. Each element is an individual structure containing four bit-field members: `icon`, `color`, `underline`, and `blink`. The size of each structure is two bytes.  \n  \n Bit fields have the same semantics as the integer type. This means a bit field is used in expressions in exactly the same way as a variable of the same base type would be used, regardless of how many bits are in the bit field.  \n  \n **Microsoft Specific**  \n  \n Bit fields defined as `int` are treated as signed. A Microsoft extension to the ANSI C standard allows `char` and **long** types (both **signed** and `unsigned`) for bit fields. Unnamed bit fields with base type **long**, **short**, or `char` (**signed** or `unsigned`) force alignment to a boundary appropriate to the base type.  \n  \n Bit fields are allocated within an integer from least-significant to most-significant bit. In the following code  \n  \n```  \nstruct mybitfields  \n{  \n    unsigned short a : 4;  \n    unsigned short b : 5;  \n    unsigned short c : 7;  \n} test;  \n  \nint main( void );  \n{  \n    test.a = 2;  \n    test.b = 31;  \n    test.c = 0;  \n}  \n```  \n  \n the bits would be arranged as follows:  \n  \n```  \n00000001 11110010  \ncccccccb bbbbaaaa  \n```  \n  \n Since the 8086 family of processors stores the low byte of integer values before the high byte, the integer `0x01F2` above would be stored in physical memory as `0xF2` followed by `0x01`.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Structure Declarations](../c-language/structure-declarations.md)"}