{"nodes":[{"pos":[12,55],"content":"raw_storage_iterator Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"raw_storage_iterator Class | Microsoft Docs","pos":[0,43]}]},{"content":"raw_storage_iterator Class","pos":[734,760]},{"content":"An adaptor class that is provided to enable algorithms to store their results into uninitialized memory.","pos":[761,865]},{"content":"Syntax","pos":[874,880]},{"content":"Parameters","pos":[977,987]},{"content":"Specifies the output iterator for the object being stored.","pos":[1011,1069]},{"content":"Type","pos":[1077,1081]},{"content":"The type of object for which storage is being allocated.","pos":[1086,1142]},{"content":"Remarks","pos":[1151,1158]},{"content":"The class describes an output iterator that constructs objects of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> in the sequence it generates.","pos":[1162,1271],"source":"The class describes an output iterator that constructs objects of type **Type** in the sequence it generates."},{"content":"An object of class <ph id=\"ph1\">`raw_storage_iterator`\\&lt;</ph> <bpt id=\"p1\">**</bpt>ForwardIterator<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>&gt; accesses storage through a forward iterator object, of class <bpt id=\"p3\">**</bpt>ForwardIterator<ept id=\"p3\">**</ept>, that you specify when you construct the object.","pos":[1272,1476],"source":" An object of class `raw_storage_iterator`\\< **ForwardIterator**, **Type**> accesses storage through a forward iterator object, of class **ForwardIterator**, that you specify when you construct the object."},{"content":"For an object first of class <bpt id=\"p1\">**</bpt>ForwardIterator<ept id=\"p1\">**</ept>, the expression <bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;\\*</ph>first<ept id=\"p2\">**</ept> must designate unconstructed storage for the next object (of type <bpt id=\"p3\">**</bpt>Type<ept id=\"p3\">**</ept>) in the generated sequence.","pos":[1477,1657],"source":" For an object first of class **ForwardIterator**, the expression **&\\*first** must designate unconstructed storage for the next object (of type **Type**) in the generated sequence."},{"content":"This adaptor class is used when it is necessary to separate memory allocation and object construction.","pos":[1664,1766]},{"content":"The <ph id=\"ph1\">`raw_storage_iterator`</ph> can be used to copy objects into uninitialized storage, such as memory allocated using the <ph id=\"ph2\">`malloc`</ph> function.","pos":[1767,1903],"source":" The `raw_storage_iterator` can be used to copy objects into uninitialized storage, such as memory allocated using the `malloc` function."},{"content":"Members","pos":[1912,1919]},{"content":"Constructors","pos":[1929,1941]},{"content":"raw_storage_iterator","pos":[1963,1983]},{"content":"Constructs a raw storage iterator with a specified underlying output iterator.","pos":[2030,2108]},{"content":"Typedefs","pos":[2119,2127]},{"content":"element_type","pos":[2149,2161]},{"content":"Provides a type that describes an element to be stored a raw storage iterator.","pos":[2200,2278]},{"content":"iter_type","pos":[2284,2293]},{"content":"Provides a type that describes an iterator that underlies a raw storage iterator.","pos":[2329,2410]},{"content":"Operators","pos":[2421,2430]},{"content":"operator*","pos":[2452,2461]},{"pos":[2501,2588],"content":"A dereferencing operator used to implement the output iterator expression * <ph id=\"ph1\">`ii` = `x`</ph>.","source":"A dereferencing operator used to implement the output iterator expression * `ii` = `x`."},{"content":"operator=","pos":[2594,2603]},{"pos":[2641,2752],"content":"An assignment operator used to implement the raw storage iterator expression * <ph id=\"ph1\">`i` = `x`</ph> for storing in memory.","source":"An assignment operator used to implement the raw storage iterator expression * `i` = `x` for storing in memory."},{"content":"operator++","pos":[2758,2768]},{"content":"Preincrement and postincrement operators for raw storage iterators.","pos":[2811,2878]},{"content":"Requirements","pos":[2888,2900]},{"pos":[2904,2925],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>memory&gt;","source":"**Header:** \\<memory>"},{"pos":[2932,2950],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[3011,3045],"content":"raw_storage_iterator::element_type"},{"content":"Provides a type that describes an element to be stored a raw storage iterator.","pos":[3049,3127]},{"content":"Remarks","pos":[3177,3184]},{"pos":[3188,3273],"content":"The type is a synonym for the raw_storage_iterator class template parameter <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the raw_storage_iterator class template parameter **Type**."},{"pos":[3331,3362],"content":"raw_storage_iterator::iter_type"},{"content":"Provides a type that describes an iterator that underlies a raw storage iterator.","pos":[3366,3447]},{"content":"Remarks","pos":[3505,3512]},{"pos":[3516,3585],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>ForwardIterator<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **ForwardIterator**."},{"pos":[3647,3678],"content":"raw_storage_iterator::operator*"},{"pos":[3682,3775],"content":"A dereferencing operator used to implement the raw storage iterator expression <ph id=\"ph1\">\\*</ph> <bpt id=\"p1\">*</bpt>ii<ept id=\"p1\">*</ept><ph id=\"ph2\"> = </ph><bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>.","source":"A dereferencing operator used to implement the raw storage iterator expression \\* *ii* = *x*."},{"content":"Return Value","pos":[3856,3868]},{"content":"A reference to the raw storage iterator","pos":[3872,3911]},{"content":"Remarks","pos":[3921,3928]},{"content":"The requirements for a <bpt id=\"p1\">**</bpt>ForwardIterator<ept id=\"p1\">**</ept> are that the raw storage iterator must satisfy require only the expression <ph id=\"ph1\">\\*</ph> <bpt id=\"p2\">*</bpt>ii<ept id=\"p2\">*</ept><ph id=\"ph2\"> = </ph><bpt id=\"p3\">*</bpt>t<ept id=\"p3\">*</ept> be valid and that it says nothing about the <bpt id=\"p4\">**</bpt>operator<ept id=\"p4\">**</ept> or the <ph id=\"ph3\">`operator=`</ph> on their own.","pos":[3932,4153],"source":"The requirements for a **ForwardIterator** are that the raw storage iterator must satisfy require only the expression \\* *ii* = *t* be valid and that it says nothing about the **operator** or the `operator=` on their own."},{"content":"The member operators in this implementation returns <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>, so that <bpt id=\"p2\">[</bpt>operator=<ept id=\"p2\">](#raw_storage_iterator__operator_eq)</ept>( <bpt id=\"p3\">**</bpt>constType<ept id=\"p3\">**</ept>&amp;) can perform the actual store in an expression, such as <ph id=\"ph2\">\\*</ph> <bpt id=\"p4\">*</bpt>ptr<ept id=\"p4\">*</ept><ph id=\"ph3\"> = `val`</ph>.","pos":[4154,4363],"source":" The member operators in this implementation returns **\\*this**, so that [operator=](#raw_storage_iterator__operator_eq)( **constType**&) can perform the actual store in an expression, such as \\* *ptr* = `val`."},{"content":"Example","pos":[4373,4380]},{"pos":[5335,5366],"content":"raw_storage_iterator::operator="},{"pos":[5370,5479],"content":"Assignment operator used to implement the raw storage iterator expression <ph id=\"ph1\">\\*</ph> <bpt id=\"p1\">*</bpt>i<ept id=\"p1\">*</ept><ph id=\"ph2\"> = </ph><bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept> for storing in memory.","source":"Assignment operator used to implement the raw storage iterator expression \\* *i* = *x* for storing in memory."},{"content":"Parameters","pos":[5580,5590]},{"content":"The value of the object of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> to be inserted into memory.","pos":[5603,5671],"source":" The value of the object of type **Type** to be inserted into memory."},{"content":"Return Value","pos":[5681,5693]},{"pos":[5697,5794],"content":"The operator inserts <ph id=\"ph1\">`val`</ph> into memory, and then returns a reference to the raw storage iterator.","source":"The operator inserts `val` into memory, and then returns a reference to the raw storage iterator."},{"content":"Remarks","pos":[5804,5811]},{"content":"The requirements for a <bpt id=\"p1\">**</bpt>ForwardIterator<ept id=\"p1\">**</ept> state that the raw storage iterator must satisfy require only the expression <ph id=\"ph1\">\\*</ph> <bpt id=\"p2\">*</bpt>ii<ept id=\"p2\">*</ept><ph id=\"ph2\"> = </ph><bpt id=\"p3\">*</bpt>t<ept id=\"p3\">*</ept> be valid, and that it says nothing about the <bpt id=\"p4\">**</bpt>operator<ept id=\"p4\">**</ept> or the <ph id=\"ph3\">`operator=`</ph> on their own.","pos":[5815,6039],"source":"The requirements for a **ForwardIterator** state that the raw storage iterator must satisfy require only the expression \\* *ii* = *t* be valid, and that it says nothing about the **operator** or the `operator=` on their own."},{"content":"These member operators return <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>.","pos":[6040,6081],"source":" These member operators return **\\*this**."},{"pos":[6088,6298],"content":"The assignment operator constructs the next object in the output sequence using the stored iterator value first, by evaluating the placement new expression <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> ( ( <ph id=\"ph1\">`void`</ph> <ph id=\"ph2\">\\*</ph>)&amp;<ph id=\"ph3\">\\*</ph> <bpt id=\"p2\">**</bpt>first<ept id=\"p2\">**</ept>) <bpt id=\"p3\">**</bpt>Type<ept id=\"p3\">**</ept>( <ph id=\"ph4\">`val`</ph>).","source":"The assignment operator constructs the next object in the output sequence using the stored iterator value first, by evaluating the placement new expression **new** ( ( `void` \\*)&\\* **first**) **Type**( `val`)."},{"content":"Example","pos":[6308,6315]},{"pos":[7265,7297],"content":"raw_storage_iterator::operator++"},{"content":"Preincrement and postincrement operators for raw storage iterators.","pos":[7301,7368]},{"content":"Return Value","pos":[7512,7524]},{"content":"An raw storage iterator or a reference to an raw storage iterator.","pos":[7528,7594]},{"content":"Remarks","pos":[7604,7611]},{"content":"The first operator eventually attempts to extract and store an object of type <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> from the associated input stream.","pos":[7615,7739],"source":"The first operator eventually attempts to extract and store an object of type **CharType** from the associated input stream."},{"content":"The second operator makes a copy of the object, increments the object, and then returns the copy.","pos":[7740,7837]},{"pos":[7844,7950],"content":"The first preincrement operator increments the stored output iterator object, and then returns <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>.","source":"The first preincrement operator increments the stored output iterator object, and then returns **\\*this**."},{"pos":[7957,8091],"content":"The second postincrement operator makes a copy of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>, increments the stored output iterator object, and then returns the copy.","source":"The second postincrement operator makes a copy of **\\*this**, increments the stored output iterator object, and then returns the copy."},{"pos":[8098,8161],"content":"The constructor stores <bpt id=\"p1\">**</bpt>first<ept id=\"p1\">**</ept> as the output iterator object.","source":"The constructor stores **first** as the output iterator object."},{"content":"Example","pos":[8171,8178]},{"pos":[8811,8853],"content":"raw_storage_iterator::raw_storage_iterator"},{"content":"Constructs a raw storage iterator with a specified underlying output iterator.","pos":[8857,8935]},{"content":"Parameters","pos":[9012,9022]},{"content":"The forward iterator that is to underlie the <ph id=\"ph1\">`raw_storage_iterator`</ph> object being constructed.","pos":[9037,9130],"source":" The forward iterator that is to underlie the `raw_storage_iterator` object being constructed."},{"content":"Example","pos":[9140,9147]},{"content":"See Also","pos":[10892,10900]},{"content":"Thread Safety in the C++ Standard Library","pos":[10905,10946]}],"content":"---\ntitle: \"raw_storage_iterator Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::raw_storage_iterator\"\n  - \"raw_storage_iterator\"\n  - \"std.raw_storage_iterator\"\n  - \"memory/std::raw_storage_iterator\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"raw_storage_iterator class\"\nms.assetid: 6f033f15-f48e-452a-a326-647ea2cf346f\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# raw_storage_iterator Class\nAn adaptor class that is provided to enable algorithms to store their results into uninitialized memory.  \n  \n## Syntax  \n  \n```\ntemplate <class OutputIterator, class Type>  \nclass raw_storage_iterator\n```  \n  \n#### Parameters  \n `OutputIterator`  \n Specifies the output iterator for the object being stored.  \n  \n *Type*  \n The type of object for which storage is being allocated.  \n  \n## Remarks  \n The class describes an output iterator that constructs objects of type **Type** in the sequence it generates. An object of class `raw_storage_iterator`\\< **ForwardIterator**, **Type**> accesses storage through a forward iterator object, of class **ForwardIterator**, that you specify when you construct the object. For an object first of class **ForwardIterator**, the expression **&\\*first** must designate unconstructed storage for the next object (of type **Type**) in the generated sequence.  \n  \n This adaptor class is used when it is necessary to separate memory allocation and object construction. The `raw_storage_iterator` can be used to copy objects into uninitialized storage, such as memory allocated using the `malloc` function.  \n  \n## Members  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[raw_storage_iterator](#raw_storage_iterator__raw_storage_iterator)|Constructs a raw storage iterator with a specified underlying output iterator.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[element_type](#raw_storage_iterator__element_type)|Provides a type that describes an element to be stored a raw storage iterator.|  \n|[iter_type](#raw_storage_iterator__iter_type)|Provides a type that describes an iterator that underlies a raw storage iterator.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator*](#raw_storage_iterator__operator_star)|A dereferencing operator used to implement the output iterator expression * `ii` = `x`.|  \n|[operator=](#raw_storage_iterator__operator_eq)|An assignment operator used to implement the raw storage iterator expression * `i` = `x` for storing in memory.|  \n|[operator++](#raw_storage_iterator__operator_add_add)|Preincrement and postincrement operators for raw storage iterators.|  \n  \n## Requirements  \n **Header:** \\<memory>  \n  \n **Namespace:** std  \n  \n##  <a name=\"raw_storage_iterator__element_type\"></a>  raw_storage_iterator::element_type  \n Provides a type that describes an element to be stored a raw storage iterator.  \n  \n```\ntypedef Type element_type;\n```  \n  \n### Remarks  \n The type is a synonym for the raw_storage_iterator class template parameter **Type**.  \n  \n##  <a name=\"raw_storage_iterator__iter_type\"></a>  raw_storage_iterator::iter_type  \n Provides a type that describes an iterator that underlies a raw storage iterator.  \n  \n```\ntypedef ForwardIterator iter_type;\n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **ForwardIterator**.  \n  \n##  <a name=\"raw_storage_iterator__operator_star\"></a>  raw_storage_iterator::operator*  \n A dereferencing operator used to implement the raw storage iterator expression \\* *ii* = *x*.  \n  \n```\nraw_storage_iterator<ForwardIterator, Type>& operator*();\n```  \n  \n### Return Value  \n A reference to the raw storage iterator  \n  \n### Remarks  \n The requirements for a **ForwardIterator** are that the raw storage iterator must satisfy require only the expression \\* *ii* = *t* be valid and that it says nothing about the **operator** or the `operator=` on their own. The member operators in this implementation returns **\\*this**, so that [operator=](#raw_storage_iterator__operator_eq)( **constType**&) can perform the actual store in an expression, such as \\* *ptr* = `val`.  \n  \n### Example  \n  \n```cpp  \n// raw_storage_iterator_op_deref.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <iterator>  \n#include <memory>  \n#include <list>  \nusing namespace std;  \n  \nclass Int   \n{  \npublic:  \n   Int(int i)   \n   {  \n      cout << \"Constructing \" << i << endl;   \n      x = i;  \n      bIsConstructed = true;  \n   };  \n  \n   Int &operator=(int i)   \n   {  \n      if (!bIsConstructed)  \n         cout << \"Not constructed.\\n\";  \n      cout << \"Copying \" << i << endl;    \n      x = i;   \n      return *this;  \n   };  \n  \n   int x;  \n  \nprivate:  \n   bool bIsConstructed;  \n};  \n  \nint main( void)   \n{  \n   Int *pInt = ( Int* ) malloc( sizeof( Int ) );  \n   memset( pInt, 0, sizeof( Int ) ); // Set bIsConstructed to false;  \n *pInt = 5;  \n   raw_storage_iterator< Int*, Int > it( pInt );  \n *it = 5;  \n}  \n\\* Output:   \nNot constructed.  \nCopying 5  \nConstructing 5  \n*\\  \n```  \n  \n##  <a name=\"raw_storage_iterator__operator_eq\"></a>  raw_storage_iterator::operator=  \n Assignment operator used to implement the raw storage iterator expression \\* *i* = *x* for storing in memory.  \n  \n```\nraw_storage_iterator<ForwardIterator, Type>& operator=(\n    const Type& val);\n```  \n  \n### Parameters  \n `val`  \n The value of the object of type **Type** to be inserted into memory.  \n  \n### Return Value  \n The operator inserts `val` into memory, and then returns a reference to the raw storage iterator.  \n  \n### Remarks  \n The requirements for a **ForwardIterator** state that the raw storage iterator must satisfy require only the expression \\* *ii* = *t* be valid, and that it says nothing about the **operator** or the `operator=` on their own. These member operators return **\\*this**.  \n  \n The assignment operator constructs the next object in the output sequence using the stored iterator value first, by evaluating the placement new expression **new** ( ( `void` \\*)&\\* **first**) **Type**( `val`).  \n  \n### Example  \n  \n```cpp  \n// raw_storage_iterator_op_assign.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <iterator>  \n#include <memory>  \n#include <list>  \nusing namespace std;  \n  \nclass Int   \n{  \npublic:  \n   Int( int i )   \n   {  \n      cout << \"Constructing \" << i << endl;   \n      x = i;  \n      bIsConstructed = true;  \n   };  \n   Int &operator=( int i )   \n   {  \n      if ( !bIsConstructed )  \n         cout << \"Not constructed.\\n\";  \n      cout << \"Copying \" << i << endl; x = i;  \n      return *this;  \n   };  \n   int x;  \nprivate:  \n   bool bIsConstructed;  \n};  \n  \nint main( void )  \n{  \n   Int *pInt = ( Int* )malloc( sizeof( Int ) );  \n   memset( pInt, 0, sizeof( Int ) ); // Set bIsConstructed to false;  \n  \n *pInt = 5;  \n  \n   raw_storage_iterator<Int*, Int> it( pInt );  \n *it = 5;  \n}  \n\\* Output:   \nNot constructed.  \nCopying 5  \nConstructing 5  \n*\\  \n```  \n  \n##  <a name=\"raw_storage_iterator__operator_add_add\"></a>  raw_storage_iterator::operator++  \n Preincrement and postincrement operators for raw storage iterators.  \n  \n```\nraw_storage_iterator<ForwardIterator, Type>& operator++();\n\nraw_storage_iterator<ForwardIterator, Type> operator++(int);\n```  \n  \n### Return Value  \n An raw storage iterator or a reference to an raw storage iterator.  \n  \n### Remarks  \n The first operator eventually attempts to extract and store an object of type **CharType** from the associated input stream. The second operator makes a copy of the object, increments the object, and then returns the copy.  \n  \n The first preincrement operator increments the stored output iterator object, and then returns **\\*this**.  \n  \n The second postincrement operator makes a copy of **\\*this**, increments the stored output iterator object, and then returns the copy.  \n  \n The constructor stores **first** as the output iterator object.  \n  \n### Example  \n  \n```cpp  \n// raw_storage_iterator_op_incr.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <iterator>  \n#include <memory>  \n#include <list>  \nusing namespace std;  \n  \nint main( void )  \n{  \n   int *pInt = new int[5];  \n   std::raw_storage_iterator<int*,int> it( pInt );  \n   for ( int i = 0; i < 5; i++, it++ ) {  \n *it = 2 * i;  \n};  \n  \n   for ( int i = 0; i < 5; i++ ) cout << \"array \" << i << \" = \" << pInt[i] << endl;;  \n  \n   delete[] pInt;  \n}  \n\\* Output:   \narray 0 = 0  \narray 1 = 2  \narray 2 = 4  \narray 3 = 6  \narray 4 = 8  \n*\\  \n```  \n  \n##  <a name=\"raw_storage_iterator__raw_storage_iterator\"></a>  raw_storage_iterator::raw_storage_iterator  \n Constructs a raw storage iterator with a specified underlying output iterator.  \n  \n```\nexplicit raw_storage_iterator(ForwardIterator first);\n```  \n  \n### Parameters  \n `first`  \n The forward iterator that is to underlie the `raw_storage_iterator` object being constructed.  \n  \n### Example  \n  \n```cpp  \n// raw_storage_iterator_ctor.cpp  \n// compile with: /EHsc /W3  \n#include <iostream>  \n#include <iterator>  \n#include <memory>  \n#include <list>  \nusing namespace std;  \n  \nclass Int  \n{  \npublic:  \n   Int(int i)  \n   {  \n      cout << \"Constructing \" << i << endl;  \n      x = i;  \n      bIsConstructed = true;  \n   };  \n   Int &operator=( int i )  \n   {  \n      if (!bIsConstructed)  \n         cout << \"Error! I'm not constructed!\\n\";  \n      cout << \"Copying \" << i << endl;  x = i; return *this;  \n   };  \n   int x;  \n   bool bIsConstructed;  \n};  \n  \nint main( void )  \n{  \n   std::list<int> l;  \n   l.push_back( 1 );  \n   l.push_back( 2 );  \n   l.push_back( 3 );  \n   l.push_back( 4 );  \n  \n   Int *pInt = (Int*)malloc(sizeof(Int)*l.size( ));  \n   memset (pInt, 0, sizeof(Int)*l.size( ));  \n   // Hack: make sure bIsConstructed is false  \n  \n   std::copy( l.begin( ), l.end( ), pInt );  // C4996  \n   for (unsigned int i = 0; i < l.size( ); i++)  \n      cout << \"array \" << i << \" = \" << pInt[i].x << endl;;  \n  \n   memset (pInt, 0, sizeof(Int)*l.size( ));  \n   // hack: make sure bIsConstructed is false  \n  \n   std::copy( l.begin( ), l.end( ),  \n      std::raw_storage_iterator<Int*,Int>(pInt));  // C4996  \n   for (unsigned int i = 0; i < l.size( ); i++ )  \n      cout << \"array \" << i << \" = \" << pInt[i].x << endl;  \n  \n   free(pInt);  \n}  \n\\* Output:   \nError! I'm not constructed!  \nCopying 1  \nError! I'm not constructed!  \nCopying 2  \nError! I'm not constructed!  \nCopying 3  \nError! I'm not constructed!  \nCopying 4  \narray 0 = 1  \narray 1 = 2  \narray 2 = 3  \narray 3 = 4  \nConstructing 1  \nConstructing 2  \nConstructing 3  \nConstructing 4  \narray 0 = 1  \narray 1 = 2  \narray 2 = 3  \narray 3 = 4  \n*\\  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n\n\n"}