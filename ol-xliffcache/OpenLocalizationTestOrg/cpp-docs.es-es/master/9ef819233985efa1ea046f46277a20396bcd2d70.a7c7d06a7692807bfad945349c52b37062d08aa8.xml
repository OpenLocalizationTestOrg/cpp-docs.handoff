{"nodes":[{"pos":[12,36],"content":"__cdecl | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__cdecl | Microsoft Docs","pos":[0,24]}]},{"content":"__cdecl","pos":[624,631]},{"content":"Microsoft Specific","pos":[634,652]},{"content":"is the default calling convention for C and C++ programs.","pos":[671,728]},{"content":"Because the stack is cleaned up by the caller, it can do <bpt id=\"p1\">**</bpt>vararg<ept id=\"p1\">**</ept> functions.","pos":[729,807],"source":" Because the stack is cleaned up by the caller, it can do **vararg** functions."},{"content":"The <ph id=\"ph1\">`__cdecl`</ph> calling convention creates larger executables than <bpt id=\"p1\">[</bpt>__stdcall<ept id=\"p1\">](../cpp/stdcall.md)</ept>, because it requires each function call to include stack cleanup code.","pos":[808,974],"source":" The `__cdecl` calling convention creates larger executables than [__stdcall](../cpp/stdcall.md), because it requires each function call to include stack cleanup code."},{"content":"The following list shows the implementation of this calling convention.","pos":[975,1046]},{"content":"Element","pos":[1053,1060]},{"content":"Implementation","pos":[1061,1075]},{"content":"Argument-passing order","pos":[1119,1141]},{"content":"Right to left.","pos":[1142,1156]},{"content":"Stack-maintenance responsibility","pos":[1161,1193]},{"content":"Calling function pops the arguments from the stack.","pos":[1194,1245]},{"content":"Name-decoration convention","pos":[1250,1276]},{"content":"Underscore character (_) is prefixed to names, except when <ph id=\"ph1\">\\_</ph>_cdecl functions that use C linkage are exported.","pos":[1277,1387],"source":"Underscore character (_) is prefixed to names, except when \\__cdecl functions that use C linkage are exported."},{"content":"Case-translation convention","pos":[1392,1419]},{"content":"No case translation performed.","pos":[1420,1450]},{"pos":[1459,1556],"content":"[!NOTE]\n For related information, see [Decorated Names](../build/reference/decorated-names.md).","leadings":["","> "],"nodes":[{"content":"For related information, see <bpt id=\"p1\">[</bpt>Decorated Names<ept id=\"p1\">](../build/reference/decorated-names.md)</ept>.","pos":[9,95],"source":" For related information, see [Decorated Names](../build/reference/decorated-names.md)."}]},{"content":"Place the <ph id=\"ph1\">`__cdecl`</ph> modifier before a variable or a function name.","pos":[1563,1629],"source":"Place the `__cdecl` modifier before a variable or a function name."},{"content":"Because the C naming and calling conventions are the default, the only time you must use <ph id=\"ph1\">`__cdecl`</ph> in x86 code is when you have specified the <bpt id=\"p1\">**</bpt>/Gv<ept id=\"p1\">**</ept> (vectorcall), <bpt id=\"p2\">**</bpt>/Gz<ept id=\"p2\">**</ept> (stdcall), or <bpt id=\"p3\">**</bpt>/Gr<ept id=\"p3\">**</ept> (fastcall) compiler option.","pos":[1630,1851],"source":" Because the C naming and calling conventions are the default, the only time you must use `__cdecl` in x86 code is when you have specified the **/Gv** (vectorcall), **/Gz** (stdcall), or **/Gr** (fastcall) compiler option."},{"content":"The <bpt id=\"p1\">[</bpt>/Gd<ept id=\"p1\">](../build/reference/gd-gr-gv-gz-calling-convention.md)</ept> compiler option forces the <ph id=\"ph1\">`__cdecl`</ph> calling convention.","pos":[1852,1972],"source":" The [/Gd](../build/reference/gd-gr-gv-gz-calling-convention.md) compiler option forces the `__cdecl` calling convention."},{"content":"On ARM and x64 processors, <ph id=\"ph1\">`__cdecl`</ph> is accepted but typically ignored by the compiler.","pos":[1979,2066],"source":"On ARM and x64 processors, `__cdecl` is accepted but typically ignored by the compiler."},{"content":"By convention on ARM and x64, arguments are passed in registers when possible, and subsequent arguments are passed on the stack.","pos":[2067,2195]},{"content":"In x64 code, use <ph id=\"ph1\">`__cdecl`</ph> to override the <bpt id=\"p1\">**</bpt>/Gv<ept id=\"p1\">**</ept> compiler option and use the default x64 calling convention.","pos":[2196,2306],"source":" In x64 code, use `__cdecl` to override the **/Gv** compiler option and use the default x64 calling convention."},{"content":"For non-static class functions, if the function is defined out-of-line, the calling convention modifier does not have to be specified on the out-of-line definition.","pos":[2313,2477]},{"content":"That is, for class non-static member methods, the calling convention specified during declaration is assumed at the point of definition.","pos":[2478,2614]},{"content":"Given this class definition:","pos":[2615,2643]},{"content":"this:","pos":[2723,2728]},{"content":"is equivalent to this:","pos":[2793,2815]},{"content":"Example","pos":[2890,2897]},{"pos":[2901,3020],"content":"In the following example, the compiler is instructed to use C naming and calling conventions for the <ph id=\"ph1\">`system`</ph> function.","source":"In the following example, the compiler is instructed to use C naming and calling conventions for the `system` function."},{"content":"See Also","pos":[3277,3285]},{"content":"Argument Passing and Naming Conventions","pos":[3290,3329]},{"content":"Keywords","pos":[3387,3395]}],"content":"---\ntitle: \"__cdecl | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__cdecl\"\n  - \"__cdecl_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__cdecl keyword [C++]\"\nms.assetid: 1ff1d03e-fb4e-4562-8be1-74f1ad6427f1\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# __cdecl\n**Microsoft Specific**  \n  \n `__cdecl` is the default calling convention for C and C++ programs. Because the stack is cleaned up by the caller, it can do **vararg** functions. The `__cdecl` calling convention creates larger executables than [__stdcall](../cpp/stdcall.md), because it requires each function call to include stack cleanup code. The following list shows the implementation of this calling convention.  \n  \n|Element|Implementation|  \n|-------------|--------------------|  \n|Argument-passing order|Right to left.|  \n|Stack-maintenance responsibility|Calling function pops the arguments from the stack.|  \n|Name-decoration convention|Underscore character (_) is prefixed to names, except when \\__cdecl functions that use C linkage are exported.|  \n|Case-translation convention|No case translation performed.|  \n  \n> [!NOTE]\n>  For related information, see [Decorated Names](../build/reference/decorated-names.md).  \n  \n Place the `__cdecl` modifier before a variable or a function name. Because the C naming and calling conventions are the default, the only time you must use `__cdecl` in x86 code is when you have specified the **/Gv** (vectorcall), **/Gz** (stdcall), or **/Gr** (fastcall) compiler option. The [/Gd](../build/reference/gd-gr-gv-gz-calling-convention.md) compiler option forces the `__cdecl` calling convention.  \n  \n On ARM and x64 processors, `__cdecl` is accepted but typically ignored by the compiler. By convention on ARM and x64, arguments are passed in registers when possible, and subsequent arguments are passed on the stack. In x64 code, use `__cdecl` to override the **/Gv** compiler option and use the default x64 calling convention.  \n  \n For non-static class functions, if the function is defined out-of-line, the calling convention modifier does not have to be specified on the out-of-line definition. That is, for class non-static member methods, the calling convention specified during declaration is assumed at the point of definition. Given this class definition:  \n  \n```cpp  \nstruct CMyClass {  \n   void __cdecl mymethod();  \n};  \n```  \n  \n this:  \n  \n```cpp  \nvoid CMyClass::mymethod() { return; }  \n```  \n  \n is equivalent to this:  \n  \n```cpp  \nvoid __cdecl CMyClass::mymethod() { return; }  \n```  \n  \n## Example  \n In the following example, the compiler is instructed to use C naming and calling conventions for the `system` function.  \n  \n```cpp  \n// Example of the __cdecl keyword on function  \nint __cdecl system(const char *);  \n// Example of the __cdecl keyword on function pointer  \ntypedef BOOL (__cdecl *funcname_ptr)(void * arg1, const char * arg2, DWORD flags, ...);  \n```  \n  \n## See Also  \n [Argument Passing and Naming Conventions](../cpp/argument-passing-and-naming-conventions.md)   \n [Keywords](../cpp/keywords-cpp.md)"}