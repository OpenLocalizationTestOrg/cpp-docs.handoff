{"nodes":[{"pos":[12,70],"content":"Determining Which Exporting Method to Use | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Determining Which Exporting Method to Use | Microsoft Docs","pos":[0,58]}]},{"content":"Determining Which Exporting Method to Use","pos":[748,789]},{"content":"You can export functions in either of two ways—a .def file or the <ph id=\"ph1\">`__declspec(dllexport)`</ph> keyword.","pos":[790,888],"source":"You can export functions in either of two ways—a .def file or the `__declspec(dllexport)` keyword."},{"content":"To help you decide which way is better for your DLL, consider these questions:","pos":[889,967]},{"content":"Do you plan to export more functions later?","pos":[977,1020]},{"content":"Is your DLL used only by applications that you can rebuild, or is it used by applications that you cannot rebuild—for example, applications that are created by third parties?","pos":[1030,1204]},{"content":"Pros and Cons of Using .def Files","pos":[1213,1246]},{"content":"Exporting functions in a .def file gives you control over the export ordinals.","pos":[1250,1328]},{"content":"When you add an exported function to your DLL, you can assign it a higher ordinal value than any other exported function.","pos":[1329,1450]},{"content":"When you do this, applications that use implicit linking do not have to relink with the import library that contains the new function.","pos":[1451,1585]},{"content":"This is very convenient if you are designing a DLL for use by many applications because you can add new functionality and also ensure that it continues to work correctly with the applications that already rely on it.","pos":[1586,1802]},{"content":"For example, the MFC DLLs are built by using .def files.","pos":[1803,1859]},{"content":"Another advantage to using a .def file is that you can use the <ph id=\"ph1\">`NONAME`</ph> attribute to export a function.","pos":[1866,1969],"source":"Another advantage to using a .def file is that you can use the `NONAME` attribute to export a function."},{"content":"This puts only the ordinal in the exports table in the DLL.","pos":[1970,2029]},{"content":"For DLLs that have a large number of exported functions, using the <ph id=\"ph1\">`NONAME`</ph> attribute can reduce the size of the DLL file.","pos":[2030,2152],"source":" For DLLs that have a large number of exported functions, using the `NONAME` attribute can reduce the size of the DLL file."},{"content":"For information about how to write a module definition statement, see <bpt id=\"p1\">[</bpt>Rules for Module-Definition Statements<ept id=\"p1\">](../build/reference/rules-for-module-definition-statements.md)</ept>.","pos":[2153,2326],"source":" For information about how to write a module definition statement, see [Rules for Module-Definition Statements](../build/reference/rules-for-module-definition-statements.md)."},{"content":"For information about ordinal export, see <bpt id=\"p1\">[</bpt>Exporting Functions from a DLL by Ordinal Rather Than by Name<ept id=\"p1\">](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md)</ept>.","pos":[2327,2508],"source":" For information about ordinal export, see [Exporting Functions from a DLL by Ordinal Rather Than by Name](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md)."},{"content":"A disadvantage of using a .def file is that if you are exporting functions in a C++ file, you either have to put the decorated names in the .def file or define the exported functions by using extern \"C\" to avoid the name decoration that's done by the Visual C++ compiler.","pos":[2515,2786]},{"content":"If you put the decorated names in the .def file, you can obtain them by using the <bpt id=\"p1\">[</bpt>DUMPBIN<ept id=\"p1\">](../build/reference/dumpbin-reference.md)</ept> tool or by using the linker <bpt id=\"p2\">[</bpt>/MAP<ept id=\"p2\">](../build/reference/map-generate-mapfile.md)</ept> option.","pos":[2793,3012],"source":"If you put the decorated names in the .def file, you can obtain them by using the [DUMPBIN](../build/reference/dumpbin-reference.md) tool or by using the linker [/MAP](../build/reference/map-generate-mapfile.md) option."},{"content":"The decorated names that are produced by the compiler are compiler-specific; therefore, if you put the decorated names that are produced by the compiler into a .def file, the applications that link to the DLL must also be built by using the same version of the compiler so that the decorated names in the calling application match the exported names in the .def file of the DLL.","pos":[3013,3391]},{"content":"Pros and Cons of Using __declspec(dllexport)","pos":[3400,3444]},{"content":"Using <ph id=\"ph1\">`__declspec(dllexport)`</ph> is convenient because you do not have to worry about maintaining a .def file and obtaining the decorated names of the exported functions.","pos":[3448,3615],"source":"Using `__declspec(dllexport)` is convenient because you do not have to worry about maintaining a .def file and obtaining the decorated names of the exported functions."},{"content":"However, the usefulness of this way of exporting is limited by the number of linked applications that you are willing to rebuild.","pos":[3616,3745]},{"content":"If you rebuild the DLL with new exports, you also have to rebuild the applications because the decorated names for exported C++ functions might change if you use a different version of the compiler to rebuild it.","pos":[3746,3958]},{"content":"What do you want to do?","pos":[3968,3991]},{"content":"Export from a DLL using .DEF files","pos":[4002,4036]},{"content":"Export from a DLL using __declspec(dllexport)","pos":[4098,4143]},{"content":"Export and import using AFX_EXT_CLASS","pos":[4214,4251]},{"content":"Export C++ functions for use in C-language executables","pos":[4320,4374]},{"content":"Export C functions for use in C or C++-language executables","pos":[4457,4516]},{"content":"Import into an application using __declspec(dllimport)","pos":[4604,4658]},{"content":"Initialize a DLL","pos":[4738,4754]},{"content":"What do you want to know more about?","pos":[4797,4833]},{"content":"Importing and exporting inline functions","pos":[4844,4884]},{"content":"Mutual imports","pos":[4950,4964]},{"content":"Decorated names","pos":[5004,5019]},{"content":"See Also","pos":[5068,5076]},{"content":"Exporting from a DLL","pos":[5081,5101]}],"content":"---\ntitle: \"Determining Which Exporting Method to Use | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__declspec(dllexport) keyword [C++]\"\n  - \"exporting DLLs [C++], method comparison\"\n  - \"def files [C++], exporting from DLLs\"\n  - \".def files [C++], exporting from DLLs\"\nms.assetid: 66d773ed-935c-45c2-ad03-1a060874b34d\ncaps.latest.revision: 13\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Determining Which Exporting Method to Use\nYou can export functions in either of two ways—a .def file or the `__declspec(dllexport)` keyword. To help you decide which way is better for your DLL, consider these questions:  \n  \n-   Do you plan to export more functions later?  \n  \n-   Is your DLL used only by applications that you can rebuild, or is it used by applications that you cannot rebuild—for example, applications that are created by third parties?  \n  \n## Pros and Cons of Using .def Files  \n Exporting functions in a .def file gives you control over the export ordinals. When you add an exported function to your DLL, you can assign it a higher ordinal value than any other exported function. When you do this, applications that use implicit linking do not have to relink with the import library that contains the new function. This is very convenient if you are designing a DLL for use by many applications because you can add new functionality and also ensure that it continues to work correctly with the applications that already rely on it. For example, the MFC DLLs are built by using .def files.  \n  \n Another advantage to using a .def file is that you can use the `NONAME` attribute to export a function. This puts only the ordinal in the exports table in the DLL. For DLLs that have a large number of exported functions, using the `NONAME` attribute can reduce the size of the DLL file. For information about how to write a module definition statement, see [Rules for Module-Definition Statements](../build/reference/rules-for-module-definition-statements.md). For information about ordinal export, see [Exporting Functions from a DLL by Ordinal Rather Than by Name](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md).  \n  \n A disadvantage of using a .def file is that if you are exporting functions in a C++ file, you either have to put the decorated names in the .def file or define the exported functions by using extern \"C\" to avoid the name decoration that's done by the Visual C++ compiler.  \n  \n If you put the decorated names in the .def file, you can obtain them by using the [DUMPBIN](../build/reference/dumpbin-reference.md) tool or by using the linker [/MAP](../build/reference/map-generate-mapfile.md) option. The decorated names that are produced by the compiler are compiler-specific; therefore, if you put the decorated names that are produced by the compiler into a .def file, the applications that link to the DLL must also be built by using the same version of the compiler so that the decorated names in the calling application match the exported names in the .def file of the DLL.  \n  \n## Pros and Cons of Using __declspec(dllexport)  \n Using `__declspec(dllexport)` is convenient because you do not have to worry about maintaining a .def file and obtaining the decorated names of the exported functions. However, the usefulness of this way of exporting is limited by the number of linked applications that you are willing to rebuild. If you rebuild the DLL with new exports, you also have to rebuild the applications because the decorated names for exported C++ functions might change if you use a different version of the compiler to rebuild it.  \n  \n### What do you want to do?  \n  \n-   [Export from a DLL using .DEF files](../build/exporting-from-a-dll-using-def-files.md)  \n  \n-   [Export from a DLL using __declspec(dllexport)](../build/exporting-from-a-dll-using-declspec-dllexport.md)  \n  \n-   [Export and import using AFX_EXT_CLASS](../build/exporting-and-importing-using-afx-ext-class.md)  \n  \n-   [Export C++ functions for use in C-language executables](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)  \n  \n-   [Export C functions for use in C or C++-language executables](../build/exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)  \n  \n-   [Import into an application using __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)  \n  \n-   [Initialize a DLL](../build/initializing-a-dll.md)  \n  \n### What do you want to know more about?  \n  \n-   [Importing and exporting inline functions](../build/importing-and-exporting-inline-functions.md)  \n  \n-   [Mutual imports](../build/mutual-imports.md)  \n  \n-   [Decorated names](../build/reference/decorated-names.md)  \n  \n## See Also  \n [Exporting from a DLL](../build/exporting-from-a-dll.md)"}