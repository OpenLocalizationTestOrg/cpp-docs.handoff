{"nodes":[{"pos":[12,62],"content":"Microsoft Extensions to C and C++ | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Microsoft Extensions to C and C++ | Microsoft Docs","pos":[0,50]}]},{"content":"Microsoft Extensions to C and C++","pos":[1310,1343]},{"content":"Visual C++ extends the ANSI C and ANSI C++ standards as follows.","pos":[1344,1408]},{"content":"Keywords","pos":[1417,1425]},{"content":"Several keywords are added.","pos":[1429,1456]},{"content":"In the list in <bpt id=\"p1\">[</bpt>Keywords<ept id=\"p1\">](../../cpp/keywords-cpp.md)</ept>, the keywords that have two leading underscores are Visual C++ extensions.","pos":[1457,1584],"source":" In the list in [Keywords](../../cpp/keywords-cpp.md), the keywords that have two leading underscores are Visual C++ extensions."},{"content":"Out of Class Definition of static const Integral (or enum) Members","pos":[1593,1659]},{"pos":[1663,1766],"content":"Under the standard (<bpt id=\"p1\">**</bpt>/Za<ept id=\"p1\">**</ept>), you must make an out-of-class definition for data members, as shown here:","source":"Under the standard (**/Za**), you must make an out-of-class definition for data members, as shown here:"},{"content":"Under <bpt id=\"p1\">**</bpt>/Ze<ept id=\"p1\">**</ept>, the out-of-class definition is optional for static, const integral, and const enum data members.","pos":[1937,2048],"source":"Under **/Ze**, the out-of-class definition is optional for static, const integral, and const enum data members."},{"content":"Only integrals and enums that are static and const can have initializers in a class; the initializing expression must be a const expression.","pos":[2049,2189]},{"content":"To avoid errors when an out-of-class definition is provided in a header file and the header file is included in multiple source files, use <bpt id=\"p1\">[</bpt>selectany<ept id=\"p1\">](../../cpp/selectany.md)</ept>.","pos":[2196,2371],"source":"To avoid errors when an out-of-class definition is provided in a header file and the header file is included in multiple source files, use [selectany](../../cpp/selectany.md)."},{"content":"For example:","pos":[2372,2384]},{"content":"Casts","pos":[2461,2466]},{"content":"Both the C++ compiler and C compiler support these kinds of non-ANSI casts:","pos":[2470,2545]},{"content":"Non-ANSI casts to produce l-values.","pos":[2555,2590]},{"content":"For example:","pos":[2591,2603]},{"pos":[2677,2865],"content":"[!NOTE]\n This extension is available in the C language only. You can use the following ANSI C standard form in C++ code to modify a pointer as if it is a pointer to a different type.","leadings":["","    > "],"nodes":[{"content":" This extension is available in the C language only. You can use the following ANSI C standard form in C++ code to modify a pointer as if it is a pointer to a different type.","pos":[8,182],"nodes":[{"content":"This extension is available in the C language only.","pos":[1,52]},{"content":"You can use the following ANSI C standard form in C++ code to modify a pointer as if it is a pointer to a different type.","pos":[53,174]}]}]},{"content":"The preceding example could be rewritten as follows to conform to the ANSI C standard.","pos":[2876,2962]},{"content":"Non-ANSI casts of a function pointer to a data pointer.","pos":[3034,3089]},{"content":"For example:","pos":[3090,3102]},{"pos":[3212,3363],"content":"To perform the same cast and also maintain ANSI compatibility, you can cast the function pointer to a <ph id=\"ph1\">`uintptr_t`</ph> before you cast it to a data pointer:","source":"To perform the same cast and also maintain ANSI compatibility, you can cast the function pointer to a `uintptr_t` before you cast it to a data pointer:"},{"content":"Variable-Length Argument Lists","pos":[3438,3468]},{"content":"Both the C++ compiler and C compiler support a function declarator that specifies a variable number of arguments, followed by a function definition that provides a type instead:","pos":[3472,3649]},{"content":"Single-Line Comments","pos":[3741,3761]},{"content":"The C compiler supports single-line comments, which are introduced by using two forward slash (//) characters:","pos":[3765,3875]},{"content":"Scope","pos":[3935,3940]},{"content":"The C compiler supports the following scope-related features.","pos":[3944,4005]},{"content":"Redefinitions of extern items as static:","pos":[4015,4055]},{"content":"Use of benign typedef redefinitions within the same scope:","pos":[4146,4204]},{"content":"Function declarators have file scope:","pos":[4283,4320]},{"content":"Use of block-scope variables that are initialized by using nonconstant expressions:","pos":[4568,4651]},{"content":"Data Declarations and Definitions","pos":[4936,4969]},{"content":"The C compiler supports the following data declaration and definition features.","pos":[4973,5052]},{"content":"Mixed character and string constants in an initializer:","pos":[5062,5117]},{"pos":[5189,5267],"content":"Bit fields that have base types other than <bpt id=\"p1\">**</bpt>unsigned int<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>signed int<ept id=\"p2\">**</ept>.","source":"Bit fields that have base types other than **unsigned int** or **signed int**."},{"content":"Declarators that don't have a type:","pos":[5277,5312]},{"content":"Unsized arrays as the last field in structures and unions:","pos":[5410,5468]},{"content":"Unnamed (anonymous) structures:","pos":[5579,5610]},{"content":"Unnamed (anonymous) unions:","pos":[5709,5736]},{"content":"Unnamed members:","pos":[5835,5851]},{"content":"Intrinsic Floating-Point Functions","pos":[5974,6008]},{"content":"Both the C++ compiler and C compiler support inline generation <bpt id=\"p1\">**</bpt>x86 Specific &gt;<ept id=\"p1\">**</ept> of the <ph id=\"ph1\">`atan`</ph>, <ph id=\"ph2\">`atan2`</ph>, <ph id=\"ph3\">`cos`</ph>, <ph id=\"ph4\">`exp`</ph>, <ph id=\"ph5\">`log`</ph>, <ph id=\"ph6\">`log10`</ph>, <ph id=\"ph7\">`sin`</ph>, <ph id=\"ph8\">`sqrt`</ph>, and <ph id=\"ph9\">`tan`</ph> functions <bpt id=\"p2\">**</bpt>END x86 Specific<ept id=\"p2\">**</ept> when <bpt id=\"p3\">**</bpt>/Oi<ept id=\"p3\">**</ept> is specified.","pos":[6012,6230],"source":"Both the C++ compiler and C compiler support inline generation **x86 Specific >** of the `atan`, `atan2`, `cos`, `exp`, `log`, `log10`, `sin`, `sqrt`, and `tan` functions **END x86 Specific** when **/Oi** is specified."},{"content":"For the C compiler, ANSI conformance is lost when these intrinsics are used, because they do not set the <ph id=\"ph1\">`errno`</ph> variable.","pos":[6231,6353],"source":" For the C compiler, ANSI conformance is lost when these intrinsics are used, because they do not set the `errno` variable."},{"content":"Passing a Non-Const Pointer Parameter to a Function that Expects a Reference to a Const Pointer Parameter","pos":[6362,6467]},{"content":"This is an extension to C++.","pos":[6471,6499]},{"content":"This code will compile with <bpt id=\"p1\">**</bpt>/Ze<ept id=\"p1\">**</ept>:","pos":[6500,6536],"source":" This code will compile with **/Ze**:"},{"content":"ISO646.H Not Enabled","pos":[7024,7044]},{"pos":[7048,7149],"content":"Under <bpt id=\"p1\">**</bpt>/Ze<ept id=\"p1\">**</ept>, you have to include iso646.h if you want to use text forms of the following operators:","source":"Under **/Ze**, you have to include iso646.h if you want to use text forms of the following operators:"},{"content":"&amp;&amp; (and)","pos":[7159,7167],"source":"&& (and)"},{"content":"&amp;= (and_eq)","pos":[7177,7188],"source":"&= (and_eq)"},{"content":"&amp; (bitand)","pos":[7198,7208],"source":"& (bitand)"},{"content":"&amp;#124; (bitor)","pos":[7218,7232],"source":"&#124; (bitor)"},{"content":"~ (compl)","pos":[7242,7251]},{"content":"!","pos":[7261,7262]},{"content":"(not)","pos":[7263,7268]},{"content":"!= (not_eq)","pos":[7278,7289]},{"content":"&amp;#124;&amp;#124; (or)","pos":[7299,7316],"source":"&#124;&#124; (or)"},{"content":"&amp;#124;= (or_eq)","pos":[7326,7341],"source":"&#124;= (or_eq)"},{"content":"^ (xor)","pos":[7351,7358]},{"content":"^= (xor_eq)","pos":[7368,7379]},{"content":"Address of String Literal Has Type const char [], not const char (*) []","pos":[7388,7459]},{"pos":[7463,7564],"content":"The following example will output char const (<ph id=\"ph1\">\\*</ph>)[4] under <bpt id=\"p1\">**</bpt>/Za<ept id=\"p1\">**</ept>, but char const [4] under <bpt id=\"p2\">**</bpt>/Ze<ept id=\"p2\">**</ept>.","source":"The following example will output char const (\\*)[4] under **/Za**, but char const [4] under **/Ze**."},{"content":"See Also","pos":[7702,7710]},{"content":"/Za, /Ze (Disable Language Extensions)","pos":[7715,7753]},{"content":"Compiler Options","pos":[7820,7836]},{"content":"Setting Compiler Options","pos":[7886,7910]}],"content":"---\ntitle: \"Microsoft Extensions to C and C++ | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"or_eq operator\"\n  - \"~ operator, extensions to C/C++\"\n  - \"& operator, extensions to C/C++\"\n  - \"&= operator\"\n  - \"iso646.h header\"\n  - \"Xor operator, Microsoft extensions to C/C++\"\n  - \"!= operator\"\n  - \"! operator, extension to C++\"\n  - \"Or operator, Microsoft extensions to C/C++\"\n  - \"^ operator, extensions to C/C++\"\n  - \"^= operator, C++ extensions\"\n  - \"xor_eq operator\"\n  - \"and_eq operator\"\n  - \"Microsoft extensions to C/C++\"\n  - \"|= operator\"\n  - \"|| operator\"\n  - \"And operator, extensions to C/C++\"\n  - \"NOT operator\"\n  - \"&& operator\"\n  - \"extensions, C language\"\n  - \"Visual C++, extensions to C/C++\"\n  - \"| operator, extensions\"\n  - \"not_eq operator\"\n  - \"Visual C, Microsoft extensions\"\n  - \"extensions\"\n  - \"compl method\"\nms.assetid: e811a74a-45ba-4c00-b206-2f2321b8689a\ncaps.latest.revision: 18\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Microsoft Extensions to C and C++\nVisual C++ extends the ANSI C and ANSI C++ standards as follows.  \n  \n## Keywords  \n Several keywords are added. In the list in [Keywords](../../cpp/keywords-cpp.md), the keywords that have two leading underscores are Visual C++ extensions.  \n  \n## Out of Class Definition of static const Integral (or enum) Members  \n Under the standard (**/Za**), you must make an out-of-class definition for data members, as shown here:  \n  \n```  \n  \n      class CMyClass  {  \n   static const int max = 5;  \n   int m_array[max];  \n}  \n...  \nconst int CMyClass::max;   // out of class definition  \n```  \n  \n Under **/Ze**, the out-of-class definition is optional for static, const integral, and const enum data members. Only integrals and enums that are static and const can have initializers in a class; the initializing expression must be a const expression.  \n  \n To avoid errors when an out-of-class definition is provided in a header file and the header file is included in multiple source files, use [selectany](../../cpp/selectany.md). For example:  \n  \n```  \n__declspec(selectany) const int CMyClass::max = 5;  \n```  \n  \n## Casts  \n Both the C++ compiler and C compiler support these kinds of non-ANSI casts:  \n  \n-   Non-ANSI casts to produce l-values. For example:  \n  \n    ```  \n    char *p;  \n    (( int * ) p )++;  \n    ```  \n  \n    > [!NOTE]\n    >  This extension is available in the C language only. You can use the following ANSI C standard form in C++ code to modify a pointer as if it is a pointer to a different type.  \n  \n     The preceding example could be rewritten as follows to conform to the ANSI C standard.  \n  \n    ```  \n    p = ( char * )(( int * )p + 1 );  \n    ```  \n  \n-   Non-ANSI casts of a function pointer to a data pointer. For example:  \n  \n    ```  \n    int ( * pfunc ) ();   \n    int *pdata;  \n    pdata = ( int * ) pfunc;  \n    ```  \n  \n     To perform the same cast and also maintain ANSI compatibility, you can cast the function pointer to a `uintptr_t` before you cast it to a data pointer:  \n  \n    ```  \n    pdata = ( int * ) (uintptr_t) pfunc;  \n    ```  \n  \n## Variable-Length Argument Lists  \n Both the C++ compiler and C compiler support a function declarator that specifies a variable number of arguments, followed by a function definition that provides a type instead:  \n  \n```  \nvoid myfunc( int x, ... );  \nvoid myfunc( int x, char * c )  \n{ }  \n```  \n  \n## Single-Line Comments  \n The C compiler supports single-line comments, which are introduced by using two forward slash (//) characters:  \n  \n```  \n// This is a single-line comment.  \n```  \n  \n## Scope  \n The C compiler supports the following scope-related features.  \n  \n-   Redefinitions of extern items as static:  \n  \n    ```  \n    extern int clip();  \n    static int clip()  \n    {}  \n    ```  \n  \n-   Use of benign typedef redefinitions within the same scope:  \n  \n    ```  \n    typedef int INT;  \n    typedef int INT;  \n    ```  \n  \n-   Function declarators have file scope:  \n  \n    ```  \n    void func1()  \n    {  \n        extern int func2( double );  \n    }  \n    int main( void )  \n    {  \n        func2( 4 );    //  /Ze passes 4 as type double  \n    }                  //  /Za passes 4 as type int  \n    ```  \n  \n-   Use of block-scope variables that are initialized by using nonconstant expressions:  \n  \n    ```  \n    int clip( int );  \n    int bar( int );  \n    int main( void )  \n    {  \n        int array[2] = { clip( 2 ), bar( 4 ) };  \n    }  \n    int clip( int x )  \n    {  \n        return x;  \n    }  \n    int bar( int x )  \n    {  \n        return x;  \n    }  \n    ```  \n  \n## Data Declarations and Definitions  \n The C compiler supports the following data declaration and definition features.  \n  \n-   Mixed character and string constants in an initializer:  \n  \n    ```  \n    char arr[5] = {'a', 'b', \"cde\"};  \n    ```  \n  \n-   Bit fields that have base types other than **unsigned int** or **signed int**.  \n  \n-   Declarators that don't have a type:  \n  \n    ```  \n    x;  \n    int main( void )  \n    {  \n        x = 1;  \n    }  \n    ```  \n  \n-   Unsized arrays as the last field in structures and unions:  \n  \n    ```  \n    struct zero  \n    {  \n        char *c;  \n        int zarray[];  \n    };  \n    ```  \n  \n-   Unnamed (anonymous) structures:  \n  \n    ```  \n    struct  \n    {  \n        int i;  \n        char *s;  \n    };  \n    ```  \n  \n-   Unnamed (anonymous) unions:  \n  \n    ```  \n    union  \n    {  \n        int i;  \n        float fl;  \n    };  \n    ```  \n  \n-   Unnamed members:  \n  \n    ```  \n    struct s  \n    {  \n       unsigned int flag : 1;  \n       unsigned int : 31;  \n    }  \n    ```  \n  \n## Intrinsic Floating-Point Functions  \n Both the C++ compiler and C compiler support inline generation **x86 Specific >** of the `atan`, `atan2`, `cos`, `exp`, `log`, `log10`, `sin`, `sqrt`, and `tan` functions **END x86 Specific** when **/Oi** is specified. For the C compiler, ANSI conformance is lost when these intrinsics are used, because they do not set the `errno` variable.  \n  \n## Passing a Non-Const Pointer Parameter to a Function that Expects a Reference to a Const Pointer Parameter  \n This is an extension to C++. This code will compile with **/Ze**:  \n  \n```  \ntypedef   int   T;  \n  \nconst T  acT = 9;      // A constant of type 'T'  \nconst T* pcT = &acT;   // A pointer to a constant of type 'T'  \n  \nvoid func2 ( const T*& rpcT )   // A reference to a pointer to a constant of type 'T'  \n{  \n   rpcT = pcT;  \n}  \n  \nT*   pT;               // A pointer to a 'T'  \n  \nvoid func ()  \n{  \n   func2 ( pT );      // Should be an error, but isn't detected  \n   *pT   = 7;         // Invalidly overwrites the constant 'acT'  \n}  \n```  \n  \n## ISO646.H Not Enabled  \n Under **/Ze**, you have to include iso646.h if you want to use text forms of the following operators:  \n  \n-   && (and)  \n  \n-   &= (and_eq)  \n  \n-   & (bitand)  \n  \n-   &#124; (bitor)  \n  \n-   ~ (compl)  \n  \n-   ! (not)  \n  \n-   != (not_eq)  \n  \n-   &#124;&#124; (or)  \n  \n-   &#124;= (or_eq)  \n  \n-   ^ (xor)  \n  \n-   ^= (xor_eq)  \n  \n## Address of String Literal Has Type const char [], not const char (*) []  \n The following example will output char const (\\*)[4] under **/Za**, but char const [4] under **/Ze**.  \n  \n```  \n#include <stdio.h>  \n#include <typeinfo>  \n  \nint main()  \n{  \n    printf_s(\"%s\\n\", typeid(&\"abc\").name());  \n}  \n```  \n  \n## See Also  \n [/Za, /Ze (Disable Language Extensions)](../../build/reference/za-ze-disable-language-extensions.md)   \n [Compiler Options](../../build/reference/compiler-options.md)   \n [Setting Compiler Options](../../build/reference/setting-compiler-options.md)"}