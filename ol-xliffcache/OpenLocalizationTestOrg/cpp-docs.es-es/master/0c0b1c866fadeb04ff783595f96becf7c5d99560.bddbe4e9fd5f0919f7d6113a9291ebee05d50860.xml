{"nodes":[{"pos":[12,47],"content":"basic_string Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"basic_string Class | Microsoft Docs","pos":[0,35]}]},{"content":"basic_string Class","pos":[687,705]},{"content":"The sequences controlled by an object of template class <ph id=\"ph1\">`basic_string`</ph> are the Standard C++ string class and are usually referred to as strings, but they should not be confused with the null-terminated C-style strings used throughout the Standard C++ Library.","pos":[706,965],"source":"The sequences controlled by an object of template class `basic_string` are the Standard C++ string class and are usually referred to as strings, but they should not be confused with the null-terminated C-style strings used throughout the Standard C++ Library."},{"content":"The Standard C++ string is a container that enables the use of strings as normal types, such as comparison and concatenation operations, iterators, STL algorithms, and copying and assigning with class allocator managed memory.","pos":[966,1192]},{"content":"If you need to convert a Standard C++ string to a null-terminated C-style string, use the <bpt id=\"p1\">[</bpt>basic_string::c_str<ept id=\"p1\">](#basic_string__c_str)</ept> member.","pos":[1193,1334],"source":" If you need to convert a Standard C++ string to a null-terminated C-style string, use the [basic_string::c_str](#basic_string__c_str) member."},{"content":"Syntax","pos":[1343,1349]},{"content":"Parameters","pos":[1502,1512]},{"content":"The data type of a single character to be stored in the string.","pos":[1530,1593]},{"content":"The Standard C++ Library provides specializations of this template class, with the type definitions <bpt id=\"p1\">[</bpt>string<ept id=\"p1\">](../standard-library/string-typedefs.md#string)</ept> for elements of type <ph id=\"ph1\">`char`</ph>, <bpt id=\"p2\">[</bpt>wstring<ept id=\"p2\">](../standard-library/string-typedefs.md#wstring)</ept>, for <ph id=\"ph2\">`wchar_t`</ph>, <bpt id=\"p3\">[</bpt>u16string<ept id=\"p3\">](../standard-library/string-typedefs.md#u16string)</ept> for <ph id=\"ph3\">`char16_t`</ph>, and <bpt id=\"p4\">[</bpt>u32string<ept id=\"p4\">](../standard-library/string-typedefs.md#u32string)</ept> for <ph id=\"ph4\">`char32_t`</ph>.","pos":[1594,2012],"source":" The Standard C++ Library provides specializations of this template class, with the type definitions [string](../standard-library/string-typedefs.md#string) for elements of type `char`, [wstring](../standard-library/string-typedefs.md#wstring), for `wchar_t`, [u16string](../standard-library/string-typedefs.md#u16string) for `char16_t`, and [u32string](../standard-library/string-typedefs.md#u32string) for `char32_t`."},{"content":"Various important properties of the <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> elements in a basic_string specialization are described by the class <bpt id=\"p2\">**</bpt>Traits<ept id=\"p2\">**</ept>.","pos":[2031,2160],"source":" Various important properties of the **CharType** elements in a basic_string specialization are described by the class **Traits**."},{"content":"The default value is <ph id=\"ph1\">`char_traits`&lt; `CharType`</ph>&gt;.","pos":[2161,2209],"source":" The default value is `char_traits`< `CharType`>."},{"content":"The type that represents the stored allocator object that encapsulates details about the string's allocation and deallocation of memory.","pos":[2231,2367]},{"content":"The default value is <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept><ph id=\"ph1\">&lt; `CharType`</ph>&gt;.","pos":[2368,2416],"source":" The default value is **allocator**< `CharType`>."},{"content":"Constructors","pos":[2426,2438]},{"content":"basic_string","pos":[2460,2472]},{"content":"Constructs a string that is empty or initialized by specific characters or that is a copy of all or part of some other string object or C-string.","pos":[2503,2648]},{"content":"Typedefs","pos":[2659,2667]},{"content":"allocator_type","pos":[2689,2703]},{"pos":[2736,2801],"content":"A type that represents the <ph id=\"ph1\">`allocator`</ph> class for a string object.","source":"A type that represents the `allocator` class for a string object."},{"content":"const_iterator","pos":[2807,2821]},{"pos":[2854,2957],"content":"A type that provides a random-access iterator that can access and read a <ph id=\"ph1\">`const`</ph> element in the string.","source":"A type that provides a random-access iterator that can access and read a `const` element in the string."},{"content":"const_pointer","pos":[2963,2976]},{"pos":[3008,3072],"content":"A type that provides a pointer to a <ph id=\"ph1\">`const`</ph> element in a string.","source":"A type that provides a pointer to a `const` element in a string."},{"content":"const_reference","pos":[3078,3093]},{"pos":[3127,3246],"content":"A type that provides a reference to a <ph id=\"ph1\">`const`</ph> element stored in a string for reading and performing <ph id=\"ph2\">`const`</ph> operations.","source":"A type that provides a reference to a `const` element stored in a string for reading and performing `const` operations."},{"content":"const_reverse_iterator","pos":[3252,3274]},{"pos":[3315,3409],"content":"A type that provides a random-access iterator that can read any <ph id=\"ph1\">`const`</ph> element in the string.","source":"A type that provides a random-access iterator that can read any `const` element in the string."},{"content":"difference_type","pos":[3415,3430]},{"content":"A type that provides the difference between two iterators that refer to elements within the same string.","pos":[3464,3568]},{"content":"iterator","pos":[3574,3582]},{"content":"A type that provides a random-access iterator that can read or modify any element in a string.","pos":[3609,3703]},{"content":"npos","pos":[3709,3713]},{"content":"An unsigned integral value initialized to –1 that indicates either \"not found\" or \"all remaining characters\" when a search function fails.","pos":[3736,3874]},{"content":"pointer","pos":[3880,3887]},{"content":"A type that provides a pointer to a character element in a string or character array.","pos":[3913,3998]},{"content":"reference","pos":[4004,4013]},{"content":"A type that provides a reference to an element stored in a string.","pos":[4041,4107]},{"content":"reverse_iterator","pos":[4113,4129]},{"content":"A type that provides a random-access iterator that can read or modify an element in a reversed string.","pos":[4164,4266]},{"content":"size_type","pos":[4272,4281]},{"content":"An unsigned integral type for the number of elements in a string.","pos":[4309,4374]},{"content":"traits_type","pos":[4380,4391]},{"content":"A type for the character traits of the elements stored in a string.","pos":[4421,4488]},{"content":"value_type","pos":[4494,4504]},{"content":"A type that represents the type of characters stored in a string.","pos":[4533,4598]},{"content":"Member Functions","pos":[4609,4625]},{"content":"append","pos":[4647,4653]},{"content":"Adds characters to the end of a string.","pos":[4678,4717]},{"content":"assign","pos":[4723,4729]},{"content":"Assigns new character values to the contents of a string.","pos":[4754,4811]},{"content":"at","pos":[4817,4819]},{"content":"Returns a reference to the element at a specified location in the string.","pos":[4840,4913]},{"content":"back","pos":[4919,4923]},{"content":"begin","pos":[4952,4957]},{"content":"Returns an iterator addressing the first element in the string.","pos":[4981,5044]},{"content":"c_str","pos":[5050,5055]},{"content":"Converts the contents of a string as a C-style, null-terminated, string.","pos":[5079,5151]},{"content":"capacity","pos":[5157,5165]},{"content":"Returns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.","pos":[5192,5319]},{"content":"cbegin","pos":[5325,5331]},{"content":"Returns a const iterator addressing the first element in the string.","pos":[5356,5424]},{"content":"cend","pos":[5430,5434]},{"content":"Returns a const iterator that addresses the location succeeding the last element in a string.","pos":[5457,5550]},{"content":"clear","pos":[5556,5561]},{"content":"Erases all elements of a string.","pos":[5585,5617]},{"content":"compare","pos":[5623,5630]},{"content":"Compares a string with a specified string to determine if the two strings are equal or if one is lexicographically less than the other.","pos":[5656,5791]},{"content":"copy","pos":[5797,5801]},{"content":"Copies at most a specified number of characters from an indexed position in a source string to a target character array.","pos":[5824,5944]},{"content":"Deprecated.","pos":[5945,5956]},{"content":"Use <bpt id=\"p1\">[</bpt>basic_string::_Copy_s<ept id=\"p1\">](#basic_string___copy_s)</ept> instead.","pos":[5957,6017],"source":" Use [basic_string::_Copy_s](#basic_string___copy_s) instead."},{"content":"crbegin","pos":[6023,6030]},{"content":"Returns a const iterator that addresses the first element in a reversed string.","pos":[6056,6135]},{"content":"crend","pos":[6141,6146]},{"content":"Returns a const iterator that addresses the location succeeding the last element in a reversed string.","pos":[6170,6272]},{"content":"_Copy_s","pos":[6278,6285]},{"content":"Copies at most a specified number of characters from an indexed position in a source string to a target character array.","pos":[6311,6431]},{"content":"data","pos":[6437,6441]},{"content":"Converts the contents of a string into an array of characters.","pos":[6464,6526]},{"content":"empty","pos":[6532,6537]},{"content":"Tests whether the string contains characters.","pos":[6561,6606]},{"content":"end","pos":[6612,6615]},{"content":"Returns an iterator that addresses the location succeeding the last element in a string.","pos":[6637,6725]},{"content":"erase","pos":[6731,6736]},{"content":"Removes an element or a range of elements in a string from a specified position.","pos":[6760,6840]},{"content":"find","pos":[6846,6850]},{"content":"Searches a string in a forward direction for the first occurrence of a substring that matches a specified sequence of characters.","pos":[6873,7002]},{"content":"find_first_not_of","pos":[7008,7025]},{"content":"Searches through a string for the first character that is not any element of a specified string.","pos":[7061,7157]},{"content":"find_first_of","pos":[7163,7176]},{"content":"Searches through a string for the first character that matches any element of a specified string.","pos":[7208,7305]},{"content":"find_last_not_of","pos":[7311,7327]},{"content":"Searches through a string for the last character that is not any element of a specified string.","pos":[7362,7457]},{"content":"find_last_of","pos":[7463,7475]},{"content":"Searches through a string for the last character that is an element of a specified string.","pos":[7506,7596]},{"content":"front","pos":[7602,7607]},{"content":"Returns a reference to the first element in a string.","pos":[7631,7684]},{"content":"get_allocator","pos":[7690,7703]},{"pos":[7735,7805],"content":"Returns a copy of the <ph id=\"ph1\">`allocator`</ph> object used to construct the string.","source":"Returns a copy of the `allocator` object used to construct the string."},{"content":"insert","pos":[7811,7817]},{"content":"Inserts an element or a number of elements or a range of elements into the string at a specified position.","pos":[7842,7948]},{"content":"length","pos":[7954,7960]},{"content":"Returns the current number of elements in a string.","pos":[7985,8036]},{"content":"max_size","pos":[8042,8050]},{"content":"Returns the maximum number of characters a string could contain.","pos":[8077,8141]},{"content":"pop_back","pos":[8147,8155]},{"content":"Erases the last element of the string.","pos":[8182,8220]},{"content":"push_back","pos":[8226,8235]},{"content":"Adds an element to the end of the string.","pos":[8263,8304]},{"content":"rbegin","pos":[8310,8316]},{"content":"Returns an iterator to the first element in a reversed string.","pos":[8341,8403]},{"content":"rend","pos":[8409,8413]},{"content":"Returns an iterator that points just beyond the last element in a reversed string.","pos":[8436,8518]},{"content":"replace","pos":[8524,8531]},{"content":"Replaces elements in a string at a specified position with specified characters or characters copied from other ranges or strings or C-strings.","pos":[8557,8700]},{"content":"reserve","pos":[8706,8713]},{"content":"Sets the capacity of the string to a number at least as great as a specified number.","pos":[8739,8823]},{"content":"resize","pos":[8829,8835]},{"content":"Specifies a new size for a string, appending or erasing elements as required.","pos":[8860,8937]},{"content":"rfind","pos":[8943,8948]},{"content":"Searches a string in a backward direction for the first occurrence of a substring that matches a specified sequence of characters.","pos":[8972,9102]},{"content":"shrink_to_fit","pos":[9108,9121]},{"content":"Discards the excess capacity of the string.","pos":[9153,9196]},{"content":"size","pos":[9202,9206]},{"content":"Returns the current number of elements in a string.","pos":[9229,9280]},{"content":"substr","pos":[9286,9292]},{"content":"Copies a substring of at most some number of characters from a string beginning from a specified position.","pos":[9317,9423]},{"content":"swap","pos":[9429,9433]},{"content":"Exchange the contents of two strings.","pos":[9456,9493]},{"content":"Operators","pos":[9504,9513]},{"content":"operator+=","pos":[9535,9545]},{"content":"Appends characters to a string.","pos":[9579,9610]},{"content":"operator=","pos":[9616,9625]},{"content":"Assigns new character values to the contents of a string.","pos":[9655,9712]},{"content":"operator&amp;#91;&amp;#93;","pos":[9718,9736],"source":"operator&#91;&#93;"},{"content":"Provides a reference to the character with a specified index in a string.","pos":[9766,9839]},{"content":"Remarks","pos":[9849,9856]},{"pos":[9860,10088],"content":"If a function is asked to generate a sequence longer than <bpt id=\"p1\">[</bpt>max_size<ept id=\"p1\">](#basic_string__max_size)</ept> elements, the function reports a length error by throwing an object of type <bpt id=\"p2\">[</bpt>length_error<ept id=\"p2\">](../standard-library/length-error-class.md)</ept>.","source":"If a function is asked to generate a sequence longer than [max_size](#basic_string__max_size) elements, the function reports a length error by throwing an object of type [length_error](../standard-library/length-error-class.md)."},{"pos":[10095,10327],"content":"References, pointers, and iterators that designate elements of the controlled sequence can become invalid after any call to a function that alters the controlled sequence, or after the first call to a non- <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> member function.","source":"References, pointers, and iterators that designate elements of the controlled sequence can become invalid after any call to a function that alters the controlled sequence, or after the first call to a non- **const** member function."},{"content":"Requirements","pos":[10336,10348]},{"pos":[10352,10373],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>string&gt;","source":"**Header:** \\<string>"},{"pos":[10380,10398],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[10453,10481],"content":"basic_string::allocator_type"},{"content":"A type that represents the allocator class for a string object.","pos":[10485,10548]},{"content":"Remarks","pos":[10609,10616]},{"pos":[10620,10683],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Allocator<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **Allocator**."},{"content":"Example","pos":[10693,10700]},{"pos":[11166,11186],"content":"basic_string::append"},{"content":"Adds characters to the end of a string.","pos":[11190,11229]},{"content":"Parameters","pos":[12148,12158]},{"content":"The C-string to be appended.","pos":[12172,12200]},{"content":"The string whose characters are to be appended.","pos":[12217,12264]},{"content":"The index of the part of the source string supplying the characters to be appended.","pos":[12281,12364]},{"content":"The number of characters to be appended, at most, from the source string.","pos":[12383,12456]},{"content":"The character value to be appended.","pos":[12472,12507]},{"content":"An input iterator addressing the first element in the range to be appended.","pos":[12526,12601]},{"content":"An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the range to be appended.","pos":[12619,12758]},{"content":"Return Value","pos":[12768,12780]},{"content":"A reference to the string object that is being appended with the characters passed by the member function.","pos":[12784,12890]},{"content":"Remarks","pos":[12900,12907]},{"content":"Characters may be appended to a string using the <bpt id=\"p1\">[</bpt>operator+=<ept id=\"p1\">](#basic_string__operator_add_eq)</ept> or the member functions <bpt id=\"p2\">**</bpt>append<ept id=\"p2\">**</ept> or <bpt id=\"p3\">[</bpt>push_back<ept id=\"p3\">](#basic_string__push_back)</ept>.","pos":[12911,13081],"source":"Characters may be appended to a string using the [operator+=](#basic_string__operator_add_eq) or the member functions **append** or [push_back](#basic_string__push_back)."},{"content":"appends single-argument values while the multiple-argument <bpt id=\"p1\">**</bpt>append<ept id=\"p1\">**</ept> member function allows a specific part of a string to be specified for adding.","pos":[13095,13243],"source":" appends single-argument values while the multiple-argument **append** member function allows a specific part of a string to be specified for adding."},{"content":"Example","pos":[13253,13260]},{"pos":[16421,16441],"content":"basic_string::assign"},{"content":"Assigns new character values to the contents of a string.","pos":[16445,16502]},{"content":"Parameters","pos":[17412,17422]},{"content":"A pointer to the characters of the C-string to be assigned to the target string.","pos":[17436,17516]},{"content":"The number of characters to be appended, at most, from the source string.","pos":[17535,17608]},{"content":"The source string whose characters are to be assigned to the target string.","pos":[17625,17700]},{"content":"The character value to be assigned.","pos":[17716,17751]},{"content":"An input iterator, const_pointer, or const_iterator addressing the first character in the range of the source string to be assigned to the target range.","pos":[17770,17922]},{"content":"An input iterator, const_pointer, or const_iterator addressing the one beyond the last character in the range of the source string to be assigned to the target range.","pos":[17940,18106]},{"content":"The position at which new characters will start to be assigned.","pos":[18122,18185]},{"content":"Return Value","pos":[18195,18207]},{"content":"A reference to the string object that is being assigned new characters by the member function.","pos":[18211,18305]},{"content":"Remarks","pos":[18315,18322]},{"content":"The strings can be assigned new character values.","pos":[18326,18375]},{"content":"The new value can be either a string and C-string or a single character.","pos":[18376,18448]},{"content":"The <bpt id=\"p1\">[</bpt>operator=<ept id=\"p1\">](#basic_string__operator_eq)</ept> may be used if the new value can be described by a single parameter; otherwise the member function <bpt id=\"p2\">**</bpt>assign<ept id=\"p2\">**</ept>, which has multiple parameters, can be used to specify which part of the string is to be assigned to a target string.","pos":[18449,18720],"source":" The [operator=](#basic_string__operator_eq) may be used if the new value can be described by a single parameter; otherwise the member function **assign**, which has multiple parameters, can be used to specify which part of the string is to be assigned to a target string."},{"content":"Example","pos":[18730,18737]},{"pos":[22158,22174],"content":"basic_string::at"},{"content":"Provides a reference to the character with a specified index in a string.","pos":[22178,22251]},{"content":"Parameters","pos":[22351,22361]},{"content":"The index of the position of the element to be referenced.","pos":[22375,22433]},{"content":"Return Value","pos":[22443,22455]},{"content":"A reference to the character of the string at the position specified by the parameter index.","pos":[22459,22551]},{"content":"Remarks","pos":[22561,22568]},{"pos":[22572,22786],"content":"The first element of the string has an index of zero and the following elements are indexed consecutively by the positive integers, so that a string of length <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> has an <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept>th element indexed by the number <bpt id=\"p3\">*</bpt>n –<ept id=\"p3\">*</ept> 1.","source":"The first element of the string has an index of zero and the following elements are indexed consecutively by the positive integers, so that a string of length *n* has an *n*th element indexed by the number *n –* 1."},{"pos":[22793,22959],"content":"The member <bpt id=\"p1\">[</bpt>operator&amp;#91;&amp;#93;<ept id=\"p1\">](#basic_string__operator_at)</ept> is faster than the member function <bpt id=\"p2\">**</bpt>at<ept id=\"p2\">**</ept> for providing read and write access to the elements of a string.","source":"The member [operator&#91;&#93;](#basic_string__operator_at) is faster than the member function **at** for providing read and write access to the elements of a string."},{"content":"The member <ph id=\"ph1\">`operator[]`</ph> does not check whether the index passed as a parameter is valid but the member function <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> does and so should be used if the validity is not certain.","pos":[22966,23143],"source":"The member `operator[]` does not check whether the index passed as a parameter is valid but the member function **at** does and so should be used if the validity is not certain."},{"content":"An invalid index, which is an index less that zero or greater than or equal to the size of the string, passed to the member function <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> throws an <bpt id=\"p2\">[</bpt>out_of_range Class<ept id=\"p2\">](../standard-library/out-of-range-class.md)</ept> exception.","pos":[23144,23368],"source":" An invalid index, which is an index less that zero or greater than or equal to the size of the string, passed to the member function **at** throws an [out_of_range Class](../standard-library/out-of-range-class.md) exception."},{"content":"An invalid index passed to the <ph id=\"ph1\">`operator[]`</ph> results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null-character when passed this index.","pos":[23369,23594],"source":" An invalid index passed to the `operator[]` results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null-character when passed this index."},{"pos":[23601,23715],"content":"The reference returned may be invalidated by string reallocations or modifications for the non- <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> strings.","source":"The reference returned may be invalidated by string reallocations or modifications for the non- **const** strings."},{"content":"Example","pos":[23725,23732]},{"pos":[25080,25098],"content":"basic_string::back"},{"content":"Returns a reference to the last element in the string.","pos":[25102,25156]},{"content":"Return Value","pos":[25232,25244]},{"content":"A reference to the last element of the string, which must be non-empty.","pos":[25248,25319]},{"content":"Remarks","pos":[25329,25336]},{"pos":[25389,25415],"content":"basic_string::basic_string"},{"content":"Constructs a string that is empty, initialized by specific characters, or is a copy of all or part of another string object or C style (null-terminated) string.","pos":[25419,25579]},{"content":"Parameters","pos":[26799,26809]},{"content":"The C-string whose characters are to be used to initialize the <ph id=\"ph1\">`string`</ph> being constructed.","pos":[26823,26913],"source":" The C-string whose characters are to be used to initialize the `string` being constructed."},{"content":"This value cannot be a null pointer.","pos":[26914,26950]},{"content":"The storage allocator class for the string object being constructed.","pos":[26966,27034]},{"content":"The number of characters to be initialized.","pos":[27053,27096]},{"content":"The string to initialize the string being constructed.","pos":[27115,27169]},{"content":"The index of a character in a string that is the first to be used to initialize character values for the string being constructed.","pos":[27187,27317]},{"content":"The character value to be copied into the string being constructed.","pos":[27333,27400]},{"content":"An input iterator, const_pointer, or const_iterator addressing the first element in the source range to be inserted.","pos":[27419,27535]},{"content":"An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the source range to be inserted.","pos":[27553,27699]},{"content":"Return Value","pos":[27709,27721]},{"content":"A reference to the string object that is being constructed by the constructors.","pos":[27725,27804]},{"content":"Remarks","pos":[27814,27821]},{"content":"All constructors store an <bpt id=\"p1\">[</bpt>basic_string::allocator_type<ept id=\"p1\">](#basic_string__allocator_type)</ept> and initialize the controlled sequence.","pos":[27825,27952],"source":"All constructors store an [basic_string::allocator_type](#basic_string__allocator_type) and initialize the controlled sequence."},{"content":"The allocator object is the argument <ph id=\"ph1\">`al`</ph>, if present.","pos":[27953,28007],"source":" The allocator object is the argument `al`, if present."},{"content":"For the copy constructor, it is <ph id=\"ph1\">`right.`</ph><bpt id=\"p1\">[</bpt>basic_string::get_allocator<ept id=\"p1\">](#basic_string__get_allocator)</ept><ph id=\"ph2\">`()`</ph>.","pos":[28008,28112],"source":" For the copy constructor, it is `right.`[basic_string::get_allocator](#basic_string__get_allocator)`()`."},{"content":"Otherwise, it is <ph id=\"ph1\">`Alloc()`</ph>.","pos":[28113,28140],"source":" Otherwise, it is `Alloc()`."},{"content":"The controlled sequence is initialized to a copy of the operand sequence specified by the remaining operands.","pos":[28147,28256]},{"content":"A constructor without an operand sequence specifies an empty initial controlled sequence.","pos":[28257,28346]},{"content":"If <ph id=\"ph1\">`InputIterator`</ph> is an integer type in a template constructor, the operand sequence _F <ph id=\"ph2\">`irst,  last`</ph> behaves the same as <ph id=\"ph3\">`(size_type) first, (value_type) last`</ph>.","pos":[28347,28509],"source":" If `InputIterator` is an integer type in a template constructor, the operand sequence _F `irst,  last` behaves the same as `(size_type) first, (value_type) last`."},{"content":"Example","pos":[28519,28526]},{"pos":[30169,30188],"content":"basic_string::begin"},{"content":"Returns an iterator addressing the first element in the string.","pos":[30192,30255]},{"content":"Return Value","pos":[30331,30343]},{"content":"A random-access iterator that addresses the first element of the sequence or just beyond the end of an empty sequence.","pos":[30347,30465]},{"content":"Example","pos":[30475,30482]},{"pos":[31635,31654],"content":"basic_string::c_str"},{"content":"Converts the contents of a string as a C-style, null-terminated string.","pos":[31658,31729]},{"content":"Return Value","pos":[31787,31799]},{"content":"A pointer to the C-style version of the invoking string.","pos":[31803,31859]},{"content":"The pointer value is not valid after calling a non-const function, including the destructor, in the basic_string class on the object.","pos":[31861,31994]},{"content":"Remarks","pos":[32004,32011]},{"content":"Objects of type string belonging to the C++ template class basic_string<ph id=\"ph1\">\\&lt;</ph>char&gt; are not necessarily null terminated.","pos":[32015,32130],"source":"Objects of type string belonging to the C++ template class basic_string\\<char> are not necessarily null terminated."},{"content":"The null character ' \\0 ' is used as a special character in a C-string to mark the end of the string but has no special meaning in an object of type string and may be a part of the string just like any other character.","pos":[32131,32349]},{"content":"There is an automatic conversion from const <bpt id=\"p1\">**</bpt>char<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type <bpt id=\"p2\">**</bpt>basic_string<ph id=\"ph2\">\\&lt;</ph>char&gt;<ept id=\"p2\">**</ept>.","pos":[32350,32547],"source":" There is an automatic conversion from const **char\\*** into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type **basic_string\\<char>**."},{"content":"The returned C-style string should not be modified, as this could invalidate the pointer to the string, or deleted, as the string has a limited lifetime and is owned by the class string.","pos":[32554,32740]},{"content":"Example","pos":[32750,32757]},{"pos":[34049,34071],"content":"basic_string::capacity"},{"content":"Returns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.","pos":[34075,34202]},{"content":"Return Value","pos":[34255,34267]},{"content":"The size of storage currently allocated in memory to hold the string.","pos":[34271,34340]},{"content":"Remarks","pos":[34350,34357]},{"pos":[34361,34511],"content":"The member function returns the storage currently allocated to hold the controlled sequence, a value at least as large as <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#basic_string__size)</ept>.","source":"The member function returns the storage currently allocated to hold the controlled sequence, a value at least as large as [size](#basic_string__size)."},{"content":"Example","pos":[34521,34528]},{"pos":[36373,36393],"content":"basic_string::cbegin"},{"pos":[36397,36470],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the first element in the range.","source":"Returns a `const` iterator that addresses the first element in the range."},{"content":"Return Value","pos":[36526,36538]},{"pos":[36542,36719],"content":"A <ph id=\"ph1\">`const`</ph> random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, <ph id=\"ph2\">`cbegin() == cend()`</ph>).","source":"A `const` random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`)."},{"content":"Remarks","pos":[36729,36736]},{"pos":[36740,36820],"content":"With the return value of <ph id=\"ph1\">`cbegin`</ph>, the elements in the range cannot be modified.","source":"With the return value of `cbegin`, the elements in the range cannot be modified."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`begin()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[36827,36957],"source":"You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[36958,37088],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`begin()`</ph> and <ph id=\"ph4\">`cbegin()`</ph>.","pos":[37089,37221],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`."},{"pos":[37421,37439],"content":"basic_string::cend"},{"pos":[37443,37538],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the location just beyond the last element in a range.","source":"Returns a `const` iterator that addresses the location just beyond the last element in a range."},{"content":"Return Value","pos":[37592,37604]},{"pos":[37608,37686],"content":"A <ph id=\"ph1\">`const`</ph> random-access iterator that points just beyond the end of the range.","source":"A `const` random-access iterator that points just beyond the end of the range."},{"content":"Remarks","pos":[37696,37703]},{"pos":[37714,37782],"content":"is used to test whether an iterator has passed the end of its range."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`end()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[37789,37917],"source":"You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[37918,38048],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`end()`</ph> and <ph id=\"ph4\">`cend()`</ph>.","pos":[38049,38177],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`."},{"pos":[38335,38391],"content":"The value returned by <ph id=\"ph1\">`cend`</ph> should not be dereferenced.","source":"The value returned by `cend` should not be dereferenced."},{"pos":[38437,38456],"content":"basic_string::clear"},{"content":"Erases all elements of a string.","pos":[38460,38492]},{"content":"Remarks","pos":[38531,38538]},{"content":"The string on which the member function is called will be empty.","pos":[38542,38606]},{"content":"Example","pos":[38616,38623]},{"pos":[39703,39724],"content":"basic_string::compare"},{"content":"Performs a case sensitive comparison with a specified string to determine if the two strings are equal or if one is lexicographically less than the other.","pos":[39728,39882]},{"content":"Parameters","pos":[40551,40561]},{"content":"The string that is to be compared to the operand string.","pos":[40575,40631]},{"content":"The index of the operand string at which the comparison begins.","pos":[40649,40712]},{"content":"The maximum number of characters from the operand string to be compared.","pos":[40730,40802]},{"content":"The maximum number of characters from the parameter string to be compared.","pos":[40820,40894]},{"content":"The index of the parameter string at which the comparison begins.","pos":[40911,40976]},{"content":"The maximum number of characters from the parameter string to be compared.","pos":[40995,41069]},{"content":"The C-string to be compared to the operand string.","pos":[41086,41136]},{"content":"Return Value","pos":[41146,41158]},{"content":"A negative value if the operand string is less than the parameter string; zero if the two strings are equal; or a positive value if the operand string is greater than the parameter string.","pos":[41162,41350]},{"content":"Remarks","pos":[41360,41367]},{"pos":[41371,41495],"content":"The <bpt id=\"p1\">**</bpt>compare<ept id=\"p1\">**</ept> member functions compare either all or part of the parameter and operand strings depending on which in used.","source":"The **compare** member functions compare either all or part of the parameter and operand strings depending on which in used."},{"content":"The comparison performed is case sensitive.","pos":[41502,41545]},{"content":"Example","pos":[41555,41562]},{"pos":[48678,48706],"content":"basic_string::const_iterator"},{"pos":[48710,48815],"content":"A type that provides a random-access iterator that can access and read a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in the string.","source":"A type that provides a random-access iterator that can access and read a **const** element in the string."},{"content":"Remarks","pos":[48889,48896]},{"pos":[48900,49037],"content":"A type <ph id=\"ph1\">`const_iterator`</ph> cannot be used to modify the value of a character and is used to iterate through a string in a forward direction.","source":"A type `const_iterator` cannot be used to modify the value of a character and is used to iterate through a string in a forward direction."},{"content":"Example","pos":[49047,49054]},{"pos":[49059,49167],"content":"See the example for <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#basic_string__begin)</ept> for an example of how to declare and use <ph id=\"ph1\">`const_iterator`</ph>.","source":"See the example for [begin](#basic_string__begin) for an example of how to declare and use `const_iterator`."},{"pos":[49221,49248],"content":"basic_string::const_pointer"},{"pos":[49252,49318],"content":"A type that provides a pointer to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in a string.","source":"A type that provides a pointer to a **const** element in a string."},{"content":"Remarks","pos":[49407,49414]},{"pos":[49418,49478],"content":"The type is a synonym for <bpt id=\"p1\">**</bpt>allocator_type::const_pointer<ept id=\"p1\">**</ept>.","source":"The type is a synonym for **allocator_type::const_pointer**."},{"pos":[49485,49534],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <ph id=\"ph1\">`char`</ph>*.","source":"For type **string**, it is equivalent to `char`*."},{"content":"Pointers that are declared const must be initialized when they are declared.","pos":[49541,49617]},{"content":"Const pointers always point to the same memory location and may point to constant or nonconstant data.","pos":[49618,49720]},{"content":"Example","pos":[49730,49737]},{"pos":[50285,50314],"content":"basic_string::const_reference"},{"pos":[50318,50441],"content":"A type that provides a reference to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element stored in a string for reading and performing <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> operations.","source":"A type that provides a reference to a **const** element stored in a string for reading and performing **const** operations."},{"content":"Remarks","pos":[50534,50541]},{"pos":[50545,50619],"content":"A type <ph id=\"ph1\">`const_reference`</ph> cannot be used to modify the value of an element.","source":"A type `const_reference` cannot be used to modify the value of an element."},{"content":"The type is a synonym for <bpt id=\"p1\">**</bpt>allocator_type::const_reference<ept id=\"p1\">**</ept>.","pos":[50626,50688],"source":"The type is a synonym for **allocator_type::const_reference**."},{"content":"For string <bpt id=\"p1\">**</bpt>type<ept id=\"p1\">**</ept>, it is equivalent to const <bpt id=\"p2\">**</bpt>char&amp;<ept id=\"p2\">**</ept>.","pos":[50689,50746],"source":" For string **type**, it is equivalent to const **char&**."},{"content":"Example","pos":[50756,50763]},{"pos":[50768,50871],"content":"See the example for <bpt id=\"p1\">[</bpt>at<ept id=\"p1\">](#basic_string__at)</ept> for an example of how to declare and use <ph id=\"ph1\">`const_reference`</ph>.","source":"See the example for [at](#basic_string__at) for an example of how to declare and use `const_reference`."},{"pos":[50934,50970],"content":"basic_string::const_reverse_iterator"},{"pos":[50974,51070],"content":"A type that provides a random-access iterator that can read any <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in the string.","source":"A type that provides a random-access iterator that can read any **const** element in the string."},{"content":"Remarks","pos":[51167,51174]},{"pos":[51178,51300],"content":"A type <ph id=\"ph1\">`const_reverse_iterator`</ph> cannot modify the value of a character and is used to iterate through a string in reverse.","source":"A type `const_reverse_iterator` cannot modify the value of a character and is used to iterate through a string in reverse."},{"content":"Example","pos":[51310,51317]},{"pos":[51322,51440],"content":"See the example for <bpt id=\"p1\">[</bpt>rbegin<ept id=\"p1\">](#basic_string__rbegin)</ept> for an example of how to declare and use <ph id=\"ph1\">`const_reverse_iterator`</ph>.","source":"See the example for [rbegin](#basic_string__rbegin) for an example of how to declare and use `const_reverse_iterator`."},{"pos":[51485,51503],"content":"basic_string::copy"},{"content":"Copies at most a specified number of characters from an indexed position in a source string to a target character array.","pos":[51507,51627]},{"content":"This method is potentially unsafe, as it relies on the caller to check that the passed values are correct.","pos":[51634,51740]},{"content":"Consider using <bpt id=\"p1\">[</bpt>basic_string::_Copy_s<ept id=\"p1\">](#basic_string___copy_s)</ept> instead.","pos":[51741,51812],"source":" Consider using [basic_string::_Copy_s](#basic_string___copy_s) instead."},{"content":"Parameters","pos":[51931,51941]},{"content":"The target character array to which the elements are to be copied.","pos":[51955,52021]},{"content":"_","pos":[52028,52029]},{"content":"The number of characters to be copied, at most, from the source string.","pos":[52041,52112]},{"content":"The beginning position in the source string from which copies are to be made.","pos":[52129,52206]},{"content":"Return Value","pos":[52216,52228]},{"content":"The number of characters actually copied.","pos":[52232,52273]},{"content":"Remarks","pos":[52283,52290]},{"content":"A null character is not appended to the end of the copy.","pos":[52294,52350]},{"content":"Example","pos":[52360,52367]},{"pos":[54000,54021],"content":"basic_string::crbegin"},{"content":"Returns a const iterator that addresses the first element in a reversed string.","pos":[54025,54104]},{"content":"Return Value","pos":[54169,54181]},{"content":"A reverse iterator that points just beyond the end of the string.","pos":[54185,54250]},{"content":"The position designates the beginning of the reverse string.","pos":[54251,54311]},{"pos":[54357,54376],"content":"basic_string::crend"},{"content":"Returns a const iterator that addresses the location succeeding the last element in a reversed string.","pos":[54380,54482]},{"content":"Return Value","pos":[54545,54557]},{"content":"A const reverse iterator that addresses the location succeeding the last element in a reversed string (the location that had preceded the first element in the unreversed string).","pos":[54561,54739]},{"content":"Remarks","pos":[54749,54756]},{"pos":[54804,54825],"content":"basic_string::_Copy_s"},{"content":"Copies at most a specified number of characters from an indexed position in a source string to a target character array.","pos":[54829,54949]},{"content":"Parameters","pos":[55098,55108]},{"content":"The target character array to which the elements are to be copied.","pos":[55123,55189]},{"content":"The size of <ph id=\"ph1\">` dest`</ph>.","pos":[55212,55232],"source":" The size of ` dest`."},{"content":"_","pos":[55239,55240]},{"content":"The number of characters to be copied, at most, from the source string.","pos":[55252,55323]},{"content":"The beginning position in the source string from which copies are to be made.","pos":[55340,55417]},{"content":"Return Value","pos":[55427,55439]},{"content":"The number of characters actually copied.","pos":[55443,55484]},{"content":"Remarks","pos":[55494,55501]},{"content":"A null character is not appended to the end of the copy.","pos":[55505,55561]},{"content":"Example","pos":[55571,55578]},{"pos":[57099,57117],"content":"basic_string::data"},{"content":"Converts the contents of a string into an array of characters.","pos":[57121,57183]},{"content":"Return Value","pos":[57240,57252]},{"content":"A pointer to the first element of the array containing the contents of the string, or, for an empty array, a non-null pointer that cannot be dereferenced.","pos":[57256,57410]},{"content":"Remarks","pos":[57420,57427]},{"content":"Objects of type string belonging to the C++ template class basic_string <ph id=\"ph1\">\\&lt;</ph>char&gt; are not necessarily null terminated.","pos":[57431,57547],"source":"Objects of type string belonging to the C++ template class basic_string \\<char> are not necessarily null terminated."},{"content":"The return type for <bpt id=\"p1\">**</bpt>data<ept id=\"p1\">**</ept> is not a valid C-string, because no null character gets appended.","pos":[57548,57642],"source":" The return type for **data** is not a valid C-string, because no null character gets appended."},{"content":"The null character ' \\0 ' is used as a special character in a C-string to mark the end of the string, but has no special meaning in an object of type string and may be a part of the string object just like any other character.","pos":[57643,57869]},{"pos":[57876,58074],"content":"There is an automatic conversion from const <bpt id=\"p1\">**</bpt>char<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type <bpt id=\"p2\">**</bpt>basic_string <ph id=\"ph2\">\\&lt;</ph>char&gt;<ept id=\"p2\">**</ept>.","source":"There is an automatic conversion from const **char\\*** into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type **basic_string \\<char>**."},{"content":"The returned string should not be modified, because this could invalidate the pointer to the string, or deleted, because the string has a limited lifetime and is owned by the class string.","pos":[58081,58269]},{"content":"Example","pos":[58279,58286]},{"pos":[59583,59612],"content":"basic_string::difference_type"},{"content":"A type that provides the difference between two iterators that refer to elements within the same string.","pos":[59616,59720]},{"content":"Remarks","pos":[59813,59820]},{"content":"The signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence.","pos":[59824,59971]},{"pos":[59978,60033],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <bpt id=\"p2\">**</bpt>ptrdiff_t<ept id=\"p2\">**</ept>.","source":"For type **string**, it is equivalent to **ptrdiff_t**."},{"content":"Example","pos":[60043,60050]},{"pos":[61006,61025],"content":"basic_string::empty"},{"content":"Tests whether the string contains characters or not.","pos":[61029,61081]},{"content":"Return Value","pos":[61126,61138]},{"pos":[61142,61239],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object contains no characters; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if it has at least one character.","source":"**true** if the string object contains no characters; **false** if it has at least one character."},{"content":"Remarks","pos":[61249,61256]},{"pos":[61260,61330],"content":"The member function is equivalent to <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#basic_string__size)</ept> == 0.","source":"The member function is equivalent to [size](#basic_string__size) == 0."},{"content":"Example","pos":[61340,61347]},{"pos":[62106,62123],"content":"basic_string::end"},{"content":"Returns an iterator that addresses the location succeeding the last element in a string.","pos":[62127,62215]},{"content":"Return Value","pos":[62287,62299]},{"content":"Returns a random-access iterator that addresses the location succeeding the last element in a string.","pos":[62303,62404]},{"content":"Remarks","pos":[62414,62421]},{"content":"<bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> is often used to test whether an iterator has reached the end of its string.","pos":[62425,62509],"source":"**end** is often used to test whether an iterator has reached the end of its string."},{"content":"The value returned by <bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> should not be dereferenced.","pos":[62510,62567],"source":" The value returned by **end** should not be dereferenced."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_iterator`</ph>, the string object cannot be modified.","pos":[62574,62677],"source":"If the return value of **end** is assigned to a `const_iterator`, the string object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> is assigned to an <bpt id=\"p2\">**</bpt>iterator<ept id=\"p2\">**</ept>, the string object can be modified.","pos":[62678,62775],"source":" If the return value of **end** is assigned to an **iterator**, the string object can be modified."},{"content":"Example","pos":[62785,62792]},{"pos":[64495,64514],"content":"basic_string::erase"},{"content":"Removes an element or a range of elements in a string from a specified position.","pos":[64518,64598]},{"content":"Parameters","pos":[64824,64834]},{"content":"An iterator addressing the position of the first element in the range to be erased.","pos":[64850,64933]},{"content":"An iterator addressing the position one past the last element in the range to be erased.","pos":[64951,65039]},{"content":"An iterator addressing the position of the element in the string to be erased.","pos":[65055,65133]},{"content":"The index of the first character in the string to be removed.","pos":[65150,65211]},{"content":"The number of elements that will be removed if there are as many in the range of the string beginning with <bpt id=\"p1\">*</bpt>_Pos<ept id=\"p1\">*</ept>.","pos":[65230,65344],"source":" The number of elements that will be removed if there are as many in the range of the string beginning with *_Pos*."},{"content":"Return Value","pos":[65354,65366]},{"content":"For the first two member functions, an iterator addressing the first character after the last character removed by the member function.","pos":[65370,65505]},{"content":"For the third member function, a reference to the string object from which the elements have been erased.","pos":[65506,65611]},{"content":"Remarks","pos":[65621,65628]},{"pos":[65632,65677],"content":"The third member function returns <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>.","source":"The third member function returns **\\*this**."},{"content":"Example","pos":[65687,65694]},{"pos":[67723,67741],"content":"basic_string::find"},{"content":"Searches a string in a forward direction for the first occurrence of a substring that matches a specified sequence of characters.","pos":[67745,67874]},{"content":"Parameters","pos":[68257,68267]},{"content":"The character value for which the member function is to search.","pos":[68280,68343]},{"content":"Index of the position at which the search is to begin.","pos":[68360,68414]},{"content":"The C-string for which the member function is to search.","pos":[68431,68487]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[68506,68634]},{"content":"The string for which the member function is to search.","pos":[68651,68705]},{"content":"Return Value","pos":[68715,68727]},{"pos":[68731,68828],"content":"The index of the first character of the substring searched for when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the first character of the substring searched for when successful; otherwise `npos`."},{"content":"Example","pos":[68838,68845]},{"pos":[73669,73700],"content":"basic_string::find_first_not_of"},{"content":"Searches through a string for the first character that is not an element of a specified string.","pos":[73704,73799]},{"content":"Parameters","pos":[74234,74244]},{"content":"The character value for which the member function is to search.","pos":[74257,74320]},{"content":"Index of the position at which the search is to begin.","pos":[74337,74391]},{"content":"The C-string for which the member function is to search.","pos":[74408,74464]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[74483,74611]},{"content":"The string for which the member function is to search.","pos":[74628,74682]},{"content":"Return Value","pos":[74692,74704]},{"pos":[74708,74805],"content":"The index of the first character of the substring searched for when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the first character of the substring searched for when successful; otherwise `npos`."},{"content":"Example","pos":[74815,74822]},{"pos":[80226,80253],"content":"basic_string::find_first_of"},{"content":"Searches through a string for the first character that matches any element of a specified string.","pos":[80257,80354]},{"content":"Parameters","pos":[80773,80783]},{"content":"The character value for which the member function is to search.","pos":[80796,80859]},{"content":"Index of the position at which the search is to begin.","pos":[80876,80930]},{"content":"The C-string for which the member function is to search.","pos":[80947,81003]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[81022,81150]},{"content":"The string for which the member function is to search.","pos":[81167,81221]},{"content":"Return Value","pos":[81231,81243]},{"pos":[81247,81344],"content":"The index of the first character of the substring searched for when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the first character of the substring searched for when successful; otherwise `npos`."},{"content":"Example","pos":[81354,81361]},{"pos":[86828,86858],"content":"basic_string::find_last_not_of"},{"content":"Searches through a string for the last character that is not any element of a specified string.","pos":[86862,86957]},{"content":"Parameters","pos":[87397,87407]},{"content":"The character value for which the member function is to search.","pos":[87420,87483]},{"content":"Index of the position at which the search is to finish.","pos":[87500,87555]},{"content":"The C-string for which the member function is to search.","pos":[87572,87628]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[87647,87775]},{"content":"The string for which the member function is to search.","pos":[87792,87846]},{"content":"Return Value","pos":[87856,87868]},{"pos":[87872,87969],"content":"The index of the first character of the substring searched for when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the first character of the substring searched for when successful; otherwise `npos`."},{"content":"Example","pos":[87979,87986]},{"pos":[93396,93422],"content":"basic_string::find_last_of"},{"content":"Searches through a string for the last character that matches any element of a specified string.","pos":[93426,93522]},{"content":"Parameters","pos":[93952,93962]},{"content":"The character value for which the member function is to search.","pos":[93975,94038]},{"content":"Index of the position at which the search is to finish.","pos":[94055,94110]},{"content":"The C-string for which the member function is to search.","pos":[94127,94183]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[94202,94330]},{"content":"The string for which the member function is to search.","pos":[94347,94401]},{"content":"Return Value","pos":[94411,94423]},{"pos":[94427,94523],"content":"The index of the last character of the substring searched for when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the last character of the substring searched for when successful; otherwise `npos`."},{"content":"Example","pos":[94533,94540]},{"pos":[99378,99397],"content":"basic_string::front"},{"content":"Returns a reference to the first element in a string.","pos":[99401,99454]},{"content":"Return Value","pos":[99532,99544]},{"content":"A reference to the first element of the string, which must be non-empty.","pos":[99548,99620]},{"content":"Remarks","pos":[99630,99637]},{"pos":[99691,99718],"content":"basic_string::get_allocator"},{"content":"Returns a copy of the allocator object used to construct the string.","pos":[99722,99790]},{"content":"Return Value","pos":[99853,99865]},{"content":"The allocator used by the string.","pos":[99869,99902]},{"content":"Remarks","pos":[99912,99919]},{"content":"The member function returns the stored allocator object.","pos":[99923,99979]},{"content":"Allocators for the string class specify how the class manages storage.","pos":[99986,100056]},{"content":"The default allocators supplied with container classes are sufficient for most programming needs.","pos":[100057,100154]},{"content":"Writing and using your own allocator class is an advanced C++ topic.","pos":[100155,100223]},{"content":"Example","pos":[100233,100240]},{"pos":[100914,100934],"content":"basic_string::insert"},{"content":"Inserts an element or a number of elements or a range of elements into the string at a specified position.","pos":[100938,101044]},{"content":"Parameters","pos":[102196,102206]},{"content":"_P0","pos":[102211,102214]},{"content":"The index of the position behind the point of insertion the new characters.","pos":[102219,102294]},{"content":"The C-string to be wholly or partly inserted into the string.","pos":[102311,102372]},{"content":"The number of characters to be inserted.","pos":[102391,102431]},{"content":"The string to be wholly or partly inserted into the target string.","pos":[102448,102514]},{"content":"The index of the part of the source string supplying the characters to be appended.","pos":[102531,102614]},{"content":"The character value of the elements to be inserted.","pos":[102630,102681]},{"content":"An iterator addressing the position behind which a character is to be inserted.","pos":[102697,102776]},{"content":"An input iterator, const_pointer, or const_iterator addressing the first element in the source range to be inserted.","pos":[102795,102911]},{"content":"An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the source range to be inserted.","pos":[102929,103075]},{"content":"Return Value","pos":[103085,103097]},{"content":"Either a reference to the string object that is being assigned new characters by the member function or, in the case of individual character insertions, an iterator addressing the position of the character inserted, or none, depending on the particular member function.","pos":[103101,103370]},{"content":"Example","pos":[103380,103387]},{"pos":[106757,106779],"content":"basic_string::iterator"},{"pos":[106783,106888],"content":"A type that provides a random-access iterator that can access and read a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in the string.","source":"A type that provides a random-access iterator that can access and read a **const** element in the string."},{"content":"Remarks","pos":[106956,106963]},{"pos":[106967,107097],"content":"A type <bpt id=\"p1\">**</bpt>iterator<ept id=\"p1\">**</ept> can be used to modify the value of a character and is used to iterate through a string in a forward direction.","source":"A type **iterator** can be used to modify the value of a character and is used to iterate through a string in a forward direction."},{"content":"Example","pos":[107107,107114]},{"pos":[107119,107223],"content":"See the example for <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#basic_string__begin)</ept> for an example of how to declare and use <bpt id=\"p2\">**</bpt>iterator<ept id=\"p2\">**</ept>.","source":"See the example for [begin](#basic_string__begin) for an example of how to declare and use **iterator**."},{"pos":[107270,107290],"content":"basic_string::length"},{"content":"Returns the current number of elements in a string.","pos":[107294,107345]},{"content":"Remarks","pos":[107396,107403]},{"pos":[107407,107470],"content":"The member function is the same as <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#basic_string__size)</ept>.","source":"The member function is the same as [size](#basic_string__size)."},{"content":"Example","pos":[107480,107487]},{"pos":[109327,109349],"content":"basic_string::max_size"},{"content":"Returns the maximum number of characters a string could contain.","pos":[109353,109417]},{"content":"Return Value","pos":[109470,109482]},{"content":"The maximum number of characters a string could contain.","pos":[109486,109542]},{"content":"Remarks","pos":[109552,109559]},{"pos":[109563,109737],"content":"A exception of type <bpt id=\"p1\">[</bpt>length_error Class<ept id=\"p1\">](../standard-library/length-error-class.md)</ept> is thrown when an operation produces a string with a length greater than the maximum size.","source":"A exception of type [length_error Class](../standard-library/length-error-class.md) is thrown when an operation produces a string with a length greater than the maximum size."},{"content":"Example","pos":[109747,109754]},{"pos":[111592,111610],"content":"basic_string::npos"},{"content":"An unsigned integral value initialized to –1 that indicates either \"not found\" or \"all remaining characters\" when a search function fails.","pos":[111614,111752]},{"content":"Remarks","pos":[111813,111820]},{"pos":[111824,112011],"content":"When the return value is to be checked for the <ph id=\"ph1\">`npos`</ph> value, it might not work unless the return value is of type <bpt id=\"p1\">[</bpt>size_type<ept id=\"p1\">](#basic_string__size_type)</ept> and not either <ph id=\"ph2\">`int`</ph> or <ph id=\"ph3\">`unsigned`</ph>.","source":"When the return value is to be checked for the `npos` value, it might not work unless the return value is of type [size_type](#basic_string__size_type) and not either `int` or `unsigned`."},{"content":"Example","pos":[112021,112028]},{"pos":[112033,112129],"content":"See the example for <bpt id=\"p1\">[</bpt>find<ept id=\"p1\">](#basic_string__find)</ept> for an example of how to declare and use <ph id=\"ph1\">`npos`</ph>.","source":"See the example for [find](#basic_string__find) for an example of how to declare and use `npos`."},{"pos":[112185,112209],"content":"basic_string::operator+="},{"content":"Appends characters to a string.","pos":[112213,112244]},{"content":"Parameters","pos":[112546,112556]},{"content":"The character to be appended.","pos":[112569,112598]},{"content":"The characters of the C-string to be appended.","pos":[112615,112661]},{"content":"The characters of the string to be appended.","pos":[112680,112724]},{"content":"Return Value","pos":[112734,112746]},{"content":"A reference to the string object that is being appended with the characters passed by the member function.","pos":[112750,112856]},{"content":"Remarks","pos":[112866,112873]},{"content":"Characters may be appended to a string using the <ph id=\"ph1\">`operator+=`</ph> or the member functions <bpt id=\"p1\">[</bpt>append<ept id=\"p1\">](#basic_string__append)</ept> or <bpt id=\"p2\">[</bpt>push_back<ept id=\"p2\">](#basic_string__push_back)</ept>.","pos":[112877,113036],"source":"Characters may be appended to a string using the `operator+=` or the member functions [append](#basic_string__append) or [push_back](#basic_string__push_back)."},{"content":"The <ph id=\"ph1\">`operator+=`</ph> appends single-argument values while the multiple argument append member function allows a specific part of a string to be specified for adding.","pos":[113037,113198],"source":" The `operator+=` appends single-argument values while the multiple argument append member function allows a specific part of a string to be specified for adding."},{"content":"Example","pos":[113208,113215]},{"pos":[114923,114946],"content":"basic_string::operator="},{"content":"Assigns new character values to the contents of a string.","pos":[114950,115007]},{"content":"Parameters","pos":[115423,115433]},{"content":"The character value to be assigned.","pos":[115446,115481]},{"content":"A pointer to the characters of the C-string to be assigned to the target string.","pos":[115498,115578]},{"content":"The source string whose characters are to be assigned to the target string.","pos":[115597,115672]},{"content":"Return Value","pos":[115682,115694]},{"content":"A reference to the string object that is being assigned new characters by the member function.","pos":[115698,115792]},{"content":"Remarks","pos":[115802,115809]},{"content":"The strings may be assigned new character values.","pos":[115813,115862]},{"content":"The new value may be either a string and C-string or a single character.","pos":[115863,115935]},{"content":"The <ph id=\"ph1\">`operator=`</ph> may be used if the new value can be described by a single parameter, otherwise the member function <bpt id=\"p1\">[</bpt>assign<ept id=\"p1\">](#basic_string__assign)</ept>, which has multiple parameters, may be used to specify which part of the string is to be assigned to a target string.","pos":[115936,116200],"source":" The `operator=` may be used if the new value can be described by a single parameter, otherwise the member function [assign](#basic_string__assign), which has multiple parameters, may be used to specify which part of the string is to be assigned to a target string."},{"content":"Example","pos":[116210,116217]},{"pos":[118147,118171],"content":"basic_string::operator[]"},{"content":"Provides a reference to the character with a specified index in a string.","pos":[118175,118248]},{"content":"Parameters","pos":[118364,118374]},{"content":"The index of the position of the element to be referenced.","pos":[118388,118446]},{"content":"Return Value","pos":[118456,118468]},{"content":"A reference to the character of the string at the position specified by the parameter index.","pos":[118472,118564]},{"content":"Remarks","pos":[118574,118581]},{"pos":[118585,118800],"content":"The first element of the string has an index of zero, and the following elements are indexed consecutively by the positive integers, so that a string of length <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> has an <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept>th element indexed by the number <bpt id=\"p3\">*</bpt>n<ept id=\"p3\">*</ept> - 1.","source":"The first element of the string has an index of zero, and the following elements are indexed consecutively by the positive integers, so that a string of length *n* has an *n*th element indexed by the number *n* - 1."},{"pos":[118820,118943],"content":"is faster than the member function <bpt id=\"p1\">[</bpt>at<ept id=\"p1\">](#basic_string__at)</ept> for providing read and write access to the elements of a string.","source":" is faster than the member function [at](#basic_string__at) for providing read and write access to the elements of a string."},{"content":"does not check whether the index passed as a parameter is valid, but the member function <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> does and so should be used in the validity is not certain.","pos":[118963,119117],"source":" does not check whether the index passed as a parameter is valid, but the member function **at** does and so should be used in the validity is not certain."},{"content":"An invalid index (an index less that zero or greater than or equal to the size of the string) passed to the member function <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> throws an <bpt id=\"p2\">[</bpt>out_of_range Class<ept id=\"p2\">](../standard-library/out-of-range-class.md)</ept> exception.","pos":[119118,119333],"source":" An invalid index (an index less that zero or greater than or equal to the size of the string) passed to the member function **at** throws an [out_of_range Class](../standard-library/out-of-range-class.md) exception."},{"content":"An invalid index passed to <ph id=\"ph1\">`operator[]`</ph> results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null character when passed this index.","pos":[119334,119555],"source":" An invalid index passed to `operator[]` results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null character when passed this index."},{"pos":[119562,119676],"content":"The reference returned may be invalidated by string reallocations or modifications for the non- <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> strings.","source":"The reference returned may be invalidated by string reallocations or modifications for the non- **const** strings."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element outside the bounds of the string.","pos":[119683,119814]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[119816,119903],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[119913,119920]},{"pos":[121277,121298],"content":"basic_string::pointer"},{"content":"A type that provides a pointer to a character element in a string or character array.","pos":[121302,121387]},{"content":"Remarks","pos":[121464,121471]},{"pos":[121475,121529],"content":"The type is a synonym for <bpt id=\"p1\">**</bpt>allocator_type::pointer<ept id=\"p1\">**</ept>.","source":"The type is a synonym for **allocator_type::pointer**."},{"pos":[121536,121588],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <bpt id=\"p2\">**</bpt>char<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>.","source":"For type **string**, it is equivalent to **char\\***."},{"content":"Example","pos":[121598,121605]},{"pos":[122129,122151],"content":"basic_string::pop_back"},{"content":"Erases the last element of the string.","pos":[122155,122193]},{"content":"Remarks","pos":[122235,122242]},{"pos":[122246,122372],"content":"This member function effectively calls <ph id=\"ph1\">`erase(size() - 1)`</ph> to erase the last element of the sequence, which must be non-empty.","source":"This member function effectively calls `erase(size() - 1)` to erase the last element of the sequence, which must be non-empty."},{"pos":[122422,122445],"content":"basic_string::push_back"},{"content":"Adds an element to the end of the string.","pos":[122449,122490]},{"content":"Parameters","pos":[122547,122557]},{"content":"The character to be added to the end of the string.","pos":[122570,122621]},{"content":"Remarks","pos":[122631,122638]},{"pos":[122642,122749],"content":"The member function effectively calls <bpt id=\"p1\">[</bpt>insert<ept id=\"p1\">](#basic_string__insert)</ept>( <bpt id=\"p2\">[</bpt>end<ept id=\"p2\">](#basic_string__end)</ept>, _ <bpt id=\"p3\">*</bpt>Ch<ept id=\"p3\">*</ept> ).","source":"The member function effectively calls [insert](#basic_string__insert)( [end](#basic_string__end), _ *Ch* )."},{"content":"Example","pos":[122759,122766]},{"pos":[123744,123764],"content":"basic_string::rbegin"},{"content":"Returns an iterator to the first element in a reversed string.","pos":[123768,123830]},{"content":"Return Value","pos":[123924,123936]},{"content":"Returns a random-access iterator to the first element in a reversed string, addressing what would be the last element in the corresponding unreversed string.","pos":[123940,124097]},{"content":"Remarks","pos":[124107,124114]},{"pos":[124127,124218],"content":"is used with a reversed string just as <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#basic_string__begin)</ept> is used with a string.","source":" is used with a reversed string just as [begin](#basic_string__begin) is used with a string."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the string object cannot be modified.","pos":[124225,124337],"source":"If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the string object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the string object can be modified.","pos":[124338,124441],"source":" If the return value of `rbegin` is assigned to a `reverse_iterator`, the string object can be modified."},{"pos":[124457,124523],"content":"can be used to initialize an iteration through a string backwards."},{"content":"Example","pos":[124533,124540]},{"pos":[126332,126355],"content":"basic_string::reference"},{"content":"A type that provides a reference to an element stored in a string.","pos":[126359,126425]},{"content":"Remarks","pos":[126506,126513]},{"pos":[126517,126584],"content":"A type <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept> can be used to modify the value of an element.","source":"A type **reference** can be used to modify the value of an element."},{"pos":[126591,126647],"content":"The type is a synonym for <bpt id=\"p1\">**</bpt>allocator_type::reference<ept id=\"p1\">**</ept>.","source":"The type is a synonym for **allocator_type::reference**."},{"pos":[126654,126704],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <bpt id=\"p2\">**</bpt>chr&amp;<ept id=\"p2\">**</ept>.","source":"For type **string**, it is equivalent to **chr&**."},{"content":"Example","pos":[126714,126721]},{"pos":[126726,126825],"content":"See the example for <bpt id=\"p1\">[</bpt>at<ept id=\"p1\">](#basic_string__at)</ept> for an example of how to declare and use <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>.","source":"See the example for [at](#basic_string__at) for an example of how to declare and use **reference**."},{"pos":[126870,126888],"content":"basic_string::rend"},{"content":"Returns an iterator that addresses the location succeeding the last element in a reversed string.","pos":[126892,126989]},{"content":"Return Value","pos":[127079,127091]},{"content":"A reverse random-access iterator that addresses the location succeeding the last element in a reversed string.","pos":[127095,127205]},{"content":"Remarks","pos":[127215,127222]},{"pos":[127233,127320],"content":"is used with a reversed string just as <bpt id=\"p1\">[</bpt>end<ept id=\"p1\">](#basic_string__end)</ept> is used with a string.","source":" is used with a reversed string just as [end](#basic_string__end) is used with a string."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the string object cannot be modified.","pos":[127327,127437],"source":"If the return value of `rend` is assigned to a `const_reverse_iterator`, the string object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the string object can be modified.","pos":[127438,127539],"source":" If the return value of `rend` is assigned to a `reverse_iterator`, the string object can be modified."},{"pos":[127553,127634],"content":"can be used to test whether a reverse iterator has reached the end of its string."},{"pos":[127641,127697],"content":"The value returned by <ph id=\"ph1\">`rend`</ph> should not be dereferenced.","source":"The value returned by `rend` should not be dereferenced."},{"content":"Example","pos":[127707,127714]},{"pos":[129491,129512],"content":"basic_string::replace"},{"content":"Replaces elements in a string at a specified position with specified characters or characters copied from other ranges or strings or C-strings.","pos":[129516,129659]},{"content":"Parameters","pos":[131540,131550]},{"content":"The string that is to be a source of characters for the operand string.","pos":[131564,131635]},{"content":"The index of the operand string at which the replacement begins.","pos":[131653,131717]},{"content":"The maximum number of characters to be replaced in the operand string.","pos":[131735,131805]},{"content":"_Pos2","pos":[131813,131818]},{"content":"The index of the parameter string at which the copying begins.","pos":[131823,131885]},{"content":"The maximum number of characters to be used from the parameter C-string.","pos":[131903,131975]},{"content":"The C-string that is to be a source of characters for the operand string.","pos":[131992,132065]},{"content":"The character to be copied into the operand string.","pos":[132081,132132]},{"pos":[132141,132231],"content":"first0*  \nAn iterator addressing the first character to be removed in the operand string.","leadings":[""," "],"nodes":[{"content":"first0*","pos":[0,7]},{"content":"An iterator addressing the first character to be removed in the operand string.","pos":[10,89]}]},{"pos":[132240,132328],"content":"last0*  \nAn iterator addressing the last character to be removed in the operand string.","leadings":[""," "],"nodes":[{"content":"last0*","pos":[0,6]},{"content":"An iterator addressing the last character to be removed in the operand string.","pos":[9,87]}]},{"pos":[132335,132461],"content":"` first`  \nAn iterator, const_pointer, or const_iterator addressing the first character to be copied in the parameter string.","leadings":[""," "],"nodes":[{"content":"An iterator, const_pointer, or const_iterator addressing the first character to be copied in the parameter string.","pos":[11,125]}]},{"pos":[132468,132592],"content":"` last`  \nAn iterator, const_pointer, or const_iterator addressing the last character to be copied in the parameter string.","leadings":[""," "],"nodes":[{"content":"An iterator, const_pointer, or const_iterator addressing the last character to be copied in the parameter string.","pos":[10,123]}]},{"pos":[132599,132671],"content":"` count`  \nThe number of times `_Ch` is copied into the operand string.","leadings":[""," "],"nodes":[{"content":"The number of times <ph id=\"ph1\">`_Ch`</ph> is copied into the operand string.","pos":[11,71],"source":"The number of times `_Ch` is copied into the operand string."}]},{"content":"Return Value","pos":[132681,132693]},{"content":"The operand string with the replacement made.","pos":[132697,132742]},{"content":"Example","pos":[132752,132759]},{"pos":[139640,139661],"content":"basic_string::reserve"},{"content":"Sets the capacity of the string to a number at least as great as a specified number.","pos":[139665,139749]},{"content":"Parameters","pos":[139809,139819]},{"content":"The number of characters for which memory is being reserved.","pos":[139835,139895]},{"content":"Remarks","pos":[139905,139912]},{"content":"Having sufficient capacity is important because reallocations is a time-consuming process and invalidates all references, pointers, and iterators that refer to characters in a string.","pos":[139916,140099]},{"content":"The concept of capacity for objects of type strings is the same as for objects of type vector.","pos":[140106,140200]},{"content":"Unlike vector, the member function <bpt id=\"p1\">**</bpt>reserve<ept id=\"p1\">**</ept> may be called to shrink the capacity of an object.","pos":[140201,140298],"source":" Unlike vector, the member function **reserve** may be called to shrink the capacity of an object."},{"content":"The request is nonbinding and may or may not happen.","pos":[140299,140351]},{"content":"As the default value for the parameter is zero, a call of <bpt id=\"p1\">**</bpt>reserve<ept id=\"p1\">**</ept> is a non-binding request to shrink the capacity of the string to fit the number of characters currently in the string.","pos":[140352,140540],"source":" As the default value for the parameter is zero, a call of **reserve** is a non-binding request to shrink the capacity of the string to fit the number of characters currently in the string."},{"content":"The capacity is never reduced below the current number of characters.","pos":[140541,140610]},{"content":"Calling <ph id=\"ph1\">`reserve`</ph> is the only possible way to shrink the capacity of a string.","pos":[140617,140695],"source":"Calling `reserve` is the only possible way to shrink the capacity of a string."},{"content":"However, as noted above, this request is nonbinding and may not happen.","pos":[140696,140767]},{"content":"Example","pos":[140777,140784]},{"pos":[142986,143006],"content":"basic_string::resize"},{"content":"Specifies a new size for a string, appending or erasing elements as required.","pos":[143010,143087]},{"content":"Parameters","pos":[143201,143211]},{"content":"The new size of the string.","pos":[143227,143254]},{"content":"The value that appended characters are initialized with if additional elements are required.","pos":[143270,143362]},{"content":"Remarks","pos":[143372,143379]},{"pos":[143383,143478],"content":"If the resulting size exceeds the maximum number of characters, the form throws <ph id=\"ph1\">`length_error`</ph>.","source":"If the resulting size exceeds the maximum number of characters, the form throws `length_error`."},{"content":"Example","pos":[143488,143495]},{"pos":[146381,146411],"content":"basic_string::reverse_iterator"},{"content":"A type that provides a reference to an element stored in a string.","pos":[146415,146481]},{"content":"Remarks","pos":[146566,146573]},{"pos":[146577,146701],"content":"A type <ph id=\"ph1\">`reverse_iterator`</ph> can be used to modify the value of a character and is used to iterate through a string in reverse.","source":"A type `reverse_iterator` can be used to modify the value of a character and is used to iterate through a string in reverse."},{"content":"Example","pos":[146711,146718]},{"pos":[146723,146835],"content":"See the example for <bpt id=\"p1\">[</bpt>rbegin<ept id=\"p1\">](#basic_string__rbegin)</ept> for an example of how to declare and use <ph id=\"ph1\">`reverse_iterator`</ph>.","source":"See the example for [rbegin](#basic_string__rbegin) for an example of how to declare and use `reverse_iterator`."},{"pos":[146881,146900],"content":"basic_string::rfind"},{"content":"Searches a string in a backward direction for the first occurrence of a substring that matches a specified sequence of characters.","pos":[146904,147034]},{"content":"Parameters","pos":[147430,147440]},{"content":"The character value for which the member function is to search.","pos":[147453,147516]},{"content":"Index of the position at which the search is to begin.","pos":[147533,147587]},{"content":"The C-string for which the member function is to search.","pos":[147604,147660]},{"content":"The number of characters, counting forward from the first character, in the C-string for which the member function is to search.","pos":[147679,147807]},{"content":"The string for which the member function is to search.","pos":[147824,147878]},{"content":"Return Value","pos":[147888,147900]},{"pos":[147904,148037],"content":"The index of the last occurrence, when searched backwards, of the first character of the substring when successful; otherwise <ph id=\"ph1\">`npos`</ph>.","source":"The index of the last occurrence, when searched backwards, of the first character of the substring when successful; otherwise `npos`."},{"content":"Example","pos":[148047,148054]},{"pos":[152862,152889],"content":"basic_string::shrink_to_fit"},{"content":"Discards the excess capacity of the string.","pos":[152893,152936]},{"content":"Remarks","pos":[152983,152990]},{"content":"This member function eliminates any unneeded storage in the container.","pos":[152994,153064]},{"pos":[153109,153127],"content":"basic_string::size"},{"content":"Returns the current number of elements in a string.","pos":[153131,153182]},{"content":"Return Value","pos":[153231,153243]},{"content":"The length of the string.","pos":[153247,153272]},{"content":"Example","pos":[153282,153289]},{"pos":[155132,155155],"content":"basic_string::size_type"},{"content":"An unsigned integer type that can represent the number of elements and indices in a string.","pos":[155159,155250]},{"content":"Remarks","pos":[155331,155338]},{"pos":[155342,155392],"content":"It is equivalent to <bpt id=\"p1\">**</bpt>allocator_type::size_type<ept id=\"p1\">**</ept>.","source":"It is equivalent to **allocator_type::size_type**."},{"pos":[155399,155451],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>.","source":"For type **string**, it is equivalent to **size_t**."},{"content":"Example","pos":[155461,155468]},{"pos":[156127,156147],"content":"basic_string::substr"},{"content":"Copies a substring of at most some number of characters from a string beginning from a specified position.","pos":[156151,156257]},{"content":"Parameters","pos":[156393,156403]},{"content":"An index locating the element at the position from which the copy of the string is made, with a default value of 0.","pos":[156417,156532]},{"content":"The number of characters that are to be copied if they are present.","pos":[156551,156618]},{"content":"Return Value","pos":[156628,156640]},{"content":"A substring object that is a copy of elements of the string operand beginning at the position specified by the first argument.","pos":[156644,156770]},{"content":"Example","pos":[156780,156787]},{"pos":[157721,157739],"content":"basic_string::swap"},{"content":"Exchange the contents of two strings.","pos":[157743,157780]},{"content":"Parameters","pos":[157869,157879]},{"content":"The source string whose elements are to be exchanged with those in the destination string.","pos":[157893,157983]},{"content":"Remarks","pos":[157993,158000]},{"pos":[158004,158092],"content":"If the strings being swapped have the same allocator object, the <ph id=\"ph1\">`swap`</ph> member function:","source":"If the strings being swapped have the same allocator object, the `swap` member function:"},{"content":"Occurs in constant time.","pos":[158102,158126]},{"content":"Throws no exceptions.","pos":[158136,158157]},{"content":"Invalidates no references, pointers, or iterators that designate elements in the two strings.","pos":[158167,158260]},{"content":"Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.","pos":[158267,158415]},{"content":"Example","pos":[158425,158432]},{"pos":[159396,159421],"content":"basic_string::traits_type"},{"content":"A type for the character traits of the elements stored in a string.","pos":[159425,159492]},{"content":"Remarks","pos":[159547,159554]},{"pos":[159558,159625],"content":"The type is a synonym for the second template parameter <bpt id=\"p1\">**</bpt>Traits<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the second template parameter **Traits**."},{"pos":[159632,159696],"content":"For type <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept>, it is equivalent to <bpt id=\"p2\">**</bpt>char_traits<ph id=\"ph1\">\\&lt;</ph>char&gt;<ept id=\"p2\">**</ept>.","source":"For type **string**, it is equivalent to **char_traits\\<char>**."},{"content":"Example","pos":[159706,159713]},{"pos":[159718,159861],"content":"See the example for <bpt id=\"p1\">[</bpt>copy<ept id=\"p1\">](../standard-library/char-traits-struct.md#char_traits__copy)</ept> for an example of how to declare and use <ph id=\"ph1\">`traits_type`</ph>.","source":"See the example for [copy](../standard-library/char-traits-struct.md#char_traits__copy) for an example of how to declare and use `traits_type`."},{"pos":[159912,159936],"content":"basic_string::value_type"},{"content":"A type that represents the type of characters stored in a string.","pos":[159940,160005]},{"content":"Remarks","pos":[160088,160095]},{"pos":[160099,160205],"content":"It is equivalent to <bpt id=\"p1\">**</bpt>traits_type::char_type<ept id=\"p1\">**</ept> and is equivalent to <ph id=\"ph1\">`char`</ph> for objects of type <bpt id=\"p2\">**</bpt>string<ept id=\"p2\">**</ept>.","source":"It is equivalent to **traits_type::char_type** and is equivalent to `char` for objects of type **string**."},{"content":"Example","pos":[160215,160222]},{"content":"See Also","pos":[160675,160683]},{"content":"string&gt;","pos":[160690,160697],"source":"string>"},{"content":"Thread Safety in the C++ Standard Library","pos":[160735,160776]}],"content":"---\ntitle: \"basic_string Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.basic_string\"\n  - \"std::basic_string\"\n  - \"basic_string\"\n  - \"xstring/std::basic_string\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"basic_string class\"\nms.assetid: a9c3e0a2-39bf-4c8a-b093-9abe30839591\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# basic_string Class\nThe sequences controlled by an object of template class `basic_string` are the Standard C++ string class and are usually referred to as strings, but they should not be confused with the null-terminated C-style strings used throughout the Standard C++ Library. The Standard C++ string is a container that enables the use of strings as normal types, such as comparison and concatenation operations, iterators, STL algorithms, and copying and assigning with class allocator managed memory. If you need to convert a Standard C++ string to a null-terminated C-style string, use the [basic_string::c_str](#basic_string__c_str) member.  \n  \n## Syntax  \n  \n```  \ntemplate <class CharType, class Traits = char_traits<CharType>, class Allocator = allocator<CharType>>  \nclass basic_string;  \n```  \n  \n#### Parameters  \n `CharType`  \n The data type of a single character to be stored in the string. The Standard C++ Library provides specializations of this template class, with the type definitions [string](../standard-library/string-typedefs.md#string) for elements of type `char`, [wstring](../standard-library/string-typedefs.md#wstring), for `wchar_t`, [u16string](../standard-library/string-typedefs.md#u16string) for `char16_t`, and [u32string](../standard-library/string-typedefs.md#u32string) for `char32_t`.  \n  \n `Traits`  \n Various important properties of the **CharType** elements in a basic_string specialization are described by the class **Traits**. The default value is `char_traits`< `CharType`>.  \n  \n `Allocator`  \n The type that represents the stored allocator object that encapsulates details about the string's allocation and deallocation of memory. The default value is **allocator**< `CharType`>.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[basic_string](#basic_string__basic_string)|Constructs a string that is empty or initialized by specific characters or that is a copy of all or part of some other string object or C-string.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[allocator_type](#basic_string__allocator_type)|A type that represents the `allocator` class for a string object.|  \n|[const_iterator](#basic_string__const_iterator)|A type that provides a random-access iterator that can access and read a `const` element in the string.|  \n|[const_pointer](#basic_string__const_pointer)|A type that provides a pointer to a `const` element in a string.|  \n|[const_reference](#basic_string__const_reference)|A type that provides a reference to a `const` element stored in a string for reading and performing `const` operations.|  \n|[const_reverse_iterator](#basic_string__const_reverse_iterator)|A type that provides a random-access iterator that can read any `const` element in the string.|  \n|[difference_type](#basic_string__difference_type)|A type that provides the difference between two iterators that refer to elements within the same string.|  \n|[iterator](#basic_string__iterator)|A type that provides a random-access iterator that can read or modify any element in a string.|  \n|[npos](#basic_string__npos)|An unsigned integral value initialized to –1 that indicates either \"not found\" or \"all remaining characters\" when a search function fails.|  \n|[pointer](#basic_string__pointer)|A type that provides a pointer to a character element in a string or character array.|  \n|[reference](#basic_string__reference)|A type that provides a reference to an element stored in a string.|  \n|[reverse_iterator](#basic_string__reverse_iterator)|A type that provides a random-access iterator that can read or modify an element in a reversed string.|  \n|[size_type](#basic_string__size_type)|An unsigned integral type for the number of elements in a string.|  \n|[traits_type](#basic_string__traits_type)|A type for the character traits of the elements stored in a string.|  \n|[value_type](#basic_string__value_type)|A type that represents the type of characters stored in a string.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[append](#basic_string__append)|Adds characters to the end of a string.|  \n|[assign](#basic_string__assign)|Assigns new character values to the contents of a string.|  \n|[at](#basic_string__at)|Returns a reference to the element at a specified location in the string.|  \n|[back](#basic_string__back)||  \n|[begin](#basic_string__begin)|Returns an iterator addressing the first element in the string.|  \n|[c_str](#basic_string__c_str)|Converts the contents of a string as a C-style, null-terminated, string.|  \n|[capacity](#basic_string__capacity)|Returns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.|  \n|[cbegin](#basic_string__cbegin)|Returns a const iterator addressing the first element in the string.|  \n|[cend](#basic_string__cend)|Returns a const iterator that addresses the location succeeding the last element in a string.|  \n|[clear](#basic_string__clear)|Erases all elements of a string.|  \n|[compare](#basic_string__compare)|Compares a string with a specified string to determine if the two strings are equal or if one is lexicographically less than the other.|  \n|[copy](#basic_string__copy)|Copies at most a specified number of characters from an indexed position in a source string to a target character array. Deprecated. Use [basic_string::_Copy_s](#basic_string___copy_s) instead.|  \n|[crbegin](#basic_string__crbegin)|Returns a const iterator that addresses the first element in a reversed string.|  \n|[crend](#basic_string__crend)|Returns a const iterator that addresses the location succeeding the last element in a reversed string.|  \n|[_Copy_s](#basic_string___copy_s)|Copies at most a specified number of characters from an indexed position in a source string to a target character array.|  \n|[data](#basic_string__data)|Converts the contents of a string into an array of characters.|  \n|[empty](#basic_string__empty)|Tests whether the string contains characters.|  \n|[end](#basic_string__end)|Returns an iterator that addresses the location succeeding the last element in a string.|  \n|[erase](#basic_string__erase)|Removes an element or a range of elements in a string from a specified position.|  \n|[find](#basic_string__find)|Searches a string in a forward direction for the first occurrence of a substring that matches a specified sequence of characters.|  \n|[find_first_not_of](#basic_string__find_first_not_of)|Searches through a string for the first character that is not any element of a specified string.|  \n|[find_first_of](#basic_string__find_first_of)|Searches through a string for the first character that matches any element of a specified string.|  \n|[find_last_not_of](#basic_string__find_last_not_of)|Searches through a string for the last character that is not any element of a specified string.|  \n|[find_last_of](#basic_string__find_last_of)|Searches through a string for the last character that is an element of a specified string.|  \n|[front](#basic_string__front)|Returns a reference to the first element in a string.|  \n|[get_allocator](#basic_string__get_allocator)|Returns a copy of the `allocator` object used to construct the string.|  \n|[insert](#basic_string__insert)|Inserts an element or a number of elements or a range of elements into the string at a specified position.|  \n|[length](#basic_string__length)|Returns the current number of elements in a string.|  \n|[max_size](#basic_string__max_size)|Returns the maximum number of characters a string could contain.|  \n|[pop_back](#basic_string__pop_back)|Erases the last element of the string.|  \n|[push_back](#basic_string__push_back)|Adds an element to the end of the string.|  \n|[rbegin](#basic_string__rbegin)|Returns an iterator to the first element in a reversed string.|  \n|[rend](#basic_string__rend)|Returns an iterator that points just beyond the last element in a reversed string.|  \n|[replace](#basic_string__replace)|Replaces elements in a string at a specified position with specified characters or characters copied from other ranges or strings or C-strings.|  \n|[reserve](#basic_string__reserve)|Sets the capacity of the string to a number at least as great as a specified number.|  \n|[resize](#basic_string__resize)|Specifies a new size for a string, appending or erasing elements as required.|  \n|[rfind](#basic_string__rfind)|Searches a string in a backward direction for the first occurrence of a substring that matches a specified sequence of characters.|  \n|[shrink_to_fit](#basic_string__shrink_to_fit)|Discards the excess capacity of the string.|  \n|[size](#basic_string__size)|Returns the current number of elements in a string.|  \n|[substr](#basic_string__substr)|Copies a substring of at most some number of characters from a string beginning from a specified position.|  \n|[swap](#basic_string__swap)|Exchange the contents of two strings.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator+=](#basic_string__operator_add_eq)|Appends characters to a string.|  \n|[operator=](#basic_string__operator_eq)|Assigns new character values to the contents of a string.|  \n|[operator&#91;&#93;](#basic_string__operator_at)|Provides a reference to the character with a specified index in a string.|  \n  \n## Remarks  \n If a function is asked to generate a sequence longer than [max_size](#basic_string__max_size) elements, the function reports a length error by throwing an object of type [length_error](../standard-library/length-error-class.md).  \n  \n References, pointers, and iterators that designate elements of the controlled sequence can become invalid after any call to a function that alters the controlled sequence, or after the first call to a non- **const** member function.  \n  \n## Requirements  \n **Header:** \\<string>  \n  \n **Namespace:** std  \n  \n##  <a name=\"basic_string__allocator_type\"></a>  basic_string::allocator_type  \n A type that represents the allocator class for a string object.  \n  \n```  \ntypedef Allocator allocator_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **Allocator**.  \n  \n### Example  \n  \n```cpp  \n// basic_string_allocator_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // The following lines declare objects  \n   // that use the default allocator.  \n   string s1;  \n   basic_string <char>::allocator_type xchar = s1.get_allocator( );  \n   // You can now call functions on the allocator class xchar used by s1  \n}  \n```  \n  \n##  <a name=\"basic_string__append\"></a>  basic_string::append  \n Adds characters to the end of a string.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& append(\n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    const value_type* ptr,  \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off,  \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    const basic_string<CharType, Traits, Allocator>& str);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    size_type count,   \n    value_type _Ch);\n\ntemplate <class InputIterator>  \nbasic_string<CharType, Traits, Allocator>& append(\n    InputIterator first,   \n    InputIterator last);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    const_pointer first,  \n    const_pointer last);\n\nbasic_string<CharType, Traits, Allocator>& append(\n    const_iterator first,  \n    const_iterator last);\n```  \n  \n### Parameters  \n ` ptr`  \n The C-string to be appended.  \n  \n ` str`  \n The string whose characters are to be appended.  \n  \n `_Off`  \n The index of the part of the source string supplying the characters to be appended.  \n  \n ` count`  \n The number of characters to be appended, at most, from the source string.  \n  \n `_Ch`  \n The character value to be appended.  \n  \n ` first`  \n An input iterator addressing the first element in the range to be appended.  \n  \n ` last`  \n An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the range to be appended.  \n  \n### Return Value  \n A reference to the string object that is being appended with the characters passed by the member function.  \n  \n### Remarks  \n Characters may be appended to a string using the [operator+=](#basic_string__operator_add_eq) or the member functions **append** or [push_back](#basic_string__push_back). `operator+=` appends single-argument values while the multiple-argument **append** member function allows a specific part of a string to be specified for adding.  \n  \n### Example  \n  \n```cpp  \n// basic_string_append.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // appending a C-string to a string  \n   string str1a ( \"Hello \" );  \n   cout << \"The original string str1 is: \" << str1a << endl;  \n   const char *cstr1a = \"Out There \";  \n   cout << \"The C-string cstr1a is: \" << cstr1a << endl;  \n   str1a.append ( cstr1a );  \n   cout << \"Appending the C-string cstr1a to string str1 gives: \"   \n        << str1a << \".\" << endl << endl;  \n  \n   // The second member function  \n   // appending part of a C-string to a string  \n   string str1b ( \"Hello \" );  \n   cout << \"The string str1b is: \" << str1b << endl;  \n   const char *cstr1b = \"Out There \";  \n   cout << \"The C-string cstr1b is: \" << cstr1b << endl;  \n   str1b.append ( cstr1b , 3 );  \n   cout << \"Appending the 1st part of the C-string cstr1b \"  \n        << \"to string str1 gives: \" << str1b << \".\"   \n        << endl << endl;  \n  \n   // The third member function  \n   // appending part of one string to another  \n   string str1c ( \"Hello \" ), str2c ( \"Wide World \" );  \n   cout << \"The string str2c is: \" << str2c << endl;  \n   str1c.append ( str2c , 5 , 5 );  \n   cout << \"The appended string str1 is: \"   \n        << str1c << \".\" << endl << endl;  \n  \n   // The fourth member function  \n   // appending one string to another in two ways,  \n   // comparing append and operator [ ]  \n   string str1d ( \"Hello \" ), str2d ( \"Wide \" ), str3d ( \"World \" );  \n   cout << \"The  string str2d is: \" << str2d << endl;  \n   str1d.append ( str2d );  \n   cout << \"The appended string str1d is: \"   \n        << str1d << \".\" << endl;  \n   str1d += str3d;  \n   cout << \"The doubly appended strig str1 is: \"   \n        << str1d << \".\" << endl << endl;  \n  \n   // The fifth member function  \n   // appending characters to a string  \n   string str1e ( \"Hello \" );  \n   str1e.append ( 4 , '!' );  \n   cout << \"The string str1 appended with exclamations is: \"   \n        << str1e << endl << endl;  \n  \n   // The sixth member function  \n   // appending a range of one string to another  \n   string str1f ( \"Hello \" ), str2f ( \"Wide World \" );  \n   cout << \"The string str2f is: \" << str2f << endl;  \n   str1f.append ( str2f.begin ( ) + 5 , str2f.end ( ) - 1 );  \n   cout << \"The appended string str1 is: \"   \n        << str1f << \".\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello   \nThe C-string cstr1a is: Out There   \nAppending the C-string cstr1a to string str1 gives: Hello Out There .  \n  \nThe string str1b is: Hello   \nThe C-string cstr1b is: Out There   \nAppending the 1st part of the C-string cstr1b to string str1 gives: Hello Out.  \n  \nThe string str2c is: Wide World   \nThe appended string str1 is: Hello World.  \n  \nThe  string str2d is: Wide   \nThe appended string str1d is: Hello Wide .  \nThe doubly appended strig str1 is: Hello Wide World .  \n  \nThe string str1 appended with exclamations is: Hello !!!!  \n  \nThe string str2f is: Wide World   \nThe appended string str1 is: Hello World.  \n```  \n  \n##  <a name=\"basic_string__assign\"></a>  basic_string::assign  \n Assigns new character values to the contents of a string.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& assign(\n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    const value_type* ptr,  \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type off,   \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    const basic_string<CharType, Traits, Allocator>& str);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    size_type count,   \n    value_type _Ch);\n\ntemplate <class InIt>  \nbasic_string<CharType, Traits, Allocator>& assign(\n    InputIterator first,   \n    InputIterator last);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    const_pointer first,  \n    const_pointer last);\n\nbasic_string<CharType, Traits, Allocator>& assign(\n    const_iterator first,  \n    const_iterator last);\n```  \n  \n### Parameters  \n ` ptr`  \n A pointer to the characters of the C-string to be assigned to the target string.  \n  \n ` count`  \n The number of characters to be appended, at most, from the source string.  \n  \n ` str`  \n The source string whose characters are to be assigned to the target string.  \n  \n `_Ch`  \n The character value to be assigned.  \n  \n ` first`  \n An input iterator, const_pointer, or const_iterator addressing the first character in the range of the source string to be assigned to the target range.  \n  \n ` last`  \n An input iterator, const_pointer, or const_iterator addressing the one beyond the last character in the range of the source string to be assigned to the target range.  \n  \n `off`  \n The position at which new characters will start to be assigned.  \n  \n### Return Value  \n A reference to the string object that is being assigned new characters by the member function.  \n  \n### Remarks  \n The strings can be assigned new character values. The new value can be either a string and C-string or a single character. The [operator=](#basic_string__operator_eq) may be used if the new value can be described by a single parameter; otherwise the member function **assign**, which has multiple parameters, can be used to specify which part of the string is to be assigned to a target string.  \n  \n### Example  \n  \n```cpp  \n// basic_string_assign.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function assigning the  \n   // characters of a C-string to a string  \n   string str1a;  \n   const char *cstr1a = \"Out There\";  \n   cout << \"The C-string cstr1a is: \" << cstr1a <<  \".\" << endl;  \n   str1a.assign ( cstr1a );  \n   cout << \"Assigning the C-string cstr1a to string str1 gives: \"   \n        << str1a << \".\" << endl << endl;  \n  \n   // The second member function assigning a specific  \n   // number of the of characters a C-string to a string  \n   string  str1b;  \n   const char *cstr1b = \"Out There\";  \n   cout << \"The C-string cstr1b is: \" << cstr1b << endl;  \n   str1b.assign ( cstr1b , 3 );  \n   cout << \"Assigning the 1st part of the C-string cstr1b \"  \n        << \"to string str1 gives: \" << str1b << \".\"   \n        << endl << endl;  \n  \n   // The third member function assigning a specific number  \n   // of the characters from one string to another string   \n   string str1c ( \"Hello \" ), str2c ( \"Wide World \" );  \n   cout << \"The string str2c is: \" << str2c << endl;  \n   str1c.assign ( str2c , 5 , 5 );  \n   cout << \"The newly assigned string str1 is: \"   \n        << str1c << \".\" << endl << endl;  \n  \n   // The fourth member function assigning the characters  \n   // from one string to another string in two equivalent  \n   // ways, comparing the assign and operator =  \n   string str1d ( \"Hello\" ), str2d ( \"Wide\" ), str3d ( \"World\" );  \n   cout << \"The original string str1 is: \" << str1d << \".\" << endl;  \n   cout << \"The string str2d is: \" << str2d << endl;  \n   str1d.assign ( str2d );  \n   cout << \"The string str1 newly assigned with string str2d is: \"   \n        << str1d << \".\" << endl;  \n   cout << \"The string str3d is: \" << str3d << \".\" << endl;  \n   str1d = str3d;  \n   cout << \"The string str1 reassigned with string str3d is: \"   \n        << str1d << \".\" << endl << endl;  \n  \n   // The fifth member function assigning a specific   \n   // number of characters of a certain value to a string  \n   string str1e ( \"Hello \" );  \n   str1e.assign ( 4 , '!' );  \n   cout << \"The string str1 assigned with eclamations is: \"   \n        << str1e << endl << endl;  \n  \n   // The sixth member function assigning the value from  \n   // the range of one string to another string  \n   string str1f ( \"Hello \" ), str2f ( \"Wide World \" );  \n   cout << \"The string str2f is: \" << str2f << endl;  \n   str1f.assign ( str2f.begin ( ) + 5 , str2f.end ( ) - 1 );  \n   cout << \"The string str1 assigned a range of string str2f is: \"   \n        << str1f << \".\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe C-string cstr1a is: Out There.  \nAssigning the C-string cstr1a to string str1 gives: Out There.  \n  \nThe C-string cstr1b is: Out There  \nAssigning the 1st part of the C-string cstr1b to string str1 gives: Out.  \n  \nThe string str2c is: Wide World   \nThe newly assigned string str1 is: World.  \n  \nThe original string str1 is: Hello.  \nThe string str2d is: Wide  \nThe string str1 newly assigned with string str2d is: Wide.  \nThe string str3d is: World.  \nThe string str1 reassigned with string str3d is: World.  \n  \nThe string str1 assigned with eclamations is: !!!!  \n  \nThe string str2f is: Wide World   \nThe string str1 assigned a range of string str2f is: World.  \n```  \n  \n##  <a name=\"basic_string__at\"></a>  basic_string::at  \n Provides a reference to the character with a specified index in a string.  \n  \n```  \nconst_reference at(size_type _Off) const;\n\n \nreference at(size_type _Off);\n```  \n  \n### Parameters  \n `_Off`  \n The index of the position of the element to be referenced.  \n  \n### Return Value  \n A reference to the character of the string at the position specified by the parameter index.  \n  \n### Remarks  \n The first element of the string has an index of zero and the following elements are indexed consecutively by the positive integers, so that a string of length *n* has an *n*th element indexed by the number *n –* 1.  \n  \n The member [operator&#91;&#93;](#basic_string__operator_at) is faster than the member function **at** for providing read and write access to the elements of a string.  \n  \n The member `operator[]` does not check whether the index passed as a parameter is valid but the member function **at** does and so should be used if the validity is not certain. An invalid index, which is an index less that zero or greater than or equal to the size of the string, passed to the member function **at** throws an [out_of_range Class](../standard-library/out-of-range-class.md) exception. An invalid index passed to the `operator[]` results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null-character when passed this index.  \n  \n The reference returned may be invalidated by string reallocations or modifications for the non- **const** strings.  \n  \n### Example  \n  \n```cpp  \n// basic_string_at.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string str1 ( \"Hello world\" ), str2 ( \"Goodbye world\" );  \n   const string  cstr1 ( \"Hello there\" ), cstr2 ( \"Goodbye now\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n  \n   // Element access to the non const strings  \n   basic_string <char>::reference refStr1 = str1 [6];  \n   basic_string <char>::reference refStr2 = str2.at ( 3 );  \n  \n   cout << \"The character with an index of 6 in string str1 is: \"  \n        << refStr1 << \".\" << endl;  \n   cout << \"The character with an index of 3 in string str2 is: \"  \n        << refStr2 << \".\" << endl;  \n  \n   // Element access to the const strings  \n   basic_string <char>::const_reference crefStr1 = cstr1 [ cstr1.length ( ) ];  \n   basic_string <char>::const_reference crefStr2 = cstr2.at ( 8 );  \n  \n   if ( crefStr1 == '\\0' )  \n      cout << \"The null character is returned as a valid reference.\"  \n           << endl;  \n   else  \n      cout << \"The null character is not returned.\" << endl;  \n   cout << \"The character with index 8 in the const string cstr2 is: \"  \n        << crefStr2 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__back\"></a>  basic_string::back  \n Returns a reference to the last element in the string.  \n  \n```  \nconst_reference back() const;\n\n \nreference back();\n```  \n  \n### Return Value  \n A reference to the last element of the string, which must be non-empty.  \n  \n### Remarks  \n  \n##  <a name=\"basic_string__basic_string\"></a>  basic_string::basic_string  \n Constructs a string that is empty, initialized by specific characters, or is a copy of all or part of another string object or C style (null-terminated) string.  \n  \n```  \nbasic_string();\n\nexplicit basic_string(\n    const allocator_type& _Al);\n\nbasic_string(\n    const basic_string& right);\n\nbasic_string(\n    basic_string&& right);\n\nbasic_string(\n    const basic_string& right,   \n    size_type _Roff,  \n    size_type count = npos);\n\nbasic_string(\n    const basic_string& right,   \n    size_type _Roff,  \n    size_type count,   \n    const allocator_type& _Al);\n\nbasic_string(\n    const value_type* ptr,   \n    size_type count);\n\nbasic_string(\n    const value_type* ptr,   \n    size_type count,  \n    const allocator_type& _Al);\n\nbasic_string(\n    const value_type* ptr);\n\nbasic_string(\n    const value_type* ptr,  \n    const allocator_type& _Al);\n\nbasic_string(\n    size_type count,   \n    value_type _Ch);\n\nbasic_string(\n    size_type count,   \n    value_type _Ch,  \n    const allocator_type& _Al);\n\ntemplate <class InputIterator>  \nbasic_string(\n InputIterator first,   \n    InputIterator last);\n\ntemplate <class InputIterator>  \nbasic_string(\n InputIterator first,   \n    InputIterator last,   \n    const allocator_type& _Al);\n\nbasic_string(\n    const_pointer first,  \n    const_pointer last);\n\nbasic_string(\n    const_iterator first,  \n    const_iterator last);\n```  \n  \n### Parameters  \n ` ptr`  \n The C-string whose characters are to be used to initialize the `string` being constructed. This value cannot be a null pointer.  \n  \n `_Al`  \n The storage allocator class for the string object being constructed.  \n  \n ` count`  \n The number of characters to be initialized.  \n  \n ` right`  \n The string to initialize the string being constructed.  \n  \n `_Roff`  \n The index of a character in a string that is the first to be used to initialize character values for the string being constructed.  \n  \n `_Ch`  \n The character value to be copied into the string being constructed.  \n  \n ` first`  \n An input iterator, const_pointer, or const_iterator addressing the first element in the source range to be inserted.  \n  \n ` last`  \n An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the source range to be inserted.  \n  \n### Return Value  \n A reference to the string object that is being constructed by the constructors.  \n  \n### Remarks  \n All constructors store an [basic_string::allocator_type](#basic_string__allocator_type) and initialize the controlled sequence. The allocator object is the argument `al`, if present. For the copy constructor, it is `right.`[basic_string::get_allocator](#basic_string__get_allocator)`()`. Otherwise, it is `Alloc()`.  \n  \n The controlled sequence is initialized to a copy of the operand sequence specified by the remaining operands. A constructor without an operand sequence specifies an empty initial controlled sequence. If `InputIterator` is an integer type in a template constructor, the operand sequence _F `irst,  last` behaves the same as `(size_type) first, (value_type) last`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_ctor.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function initializing with a C-string  \n   const char *cstr1a = \"Hello Out There.\";  \n   basic_string <char> str1a ( cstr1a , 5);  \n   cout << \"The string initialized by C-string cstr1a is: \"  \n        << str1a << \".\" << endl;  \n  \n   // The second member function initializing with a string  \n   string  str2a ( \"How Do You Do\" );  \n   basic_string <char> str2b ( str2a , 7 , 7 );  \n   cout << \"The string initialized by part of the string cstr2a is: \"  \n        << str2b << \".\" << endl;  \n  \n   // The third member function initializing a string  \n   // with a number of characters of a specific value  \n   basic_string <char> str3a ( 5, '9' );  \n   cout << \"The string initialized by five number 9s is: \"  \n        << str3a << endl;  \n  \n   // The fourth member function creates an empty string  \n   // and string with a specified allocator  \n   basic_string <char> str4a;  \n   string str4b;  \n   basic_string <char> str4c ( str4b.get_allocator( ) );  \n   if (str4c.empty ( ) )  \n      cout << \"The string str4c is empty.\" << endl;  \n   else  \n      cout << \"The string str4c is not empty.\" << endl;  \n  \n   // The fifth member function initializes a string from  \n   // another range of characters  \n   string str5a ( \"Hello World\" );  \n   basic_string <char> str5b ( str5a.begin ( ) + 5 , str5a.end ( ) );  \n   cout << \"The string initialized by another range is: \"  \n        << str5b << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__begin\"></a>  basic_string::begin  \n Returns an iterator addressing the first element in the string.  \n  \n```  \nconst_iterator begin() const;\n\n \niterator begin();\n```  \n  \n### Return Value  \n A random-access iterator that addresses the first element of the sequence or just beyond the end of an empty sequence.  \n  \n### Example  \n  \n```cpp  \n// basic_string_begin.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   string str1 ( \"No way out.\" ), str2;  \n   basic_string <char>::iterator strp_Iter, str1_Iter, str2_Iter;  \n   basic_string <char>::const_iterator str1_cIter;  \n  \n   str1_Iter = str1.begin ( );  \n   cout << \"The first character of the string str1 is: \"   \n        << *str1_Iter << endl;  \n   cout << \"The full original string str1 is: \" << str1 << endl;  \n  \n   // The dereferenced iterator can be used to modify a character  \n *str1_Iter = 'G';  \n   cout << \"The first character of the modified str1 is now: \"   \n        << *str1_Iter << endl;  \n   cout << \"The full modified string str1 is now: \" << str1 << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *str1_cIter = 'g';  \n  \n   // For an empty string, begin is equivalent to end  \n   if (  str2.begin ( ) == str2.end ( ) )  \n      cout << \"The string str2 is empty.\" << endl;  \n   else  \n      cout << \"The string str2 is not empty.\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__c_str\"></a>  basic_string::c_str  \n Converts the contents of a string as a C-style, null-terminated string.  \n  \n```  \nconst value_type *c_str() const;\n```  \n  \n### Return Value  \n A pointer to the C-style version of the invoking string.  The pointer value is not valid after calling a non-const function, including the destructor, in the basic_string class on the object.  \n  \n### Remarks  \n Objects of type string belonging to the C++ template class basic_string\\<char> are not necessarily null terminated. The null character ' \\0 ' is used as a special character in a C-string to mark the end of the string but has no special meaning in an object of type string and may be a part of the string just like any other character. There is an automatic conversion from const **char\\*** into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type **basic_string\\<char>**.  \n  \n The returned C-style string should not be modified, as this could invalidate the pointer to the string, or deleted, as the string has a limited lifetime and is owned by the class string.  \n  \n### Example  \n  \n```cpp  \n// basic_string_c_str.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   string  str1 ( \"Hello world\" );  \n   cout << \"The original string object str1 is: \"   \n        << str1 << endl;  \n   cout << \"The length of the string object str1 = \"   \n        << str1.length ( ) << endl << endl;  \n  \n   // Converting a string to an array of characters  \n   const char *ptr1 = 0;  \n   ptr1= str1.data ( );  \n   cout << \"The modified string object ptr1 is: \" << ptr1   \n        << endl;  \n   cout << \"The length of character array str1 = \"   \n        << strlen ( ptr1) << endl << endl;  \n  \n   // Converting a string to a C-style string  \n   const char *c_str1 = str1.c_str ( );  \n   cout << \"The C-style string c_str1 is: \" << c_str1   \n        << endl;  \n   cout << \"The length of C-style string str1 = \"   \n        << strlen ( c_str1) << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string object str1 is: Hello world  \nThe length of the string object str1 = 11  \n  \nThe modified string object ptr1 is: Hello world  \nThe length of character array str1 = 11  \n  \nThe C-style string c_str1 is: Hello world  \nThe length of C-style string str1 = 11  \n```  \n  \n##  <a name=\"basic_string__capacity\"></a>  basic_string::capacity  \n Returns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.  \n  \n```  \nsize_type capacity() const;\n```  \n  \n### Return Value  \n The size of storage currently allocated in memory to hold the string.  \n  \n### Remarks  \n The member function returns the storage currently allocated to hold the controlled sequence, a value at least as large as [size](#basic_string__size).  \n  \n### Example  \n  \n```cpp  \n// basic_string_capacity.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string  str1 (\"Hello world\");  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   // The size and length member functions differ in name only  \n   basic_string <char>::size_type sizeStr1, lenStr1;  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n  \n   basic_string <char>::size_type capStr1, max_sizeStr1;  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of original string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of original string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl << endl;  \n  \n   str1.erase ( 6, 5 );  \n   cout << \"The modified string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size (  );  \n   lenStr1 = str1.length (  );  \n   capStr1 = str1.capacity (  );  \n   max_sizeStr1 = str1.max_size (  );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   // after erasing part of the original string  \n   cout << \"The current size of modified string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of modified string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of modified string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of modified string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__cbegin\"></a>  basic_string::cbegin  \n Returns a `const` iterator that addresses the first element in the range.  \n  \n```  \nconst_iterator cbegin() const;\n```  \n  \n### Return Value  \n A `const` random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`).  \n  \n### Remarks  \n With the return value of `cbegin`, the elements in the range cannot be modified.  \n  \n You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`.  \n  \n```cpp  \n \nauto i1 = Container.begin();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cbegin();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"basic_string__cend\"></a>  basic_string::cend  \n Returns a `const` iterator that addresses the location just beyond the last element in a range.  \n  \n```  \nconst_iterator cend() const;\n```  \n  \n### Return Value  \n A `const` random-access iterator that points just beyond the end of the range.  \n  \n### Remarks  \n `cend` is used to test whether an iterator has passed the end of its range.  \n  \n You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`.  \n  \n```cpp  \n \nauto i1 = Container.end();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cend();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n The value returned by `cend` should not be dereferenced.  \n  \n##  <a name=\"basic_string__clear\"></a>  basic_string::clear  \n Erases all elements of a string.  \n  \n```  \nvoid clear();\n```  \n  \n### Remarks  \n The string on which the member function is called will be empty.  \n  \n### Example  \n  \n```cpp  \n// basic_string_clear.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string  str1 (\"Hello world\"), str2;  \n   basic_string <char>::iterator str_Iter;  \n   cout << \"The original string str1 is: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n  \n   str1.clear ( );  \n   cout << \"The modified string str1 is: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n  \n   //For an empty string, begin is equivalent to end  \n   if ( str1.begin ( ) == str1.end ( ) )  \n      cout << \"Nothing printed above because \"  \n           << \"the string str1 is empty.\" << endl;  \n   else  \n      cout << \"The string str1 is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello world  \nThe modified string str1 is:   \nNothing printed above because the string str1 is empty.  \n```  \n  \n##  <a name=\"basic_string__compare\"></a>  basic_string::compare  \n Performs a case sensitive comparison with a specified string to determine if the two strings are equal or if one is lexicographically less than the other.  \n  \n```  \nint compare(\n    const basic_string<CharType, Traits, Allocator>& str) const;\n\n \nint compare(\n    size_type _Pos1,   \n    size_type _Num1,  \n    const basic_string<CharType, Traits, Allocator>& str) const;\n\n \nint compare(\n    size_type _Pos1,  \n    size_type _Num1,  \n    const basic_string<CharType, Traits, Allocator>& str,   \n    size_type _Off,   \n    size_type count) const;\n\n \nint compare(\n    const value_type* ptr) const;\n\n \nint compare(\n    size_type _Pos1,  \n    size_type _Num1,  \n    const value_type* ptr) const;\n\n \nint compare(\n    size_type _Pos1,  \n    size_type _Num1,  \n    const value_type* ptr  \n    size_type _Num2) const;\n```  \n  \n### Parameters  \n ` str`  \n The string that is to be compared to the operand string.  \n  \n `_Pos1`  \n The index of the operand string at which the comparison begins.  \n  \n `_Num1`  \n The maximum number of characters from the operand string to be compared.  \n  \n `_Num2`  \n The maximum number of characters from the parameter string to be compared.  \n  \n `_Off`  \n The index of the parameter string at which the comparison begins.  \n  \n ` count`  \n The maximum number of characters from the parameter string to be compared.  \n  \n ` ptr`  \n The C-string to be compared to the operand string.  \n  \n### Return Value  \n A negative value if the operand string is less than the parameter string; zero if the two strings are equal; or a positive value if the operand string is greater than the parameter string.  \n  \n### Remarks  \n The **compare** member functions compare either all or part of the parameter and operand strings depending on which in used.  \n  \n The comparison performed is case sensitive.  \n  \n### Example  \n  \n```cpp  \n// basic_string_compare.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function compares  \n   // an operand string to a parameter string  \n   int comp1;  \n   string s1o ( \"CAB\" );  \n   string s1p ( \"CAB\" );  \n   cout << \"The operand string is: \" << s1o << endl;  \n   cout << \"The parameter string is: \" << s1p << endl;  \n   comp1 = s1o.compare ( s1p );  \n   if ( comp1 < 0 )  \n      cout << \"The operand string is less than \"  \n           << \"the parameter string.\" << endl;  \n   else if ( comp1 == 0 )  \n      cout << \"The operand string is equal to \"  \n           << \"the parameter string.\" << endl;  \n   else  \n      cout << \"The operand string is greater than \"  \n           << \"the parameter string.\" << endl;  \n   cout << endl;  \n  \n   // The second member function compares part of  \n   // an operand string to a parameter string  \n   int comp2a, comp2b;  \n   string s2o ( \"AACAB\" );  \n   string s2p ( \"CAB\" );  \n   cout << \"The operand string is: \" << s2o << endl;  \n   cout << \"The parameter string is: \" << s2p << endl;  \n   comp2a = s2o.compare (  2 , 3 , s2p );  \n   if ( comp2a < 0 )  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n are less than \"  \n           << \"the parameter string.\" << endl;  \n   else if ( comp2a == 0 )  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n are equal to \"  \n           << \"the parameter string.\" << endl;  \n   else  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n is greater than \"  \n           << \"the parameter string.\" << endl;  \n  \n   comp2b = s2o.compare (  0 , 3 , s2p );  \n   if ( comp2b < 0 )  \n      cout << \"The first three characters of \"  \n           << \"the operand string\\n are less than \"  \n           << \"the parameter string.\" << endl;  \n   else if ( comp2b == 0 )  \n      cout << \"The first three characters of \"  \n           << \"the operand string\\n are equal to \"  \n           << \"the parameter string.\" << endl;  \n   else  \n      cout << \"The first three characters of \"  \n           << \"the operand string\\n is greater than \"  \n           << \"the parameter string.\" << endl;  \n   cout << endl;  \n  \n   // The third member function compares part of  \n   // an operand string to part of a parameter string  \n   int comp3a;  \n   string s3o ( \"AACAB\" );  \n   string s3p ( \"DCABD\" );  \n   cout << \"The operand string is: \" << s3o << endl;  \n   cout << \"The parameter string is: \" << s3p << endl;  \n   comp3a = s3o.compare (  2 , 3 , s3p , 1 , 3 );  \n   if ( comp3a < 0 )  \n      cout << \"The three characters from position 2 of \"  \n           << \"the operand string are less than\\n \"  \n           << \"the 3 characters parameter string \"   \n           << \"from position 1.\" << endl;  \n   else if ( comp3a == 0 )  \n      cout << \"The three characters from position 2 of \"  \n           << \"the operand string are equal to\\n \"  \n           << \"the 3 characters parameter string \"   \n           << \"from position 1.\" << endl;  \n   else  \n      cout << \"The three characters from position 2 of \"  \n           << \"the operand string is greater than\\n \"  \n           << \"the 3 characters parameter string \"   \n           << \"from position 1.\" << endl;  \n   cout << endl;  \n  \n   // The fourth member function compares  \n   // an operand string to a parameter C-string  \n   int comp4a;  \n   string s4o ( \"ABC\" );  \n   const char* cs4p = \"DEF\";  \n   cout << \"The operand string is: \" << s4o << endl;  \n   cout << \"The parameter C-string is: \" << cs4p << endl;  \n   comp4a = s4o.compare ( cs4p );  \n   if ( comp4a < 0 )  \n      cout << \"The operand string is less than \"  \n           << \"the parameter C-string.\" << endl;  \n   else if ( comp4a == 0 )  \n      cout << \"The operand string is equal to \"  \n           << \"the parameter C-string.\" << endl;  \n   else  \n      cout << \"The operand string is greater than \"  \n           << \"the parameter C-string.\" << endl;  \n   cout << endl;  \n  \n   // The fifth member function compares part of  \n   // an operand string to a parameter C-string  \n   int comp5a;  \n   string s5o ( \"AACAB\" );  \n   const char* cs5p = \"CAB\";  \n   cout << \"The operand string is: \" << s5o << endl;  \n   cout << \"The parameter string is: \" << cs5p << endl;  \n   comp5a = s5o.compare (  2 , 3 , s2p );  \n   if ( comp5a < 0 )  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n are less than \"  \n           << \"the parameter C-string.\" << endl;  \n   else if ( comp5a == 0 )  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n are equal to \"  \n           << \"the parameter C-string.\" << endl;  \n   else  \n      cout << \"The last three characters of \"  \n           << \"the operand string\\n is greater than \"  \n           << \"the parameter C-string.\" << endl;  \n   cout << endl;  \n  \n   // The sixth member function compares part of  \n   // an operand string to part of an equal length of  \n   // a parameter C-string  \n   int comp6a;  \n   string s6o ( \"AACAB\" );  \n   const char* cs6p = \"ACAB\";  \n   cout << \"The operand string is: \" << s6o << endl;  \n   cout << \"The parameter C-string is: \" << cs6p << endl;  \n   comp6a = s6o.compare (  1 , 3 , cs6p , 3 );  \n   if ( comp6a < 0 )  \n      cout << \"The 3 characters from position 1 of \"  \n           << \"the operand string are less than\\n \"  \n           << \"the first 3 characters of the parameter C-string.\"   \n           << endl;  \n   else if ( comp6a == 0 )  \n      cout << \"The 3 characters from position 2 of \"  \n           << \"the operand string are equal to\\n \"  \n           << \"the first 3 characters of the parameter C-string.\"   \n           <<  endl;  \n   else  \n      cout << \"The 3 characters from position 2 of \"  \n           << \"the operand string is greater than\\n \"  \n           << \"the first 3 characters of the parameter C-string.\"   \n           << endl;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe operand string is: CAB  \nThe parameter string is: CAB  \nThe operand string is equal to the parameter string.  \n  \nThe operand string is: AACAB  \nThe parameter string is: CAB  \nThe last three characters of the operand string  \n are equal to the parameter string.  \nThe first three characters of the operand string  \n are less than the parameter string.  \n  \nThe operand string is: AACAB  \nThe parameter string is: DCABD  \nThe three characters from position 2 of the operand string are equal to  \n the 3 characters parameter string from position 1.  \n  \nThe operand string is: ABC  \nThe parameter C-string is: DEF  \nThe operand string is less than the parameter C-string.  \n  \nThe operand string is: AACAB  \nThe parameter string is: CAB  \nThe last three characters of the operand string  \n are equal to the parameter C-string.  \n  \nThe operand string is: AACAB  \nThe parameter C-string is: ACAB  \nThe 3 characters from position 2 of the operand string are equal to  \n the first 3 characters of the parameter C-string.  \n```  \n  \n##  <a name=\"basic_string__const_iterator\"></a>  basic_string::const_iterator  \n A type that provides a random-access iterator that can access and read a **const** element in the string.  \n  \n```  \ntypedef implementation-defined const_iterator;  \n```  \n  \n### Remarks  \n A type `const_iterator` cannot be used to modify the value of a character and is used to iterate through a string in a forward direction.  \n  \n### Example  \n  See the example for [begin](#basic_string__begin) for an example of how to declare and use `const_iterator`.  \n  \n##  <a name=\"basic_string__const_pointer\"></a>  basic_string::const_pointer  \n A type that provides a pointer to a **const** element in a string.  \n  \n```  \ntypedef typename allocator_type::const_pointer const_pointer;  \n```  \n  \n### Remarks  \n The type is a synonym for **allocator_type::const_pointer**.  \n  \n For type **string**, it is equivalent to `char`*.  \n  \n Pointers that are declared const must be initialized when they are declared. Const pointers always point to the same memory location and may point to constant or nonconstant data.  \n  \n### Example  \n  \n```cpp  \n// basic_string_const_ptr.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   basic_string<char>::const_pointer pstr1a = \"In Here\";  \n   const char *cstr1c = \"Out There\";  \n  \n   cout << \"The string pstr1a is: \" << pstr1a <<  \".\" << endl;  \n   cout << \"The C-string cstr1c is: \" << cstr1c << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe string pstr1a is: In Here.  \nThe C-string cstr1c is: Out There.  \n```  \n  \n##  <a name=\"basic_string__const_reference\"></a>  basic_string::const_reference  \n A type that provides a reference to a **const** element stored in a string for reading and performing **const** operations.  \n  \n```  \ntypedef typename allocator_type::const_reference const_reference;  \n```  \n  \n### Remarks  \n A type `const_reference` cannot be used to modify the value of an element.  \n  \n The type is a synonym for **allocator_type::const_reference**. For string **type**, it is equivalent to const **char&**.  \n  \n### Example  \n  See the example for [at](#basic_string__at) for an example of how to declare and use `const_reference`.  \n  \n##  <a name=\"basic_string__const_reverse_iterator\"></a>  basic_string::const_reverse_iterator  \n A type that provides a random-access iterator that can read any **const** element in the string.  \n  \n```  \ntypedef std::reverse_iterator<const_iterator> const_reverse_iterator;  \n```  \n  \n### Remarks  \n A type `const_reverse_iterator` cannot modify the value of a character and is used to iterate through a string in reverse.  \n  \n### Example  \n  See the example for [rbegin](#basic_string__rbegin) for an example of how to declare and use `const_reverse_iterator`.  \n  \n##  <a name=\"basic_string__copy\"></a>  basic_string::copy  \n Copies at most a specified number of characters from an indexed position in a source string to a target character array.  \n  \n This method is potentially unsafe, as it relies on the caller to check that the passed values are correct. Consider using [basic_string::_Copy_s](#basic_string___copy_s) instead.  \n  \n```  \nsize_type copy(\n    value_type* ptr,   \n    size_type count,  \n    size_type _Off = 0) const;\n```  \n  \n### Parameters  \n ` ptr`  \n The target character array to which the elements are to be copied.  \n  \n _ `Count`  \n The number of characters to be copied, at most, from the source string.  \n  \n `_Off`  \n The beginning position in the source string from which copies are to be made.  \n  \n### Return Value  \n The number of characters actually copied.  \n  \n### Remarks  \n A null character is not appended to the end of the copy.  \n  \n### Example  \n  \n```cpp  \n// basic_string_copy.cpp  \n// compile with: /EHsc /W3  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string str1 ( \"Hello World\" );  \n   basic_string <char>::iterator str_Iter;  \n   char array1 [ 20 ] = { 0 };  \n   char array2 [ 10 ] = { 0 };  \n   basic_string <char>:: pointer array1Ptr = array1;  \n   basic_string <char>:: value_type *array2Ptr = array2;  \n  \n   cout << \"The original string str1 is: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n  \n   basic_string <char>:: size_type nArray1;  \n   // Note: string::copy is potentially unsafe, consider  \n   // using string::_Copy_s instead.  \n   nArray1 = str1.copy ( array1Ptr , 12 );  // C4996  \n   cout << \"The number of copied characters in array1 is: \"  \n        << nArray1 << endl;  \n   cout << \"The copied characters array1 is: \" << array1 << endl;  \n  \n   basic_string <char>:: size_type nArray2;  \n   // Note: string::copy is potentially unsafe, consider  \n   // using string::_Copy_s instead.  \n   nArray2 = str1.copy ( array2Ptr , 5 , 6  );  // C4996  \n   cout << \"The number of copied characters in array2 is: \"  \n           << nArray2 << endl;  \n   cout << \"The copied characters array2 is: \" << array2Ptr << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello World  \nThe number of copied characters in array1 is: 11  \nThe copied characters array1 is: Hello World  \nThe number of copied characters in array2 is: 5  \nThe copied characters array2 is: World  \n```  \n  \n##  <a name=\"basic_string__crbegin\"></a>  basic_string::crbegin  \n Returns a const iterator that addresses the first element in a reversed string.  \n  \n```  \nconst_reverse_iterator crbegin() const;\n```  \n  \n### Return Value  \n A reverse iterator that points just beyond the end of the string. The position designates the beginning of the reverse string.  \n  \n##  <a name=\"basic_string__crend\"></a>  basic_string::crend  \n Returns a const iterator that addresses the location succeeding the last element in a reversed string.  \n  \n```  \nconst_reverse_iterator crend() const;\n```  \n  \n### Return Value  \n A const reverse iterator that addresses the location succeeding the last element in a reversed string (the location that had preceded the first element in the unreversed string).  \n  \n### Remarks  \n  \n##  <a name=\"basic_string___copy_s\"></a>  basic_string::_Copy_s  \n Copies at most a specified number of characters from an indexed position in a source string to a target character array.  \n  \n```  \nsize_type _Copy_s(\n    value_type* dest,  \n    size_type dest_size,  \n    size_type count,  \n    size_type _Off = 0) const;\n```  \n  \n### Parameters  \n ` dest`  \n The target character array to which the elements are to be copied.  \n  \n ` dest_size`  \n The size of ` dest`.  \n  \n _ `Count`  \n The number of characters to be copied, at most, from the source string.  \n  \n `_Off`  \n The beginning position in the source string from which copies are to be made.  \n  \n### Return Value  \n The number of characters actually copied.  \n  \n### Remarks  \n A null character is not appended to the end of the copy.  \n  \n### Example  \n  \n```cpp  \n// basic_string__Copy_s.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n    using namespace std;  \n    string str1(\"Hello World\");  \n    basic_string<char>::iterator str_Iter;  \n    const int array1_size = 20;  \n    char array1[array1_size] = { 0 };  \n    const int array2_size = 10;  \n    char array2[array2_size] = { 0 };  \n    basic_string<char>:: pointer array1Ptr = array1;  \n    basic_string<char>:: value_type *array2Ptr = array2;  \n  \n    cout << \"The original string str1 is: \";  \n    for (str_Iter = str1.begin(); str_Iter != str1.end(); str_Iter++)  \n        cout << *str_Iter;  \n    cout << endl;  \n  \n    basic_string<char>::size_type nArray1;  \n    nArray1 = str1._Copy_s(array1Ptr, array1_size, 12);  \n    cout << \"The number of copied characters in array1 is: \"  \n         << nArray1 << endl;  \n    cout << \"The copied characters array1 is: \" << array1 << endl;  \n  \n    basic_string<char>:: size_type nArray2;  \n    nArray2 = str1._Copy_s(array2Ptr, array2_size, 5, 6);  \n    cout << \"The number of copied characters in array2 is: \"  \n         << nArray2 << endl;  \n    cout << \"The copied characters array2 is: \" << array2Ptr << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello World  \nThe number of copied characters in array1 is: 11  \nThe copied characters array1 is: Hello World  \nThe number of copied characters in array2 is: 5  \nThe copied characters array2 is: World  \n```  \n  \n##  <a name=\"basic_string__data\"></a>  basic_string::data  \n Converts the contents of a string into an array of characters.  \n  \n```  \nconst value_type *data() const;\n```  \n  \n### Return Value  \n A pointer to the first element of the array containing the contents of the string, or, for an empty array, a non-null pointer that cannot be dereferenced.  \n  \n### Remarks  \n Objects of type string belonging to the C++ template class basic_string \\<char> are not necessarily null terminated. The return type for **data** is not a valid C-string, because no null character gets appended. The null character ' \\0 ' is used as a special character in a C-string to mark the end of the string, but has no special meaning in an object of type string and may be a part of the string object just like any other character.  \n  \n There is an automatic conversion from const **char\\*** into strings, but the string class does not provide for automatic conversions from C-style strings to objects of type **basic_string \\<char>**.  \n  \n The returned string should not be modified, because this could invalidate the pointer to the string, or deleted, because the string has a limited lifetime and is owned by the class string.  \n  \n### Example  \n  \n```cpp  \n// basic_string_data.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   string str1 ( \"Hello world\" );  \n   cout << \"The original string object str1 is: \"   \n        << str1 << endl;  \n   cout << \"The length of the string object str1 = \"   \n        << str1.length ( ) << endl << endl;  \n  \n   // Converting a string to an array of characters  \n   const char *ptr1 = 0;  \n   ptr1= str1.data ( );  \n   cout << \"The modified string object ptr1 is: \" << ptr1   \n        << endl;  \n   cout << \"The length of character array str1 = \"   \n        << strlen ( ptr1) << endl << endl;  \n  \n   // Converting a string to a C-style string  \n   const char *c_str1 = str1.c_str ( );  \n   cout << \"The C-style string c_str1 is: \" << c_str1   \n        << endl;  \n   cout << \"The length of C-style string str1 = \"   \n        << strlen ( c_str1) << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string object str1 is: Hello world  \nThe length of the string object str1 = 11  \n  \nThe modified string object ptr1 is: Hello world  \nThe length of character array str1 = 11  \n  \nThe C-style string c_str1 is: Hello world  \nThe length of C-style string str1 = 11  \n```  \n  \n##  <a name=\"basic_string__difference_type\"></a>  basic_string::difference_type  \n A type that provides the difference between two iterators that refer to elements within the same string.  \n  \n```  \ntypedef typename allocator_type::difference_type difference_type;  \n```  \n  \n### Remarks  \n The signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence.  \n  \n For type **string**, it is equivalent to **ptrdiff_t**.  \n  \n### Example  \n  \n```cpp  \n// basic_string_diff_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 ( \"quintillion\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexChFi, indexChLi;  \n  \n   indexChFi = str1.find_first_of ( \"i\" );  \n   indexChLi = str1.find_last_of ( \"i\" );  \n   basic_string<char>::difference_type diffi = indexChLi - indexChFi;  \n  \n   cout << \"The first character i is at position: \"  \n        << indexChFi << \".\" << endl;  \n   cout << \"The last character i is at position: \"  \n        << indexChLi << \".\" << endl;  \n   cout << \"The difference is: \" << diffi << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: quintillion  \nThe first character i is at position: 2.  \nThe last character i is at position: 8.  \nThe difference is: 6.  \n```  \n  \n##  <a name=\"basic_string__empty\"></a>  basic_string::empty  \n Tests whether the string contains characters or not.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the string object contains no characters; **false** if it has at least one character.  \n  \n### Remarks  \n The member function is equivalent to [size](#basic_string__size) == 0.  \n  \n### Example  \n  \n```cpp  \n// basic_string_empty.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n  \n   bool b1, b2;  \n  \n   string str1 (\"Hello world\");  \n   cout << \"The original string object str1 is: \" << str1 << endl;  \n   b1 = str1.empty();  \n   if (b1)  \n      cout << \"The string object str1 is empty.\" << endl;  \n   else  \n      cout << \"The string object str1 is not empty.\" << endl;  \n   cout << endl;  \n  \n   // An example of an empty string object  \n   string str2;  \n   b2 = str2.empty();  \n   if (b2)  \n      cout << \"The string object str2 is empty.\" << endl;  \n   else  \n      cout << \"The string object str2 is not empty.\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__end\"></a>  basic_string::end  \n Returns an iterator that addresses the location succeeding the last element in a string.  \n  \n```  \nconst_iterator end() const;\n\n \niterator end();\n```  \n  \n### Return Value  \n Returns a random-access iterator that addresses the location succeeding the last element in a string.  \n  \n### Remarks  \n **end** is often used to test whether an iterator has reached the end of its string. The value returned by **end** should not be dereferenced.  \n  \n If the return value of **end** is assigned to a `const_iterator`, the string object cannot be modified. If the return value of **end** is assigned to an **iterator**, the string object can be modified.  \n  \n### Example  \n  \n```cpp  \n// basic_string_end.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 ( \"No way out.\" ), str2;  \n   basic_string <char>::iterator str_Iter, str1_Iter, str2_Iter;  \n   basic_string <char>::const_iterator str1_cIter;  \n  \n   str1_Iter = str1.end ( );  \n   str1_Iter--;  \n   str1_Iter--;  \n   cout << \"The last character-letter of the string str1 is: \" << *str1_Iter << endl;  \n   cout << \"The full orginal string str1 is: \" << str1 << endl;  \n  \n   // end used to test when an iterator has reached the end of its string  \n   cout << \"The string is now: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n  \n   // The dereferenced iterator can be used to modify a character  \n *str1_Iter = 'T';  \n   cout << \"The last character-letter of the modified str1 is now: \"  \n        << *str1_Iter << endl;  \n   cout << \"The modified string str1 is now: \" << str1 << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *str1_cIter = 'T';  \n  \n   // For an empty string, end is equivalent to begin  \n   if ( str2.begin( ) == str2.end ( ) )  \n      cout << \"The string str2 is empty.\" << endl;  \n   else  \n      cout << \"The stringstr2  is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe last character-letter of the string str1 is: t  \nThe full orginal string str1 is: No way out.  \nThe string is now: No way out.  \nThe last character-letter of the modified str1 is now: T  \nThe modified string str1 is now: No way ouT.  \nThe string str2 is empty.  \n```  \n  \n##  <a name=\"basic_string__erase\"></a>  basic_string::erase  \n Removes an element or a range of elements in a string from a specified position.  \n  \n```  \niterator erase(\n    iterator first,   \n    iterator last);\n\niterator erase(\n    iterator _It);\n\nbasic_string<CharType, Traits, Allocator>& erase(\n    size_type _Pos = 0,  \n    size_type count = npos);\n```  \n  \n### Parameters  \n ` first`  \n An iterator addressing the position of the first element in the range to be erased.  \n  \n ` last`  \n An iterator addressing the position one past the last element in the range to be erased.  \n  \n `_It`  \n An iterator addressing the position of the element in the string to be erased.  \n  \n `_Pos`  \n The index of the first character in the string to be removed.  \n  \n ` count`  \n The number of elements that will be removed if there are as many in the range of the string beginning with *_Pos*.  \n  \n### Return Value  \n For the first two member functions, an iterator addressing the first character after the last character removed by the member function. For the third member function, a reference to the string object from which the elements have been erased.  \n  \n### Remarks  \n The third member function returns **\\*this**.  \n  \n### Example  \n  \n```cpp  \n// basic_string_erase.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The 1st member function using a range demarcated  \n   // by iterators  \n   string str1 ( \"Hello world\" );  \n   basic_string <char>::iterator str1_Iter;  \n   cout << \"The original string object str1 is: \"   \n        << str1 << \".\" << endl;  \n   str1_Iter = str1.erase ( str1.begin ( ) + 3 , str1.end ( ) - 1 );  \n   cout << \"The first element after those removed is: \"  \n        << *str1_Iter << \".\" << endl;  \n   cout << \"The modified string object str1 is: \" << str1   \n           << \".\" << endl << endl;  \n  \n   // The 2nd member function erasing a char pointed to   \n   // by an iterator  \n   string str2 ( \"Hello World\" );  \n   basic_string <char>::iterator str2_Iter;  \n   cout << \"The original string object str2 is: \" << str2  \n        << \".\" << endl;  \n   str2_Iter = str2.erase ( str2.begin ( ) + 5 );  \n   cout << \"The first element after those removed is: \"  \n        << *str2_Iter << \".\" << endl;  \n   cout << \"The modified string object str2 is: \" << str2   \n        << \".\" << endl << endl;  \n  \n   // The 3rd member function erasing a number of chars   \n   // after a char  \n   string str3 ( \"Hello computer\" ), str3m;  \n   basic_string <char>::iterator str3_Iter;  \n   cout << \"The original string object str3 is: \"   \n        << str3 << \".\" << endl;  \n   str3m = str3.erase ( 6 , 8 );  \n   cout << \"The modified string object str3m is: \"   \n        << str3m << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original string object str1 is: Hello world.  \nThe first element after those removed is: d.  \nThe modified string object str1 is: Held.  \n  \nThe original string object str2 is: Hello World.  \nThe first element after those removed is: W.  \nThe modified string object str2 is: HelloWorld.  \n  \nThe original string object str3 is: Hello computer.  \nThe modified string object str3m is: Hello .  \n```  \n  \n##  <a name=\"basic_string__find\"></a>  basic_string::find  \n Searches a string in a forward direction for the first occurrence of a substring that matches a specified sequence of characters.  \n  \n```  \nsize_type find(\n    value_type _Ch,   \n    size_type _Off = 0) const;\n\n \nsize_type find(\n    const value_type* ptr,  \n    size_type _Off = 0) const;\n\n \nsize_type find(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \nsize_type find(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = 0) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to begin.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the first character of the substring searched for when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_find.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"Hello Everyone\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n  \n   indexCh1a = str1.find ( \"e\" , 3 );  \n   if (indexCh1a != string::npos )  \n      cout << \"The index of the 1st 'e' found after the 3rd\"  \n           << \" position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The character 'e' was not found in str1 .\" << endl;  \n  \n   indexCh1b = str1.find ( \"x\" );  \n   if (indexCh1b != string::npos )  \n      cout << \"The index of the 'x' found in str1 is: \"  \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The Character 'x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for a substring as specified by a C-string  \n   string str2 ( \"Let me make this perfectly clear.\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"perfect\";  \n   indexCh2a = str2.find ( cstr2 , 5 );  \n   if ( indexCh2a != string::npos )  \n      cout << \"The index of the 1st element of 'perfect' \"  \n           << \"after\\n the 5th position in str2 is: \"  \n           << indexCh2a << endl;  \n   else  \n      cout << \"The substring 'perfect' was not found in str2 .\"  \n           << endl;  \n  \n   const char *cstr2b = \"imperfectly\";  \n   indexCh2b = str2.find ( cstr2b , 0 );  \n   if (indexCh2b != string::npos )  \n      cout << \"The index of the 1st element of 'imperfect' \"  \n           << \"after\\n the 5th position in str3 is: \"  \n           << indexCh2b << endl;  \n   else  \n      cout << \"The substring 'imperfect' was not found in str2 .\"  \n           << endl << endl;  \n  \n   // The third member function searches a string  \n   // for a substring as specified by a C-string  \n   string str3 ( \"This is a sample string for this program\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a, indexCh3b;  \n  \n   const char *cstr3a = \"sample\";  \n   indexCh3a = str3.find ( cstr3a );  \n   if ( indexCh3a != string::npos )  \n      cout << \"The index of the 1st element of sample \"  \n           << \"in str3 is: \" << indexCh3a << endl;  \n   else  \n      cout << \"The substring 'perfect' was not found in str3 .\"  \n           << endl;  \n  \n   const char *cstr3b = \"for\";  \n   indexCh3b = str3.find ( cstr3b , indexCh3a + 1 , 2 );  \n   if (indexCh3b != string::npos )  \n      cout << \"The index of the next occurrence of 'for' is in \"  \n           << \"str3 begins at: \" << indexCh3b << endl << endl;  \n   else  \n      cout << \"There is no next occurrence of 'for' in str3 .\"  \n           << endl << endl;  \n  \n   // The fourth member function searches a string  \n   // for a substring as specified by a string  \n   string str4 ( \"clearly this perfectly unclear.\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"clear\" );  \n   indexCh4a = str4.find ( str4a , 5 );  \n   if ( indexCh4a != string::npos )  \n      cout << \"The index of the 1st element of 'clear' \"  \n           << \"after\\n the 5th position in str4 is: \"  \n           << indexCh4a << endl;  \n   else  \n      cout << \"The substring 'clear' was not found in str4 .\"  \n           << endl;  \n  \n   string str4b ( \"clear\" );  \n   indexCh4b = str4.find ( str4b );  \n   if (indexCh4b != string::npos )  \n      cout << \"The index of the 1st element of 'clear' \"  \n           << \"in str4 is: \"  \n           << indexCh4b << endl;  \n   else  \n      cout << \"The substring 'clear' was not found in str4 .\"  \n           << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello Everyone  \nThe index of the 1st 'e' found after the 3rd position in str1 is: 8  \nThe Character 'x' was not found in str1.  \n  \nThe original string str2 is: Let me make this perfectly clear.  \nThe index of the 1st element of 'perfect' after  \n the 5th position in str2 is: 17  \nThe substring 'imperfect' was not found in str2 .  \n  \nThe original string str3 is: This is a sample string for this program  \nThe index of the 1st element of sample in str3 is: 10  \nThe index of the next occurrence of 'for' is in str3 begins at: 24  \n  \nThe original string str4 is: clearly this perfectly unclear.  \nThe index of the 1st element of 'clear' after  \n the 5th position in str4 is: 25  \nThe index of the 1st element of 'clear' in str4 is: 0  \n```  \n  \n##  <a name=\"basic_string__find_first_not_of\"></a>  basic_string::find_first_not_of  \n Searches through a string for the first character that is not an element of a specified string.  \n  \n```  \nsize_type find_first_not_of(\n    value_type _Ch,   \n    size_type _Off = 0) const;\n\n \nsize_type find_first_not_of(\n    const value_type* ptr,  \n    size_type _Off = 0) const;\n\n \nsize_type find_first_not_of(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \nsize_type find_first_not_of(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = 0) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to begin.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the first character of the substring searched for when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_find_first_not_of.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"xddd-1234-abcd\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n   static const basic_string <char>::size_type npos = -1;  \n  \n   indexCh1a = str1.find_first_not_of ( \"d\" , 2 );  \n   if ( indexCh1a != npos )  \n      cout << \"The index of the 1st 'd' found after the 3rd\"  \n           << \" position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The character 'd' was not found in str1 .\" << endl;  \n  \n   indexCh1b = str1.find_first_not_of  ( \"x\" );  \n   if (indexCh1b != npos )  \n      cout << \"The index of the 'non x' found in str1 is: \"   \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The character 'non x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for a substring as specified by a C-string  \n   string str2 ( \"BBB-1111\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"B1\";  \n   indexCh2a = str2.find_first_not_of ( cstr2 , 6 );  \n   if ( indexCh2a != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element of 'B1' in str2 after\\n the 6th \"  \n           << \"position is: \" << indexCh2a << endl;  \n   else  \n      cout << \"Elements of the substring 'B1' were not\"  \n           << \"\\n found in str2 after the 6th position.\"  \n           << endl;  \n  \n   const char *cstr2b = \"B2\";  \n   indexCh2b = str2.find_first_not_of ( cstr2b );  \n   if ( indexCh2b != npos )  \n      cout << \"The index of the 1st element of 'B2' \"  \n           << \"after\\n the 0th position in str2 is: \"  \n           << indexCh2b << endl << endl;  \n   else  \n      cout << \"The substring 'B2' was not found in str2 .\"   \n           << endl << endl << endl;  \n  \n   // The third member function searches a string  \n   // for a substring as specified by a C-string  \n   string str3 ( \"444-555-GGG\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a, indexCh3b;  \n  \n   const char *cstr3a = \"45G\";  \n   indexCh3a = str3.find_first_not_of ( cstr3a );  \n   if ( indexCh3a != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element in str3\\n other than one of the \"  \n           << \"characters in '45G' is: \" << indexCh3a   \n           << endl;  \n   else  \n      cout << \"Elements in str3 contain only characters \"  \n           << \" in the string '45G'. \"  \n           << endl;  \n  \n   const char *cstr3b = \"45G\";  \n   indexCh3b = str3.find_first_not_of ( cstr3b , indexCh3a + 1 , 2 );  \n   if ( indexCh3b != npos )  \n      cout << \"The index of the second occurrence of an \"  \n           << \"element of '45G' in str3\\n after the 0th \"  \n           << \"position is: \" << indexCh3b << endl << endl;  \n   else  \n      cout << \"Elements in str3 contain only characters \"  \n           << \" in the string  '45G'. \"  \n           << endl  << endl;  \n  \n   // The fourth member function searches a string  \n   // for a substring as specified by a string  \n   string str4 ( \"12-ab-12-ab\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"ba3\" );  \n   indexCh4a = str4.find_first_not_of ( str4a , 5 );  \n   if (indexCh4a != npos )  \n      cout << \"The index of the 1st non occurrence of an \"  \n           << \"element of 'ba3' in str4 after\\n the 5th \"  \n           << \"position is: \" << indexCh4a << endl;  \n   else  \n      cout << \"Elements other than those in the substring\"  \n           << \" 'ba3' were not found in the string str4.\"  \n           << endl;  \n  \n   string str4b ( \"12\" );  \n   indexCh4b = str4.find_first_not_of ( str4b  );  \n   if (indexCh4b != npos )  \n      cout << \"The index of the 1st non occurrence of an \"  \n           << \"element of '12' in str4 after\\n the 0th \"  \n           << \"position is: \" << indexCh4b << endl;  \n   else  \n      cout << \"Elements other than those in the substring\"  \n           << \" '12' were not found in the string str4.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: xddd-1234-abcd  \nThe index of the 1st 'd' found after the 3rd position in str1 is: 4  \nThe index of the 'non x' found in str1 is: 1  \n  \nThe original string str2 is: BBB-1111  \nElements of the substring 'B1' were not  \n found in str2 after the 6th position.  \nThe index of the 1st element of 'B2' after  \n the 0th position in str2 is: 3  \n  \nThe original string str3 is: 444-555-GGG  \nThe index of the 1st occurrence of an element in str3  \n other than one of the characters in '45G' is: 3  \nThe index of the second occurrence of an element of '45G' in str3  \n after the 0th position is: 7  \n  \nThe original string str4 is: 12-ab-12-ab  \nThe index of the 1st non occurrence of an element of 'ba3' in str4 after  \n the 5th position is: 5  \nThe index of the 1st non occurrence of an element of '12' in str4 after  \n the 0th position is: 2  \n```  \n  \n##  <a name=\"basic_string__find_first_of\"></a>  basic_string::find_first_of  \n Searches through a string for the first character that matches any element of a specified string.  \n  \n```  \nsize_type find_first_of(\n    value_type _Ch,   \n    size_type _Off = 0) const;\n\n \nsize_type find_first_of(\n    const value_type* ptr,  \n    size_type _Off = 0) const;\n\n \nsize_type find_first_of(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \nsize_type find_first_of(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = 0) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to begin.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the first character of the substring searched for when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_find_first_of.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"abcd-1234-abcd-1234\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n   static const basic_string <char>::size_type npos = -1;  \n  \n   indexCh1a = str1.find_first_of ( \"d\" , 5 );  \n   if ( indexCh1a != npos )  \n      cout << \"The index of the 1st 'd' found after the 5th\"  \n           << \" position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The character 'd' was not found in str1 .\" << endl;  \n  \n   indexCh1b = str1.find_first_of ( \"x\" );  \n   if ( indexCh1b != npos )  \n      cout << \"The index of the 'x' found in str1 is: \"   \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The character 'x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for any element of a substring as specified by a C-string  \n   string str2 ( \"ABCD-1234-ABCD-1234\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"B1\";  \n   indexCh2a = str2.find_first_of ( cstr2 , 6 );  \n   if ( indexCh2a != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element of 'B1' in str2 after\\n the 6th \"  \n           << \"position is: \" << indexCh2a << endl;  \n   else  \n      cout << \"Elements of the substring 'B1' were not \"  \n           << \"found in str2 after the 10th position.\"  \n           << endl;  \n  \n   const char *cstr2b = \"D2\";  \n   indexCh2b = str2.find_first_of ( cstr2b );  \n   if ( indexCh2b != npos )  \n      cout << \"The index of the 1st element of 'D2' \"  \n           << \"after\\n the 0th position in str2 is: \"  \n           << indexCh2b << endl << endl;  \n   else  \n      cout << \"The substring 'D2' was not found in str2 .\"   \n           << endl << endl << endl;  \n  \n   // The third member function searches a string  \n   // for any element of a substring as specified by a C-string  \n   string str3 ( \"123-abc-123-abc-456-EFG-456-EFG\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a, indexCh3b;  \n  \n   const char *cstr3a = \"5G\";  \n   indexCh3a = str3.find_first_of ( cstr3a );  \n   if ( indexCh3a != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element of '5G' in str3 after\\n the 0th \"  \n           << \"position is: \" << indexCh3a << endl;  \n   else  \n      cout << \"Elements of the substring '5G' were not \"  \n           << \"found in str3\\n after the 0th position.\"  \n           << endl;  \n  \n   const char *cstr3b = \"5GF\";  \n   indexCh3b = str3.find_first_of  ( cstr3b , indexCh3a + 1 , 2 );  \n   if (indexCh3b != npos )  \n      cout << \"The index of the second occurrence of an \"  \n           << \"element of '5G' in str3\\n after the 0th \"  \n           << \"position is: \" << indexCh3b << endl << endl;  \n   else  \n      cout << \"Elements of the substring '5G' were not \"  \n           << \"found in str3\\n after the first occurrrence.\"  \n           << endl << endl;  \n  \n   // The fourth member function searches a string  \n   // for any element of a substring as specified by a string  \n   string str4 ( \"12-ab-12-ab\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"ba3\" );  \n   indexCh4a = str4.find_first_of ( str4a , 5 );  \n   if ( indexCh4a != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element of 'ba3' in str4 after\\n the 5th \"  \n           << \"position is: \" << indexCh4a << endl;  \n   else  \n      cout << \"Elements of the substring 'ba3' were not \"  \n           << \"found in str4\\n after the 0th position.\"  \n           << endl;  \n  \n   string str4b ( \"a2\" );  \n   indexCh4b = str4.find_first_of ( str4b );  \n   if ( indexCh4b != npos )  \n      cout << \"The index of the 1st occurrence of an \"  \n           << \"element of 'a2' in str4 after\\n the 0th \"  \n           << \"position is: \" << indexCh4b << endl;  \n   else  \n      cout << \"Elements of the substring 'a2' were not \"  \n           << \"found in str4\\n after the 0th position.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: abcd-1234-abcd-1234  \nThe index of the 1st 'd' found after the 5th position in str1 is: 13  \nThe character 'x' was not found in str1.  \n  \nThe original string str2 is: ABCD-1234-ABCD-1234  \nThe index of the 1st occurrence of an element of 'B1' in str2 after  \n the 6th position is: 11  \nThe index of the 1st element of 'D2' after  \n the 0th position in str2 is: 3  \n  \nThe original string str3 is: 123-abc-123-abc-456-EFG-456-EFG  \nThe index of the 1st occurrence of an element of '5G' in str3 after  \n the 0th position is: 17  \nThe index of the second occurrence of an element of '5G' in str3  \n after the 0th position is: 22  \n  \nThe original string str4 is: 12-ab-12-ab  \nThe index of the 1st occurrence of an element of 'ba3' in str4 after  \n the 5th position is: 9  \nThe index of the 1st occurrence of an element of 'a2' in str4 after  \n the 0th position is: 1  \n```  \n  \n##  <a name=\"basic_string__find_last_not_of\"></a>  basic_string::find_last_not_of  \n Searches through a string for the last character that is not any element of a specified string.  \n  \n```  \nsize_type find_last_not_of(\n    value_type _Ch,   \n    size_type _Off = npos) const;\n\n \nsize_type find_last_not_of(\n    const value_type* ptr,  \n    size_type _Off = npos) const;\n\n \nsize_type find_last_not_of(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \nsize_type find_last_not_of(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = npos) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to finish.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the first character of the substring searched for when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_find_last_not_of.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"dddd-1dd4-abdd\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n   static const basic_string <char>::size_type npos = -1;  \n  \n   indexCh1a = str1.find_last_not_of ( \"d\" , 7 );  \n   if ( indexCh1a != npos )  \n      cout << \"The index of the last non 'd'\\n found before the \"  \n           << \"7th position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The non 'd' character was not found .\" << endl;  \n  \n   indexCh1b = str1.find_last_not_of  ( \"d\" );  \n   if ( indexCh1b != npos )  \n      cout << \"The index of the non 'd' found in str1 is: \"   \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The Character 'non x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for a substring as specified by a C-string  \n   string str2 ( \"BBB-1111\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"B1\";  \n   indexCh2a = str2.find_last_not_of  ( cstr2 , 6 );  \n   if ( indexCh2a != npos )  \n      cout << \"The index of the last occurrence of a \"  \n           << \"element\\n not of 'B1' in str2 before the 6th \"  \n           << \"position is: \" << indexCh2a << endl;  \n   else  \n      cout << \"Elements not of the substring 'B1' were not \"  \n           << \"\\n found in str2 before the 6th position.\"  \n           << endl;  \n  \n   const char *cstr2b = \"B-1\";  \n   indexCh2b = str2.find_last_not_of  ( cstr2b );  \n   if ( indexCh2b != npos )  \n      cout << \"The index of the last element not \"  \n           << \"in 'B-1'\\n is: \"  \n           << indexCh2b << endl << endl;  \n   else  \n      cout << \"The elements of the substring 'B-1' were \"  \n           << \"not found in str2 .\"   \n           << endl << endl;  \n  \n   // The third member function searches a string  \n   // for a substring as specified by a C-string  \n   string str3 ( \"444-555-GGG\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a, indexCh3b;  \n  \n   const char *cstr3a = \"45G\";  \n   indexCh3a = str3.find_last_not_of ( cstr3a );  \n   if ( indexCh3a != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element in str3\\n other than one of the \"  \n           << \"characters in '45G' is: \" << indexCh3a   \n           << endl;  \n   else  \n      cout << \"Elements in str3 contain only characters \"  \n           << \" in the string  '45G'. \"  \n           << endl;  \n  \n   const char *cstr3b = \"45G\";  \n   indexCh3b = str3.find_last_not_of ( cstr3b , 6 , indexCh3a - 1 );  \n   if (indexCh3b != npos )  \n      cout << \"The index of the penultimate occurrence of an \"  \n           << \"element\\n not in '45G' in str3 is: \"  \n           << indexCh3b << endl << endl;  \n   else  \n      cout << \"Elements in str3 contain only characters \"  \n           << \" in the string '45G'. \"  \n           << endl  << endl;  \n  \n   // The fourth member function searches a string  \n   // for a substring as specified by a string  \n   string str4 ( \"12-ab-12-ab\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"b-a\" );  \n   indexCh4a = str4.find_last_not_of  ( str4a , 5 );  \n   if ( indexCh4a != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element not\\n in 'b-a' in str4 before the 5th \"  \n           << \"position is: \" << indexCh4a << endl;  \n   else  \n      cout << \"Elements other than those in the substring\"  \n           << \" 'b-a' were not found in the string str4.\"  \n           << endl;  \n  \n   string str4b ( \"12\" );  \n   indexCh4b = str4.find_last_not_of ( str4b  );  \n   if ( indexCh4b != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element not in '12'\\n in str4 before the end \"  \n           << \"position is: \" << indexCh4b << endl;  \n   else  \n      cout << \"Elements other than those in the substring\"  \n           << \" '12'\\n were not found in the string str4.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: dddd-1dd4-abdd  \nThe index of the last non 'd'  \n found before the 7th position in str1 is: 5  \nThe index of the non 'd' found in str1 is: 11  \n  \nThe original string str2 is: BBB-1111  \nThe index of the last occurrence of a element  \n not of 'B1' in str2 before the 6th position is: 3  \nThe elements of the substring 'B-1' were not found in str2 .  \n  \nThe original string str3 is: 444-555-GGG  \nThe index of the last occurrence of an element in str3  \n other than one of the characters in '45G' is: 7  \nThe index of the penultimate occurrence of an element  \n not in '45G' in str3 is: 3  \n  \nThe original string str4 is: 12-ab-12-ab  \nThe index of the last occurrence of an element not  \n in 'b-a' in str4 before the 5th position is: 1  \nThe index of the last occurrence of an element not in '12'  \n in str4 before the end position is: 10  \n```  \n  \n##  <a name=\"basic_string__find_last_of\"></a>  basic_string::find_last_of  \n Searches through a string for the last character that matches any element of a specified string.  \n  \n```  \nsize_type find_last_of(\n    value_type _Ch,   \n    size_type _Off = npos) const;\n\n \n \nsize_type find_last_of(\n    const value_type* ptr,  \n    size_type _Off = npos) const;\n\n \n \nsize_type find_last_of(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \n \nsize_type find_last_of(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = npos) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to finish.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the last character of the substring searched for when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_find_last_of.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"abcd-1234-abcd-1234\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n   static const basic_string <char>::size_type npos = -1;  \n  \n   indexCh1a = str1.find_last_of ( \"d\" , 14 );  \n   if ( indexCh1a != npos )  \n      cout << \"The index of the last 'd' found before the 14th\"  \n           << \" position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The character 'd' was not found in str1 .\" << endl;  \n  \n   indexCh1b = str1.find_first_of ( \"x\" );  \n   if ( indexCh1b != npos )  \n      cout << \"The index of the 'x' found in str1 is: \"  \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The character 'x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for a substring as specified by a C-string  \n   string str2 ( \"ABCD-1234-ABCD-1234\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"B1\";  \n   indexCh2a = str2.find_last_of  ( cstr2 , 12 );  \n   if (indexCh2a != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element of 'B1' in str2 before\\n the 12th \"  \n           << \"position is: \" << indexCh2a << endl;  \n   else  \n      cout << \"Elements of the substring 'B1' were not \"  \n           << \"found in str2 before the 12th position.\"  \n           << endl;  \n  \n   const char *cstr2b = \"D2\";  \n   indexCh2b = str2.find_last_of  ( cstr2b );  \n   if ( indexCh2b != npos )  \n      cout << \"The index of the last element of 'D2' \"  \n           << \"after\\n the 0th position in str2 is: \"  \n           << indexCh2b << endl << endl;  \n   else  \n      cout << \"The substring 'D2' was not found in str2 .\"  \n           << endl << endl << endl;  \n  \n   // The third member function searches a string  \n   // for a substring as specified by a C-string  \n   string str3 ( \"456-EFG-456-EFG\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a;  \n  \n   const char *cstr3a = \"5E\";  \n   indexCh3a = str3.find_last_of ( cstr3a , 8 , 8 );  \n   if ( indexCh3a != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element of '5E' in str3 before\\n the 8th \"  \n           << \"position is: \" << indexCh3a << endl << endl;  \n   else  \n      cout << \"Elements of the substring '5G' were not \"  \n           << \"found in str3\\n before the 8th position.\"  \n           << endl << endl;  \n  \n   // The fourth member function searches a string  \n   // for a substring as specified by a string  \n   string str4 ( \"12-ab-12-ab\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"ba3\" );  \n   indexCh4a = str4.find_last_of  ( str4a , 8 );  \n   if ( indexCh4a != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element of 'ba3' in str4 before\\n the 8th \"  \n           << \"position is: \" << indexCh4a << endl;  \n   else  \n      cout << \"Elements of the substring 'ba3' were not \"  \n           << \"found in str4\\n after the 0th position.\"  \n           << endl;  \n  \n   string str4b ( \"a2\" );  \n   indexCh4b = str4.find_last_of ( str4b  );  \n   if ( indexCh4b != npos )  \n      cout << \"The index of the last occurrence of an \"  \n           << \"element of 'a2' in str4 before\\n the 0th \"  \n           << \"position is: \" << indexCh4b << endl;  \n   else  \n      cout << \"Elements of the substring 'a2' were not \"  \n           << \"found in str4\\n after the 0th position.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: abcd-1234-abcd-1234  \nThe index of the last 'd' found before the 14th position in str1 is: 13  \nThe character 'x' was not found in str1.  \n  \nThe original string str2 is: ABCD-1234-ABCD-1234  \nThe index of the last occurrence of an element of 'B1' in str2 before  \n the 12th position is: 11  \nThe index of the last element of 'D2' after  \n the 0th position in str2 is: 16  \n  \nThe original string str3 is: 456-EFG-456-EFG  \nThe index of the last occurrence of an element of '5E' in str3 before  \n the 8th position is: 4  \n  \nThe original string str4 is: 12-ab-12-ab  \nThe index of the last occurrence of an element of 'ba3' in str4 before  \n the 8th position is: 4  \nThe index of the last occurrence of an element of 'a2' in str4 before  \n the 0th position is: 9  \n```  \n  \n##  <a name=\"basic_string__front\"></a>  basic_string::front  \n Returns a reference to the first element in a string.  \n  \n```  \nconst_reference front() const;\n\n \nreference front();\n```  \n  \n### Return Value  \n A reference to the first element of the string, which must be non-empty.  \n  \n### Remarks  \n  \n##  <a name=\"basic_string__get_allocator\"></a>  basic_string::get_allocator  \n Returns a copy of the allocator object used to construct the string.  \n  \n```  \nallocator_type get_allocator() const;\n```  \n  \n### Return Value  \n The allocator used by the string.  \n  \n### Remarks  \n The member function returns the stored allocator object.  \n  \n Allocators for the string class specify how the class manages storage. The default allocators supplied with container classes are sufficient for most programming needs. Writing and using your own allocator class is an advanced C++ topic.  \n  \n### Example  \n  \n```cpp  \n// basic_string_get_allocator.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // The following lines declare objects  \n   // that use the default allocator.  \n   string s1;  \n   basic_string <char> s2;  \n   basic_string <char, char_traits< char >, allocator< char > > s3;  \n  \n   // s4 will use the same allocator class as s1  \n   basic_string <char> s4( s1.get_allocator ( ) );  \n  \n   basic_string <char>::allocator_type xchar = s1.get_allocator( );  \n   // You can now call functions on the allocator class xchar used by s1  \n}  \n```  \n  \n##  <a name=\"basic_string__insert\"></a>  basic_string::insert  \n Inserts an element or a number of elements or a range of elements into the string at a specified position.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& insert(\n    size_type _P0,   \n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& insert(\n    size_type _P0,   \n    const value_type* ptr,  \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& insert(\n    size_type _P0,  \n    const basic_string<CharType, Traits, Allocator>& str);\n\nbasic_string<CharType, Traits, Allocator>& insert(\n    size_type _P0,  \n    const basic_string<CharType, Traits, Allocator>& str,   \n    size_type _Off,   \n    size_type count);\n\nbasic_string<CharType, Traits, Allocator>& insert(\n    size_type _P0,  \n    size_type count,   \n    value_type _Ch);\n\niterator insert(\n    iterator _It);\n\niterator insert(\n    iterator _It,  \n    value_type _Ch)l  \ntemplate <class InputIterator>  \nvoid insert(\n    iterator _It,   \n    InputIterator first,   \n    InputIterator last);\n\nvoid insert(\n    iterator _It,   \n    size_type count,   \n    value_type _Ch);\n\nvoid insert(\n    iterator _It,  \n    const_pointer first,  \n    const_pointer last);\n\nvoid insert(\n    iterator _It,  \n    const_iterator first,  \n    const_iterator last);\n```  \n  \n### Parameters  \n *_P0*  \n The index of the position behind the point of insertion the new characters.  \n  \n ` ptr`  \n The C-string to be wholly or partly inserted into the string.  \n  \n ` count`  \n The number of characters to be inserted.  \n  \n ` str`  \n The string to be wholly or partly inserted into the target string.  \n  \n `_Off`  \n The index of the part of the source string supplying the characters to be appended.  \n  \n `_Ch`  \n The character value of the elements to be inserted.  \n  \n `_It`  \n An iterator addressing the position behind which a character is to be inserted.  \n  \n ` first`  \n An input iterator, const_pointer, or const_iterator addressing the first element in the source range to be inserted.  \n  \n ` last`  \n An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the source range to be inserted.  \n  \n### Return Value  \n Either a reference to the string object that is being assigned new characters by the member function or, in the case of individual character insertions, an iterator addressing the position of the character inserted, or none, depending on the particular member function.  \n  \n### Example  \n  \n```cpp  \n// basic_string_insert.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function inserting a C-string  \n   // at a given position  \n   basic_string <char> str1a ( \"way\" );  \n   const char *cstr1a = \"a\";  \n   str1a.insert ( 0, cstr1a );  \n   cout << \"The string with a C-string inserted at position 0 is: \"  \n        << str1a << \".\" << endl;  \n  \n   // The second member function inserting a C-string  \n   // at a given position for a specified number of elements  \n   basic_string <char> str2a ( \"Good\" );  \n   const char *cstr2a = \"Bye Bye Baby\";  \n   str2a.insert ( 4, cstr2a ,3 );  \n   cout << \"The string with a C-string inserted at the end is: \"  \n        << str2a << \".\" << endl;  \n  \n   // The third member function inserting a string  \n   // at a given position  \n   basic_string <char> str3a ( \"Bye\" );  \n   string str3b ( \"Good\" );  \n   str3a.insert ( 0, str3b );  \n   cout << \"The string with a string inserted at position 0 is: \"  \n        << str3a << \".\" << endl;  \n  \n   // The fourth member function inserting part of  \n   // a string at a given position  \n   basic_string <char> str4a ( \"Good \" );  \n   string str4b ( \"Bye Bye Baby\" );  \n   str4a.insert ( 5, str4b , 8 , 4 );  \n   cout << \"The string with part of a string inserted at position 4 is: \"  \n        << str4a << \".\" << endl;  \n  \n   // The fifth member function inserts a number of characters  \n   // at a specified position in the string  \n   string str5 ( \"The number is: .\" );  \n   str5.insert ( 15 , 3 , '3' );  \n   cout << \"The string with characters inserted is: \"  \n        << str5 << endl;  \n  \n   // The sixth member function inserts a character  \n   // at a specified position in the string  \n   string str6 ( \"ABCDFG\" );  \n   basic_string <char>::iterator str6_Iter = ( str6.begin ( ) + 4 );  \n   str6.insert ( str6_Iter , 'e' );  \n   cout << \"The string with a character inserted is: \"  \n        << str6 << endl;  \n  \n   // The seventh member function inserts a range  \n   // at a specified position in the string  \n   string str7a ( \"ABCDHIJ\" );  \n   string str7b ( \"abcdefgh\" );  \n   basic_string <char>::iterator str7a_Iter = (str7a.begin ( ) + 4 );  \n   str7a.insert ( str7a_Iter , str7b.begin ( ) + 4 , str7b.end ( ) -1 );  \n   cout << \"The string with a character inserted from a range is: \"  \n        << str7a << endl;  \n  \n   // The eigth member function inserts a number of  \n   // characters at a specified position in the string  \n   string str8 ( \"ABCDHIJ\" );  \n   basic_string <char>::iterator str8_Iter = ( str8.begin ( ) + 4 );  \n   str8.insert ( str8_Iter , 3 , 'e' );  \n   cout << \"The string with a character inserted from a range is: \"  \n        << str8 << endl;  \n}  \n```  \n  \n```Output  \nThe string with a C-string inserted at position 0 is: away.  \nThe string with a C-string inserted at the end is: GoodBye.  \nThe string with a string inserted at position 0 is: GoodBye.  \nThe string with part of a string inserted at position 4 is: Good Baby.  \nThe string with characters inserted is: The number is: 333.  \nThe string with a character inserted is: ABCDeFG  \nThe string with a character inserted from a range is: ABCDefgHIJ  \nThe string with a character inserted from a range is: ABCDeeeHIJ  \n```  \n  \n##  <a name=\"basic_string__iterator\"></a>  basic_string::iterator  \n A type that provides a random-access iterator that can access and read a **const** element in the string.  \n  \n```  \ntypedef implementation-defined iterator;  \n```  \n  \n### Remarks  \n A type **iterator** can be used to modify the value of a character and is used to iterate through a string in a forward direction.  \n  \n### Example  \n  See the example for [begin](#basic_string__begin) for an example of how to declare and use **iterator**.  \n  \n##  <a name=\"basic_string__length\"></a>  basic_string::length  \n Returns the current number of elements in a string.  \n  \n```  \nsize_type length() const;\n```  \n  \n### Remarks  \n The member function is the same as [size](#basic_string__size).  \n  \n### Example  \n  \n```cpp  \n// basic_string_length.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 (\"Hello world\");  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   // The size and length member functions differ in name only  \n   basic_string <char>::size_type sizeStr1, lenStr1;  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n  \n   basic_string <char>::size_type capStr1, max_sizeStr1;  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of original string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of original string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl << endl;  \n  \n   str1.erase ( 6, 5 );  \n   cout << \"The modified string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   // after erasing part of the original string  \n   cout << \"The current size of modified string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of modified string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of modified string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of modified string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__max_size\"></a>  basic_string::max_size  \n Returns the maximum number of characters a string could contain.  \n  \n```  \nsize_type max_size() const;\n```  \n  \n### Return Value  \n The maximum number of characters a string could contain.  \n  \n### Remarks  \n A exception of type [length_error Class](../standard-library/length-error-class.md) is thrown when an operation produces a string with a length greater than the maximum size.  \n  \n### Example  \n  \n```cpp  \n// basic_string_max_size.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 (\"Hello world\");  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   // The size and length member functions differ in name only  \n   basic_string <char>::size_type sizeStr1, lenStr1;  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n  \n   basic_string <char>::size_type capStr1, max_sizeStr1;  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of original string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of original string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl << endl;  \n  \n   str1.erase ( 6, 5 );  \n   cout << \"The modified string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   // after erasing part of the original string  \n   cout << \"The current size of modified string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of modified string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of modified string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of modified string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__npos\"></a>  basic_string::npos  \n An unsigned integral value initialized to –1 that indicates either \"not found\" or \"all remaining characters\" when a search function fails.  \n  \n```  \nstatic const size_type npos = -1;  \n```  \n  \n### Remarks  \n When the return value is to be checked for the `npos` value, it might not work unless the return value is of type [size_type](#basic_string__size_type) and not either `int` or `unsigned`.  \n  \n### Example  \n  See the example for [find](#basic_string__find) for an example of how to declare and use `npos`.  \n  \n##  <a name=\"basic_string__operator_add_eq\"></a>  basic_string::operator+=  \n Appends characters to a string.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& operator+=(\n    value_type _Ch);\n\nbasic_string<CharType, Traits, Allocator>& operator+=(\n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& operator+=(\n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n `_Ch`  \n The character to be appended.  \n  \n ` ptr`  \n The characters of the C-string to be appended.  \n  \n ` right`  \n The characters of the string to be appended.  \n  \n### Return Value  \n A reference to the string object that is being appended with the characters passed by the member function.  \n  \n### Remarks  \n Characters may be appended to a string using the `operator+=` or the member functions [append](#basic_string__append) or [push_back](#basic_string__push_back). The `operator+=` appends single-argument values while the multiple argument append member function allows a specific part of a string to be specified for adding.  \n  \n### Example  \n  \n```cpp  \n// basic_string_op_app.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // appending a single character to a string  \n   string str1a ( \"Hello\" );  \n   cout << \"The original string str1 is: \" << str1a << endl;  \n   str1a +=  '!' ;  \n   cout << \"The string str1 appended with an exclamation is: \"   \n        << str1a << endl << endl;  \n  \n   // The second member function  \n   // appending a C-string to a string  \n   string  str1b ( \"Hello \" );  \n   const char *cstr1b = \"Out There\";  \n   cout << \"The C-string cstr1b is: \" << cstr1b << endl;  \n   str1b +=  cstr1b;  \n   cout << \"Appending the C-string cstr1b to string str1 gives: \"   \n        << str1b << \".\" << endl << endl;  \n  \n   // The third member function  \n   // appending one string to another in two ways,  \n   // comparing append and operator [ ]  \n   string str1d ( \"Hello \" ), str2d ( \"Wide \" ), str3d ( \"World\" );  \n   cout << \"The string str2d is: \" << str2d << endl;  \n   str1d.append ( str2d );  \n   cout << \"The appended string str1d is: \"   \n        << str1d << \".\" << endl;  \n   str1d += str3d;  \n   cout << \"The doubly appended strig str1 is: \"   \n        << str1d << \".\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello  \nThe string str1 appended with an exclamation is: Hello!  \n  \nThe C-string cstr1b is: Out There  \nAppending the C-string cstr1b to string str1 gives: Hello Out There.  \n  \nThe string str2d is: Wide   \nThe appended string str1d is: Hello Wide .  \nThe doubly appended strig str1 is: Hello Wide World.  \n```  \n  \n##  <a name=\"basic_string__operator_eq\"></a>  basic_string::operator=  \n Assigns new character values to the contents of a string.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& operator=(\n    value_type _Ch);\n\nbasic_string<CharType, Traits, Allocator>& operator=(\n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& operator=(\n    const basic_string<CharType, Traits, Allocator>& right);\n\nbasic_string<CharType, Traits, Allocator>& operator=(\n    const basic_string<CharType, Traits, Allocator>&& right);\n```  \n  \n### Parameters  \n `_Ch`  \n The character value to be assigned.  \n  \n ` ptr`  \n A pointer to the characters of the C-string to be assigned to the target string.  \n  \n ` right`  \n The source string whose characters are to be assigned to the target string.  \n  \n### Return Value  \n A reference to the string object that is being assigned new characters by the member function.  \n  \n### Remarks  \n The strings may be assigned new character values. The new value may be either a string and C-string or a single character. The `operator=` may be used if the new value can be described by a single parameter, otherwise the member function [assign](#basic_string__assign), which has multiple parameters, may be used to specify which part of the string is to be assigned to a target string.  \n  \n### Example  \n  \n```cpp  \n// basic_string_op_assign.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function assigning a  \n   // character of a certain value to a string  \n   string str1a ( \"Hello \" );  \n   str1a = '0';  \n   cout << \"The string str1 assigned with the zero character is: \"   \n        << str1a << endl << endl;  \n  \n   // The second member function assigning the  \n   // characters of a C-string to a string  \n   string  str1b;  \n   const char *cstr1b = \"Out There\";  \n   cout << \"The C-string cstr1b is: \" << cstr1b <<  \".\" << endl;  \n   str1b = cstr1b;  \n   cout << \"Assigning the C-string cstr1a to string str1 gives: \"   \n        << str1b << \".\" << endl << endl;  \n  \n   // The third member function assigning the characters  \n   // from one string to another string in two equivalent  \n   // ways, comparing the assign and operator =  \n   string str1c ( \"Hello\" ), str2c ( \"Wide\" ), str3c ( \"World\" );  \n   cout << \"The original string str1 is: \" << str1c << \".\" << endl;  \n   cout << \"The string str2c is: \" << str2c << \".\" << endl;  \n   str1c.assign ( str2c );  \n   cout << \"The string str1 newly assigned with string str2c is: \"   \n        << str1c << \".\" << endl;  \n   cout << \"The string str3c is: \" << str3c << \".\" << endl;  \n   str1c = str3c;  \n   cout << \"The string str1 reassigned with string str3c is: \"   \n        << str1c << \".\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe string str1 assigned with the zero character is: 0  \n  \nThe C-string cstr1b is: Out There.  \nAssigning the C-string cstr1a to string str1 gives: Out There.  \n  \nThe original string str1 is: Hello.  \nThe string str2c is: Wide.  \nThe string str1 newly assigned with string str2c is: Wide.  \nThe string str3c is: World.  \nThe string str1 reassigned with string str3c is: World.  \n```  \n  \n##  <a name=\"basic_string__operator_at\"></a>  basic_string::operator[]  \n Provides a reference to the character with a specified index in a string.  \n  \n```  \nconst_reference operator[](size_type _Off) const;\n\n \nreference operator[](size_type _Off);\n```  \n  \n### Parameters  \n `_Off`  \n The index of the position of the element to be referenced.  \n  \n### Return Value  \n A reference to the character of the string at the position specified by the parameter index.  \n  \n### Remarks  \n The first element of the string has an index of zero, and the following elements are indexed consecutively by the positive integers, so that a string of length *n* has an *n*th element indexed by the number *n* - 1.  \n  \n `operator[]` is faster than the member function [at](#basic_string__at) for providing read and write access to the elements of a string.  \n  \n `operator[]` does not check whether the index passed as a parameter is valid, but the member function **at** does and so should be used in the validity is not certain. An invalid index (an index less that zero or greater than or equal to the size of the string) passed to the member function **at** throws an [out_of_range Class](../standard-library/out-of-range-class.md) exception. An invalid index passed to `operator[]` results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null character when passed this index.  \n  \n The reference returned may be invalidated by string reallocations or modifications for the non- **const** strings.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element outside the bounds of the string.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp  \n// basic_string_op_ref.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string str1 ( \"Hello world\" ), str2 ( \"Goodbye world\" );  \n   const string cstr1 ( \"Hello there\" ), cstr2 ( \"Goodbye now\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n  \n   // Element access to the non-const strings  \n   basic_string <char>::reference refStr1 = str1 [6];  \n   basic_string <char>::reference refStr2 = str2.at ( 3 );  \n  \n   cout << \"The character with an index of 6 in string str1 is: \"  \n        << refStr1 << \".\" << endl;  \n   cout << \"The character with an index of 3 in string str2 is: \"  \n        << refStr2 << \".\" << endl;  \n  \n   // Element access to the const strings  \n   basic_string <char>::const_reference crefStr1 = cstr1 [ cstr1.length ( ) ];  \n   basic_string <char>::const_reference crefStr2 = cstr2.at ( 8 );  \n  \n   if ( crefStr1 == '\\0' )  \n      cout << \"The null character is returned as a valid reference.\"  \n           << endl;  \n   else  \n      cout << \"The null character is not returned.\" << endl;  \n   cout << \"The character with index of 8 in the const string cstr2 is: \"  \n        << crefStr2 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__pointer\"></a>  basic_string::pointer  \n A type that provides a pointer to a character element in a string or character array.  \n  \n```  \ntypedef typename allocator_type::pointer pointer;  \n```  \n  \n### Remarks  \n The type is a synonym for **allocator_type::pointer**.  \n  \n For type **string**, it is equivalent to **char\\***.  \n  \n### Example  \n  \n```cpp  \n// basic_string_pointer.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   basic_string<char>::pointer pstr1a = \"In Here\";  \n   char *cstr1b = \"Out There\";  \n   cout << \"The string pstr1a is: \" << pstr1a <<  \".\" << endl;  \n   cout << \"The C-string cstr1b is: \" << cstr1b << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe string pstr1a is: In Here.  \nThe C-string cstr1b is: Out There.  \n```  \n  \n##  <a name=\"basic_string__pop_back\"></a>  basic_string::pop_back  \n Erases the last element of the string.  \n  \n```  \nvoid pop_back();\n```  \n  \n### Remarks  \n This member function effectively calls `erase(size() - 1)` to erase the last element of the sequence, which must be non-empty.  \n  \n##  <a name=\"basic_string__push_back\"></a>  basic_string::push_back  \n Adds an element to the end of the string.  \n  \n```  \nvoid push_back(value_type _Ch);\n```  \n  \n### Parameters  \n `_Ch`  \n The character to be added to the end of the string.  \n  \n### Remarks  \n The member function effectively calls [insert](#basic_string__insert)( [end](#basic_string__end), _ *Ch* ).  \n  \n### Example  \n  \n```cpp  \n// basic_string_push_back.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 ( \"abc\" );  \n   basic_string <char>::iterator str_Iter, str1_Iter;  \n  \n   cout << \"The original string str1 is: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n  \n   // str1.push_back ( 'd' );  \n   str1_Iter = str1.end ( );  \n   str1_Iter--;  \n   cout << \"The last character-letter of the modified str1 is now: \"  \n        << *str1_Iter << endl;  \n  \n   cout << \"The modified string str1 is: \";  \n   for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )  \n      cout << *str_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: abc  \nThe last character-letter of the modified str1 is now: c  \nThe modified string str1 is: abc  \n```  \n  \n##  <a name=\"basic_string__rbegin\"></a>  basic_string::rbegin  \n Returns an iterator to the first element in a reversed string.  \n  \n```  \nconst_reverse_iterator rbegin() const;\n\n \nreverse_iterator rbegin();\n```  \n  \n### Return Value  \n Returns a random-access iterator to the first element in a reversed string, addressing what would be the last element in the corresponding unreversed string.  \n  \n### Remarks  \n `rbegin` is used with a reversed string just as [begin](#basic_string__begin) is used with a string.  \n  \n If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the string object cannot be modified. If the return value of `rbegin` is assigned to a `reverse_iterator`, the string object can be modified.  \n  \n `rbegin` can be used to initialize an iteration through a string backwards.  \n  \n### Example  \n  \n```cpp  \n// basic_string_rbegin.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string str1 ( \"Able was I ere I saw Elba\" ), str2;  \n   basic_string <char>::reverse_iterator str_rIter, str1_rIter, str2_rIter;  \n   basic_string <char>::const_reverse_iterator str1_rcIter;  \n  \n   str1_rIter = str1.rbegin ( );  \n   // str1_rIter--;  \n   cout << \"The first character-letter of the reversed string str1 is: \"  \n        << *str1_rIter << endl;  \n   cout << \"The full reversed string str1 is:\\n \";  \n   for ( str_rIter = str1.rbegin( ); str_rIter != str1.rend( ); str_rIter++ )  \n      cout << *str_rIter;  \n   cout << endl;  \n  \n   // The dereferenced iterator can be used to modify a character  \n *str1_rIter = 'A';  \n   cout << \"The first character-letter of the modified str1 is now: \"  \n        << *str1_rIter << endl;  \n   cout << \"The full modified reversed string str1 is now:\\n \";  \n   for ( str_rIter = str1.rbegin( ); str_rIter != str1.rend( ); str_rIter++ )  \n      cout << *str_rIter;  \n   cout << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *str1_rcIter = 'A';  \n  \n   // For an empty string, begin is equivalent to end  \n   if ( str2.rbegin( ) == str2.rend ( ) )  \n      cout << \"The string str2 is empty.\" << endl;  \n   else  \n      cout << \"The stringstr2  is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe first character-letter of the reversed string str1 is: a  \nThe full reversed string str1 is:  \n ablE was I ere I saw elbA  \nThe first character-letter of the modified str1 is now: A  \nThe full modified reversed string str1 is now:  \n AblE was I ere I saw elbA  \nThe string str2 is empty.  \n```  \n  \n##  <a name=\"basic_string__reference\"></a>  basic_string::reference  \n A type that provides a reference to an element stored in a string.  \n  \n```  \ntypedef typename allocator_type::reference reference;  \n```  \n  \n### Remarks  \n A type **reference** can be used to modify the value of an element.  \n  \n The type is a synonym for **allocator_type::reference**.  \n  \n For type **string**, it is equivalent to **chr&**.  \n  \n### Example  \n  See the example for [at](#basic_string__at) for an example of how to declare and use **reference**.  \n  \n##  <a name=\"basic_string__rend\"></a>  basic_string::rend  \n Returns an iterator that addresses the location succeeding the last element in a reversed string.  \n  \n```  \nconst_reverse_iterator rend() const;\n\n \nreverse_iterator rend();\n```  \n  \n### Return Value  \n A reverse random-access iterator that addresses the location succeeding the last element in a reversed string.  \n  \n### Remarks  \n `rend` is used with a reversed string just as [end](#basic_string__end) is used with a string.  \n  \n If the return value of `rend` is assigned to a `const_reverse_iterator`, the string object cannot be modified. If the return value of `rend` is assigned to a `reverse_iterator`, the string object can be modified.  \n  \n `rend` can be used to test whether a reverse iterator has reached the end of its string.  \n  \n The value returned by `rend` should not be dereferenced.  \n  \n### Example  \n  \n```cpp  \n// basic_string_rend.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   string str1 (\"Able was I ere I saw Elba\"), str2;  \n   basic_string <char>::reverse_iterator str_rIter, str1_rIter, str2_rIter;  \n   basic_string <char>::const_reverse_iterator str1_rcIter;  \n  \n   str1_rIter = str1.rend ( );  \n   str1_rIter--;  \n   cout << \"The last character-letter of the reversed string str1 is: \"  \n        << *str1_rIter << endl;  \n   cout << \"The full reversed string str1 is:\\n \";  \n   for ( str_rIter = str1.rbegin( ); str_rIter != str1.rend( ); str_rIter++ )  \n      cout << *str_rIter;  \n   cout << endl;  \n  \n   // The dereferenced iterator can be used to modify a character  \n *str1_rIter = 'o';  \n   cout << \"The last character-letter of the modified str1 is now: \"  \n        << *str1_rIter << endl;  \n   cout << \"The full modified reversed string str1 is now:\\n \";  \n   for ( str_rIter = str1.rbegin( ); str_rIter != str1.rend( ); str_rIter++ )  \n      cout << *str_rIter;  \n   cout << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *str1_rcIter = 'T';  \n  \n   // For an empty string, end is equivalent to begin  \n   if ( str2.rbegin( ) == str2.rend ( ) )  \n      cout << \"The string str2 is empty.\" << endl;  \n   else  \n      cout << \"The stringstr2  is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe last character-letter of the reversed string str1 is: A  \nThe full reversed string str1 is:  \n ablE was I ere I saw elbA  \nThe last character-letter of the modified str1 is now: o  \nThe full modified reversed string str1 is now:  \n ablE was I ere I saw elbo  \nThe string str2 is empty.  \n```  \n  \n##  <a name=\"basic_string__replace\"></a>  basic_string::replace  \n Replaces elements in a string at a specified position with specified characters or characters copied from other ranges or strings or C-strings.  \n  \n```  \nbasic_string<CharType, Traits, Allocator>& replace(\n    size_type _Pos1,   \n    size_type _Num1,  \n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    size_type _Pos1,   \n    size_type _Num1,  \n    const basic_string<CharType, Traits, Allocator>& str);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    size_type _Pos1,   \n    size_type _Num1,  \n    const value_type* ptr,   \n    size_type _Num2);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    size_type _Pos1,   \n    size_type _Num1,  \n    const basic_string<CharType, Traits, Allocator>& str,   \n    size_type _Pos2,   \n    size_type _Num2);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    size_type _Pos1,   \n    size_type _Num1,  \n    size_type count,   \n    value_type _Ch);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,   \n    iterator last0,  \n    const value_type* ptr);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,   \n    iterator last0,  \n    const basic_string<CharType, Traits, Allocator>& str);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,  \n    iterator last0,  \n    const value_type* ptr,   \n    size_type _Num2);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,   \n    iterator last0,  \n    size_type _Num2,   \n    value_type _Ch);\n\ntemplate <class InputIterator>  \nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,   \n    iterator last0,  \n    InputIterator first,   \n    InputIterator last);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,  \n    iterator last0,  \n    const_pointer first,  \n    const_pointer last);\n\nbasic_string<CharType, Traits, Allocator>& replace(\n    iterator first0,  \n    iterator last0,  \n    const_iterator first,  \n    const_iterator last);\n```  \n  \n### Parameters  \n ` str`  \n The string that is to be a source of characters for the operand string.  \n  \n `_Pos1`  \n The index of the operand string at which the replacement begins.  \n  \n `_Num1`  \n The maximum number of characters to be replaced in the operand string.  \n  \n *_Pos2*  \n The index of the parameter string at which the copying begins.  \n  \n `_Num2`  \n The maximum number of characters to be used from the parameter C-string.  \n  \n ` ptr`  \n The C-string that is to be a source of characters for the operand string.  \n  \n `_Ch`  \n The character to be copied into the operand string.  \n  \n * first0*  \n An iterator addressing the first character to be removed in the operand string.  \n  \n * last0*  \n An iterator addressing the last character to be removed in the operand string.  \n  \n ` first`  \n An iterator, const_pointer, or const_iterator addressing the first character to be copied in the parameter string.  \n  \n ` last`  \n An iterator, const_pointer, or const_iterator addressing the last character to be copied in the parameter string.  \n  \n ` count`  \n The number of times `_Ch` is copied into the operand string.  \n  \n### Return Value  \n The operand string with the replacement made.  \n  \n### Example  \n  \n```cpp  \n// basic_string_replace.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first two member functions replace  \n   // part of the operand string with  \n   // characters from a parameter string or C-string  \n   string result1a, result1b;  \n   string s1o ( \"AAAAAAAA\" );  \n   string s1p ( \"BBB\" );  \n   const char* cs1p = \"CCC\";  \n   cout << \"The operand string s1o is: \" << s1o << endl;  \n   cout << \"The parameter string s1p is: \" << s1p << endl;  \n   cout << \"The parameter C-string cs1p is: \" << cs1p << endl;  \n   result1a = s1o.replace ( 1 , 3 , s1p );  \n   cout << \"The result of s1o.replace ( 1 , 3 , s1p )\\n is \"   \n        << \"the string: \" << result1a << \".\" << endl;  \n   result1b = s1o.replace ( 5 , 3 , cs1p );  \n   cout << \"The result of s1o.replace ( 5 , 3 , cs1p )\\n is \"   \n        << \"the string: \" << result1b << \".\" << endl;  \n   cout << endl;  \n  \n   // The third & fourth member function replace  \n   // part of the operand string with characters  \n   // form part of a parameter string or C-string  \n   string result2a, result2b;  \n   string s2o ( \"AAAAAAAA\" );  \n   string s2p ( \"BBB\" );  \n   const char* cs2p = \"CCC\";  \n   cout << \"The operand string s2o is: \" << s2o << endl;  \n   cout << \"The parameter string s1p is: \" << s2p << endl;  \n   cout << \"The parameter C-string cs2p is: \" << cs2p << endl;  \n   result2a = s2o.replace ( 1 , 3 , s2p , 1 , 2 );  \n   cout << \"The result of s2o.replace (1, 3, s2p, 1, 2)\\n is \"   \n        << \"the string: \" << result2a << \".\" << endl;  \n   result2b = s2o.replace ( 4 , 3 , cs2p , 1 );  \n   cout << \"The result of s2o.replace (4 ,3 ,cs2p)\\n is \"   \n        << \"the string: \" << result2b << \".\" << endl;  \n   cout << endl;  \n  \n   // The fifth member function replaces  \n   // part of the operand string with characters  \n   string result3a;  \n   string s3o ( \"AAAAAAAA\" );  \n   char ch3p = 'C';  \n   cout << \"The operand string s3o is: \" << s3o << endl;  \n   cout << \"The parameter character c1p is: \" << ch3p << endl;  \n   result3a = s3o.replace ( 1 , 3 , 4 , ch3p );  \n   cout << \"The result of s3o.replace(1, 3, 4, ch3p)\\n is \"   \n        << \"the string: \" << result3a << \".\" << endl;  \n   cout << endl;  \n  \n   // The sixth & seventh member functions replace  \n   // part of the operand string, delineated with iterators,  \n   // with a parameter string or C-string  \n   string s4o ( \"AAAAAAAA\" );  \n   string s4p ( \"BBB\" );  \n   const char* cs4p = \"CCC\";  \n   cout << \"The operand string s4o is: \" << s4o << endl;  \n   cout << \"The parameter string s4p is: \" << s4p << endl;  \n   cout << \"The parameter C-string cs4p is: \" << cs4p << endl;  \n   basic_string<char>::iterator IterF0, IterL0;  \n   IterF0 = s4o.begin ( );  \n   IterL0 = s4o.begin ( ) + 3;  \n   string result4a, result4b;  \n   result4a = s4o.replace ( IterF0 , IterL0 , s4p );  \n   cout << \"The result of s1o.replace (IterF0, IterL0, s4p)\\n is \"   \n        << \"the string: \" << result4a << \".\" << endl;  \n   result4b = s4o.replace ( IterF0 , IterL0 , cs4p );  \n   cout << \"The result of s4o.replace (IterF0, IterL0, cs4p)\\n is \"   \n        << \"the string: \" << result4b << \".\" << endl;  \n   cout << endl;  \n  \n   // The 8th member function replaces  \n   // part of the operand string delineated with iterators  \n   // with a number of characters from a parameter C-string  \n   string s5o ( \"AAAAAAAF\" );  \n   const char* cs5p = \"CCCBB\";  \n   cout << \"The operand string s5o is: \" << s5o << endl;  \n   cout << \"The parameter C-string cs5p is: \" << cs5p << endl;  \n   basic_string<char>::iterator IterF1, IterL1;  \n   IterF1 = s5o.begin ( );  \n   IterL1 = s5o.begin ( ) + 4;  \n   string result5a;  \n   result5a = s5o.replace ( IterF1 , IterL1 , cs5p , 4 );  \n   cout << \"The result of s5o.replace (IterF1, IterL1, cs4p ,4)\\n is \"   \n        << \"the string: \" << result5a << \".\" << endl;  \n   cout << endl;  \n  \n   // The 9th member function replaces  \n   // part of the operand string delineated with iterators  \n   // with specified characters  \n   string s6o ( \"AAAAAAAG\" );  \n   char ch6p = 'q';  \n   cout << \"The operand string s6o is: \" << s6o << endl;  \n   cout << \"The parameter character ch6p is: \" << ch6p << endl;  \n   basic_string<char>::iterator IterF2, IterL2;  \n   IterF2 = s6o.begin ( );  \n   IterL2 = s6o.begin ( ) + 3;  \n   string result6a;  \n   result6a = s6o.replace ( IterF2 , IterL2 , 4 , ch6p );  \n   cout << \"The result of s6o.replace (IterF1, IterL1, 4, ch6p)\\n is \"   \n        << \"the string: \" << result6a << \".\" << endl;  \n   cout << endl;  \n  \n   // The 10th member function replaces  \n   // part of the operand string delineated with iterators  \n   // with part of a parameter string delineated with iterators  \n   string s7o ( \"OOOOOOO\" );  \n   string s7p ( \"PPPP\" );  \n   cout << \"The operand string s7o is: \" << s7o << endl;  \n   cout << \"The parameter string s7p is: \" << s7p << endl;  \n   basic_string<char>::iterator IterF3, IterL3, IterF4, IterL4;  \n   IterF3 = s7o.begin ( ) + 1;  \n   IterL3 = s7o.begin ( ) + 3;  \n   IterF4 = s7p.begin ( );  \n   IterL4 = s7p.begin ( ) + 2;  \n   string result7a;  \n   result7a = s7o.replace ( IterF3 , IterL3 , IterF4 , IterL4 );  \n   cout << \"The result of s7o.replace (IterF3 ,IterL3 ,IterF4 ,IterL4)\\n is \"   \n        << \"the string: \" << result7a << \".\" << endl;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe operand string s1o is: AAAAAAAA  \nThe parameter string s1p is: BBB  \nThe parameter C-string cs1p is: CCC  \nThe result of s1o.replace ( 1 , 3 , s1p )  \n is the string: ABBBAAAA.  \nThe result of s1o.replace ( 5 , 3 , cs1p )  \n is the string: ABBBACCC.  \n  \nThe operand string s2o is: AAAAAAAA  \nThe parameter string s1p is: BBB  \nThe parameter C-string cs2p is: CCC  \nThe result of s2o.replace (1, 3, s2p, 1, 2)  \n is the string: ABBAAAA.  \nThe result of s2o.replace (4 ,3 ,cs2p)  \n is the string: ABBAC.  \n  \nThe operand string s3o is: AAAAAAAA  \nThe parameter character c1p is: C  \nThe result of s3o.replace(1, 3, 4, ch3p)  \n is the string: ACCCCAAAA.  \n  \nThe operand string s4o is: AAAAAAAA  \nThe parameter string s4p is: BBB  \nThe parameter C-string cs4p is: CCC  \nThe result of s1o.replace (IterF0, IterL0, s4p)  \n is the string: BBBAAAAA.  \nThe result of s4o.replace (IterF0, IterL0, cs4p)  \n is the string: CCCAAAAA.  \n  \nThe operand string s5o is: AAAAAAAF  \nThe parameter C-string cs5p is: CCCBB  \nThe result of s5o.replace (IterF1, IterL1, cs4p ,4)  \n is the string: CCCBAAAF.  \n  \nThe operand string s6o is: AAAAAAAG  \nThe parameter character ch6p is: q  \nThe result of s6o.replace (IterF1, IterL1, 4, ch6p)  \n is the string: qqqqAAAAG.  \n  \nThe operand string s7o is: OOOOOOO  \nThe parameter string s7p is: PPPP  \nThe result of s7o.replace (IterF3 ,IterL3 ,IterF4 ,IterL4)  \n is the string: OPPOOOO.  \n```  \n  \n##  <a name=\"basic_string__reserve\"></a>  basic_string::reserve  \n Sets the capacity of the string to a number at least as great as a specified number.  \n  \n```  \nvoid reserve(size_type count = 0);\n```  \n  \n### Parameters  \n ` count`  \n The number of characters for which memory is being reserved.  \n  \n### Remarks  \n Having sufficient capacity is important because reallocations is a time-consuming process and invalidates all references, pointers, and iterators that refer to characters in a string.  \n  \n The concept of capacity for objects of type strings is the same as for objects of type vector. Unlike vector, the member function **reserve** may be called to shrink the capacity of an object. The request is nonbinding and may or may not happen. As the default value for the parameter is zero, a call of **reserve** is a non-binding request to shrink the capacity of the string to fit the number of characters currently in the string. The capacity is never reduced below the current number of characters.  \n  \n Calling `reserve` is the only possible way to shrink the capacity of a string. However, as noted above, this request is nonbinding and may not happen.  \n  \n### Example  \n  \n```cpp  \n// basic_string_reserve.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 (\"Hello world\");  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   basic_string <char>::size_type sizeStr1, sizerStr1;  \n   sizeStr1 = str1.size ( );  \n   basic_string <char>::size_type capStr1, caprStr1;  \n   capStr1 = str1.capacity ( );  \n  \n   // Compare size & capacity of the original string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl << endl;  \n  \n   // Compare size & capacity of the string  \n   // with added capacity  \n   str1.reserve ( 40 );  \n   sizerStr1 = str1.size ( );  \n   caprStr1 = str1.capacity ( );  \n  \n   cout << \"The string str1with augmented capacity is: \"  \n        << str1 << endl;  \n   cout << \"The current size of string str1 is: \"   \n        << sizerStr1 << \".\" << endl;  \n   cout << \"The new capacity of string str1 is: \"  \n        << caprStr1 << \".\" << endl << endl;  \n  \n   // Compare size & capacity of the string  \n   // with downsized capacity  \n   str1.reserve ( );  \n   basic_string <char>::size_type sizedStr1;  \n   basic_string <char>::size_type capdStr1;  \n   sizedStr1 = str1.size ( );  \n   capdStr1 = str1.capacity ( );  \n  \n   cout << \"The string str1 with downsized capacity is: \"  \n        << str1 << endl;  \n   cout << \"The current size of string str1 is: \"   \n        << sizedStr1 << \".\" << endl;  \n   cout << \"The reduced capacity of string str1 is: \"  \n        << capdStr1 << \".\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello world  \nThe current size of original string str1 is: 11.  \nThe capacity of original string str1 is: 15.  \n  \nThe string str1with augmented capacity is: Hello world  \nThe current size of string str1 is: 11.  \nThe new capacity of string str1 is: 47.  \n  \nThe string str1 with downsized capacity is: Hello world  \nThe current size of string str1 is: 11.  \nThe reduced capacity of string str1 is: 47.  \n```  \n  \n##  <a name=\"basic_string__resize\"></a>  basic_string::resize  \n Specifies a new size for a string, appending or erasing elements as required.  \n  \n```  \nvoid resize(\n    size_type count,);\n\nvoid resize(\n    size_type count,  \n    _Elem _Ch);\n```  \n  \n### Parameters  \n ` count`  \n The new size of the string.  \n  \n `_Ch`  \n The value that appended characters are initialized with if additional elements are required.  \n  \n### Remarks  \n If the resulting size exceeds the maximum number of characters, the form throws `length_error`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_resize.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string  str1 ( \"Hello world\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   basic_string <char>::size_type sizeStr1;  \n   sizeStr1 = str1.size ( );  \n   basic_string <char>::size_type capStr1;  \n   capStr1 = str1.capacity ( );  \n  \n   // Compare size & capacity of the original string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl << endl;  \n  \n   // Use resize to increase size by 2 elements: exclamations  \n   str1.resize ( str1.size ( ) + 2 , '!' );  \n   cout << \"The resized string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size ( );  \n   capStr1 = str1.capacity ( );  \n  \n   // Compare size & capacity of a string after resizing  \n   cout << \"The current size of resized string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of resized string str1 is: \"  \n        << capStr1 << \".\" << endl << endl;  \n  \n   // Use resize to increase size by 20 elements:  \n   str1.resize ( str1.size ( ) + 20 );  \n   cout << \"The resized string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size ( );  \n   capStr1 = str1.capacity ( );  \n  \n   // Compare size & capacity of a string after resizing  \n   // note capacity increases automatically as required  \n   cout << \"The current size of modified string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of modified string str1 is: \"  \n        << capStr1 << \".\" << endl << endl;  \n  \n   // Use resize to downsize by 28 elements:  \n   str1.resize ( str1.size ( ) - 28 );  \n   cout << \"The downsized string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size (  );  \n   capStr1 = str1.capacity (  );  \n  \n   // Compare size & capacity of a string after downsizing  \n   cout << \"The current size of downsized string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of downsized string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello world  \nThe current size of original string str1 is: 11.  \nThe capacity of original string str1 is: 15.  \n  \nThe resized string str1 is: Hello world!!  \nThe current size of resized string str1 is: 13.  \nThe capacity of resized string str1 is: 15.  \n  \nThe resized string str1 is: Hello world!!                      \nThe current size of modified string str1 is: 33.  \nThe capacity of modified string str1 is: 47.  \n  \nThe downsized string str1 is: Hello  \nThe current size of downsized string str1 is: 5.  \nThe capacity of downsized string str1 is: 47.  \n```  \n  \n##  <a name=\"basic_string__reverse_iterator\"></a>  basic_string::reverse_iterator  \n A type that provides a reference to an element stored in a string.  \n  \n```  \ntypedef std::reverse_iterator<iterator> reverse_iterator;  \n```  \n  \n### Remarks  \n A type `reverse_iterator` can be used to modify the value of a character and is used to iterate through a string in reverse.  \n  \n### Example  \n  See the example for [rbegin](#basic_string__rbegin) for an example of how to declare and use `reverse_iterator`.  \n  \n##  <a name=\"basic_string__rfind\"></a>  basic_string::rfind  \n Searches a string in a backward direction for the first occurrence of a substring that matches a specified sequence of characters.  \n  \n```  \nsize_type rfind(\n    value_type _Ch,   \n    size_type _Off = npos) const;\n\n \nsize_type rfind(\n    const value_type* ptr,  \n    size_type _Off = npos) const;\n\n \nsize_type rfind(\n    const value_type* ptr,   \n    size_type _Off,  \n    size_type count) const;\n\n \nsize_type rfind(\n    const basic_string<CharType, Traits, Allocator>& str,  \n    size_type _Off = npos) const;\n```  \n  \n### Parameters  \n `_Ch`  \n The character value for which the member function is to search.  \n  \n `_Off`  \n Index of the position at which the search is to begin.  \n  \n ` ptr`  \n The C-string for which the member function is to search.  \n  \n ` count`  \n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.  \n  \n ` str`  \n The string for which the member function is to search.  \n  \n### Return Value  \n The index of the last occurrence, when searched backwards, of the first character of the substring when successful; otherwise `npos`.  \n  \n### Example  \n  \n```cpp  \n// basic_string_rfind.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function  \n   // searches for a single character in a string  \n   string str1 ( \"Hello Everyone\" );  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n   basic_string <char>::size_type indexCh1a, indexCh1b;  \n   static const basic_string <char>::size_type npos = -1;  \n  \n   indexCh1a = str1.rfind ( \"e\" , 9 );  \n   if ( indexCh1a != npos )  \n      cout << \"The index of the 1st 'e' found before the 9th\"  \n           << \" position in str1 is: \" << indexCh1a << endl;  \n   else  \n      cout << \"The character 'e' was not found in str1 .\" << endl;  \n  \n   indexCh1b = str1.rfind ( \"x\" );  \n   if ( indexCh1b != npos )  \n      cout << \"The index of the 'x' found in str1 is: \"  \n           << indexCh1b << endl << endl;  \n   else  \n      cout << \"The character 'x' was not found in str1.\"  \n           << endl << endl;  \n  \n   // The second member function searches a string  \n   // for a substring as specified by a C-string  \n   string str2 ( \"Let me make this perfectly clear.\" );  \n   cout << \"The original string str2 is: \" << str2 << endl;  \n   basic_string <char>::size_type indexCh2a, indexCh2b;  \n  \n   const char *cstr2 = \"perfect\";  \n   indexCh2a = str2.rfind ( cstr2 , 30 );  \n   if ( indexCh2a != npos )  \n      cout << \"The index of the 1st element of 'perfect' \"  \n           << \"before\\n the 30th position in str2 is: \"  \n           << indexCh2a << endl;  \n   else  \n      cout << \"The substring 'perfect' was not found in str2 .\"  \n           << endl;  \n  \n   const char *cstr2b = \"imperfectly\";  \n   indexCh2b = str2.rfind ( cstr2b , 30 );  \n   if ( indexCh2b != npos )  \n      cout << \"The index of the 1st element of 'imperfect' \"  \n           << \"before\\n the 5th position in str3 is: \"  \n           << indexCh2b << endl;  \n   else  \n      cout << \"The substring 'imperfect' was not found in str2 .\"  \n           << endl << endl;  \n  \n   // The third member function searches a string  \n   // for a substring as specified by a C-string  \n   string str3 ( \"It is a nice day. I am happy.\" );  \n   cout << \"The original string str3 is: \" << str3 << endl;  \n   basic_string <char>::size_type indexCh3a, indexCh3b;  \n  \n   const char *cstr3a = \"nice\";  \n   indexCh3a = str3.rfind ( cstr3a );  \n   if ( indexCh3a != npos )  \n      cout << \"The index of the 1st element of 'nice' \"  \n           << \"in str3 is: \" << indexCh3a << endl;  \n   else  \n      cout << \"The substring 'nice' was not found in str3 .\"  \n           << endl;  \n  \n   const char *cstr3b = \"am\";  \n   indexCh3b = str3.rfind ( cstr3b , indexCh3a + 25 , 2 );  \n   if ( indexCh3b != npos )  \n      cout << \"The index of the next occurrance of 'am' in \"  \n           << \"str3 begins at: \" << indexCh3b << endl << endl;  \n   else  \n      cout << \"There is no next occurrence of 'am' in str3 .\"  \n           << endl << endl;  \n  \n   // The fourth member function searches a string  \n   // for a substring as specified by a string  \n   string str4 ( \"This perfectly unclear.\" );  \n   cout << \"The original string str4 is: \" << str4 << endl;  \n   basic_string <char>::size_type indexCh4a, indexCh4b;  \n  \n   string str4a ( \"clear\" );  \n   indexCh4a = str4.rfind ( str4a , 15 );  \n   if (indexCh4a != npos )  \n      cout << \"The index of the 1st element of 'clear' \"  \n           << \"before\\n the 15th position in str4 is: \"  \n           << indexCh4a << endl;  \n   else  \n      cout << \"The substring 'clear' was not found in str4 \"  \n           << \"before the 15th position.\" << endl;  \n  \n   string str4b ( \"clear\" );  \n   indexCh4b = str4.rfind ( str4b );  \n   if ( indexCh4b != npos )  \n      cout << \"The index of the 1st element of 'clear' \"  \n           << \"in str4 is: \"  \n           << indexCh4b << endl;  \n   else  \n      cout << \"The substring 'clear' was not found in str4 .\"  \n           << endl << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is: Hello Everyone  \nThe index of the 1st 'e' found before the 9th position in str1 is: 8  \nThe character 'x' was not found in str1.  \n  \nThe original string str2 is: Let me make this perfectly clear.  \nThe index of the 1st element of 'perfect' before  \n the 30th position in str2 is: 17  \nThe substring 'imperfect' was not found in str2 .  \n  \nThe original string str3 is: It is a nice day. I am happy.  \nThe index of the 1st element of 'nice' in str3 is: 8  \nThe index of the next occurrance of 'am' in str3 begins at: 20  \n  \nThe original string str4 is: This perfectly unclear.  \nThe substring 'clear' was not found in str4 before the 15th position.  \nThe index of the 1st element of 'clear' in str4 is: 17  \n```  \n  \n##  <a name=\"basic_string__shrink_to_fit\"></a>  basic_string::shrink_to_fit  \n Discards the excess capacity of the string.  \n  \n```  \nvoid shrink_to_fit();\n```  \n  \n### Remarks  \n This member function eliminates any unneeded storage in the container.  \n  \n##  <a name=\"basic_string__size\"></a>  basic_string::size  \n Returns the current number of elements in a string.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Return Value  \n The length of the string.  \n  \n### Example  \n  \n```cpp  \n// basic_string_size.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 (\"Hello world\");  \n   cout << \"The original string str1 is: \" << str1 << endl;  \n  \n   // The size and length member functions differ in name only  \n   basic_string <char>::size_type sizeStr1, lenStr1;  \n   sizeStr1 = str1.size (  );  \n   lenStr1 = str1.length (  );  \n  \n   basic_string <char>::size_type capStr1, max_sizeStr1;  \n   capStr1 = str1.capacity (  );  \n   max_sizeStr1 = str1.max_size (  );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   cout << \"The current size of original string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of original string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of original string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of original string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl << endl;  \n  \n   str1.erase ( 6, 5 );  \n   cout << \"The modified string str1 is: \" << str1 << endl;  \n  \n   sizeStr1 = str1.size ( );  \n   lenStr1 = str1.length ( );  \n   capStr1 = str1.capacity ( );  \n   max_sizeStr1 = str1.max_size ( );  \n  \n   // Compare size, length, capacity & max_size of a string  \n   // after erasing part of the original string  \n   cout << \"The current size of modified string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The current length of modified string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n   cout << \"The capacity of modified string str1 is: \"  \n        << capStr1 << \".\" << endl;  \n   cout << \"The max_size of modified string str1 is: \"   \n        << max_sizeStr1 << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"basic_string__size_type\"></a>  basic_string::size_type  \n An unsigned integer type that can represent the number of elements and indices in a string.  \n  \n```  \ntypedef typename allocator_type::size_type size_type;  \n```  \n  \n### Remarks  \n It is equivalent to **allocator_type::size_type**.  \n  \n For type **string**, it is equivalent to **size_t**.  \n  \n### Example  \n  \n```cpp  \n// basic_string_size_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   string str1 ( \"Hello world\" );  \n  \n   basic_string <char>::size_type sizeStr1, capStr1;  \n   sizeStr1 = str1.size (  );  \n   capStr1 = str1.capacity (  );  \n  \n   cout << \"The current size of string str1 is: \"   \n        << sizeStr1 << \".\" << endl;  \n   cout << \"The capacity of string str1 is: \" << capStr1   \n         << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe current size of string str1 is: 11.  \nThe capacity of string str1 is: 15.  \n```  \n  \n##  <a name=\"basic_string__substr\"></a>  basic_string::substr  \n Copies a substring of at most some number of characters from a string beginning from a specified position.  \n  \n```  \nbasic_string<CharType, Traits, Allocator> substr(\n    size_type _Off = 0,  \n    size_type count = npos) const;\n```  \n  \n### Parameters  \n `_Off`  \n An index locating the element at the position from which the copy of the string is made, with a default value of 0.  \n  \n ` count`  \n The number of characters that are to be copied if they are present.  \n  \n### Return Value  \n A substring object that is a copy of elements of the string operand beginning at the position specified by the first argument.  \n  \n### Example  \n  \n```cpp  \n// basic_string_substr.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   string  str1 (\"Heterological paradoxes are persistent.\");  \n   cout << \"The original string str1 is: \\n \" << str1  \n        << endl << endl;  \n  \n   basic_string <char> str2 = str1.substr ( 6 , 7 );  \n   cout << \"The substring str1 copied is: \" << str2  \n        << endl << endl;  \n  \n   basic_string <char> str3 = str1.substr (  );  \n   cout << \"The default substring str3 is: \\n \" << str3  \n        <<  \"\\n which is the entire original string.\" << endl;  \n}  \n```  \n  \n```Output  \nThe original string str1 is:   \n Heterological paradoxes are persistent.  \n  \nThe substring str1 copied is: logical  \n  \nThe default substring str3 is:   \n Heterological paradoxes are persistent.  \n which is the entire original string.  \n```  \n  \n##  <a name=\"basic_string__swap\"></a>  basic_string::swap  \n Exchange the contents of two strings.  \n  \n```  \nvoid swap(\n    basic_string<CharType, Traits, Allocator>& str);\n```  \n  \n### Parameters  \n ` str`  \n The source string whose elements are to be exchanged with those in the destination string.  \n  \n### Remarks  \n If the strings being swapped have the same allocator object, the `swap` member function:  \n  \n-   Occurs in constant time.  \n  \n-   Throws no exceptions.  \n  \n-   Invalidates no references, pointers, or iterators that designate elements in the two strings.  \n  \n Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.  \n  \n### Example  \n  \n```cpp  \n// basic_string_swap.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"Tweedledee\" );  \n   string s2 ( \"Tweedledum\" );  \n   cout << \"Before swapping string s1 and s2:\" << endl;  \n   cout << \" The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \" The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   s1.swap ( s2 );  \n   cout << \"After swapping string s1 and s2:\" << endl;  \n   cout << \" The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \" The basic_string s2 = \" << s2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nBefore swapping string s1 and s2:  \n The basic_string s1 = Tweedledee.  \n The basic_string s2 = Tweedledum.  \nAfter swapping string s1 and s2:  \n The basic_string s1 = Tweedledum.  \n The basic_string s2 = Tweedledee.  \n```  \n  \n##  <a name=\"basic_string__traits_type\"></a>  basic_string::traits_type  \n A type for the character traits of the elements stored in a string.  \n  \n```  \ntypedef Traits traits_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the second template parameter **Traits**.  \n  \n For type **string**, it is equivalent to **char_traits\\<char>**.  \n  \n### Example  \n  See the example for [copy](../standard-library/char-traits-struct.md#char_traits__copy) for an example of how to declare and use `traits_type`.  \n  \n##  <a name=\"basic_string__value_type\"></a>  basic_string::value_type  \n A type that represents the type of characters stored in a string.  \n  \n```  \ntypedef typename allocator_type::value_type value_type;  \n```  \n  \n### Remarks  \n It is equivalent to **traits_type::char_type** and is equivalent to `char` for objects of type **string**.  \n  \n### Example  \n  \n```cpp  \n// basic_string_value_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   basic_string<char>::value_type ch1 = 'G';  \n  \n   char ch2 = 'H';  \n  \n   cout << \"The character ch1 is: \" << ch1 << \".\" << endl;  \n   cout << \"The character ch2 is: \" << ch2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe character ch1 is: G.  \nThe character ch2 is: H.  \n```  \n  \n## See Also  \n [\\<string>](../standard-library/string.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}