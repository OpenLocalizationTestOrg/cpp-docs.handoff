{"nodes":[{"pos":[12,70],"content":"How to: Create and Use weak_ptr Instances | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Create and Use weak_ptr Instances | Microsoft Docs","pos":[0,58]}]},{"content":"How to: Create and Use weak_ptr Instances","pos":[551,592]},{"content":"Sometimes an object must store a way to access the underlying object of a <ph id=\"ph1\">`shared_ptr`</ph> without causing the reference count to be incremented.","pos":[593,734],"source":"Sometimes an object must store a way to access the underlying object of a `shared_ptr` without causing the reference count to be incremented."},{"content":"Typically, this situation occurs when you have cyclic references between <ph id=\"ph1\">`shared_ptr`</ph> instances.","pos":[735,831],"source":" Typically, this situation occurs when you have cyclic references between `shared_ptr` instances."},{"content":"The best design is to avoid shared ownership of pointers whenever you can.","pos":[838,912]},{"content":"However, if you must have shared ownership of <ph id=\"ph1\">`shared_ptr`</ph> instances, avoid cyclic references between them.","pos":[913,1020],"source":" However, if you must have shared ownership of `shared_ptr` instances, avoid cyclic references between them."},{"content":"When cyclic references are unavoidable, or even preferable for some reason, use <ph id=\"ph1\">`weak_ptr`</ph> to give one or more of the owners a weak reference to another <ph id=\"ph2\">`shared_ptr`</ph>.","pos":[1021,1187],"source":" When cyclic references are unavoidable, or even preferable for some reason, use `weak_ptr` to give one or more of the owners a weak reference to another `shared_ptr`."},{"content":"By using a <ph id=\"ph1\">`weak_ptr`</ph>, you can create a <ph id=\"ph2\">`shared_ptr`</ph> that joins to an existing set of related instances, but only if the underlying memory resource is still valid.","pos":[1188,1351],"source":" By using a `weak_ptr`, you can create a `shared_ptr` that joins to an existing set of related instances, but only if the underlying memory resource is still valid."},{"content":"A <ph id=\"ph1\">`weak_ptr`</ph> itself does not participate in the reference counting, and therefore, it cannot prevent the reference count from going to zero.","pos":[1352,1492],"source":" A `weak_ptr` itself does not participate in the reference counting, and therefore, it cannot prevent the reference count from going to zero."},{"content":"However, you can use a <ph id=\"ph1\">`weak_ptr`</ph> to try to obtain a new copy of the <ph id=\"ph2\">`shared_ptr`</ph> with which it was initialized.","pos":[1493,1605],"source":" However, you can use a `weak_ptr` to try to obtain a new copy of the `shared_ptr` with which it was initialized."},{"content":"If the memory has already been deleted, a <bpt id=\"p1\">**</bpt>bad_weak_ptr<ept id=\"p1\">**</ept> exception is thrown.","pos":[1606,1685],"source":" If the memory has already been deleted, a **bad_weak_ptr** exception is thrown."},{"content":"If the memory is still valid, the new shared pointer increments the reference count and guarantees that the memory will be valid as long as the <ph id=\"ph1\">`shared_ptr`</ph> variable stays in scope.","pos":[1686,1867],"source":" If the memory is still valid, the new shared pointer increments the reference count and guarantees that the memory will be valid as long as the `shared_ptr` variable stays in scope."},{"content":"Example","pos":[1876,1883]},{"content":"The following code example shows a case where <ph id=\"ph1\">`weak_ptr`</ph> is used to ensure proper deletion of objects that have circular dependencies.","pos":[1887,2021],"source":"The following code example shows a case where `weak_ptr` is used to ensure proper deletion of objects that have circular dependencies."},{"content":"As you examine the example, assume that it was created only after alternative solutions were considered.","pos":[2022,2126]},{"content":"The <ph id=\"ph1\">`Controller`</ph> objects represent some aspect of a machine process, and they operate independently.","pos":[2127,2227],"source":" The `Controller` objects represent some aspect of a machine process, and they operate independently."},{"content":"Each controller must be able to query the status of the other controllers at any time, and each one contains a private <ph id=\"ph1\">`vector&lt;weak_ptr&lt;Controller&gt;&gt;`</ph> for this purpose.","pos":[2228,2395],"source":" Each controller must be able to query the status of the other controllers at any time, and each one contains a private `vector<weak_ptr<Controller>>` for this purpose."},{"content":"Each vector contains a circular reference, and therefore, <ph id=\"ph1\">`weak_ptr`</ph> instances are used instead of <ph id=\"ph2\">`shared_ptr`</ph>.","pos":[2396,2508],"source":" Each vector contains a circular reference, and therefore, `weak_ptr` instances are used instead of `shared_ptr`."},{"pos":[2526,2548],"content":"stl_smart_pointers#222"},{"pos":[3660,3833],"content":"As an experiment, modify the vector <ph id=\"ph1\">`others`</ph> to be a <ph id=\"ph2\">`vector&lt;shared_ptr&lt;Controller&gt;&gt;`</ph>, and then in the output, notice that no destructors are invoked when <ph id=\"ph3\">`TestRun`</ph> returns.","source":"As an experiment, modify the vector `others` to be a `vector<shared_ptr<Controller>>`, and then in the output, notice that no destructors are invoked when `TestRun` returns."},{"content":"See Also","pos":[3842,3850]},{"content":"Smart Pointers","pos":[3855,3869]}],"content":"---\ntitle: \"How to: Create and Use weak_ptr Instances | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8dd6909b-b070-4afa-9696-f2fc94579c65\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Create and Use weak_ptr Instances\nSometimes an object must store a way to access the underlying object of a `shared_ptr` without causing the reference count to be incremented. Typically, this situation occurs when you have cyclic references between `shared_ptr` instances.  \n  \n The best design is to avoid shared ownership of pointers whenever you can. However, if you must have shared ownership of `shared_ptr` instances, avoid cyclic references between them. When cyclic references are unavoidable, or even preferable for some reason, use `weak_ptr` to give one or more of the owners a weak reference to another `shared_ptr`. By using a `weak_ptr`, you can create a `shared_ptr` that joins to an existing set of related instances, but only if the underlying memory resource is still valid. A `weak_ptr` itself does not participate in the reference counting, and therefore, it cannot prevent the reference count from going to zero. However, you can use a `weak_ptr` to try to obtain a new copy of the `shared_ptr` with which it was initialized. If the memory has already been deleted, a **bad_weak_ptr** exception is thrown. If the memory is still valid, the new shared pointer increments the reference count and guarantees that the memory will be valid as long as the `shared_ptr` variable stays in scope.  \n  \n## Example  \n The following code example shows a case where `weak_ptr` is used to ensure proper deletion of objects that have circular dependencies. As you examine the example, assume that it was created only after alternative solutions were considered. The `Controller` objects represent some aspect of a machine process, and they operate independently. Each controller must be able to query the status of the other controllers at any time, and each one contains a private `vector<weak_ptr<Controller>>` for this purpose. Each vector contains a circular reference, and therefore, `weak_ptr` instances are used instead of `shared_ptr`.  \n  \n [!code-cpp[stl_smart_pointers#222](../cpp/codesnippet/CPP/how-to-create-and-use-weak-ptr-instances_1.cpp)]  \n  \n```Output  \nCreating Controller0Creating Controller1Creating Controller2Creating Controller3Creating Controller4push_back to v[0]: 1push_back to v[0]: 2push_back to v[0]: 3push_back to v[0]: 4push_back to v[1]: 0push_back to v[1]: 2push_back to v[1]: 3push_back to v[1]: 4push_back to v[2]: 0push_back to v[2]: 1push_back to v[2]: 3push_back to v[2]: 4push_back to v[3]: 0push_back to v[3]: 1push_back to v[3]: 2push_back to v[3]: 4push_back to v[4]: 0push_back to v[4]: 1push_back to v[4]: 2push_back to v[4]: 3use_count = 1Status of 1 = OnStatus of 2 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 2 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 2 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 2 = OnStatus of 3 = OnDestroying Controller0Destroying Controller1Destroying Controller2Destroying Controller3Destroying Controller4Press any key  \n```  \n  \n As an experiment, modify the vector `others` to be a `vector<shared_ptr<Controller>>`, and then in the output, notice that no destructors are invoked when `TestRun` returns.  \n  \n## See Also  \n [Smart Pointers](../cpp/smart-pointers-modern-cpp.md)"}