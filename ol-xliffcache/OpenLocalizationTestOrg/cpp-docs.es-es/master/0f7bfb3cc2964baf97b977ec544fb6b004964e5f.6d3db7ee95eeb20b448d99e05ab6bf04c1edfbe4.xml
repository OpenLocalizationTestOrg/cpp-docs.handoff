{"nodes":[{"pos":[12,60],"content":"Using extern to Specify Linkage | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using extern to Specify Linkage | Microsoft Docs","pos":[0,48]}]},{"content":"Using extern to Specify Linkage","pos":[727,758]},{"content":"Syntax","pos":[762,768]},{"content":"Remarks","pos":[882,889]},{"content":"The <ph id=\"ph1\">`extern`</ph> keyword declares a variable or function and specifies that it has external linkage (its name is visible from files other than the one in which it's defined).","pos":[893,1063],"source":"The `extern` keyword declares a variable or function and specifies that it has external linkage (its name is visible from files other than the one in which it's defined)."},{"content":"When modifying a variable, <ph id=\"ph1\">`extern`</ph> specifies that the variable has static duration (it is allocated when the program begins and deallocated when the program ends).","pos":[1064,1228],"source":" When modifying a variable, `extern` specifies that the variable has static duration (it is allocated when the program begins and deallocated when the program ends)."},{"content":"The variable or function may be defined in another source file, or later in the same file.","pos":[1229,1319]},{"content":"Declarations of variables and functions at file scope are external by default.","pos":[1320,1398]},{"content":"Example","pos":[1407,1414]},{"content":"In C++, when used with a string, <ph id=\"ph1\">`extern`</ph> specifies that the linkage conventions of another language are being used for the declarator(s).","pos":[1770,1908],"source":"In C++, when used with a string, `extern` specifies that the linkage conventions of another language are being used for the declarator(s)."},{"content":"C functions and data can be accessed only if they are previously declared as having C linkage.","pos":[1909,2003]},{"content":"However, they must be defined in a separately compiled translation unit.","pos":[2004,2076]},{"content":"Microsoft C++ supports the strings <bpt id=\"p1\">**</bpt>\"C\"<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>\"C++\"<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">*</bpt>string-literal<ept id=\"p3\">*</ept> field.","pos":[2083,2170],"source":"Microsoft C++ supports the strings **\"C\"** and **\"C++\"** in the *string-literal* field."},{"content":"All of the standard include files use the <ph id=\"ph1\">`extern`</ph> \"C\" syntax to allow the run-time library functions to be used in C++ programs.","pos":[2171,2300],"source":" All of the standard include files use the `extern` \"C\" syntax to allow the run-time library functions to be used in C++ programs."},{"content":"Example","pos":[2309,2316]},{"content":"The following example shows alternative ways to declare names that have C linkage:","pos":[2320,2402]},{"content":"If a function has more than one linkage specification, they must agree; it is an error to declare functions as having both C and C++ linkage.","pos":[3220,3361]},{"content":"Furthermore, if two declarations for a function occur in a program — one with a linkage specification and one without — the declaration with the linkage specification must be first.","pos":[3362,3543]},{"content":"Any redundant declarations of functions that already have linkage specification are given the linkage specified in the first declaration.","pos":[3544,3681]},{"content":"For example:","pos":[3682,3694]},{"content":"Functions and objects explicitly declared as <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> within the body of a compound linkage specifier (<bpt id=\"p2\">**</bpt>{ }<ept id=\"p2\">**</ept>) are treated as static functions or objects; the linkage specifier is ignored.","pos":[4054,4245],"source":"Functions and objects explicitly declared as **static** within the body of a compound linkage specifier (**{ }**) are treated as static functions or objects; the linkage specifier is ignored."},{"content":"Other functions and objects behave as if declared using the <ph id=\"ph1\">`extern`</ph> keyword.","pos":[4246,4323],"source":" Other functions and objects behave as if declared using the `extern` keyword."},{"content":"(See <bpt id=\"p1\">[</bpt>Using extern to Specify Linkage<ept id=\"p1\">](../cpp/using-extern-to-specify-linkage.md)</ept> for details about the <ph id=\"ph1\">`extern`</ph> keyword.)","pos":[4324,4446],"source":" (See [Using extern to Specify Linkage](../cpp/using-extern-to-specify-linkage.md) for details about the `extern` keyword.)"},{"content":"See Also","pos":[4455,4463]},{"content":"Keywords","pos":[4468,4476]},{"content":"extern Storage-Class Specifier","pos":[4507,4537]},{"content":"Behavior of Identifiers","pos":[4593,4616]},{"content":"Linkage","pos":[4665,4672]}],"content":"---\ntitle: \"Using extern to Specify Linkage | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"extern\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"extern keyword [C++], linkage to non-C++ functions\"\n  - \"declarations, external\"\n  - \"external linkage, extern modifier\"\nms.assetid: 1e2f0ae3-ae98-4410-85b5-222d6abc865a\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using extern to Specify Linkage\n## Syntax  \n  \n```  \n  \n      extern string-literal { declaration-list }  \nextern string-literal declaration  \n```  \n  \n## Remarks  \n The `extern` keyword declares a variable or function and specifies that it has external linkage (its name is visible from files other than the one in which it's defined). When modifying a variable, `extern` specifies that the variable has static duration (it is allocated when the program begins and deallocated when the program ends). The variable or function may be defined in another source file, or later in the same file. Declarations of variables and functions at file scope are external by default.  \n  \n## Example  \n  \n```  \n// specifying_linkage1.cpp  \nint i = 1;  \nvoid other();  \n  \nint main() {  \n   // Reference to i, defined above:  \n   extern int i;  \n}  \n  \nvoid other() {  \n   // Address of global i assigned to pointer variable:  \n   static int *external_i = &i;  \n  \n   // i will be redefined; global i no longer visible:  \n   // int i = 16;  \n}  \n```  \n  \n In C++, when used with a string, `extern` specifies that the linkage conventions of another language are being used for the declarator(s). C functions and data can be accessed only if they are previously declared as having C linkage. However, they must be defined in a separately compiled translation unit.  \n  \n Microsoft C++ supports the strings **\"C\"** and **\"C++\"** in the *string-literal* field. All of the standard include files use the `extern` \"C\" syntax to allow the run-time library functions to be used in C++ programs.  \n  \n## Example  \n The following example shows alternative ways to declare names that have C linkage:  \n  \n```  \n// specifying_linkage2.cpp  \n// compile with: /c  \n// Declare printf with C linkage.  \nextern \"C\" int printf( const char *fmt, ... );  \n  \n//  Cause everything in the specified header files  \n//   to have C linkage.  \nextern \"C\" {  \n   // add your #include statements here  \n   #include <stdio.h>  \n}  \n  \n//  Declare the two functions ShowChar and GetChar  \n//   with C linkage.  \nextern \"C\" {  \n   char ShowChar( char ch );  \n   char GetChar( void );  \n}  \n  \n//  Define the two functions ShowChar and GetChar  \n//   with C linkage.  \nextern \"C\" char ShowChar( char ch ) {  \n   putchar( ch );  \n   return ch;  \n}  \n  \nextern \"C\" char GetChar( void ) {  \n   char ch;  \n  \n   ch = getchar();  \n   return ch;  \n}  \n  \n// Declare a global variable, errno, with C linkage.  \nextern \"C\" int errno;  \n```  \n  \n If a function has more than one linkage specification, they must agree; it is an error to declare functions as having both C and C++ linkage. Furthermore, if two declarations for a function occur in a program — one with a linkage specification and one without — the declaration with the linkage specification must be first. Any redundant declarations of functions that already have linkage specification are given the linkage specified in the first declaration. For example:  \n  \n```  \nextern \"C\" int CFunc1();  \n...  \nint CFunc1();            // Redeclaration is benign; C linkage is  \n                         //  retained.  \n  \nint CFunc2();  \n...  \nextern \"C\" int CFunc2(); // Error: not the first declaration of  \n                         //  CFunc2;  cannot contain linkage  \n                         //  specifier.  \n```  \n  \n Functions and objects explicitly declared as **static** within the body of a compound linkage specifier (**{ }**) are treated as static functions or objects; the linkage specifier is ignored. Other functions and objects behave as if declared using the `extern` keyword. (See [Using extern to Specify Linkage](../cpp/using-extern-to-specify-linkage.md) for details about the `extern` keyword.)  \n  \n## See Also  \n [Keywords](../cpp/keywords-cpp.md)   \n [extern Storage-Class Specifier](../c-language/extern-storage-class-specifier.md)   \n [Behavior of Identifiers](../c-language/behavior-of-identifiers.md)   \n [Linkage](../c-language/linkage.md)"}