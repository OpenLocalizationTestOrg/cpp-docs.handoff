{"nodes":[{"pos":[12,76],"content":"Recordset: Working with Large Data Items (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recordset: Working with Large Data Items (ODBC) | Microsoft Docs","pos":[0,64]}]},{"content":"Recordset: Working with Large Data Items (ODBC)","pos":[778,825]},{"content":"This topic applies to both the MFC ODBC classes and the MFC DAO classes.","pos":[826,898]},{"pos":[906,1385],"content":"[!NOTE]\n If you are using the MFC DAO classes, manage your large data items with class [CByteArray](../../mfc/reference/cbytearray-class.md) rather than class [CLongBinary](../../mfc/reference/clongbinary-class.md). If you are using the MFC ODBC classes with bulk row fetching, use `CLongBinary` rather than `CByteArray`. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you are using the MFC DAO classes, manage your large data items with class [CByteArray](../../mfc/reference/cbytearray-class.md) rather than class [CLongBinary](../../mfc/reference/clongbinary-class.md). If you are using the MFC ODBC classes with bulk row fetching, use `CLongBinary` rather than `CByteArray`. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,477],"nodes":[{"content":"If you are using the MFC DAO classes, manage your large data items with class <bpt id=\"p1\">[</bpt>CByteArray<ept id=\"p1\">](../../mfc/reference/cbytearray-class.md)</ept> rather than class <bpt id=\"p2\">[</bpt>CLongBinary<ept id=\"p2\">](../../mfc/reference/clongbinary-class.md)</ept>.","pos":[1,207],"source":" If you are using the MFC DAO classes, manage your large data items with class [CByteArray](../../mfc/reference/cbytearray-class.md) rather than class [CLongBinary](../../mfc/reference/clongbinary-class.md)."},{"content":"If you are using the MFC ODBC classes with bulk row fetching, use <ph id=\"ph1\">`CLongBinary`</ph> rather than <ph id=\"ph2\">`CByteArray`</ph>.","pos":[208,313],"source":" If you are using the MFC ODBC classes with bulk row fetching, use `CLongBinary` rather than `CByteArray`."},{"content":"For more information about bulk row fetching, see <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[314,469],"source":" For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"Suppose your database can store large pieces of data, such as bitmaps (employee photographs, maps, pictures of products, OLE objects, and so on).","pos":[1392,1537]},{"content":"This kind of data is often referred to as a Binary Large Object (or BLOB) because:","pos":[1538,1620]},{"content":"Each field value is large.","pos":[1630,1656]},{"content":"Unlike numbers and other simple data types, it has no predictable size.","pos":[1666,1737]},{"content":"The data is formless from the perspective of your program.","pos":[1747,1805]},{"content":"This topic explains what support the database classes provide for working with such objects.","pos":[1812,1904]},{"pos":[1958,1980],"content":"Managing Large Objects"},{"content":"Recordsets have two ways to solve the special difficulty of managing binary large objects.","pos":[1984,2074]},{"content":"You can use class <bpt id=\"p1\">[</bpt>CByteArray<ept id=\"p1\">](../../mfc/reference/cbytearray-class.md)</ept> or you can use class <bpt id=\"p2\">[</bpt>CLongBinary<ept id=\"p2\">](../../mfc/reference/clongbinary-class.md)</ept>.","pos":[2075,2224],"source":" You can use class [CByteArray](../../mfc/reference/cbytearray-class.md) or you can use class [CLongBinary](../../mfc/reference/clongbinary-class.md)."},{"content":"In general, <ph id=\"ph1\">`CByteArray`</ph> is the preferred way to manage large binary data.","pos":[2225,2299],"source":" In general, `CByteArray` is the preferred way to manage large binary data."},{"content":"requires more overhead than <ph id=\"ph1\">`CLongBinary`</ph> but is more capable, as described in <bpt id=\"p1\">[</bpt>The CByteArray Class<ept id=\"p1\">](#_core_the_cbytearray_class)</ept>.","pos":[2319,2450],"source":" requires more overhead than `CLongBinary` but is more capable, as described in [The CByteArray Class](#_core_the_cbytearray_class)."},{"content":"is described briefly in <bpt id=\"p1\">[</bpt>The CLongBinary Class<ept id=\"p1\">](#_core_the_clongbinary_class)</ept>.","pos":[2465,2543],"source":" is described briefly in [The CLongBinary Class](#_core_the_clongbinary_class)."},{"pos":[2550,2723],"content":"For detailed information about using <ph id=\"ph1\">`CByteArray`</ph> to work with large data items, see <bpt id=\"p1\">[</bpt>Technical Note 45<ept id=\"p1\">](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)</ept>.","source":"For detailed information about using `CByteArray` to work with large data items, see [Technical Note 45](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)."},{"pos":[2775,2791],"content":"CByteArray Class"},{"content":"is one of the MFC collection classes.","pos":[2808,2845]},{"content":"A <ph id=\"ph1\">`CByteArray`</ph> object stores a dynamic array of bytes — the array can grow if needed.","pos":[2846,2931],"source":" A `CByteArray` object stores a dynamic array of bytes — the array can grow if needed."},{"content":"The class provides fast access by index, as with built-in C++ arrays.","pos":[2932,3001]},{"content":"objects can be serialized and dumped for diagnostic purposes.","pos":[3015,3076]},{"content":"The class supplies member functions for getting and setting specified bytes, inserting and appending bytes, and removing one byte or all bytes.","pos":[3077,3220]},{"content":"These facilities make parsing the binary data easier.","pos":[3221,3274]},{"content":"For example, if the binary object is an OLE object, you might have to work through some header bytes to reach the actual object.","pos":[3275,3403]},{"pos":[3465,3495],"content":"Using CByteArray in Recordsets"},{"content":"By giving a field data member of your recordset the type <ph id=\"ph1\">`CByteArray`</ph>, you provide a fixed base from which <bpt id=\"p1\">[</bpt>RFX<ept id=\"p1\">](../../data/odbc/record-field-exchange-rfx.md)</ept> can manage the transfer of such an object between your recordset and the data source and through which you can manipulate the data inside the object.","pos":[3499,3807],"source":"By giving a field data member of your recordset the type `CByteArray`, you provide a fixed base from which [RFX](../../data/odbc/record-field-exchange-rfx.md) can manage the transfer of such an object between your recordset and the data source and through which you can manipulate the data inside the object."},{"content":"RFX needs a specific site for retrieved data, and you need a way to access the underlying data.","pos":[3808,3903]},{"pos":[3910,4083],"content":"For detailed information about using <ph id=\"ph1\">`CByteArray`</ph> to work with large data items, see <bpt id=\"p1\">[</bpt>Technical Note 45<ept id=\"p1\">](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)</ept>.","source":"For detailed information about using `CByteArray` to work with large data items, see [Technical Note 45](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)."},{"pos":[4136,4153],"content":"CLongBinary Class"},{"content":"A <bpt id=\"p1\">[</bpt>CLongBinary<ept id=\"p1\">](../../mfc/reference/clongbinary-class.md)</ept> object is a simple shell around an <ph id=\"ph1\">`HGLOBAL`</ph> handle to a block of storage allocated on the heap.","pos":[4157,4311],"source":"A [CLongBinary](../../mfc/reference/clongbinary-class.md) object is a simple shell around an `HGLOBAL` handle to a block of storage allocated on the heap."},{"content":"When it binds a table column containing a binary large object, RFX allocates the <ph id=\"ph1\">`HGLOBAL`</ph> handle when it needs to transfer the data to the recordset and stores the handle in the <ph id=\"ph2\">`CLongBinary`</ph> field of the recordset.","pos":[4312,4528],"source":" When it binds a table column containing a binary large object, RFX allocates the `HGLOBAL` handle when it needs to transfer the data to the recordset and stores the handle in the `CLongBinary` field of the recordset."},{"content":"In turn, you use the <ph id=\"ph1\">`HGLOBAL`</ph> handle, <ph id=\"ph2\">`m_hData`</ph>, to work with the data itself, operating on it as you would on any handle data.","pos":[4535,4663],"source":"In turn, you use the `HGLOBAL` handle, `m_hData`, to work with the data itself, operating on it as you would on any handle data."},{"content":"This is where <bpt id=\"p1\">[</bpt>CByteArray<ept id=\"p1\">](../../mfc/reference/cbytearray-class.md)</ept> adds capabilities.","pos":[4664,4750],"source":" This is where [CByteArray](../../mfc/reference/cbytearray-class.md) adds capabilities."},{"pos":[4758,5078],"content":"[!CAUTION]\n CLongBinary objects cannot be used as parameters in function calls. In addition, their implementation, which calls **::SQLGetData**, necessarily slows scrolling performance for a scrollable snapshot. This might also be true when you use an **::SQLGetData** call yourself to retrieve dynamic schema columns.","leadings":["","> "],"nodes":[{"content":" CLongBinary objects cannot be used as parameters in function calls. In addition, their implementation, which calls **::SQLGetData**, necessarily slows scrolling performance for a scrollable snapshot. This might also be true when you use an **::SQLGetData** call yourself to retrieve dynamic schema columns.","pos":[11,318],"nodes":[{"content":"CLongBinary objects cannot be used as parameters in function calls.","pos":[1,68]},{"content":"In addition, their implementation, which calls <bpt id=\"p1\">**</bpt>::SQLGetData<ept id=\"p1\">**</ept>, necessarily slows scrolling performance for a scrollable snapshot.","pos":[69,200],"source":" In addition, their implementation, which calls **::SQLGetData**, necessarily slows scrolling performance for a scrollable snapshot."},{"content":"This might also be true when you use an <bpt id=\"p1\">**</bpt>::SQLGetData<ept id=\"p1\">**</ept> call yourself to retrieve dynamic schema columns.","pos":[201,307],"source":" This might also be true when you use an **::SQLGetData** call yourself to retrieve dynamic schema columns."}]}]},{"content":"See Also","pos":[5087,5095]},{"content":"Recordset (ODBC)","pos":[5100,5116]},{"content":"Recordset: Obtaining SUMs and Other Aggregate Results (ODBC)","pos":[5158,5218]},{"content":"Record Field Exchange (RFX)","pos":[5303,5330]}],"content":"---\ntitle: \"Recordset: Working with Large Data Items (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"BLOB (binary large object), recordsets\"\n  - \"ODBC recordsets, binary large objects\"\n  - \"recordsets, binary large objects\"\n  - \"binary large objects\"\n  - \"CLongBinary class, using in recordsets\"\nms.assetid: 3e80b5a8-b6e7-43c6-a816-e54befc513a3\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recordset: Working with Large Data Items (ODBC)\nThis topic applies to both the MFC ODBC classes and the MFC DAO classes.  \n  \n> [!NOTE]\n>  If you are using the MFC DAO classes, manage your large data items with class [CByteArray](../../mfc/reference/cbytearray-class.md) rather than class [CLongBinary](../../mfc/reference/clongbinary-class.md). If you are using the MFC ODBC classes with bulk row fetching, use `CLongBinary` rather than `CByteArray`. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n Suppose your database can store large pieces of data, such as bitmaps (employee photographs, maps, pictures of products, OLE objects, and so on). This kind of data is often referred to as a Binary Large Object (or BLOB) because:  \n  \n-   Each field value is large.  \n  \n-   Unlike numbers and other simple data types, it has no predictable size.  \n  \n-   The data is formless from the perspective of your program.  \n  \n This topic explains what support the database classes provide for working with such objects.  \n  \n##  <a name=\"_core_managing_large_objects\"></a> Managing Large Objects  \n Recordsets have two ways to solve the special difficulty of managing binary large objects. You can use class [CByteArray](../../mfc/reference/cbytearray-class.md) or you can use class [CLongBinary](../../mfc/reference/clongbinary-class.md). In general, `CByteArray` is the preferred way to manage large binary data.  \n  \n `CByteArray` requires more overhead than `CLongBinary` but is more capable, as described in [The CByteArray Class](#_core_the_cbytearray_class). `CLongBinary` is described briefly in [The CLongBinary Class](#_core_the_clongbinary_class).  \n  \n For detailed information about using `CByteArray` to work with large data items, see [Technical Note 45](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md).  \n  \n##  <a name=\"_core_the_cbytearray_class\"></a> CByteArray Class  \n `CByteArray` is one of the MFC collection classes. A `CByteArray` object stores a dynamic array of bytes — the array can grow if needed. The class provides fast access by index, as with built-in C++ arrays. `CByteArray` objects can be serialized and dumped for diagnostic purposes. The class supplies member functions for getting and setting specified bytes, inserting and appending bytes, and removing one byte or all bytes. These facilities make parsing the binary data easier. For example, if the binary object is an OLE object, you might have to work through some header bytes to reach the actual object.  \n  \n##  <a name=\"_core_using_cbytearray_in_recordsets\"></a> Using CByteArray in Recordsets  \n By giving a field data member of your recordset the type `CByteArray`, you provide a fixed base from which [RFX](../../data/odbc/record-field-exchange-rfx.md) can manage the transfer of such an object between your recordset and the data source and through which you can manipulate the data inside the object. RFX needs a specific site for retrieved data, and you need a way to access the underlying data.  \n  \n For detailed information about using `CByteArray` to work with large data items, see [Technical Note 45](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md).  \n  \n##  <a name=\"_core_the_clongbinary_class\"></a> CLongBinary Class  \n A [CLongBinary](../../mfc/reference/clongbinary-class.md) object is a simple shell around an `HGLOBAL` handle to a block of storage allocated on the heap. When it binds a table column containing a binary large object, RFX allocates the `HGLOBAL` handle when it needs to transfer the data to the recordset and stores the handle in the `CLongBinary` field of the recordset.  \n  \n In turn, you use the `HGLOBAL` handle, `m_hData`, to work with the data itself, operating on it as you would on any handle data. This is where [CByteArray](../../mfc/reference/cbytearray-class.md) adds capabilities.  \n  \n> [!CAUTION]\n>  CLongBinary objects cannot be used as parameters in function calls. In addition, their implementation, which calls **::SQLGetData**, necessarily slows scrolling performance for a scrollable snapshot. This might also be true when you use an **::SQLGetData** call yourself to retrieve dynamic schema columns.  \n  \n## See Also  \n [Recordset (ODBC)](../../data/odbc/recordset-odbc.md)   \n [Recordset: Obtaining SUMs and Other Aggregate Results (ODBC)](../../data/odbc/recordset-obtaining-sums-and-other-aggregate-results-odbc.md)   \n [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md)"}