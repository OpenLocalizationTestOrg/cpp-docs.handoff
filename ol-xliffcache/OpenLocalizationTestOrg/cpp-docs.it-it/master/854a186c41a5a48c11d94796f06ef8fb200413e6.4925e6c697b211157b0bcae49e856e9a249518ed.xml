{"nodes":[{"pos":[12,53],"content":"&lt;string&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>string<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,41],"source":"&lt;string&gt; functions | Microsoft Docs"}]},{"pos":[296,320],"content":"&lt;string&gt; functions","linkify":"&lt;string&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>string<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,24],"source":"&lt;string&gt; functions"}]},{"pos":[339,358],"content":"<bpt id=\"p1\">[</bpt>getline<ept id=\"p1\">](#getline)</ept>","source":"[getline](#getline)"},{"pos":[359,372],"content":"<bpt id=\"p1\">[</bpt>stod<ept id=\"p1\">](#stod)</ept>","source":"[stod](#stod)"},{"pos":[373,386],"content":"<bpt id=\"p1\">[</bpt>stof<ept id=\"p1\">](#stof)</ept>","source":"[stof](#stof)"},{"pos":[391,404],"content":"<bpt id=\"p1\">[</bpt>stoi<ept id=\"p1\">](#stoi)</ept>","source":"[stoi](#stoi)"},{"pos":[405,418],"content":"<bpt id=\"p1\">[</bpt>stol<ept id=\"p1\">](#stol)</ept>","source":"[stol](#stol)"},{"pos":[419,434],"content":"<bpt id=\"p1\">[</bpt>stold<ept id=\"p1\">](#stold)</ept>","source":"[stold](#stold)"},{"pos":[439,454],"content":"<bpt id=\"p1\">[</bpt>stoll<ept id=\"p1\">](#stoll)</ept>","source":"[stoll](#stoll)"},{"pos":[455,470],"content":"<bpt id=\"p1\">[</bpt>stoul<ept id=\"p1\">](#stoul)</ept>","source":"[stoul](#stoul)"},{"pos":[471,488],"content":"<bpt id=\"p1\">[</bpt>stoull<ept id=\"p1\">](#stoull)</ept>","source":"[stoull](#stoull)"},{"pos":[493,506],"content":"<bpt id=\"p1\">[</bpt>swap<ept id=\"p1\">](#swap)</ept>","source":"[swap](#swap)"},{"pos":[507,530],"content":"<bpt id=\"p1\">[</bpt>to_string<ept id=\"p1\">](#to_string)</ept>","source":"[to_string](#to_string)"},{"pos":[531,556],"content":"<bpt id=\"p1\">[</bpt>to_wstring<ept id=\"p1\">](#to_wstring)</ept>","source":"[to_wstring](#to_wstring)"},{"pos":[567,598],"content":"<bpt id=\"p1\">&lt;a name=\"getline\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  getline","linkify":"<a name=\"getline\"></a>  getline","source":"<a name=\"getline\"></a>  getline"},{"content":"Extract strings from the input stream line-by-line.","pos":[602,653]},{"pos":[1593,1603],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The input stream from which a string is to be extracted.","pos":[1615,1671]},{"content":"The string into which are read the characters from the input stream.","pos":[1687,1755]},{"content":"The line delimiter.","pos":[1773,1792]},{"pos":[1802,1814],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[1818,1840],"content":"The input stream <ph id=\"ph1\">`is`</ph>.","source":"The input stream `is`."},{"pos":[1850,1857],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1861,1981],"content":"The pair of function signatures marked <ph id=\"ph1\">`(1)`</ph> extract characters from <ph id=\"ph2\">`is`</ph> until <ph id=\"ph3\">`delim`</ph> is found, storing them in <ph id=\"ph4\">`str`</ph>.","source":"The pair of function signatures marked `(1)` extract characters from `is` until `delim` is found, storing them in `str`."},{"content":"The pair of function signatures marked <ph id=\"ph1\">`(2)`</ph> use newline as the default line delimiter and behave as <bpt id=\"p1\">**</bpt>getline<ept id=\"p1\">**</ept>( <ph id=\"ph2\">`is`</ph>, <ph id=\"ph3\">`str`</ph>, <ph id=\"ph4\">`is`</ph>.","pos":[1988,2120],"source":"The pair of function signatures marked `(2)` use newline as the default line delimiter and behave as **getline**( `is`, `str`, `is`."},{"content":"<ph id=\"ph1\">`widen`</ph>(' <ph id=\"ph2\">`\\n`</ph>')).","pos":[2121,2139],"source":"`widen`(' `\\n`'))."},{"pos":[2146,2282],"content":"The second function of each pair is an analog to the first one to support <bpt id=\"p1\">[</bpt>rvalue references<ept id=\"p1\">](../cpp/lvalues-and-rvalues-visual-cpp.md)</ept>.","source":"The second function of each pair is an analog to the first one to support [rvalue references](../cpp/lvalues-and-rvalues-visual-cpp.md)."},{"content":"Extraction stops when one of the following occurs:","pos":[2289,2339]},{"pos":[2349,2440],"content":"At end-of-file, in which case the internal state flag of <ph id=\"ph1\">`is`</ph> is set to <ph id=\"ph2\">`ios_base::eofbit`</ph>.","source":"At end-of-file, in which case the internal state flag of `is` is set to `ios_base::eofbit`."},{"pos":[2450,2609],"content":"After the function extracts an element that compares equal to <bpt id=\"p1\">**</bpt>delim<ept id=\"p1\">**</ept>, in which case the element is neither put back nor appended to the controlled sequence.","source":"After the function extracts an element that compares equal to **delim**, in which case the element is neither put back nor appended to the controlled sequence."},{"pos":[2619,2816],"content":"After the function extracts <ph id=\"ph1\">`str.`</ph><bpt id=\"p1\">[</bpt>max_size<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__max_size)</ept> elements, in which case the internal state flag of <ph id=\"ph2\">`is`</ph> is set to <ph id=\"ph3\">`ios_base::failbit`</ph>.","source":"After the function extracts `str.`[max_size](../standard-library/basic-string-class.md#basic_string__max_size) elements, in which case the internal state flag of `is` is set to `ios_base::failbit`."},{"pos":[2826,2953],"content":"Some other error other than those previously listed, in which case the internal state flag of <ph id=\"ph1\">`is`</ph> is set to <ph id=\"ph2\">`ios_base::badbit`</ph>","source":"Some other error other than those previously listed, in which case the internal state flag of `is` is set to `ios_base::badbit`"},{"pos":[2960,3085],"content":"For information about internal state flags, see <bpt id=\"p1\">[</bpt>ios_base::iostate<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__iostate)</ept>.","source":"For information about internal state flags, see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate)."},{"content":"If the function extracts no elements, the internal state flag of <ph id=\"ph1\">`is`</ph> is set to <ph id=\"ph2\">`ios_base::failbit`</ph>.","pos":[3092,3192],"source":"If the function extracts no elements, the internal state flag of `is` is set to `ios_base::failbit`."},{"content":"In any case, <ph id=\"ph1\">`getline`</ph> returns <ph id=\"ph2\">`is`</ph>.","pos":[3193,3229],"source":" In any case, `getline` returns `is`."},{"pos":[3236,3304],"content":"If an exception is thrown, <ph id=\"ph1\">`is`</ph> and <ph id=\"ph2\">`str`</ph> are left in a valid state.","source":"If an exception is thrown, `is` and `str` are left in a valid state."},{"pos":[3314,3321],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following code demonstrates <ph id=\"ph1\">`getline()`</ph> in two modes: first with the default delimiter (newline) and second with a whitespace as delimiter.","pos":[3326,3469],"source":"The following code demonstrates `getline()` in two modes: first with the default delimiter (newline) and second with a whitespace as delimiter."},{"content":"The end-of-file character (CTRL-Z on the keyboard) is used to control termination of the while loops.","pos":[3470,3571]},{"content":"This sets the internal state flag of <ph id=\"ph1\">`cin`</ph> to <ph id=\"ph2\">`eofbit`</ph>, which must be cleared with <bpt id=\"p1\">[</bpt>basic_ios::clear()<ept id=\"p1\">](../standard-library/basic-ios-class.md#basic_ios__clear)</ept> before the second while loop will work properly.","pos":[3572,3781],"source":" This sets the internal state flag of `cin` to `eofbit`, which must be cleared with [basic_ios::clear()](../standard-library/basic-ios-class.md#basic_ios__clear) before the second while loop will work properly."},{"pos":[4783,4808],"content":"<bpt id=\"p1\">&lt;a name=\"stod\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stod","linkify":"<a name=\"stod\"></a>  stod","source":"<a name=\"stod\"></a>  stod"},{"pos":[4812,4856],"content":"Converts a character sequence to a <ph id=\"ph1\">`double`</ph>.","source":"Converts a character sequence to a `double`."},{"pos":[5009,5019],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[5026,5035]},{"content":"Description","pos":[5036,5047]},{"content":"The character sequence to be converted.","pos":[5097,5136]},{"content":"The index value of the first unconverted character.","pos":[5147,5198]},{"pos":[5209,5221],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[5225,5244],"content":"The <ph id=\"ph1\">`double`</ph> value.","source":"The `double` value."},{"pos":[5254,5261],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`double`</ph> as if by calling <ph id=\"ph4\">`strtod( str.c_str(), _Eptr)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[5265,5457],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `double` as if by calling `strtod( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[5458,5533],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[5534,5611],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[5612,5728],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[5738,5763],"content":"<bpt id=\"p1\">&lt;a name=\"stof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stof","linkify":"<a name=\"stof\"></a>  stof","source":"<a name=\"stof\"></a>  stof"},{"content":"Converts a character sequence to a float.","pos":[5767,5808]},{"pos":[5955,5965],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[5972,5981]},{"content":"Description","pos":[5982,5993]},{"content":"The character sequence to be converted.","pos":[6043,6082]},{"content":"The index value of the first unconverted character.","pos":[6093,6144]},{"pos":[6155,6167],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The float value.","pos":[6171,6187]},{"pos":[6197,6204],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`float`</ph> as if by calling <ph id=\"ph4\">`strtof( str.c_str(), _Eptr)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[6208,6399],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `float` as if by calling `strtof( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[6400,6475],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[6476,6553],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[6554,6670],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[6680,6705],"content":"<bpt id=\"p1\">&lt;a name=\"stoi\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stoi","linkify":"<a name=\"stoi\"></a>  stoi","source":"<a name=\"stoi\"></a>  stoi"},{"content":"Converts a character sequence to an integer.","pos":[6709,6753]},{"pos":[6936,6948],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The integer value.","pos":[6952,6970]},{"pos":[6980,6990],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[6997,7006]},{"content":"Description","pos":[7007,7018]},{"content":"The character sequence to be converted.","pos":[7068,7107]},{"content":"Contains the index of the first unconverted character on return.","pos":[7118,7182]},{"content":"The number base to use.","pos":[7193,7216]},{"pos":[7227,7234],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function <ph id=\"ph1\">`stoi`</ph> converts the sequence of characters in <ph id=\"ph2\">` str`</ph> to a value of type <ph id=\"ph3\">`int`</ph> and returns the value.","pos":[7238,7351],"source":"The function `stoi` converts the sequence of characters in ` str` to a value of type `int` and returns the value."},{"content":"For example, when passed a character sequence \"10\", the value returned by <ph id=\"ph1\">`stoi`</ph> is the integer 10.","pos":[7352,7451],"source":" For example, when passed a character sequence \"10\", the value returned by `stoi` is the integer 10."},{"content":"<ph id=\"ph1\">`stoi`</ph> behaves similarly to the function <ph id=\"ph2\">`strtol`</ph> for single-byte characters when it is called in the manner <ph id=\"ph3\">`strtol( str.c_str(), _Eptr, Idx)`</ph>, where <ph id=\"ph4\">`_Eptr`</ph> is an object internal to the function; or <ph id=\"ph5\">`wcstol`</ph> for wide characters, when it is called in similar manner, <ph id=\"ph6\">`wcstol(Str.c_str(), _Eptr, Idx)`</ph>.","pos":[7458,7760],"source":"`stoi` behaves similarly to the function `strtol` for single-byte characters when it is called in the manner `strtol( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function; or `wcstol` for wide characters, when it is called in similar manner, `wcstol(Str.c_str(), _Eptr, Idx)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>strtol, wcstol, _strtol_l, _wcstol_l<ept id=\"p1\">](../c-runtime-library/reference/strtol-wcstol-strtol-l-wcstol-l.md)</ept>.","pos":[7761,7893],"source":" For more information, see [strtol, wcstol, _strtol_l, _wcstol_l](../c-runtime-library/reference/strtol-wcstol-strtol-l-wcstol-l.md)."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr,``stoi`</ph> throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[7900,7979],"source":"If ` str.c_str() == *_Eptr,``stoi` throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, or if the returned value cannot be represented as an object of type <ph id=\"ph2\">`int`</ph>, it throws an object of type <ph id=\"ph3\">`out_of_range`</ph>.","pos":[7980,8132],"source":" If such a call would set `errno`, or if the returned value cannot be represented as an object of type `int`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr - _ str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph>.","pos":[8133,8231],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr - _ str.c_str()` in `*Idx`."},{"pos":[8241,8266],"content":"<bpt id=\"p1\">&lt;a name=\"stol\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stol","linkify":"<a name=\"stol\"></a>  stol","source":"<a name=\"stol\"></a>  stol"},{"pos":[8270,8312],"content":"Converts a character sequence to a <ph id=\"ph1\">`long`</ph>.","source":"Converts a character sequence to a `long`."},{"pos":[8496,8506],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[8513,8522]},{"content":"Description","pos":[8523,8534]},{"content":"The character sequence to be converted.","pos":[8584,8623]},{"content":"The index value of the first unconverted character.","pos":[8634,8685]},{"content":"The number base to use.","pos":[8696,8719]},{"pos":[8730,8742],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The long-integer value.","pos":[8746,8769]},{"pos":[8779,8786],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`long`</ph> as if by calling <ph id=\"ph4\">`strtol( str.c_str(), _Eptr, Idx)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[8790,8985],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `long` as if by calling `strtol( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[8986,9061],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[9062,9139],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[9140,9256],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[9266,9293],"content":"<bpt id=\"p1\">&lt;a name=\"stold\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stold","linkify":"<a name=\"stold\"></a>  stold","source":"<a name=\"stold\"></a>  stold"},{"pos":[9297,9346],"content":"Converts a character sequence to a <ph id=\"ph1\">`long double`</ph>.","source":"Converts a character sequence to a `long double`."},{"pos":[9497,9507],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[9514,9523]},{"content":"Description","pos":[9524,9535]},{"content":"The character sequence to be converted.","pos":[9585,9624]},{"content":"The index value of the first unconverted character.","pos":[9635,9686]},{"pos":[9697,9709],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[9713,9737],"content":"The <ph id=\"ph1\">`long double`</ph> value.","source":"The `long double` value."},{"pos":[9747,9754],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`long double`</ph> as if by calling <ph id=\"ph4\">`strtold( str.c_str(), _Eptr)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[9758,9956],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `long double` as if by calling `strtold( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[9957,10032],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[10033,10110],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[10111,10227],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[10237,10264],"content":"<bpt id=\"p1\">&lt;a name=\"stoll\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stoll","linkify":"<a name=\"stoll\"></a>  stoll","source":"<a name=\"stoll\"></a>  stoll"},{"pos":[10268,10315],"content":"Converts a character sequence to a <ph id=\"ph1\">`long long`</ph>.","source":"Converts a character sequence to a `long long`."},{"pos":[10512,10522],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[10529,10538]},{"content":"Description","pos":[10539,10550]},{"content":"The character sequence to be converted.","pos":[10600,10639]},{"content":"The index value of the first unconverted character.","pos":[10650,10701]},{"content":"The number base to use.","pos":[10712,10735]},{"pos":[10746,10758],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[10762,10784],"content":"The <ph id=\"ph1\">`long long`</ph> value.","source":"The `long long` value."},{"pos":[10794,10801],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`long long`</ph> as if by calling <ph id=\"ph4\">`strtoll( str.c_str(), _Eptr, Idx)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[10805,11006],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `long long` as if by calling `strtoll( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[11007,11082],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[11083,11160],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[11161,11277],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[11287,11314],"content":"<bpt id=\"p1\">&lt;a name=\"stoul\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stoul","linkify":"<a name=\"stoul\"></a>  stoul","source":"<a name=\"stoul\"></a>  stoul"},{"content":"Converts a character sequence to an unsigned long.","pos":[11318,11368]},{"pos":[11573,11583],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[11590,11599]},{"content":"Description","pos":[11600,11611]},{"content":"The character sequence to be converted.","pos":[11661,11700]},{"content":"The index value of the first unconverted character.","pos":[11711,11762]},{"content":"The number base to use.","pos":[11773,11796]},{"pos":[11807,11819],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The unsigned long-integer value.","pos":[11823,11855]},{"pos":[11865,11872],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`unsigned long`</ph> as if by calling <ph id=\"ph4\">`strtoul( str.c_str(), _Eptr, Idx)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[11876,12081],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `unsigned long` as if by calling `strtoul( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[12082,12157],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[12158,12235],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[12236,12352],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[12362,12391],"content":"<bpt id=\"p1\">&lt;a name=\"stoull\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  stoull","linkify":"<a name=\"stoull\"></a>  stoull","source":"<a name=\"stoull\"></a>  stoull"},{"pos":[12395,12452],"content":"Converts a character sequence to an <ph id=\"ph1\">`unsigned long long`</ph>.","source":"Converts a character sequence to an `unsigned long long`."},{"pos":[12669,12679],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[12686,12695]},{"content":"Description","pos":[12696,12707]},{"content":"The character sequence to be converted.","pos":[12757,12796]},{"content":"The index value of the first unconverted character.","pos":[12807,12858]},{"content":"The number base to use.","pos":[12869,12892]},{"pos":[12903,12915],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[12919,12950],"content":"The <ph id=\"ph1\">`unsigned long long`</ph> value.","source":"The `unsigned long long` value."},{"pos":[12960,12967],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function converts the sequence of elements in <ph id=\"ph1\">` str`</ph> to a value <ph id=\"ph2\">` val`</ph> of type <ph id=\"ph3\">`unsigned long long`</ph> as if by calling <ph id=\"ph4\">`strtoull( str.c_str(), _Eptr, Idx)`</ph>, where <ph id=\"ph5\">`_Eptr`</ph> is an object internal to the function.","pos":[12971,13182],"source":"The function converts the sequence of elements in ` str` to a value ` val` of type `unsigned long long` as if by calling `strtoull( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function."},{"content":"If <ph id=\"ph1\">` str.c_str() == *_Eptr`</ph> it throws an object of type <ph id=\"ph2\">`invalid_argument`</ph>.","pos":[13183,13258],"source":" If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`."},{"content":"If such a call would set <ph id=\"ph1\">`errno`</ph>, it throws an object of type <ph id=\"ph2\">`out_of_range`</ph>.","pos":[13259,13336],"source":" If such a call would set `errno`, it throws an object of type `out_of_range`."},{"content":"Otherwise, if <ph id=\"ph1\">`Idx`</ph> is not a null pointer, the function stores <ph id=\"ph2\">`*_Eptr -  str.c_str()`</ph> in <ph id=\"ph3\">`*Idx`</ph> and returns <ph id=\"ph4\">` val`</ph>.","pos":[13337,13453],"source":" Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`."},{"pos":[13463,13488],"content":"<bpt id=\"p1\">&lt;a name=\"swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  swap","linkify":"<a name=\"swap\"></a>  swap","source":"<a name=\"swap\"></a>  swap"},{"content":"Exchanges the arrays of characters of two strings.","pos":[13492,13542]},{"pos":[13720,13730],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"One string whose elements are to be swapped with those of another string.","pos":[13745,13818]},{"content":"The other string whose elements are to be swapped with the first string.","pos":[13837,13909]},{"pos":[13919,13926],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function executes the specialized member function _ <bpt id=\"p1\">*</bpt>Left<ept id=\"p1\">*</ept>.","pos":[13930,14002],"source":"The template function executes the specialized member function _ *Left*."},{"content":"<bpt id=\"p1\">[</bpt>swap<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__swap)</ept>(<ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Right<ept id=\"p2\">*</ept>) for strings, which guarantees constant complexity.","pos":[14003,14134],"source":"[swap](../standard-library/basic-string-class.md#basic_string__swap)(\\_ *Right*) for strings, which guarantees constant complexity."},{"pos":[14144,14151],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15062,15097],"content":"<bpt id=\"p1\">&lt;a name=\"to_string\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  to_string","linkify":"<a name=\"to_string\"></a>  to_string","source":"<a name=\"to_string\"></a>  to_string"},{"pos":[15101,15132],"content":"Converts a value to a <ph id=\"ph1\">`string`</ph>.","source":"Converts a value to a `string`."},{"pos":[15454,15464],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[15471,15480]},{"content":"Description","pos":[15481,15492]},{"content":"The value to be converted.","pos":[15541,15567]},{"pos":[15578,15590],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[15594,15633],"content":"The <ph id=\"ph1\">`string`</ph> that represents the value.","source":"The `string` that represents the value."},{"pos":[15643,15650],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[15654,15822],"content":"The function converts <ph id=\"ph1\">`Val`</ph> to a sequence of elements stored in an array object <ph id=\"ph2\">`Buf`</ph> internal to the function as if by calling <ph id=\"ph3\">`sprintf(Buf, Fmt, Val)`</ph>, where <ph id=\"ph4\">`Fmt`</ph> is","source":"The function converts `Val` to a sequence of elements stored in an array object `Buf` internal to the function as if by calling `sprintf(Buf, Fmt, Val)`, where `Fmt` is"},{"pos":[15830,15860],"content":"<ph id=\"ph1\">`\"%d\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`int`</ph>","source":"`\"%d\"` if `Val` has type `int`"},{"pos":[15868,15907],"content":"<ph id=\"ph1\">`\"%u\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned int`</ph>","source":"`\"%u\"` if `Val` has type `unsigned int`"},{"pos":[15915,15947],"content":"<ph id=\"ph1\">`\"%ld\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long`</ph>","source":"`\"%ld\"` if `Val` has type `long`"},{"pos":[15955,15996],"content":"<ph id=\"ph1\">`\"%lu\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned long`</ph>","source":"`\"%lu\"` if `Val` has type `unsigned long`"},{"pos":[16004,16042],"content":"<ph id=\"ph1\">`\"%lld\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long long`</ph>","source":"`\"%lld\"` if `Val` has type `long long`"},{"pos":[16050,16097],"content":"<ph id=\"ph1\">`\"%llu\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned long long`</ph>","source":"`\"%llu\"` if `Val` has type `unsigned long long`"},{"pos":[16105,16149],"content":"<ph id=\"ph1\">`\"%f\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`float`</ph> or <ph id=\"ph4\">`double`</ph>","source":"`\"%f\"` if `Val` has type `float` or `double`"},{"pos":[16157,16196],"content":"<ph id=\"ph1\">`\"%Lf\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long double`</ph>","source":"`\"%Lf\"` if `Val` has type `long double`"},{"pos":[16203,16238],"content":"The function returns <ph id=\"ph1\">`string(Buf)`</ph>.","source":"The function returns `string(Buf)`."},{"pos":[16248,16285],"content":"<bpt id=\"p1\">&lt;a name=\"to_wstring\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  to_wstring","linkify":"<a name=\"to_wstring\"></a>  to_wstring","source":"<a name=\"to_wstring\"></a>  to_wstring"},{"content":"Converts a value to a wide string.","pos":[16289,16323]},{"pos":[16663,16673],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[16680,16689]},{"content":"Description","pos":[16690,16701]},{"content":"The value to be converted.","pos":[16750,16776]},{"pos":[16787,16799],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The wide string that represents the value.","pos":[16803,16845]},{"pos":[16855,16862],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[16866,17040],"content":"The function converts <ph id=\"ph1\">`Val`</ph> to a sequence of elements stored in an array object <ph id=\"ph2\">`Buf`</ph> internal to the function as if by calling <ph id=\"ph3\">`swprintf(Buf, Len, Fmt, Val)`</ph>, where <ph id=\"ph4\">`Fmt`</ph> is","source":"The function converts `Val` to a sequence of elements stored in an array object `Buf` internal to the function as if by calling `swprintf(Buf, Len, Fmt, Val)`, where `Fmt` is"},{"pos":[17048,17079],"content":"<ph id=\"ph1\">`L\"%d\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`int`</ph>","source":"`L\"%d\"` if `Val` has type `int`"},{"pos":[17087,17127],"content":"<ph id=\"ph1\">`L\"%u\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned int`</ph>","source":"`L\"%u\"` if `Val` has type `unsigned int`"},{"pos":[17135,17168],"content":"<ph id=\"ph1\">`L\"%ld\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long`</ph>","source":"`L\"%ld\"` if `Val` has type `long`"},{"pos":[17176,17218],"content":"<ph id=\"ph1\">`L\"%lu\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned long`</ph>","source":"`L\"%lu\"` if `Val` has type `unsigned long`"},{"pos":[17226,17265],"content":"<ph id=\"ph1\">`L\"%lld\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long long`</ph>","source":"`L\"%lld\"` if `Val` has type `long long`"},{"pos":[17273,17321],"content":"<ph id=\"ph1\">`L\"%llu\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`unsigned long long`</ph>","source":"`L\"%llu\"` if `Val` has type `unsigned long long`"},{"pos":[17329,17374],"content":"<ph id=\"ph1\">`L\"%f\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`float`</ph> or <ph id=\"ph4\">`double`</ph>","source":"`L\"%f\"` if `Val` has type `float` or `double`"},{"pos":[17382,17422],"content":"<ph id=\"ph1\">`L\"%Lf\"`</ph> if <ph id=\"ph2\">`Val`</ph> has type <ph id=\"ph3\">`long double`</ph>","source":"`L\"%Lf\"` if `Val` has type `long double`"},{"pos":[17429,17465],"content":"The function returns <ph id=\"ph1\">`wstring(Buf)`</ph>.","source":"The function returns `wstring(Buf)`."},{"pos":[17474,17482],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[17486,17528],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>string&gt;<ept id=\"p1\">](../standard-library/string.md)</ept>","source":"[\\<string>](../standard-library/string.md)"}],"content":"---\ntitle: \"&lt;string&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 1a4ffd11-dce5-4cc6-a043-b95de034c7c4\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\n---\n# &lt;string&gt; functions\n||||  \n|-|-|-|  \n|[getline](#getline)|[stod](#stod)|[stof](#stof)|  \n|[stoi](#stoi)|[stol](#stol)|[stold](#stold)|  \n|[stoll](#stoll)|[stoul](#stoul)|[stoull](#stoull)|  \n|[swap](#swap)|[to_string](#to_string)|[to_wstring](#to_wstring)|  \n  \n##  <a name=\"getline\"></a>  getline  \n Extract strings from the input stream line-by-line.  \n  \n```  \n// (1) delimiter as parameter  \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_istream<CharType, Traits>& getline(\n    basic_istream<CharType, Traits>& is,  \n    basic_string<CharType, Traits, Allocator>& str, \n    CharType delim);\n\n \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_istream<CharType, Traits>& getline(\n    basic_istream<CharType, Traits>&& is,  \n    basic_string<CharType, Traits, Allocator>& str, \n    const CharType delim);\n\n \n// (2) default delimiter used  \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_istream<CharType, Traits>& getline(\n    basic_istream<CharType, Traits>& is,  \n    basic_string<CharType, Traits, Allocator>& str);\n\n \ntemplate <class Allocator, class Traits, class Allocator>  \nbasic_istream<Allocator, Traits>& getline(\n    basic_istream<Allocator, Traits>&& is,  \n    basic_string<Allocator, Traits, Allocator>& str);\n```  \n  \n### Parameters  \n `is`  \n The input stream from which a string is to be extracted.  \n  \n `str`  \n The string into which are read the characters from the input stream.  \n  \n `delim`  \n The line delimiter.  \n  \n### Return Value  \n The input stream `is`.  \n  \n### Remarks  \n The pair of function signatures marked `(1)` extract characters from `is` until `delim` is found, storing them in `str`.  \n  \n The pair of function signatures marked `(2)` use newline as the default line delimiter and behave as **getline**( `is`, `str`, `is`. `widen`(' `\\n`')).  \n  \n The second function of each pair is an analog to the first one to support [rvalue references](../cpp/lvalues-and-rvalues-visual-cpp.md).  \n  \n Extraction stops when one of the following occurs:  \n  \n-   At end-of-file, in which case the internal state flag of `is` is set to `ios_base::eofbit`.  \n  \n-   After the function extracts an element that compares equal to **delim**, in which case the element is neither put back nor appended to the controlled sequence.  \n  \n-   After the function extracts `str.`[max_size](../standard-library/basic-string-class.md#basic_string__max_size) elements, in which case the internal state flag of `is` is set to `ios_base::failbit`.  \n  \n-   Some other error other than those previously listed, in which case the internal state flag of `is` is set to `ios_base::badbit`  \n  \n For information about internal state flags, see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate).  \n  \n If the function extracts no elements, the internal state flag of `is` is set to `ios_base::failbit`. In any case, `getline` returns `is`.  \n  \n If an exception is thrown, `is` and `str` are left in a valid state.  \n  \n### Example  \n  The following code demonstrates `getline()` in two modes: first with the default delimiter (newline) and second with a whitespace as delimiter. The end-of-file character (CTRL-Z on the keyboard) is used to control termination of the while loops. This sets the internal state flag of `cin` to `eofbit`, which must be cleared with [basic_ios::clear()](../standard-library/basic-ios-class.md#basic_ios__clear) before the second while loop will work properly.  \n  \n```cpp  \n// compile with: /EHsc /W4  \n#include <string>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    string str;  \n    vector<string> v1;  \n    cout << \"Enter a sentence, press ENTER between sentences. (Ctrl-Z to stop): \" << endl;  \n    // Loop until end-of-file (Ctrl-Z) is input, store each sentence in a vector.  \n    // Default delimiter is the newline character.  \n    while (getline(cin, str)) {  \n        v1.push_back(str);  \n    }  \n  \n    cout << \"The following input was stored with newline delimiter:\" << endl;  \n    for (const auto& p : v1) {  \n        cout << p << endl;  \n    }  \n  \n    cin.clear();  \n  \n    vector<string> v2;  \n    // Now try it with a whitespace delimiter  \n    while (getline(cin, str, ' ')) {  \n        v2.push_back(str);  \n    }  \n  \n    cout << \"The following input was stored with whitespace as delimiter:\" << endl;  \n    for (const auto& p : v2) {  \n        cout << p << endl;  \n    }  \n}  \n  \n```  \n  \n##  <a name=\"stod\"></a>  stod  \n Converts a character sequence to a `double`.  \n  \n```  \ndouble stod(\n    const string& str,   \n    size_t* Idx = 0);\n\ndouble stod(\n    const wstring& str,   \n    size_t* Idx = 0  \n;  \n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n  \n### Return Value  \n The `double` value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `double` as if by calling `strtod( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stof\"></a>  stof  \n Converts a character sequence to a float.  \n  \n```  \nfloat stof(\n    const string& str,   \n    size_t* Idx = 0);\n\nfloat stof(\n    const wstring& str,   \n    size_t* Idx = 0);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n  \n### Return Value  \n The float value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `float` as if by calling `strtof( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stoi\"></a>  stoi  \n Converts a character sequence to an integer.  \n  \n```  \nint stoi(\n    const string& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n\nint stoi(\n    const wstring& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n```  \n  \n### Return Value  \n The integer value.  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|Contains the index of the first unconverted character on return.|  \n|`Idx`|The number base to use.|  \n  \n### Remarks  \n The function `stoi` converts the sequence of characters in ` str` to a value of type `int` and returns the value. For example, when passed a character sequence \"10\", the value returned by `stoi` is the integer 10.  \n  \n `stoi` behaves similarly to the function `strtol` for single-byte characters when it is called in the manner `strtol( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function; or `wcstol` for wide characters, when it is called in similar manner, `wcstol(Str.c_str(), _Eptr, Idx)`. For more information, see [strtol, wcstol, _strtol_l, _wcstol_l](../c-runtime-library/reference/strtol-wcstol-strtol-l-wcstol-l.md).  \n  \n If ` str.c_str() == *_Eptr,``stoi` throws an object of type `invalid_argument`. If such a call would set `errno`, or if the returned value cannot be represented as an object of type `int`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr - _ str.c_str()` in `*Idx`.  \n  \n##  <a name=\"stol\"></a>  stol  \n Converts a character sequence to a `long`.  \n  \n```  \nlong stol(\n    const string& str,  \n    size_t* Idx = 0,  \n    int Idx = 10);\n\nlong stol(\n    const wstring& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n|`Idx`|The number base to use.|  \n  \n### Return Value  \n The long-integer value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `long` as if by calling `strtol( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stold\"></a>  stold  \n Converts a character sequence to a `long double`.  \n  \n```  \ndouble stold(\n    const string& str,   \n    size_t* Idx = 0);\n\ndouble stold(\n    const wstring& str,   \n    size_t* Idx = 0);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n  \n### Return Value  \n The `long double` value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `long double` as if by calling `strtold( str.c_str(), _Eptr)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stoll\"></a>  stoll  \n Converts a character sequence to a `long long`.  \n  \n```  \nlong long stoll(\n    const string& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n\nlong long stoll(\n    const wstring& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n|`Idx`|The number base to use.|  \n  \n### Return Value  \n The `long long` value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `long long` as if by calling `strtoll( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stoul\"></a>  stoul  \n Converts a character sequence to an unsigned long.  \n  \n```  \nunsigned long stoul(\n    const string& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n\nunsigned long stoul(\n    const wstring& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n|`Idx`|The number base to use.|  \n  \n### Return Value  \n The unsigned long-integer value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `unsigned long` as if by calling `strtoul( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"stoull\"></a>  stoull  \n Converts a character sequence to an `unsigned long long`.  \n  \n```  \nunsigned long long stoull(\n    const string& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n\nunsigned long long stoull(\n    const wstring& str,   \n    size_t* Idx = 0,  \n    int Idx = 10);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` str`|The character sequence to be converted.|  \n|`Idx`|The index value of the first unconverted character.|  \n|`Idx`|The number base to use.|  \n  \n### Return Value  \n The `unsigned long long` value.  \n  \n### Remarks  \n The function converts the sequence of elements in ` str` to a value ` val` of type `unsigned long long` as if by calling `strtoull( str.c_str(), _Eptr, Idx)`, where `_Eptr` is an object internal to the function. If ` str.c_str() == *_Eptr` it throws an object of type `invalid_argument`. If such a call would set `errno`, it throws an object of type `out_of_range`. Otherwise, if `Idx` is not a null pointer, the function stores `*_Eptr -  str.c_str()` in `*Idx` and returns ` val`.  \n  \n##  <a name=\"swap\"></a>  swap  \n Exchanges the arrays of characters of two strings.  \n  \n```  \ntemplate <class Traits, class Allocator>  \nvoid swap(basic_string<CharType, Traits, Allocator>& left, basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n One string whose elements are to be swapped with those of another string.  \n  \n ` right`  \n The other string whose elements are to be swapped with the first string.  \n  \n### Remarks  \n The template function executes the specialized member function _ *Left*. [swap](../standard-library/basic-string-class.md#basic_string__swap)(\\_ *Right*) for strings, which guarantees constant complexity.  \n  \n### Example  \n  \n```cpp  \n// string_swap.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // Declaring an object of type basic_string<char>  \n   string s1 ( \"Tweedledee\" );  \n   string s2 ( \"Tweedledum\" );  \n   cout << \"Before swapping string s1 and s2:\" << endl;  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   swap ( s1 , s2 );  \n   cout << \"\\nAfter swapping string s1 and s2:\" << endl;  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nBefore swapping string s1 and s2:  \nThe basic_string s1 = Tweedledee.  \nThe basic_string s2 = Tweedledum.  \n  \nAfter swapping string s1 and s2:  \nThe basic_string s1 = Tweedledum.  \nThe basic_string s2 = Tweedledee.  \n```  \n  \n##  <a name=\"to_string\"></a>  to_string  \n Converts a value to a `string`.  \n  \n```  \nstring to_string(int Val);\nstring to_string(unsigned int Val);\nstring to_string(long Val);\nstring to_string(unsigned long Val);\nstring to_string(long long Val);\nstring to_string(unsigned long long Val);\nstring to_string(float Val);\nstring to_string(double Val);\nstring to_string(long double Val);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`Val`|The value to be converted.|  \n  \n### Return Value  \n The `string` that represents the value.  \n  \n### Remarks  \n The function converts `Val` to a sequence of elements stored in an array object `Buf` internal to the function as if by calling `sprintf(Buf, Fmt, Val)`, where `Fmt` is  \n  \n- `\"%d\"` if `Val` has type `int`  \n  \n- `\"%u\"` if `Val` has type `unsigned int`  \n  \n- `\"%ld\"` if `Val` has type `long`  \n  \n- `\"%lu\"` if `Val` has type `unsigned long`  \n  \n- `\"%lld\"` if `Val` has type `long long`  \n  \n- `\"%llu\"` if `Val` has type `unsigned long long`  \n  \n- `\"%f\"` if `Val` has type `float` or `double`  \n  \n- `\"%Lf\"` if `Val` has type `long double`  \n  \n The function returns `string(Buf)`.  \n  \n##  <a name=\"to_wstring\"></a>  to_wstring  \n Converts a value to a wide string.  \n  \n```  \nwstring to_wstring(int Val);\nwstring to_wstring(unsigned int Val);\nwstring to_wstring(long Val);\nwstring to_wstring(unsigned long Val);\nwstring to_wstring(long long Val);\nwstring to_wstring(unsigned long long Val);\nwstring to_wstring(float Val);\nwstring to_wstring(double Val);\nwstring to_wstring(long double Val);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`Val`|The value to be converted.|  \n  \n### Return Value  \n The wide string that represents the value.  \n  \n### Remarks  \n The function converts `Val` to a sequence of elements stored in an array object `Buf` internal to the function as if by calling `swprintf(Buf, Len, Fmt, Val)`, where `Fmt` is  \n  \n- `L\"%d\"` if `Val` has type `int`  \n  \n- `L\"%u\"` if `Val` has type `unsigned int`  \n  \n- `L\"%ld\"` if `Val` has type `long`  \n  \n- `L\"%lu\"` if `Val` has type `unsigned long`  \n  \n- `L\"%lld\"` if `Val` has type `long long`  \n  \n- `L\"%llu\"` if `Val` has type `unsigned long long`  \n  \n- `L\"%f\"` if `Val` has type `float` or `double`  \n  \n- `L\"%Lf\"` if `Val` has type `long double`  \n  \n The function returns `wstring(Buf)`.  \n  \n## See Also  \n [\\<string>](../standard-library/string.md)\n\n"}