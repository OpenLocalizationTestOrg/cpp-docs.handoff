{"nodes":[{"pos":[12,49],"content":"Evaluation of Tokens | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Evaluation of Tokens | Microsoft Docs","pos":[0,37]}]},{"content":"Evaluation of Tokens","pos":[584,604]},{"content":"When the compiler interprets tokens, it includes as many characters as possible in a single token before moving on to the next token.","pos":[605,738]},{"content":"Because of this behavior, the compiler may not interpret tokens as you intended if they are not properly separated by white space.","pos":[739,869]},{"content":"Consider the following expression:","pos":[870,904]},{"content":"In this example, the compiler first makes the longest possible operator (<ph id=\"ph1\">`++`</ph>) from the three plus signs, then processes the remaining plus sign as an addition operator (<ph id=\"ph2\">`+`</ph>).","pos":[934,1109],"source":"In this example, the compiler first makes the longest possible operator (`++`) from the three plus signs, then processes the remaining plus sign as an addition operator (`+`)."},{"content":"Thus, the expression is interpreted as <ph id=\"ph1\">`(i++) + (j)`</ph>, not <ph id=\"ph2\">`(i) + (++j)`</ph>.","pos":[1110,1182],"source":" Thus, the expression is interpreted as `(i++) + (j)`, not `(i) + (++j)`."},{"content":"In this and similar cases, use white space and parentheses to avoid ambiguity and ensure proper expression evaluation.","pos":[1183,1301]},{"content":"Microsoft Specific","pos":[1310,1328]},{"content":"The C compiler treats a CTRL+Z character as an end-of-file indicator.","pos":[1337,1406]},{"content":"It ignores any text after CTRL+Z.","pos":[1407,1440]},{"content":"END Microsoft Specific","pos":[1449,1471]},{"content":"See Also","pos":[1482,1490]},{"content":"C Tokens","pos":[1495,1503]}],"content":"---\ntitle: \"Evaluation of Tokens | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"tokens, evaluating\"\nms.assetid: 28870b62-dff6-4644-8b75-d58f340b48d2\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Evaluation of Tokens\nWhen the compiler interprets tokens, it includes as many characters as possible in a single token before moving on to the next token. Because of this behavior, the compiler may not interpret tokens as you intended if they are not properly separated by white space. Consider the following expression:  \n  \n```  \ni+++j  \n```  \n  \n In this example, the compiler first makes the longest possible operator (`++`) from the three plus signs, then processes the remaining plus sign as an addition operator (`+`). Thus, the expression is interpreted as `(i++) + (j)`, not `(i) + (++j)`. In this and similar cases, use white space and parentheses to avoid ambiguity and ensure proper expression evaluation.  \n  \n **Microsoft Specific**  \n  \n The C compiler treats a CTRL+Z character as an end-of-file indicator. It ignores any text after CTRL+Z.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [C Tokens](../c-language/c-tokens.md)"}