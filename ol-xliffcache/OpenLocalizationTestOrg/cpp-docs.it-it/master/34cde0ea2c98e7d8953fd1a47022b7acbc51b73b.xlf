<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">34cde0ea2c98e7d8953fd1a47022b7acbc51b73b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\how-to-define-and-consume-classes-and-structs-cpp-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7de85ec2e598a00805c924cf6fb34126c50507be</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fe19b87de19d9c1e0d87e92489c16180d63d5185</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>How to: Define and Consume Classes and Structs (C++-CLI) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>How to: Define and Consume Classes and Structs (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This article shows how to define and consume user-defined reference types and value types in <ph id="ph1">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Contents</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Object instantiation</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Implicitly abstract classes</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Type visibility</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Member visibility</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Public and private native classes</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Static constructors</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Semantics of the this pointer</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Hide-by-signature functions</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Copy constructors</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Destructors and finalizers</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Object instantiation</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Reference (ref) types and value types can only be instantiated on the managed heap, not on the stack or on the native heap.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Implicitly abstract classes</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>implicitly abstract class<ept id="p1">*</ept> can't be instantiated.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A class is implicitly abstract if the base type of the class is an interface and the class does not implement all of the interface's member functions.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you are unable to construct objects from a class that's derived from an interface, the reason might be that the class is implicitly abstract.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For more information about abstract classes, see <bpt id="p1">[</bpt>abstract<ept id="p1">](../windows/abstract-cpp-component-extensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following code example demonstrates that the <ph id="ph1">`MyClass`</ph> class cannot be instantiated because function <ph id="ph2">`MyClass::func2`</ph> is not implemented.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>To enable the example to compile, uncomment <ph id="ph1">`MyClass::func2`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Type visibility</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can control the visibility of common language runtime (CLR) types so that, if an assembly is referenced, types in the assembly can be visible or not visible outside the assembly.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>indicates that a type is visible to any source file that contains a <ph id="ph1">`#using`</ph> directive for the assembly that contains the type.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>indicates that a type is not visible to source files that contain a <ph id="ph1">`#using`</ph> directive for the assembly that contains the type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, private types are visible within the same assembly.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By default, the visibility for a class is <ph id="ph1">`private`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>By default prior to Visual C++ 2005, native types had public accessibility outside the assembly.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Enable <bpt id="p1">[</bpt>Compiler Warning (level 1) C4692<ept id="p1">](../error-messages/compiler-warnings/compiler-warning-level-1-c4692.md)</ept> to help you see where private native types are used incorrectly.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>make_public<ept id="p1">](../preprocessor/make-public.md)</ept> pragma to give public accessibility to a native type in a source code file that you can't modify.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>#using Directive<ept id="p1">](../preprocessor/hash-using-directive-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following sample shows how to declare types and specify their accessibility, and then access those types inside the assembly.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Of course, if an assembly that has private types is referenced by using <ph id="ph1">`#using`</ph>, only public types in the assembly are visible.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Now, let's rewrite the previous sample so that it is built as a DLL.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The next sample shows how to access types outside the assembly.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In this sample, the client consumes the component that's built in the previous sample.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Member visibility</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can make access to a member of a public class from within the same assembly different than access to it from outside the assembly by using pairs of the access specifiers <ph id="ph1">`public`</ph>, <ph id="ph2">`protected`</ph>, and</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This table summarizes the effect of the various access specifiers:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Specifier</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Effect</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>public</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Member is accessible inside and outside the assembly.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>public<ept id="p1">](../cpp/public-cpp.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>private</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Member is not accessible, neither inside nor outside the assembly.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>private<ept id="p1">](../cpp/private-cpp.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>protected</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Member is accessible inside and outside the assembly, but only to derived types.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>protected<ept id="p1">](../cpp/protected-cpp.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>internal</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Member is public inside the assembly but private outside the assembly.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>is a context-sensitive keyword.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Context-Sensitive Keywords<ept id="p1">](../windows/context-sensitive-keywords-cpp-component-extensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>public protected -or- protected public</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Member is public inside the assembly but protected outside the assembly.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>private protected -or- protected private</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Member is protected inside the assembly but private outside the assembly.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The following sample shows a public type that has members that are declared with the different accessibilities, and then shows the accessing of those members from inside the assembly.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Now let's build the previous sample as a DLL.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following sample consumes the component that's created in the previous sample, and thereby shows how to access the members from outside the assembly.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Public and private native classes</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A native type can be referenced from a managed type.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, a function in a managed type can take a parameter whose type is a native struct.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the managed type and function are public in an assembly, then the native type must also be public.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Next, create the source code file that consumes the native type:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Now, compile a client:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Static constructors</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A CLR type—for example, a class or struct—can have a static constructor that can be used to initialize static data members.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A static constructor is called at most once, and is called before any static member of the type is accessed the first time.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>An instance constructor always runs after a static constructor.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The compiler cannot inline a call to a constructor if the class has a static constructor.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The compiler cannot inline a call to any member function if the class is a value type, has a static constructor, and does not have an instance constructor.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The CLR may inline the call, but the compiler cannot.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Define a static constructor as a private member function, because it is meant to be called only by the CLR.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information about static constructors, see <bpt id="p1">[</bpt>How to: Define an Interface Static Constructor (C++/CLI)<ept id="p1">](../dotnet/how-to-define-an-interface-static-constructor-cpp-cli.md)</ept> .</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Semantics of the this pointer</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When you are using Visual C++ to define types, the <ph id="ph1">`this`</ph> pointer in a reference type is of type "handle".</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`this`</ph> pointer in a value type is of type "interior pointer".</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>These different semantics of the <ph id="ph1">`this`</ph> pointer can cause unexpected behavior when a default indexer is called.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The next example shows the correct way to access a default indexer in both a ref type and a value type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more information, see</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Handle to Object Operator (^)</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>interior_ptr (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Hide-by-signature functions</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In standard C++, a function in a base class is hidden by a function that has the same name in a derived class, even if the derived-class function does not have the same number or kind of parameters.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This is referred to as <bpt id="p1">*</bpt>hide-by-name<ept id="p1">*</ept> semantics.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In a reference type, a function in a base class can only be hidden by a function in a derived class if both the name and the parameter list are the same.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is known as <bpt id="p1">*</bpt>hide-by-signature<ept id="p1">*</ept> semantics.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A class is considered a hide-by-signature class when all of its functions are marked in the metadata as <ph id="ph1">`hidebysig`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>By default, all classes that are created under <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> have <ph id="ph1">`hidebysig`</ph> functions.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>When a class has <ph id="ph1">`hidebysig`</ph> functions, the compiler doesn't hide functions by name in any direct base classes, but if the compiler encounters a hide-by-name class in an inheritance chain, it continues that hide-by-name behavior.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Under hide-by-signature semantics, when a function is called on an object, the compiler identifies the most derived class that contains a function that could satisfy the function call.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If there is only one function in the class that could satisfy the call, the compiler calls that function.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If there is more than one function in the class that could satisfy the call, the compiler uses overload resolution rules to determine which function to call.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information about overload rules, see <bpt id="p1">[</bpt>Function Overloading<ept id="p1">](../cpp/function-overloading.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For a given function call, a function in a base class might have a signature that makes it a slightly better match than a function in a derived class.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, if the function was explicitly called on an object of the derived class, the function in the derived class is called.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Because the return value is not considered part of a function's signature, a base-class function is hidden if it has the same name and takes the same number and kind of arguments as a derived-class function, even if it differs in the type of the return value.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following sample shows that a function in a base class is not hidden by a function in a derived class.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The next sample shows that the Visual C++ compiler calls a function in the most derived class—even if a conversion is required to match one or more of the parameters—and not call a function in a base class that is a better match for the function call.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following sample shows that it's possible to hide a function even if the base class has the same signature as the derived class.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Copy constructors</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The C++ standard says that a copy constructor is called when an object is moved, such that an object is created and destroyed at the same address.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, when <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> is used to compile and a function that's compiled to MSIL calls a native function where a native class—or more than one—is passed by value and where the native class has a copy constructor and/or destructor, no copy constructor is called and the object is destroyed at a different address than where it was created.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This could cause problems if the class has a pointer into itself, or if the code is tracking objects by address.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/clr (Common Language Runtime Compilation)<ept id="p1">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following sample demonstrates when a copy constructor is not generated.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Destructors and finalizers</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Destructors in a reference type perform a deterministic clean-up of resources.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Finalizers clean up unmanaged resources and can be called deterministically by the destructor or nondeterministically by the garbage collector.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For information about destructors in standard C++, see <bpt id="p1">[</bpt>Destructors<ept id="p1">](../cpp/destructors-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The behavior of destructors in a managed Visual C++ class differs from Managed Extensions for C++.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For more information about this change, see <bpt id="p1">[</bpt>Changes in Destructor Semantics<ept id="p1">](../dotnet/changes-in-destructor-semantics.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The CLR garbage collector deletes unused managed objects and releases their memory when they are no longer required.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>However, a type may use resources that the garbage collector does not know how to release.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>These resources are known as unmanaged resources (native file handles, for example).</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>We recommend that you release all unmanaged resources in the finalizer.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Because managed resources are released nondeterministically by the garbage collector, it's not safe to refer to managed resources in a finalizer because it's possible that the garbage collector has already cleaned up that managed resource.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A Visual C++ finalizer is not the same as the &lt;xref:System.Object.Finalize%2A&gt; method.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>(CLR documentation uses finalizer and the &lt;xref:System.Object.Finalize%2A&gt; method synonymously).</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object.Finalize%2A&gt; method is called by the garbage collector, which invokes each finalizer in a class inheritance chain.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Unlike Visual C++ destructors, a derived-class finalizer call does not cause the compiler to invoke the finalizer in all base classes.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Because the Visual C++ compiler supports deterministic release of resources, don't try to implement the &lt;xref:System.IDisposable.Dispose%2A&gt; or &lt;xref:System.Object.Finalize%2A&gt; methods.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>However, if you're familiar with these methods, here's how a Visual C++ finalizer and a destructor that calls the finalizer map to the &lt;xref:System.IDisposable.Dispose%2A&gt; pattern:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A managed type may also use managed resources that you would prefer to release deterministically, and not leave to the garbage collector to release nondeterministically at some point after the object is no longer required.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The deterministic release of resources can significantly improve performance.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The Visual C++ compiler enables the definition of a destructor to deterministically clean up objects.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Use the destructor to release all resources that you want to deterministically release.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>If a finalizer is present, call it from the destructor, to avoid code duplication.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If the code that consumes your type does not call the destructor, the garbage collector eventually releases all managed resources.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The presence of a destructor does not imply the presence of a finalizer.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>However, the presence of a finalizer implies that you must define a destructor and call the finalizer from that destructor.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This provides for the deterministic release of unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Calling the destructor suppresses—by using &lt;xref:System.GC.SuppressFinalize%2A&gt;—finalization of the object.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>If the destructor is not called, your type's finalizer will eventually be called by the garbage collector.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Deterministically cleaning up your object's resources by calling the destructor can improve performance compared with letting the CLR nondeterministically finalize the object.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Code that's written in Visual C++ and compiled by using <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> runs a type's destructor if:</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>An object that's created by using stack semantics goes out of scope.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>C++ Stack Semantics for Reference Types<ept id="p1">](../dotnet/cpp-stack-semantics-for-reference-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>An exception is thrown during the object's construction.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The object is a member in an object whose destructor is running.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>You call the <bpt id="p1">[</bpt>delete<ept id="p1">](../cpp/delete-operator-cpp.md)</ept> operator on a handle (<bpt id="p2">[</bpt>Handle to Object Operator (^)<ept id="p2">](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>You explicitly call the destructor.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If your type is being consumed by a client that's written in another language, the destructor is called as follows:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>On a call to &lt;xref:System.IDisposable.Dispose%2A&gt;.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>On a call to <ph id="ph1">`Dispose(void)`</ph> on the type.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If the type goes out of scope in a C# <ph id="ph1">`using`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If you create an object of a reference type on the managed heap (not using stack semantics for reference types), use <bpt id="p1">[</bpt>try-finally<ept id="p1">](../cpp/try-finally-statement.md)</ept> syntax to ensure that an exception doesn't prevent the destructor from running.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If your type has a destructor, the compiler generates a <ph id="ph1">`Dispose`</ph> method that implements &lt;xref:System.IDisposable&gt;.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If a type that's written in Visual C++ and has a destructor that's consumed from another language, calling <ph id="ph1">`IDisposable::Dispose`</ph> on that type causes the type's destructor to be called.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When the type is consumed from a Visual C++ client, you can't directly call <ph id="ph1">`Dispose`</ph>; instead, call the destructor by using the <ph id="ph2">`delete`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>If your type has a finalizer, the compiler generates a <ph id="ph1">`Finalize(void)`</ph> method that overrides &lt;xref:System.Object.Finalize%2A&gt;.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If a type has either a finalizer or a destructor, the compiler generates a <ph id="ph1">`Dispose(bool)`</ph> method, according to the design pattern.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>(For information, see <bpt id="p1">[</bpt>Dispose Pattern<ept id="p1">](http://msdn.microsoft.com/Library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)</ept>).</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>You cannot explicitly author or call <ph id="ph1">`Dispose(bool)`</ph> in Visual C++.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If a type has a base class that conforms to the design pattern, the destructors for all base classes are called when the destructor for the derived class is called.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>(If your type is written in Visual C++, the compiler ensures that your types implement this pattern.) In other words, the destructor of a reference class chains to its bases and members as specified by the C++ standard—first the class’s destructor is run, then the destructors for its members in the reverse of the order in which they were constructed, and finally the destructors for its base classes in the reverse of the order in which they were constructed.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Destructors and finalizers are not allowed inside value types or interfaces.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A finalizer can only be defined or declared in a reference type.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Like a constructor and destructor, a finalizer has no return type.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>After an object's finalizer runs, finalizers in any base classes are also called, beginning with the least derived type.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Finalizers for data members are not automatically chained to by a class’s finalizer.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>If a finalizer deletes a native pointer in a managed type, you must ensure that references to or through the native pointer are not prematurely collected; call the destructor on the managed type instead of using &lt;xref:System.GC.KeepAlive%2A&gt;.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>At compile time, you can detect whether a type has a finalizer or a destructor.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiler Support for Type Traits<ept id="p1">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The next sample shows two types, one that has unmanaged resources and one that has managed resources that are deterministically released.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Classes and Structs</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Classes and Structs</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>