{"nodes":[{"pos":[12,49],"content":"Porting Guide: Spy++ | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Porting Guide: Spy++ | Microsoft Docs","pos":[0,37]}]},{"content":"Porting Guide: Spy++","pos":[530,550]},{"content":"This porting case study is designed to give you an idea of what a typical porting project is like, the types of problems you might encounter, and some general tips and tricks for addressing porting problems.","pos":[551,758]},{"content":"It's not meant to be a definitive guide to porting, since the experience of porting a project depends very much on the specifics of the code.","pos":[759,900]},{"content":"Spy++","pos":[909,914]},{"content":"Spy++ is a widely used GUI diagnostic tool for the Windows desktop that provides all sorts of information about user interface elements on the Windows desktop.","pos":[918,1077]},{"content":"It shows the complete hierarchy of windows and provides access to metadata about each window and control.","pos":[1078,1183]},{"content":"This useful application has shipped with Visual Studio for many years.","pos":[1184,1254]},{"content":"We found an old version of it that was last compiled in Visual C++ 6.0 and ported it to <ph id=\"ph1\">[!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)]</ph>.","pos":[1255,1396],"source":" We found an old version of it that was last compiled in Visual C++ 6.0 and ported it to [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)]."},{"content":"We considered this case to be typical for porting Windows desktop applications that use MFC and the Win32 API, especially for old projects that have not been updated with each release of Visual C++ since Visual C++ 6.0.","pos":[1403,1622]},{"content":"Step 1.","pos":[1668,1675]},{"content":"Converting the project file.","pos":[1676,1704]},{"content":"The project file, two old .dsw files from Visual C++ 6.0, converted easily with no issues that require further attention.","pos":[1708,1829]},{"content":"One project is the Spy++ application.","pos":[1830,1867]},{"content":"The other is SpyHk, written in C, a supporting DLL.","pos":[1868,1919]},{"content":"More complex projects might not upgrade as easily, as discussed <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](../porting/visual-cpp-porting-and-upgrading-guide.md)</ept>.","pos":[1920,2045],"source":" More complex projects might not upgrade as easily, as discussed [here](../porting/visual-cpp-porting-and-upgrading-guide.md)."},{"content":"After upgrading the two projects, our solution looked like this:","pos":[2052,2116]},{"content":"The Spy&amp;#43;&amp;#43; Solution","pos":[2125,2151],"source":"The Spy&#43;&#43; Solution"},{"content":"We have two projects, one with a large number of C++ files, and another a DLL that's written in C.","pos":[2211,2309]},{"content":"Step 2.","pos":[2355,2362]},{"content":"Header file problems","pos":[2363,2383]},{"content":"Upon building a newly converted project, one of the first things you'll often find is that header files that your project uses are not found.","pos":[2387,2528]},{"content":"One of the files that couldn't be found in Spy++ was verstamp.h.","pos":[2535,2599]},{"content":"From an Internet search, we determined that this came from a DAO SDK, an obsolete data technology.","pos":[2600,2698]},{"content":"We wanted to find out what symbols were being used from that header file, to see if that file was really needed or if those symbols were defined elsewhere, so we commented out the header file declaration and recompiled.","pos":[2699,2918]},{"content":"It turns out there is just one symbol that is needed, VER_FILEFLAGSMASK.","pos":[2919,2991]},{"content":"The easiest way to find a symbol in the available include files is to use Find in Files (Ctrl+Shift+F) and specify <bpt id=\"p1\">**</bpt>Visual C++ Include Directories<ept id=\"p1\">**</ept>.","pos":[3152,3302],"source":"The easiest way to find a symbol in the available include files is to use Find in Files (Ctrl+Shift+F) and specify **Visual C++ Include Directories**."},{"content":"We found it in ntverp.h.","pos":[3303,3327]},{"content":"We replaced the verstamp.h include with ntverp.h and this error disappeared.","pos":[3328,3404]},{"content":"Step 3.","pos":[3452,3459]},{"content":"Linker OutputFile setting","pos":[3460,3485]},{"content":"Older projects sometimes have files placed in unconventional locations that can cause problems after upgrading.","pos":[3489,3600]},{"content":"In this case, we have to add $(SolutionDir) to the Include path in the project properties to ensure that Visual Studio can find some header files that are placed there, rather than in one of the project folders.","pos":[3601,3812]},{"content":"MSBuild complains that the Link.OutputFile property does not match the TargetPath and TargetName values, issuing MSB8012.","pos":[3819,3940]},{"content":"<bpt id=\"p1\">**</bpt>Link.OutputFile<ept id=\"p1\">**</ept> is the build output (EXE, DLL, for example), and it is normally constructed from $(TargetDir)$(TargetName)$(TargetExt), giving the path, filename and extension.","pos":[4618,4798],"source":"**Link.OutputFile** is the build output (EXE, DLL, for example), and it is normally constructed from $(TargetDir)$(TargetName)$(TargetExt), giving the path, filename and extension."},{"content":"This is a common error when migrating projects from the old Visual C++ build tool (vcbuild.exe) to the new build tool (MSBuild.exe).","pos":[4799,4931]},{"content":"Since the build tool change occurred in Visual Studio 2010, you might encounter this issue whenever you migrate a pre-2010 project to a 2010 or later version.","pos":[4932,5090]},{"content":"The basic problem is that the project migration wizard doesn’t update the <bpt id=\"p1\">**</bpt>Link.OutputFile<ept id=\"p1\">**</ept> value since it’s not always possible to determine what its value should be based on the other project settings.","pos":[5091,5296],"source":" The basic problem is that the project migration wizard doesn’t update the **Link.OutputFile** value since it’s not always possible to determine what its value should be based on the other project settings."},{"content":"Therefore, you usually have to set it manually.","pos":[5297,5344]},{"content":"For more details, see this <bpt id=\"p1\">[</bpt>post<ept id=\"p1\">](http://blogs.msdn.com/b/vcblog/archive/2010/03/02/visual-studio-2010-c-project-upgrade-guide.aspx)</ept> on the Visual C++ blog.","pos":[5345,5501],"source":" For more details, see this [post](http://blogs.msdn.com/b/vcblog/archive/2010/03/02/visual-studio-2010-c-project-upgrade-guide.aspx) on the Visual C++ blog."},{"content":"In this case, the <bpt id=\"p1\">**</bpt>Link.OutputFile<ept id=\"p1\">**</ept> property in the converted project was set to .\\Debug\\Spyxx.exe and .\\Release\\Spyxx.exe for the Spy++ project, depending on the configuration.","pos":[5508,5687],"source":"In this case, the **Link.OutputFile** property in the converted project was set to .\\Debug\\Spyxx.exe and .\\Release\\Spyxx.exe for the Spy++ project, depending on the configuration."},{"content":"The best bet is to simply replace these hardcoded values with $(TargetDir)$(TargetName)$(TargetExt) for All Configurations.","pos":[5688,5811]},{"content":"If that doesn’t work, you can customize from there, or change the properties in the General section where those values are set (the properties are <bpt id=\"p1\">**</bpt>Output Directory<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Target Name<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Target Extension<ept id=\"p3\">**</ept>.","pos":[5812,6023],"source":" If that doesn’t work, you can customize from there, or change the properties in the General section where those values are set (the properties are **Output Directory**, **Target Name**, and **Target Extension**."},{"content":"Remember that if the property you are viewing uses macros, you can choose <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> in the dropdown list to bring up a dialog box that shows the final string with the macro substitutions made.","pos":[6024,6215],"source":" Remember that if the property you are viewing uses macros, you can choose **Edit** in the dropdown list to bring up a dialog box that shows the final string with the macro substitutions made."},{"content":"You can view all available macros and their current values by choosing the <bpt id=\"p1\">**</bpt>Macros<ept id=\"p1\">**</ept> button.","pos":[6216,6309],"source":" You can view all available macros and their current values by choosing the **Macros** button."},{"content":"Step 4.","pos":[6350,6357]},{"content":"Updating the Target Windows Version","pos":[6358,6393]},{"content":"The next error indicates that WINVER version is no longer supported in MFC.","pos":[6397,6472]},{"content":"WINVER for Windows XP is 0x0501.","pos":[6473,6505]},{"pos":[6785,7052],"content":"Windows XP is no longer supported by Microsoft, so even though targeting it is allowed in <ph id=\"ph1\">[!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)]</ph>, you should be phasing out support for it in your applications, and encouraging your users to adopt new versions of Windows.","source":"Windows XP is no longer supported by Microsoft, so even though targeting it is allowed in [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)], you should be phasing out support for it in your applications, and encouraging your users to adopt new versions of Windows."},{"content":"To get rid of the error, define WINVER by updating the <bpt id=\"p1\">**</bpt>Project Properties<ept id=\"p1\">**</ept> setting to the lowest version of Windows you currently want to target.","pos":[7059,7207],"source":"To get rid of the error, define WINVER by updating the **Project Properties** setting to the lowest version of Windows you currently want to target."},{"content":"Find a table of values for various Windows releases <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa383745.aspx)</ept>.","pos":[7208,7332],"source":" Find a table of values for various Windows releases [here](http://msdn.microsoft.com/library/windows/desktop/aa383745.aspx)."},{"content":"The stdafx.h file contained some of these macro definitions.","pos":[7339,7399]},{"content":"WINVER we will set to Windows 7.","pos":[7650,7682]},{"content":"It’s easier to read the code later if you use the macro for Windows 7 (_WIN32_WINNT_WIN7), rather than the value itself (0x0601).","pos":[7683,7812]},{"content":"Step 5.","pos":[7953,7960]},{"content":"Linker Errors","pos":[7961,7974]},{"content":"With these changes, the SpyHk (DLL) project builds but produces a linker error.","pos":[7978,8057]},{"content":"The entry point for a DLL should not be exported.","pos":[8144,8193]},{"content":"The entry point is only intended to be called by the loader when the DLL is first loaded into memory, so it should not be in the export table, which is for other callers.","pos":[8194,8364]},{"content":"We just need to make sure it does not have the <ph id=\"ph1\">`__declspec(dllexport)`</ph> directive attached to it.","pos":[8365,8461],"source":" We just need to make sure it does not have the `__declspec(dllexport)` directive attached to it."},{"content":"In spyxxhk.c, we have to remove it from two places, the declaration and definition of DLLEntryPoint.","pos":[8462,8562]},{"content":"It never made sense to use this directive, but previous versions of the linker and compiler did not flag it as problem.","pos":[8563,8682]},{"content":"The newer versions of the linker give a warning.","pos":[8683,8731]},{"content":"The C DLL project, SpyHK.dll, now builds and links without error.","pos":[8882,8947]},{"content":"Step 6.","pos":[8994,9001]},{"content":"More outdated header files","pos":[9002,9028]},{"content":"At this point we start working on the main executable project, Spyxx.","pos":[9032,9101]},{"content":"A couple of other include files could not be found: ctl3d.h and penwin.h.","pos":[9108,9181]},{"content":"While it might be helpful to search the Internet to try to identify what included the header, sometimes the information isn’t that helpful.","pos":[9182,9321]},{"content":"We found out that ctl3d.h was part of the Exchange Development Kit and provided support for a certain style of controls on Windows 95, and penwin.h relates to Window Pen Computing, an obsolete API.","pos":[9322,9519]},{"content":"In this case, we simply comment out the #include line, and deal with the undefined symbols as we did with verstamp.h.","pos":[9520,9637]},{"content":"Everything that relates to 3D Controls or Pen Computing was removed from the project.","pos":[9638,9723]},{"content":"Given a project with many compilation errors that you are gradually eliminating, it's not realistic to find all the uses of an outdated API right away when you remove the #include directive.","pos":[9730,9920]},{"content":"We didn't detect it immediately, but rather at some later point came to an error that WM_DLGBORDER was undefined.","pos":[9921,10034]},{"content":"It is actually just one many undefined symbols that come from ctl3d.h.","pos":[10035,10105]},{"content":"Once we've determined that it relates to an outdated API, we removed all references in code to it.","pos":[10106,10204]},{"content":"Step 7.","pos":[10253,10260]},{"content":"Updating old iostreams code","pos":[10261,10288]},{"content":"The next error is common with old C++ code that uses iostreams.","pos":[10292,10355]},{"content":"mstream.h(40): fatal error C1083: Cannot open include file: 'iostream.h': No such file or directory","pos":[10362,10461]},{"content":"The issue is that the old iostreams library has been removed and replaced.","pos":[10468,10542]},{"content":"We have to replace the old iostreams with the newer standards.","pos":[10543,10605]},{"content":"These are the updated includes:","pos":[10707,10738]},{"content":"With this change, we have problems with ostrstream, which is no longer used.","pos":[10833,10909]},{"content":"The appropriate replacement is ostringstream.","pos":[10910,10955]},{"content":"We try adding a typedef for ostrstream to avoid modifying the code too much, at least as a start.","pos":[10956,11053]},{"content":"Currently the project is building using MBCS (Multi-byte Character Set), so char is the appropriate character data type.","pos":[11138,11258]},{"content":"However, to allow an easier update the code to UTF-16 Unicode, we update this to TCHAR, which resolves to char or wchar_t depending on whether the <bpt id=\"p1\">**</bpt>Character Set<ept id=\"p1\">**</ept> property in the project settings is set to MBCS or Unicode.","pos":[11259,11483],"source":" However, to allow an easier update the code to UTF-16 Unicode, we update this to TCHAR, which resolves to char or wchar_t depending on whether the **Character Set** property in the project settings is set to MBCS or Unicode."},{"content":"A few other pieces of code need to be updated.","pos":[11490,11536]},{"content":"We replaced the base class ios with ios_base, and we replaced ostream is by basic_ostream<ph id=\"ph1\">\\&lt;</ph>T&gt;.","pos":[11538,11632],"source":"  We replaced the base class ios with ios_base, and we replaced ostream is by basic_ostream\\<T>."},{"content":"We add two additional typedefs, and this section compiles.","pos":[11633,11691]},{"content":"Using these typedefs is just a temporary solution.","pos":[11791,11841]},{"content":"For a more permanent solution, we could update each reference to the renamed or outdated API.","pos":[11842,11935]},{"content":"Here’s the next error.","pos":[11942,11964]},{"content":"The next issue is that basic_stringbuf doesn’t have a freeze method.","pos":[12109,12177]},{"content":"The freeze method is used to prevent a memory leak in the old ostream.","pos":[12178,12248]},{"content":"We don’t need it now that we’re using the new ostringstream.","pos":[12249,12309]},{"content":"We can delete the call to freeze.","pos":[12310,12343]},{"content":"The next two errors occurred on adjacent lines.","pos":[12392,12439]},{"content":"The first complains about using ends, which is the old iostream library’s IO manipulator that adds a null terminator to a string.","pos":[12440,12569]},{"content":"The second of these errors explains that the output of the str method can’t be assigned to a non-const pointer.","pos":[12571,12682]},{"content":"Using the new stream library, ends is not needed since the string is always null-terminated, so that line can be removed.","pos":[13066,13187]},{"content":"For the second issue, the problem is that now str() doesn’t return a pointer to the character array for a string; it returns the std::string type.","pos":[13188,13334]},{"content":"The solution to the second is to change the type to LPCSTR and use the c_str() method to request the pointer.","pos":[13335,13444]},{"content":"An error that puzzled us for a while occurred on this code.","pos":[13525,13584]},{"content":"The macro <ph id=\"ph1\">`MOUT`</ph> resolves to *g_pmout which is an object of type <ph id=\"ph2\">`mstream`</ph>.","pos":[13700,13775],"source":"The macro `MOUT` resolves to *g_pmout which is an object of type `mstream`."},{"content":"The mstream class is derived from the standard output string class, <ph id=\"ph1\">`std::basic_ostream&lt;TCHAR&gt;.`</ph> However with _T around the string literal, which we put in in preparation for converting to Unicode, the overload resolution for operator &lt;&lt; fails with the following error message:","pos":[13776,14053],"source":" The mstream class is derived from the standard output string class, `std::basic_ostream<TCHAR>.` However with _T around the string literal, which we put in in preparation for converting to Unicode, the overload resolution for operator << fails with the following error message:"},{"content":"There are so many operator &lt;&lt; definitions that this kind of error can be intimidating.","pos":[20480,20566],"source":"There are so many operator << definitions that this kind of error can be intimidating."},{"content":"After looking more closely at the available overloads, we can see that most of them are irrelevant, and looking more closely at the <ph id=\"ph1\">`mstream`</ph> class definition, we identified the following function that we think should be called in this case.","pos":[20567,20808],"source":" After looking more closely at the available overloads, we can see that most of them are irrelevant, and looking more closely at the `mstream` class definition, we identified the following function that we think should be called in this case."},{"content":"The reason it isn't called is because the string literal has the type <ph id=\"ph1\">`const wchar_t[10]`</ph> as you can see from the last line of that long error message, so the conversion to a non-const pointer is not automatic.","pos":[20929,21139],"source":"The reason it isn't called is because the string literal has the type `const wchar_t[10]` as you can see from the last line of that long error message, so the conversion to a non-const pointer is not automatic."},{"content":"However that operator should not modify the input parameter, so the more appropriate parameter type is LPCTSTR (<ph id=\"ph1\">`const char*`</ph> when compiling as MBCS, and <ph id=\"ph2\">`const wchar_t*`</ph> as Unicode), not LPTSTR (<ph id=\"ph3\">`char*`</ph> when compiling as MBCS, and <ph id=\"ph4\">`wchar_t*`</ph> as Unicode).","pos":[21140,21395],"source":" However that operator should not modify the input parameter, so the more appropriate parameter type is LPCTSTR (`const char*` when compiling as MBCS, and `const wchar_t*` as Unicode), not LPTSTR (`char*` when compiling as MBCS, and `wchar_t*` as Unicode)."},{"content":"Making that change fixes this error.","pos":[21396,21432]},{"content":"This type of conversion was allowed under the older, less strict compiler, but more recent conformance changes require more correct code.","pos":[21439,21576]},{"content":"Step 8.","pos":[21622,21629]},{"content":"The compiler's more strict conversions","pos":[21630,21668]},{"content":"We also get many errors like the following:","pos":[21672,21715]},{"content":"The error occurs in a message map that is simply a macro:","pos":[21875,21932]},{"content":"Going to the definition of this macro, we see it references the function OnNcHitTest.","pos":[22103,22188]},{"content":"The problem has to do with the mismatch in the pointer to member function types.","pos":[22405,22485]},{"content":"The problem isn’t the conversion from CHotLinkCtrl as a class type to CWnd as the class type, since that is a valid derived-to-base conversion.","pos":[22486,22629]},{"content":"The problem is the return type: UINT vs. LRESULT.","pos":[22630,22679]},{"content":"LRESULT resolves to LONG_PTR which is a 64-bit pointer or a 32-bit pointer, depending on the target binary type, so UINT does not convert to this type.","pos":[22680,22831]},{"content":"This is not uncommon when upgrading code written before 2005 since the return type of many message map methods changed from UINT to LRESULT in Visual Studio 2005 as part of the 64-bit compatibility changes.","pos":[22832,23038]},{"content":"We change the return type from UINT in the following code to LRESULT:","pos":[23039,23108]},{"content":"After the change we have the following code:","pos":[23175,23219]},{"content":"Since there are about ten occurrences of this function all in different classes derived from CWnd, it’s helpful to use <bpt id=\"p1\">**</bpt>Go to Definition<ept id=\"p1\">**</ept> (Keyboard: F12) and <bpt id=\"p2\">**</bpt>Go to Declaration<ept id=\"p2\">**</ept> (Keyboard: Ctrl+F12) when the cursor is on the function in the editor to locate these and navigate to them from the <bpt id=\"p3\">**</bpt>Find Symbol<ept id=\"p3\">**</ept> tool window.","pos":[23289,23615],"source":"Since there are about ten occurrences of this function all in different classes derived from CWnd, it’s helpful to use **Go to Definition** (Keyboard: F12) and **Go to Declaration** (Keyboard: Ctrl+F12) when the cursor is on the function in the editor to locate these and navigate to them from the **Find Symbol** tool window."},{"content":"<bpt id=\"p1\">**</bpt>Go to Definition<ept id=\"p1\">**</ept> is usually the more useful of the two.","pos":[23616,23675],"source":"**Go to Definition** is usually the more useful of the two."},{"content":"<bpt id=\"p1\">**</bpt>Go to Declaration<ept id=\"p1\">**</ept> will find declarations other than the defining class declaration, such as friend class declarations or forward references.","pos":[23676,23820],"source":"**Go to Declaration** will find declarations other than the defining class declaration, such as friend class declarations or forward references."},{"content":"Step 9.","pos":[23857,23864]},{"content":"MFC Changes","pos":[23865,23876]},{"content":"The next error also relates to a changed declaration type and also occurs in a macro.","pos":[23880,23965]},{"content":"The issue is that the second parameter of CWnd::OnActivateApp changed from HTASK to DWORD.","pos":[24138,24228]},{"content":"This change occurred in the 2002 release of Visual Studio, Visual Studio .NET.","pos":[24229,24307]},{"content":"We have to update the declarations of OnActivateApp in derived classes accordingly as follows:","pos":[24389,24483]},{"content":"At this point, we are able to compile the project.","pos":[24570,24620]},{"content":"There are a few warnings to work through, however, and there are optional parts of the upgrade, such as converting from MBCS to Unicode or improving security by using the Secure CRT functions.","pos":[24621,24813]},{"content":"Step 10.","pos":[24856,24864]},{"content":"Addressing compiler warnings","pos":[24865,24893]},{"content":"To get a full list of warnings, you should do a <bpt id=\"p1\">**</bpt>Rebuild All<ept id=\"p1\">**</ept> on the solution rather than an ordinary build, just to make sure that everything that previously compiled will be recompiled, since you only get warning reports from the current compilation.","pos":[24897,25151],"source":"To get a full list of warnings, you should do a **Rebuild All** on the solution rather than an ordinary build, just to make sure that everything that previously compiled will be recompiled, since you only get warning reports from the current compilation."},{"content":"The other question is whether to accept the current warning level or use a higher warning level.","pos":[25152,25248]},{"content":"When porting a lot of code, especially old code, using a higher warning level might be appropriate.","pos":[25250,25349]},{"content":"You might also want to start with the default warning level and then increase the warning level to get all warnings.","pos":[25351,25467]},{"content":"If you use /Wall, you get some warnings in the system header files, so many people use /W4 to get the most warnings on their code without getting warnings for system headers.","pos":[25468,25642]},{"content":"If you want warnings to show up as errors, add the /WX option.","pos":[25643,25705]},{"content":"These settings are in the C/C++ section of the Project Properties dialog box.","pos":[25706,25783]},{"content":"One of the methods in the CSpyApp class produces a warning about a function that is no longer supported.","pos":[25790,25894]},{"content":"The warning is as follows.","pos":[26004,26030]},{"content":"The message WM_CTLCOLORDLG was already handled in Spy++ code, so the only change required was to delete any references to SetDialogBkColor, which is no longer needed.","pos":[26200,26366]},{"content":"The next warning was straightforward to fix by commenting out the variable name.","pos":[26373,26453]},{"content":"We received the following warning:","pos":[26454,26488]},{"content":"The code that produces this involves a macro.","pos":[26594,26639]},{"content":"Heavy use of macros as in this code tends to make code harder to maintain.","pos":[26945,27019]},{"content":"In this case, the macros include the declarations of the variables.","pos":[27020,27087]},{"content":"The macro PARM is defined as follows:","pos":[27088,27125]},{"content":"Therefore the lpszBuffer variable gets declared twice in the same function.","pos":[27201,27276]},{"content":"It's not that straightfoward to fix this as it would be if the code were not using macros (simply remove the second type declaration).","pos":[27277,27411]},{"content":"As it is, we have the unfortunate choice of having to decide whether to rewrite the macro code as ordinary code (a tedious and possibly error-prone task) or disable the warning.","pos":[27412,27589]},{"content":"In this case, we opt to disable the warning.","pos":[27596,27640]},{"content":"We can do that by adding a pragma as follows:","pos":[27641,27686]},{"content":"When disabling a warning, you might want to restrict the disabling effect to just the code you that produces the warning, to avoid suppressing the warning when it might provide useful information.","pos":[27745,27941]},{"content":"We add code to restore the warning just after the line that produces it, or better yet, since this warning occurs in a macro, use the <ph id=\"ph1\">`__pragma`</ph> keyword, which works in macros (<ph id=\"ph2\">`#pragma`</ph> does not work in macros).","pos":[27942,28154],"source":" We add code to restore the warning just after the line that produces it, or better yet, since this warning occurs in a macro, use the `__pragma` keyword, which works in macros (`#pragma` does not work in macros)."},{"content":"The next warning requires some code revisions.","pos":[28313,28359]},{"content":"The Win32 API GetVersion (and GetVersionEx) is deprecated.","pos":[28360,28418]},{"content":"The following code shows how the version is obtained.","pos":[28501,28554]},{"content":"This is followed by a lot of code that examines the dwWindowsVersion value to determine whether we're running on Windows 95, and which version of Windows NT.","pos":[28725,28882]},{"content":"Since this is all outdated, we remove the code and deal with any references to those variables.","pos":[28883,28978]},{"pos":[28985,29163],"content":"The article <bpt id=\"p1\">[</bpt>Operating system version changes in Windows 8.1 and Windows Server 2012 R2<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dn302074.aspx)</ept> explains the situation.","source":"The article [Operating system version changes in Windows 8.1 and Windows Server 2012 R2](https://msdn.microsoft.com/library/windows/desktop/dn302074.aspx) explains the situation."},{"content":"There are methods in the CSpyApp class that query the operating system version: IsWindows9x, IsWindows4x and IsWindows5x.","pos":[29170,29291]},{"content":"A good starting point is to assume that the versions of Windows that we intend to support (Windows 7 and later) are all close to Windows NT 5 as far the technologies used by this older application is concerned.","pos":[29292,29502]},{"content":"The uses of these methods were to deal with limitations of the older operating systems.","pos":[29503,29590]},{"content":"So we changed those methods to return TRUE for IsWindows5x and FALSE for the others.","pos":[29591,29675]},{"content":"That left only a few places where the internal variables were used directly.","pos":[29906,29982]},{"content":"Since we removed those variables, we get a few errors that have to deal with explicitly.","pos":[29983,30071]},{"content":"We could replace this with a method call or simply pass TRUE and remove the old special case for Windows 9x.","pos":[30296,30404]},{"content":"The final warning at the default level (3) has to do with a bitfield.","pos":[30563,30632]},{"content":"The code that triggers this is as follows.","pos":[30770,30812]},{"content":"The declaration of m_bStdMouse indicates that it is a bitfield.","pos":[30859,30922]},{"content":"This code was written before the built-in bool type was supported in Visual C++.","pos":[31223,31303]},{"content":"In such code, BOOL was a typedef for int.","pos":[31304,31345]},{"content":"The type int is a signed type, and the bit representation of a signed int is to use the first bit as a sign bit, so a bitfield of type int could be interpreted as representing 0 or -1, probably not what was intended.","pos":[31346,31562]},{"content":"You wouldn't know by looking at the code why these are bitfields.","pos":[31569,31634]},{"content":"Was the intent to keep the size of the object small, or is there anywhere where the binary layout of the object is used?","pos":[31635,31755]},{"content":"We changed these to ordinary BOOL members since we didn't see any reason for the use of a bitfield.","pos":[31756,31855]},{"content":"Using bitfields to keep an object's size small isn't guaranteed to work.","pos":[31856,31928]},{"content":"It depends on how the compiler lays out the type.","pos":[31929,31978]},{"content":"You might wonder if using the standard type bool throughout would be helpful.","pos":[31985,32062]},{"content":"Many of the old code patterns such as the BOOL type were invented to solve problems that were later solved in standard C++, so changing from BOOL to the bool built-in type is just one example of such a change that you consider doing after you get your code initially running in the new version.","pos":[32063,32357]},{"content":"Once we've dealt with all the warnings that appear at the default level (level 3) we changed to level 4 to catch a few additional warnings.","pos":[32364,32503]},{"content":"The first to appear was as follows:","pos":[32504,32539]},{"content":"The code that produced this warning was as follows.","pos":[32622,32673]},{"content":"This seems harmless enough, but since we wanted a clean compilation with /W4  and /WX set, we simply commented out the variable name, leaving it for the sake of readability.","pos":[32739,32912]},{"content":"Other warnings we received were useful for general code cleanup.","pos":[32982,33046]},{"content":"There are a number of implicit conversions from <ph id=\"ph1\">`int`</ph> or <ph id=\"ph2\">`unsigned int`</ph> to <ph id=\"ph3\">`WORD`</ph> (which is a typedef for <ph id=\"ph4\">`unsigned short`</ph>).","pos":[33047,33171],"source":" There are a number of implicit conversions from `int` or `unsigned int` to `WORD` (which is a typedef for `unsigned short`)."},{"content":"These involve a possible loss of data.","pos":[33172,33210]},{"content":"We added a cast to <ph id=\"ph1\">`WORD`</ph> in these cases.","pos":[33211,33252],"source":" We added a cast to `WORD` in these cases."},{"content":"Another level 4 warning we got for this code was:","pos":[33259,33308]},{"content":"The problem occurs when a variable was first declared <ph id=\"ph1\">`extern`</ph>, then later declared <ph id=\"ph2\">`static`</ph>.","pos":[33408,33501],"source":"The problem occurs when a variable was first declared `extern`, then later declared `static`."},{"content":"The meaning of these two storage class specifiers is mutually exclusive, but this is allowed as a Microsoft extension.","pos":[33502,33620]},{"content":"If you wanted the code to be portable to other compilers, or you wanted to compile it with /Za (ANSI compatibility), you would change the declarations to have matching storage class specifiers.","pos":[33621,33814]},{"content":"Step 11.","pos":[33858,33866]},{"content":"Porting from MBCS to Unicode","pos":[33867,33895]},{"content":"Note that in the Windows world, when we say Unicode, we usually mean UTF-16.","pos":[33899,33975]},{"content":"Other operating systems such as Linux use UTF-8, but Windows generally does not.","pos":[33976,34056]},{"content":"Before taking the step to actually port MBCS code to UTF-16 Unicode, we might want to temporarily eliminate the warnings that MBCS is deprecated, in order to do other work or postpone the porting until a convenient time.","pos":[34057,34277]},{"content":"The current code uses MBCS and to continue with that we need to download the MBCS version of MFC.","pos":[34278,34375]},{"content":"This rather large library was removed from the default Visual Studio installation, so it must be downloaded separately.","pos":[34377,34496]},{"content":"See <bpt id=\"p1\">[</bpt>MFC MBCS DLL Add-on<ept id=\"p1\">](../mfc/mfc-mbcs-dll-add-on.md)</ept>.","pos":[34497,34554],"source":" See [MFC MBCS DLL Add-on](../mfc/mfc-mbcs-dll-add-on.md)."},{"content":"Once you download this and restart Visual Studio, you can compile and link with the MBCS version of MFC, but to get rid of the warnings about MBCS, you should also add NO_WARN_MBCS_MFC_DEPRECATION to your list of predefined macros in the Preprocessor section of project properties, or at the beginning of your stdafx.h header file or other common header file.","pos":[34555,34914]},{"content":"We now have some linker errors.","pos":[34921,34952]},{"content":"LNK1181 occurs because an outdated static library version of mfc is included on the linker input.","pos":[35039,35136]},{"content":"This isn’t required anymore since we can link MFC dynamically, so we just need to remove all MFC static libraries from the Input property in the Linker section of the project properties.","pos":[35137,35323]},{"content":"This project is also using the /NODEFAULTLIB option, and instead it lists all the library dependencies.","pos":[35324,35427]},{"content":"Now let us actually update the old Multi-byte Character Set (MBCS) code to Unicode.","pos":[35567,35650]},{"content":"Since this is a Windows application, intimately tied to the Windows desktop platform, we will port it to UTF-16 Unicode that Windows uses.","pos":[35651,35789]},{"content":"If you are writing cross-platform code or porting a Windows application to another platform, you might want to consider porting to UTF-8, which is widely used on other operating systems.","pos":[35790,35976]},{"content":"Porting to UTF-16 Unicode, we must decide whether we still want the option to compile to MBCS or not.","pos":[35983,36084]},{"content":"If we want to have the option to support MBCS, we should use the TCHAR macro as the character type, which resolves to either char or wchar_t, depending on whether _MBCS or _UNICODE is defined during compilation.","pos":[36086,36297]},{"content":"Switching to TCHAR and the TCHAR versions of various APIs instead of wchar_t and its associated APIs means that you can get back to an MBCS version of your code simply by defining _MBCS macro instead of _UNICODE.","pos":[36298,36510]},{"content":"In addition to TCHAR, a variety of TCHAR versions of such as widely used typedefs, macros, and functions exists.","pos":[36511,36623]},{"content":"For example, LPCTSTR instead of LPCSTR, and so on.","pos":[36624,36674]},{"content":"In the project properties dialog, under <bpt id=\"p1\">**</bpt>Configuration Properties<ept id=\"p1\">**</ept>, in the <bpt id=\"p2\">**</bpt>General<ept id=\"p2\">**</ept> section, change the <bpt id=\"p3\">**</bpt>Character Set<ept id=\"p3\">**</ept> property from <bpt id=\"p4\">**</bpt>Use MBCS Character Set<ept id=\"p4\">**</ept> to <bpt id=\"p5\">**</bpt>Use Unicode Character Set<ept id=\"p5\">**</ept>.","pos":[36675,36876],"source":" In the project properties dialog, under **Configuration Properties**, in the **General** section, change the **Character Set** property from **Use MBCS Character Set** to **Use Unicode Character Set**."},{"content":"This setting affects which macro is predefined during compilation.","pos":[36877,36943]},{"content":"There is both a UNICODE macro and a _UNICODE macro.","pos":[36944,36995]},{"content":"The project property affects both consistently.","pos":[36996,37043]},{"content":"Windows headers use UNICODE where Visual C++ headers such as MFC use _UNICODE, but when one is defined, the other is always defined.","pos":[37044,37176]},{"content":"A good <bpt id=\"p1\">[</bpt>guide<ept id=\"p1\">](http://msdn.microsoft.com/library/cc194801.aspx)</ept> to porting from MBCS to UTF-16 Unicode using TCHAR exists.","pos":[37183,37305],"source":"A good [guide](http://msdn.microsoft.com/library/cc194801.aspx) to porting from MBCS to UTF-16 Unicode using TCHAR exists."},{"content":"We choose this route.","pos":[37306,37327]},{"content":"First, we change the <bpt id=\"p1\">**</bpt>Character Set<ept id=\"p1\">**</ept> property to <bpt id=\"p2\">**</bpt>Use Unicode Character Set<ept id=\"p2\">**</ept> and rebuild the project.","pos":[37328,37433],"source":" First, we change the **Character Set** property to **Use Unicode Character Set** and rebuild the project."},{"content":"Some places in the code were already using <ph id=\"ph1\">`TCHAR`</ph>, apparently in anticipation of eventually supporting Unicode.","pos":[37440,37552],"source":"Some places in the code were already using `TCHAR`, apparently in anticipation of eventually supporting Unicode."},{"content":"Some were not.","pos":[37553,37567]},{"content":"We searched for instances of <ph id=\"ph1\">`CHAR`</ph>, which is a typedef for char, and replaced most of them with TCHAR.","pos":[37568,37671],"source":" We searched for instances of `CHAR`, which is a typedef for char, and replaced most of them with TCHAR."},{"content":"Also, we looked for <ph id=\"ph1\">`sizeof (CHAR)`</ph>.","pos":[37672,37708],"source":" Also, we looked for `sizeof (CHAR)`."},{"content":"Whenever we changed from <ph id=\"ph1\">`CHAR`</ph> to <ph id=\"ph2\">`TCHAR`</ph>, we usually had to change to <ph id=\"ph3\">`sizeof(TCHAR)`</ph> since this was often used to determine the number of characters in a string.","pos":[37709,37873],"source":" Whenever we changed from `CHAR` to `TCHAR`, we usually had to change to `sizeof(TCHAR)` since this was often used to determine the number of characters in a string."},{"content":"Using the wrong type here does not produce a compiler error, so it's worth paying a bit of attention to this case.","pos":[37874,37988]},{"content":"This type of error is very common just after switching to Unicode.","pos":[37995,38061]},{"content":"Here’s an example of code that produces this:","pos":[38196,38241]},{"content":"We put _T around the string literal to remove the error.","pos":[38318,38374]},{"content":"The _T macro has the effect of making a string literal compile as a char string or a wchar_t string, depending on the setting of MBCS or UNICODE.","pos":[38455,38600]},{"content":"To replace all strings with _T in Visual Studio, first open the <bpt id=\"p1\">**</bpt>Quick Replace<ept id=\"p1\">**</ept> (Keyboard: Ctrl+F) box or the <bpt id=\"p2\">**</bpt>Replace In Files<ept id=\"p2\">**</ept> (Keyboard: Ctrl+Shift+H), then choose the <bpt id=\"p3\">**</bpt>Use Regular Expressions<ept id=\"p3\">**</ept> checkbox.","pos":[38601,38813],"source":" To replace all strings with _T in Visual Studio, first open the **Quick Replace** (Keyboard: Ctrl+F) box or the **Replace In Files** (Keyboard: Ctrl+Shift+H), then choose the **Use Regular Expressions** checkbox."},{"content":"Enter <ph id=\"ph1\">`((\\\".*?\\\")|('.+?'))`</ph> as the search text and <ph id=\"ph2\">`_T($1)`</ph> as the replacement text.","pos":[38814,38898],"source":" Enter `((\\\".*?\\\")|('.+?'))` as the search text and `_T($1)` as the replacement text."},{"content":"If you already have the _T macro around some strings, this procedure will add it again, and it might also find cases where you don't want _T, such as when you use <ph id=\"ph1\">`#include`</ph>, so it's best to use <bpt id=\"p1\">**</bpt>Replace Next<ept id=\"p1\">**</ept> rather than <bpt id=\"p2\">**</bpt>Replace All<ept id=\"p2\">**</ept>.","pos":[38899,39139],"source":" If you already have the _T macro around some strings, this procedure will add it again, and it might also find cases where you don't want _T, such as when you use `#include`, so it's best to use **Replace Next** rather than **Replace All**."},{"content":"This particular function, <bpt id=\"p1\">[</bpt>wsprintf<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ms647550.aspx)</ept>, is actually defined in the Windows headers, and the documentation for it recommends that it not be used, due to possible buffer overrun.","pos":[39146,39386],"source":"This particular function, [wsprintf](https://msdn.microsoft.com/library/windows/desktop/ms647550.aspx), is actually defined in the Windows headers, and the documentation for it recommends that it not be used, due to possible buffer overrun."},{"content":"No size is given for the <ph id=\"ph1\">`szTmp`</ph> buffer, so there is no way for the function to check that the buffer can hold all the data to be written to it.","pos":[39387,39531],"source":" No size is given for the `szTmp` buffer, so there is no way for the function to check that the buffer can hold all the data to be written to it."},{"content":"See the next section about porting to the Secure CRT, in which we fix other similar problems.","pos":[39532,39625]},{"content":"We ended up replacing it with <bpt id=\"p1\">[</bpt>_stprintf_s<ept id=\"p1\">](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md)</ept>.","pos":[39626,39751],"source":" We ended up replacing it with [_stprintf_s](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md)."},{"content":"Another common error you’ll see in converting to Unicode is this.","pos":[39758,39823]},{"content":"The code that produces it is as follows:","pos":[39913,39953]},{"content":"Even though the _tcscpy function was used, which is the TCHAR strcpy function for copying a string, the buffer that was allocated was a char buffer.","pos":[40090,40238]},{"content":"This is easily changed to TCHAR.","pos":[40239,40271]},{"content":"Similarly, we changed <ph id=\"ph1\">`LPSTR`</ph> (Long Pointer to STRing) and <ph id=\"ph2\">`LPCSTR`</ph> (Long Pointer to Constant STRing) to <ph id=\"ph3\">`LPTSTR`</ph> (Long Pointer to TCHAR STRing) and <ph id=\"ph4\">`LPCTSTR`</ph> (Long Pointer to Constant TCHAR STRing) respectively, when warranted by a compiler error.","pos":[40409,40657],"source":"Similarly, we changed `LPSTR` (Long Pointer to STRing) and `LPCSTR` (Long Pointer to Constant STRing) to `LPTSTR` (Long Pointer to TCHAR STRing) and `LPCTSTR` (Long Pointer to Constant TCHAR STRing) respectively, when warranted by a compiler error."},{"content":"We chose not to make such replacements by using global search and replace, because each situation had to be examined individually.","pos":[40658,40788]},{"content":"In some cases, the char version is wanted, such as when processing certain Windows messages which use Windows structures that have the A suffix.","pos":[40789,40933]},{"content":"In the Windows API, the suffix A means ASCII or ANSI (and also applies to MBCS), and the suffix W means wide characters, or UTF-16 Unicode.","pos":[40934,41073]},{"content":"This naming pattern is used in the Windows headers, but we also followed it in the Spy++ code when we had to add a Unicode version of a function that was already defined in only an MBCS version.","pos":[41074,41268]},{"content":"In some cases we had to replace a type to use a version that resolves correctly (WNDCLASS instead of WNDCLASSA for example).","pos":[41275,41399]},{"content":"In many cases we had to use the generic version (macro) of a Win32 API like GetClassName (instead of GetClassNameA).","pos":[41406,41522]},{"content":"In message handler switch statement, some messages are MBCS or Unicode specific, in those cases, we had to change the code to explicitly call the MBCS version, because we replaced the generically named functions with A and W specific functions, and added a macro for the generic name that resolves to the correct A or W name based on whether UNICODE is defined.","pos":[41523,41884]},{"content":"In many parts of the code, when we switched to define _UNICODE, the W version is now chosen even when the A version is what's wanted.","pos":[41886,42019]},{"content":"There are a few places where special actions had to be taken.","pos":[42026,42087]},{"content":"Any use of WideCharToMultiByte or MultiByteToWideChar might require a closer look.","pos":[42088,42170]},{"content":"Here's one example where WideCharToMultiByte was being used.","pos":[42171,42231]},{"content":"To address this, we had to understand that the reason this was done was to copy a wide character string representing the name of a font into the internal buffer of a CString, strFace.","pos":[42820,43003]},{"content":"This required slightly different code for multibyte CString strings as for wide character CString strings, so we added an #ifdef in this case.","pos":[43004,43146]},{"content":"Of course, instead of wcscpy we really should use wcscpy_s, the more secure version.","pos":[43446,43530]},{"content":"The next section addresses this.","pos":[43531,43563]},{"content":"As a check on our work, we should reset the Character Set to Use Multibyte Character Set and make sure that the code still compiles using MBCS as well as Unicode.","pos":[43570,43732]},{"content":"Needless to say, a full test pass should be executed on the recompiled app after all these changes.","pos":[43733,43832]},{"content":"In our work with this Spy++ solution, it took about two working days for an average C++ developer to convert the code to Unicode.","pos":[43839,43968]},{"content":"That did not include the retesting time.","pos":[43969,44009]},{"content":"Step 12.","pos":[44056,44064]},{"content":"Porting to use the Secure CRT","pos":[44065,44094]},{"content":"Porting the code to use the secure versions (the versions with the _s suffix) of CRT functions is next.","pos":[44098,44201]},{"content":"In this case, the general strategy is to replace the function with the _s version and then, usually, add the required additional buffer size parameters.","pos":[44202,44354]},{"content":"In many cases this is straightforward since the size is known.","pos":[44355,44417]},{"content":"In other cases, where the size is not immediately available, it’s necessary to add additional parameters to the function that’s using the CRT function, or perhaps examine the usage of the destination buffer and see what the appropriate size limits are.","pos":[44418,44670]},{"content":"Visual C++ provides a trick to make it easier to get code secure without adding as many size parameters, and that is by using the template overloads.","pos":[44677,44826]},{"content":"Since these overloads are templates, they are only available when compiling as C++, not as C. Spyxxhk is a C project, so the trick won't work for that.","pos":[44827,44978]},{"content":"However, Spyxx is not and we can use the trick.","pos":[44980,45027]},{"content":"The trick is to add a line like this in a place where it will be compiled in every file of the project, such as in stdafx.h:","pos":[45028,45152]},{"content":"When you define that, whenever the buffer is an array, rather than a raw pointer, its size is inferred from the array type and that is used as the size parameter, without you having to supply it.","pos":[45220,45415]},{"content":"That helps to cut down the complexity of rewriting the code.","pos":[45416,45476]},{"content":"You still have to replace the function name with the _s version, but that can often be done by a search and replace operation.","pos":[45477,45603]},{"content":"The return values of some functions changed.","pos":[45610,45654]},{"content":"For example, _itoa_s (and _itow_s and the macro _itot_s) returns an error code (errno_t), rather than the string.","pos":[45655,45768]},{"content":"So in those cases, you have to move the call to _itoa_s onto a separate line and replace it with the buffer's identifier.","pos":[45769,45890]},{"content":"Some of the common cases: for memcpy, when switching to memcpy_s, we frequently added the size of the structure being copied to.","pos":[45897,46025]},{"content":"Similarly, for most strings and buffers, the size of the array or buffer is easily determined from the declaration of the buffer or by finding where the buffer was originally allocated.","pos":[46026,46211]},{"content":"For some situations, you need to determine how big of a buffer is actually available, and if that information is not available in the scope of the function that you’re modifying, it should be added as an additional parameter and the calling code should be modified to provide the information.","pos":[46212,46504]},{"content":"With these techniques, it took about half a day to convert the code to use the secure CRT functions.","pos":[46511,46611]},{"content":"If you choose not to the template overloads and to add the size parameters manually, it would probably take twice or three times more time.","pos":[46612,46751]},{"content":"Step 13.","pos":[46796,46804]},{"content":"/Zc:forScope- is deprecated","pos":[46805,46832]},{"content":"Since Visual C++ 6.0, the compiler conforms to the current standard, which limits the scope of variables declared in a  loop to the scope of the loop.","pos":[46836,46986]},{"content":"The compiler option <bpt id=\"p1\">[</bpt>/Zc:forScope<ept id=\"p1\">](../build/reference/zc-forscope-force-conformance-in-for-loop-scope.md)</ept> (<bpt id=\"p2\">**</bpt>Force Conformance for Loop Scope<ept id=\"p2\">**</ept> in the project properties) controls whether or not this is reported as an error.","pos":[46987,47211],"source":" The compiler option [/Zc:forScope](../build/reference/zc-forscope-force-conformance-in-for-loop-scope.md) (**Force Conformance for Loop Scope** in the project properties) controls whether or not this is reported as an error."},{"content":"We should update our code to be conformant, and add declarations just outside the loop.","pos":[47212,47299]},{"content":"To avoid making the code changes, you can change that setting in the Language section of the C++ project properties to <bpt id=\"p1\">**</bpt>No (/Zc:forScope-)<ept id=\"p1\">**</ept>.","pos":[47300,47442],"source":" To avoid making the code changes, you can change that setting in the Language section of the C++ project properties to **No (/Zc:forScope-)**."},{"content":"However, keep in mind that <bpt id=\"p1\">**</bpt>/Zc:forScope-<ept id=\"p1\">**</ept> might be removed in a future release of Visual C++, so eventually your code will need to change to conform to the standard.","pos":[47443,47611],"source":" However, keep in mind that **/Zc:forScope-** might be removed in a future release of Visual C++, so eventually your code will need to change to conform to the standard."},{"content":"These issues are relatively easy to fix, but depending on your code, it might affect a lot of code.","pos":[47618,47717]},{"content":"Here's a typical issue.","pos":[47718,47741]},{"content":"The above code produces the error:","pos":[47941,47975]},{"content":"This occurs because the compiler has deprecated a compiler option that allowed code that no longer complies with the C++ standard.","pos":[48032,48162]},{"content":"In the standard, declaring a variable inside a loop restricts its scope to the loop only, so the common practice of using a loop counter outside of the loop requires that the declaration of the counter also be moved outside the loop, as in the following revised code:","pos":[48163,48430]},{"content":"Summary","pos":[48637,48644]},{"content":"Porting Spy++ from the original Visual C++ 6.0 code to the latest compiler took about 20 hours of coding time over the course of about a week.","pos":[48648,48790]},{"content":"We upgraded directly through eight releases of the product, but for larger projects, you might find it better to upgrade one release at a time.","pos":[48791,48934]},{"content":"This might take longer, but at least you will be able to narrow down what version of the tools caused a particular error to occur.","pos":[48935,49065]},{"content":"See Also","pos":[49074,49082]},{"content":"Porting and Upgrading: Examples and Case Studies","pos":[49087,49135]},{"content":"Previous case study: COM Spy","pos":[49205,49233]}],"content":"---\ntitle: \"Porting Guide: Spy++ | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: e558f759-3017-48a7-95a9-b5b779d5e51d\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Porting Guide: Spy++\nThis porting case study is designed to give you an idea of what a typical porting project is like, the types of problems you might encounter, and some general tips and tricks for addressing porting problems. It's not meant to be a definitive guide to porting, since the experience of porting a project depends very much on the specifics of the code.  \n  \n## Spy++  \n Spy++ is a widely used GUI diagnostic tool for the Windows desktop that provides all sorts of information about user interface elements on the Windows desktop. It shows the complete hierarchy of windows and provides access to metadata about each window and control. This useful application has shipped with Visual Studio for many years. We found an old version of it that was last compiled in Visual C++ 6.0 and ported it to [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)].  \n  \n We considered this case to be typical for porting Windows desktop applications that use MFC and the Win32 API, especially for old projects that have not been updated with each release of Visual C++ since Visual C++ 6.0.  \n  \n##  <a name=\"convert_project_file\"></a> Step 1. Converting the project file.  \n The project file, two old .dsw files from Visual C++ 6.0, converted easily with no issues that require further attention. One project is the Spy++ application. The other is SpyHk, written in C, a supporting DLL. More complex projects might not upgrade as easily, as discussed [here](../porting/visual-cpp-porting-and-upgrading-guide.md).  \n  \n After upgrading the two projects, our solution looked like this:  \n  \n ![The Spy&#43;&#43; Solution](../porting/media/spyxxsolution.PNG \"SpyxxSolution\")  \n  \n We have two projects, one with a large number of C++ files, and another a DLL that's written in C.  \n  \n##  <a name=\"header_file_problems\"></a> Step 2. Header file problems  \n Upon building a newly converted project, one of the first things you'll often find is that header files that your project uses are not found.  \n  \n One of the files that couldn't be found in Spy++ was verstamp.h. From an Internet search, we determined that this came from a DAO SDK, an obsolete data technology. We wanted to find out what symbols were being used from that header file, to see if that file was really needed or if those symbols were defined elsewhere, so we commented out the header file declaration and recompiled. It turns out there is just one symbol that is needed, VER_FILEFLAGSMASK.  \n  \n```  \n1>C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\common.ver(212): error RC2104: undefined keyword or key name: VER_FILEFLAGSMASK  \n```  \n  \n The easiest way to find a symbol in the available include files is to use Find in Files (Ctrl+Shift+F) and specify **Visual C++ Include Directories**. We found it in ntverp.h. We replaced the verstamp.h include with ntverp.h and this error disappeared.  \n  \n##  <a name=\"linker_output_settings\"></a> Step 3. Linker OutputFile setting  \n Older projects sometimes have files placed in unconventional locations that can cause problems after upgrading. In this case, we have to add $(SolutionDir) to the Include path in the project properties to ensure that Visual Studio can find some header files that are placed there, rather than in one of the project folders.  \n  \n MSBuild complains that the Link.OutputFile property does not match the TargetPath and TargetName values, issuing MSB8012.  \n  \n```Output  \nwarning MSB8012: TargetPath(...\\spyxx\\spyxxhk\\.\\..\\Debug\\SpyxxHk.dll) does not match the Linker's OutputFile property value (...\\spyxx\\Debug\\SpyHk55.dll). This may cause your project to build incorrectly. To correct this, please make sure that $(OutDir), $(TargetName) and $(TargetExt) property values match the value specified in %(Link.OutputFile).warning MSB8012: TargetName(SpyxxHk) does not match the Linker's OutputFile property value (SpyHk55). This may cause your project to build incorrectly. To correct this, please make sure that $(OutDir), $(TargetName) and $(TargetExt) property values match the value specified in %(Link.OutputFile).  \n```  \n  \n **Link.OutputFile** is the build output (EXE, DLL, for example), and it is normally constructed from $(TargetDir)$(TargetName)$(TargetExt), giving the path, filename and extension. This is a common error when migrating projects from the old Visual C++ build tool (vcbuild.exe) to the new build tool (MSBuild.exe). Since the build tool change occurred in Visual Studio 2010, you might encounter this issue whenever you migrate a pre-2010 project to a 2010 or later version. The basic problem is that the project migration wizard doesn’t update the **Link.OutputFile** value since it’s not always possible to determine what its value should be based on the other project settings. Therefore, you usually have to set it manually. For more details, see this [post](http://blogs.msdn.com/b/vcblog/archive/2010/03/02/visual-studio-2010-c-project-upgrade-guide.aspx) on the Visual C++ blog.  \n  \n In this case, the **Link.OutputFile** property in the converted project was set to .\\Debug\\Spyxx.exe and .\\Release\\Spyxx.exe for the Spy++ project, depending on the configuration. The best bet is to simply replace these hardcoded values with $(TargetDir)$(TargetName)$(TargetExt) for All Configurations. If that doesn’t work, you can customize from there, or change the properties in the General section where those values are set (the properties are **Output Directory**, **Target Name**, and **Target Extension**. Remember that if the property you are viewing uses macros, you can choose **Edit** in the dropdown list to bring up a dialog box that shows the final string with the macro substitutions made. You can view all available macros and their current values by choosing the **Macros** button.  \n  \n##  <a name=\"updating_winver\"></a> Step 4. Updating the Target Windows Version  \n The next error indicates that WINVER version is no longer supported in MFC. WINVER for Windows XP is 0x0501.  \n  \n```Output  \nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxv_w32.h(40): fatal error C1189: #error:  MFC does not support WINVER less than 0x0501.  Please change the definition of WINVER in your project properties or precompiled header.  \n```  \n  \n Windows XP is no longer supported by Microsoft, so even though targeting it is allowed in [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)], you should be phasing out support for it in your applications, and encouraging your users to adopt new versions of Windows.  \n  \n To get rid of the error, define WINVER by updating the **Project Properties** setting to the lowest version of Windows you currently want to target. Find a table of values for various Windows releases [here](http://msdn.microsoft.com/library/windows/desktop/aa383745.aspx).  \n  \n The stdafx.h file contained some of these macro definitions.  \n  \n```cpp  \n  \n#define WINVER       0x0500  // these defines are set so that we get the  \n#define _WIN32_WINNT 0x0500  // maximum set of message/flag definitions,  \n#define _WIN32_IE    0x0400  // from both winuser.h and commctrl.h.  \n  \n```  \n  \n WINVER we will set to Windows 7. It’s easier to read the code later if you use the macro for Windows 7 (_WIN32_WINNT_WIN7), rather than the value itself (0x0601).  \n  \n```cpp  \n#define WINVER _WINNT_WIN32_WIN7 // Minimum targeted Windows version is Windows 7  \n```  \n  \n##  <a name=\"linker_errors\"></a> Step 5. Linker Errors  \n With these changes, the SpyHk (DLL) project builds but produces a linker error.  \n  \n```  \nLINK : warning LNK4216: Exported entry point _DLLEntryPoint@12  \n```  \n  \n The entry point for a DLL should not be exported. The entry point is only intended to be called by the loader when the DLL is first loaded into memory, so it should not be in the export table, which is for other callers. We just need to make sure it does not have the `__declspec(dllexport)` directive attached to it. In spyxxhk.c, we have to remove it from two places, the declaration and definition of DLLEntryPoint. It never made sense to use this directive, but previous versions of the linker and compiler did not flag it as problem. The newer versions of the linker give a warning.  \n  \n```cpp  \n  \n// deleted __declspec(dllexport)  \nBOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL,DWORD fdwReason, LPVOID lpvReserved);  \n  \n```  \n  \n The C DLL project, SpyHK.dll, now builds and links without error.  \n  \n##  <a name=\"outdated_header_files\"></a> Step 6. More outdated header files  \n At this point we start working on the main executable project, Spyxx.  \n  \n A couple of other include files could not be found: ctl3d.h and penwin.h. While it might be helpful to search the Internet to try to identify what included the header, sometimes the information isn’t that helpful. We found out that ctl3d.h was part of the Exchange Development Kit and provided support for a certain style of controls on Windows 95, and penwin.h relates to Window Pen Computing, an obsolete API. In this case, we simply comment out the #include line, and deal with the undefined symbols as we did with verstamp.h. Everything that relates to 3D Controls or Pen Computing was removed from the project.  \n  \n Given a project with many compilation errors that you are gradually eliminating, it's not realistic to find all the uses of an outdated API right away when you remove the #include directive. We didn't detect it immediately, but rather at some later point came to an error that WM_DLGBORDER was undefined. It is actually just one many undefined symbols that come from ctl3d.h. Once we've determined that it relates to an outdated API, we removed all references in code to it.  \n  \n##  <a name=\"updating_iostreams_code\"></a> Step 7. Updating old iostreams code  \n The next error is common with old C++ code that uses iostreams.  \n  \n mstream.h(40): fatal error C1083: Cannot open include file: 'iostream.h': No such file or directory  \n  \n The issue is that the old iostreams library has been removed and replaced. We have to replace the old iostreams with the newer standards.  \n  \n```cpp  \n  \n#include <iostream.h>  \n#include <strstrea.h>  \n#include <iomanip.h>  \n  \n```  \n  \n These are the updated includes:  \n  \n```cpp  \n  \n#include <iostream>  \n#include <sstream>  \n#include <iomanip>  \n  \n```  \n  \n With this change, we have problems with ostrstream, which is no longer used. The appropriate replacement is ostringstream. We try adding a typedef for ostrstream to avoid modifying the code too much, at least as a start.  \n  \n```cpp  \n  \ntypedef std::basic_ostringstream<TCHAR> ostrstream;  \n  \n```  \n  \n Currently the project is building using MBCS (Multi-byte Character Set), so char is the appropriate character data type. However, to allow an easier update the code to UTF-16 Unicode, we update this to TCHAR, which resolves to char or wchar_t depending on whether the **Character Set** property in the project settings is set to MBCS or Unicode.  \n  \n A few other pieces of code need to be updated.  We replaced the base class ios with ios_base, and we replaced ostream is by basic_ostream\\<T>. We add two additional typedefs, and this section compiles.  \n  \n```cpp  \n  \ntypedef std::basic_ostream<TCHAR> ostream;  \ntypedef ios_base ios;  \n  \n```  \n  \n Using these typedefs is just a temporary solution. For a more permanent solution, we could update each reference to the renamed or outdated API.  \n  \n Here’s the next error.  \n  \n```Output  \nerror C2039: 'freeze': is not a member of 'std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>'  \n```  \n  \n The next issue is that basic_stringbuf doesn’t have a freeze method. The freeze method is used to prevent a memory leak in the old ostream. We don’t need it now that we’re using the new ostringstream. We can delete the call to freeze.  \n  \n```cpp  \n//rdbuf()->freeze(0);  \n```  \n  \n The next two errors occurred on adjacent lines. The first complains about using ends, which is the old iostream library’s IO manipulator that adds a null terminator to a string.  The second of these errors explains that the output of the str method can’t be assigned to a non-const pointer.  \n  \n```cpp  \n  \n// Null terminate the string in the buffer and  \n// get a pointer to it.  \n//  \n*this << ends;  \nLPSTR psz = str();  \n  \n```  \n  \n```Output  \n2>mstream.cpp(167): error C2065: 'ends': undeclared identifier2>mstream.cpp(168): error C2440: 'initializing': cannot convert from 'std::basic_string<char,std::char_traits<char>,std::allocator<char>>' to 'LPSTR'  \n```  \n  \n Using the new stream library, ends is not needed since the string is always null-terminated, so that line can be removed. For the second issue, the problem is that now str() doesn’t return a pointer to the character array for a string; it returns the std::string type. The solution to the second is to change the type to LPCSTR and use the c_str() method to request the pointer.  \n  \n```cpp  \n  \n//*this << ends;  \nLPCTSTR psz = str().c_str();  \n  \n```  \n  \n An error that puzzled us for a while occurred on this code.  \n  \n```cpp  \n  \nMOUT << _T(\" chUser:'\") << chUser  \n<< _T(\"' (\") << (INT)(UCHAR)chUser << _T(')');  \n  \n```  \n  \n The macro `MOUT` resolves to *g_pmout which is an object of type `mstream`. The mstream class is derived from the standard output string class, `std::basic_ostream<TCHAR>.` However with _T around the string literal, which we put in in preparation for converting to Unicode, the overload resolution for operator << fails with the following error message:  \n  \n```Output  \n1>winmsgs.cpp(4612): error C2666: 'mstream::operator <<': 2 overloads have similar conversions\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(120): note: could be 'mstream &mstream::operator <<(ios &(__cdecl *)(ios &))'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(118): note: or       'mstream &mstream::operator <<(ostream &(__cdecl *)(ostream &))'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(116): note: or       'mstream &mstream::operator <<(ostrstream &(__cdecl *)(ostrstream &))'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(114): note: or       'mstream &mstream::operator <<(mstream &(__cdecl *)(mstream &))'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(109): note: or       'mstream &mstream::operator <<(LPTSTR)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(104): note: or       'mstream &mstream::operator <<(TCHAR)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(102): note: or       'mstream &mstream::operator <<(DWORD)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(101): note: or       'mstream &mstream::operator <<(WORD)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(100): note: or       'mstream &mstream::operator <<(BYTE)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(95): note: or       'mstream &mstream::operator <<(long)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(90): note: or       'mstream &mstream::operator <<(unsigned int)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(85): note: or       'mstream &mstream::operator <<(int)'\n1>  c:\\source\\spyxx\\spyxx\\mstream.h(83): note: or       'mstream &mstream::operator <<(HWND)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1132): note: or       'CDumpContext &operator <<(CDumpContext &,COleSafeArray &)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1044): note: or       'CArchive &operator <<(CArchive &,ATL::COleDateTimeSpan)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1042): note: or       'CDumpContext &operator <<(CDumpContext &,ATL::COleDateTimeSpan)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1037): note: or       'CArchive &operator <<(CArchive &,ATL::COleDateTime)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1035): note: or       'CDumpContext &operator <<(CDumpContext &,ATL::COleDateTime)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1030): note: or       'CArchive &operator <<(CArchive &,COleCurrency)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(1028): note: or       'CDumpContext &operator <<(CDumpContext &,COleCurrency)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(955): note: or       'CArchive &operator <<(CArchive &,ATL::CComBSTR)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(951): note: or       'CArchive &operator <<(CArchive &,COleVariant)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxdisp.h(949): note: or       'CDumpContext &operator <<(CDumpContext &,COleVariant)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(248): note: or       'CArchive &operator <<(CArchive &,const RECT &)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(247): note: or       'CArchive &operator <<(CArchive &,POINT)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(246): note: or       'CArchive &operator <<(CArchive &,SIZE)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(242): note: or       'CDumpContext &operator <<(CDumpContext &,const RECT &)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(241): note: or       'CDumpContext &operator <<(CDumpContext &,POINT)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afxwin.h(240): note: or       'CDumpContext &operator <<(CDumpContext &,SIZE)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afx.h(1639): note: or       'CArchive &operator <<(CArchive &,const CObject *)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afx.h(1425): note: or       'CArchive &operator <<(CArchive &,ATL::CTime)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afx.h(1423): note: or       'CDumpContext &operator <<(CDumpContext &,ATL::CTime)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afx.h(1418): note: or       'CArchive &operator <<(CArchive &,ATL::CTimeSpan)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\atlmfc\\include\\afx.h(1416): note: or       'CDumpContext &operator <<(CDumpContext &,ATL::CTimeSpan)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream(694): note: or       'std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &std::operator <<<wchar_t,std::char_traits<wchar_t>>(std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &,const char *)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream(741): note: or       'std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &std::operator <<<wchar_t,std::char_traits<wchar_t>>(std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &,char)'\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream(866): note: or       'std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &std::operator <<<wchar_t,std::char_traits<wchar_t>>(std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &,const _Elem *)'\n1>          with\n1>          [\n1>              _Elem=wchar_t\n1>          ]\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream(983): note: or       'std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &std::operator <<<wchar_t,std::char_traits<wchar_t>,wchar_t[10]>(std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &&,const _Ty (&))'\n1>          with\n1>          [\n1>              _Ty=wchar_t [10]\n1>          ]\n1>  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream(1021): note: or       'std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &std::operator <<<wchar_t,std::char_traits<wchar_t>>(std::basic_ostream<wchar_t,std::char_traits<wchar_t>> &,const std::error_code &)'\n1>  winmsgs.cpp(4612): note: while trying to match the argument list '(CMsgStream, const wchar_t [10])'  \n```  \n  \n There are so many operator << definitions that this kind of error can be intimidating. After looking more closely at the available overloads, we can see that most of them are irrelevant, and looking more closely at the `mstream` class definition, we identified the following function that we think should be called in this case.  \n  \n```cpp  \n  \nmstream& operator<<(LPTSTR psz)  \n{  \nreturn (mstream&)ostrstream::operator<<(psz);  \n}  \n  \n```  \n  \n The reason it isn't called is because the string literal has the type `const wchar_t[10]` as you can see from the last line of that long error message, so the conversion to a non-const pointer is not automatic. However that operator should not modify the input parameter, so the more appropriate parameter type is LPCTSTR (`const char*` when compiling as MBCS, and `const wchar_t*` as Unicode), not LPTSTR (`char*` when compiling as MBCS, and `wchar_t*` as Unicode). Making that change fixes this error.  \n  \n This type of conversion was allowed under the older, less strict compiler, but more recent conformance changes require more correct code.  \n  \n##  <a name=\"stricter_conversions\"></a> Step 8. The compiler's more strict conversions  \n We also get many errors like the following:  \n  \n```  \nerror C2440: 'static_cast': cannot convert from 'UINT (__thiscall CHotLinkCtrl::* )(CPoint)' to 'LRESULT (__thiscall CWnd::* )(CPoint)'  \n```  \n  \n The error occurs in a message map that is simply a macro:  \n  \n```cpp  \n  \nBEGIN_MESSAGE_MAP(CFindToolIcon, CWnd)  \n// other message omitted …  \nON_WM_NCHITTEST() // Error occurs on this line.  \nEND_MESSAGE_MAP()  \n  \n```  \n  \n Going to the definition of this macro, we see it references the function OnNcHitTest.  \n  \n```cpp  \n  \n#define ON_WM_NCHITTEST() \\  \n{ WM_NCHITTEST, 0, 0, 0, AfxSig_l_p, \\  \n(AFX_PMSG)(AFX_PMSGW) \\  \n(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(CPoint) > (&ThisClass :: OnNcHitTest)) },  \n  \n```  \n  \n The problem has to do with the mismatch in the pointer to member function types. The problem isn’t the conversion from CHotLinkCtrl as a class type to CWnd as the class type, since that is a valid derived-to-base conversion. The problem is the return type: UINT vs. LRESULT. LRESULT resolves to LONG_PTR which is a 64-bit pointer or a 32-bit pointer, depending on the target binary type, so UINT does not convert to this type. This is not uncommon when upgrading code written before 2005 since the return type of many message map methods changed from UINT to LRESULT in Visual Studio 2005 as part of the 64-bit compatibility changes. We change the return type from UINT in the following code to LRESULT:  \n  \n```cpp  \nafx_msg UINT OnNcHitTest(CPoint point);  \n```  \n  \n After the change we have the following code:  \n  \n```cpp  \nafx_msg LRESULT OnNcHitTest(CPoint point);  \n```  \n  \n Since there are about ten occurrences of this function all in different classes derived from CWnd, it’s helpful to use **Go to Definition** (Keyboard: F12) and **Go to Declaration** (Keyboard: Ctrl+F12) when the cursor is on the function in the editor to locate these and navigate to them from the **Find Symbol** tool window. **Go to Definition** is usually the more useful of the two. **Go to Declaration** will find declarations other than the defining class declaration, such as friend class declarations or forward references.  \n  \n##  <a name=\"mfc_changes\"></a> Step 9. MFC Changes  \n The next error also relates to a changed declaration type and also occurs in a macro.  \n  \n```Output  \nerror C2440: 'static_cast': cannot convert from 'void (__thiscall CFindWindowDlg::* )(BOOL,HTASK)' to 'void (__thiscall CWnd::* )(BOOL,DWORD)'  \n```  \n  \n The issue is that the second parameter of CWnd::OnActivateApp changed from HTASK to DWORD. This change occurred in the 2002 release of Visual Studio, Visual Studio .NET.  \n  \n```cpp  \nafx_msg void OnActivateApp(BOOL bActive, HTASK hTask);  \n```  \n  \n We have to update the declarations of OnActivateApp in derived classes accordingly as follows:  \n  \n```cpp  \nafx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadId);  \n```  \n  \n At this point, we are able to compile the project. There are a few warnings to work through, however, and there are optional parts of the upgrade, such as converting from MBCS to Unicode or improving security by using the Secure CRT functions.  \n  \n##  <a name=\"compiler_warnings\"></a> Step 10. Addressing compiler warnings  \n To get a full list of warnings, you should do a **Rebuild All** on the solution rather than an ordinary build, just to make sure that everything that previously compiled will be recompiled, since you only get warning reports from the current compilation. The other question is whether to accept the current warning level or use a higher warning level.  When porting a lot of code, especially old code, using a higher warning level might be appropriate.  You might also want to start with the default warning level and then increase the warning level to get all warnings. If you use /Wall, you get some warnings in the system header files, so many people use /W4 to get the most warnings on their code without getting warnings for system headers. If you want warnings to show up as errors, add the /WX option. These settings are in the C/C++ section of the Project Properties dialog box.  \n  \n One of the methods in the CSpyApp class produces a warning about a function that is no longer supported.  \n  \n```cpp  \nvoid SetDialogBkColor() {CWinApp::SetDialogBkColor(::GetSysColor(COLOR_BTNFACE));}  \n```  \n  \n The warning is as follows.  \n  \n```Output  \nwarning C4996: 'CWinApp::SetDialogBkColor': CWinApp::SetDialogBkColor is no longer supported. Instead, handle WM_CTLCOLORDLG in your dialog  \n```  \n  \n The message WM_CTLCOLORDLG was already handled in Spy++ code, so the only change required was to delete any references to SetDialogBkColor, which is no longer needed.  \n  \n The next warning was straightforward to fix by commenting out the variable name. We received the following warning:  \n  \n```Output  \nwarning C4456: declaration of 'lpszBuffer' hides previous local declaration  \n```  \n  \n The code that produces this involves a macro.  \n  \n```cpp  \n  \nDECODEPARM(CB_GETLBTEXT)  \n{  \nP2WPOUT();  \n  \nP2LPOUTPTRSTR;  \nP2IFDATA()  \n{  \nPARM(lpszBuffer, PPACK_STRINGORD, ED2);  \n  \nINDENT();  \n  \nP2IFISORD(lpszBuffer)  \n{  \nP2OUTORD(lpszBuffer);  \n}  \nelse  \n{  \nPARM(lpszBuffer, LPTSTR, ED2);  \nP2OUTS(lpszBuffer);  \n}  \n}  \n}  \n  \n```  \n  \n Heavy use of macros as in this code tends to make code harder to maintain. In this case, the macros include the declarations of the variables. The macro PARM is defined as follows:  \n  \n```cpp  \n#define PARM(var, type, src)type var = (type)src  \n```  \n  \n Therefore the lpszBuffer variable gets declared twice in the same function. It's not that straightfoward to fix this as it would be if the code were not using macros (simply remove the second type declaration). As it is, we have the unfortunate choice of having to decide whether to rewrite the macro code as ordinary code (a tedious and possibly error-prone task) or disable the warning.  \n  \n In this case, we opt to disable the warning. We can do that by adding a pragma as follows:  \n  \n```cpp  \n#pragma warning(disable : 4456)  \n```  \n  \n When disabling a warning, you might want to restrict the disabling effect to just the code you that produces the warning, to avoid suppressing the warning when it might provide useful information. We add code to restore the warning just after the line that produces it, or better yet, since this warning occurs in a macro, use the `__pragma` keyword, which works in macros (`#pragma` does not work in macros).  \n  \n```cpp  \n  \n#define PARM(var, type, src)__pragma(warning(disable : 4456))  \\  \ntype var = (type)src \\  \n__pragma(warning(default : 4456))  \n  \n```  \n  \n The next warning requires some code revisions. The Win32 API GetVersion (and GetVersionEx) is deprecated.  \n  \n```Output  \nwarning C4996: 'GetVersion': was declared deprecated  \n```  \n  \n The following code shows how the version is obtained.  \n  \n```cpp  \n  \n// check Windows version and set m_bIsWindows9x/m_bIsWindows4x/m_bIsWindows5x flags accordingly.  \nDWORD dwWindowsVersion = GetVersion();  \n  \n```  \n  \n This is followed by a lot of code that examines the dwWindowsVersion value to determine whether we're running on Windows 95, and which version of Windows NT. Since this is all outdated, we remove the code and deal with any references to those variables.  \n  \n The article [Operating system version changes in Windows 8.1 and Windows Server 2012 R2](https://msdn.microsoft.com/library/windows/desktop/dn302074.aspx) explains the situation.  \n  \n There are methods in the CSpyApp class that query the operating system version: IsWindows9x, IsWindows4x and IsWindows5x. A good starting point is to assume that the versions of Windows that we intend to support (Windows 7 and later) are all close to Windows NT 5 as far the technologies used by this older application is concerned. The uses of these methods were to deal with limitations of the older operating systems. So we changed those methods to return TRUE for IsWindows5x and FALSE for the others.  \n  \n```cpp  \n  \nBOOL IsWindows9x() {/*return(m_bIsWindows9x);*/ return FALSE;  }  \nBOOL IsWindows4x() {/*return(m_bIsWindows4x);*/ return FALSE;  }  \nBOOL IsWindows5x() {/*return(m_bIsWindows5x);*/ return TRUE;  }  \n  \n```  \n  \n That left only a few places where the internal variables were used directly. Since we removed those variables, we get a few errors that have to deal with explicitly.  \n  \n```Output  \nerror C2065: 'm_bIsWindows9x': undeclared identifier  \n```  \n  \n```cpp  \n  \nvoid CSpyApp::OnUpdateSpyProcesses(CCmdUI *pCmdUI)  \n{  \npCmdUI->Enable(m_bIsWindows9x || hToolhelp32 != NULL);  \n}  \n  \n```  \n  \n We could replace this with a method call or simply pass TRUE and remove the old special case for Windows 9x.  \n  \n```cpp  \n  \nvoid CSpyApp::OnUpdateSpyProcesses(CCmdUI *pCmdUI)  \n{  \npCmdUI->Enable(TRUE /*!m_bIsWindows9x || hToolhelp32 != NULL*/);  \n}  \n  \n```  \n  \n The final warning at the default level (3) has to do with a bitfield.  \n  \n```Output  \ntreectl.cpp(1656): warning C4463: overflow; assigning 1 to bit-field that can only hold values from -1 to 0  \n```  \n  \n The code that triggers this is as follows.  \n  \n```cpp  \nm_bStdMouse = TRUE;  \n```  \n  \n The declaration of m_bStdMouse indicates that it is a bitfield.  \n  \n```cpp  \n  \nclass CTreeListBox : public CListBox  \n{  \nDECLARE_DYNCREATE(CTreeListBox)  \n  \nCTreeListBox();  \n  \nprivate:  \nint ItemFromPoint(const CPoint& point);  \n  \nclass CTreeCtl* m_pTree;  \nBOOL m_bGotMouseDown : 1;  \nBOOL m_bDeferedDeselection : 1;  \nBOOL m_bStdMouse : 1;  \n  \n```  \n  \n This code was written before the built-in bool type was supported in Visual C++. In such code, BOOL was a typedef for int. The type int is a signed type, and the bit representation of a signed int is to use the first bit as a sign bit, so a bitfield of type int could be interpreted as representing 0 or -1, probably not what was intended.  \n  \n You wouldn't know by looking at the code why these are bitfields. Was the intent to keep the size of the object small, or is there anywhere where the binary layout of the object is used? We changed these to ordinary BOOL members since we didn't see any reason for the use of a bitfield. Using bitfields to keep an object's size small isn't guaranteed to work. It depends on how the compiler lays out the type.  \n  \n You might wonder if using the standard type bool throughout would be helpful. Many of the old code patterns such as the BOOL type were invented to solve problems that were later solved in standard C++, so changing from BOOL to the bool built-in type is just one example of such a change that you consider doing after you get your code initially running in the new version.  \n  \n Once we've dealt with all the warnings that appear at the default level (level 3) we changed to level 4 to catch a few additional warnings. The first to appear was as follows:  \n  \n```Output  \nwarning C4100: 'nTab': unreferenced formal parameter  \n```  \n  \n The code that produced this warning was as follows.  \n  \n```cpp  \nvirtual void OnSelectTab(int nTab) {};  \n```  \n  \n This seems harmless enough, but since we wanted a clean compilation with /W4  and /WX set, we simply commented out the variable name, leaving it for the sake of readability.  \n  \n```cpp  \nvirtual void OnSelectTab(int /*nTab*/) {};  \n```  \n  \n Other warnings we received were useful for general code cleanup. There are a number of implicit conversions from `int` or `unsigned int` to `WORD` (which is a typedef for `unsigned short`). These involve a possible loss of data. We added a cast to `WORD` in these cases.  \n  \n Another level 4 warning we got for this code was:  \n  \n```Output  \nwarning C4211: nonstandard extension used: redefined extern to static  \n```  \n  \n The problem occurs when a variable was first declared `extern`, then later declared `static`. The meaning of these two storage class specifiers is mutually exclusive, but this is allowed as a Microsoft extension. If you wanted the code to be portable to other compilers, or you wanted to compile it with /Za (ANSI compatibility), you would change the declarations to have matching storage class specifiers.  \n  \n##  <a name=\"porting_to_unicode\"></a> Step 11. Porting from MBCS to Unicode  \n Note that in the Windows world, when we say Unicode, we usually mean UTF-16. Other operating systems such as Linux use UTF-8, but Windows generally does not. Before taking the step to actually port MBCS code to UTF-16 Unicode, we might want to temporarily eliminate the warnings that MBCS is deprecated, in order to do other work or postpone the porting until a convenient time. The current code uses MBCS and to continue with that we need to download the MBCS version of MFC.  This rather large library was removed from the default Visual Studio installation, so it must be downloaded separately. See [MFC MBCS DLL Add-on](../mfc/mfc-mbcs-dll-add-on.md). Once you download this and restart Visual Studio, you can compile and link with the MBCS version of MFC, but to get rid of the warnings about MBCS, you should also add NO_WARN_MBCS_MFC_DEPRECATION to your list of predefined macros in the Preprocessor section of project properties, or at the beginning of your stdafx.h header file or other common header file.  \n  \n We now have some linker errors.  \n  \n```Output  \nfatal error LNK1181: cannot open input file 'mfc42d.lib'  \n```  \n  \n LNK1181 occurs because an outdated static library version of mfc is included on the linker input. This isn’t required anymore since we can link MFC dynamically, so we just need to remove all MFC static libraries from the Input property in the Linker section of the project properties. This project is also using the /NODEFAULTLIB option, and instead it lists all the library dependencies.  \n  \n```  \nmsvcrtd.lib;msvcirtd.lib;kernel32.lib;user32.lib;gdi32.lib;advapi32.lib;Debug\\SpyHk55.lib;%(AdditionalDependencies)  \n```  \n  \n Now let us actually update the old Multi-byte Character Set (MBCS) code to Unicode. Since this is a Windows application, intimately tied to the Windows desktop platform, we will port it to UTF-16 Unicode that Windows uses. If you are writing cross-platform code or porting a Windows application to another platform, you might want to consider porting to UTF-8, which is widely used on other operating systems.  \n  \n Porting to UTF-16 Unicode, we must decide whether we still want the option to compile to MBCS or not.  If we want to have the option to support MBCS, we should use the TCHAR macro as the character type, which resolves to either char or wchar_t, depending on whether _MBCS or _UNICODE is defined during compilation. Switching to TCHAR and the TCHAR versions of various APIs instead of wchar_t and its associated APIs means that you can get back to an MBCS version of your code simply by defining _MBCS macro instead of _UNICODE. In addition to TCHAR, a variety of TCHAR versions of such as widely used typedefs, macros, and functions exists. For example, LPCTSTR instead of LPCSTR, and so on. In the project properties dialog, under **Configuration Properties**, in the **General** section, change the **Character Set** property from **Use MBCS Character Set** to **Use Unicode Character Set**. This setting affects which macro is predefined during compilation. There is both a UNICODE macro and a _UNICODE macro. The project property affects both consistently. Windows headers use UNICODE where Visual C++ headers such as MFC use _UNICODE, but when one is defined, the other is always defined.  \n  \n A good [guide](http://msdn.microsoft.com/library/cc194801.aspx) to porting from MBCS to UTF-16 Unicode using TCHAR exists. We choose this route. First, we change the **Character Set** property to **Use Unicode Character Set** and rebuild the project.  \n  \n Some places in the code were already using `TCHAR`, apparently in anticipation of eventually supporting Unicode. Some were not. We searched for instances of `CHAR`, which is a typedef for char, and replaced most of them with TCHAR. Also, we looked for `sizeof (CHAR)`. Whenever we changed from `CHAR` to `TCHAR`, we usually had to change to `sizeof(TCHAR)` since this was often used to determine the number of characters in a string. Using the wrong type here does not produce a compiler error, so it's worth paying a bit of attention to this case.  \n  \n This type of error is very common just after switching to Unicode.  \n  \n```Output  \nerror C2664: 'int wsprintfW(LPWSTR,LPCWSTR,...)': cannot convert argument 1 from 'CHAR [16]' to 'LPWSTR'  \n```  \n  \n Here’s an example of code that produces this:  \n  \n```cpp  \nwsprintf(szTmp, \"%d.%2.2d.%4.4d\", rmj, rmm, rup);  \n```  \n  \n We put _T around the string literal to remove the error.  \n  \n```cpp  \nwsprintf(szTmp, _T(\"%d.%2.2d.%4.4d\"), rmj, rmm, rup);  \n```  \n  \n The _T macro has the effect of making a string literal compile as a char string or a wchar_t string, depending on the setting of MBCS or UNICODE. To replace all strings with _T in Visual Studio, first open the **Quick Replace** (Keyboard: Ctrl+F) box or the **Replace In Files** (Keyboard: Ctrl+Shift+H), then choose the **Use Regular Expressions** checkbox. Enter `((\\\".*?\\\")|('.+?'))` as the search text and `_T($1)` as the replacement text. If you already have the _T macro around some strings, this procedure will add it again, and it might also find cases where you don't want _T, such as when you use `#include`, so it's best to use **Replace Next** rather than **Replace All**.  \n  \n This particular function, [wsprintf](https://msdn.microsoft.com/library/windows/desktop/ms647550.aspx), is actually defined in the Windows headers, and the documentation for it recommends that it not be used, due to possible buffer overrun. No size is given for the `szTmp` buffer, so there is no way for the function to check that the buffer can hold all the data to be written to it. See the next section about porting to the Secure CRT, in which we fix other similar problems. We ended up replacing it with [_stprintf_s](../c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l.md).  \n  \n Another common error you’ll see in converting to Unicode is this.  \n  \n```Output  \nerror C2440: '=': cannot convert from 'char *' to 'TCHAR *'  \n```  \n  \n The code that produces it is as follows:  \n  \n```cpp  \n  \npParentNode->m_szText = new char[strTitle.GetLength() + 1];  \n_tcscpy(pParentNode->m_szText, strTitle);  \n  \n```  \n  \n Even though the _tcscpy function was used, which is the TCHAR strcpy function for copying a string, the buffer that was allocated was a char buffer. This is easily changed to TCHAR.  \n  \n```cpp  \n  \npParentNode->m_szText = new TCHAR[strTitle.GetLength() + 1];  \n_tcscpy(pParentNode->m_szText, strTitle);  \n  \n```  \n  \n Similarly, we changed `LPSTR` (Long Pointer to STRing) and `LPCSTR` (Long Pointer to Constant STRing) to `LPTSTR` (Long Pointer to TCHAR STRing) and `LPCTSTR` (Long Pointer to Constant TCHAR STRing) respectively, when warranted by a compiler error. We chose not to make such replacements by using global search and replace, because each situation had to be examined individually. In some cases, the char version is wanted, such as when processing certain Windows messages which use Windows structures that have the A suffix. In the Windows API, the suffix A means ASCII or ANSI (and also applies to MBCS), and the suffix W means wide characters, or UTF-16 Unicode. This naming pattern is used in the Windows headers, but we also followed it in the Spy++ code when we had to add a Unicode version of a function that was already defined in only an MBCS version.  \n  \n In some cases we had to replace a type to use a version that resolves correctly (WNDCLASS instead of WNDCLASSA for example).  \n  \n In many cases we had to use the generic version (macro) of a Win32 API like GetClassName (instead of GetClassNameA). In message handler switch statement, some messages are MBCS or Unicode specific, in those cases, we had to change the code to explicitly call the MBCS version, because we replaced the generically named functions with A and W specific functions, and added a macro for the generic name that resolves to the correct A or W name based on whether UNICODE is defined.  In many parts of the code, when we switched to define _UNICODE, the W version is now chosen even when the A version is what's wanted.  \n  \n There are a few places where special actions had to be taken. Any use of WideCharToMultiByte or MultiByteToWideChar might require a closer look. Here's one example where WideCharToMultiByte was being used.  \n  \n```cpp  \n  \nBOOL C3dDialogTemplate::GetFont(CString& strFace, WORD& nFontSize)  \n{  \nASSERT(m_hTemplate != NULL);  \n  \nDLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(m_hTemplate);  \nif ((pTemplate->style & DS_SETFONT) == 0)  \n{  \nGlobalUnlock(m_hTemplate);  \nreturn FALSE;  \n}  \n  \nBYTE* pb = GetFontSizeField(pTemplate);  \nnFontSize = *(WORD*)pb;  \npb += sizeof (WORD);  \nWideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pb, -1,  \nstrFace.GetBufferSetLength(LF_FACESIZE), LF_FACESIZE, NULL, NULL);  \nstrFace.ReleaseBuffer();  \nGlobalUnlock(m_hTemplate);  \nreturn TRUE;  \n}  \n  \n```  \n  \n To address this, we had to understand that the reason this was done was to copy a wide character string representing the name of a font into the internal buffer of a CString, strFace. This required slightly different code for multibyte CString strings as for wide character CString strings, so we added an #ifdef in this case.  \n  \n```cpp  \n  \n#ifdef _MBCS  \nWideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pb, -1,  \nstrFace.GetBufferSetLength(LF_FACESIZE), LF_FACESIZE, NULL, NULL);  \nstrFace.ReleaseBuffer();  \n#else  \nwcscpy(strFace.GetBufferSetLength(LF_FACESIZE), (LPCWSTR)pb);  \nstrFace.ReleaseBuffer();  \n#endif  \n  \n```  \n  \n Of course, instead of wcscpy we really should use wcscpy_s, the more secure version. The next section addresses this.  \n  \n As a check on our work, we should reset the Character Set to Use Multibyte Character Set and make sure that the code still compiles using MBCS as well as Unicode. Needless to say, a full test pass should be executed on the recompiled app after all these changes.  \n  \n In our work with this Spy++ solution, it took about two working days for an average C++ developer to convert the code to Unicode. That did not include the retesting time.  \n  \n##  <a name=\"porting_to_secure_crt\"></a> Step 12. Porting to use the Secure CRT  \n Porting the code to use the secure versions (the versions with the _s suffix) of CRT functions is next. In this case, the general strategy is to replace the function with the _s version and then, usually, add the required additional buffer size parameters. In many cases this is straightforward since the size is known. In other cases, where the size is not immediately available, it’s necessary to add additional parameters to the function that’s using the CRT function, or perhaps examine the usage of the destination buffer and see what the appropriate size limits are.  \n  \n Visual C++ provides a trick to make it easier to get code secure without adding as many size parameters, and that is by using the template overloads. Since these overloads are templates, they are only available when compiling as C++, not as C. Spyxxhk is a C project, so the trick won't work for that.  However, Spyxx is not and we can use the trick. The trick is to add a line like this in a place where it will be compiled in every file of the project, such as in stdafx.h:  \n  \n```cpp  \n#define _CRT_SECURE_TEMPLATE_OVERLOADS 1  \n```  \n  \n When you define that, whenever the buffer is an array, rather than a raw pointer, its size is inferred from the array type and that is used as the size parameter, without you having to supply it. That helps to cut down the complexity of rewriting the code. You still have to replace the function name with the _s version, but that can often be done by a search and replace operation.  \n  \n The return values of some functions changed. For example, _itoa_s (and _itow_s and the macro _itot_s) returns an error code (errno_t), rather than the string. So in those cases, you have to move the call to _itoa_s onto a separate line and replace it with the buffer's identifier.  \n  \n Some of the common cases: for memcpy, when switching to memcpy_s, we frequently added the size of the structure being copied to. Similarly, for most strings and buffers, the size of the array or buffer is easily determined from the declaration of the buffer or by finding where the buffer was originally allocated. For some situations, you need to determine how big of a buffer is actually available, and if that information is not available in the scope of the function that you’re modifying, it should be added as an additional parameter and the calling code should be modified to provide the information.  \n  \n With these techniques, it took about half a day to convert the code to use the secure CRT functions. If you choose not to the template overloads and to add the size parameters manually, it would probably take twice or three times more time.  \n  \n##  <a name=\"deprecated_forscope\"></a> Step 13. /Zc:forScope- is deprecated  \n Since Visual C++ 6.0, the compiler conforms to the current standard, which limits the scope of variables declared in a  loop to the scope of the loop. The compiler option [/Zc:forScope](../build/reference/zc-forscope-force-conformance-in-for-loop-scope.md) (**Force Conformance for Loop Scope** in the project properties) controls whether or not this is reported as an error. We should update our code to be conformant, and add declarations just outside the loop. To avoid making the code changes, you can change that setting in the Language section of the C++ project properties to **No (/Zc:forScope-)**. However, keep in mind that **/Zc:forScope-** might be removed in a future release of Visual C++, so eventually your code will need to change to conform to the standard.  \n  \n These issues are relatively easy to fix, but depending on your code, it might affect a lot of code. Here's a typical issue.  \n  \n```cpp  \n  \nint CPerfTextDataBase::NumStrings(LPCTSTR mszStrings) const  \n{  \nfor (int n = 0; mszStrings[0] != 0; n++)  \nmszStrings = _tcschr(mszStrings, 0) + 1;  \nreturn(n);  \n}  \n  \n```  \n  \n The above code produces the error:  \n  \n```Output  \n'n': undeclared identifier  \n```  \n  \n This occurs because the compiler has deprecated a compiler option that allowed code that no longer complies with the C++ standard. In the standard, declaring a variable inside a loop restricts its scope to the loop only, so the common practice of using a loop counter outside of the loop requires that the declaration of the counter also be moved outside the loop, as in the following revised code:  \n  \n```cpp  \n  \nint CPerfTextDataBase::NumStrings(LPCTSTR mszStrings) const  \n{  \nint n;  \nfor (n = 0; mszStrings[0] != 0; n++)  \nmszStrings = _tcschr(mszStrings, 0) + 1;  \nreturn(n);  \n}  \n  \n```  \n  \n## Summary  \n Porting Spy++ from the original Visual C++ 6.0 code to the latest compiler took about 20 hours of coding time over the course of about a week. We upgraded directly through eight releases of the product, but for larger projects, you might find it better to upgrade one release at a time. This might take longer, but at least you will be able to narrow down what version of the tools caused a particular error to occur.  \n  \n## See Also  \n [Porting and Upgrading: Examples and Case Studies](../porting/porting-and-upgrading-examples-and-case-studies.md)   \n [Previous case study: COM Spy](../porting/porting-guide-com-spy.md)"}