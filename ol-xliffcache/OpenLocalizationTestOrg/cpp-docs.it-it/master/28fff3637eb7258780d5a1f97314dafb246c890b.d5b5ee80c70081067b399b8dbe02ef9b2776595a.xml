{"nodes":[{"pos":[12,77],"content":"Constraints on Generic Type Parameters (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Constraints on Generic Type Parameters (C++-CLI) | Microsoft Docs","pos":[0,65]}]},{"content":"Constraints on Generic Type Parameters (C++/CLI)","pos":[666,714]},{"content":"In generic type or method declarations, you can qualify a type parameter with constraints.","pos":[715,805]},{"content":"A constraint is a requirement that types used as type arguments must satisfy.","pos":[806,883]},{"content":"For example, a constraint might be that the type argument must implement a certain interface or inherit from a specific class.","pos":[884,1010]},{"content":"Constraints are optional; not specifying a constraint on a parameter is equivalent to constraining that parameter to &lt;xref:System.Object&gt;.","pos":[1017,1155],"source":"Constraints are optional; not specifying a constraint on a parameter is equivalent to constraining that parameter to <xref:System.Object>."},{"content":"Syntax","pos":[1164,1170]},{"content":"Parameters","pos":[1239,1249]},{"content":"type-parameter","pos":[1254,1268]},{"content":"One of the type parameters, to be constrained.","pos":[1273,1319]},{"content":"constraint list","pos":[1327,1342]},{"content":"<bpt id=\"p1\"> *</bpt>constraint list<ept id=\"p1\">*</ept> is a comma-separated list of constraint specifications.","pos":[1346,1420],"source":" *constraint list* is a comma-separated list of constraint specifications."},{"content":"The list can include interfaces to be implemented by the type parameter.","pos":[1421,1493]},{"content":"The list can also include a class.","pos":[1500,1534]},{"content":"For the type argument to satisfy a base class constraint, it must be the same class as the constraint or derive from the constraint.","pos":[1535,1667]},{"content":"You can also specify <ph id=\"ph1\">`gcnew()`</ph> to indicate the type argument must have a public parameterless constructor; or <ph id=\"ph2\">`ref class`</ph> to indicate the type argument must be a reference type, including any class, interface, delegate, or array type; or <ph id=\"ph3\">`value class`</ph> to indicate the type argument must be a value type.","pos":[1674,1977],"source":"You can also specify `gcnew()` to indicate the type argument must have a public parameterless constructor; or `ref class` to indicate the type argument must be a reference type, including any class, interface, delegate, or array type; or `value class` to indicate the type argument must be a value type."},{"content":"Any value type except Nullable<ph id=\"ph1\">\\&lt;</ph>T&gt; can be specified.","pos":[1978,2030],"source":" Any value type except Nullable\\<T> can be specified."},{"content":"You can also specify a generic parameter as a constraint.","pos":[2037,2094]},{"content":"The type argument supplied for the type you are constraining must be or derive from the type of the constraint.","pos":[2095,2206]},{"content":"This is called a naked type constraint.","pos":[2207,2246]},{"content":"Remarks","pos":[2255,2262]},{"content":"The constraint clause consists of <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> followed by a type parameter, a colon (<bpt id=\"p2\">**</bpt>:<ept id=\"p2\">**</ept>), and the constraint, which specifies the nature of the restriction on the type parameter.","pos":[2266,2445],"source":"The constraint clause consists of **where** followed by a type parameter, a colon (**:**), and the constraint, which specifies the nature of the restriction on the type parameter."},{"content":"<bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> is a context-sensitive keyword; see <bpt id=\"p2\">[</bpt>Context-Sensitive Keywords<ept id=\"p2\">](../windows/context-sensitive-keywords-cpp-component-extensions.md)</ept> for more information.","pos":[2446,2609],"source":"**where** is a context-sensitive keyword; see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md) for more information."},{"content":"Separate multiple <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses with a space.","pos":[2610,2659],"source":" Separate multiple **where** clauses with a space."},{"content":"Constraints are applied to type parameters to place limitations on the types that can be used as arguments for a generic type or method.","pos":[2666,2802]},{"content":"Class and interface constraints specify that the argument types must be or inherit from a specified class or implement a specified interface.","pos":[2809,2950]},{"content":"The application of constraints to a generic type or method allows code in that type or method to take advantage of the known features of the constrained types.","pos":[2957,3116]},{"content":"For example, you can declare a generic class such that the type parameter implements the <bpt id=\"p1\">**</bpt>IComparable<ph id=\"ph1\">\\&lt;</ph>T&gt;<ept id=\"p1\">**</ept> interface:","pos":[3117,3236],"source":" For example, you can declare a generic class such that the type parameter implements the **IComparable\\<T>** interface:"},{"content":"This constraint requires that a type argument used for <ph id=\"ph1\">`T`</ph> implements <ph id=\"ph2\">`IComparable&lt;T&gt;`</ph> at compile time.","pos":[3414,3517],"source":"This constraint requires that a type argument used for `T` implements `IComparable<T>` at compile time."},{"content":"It also allows interface methods, such as <bpt id=\"p1\">**</bpt>CompareTo<ept id=\"p1\">**</ept>, to be called.","pos":[3518,3588],"source":" It also allows interface methods, such as **CompareTo**, to be called."},{"content":"No cast is needed on an instance of the type parameter to call interface methods.","pos":[3589,3670]},{"content":"Static methods in the type argument's class cannot be called through the type parameter; they can be called only through the actual named type.","pos":[3677,3820]},{"content":"A constraint cannot be a value type, including built-in types such as <ph id=\"ph1\">`int`</ph> or <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","pos":[3827,3917],"source":"A constraint cannot be a value type, including built-in types such as `int` or **double**."},{"content":"Since value types cannot have derived classes, only one class would ever be able to satisfy the constraint.","pos":[3918,4025]},{"content":"In that case, the generic can be rewritten with the type parameter replaced by the specific value type.","pos":[4026,4129]},{"content":"Constraints are required in some cases since the compiler will not allow the use of methods or other features of an unknown type unless the constraints imply that the unknown type supports the methods or interfaces.","pos":[4136,4351]},{"content":"Multiple constraints for the same type parameter can be specified in a comma-separated list","pos":[4358,4449]},{"content":"With multiple type parameters, use one <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause for each type parameter.","pos":[4684,4764],"source":"With multiple type parameters, use one **where** clause for each type parameter."},{"content":"For example:","pos":[4765,4777]},{"content":"To summarize, use constraints in your code according to the following rules:","pos":[5055,5131]},{"content":"If multiple constraints are listed, the constraints may be listed in any order.","pos":[5141,5220]},{"content":"Constraints can also be class types, such as abstract base classes.","pos":[5230,5297]},{"content":"However, constraints cannot be value types or sealed classes.","pos":[5298,5359]},{"content":"Constraints cannot themselves be type parameters, but they can involve the type parameters in an open constructed type.","pos":[5369,5488]},{"content":"For example:","pos":[5489,5501]},{"content":"Example","pos":[5789,5796]},{"content":"The following example demonstrates using constraints to call instance methods on type parameters.","pos":[5800,5897]},{"content":"Example","pos":[7140,7147]},{"content":"When a generic type parameter is used as a constraint, it is called a naked type constraint.","pos":[7151,7243]},{"content":"Naked type constraints are useful when a member function with its own type parameter needs to constrain that parameter to the type parameter of the containing type.","pos":[7244,7408]},{"content":"In the following example, T is a naked type constraint in the context of the Add method.","pos":[7415,7503]},{"content":"Naked type constraints can also be used in generic class definitions.","pos":[7510,7579]},{"content":"The usefulness of naked type constraints with generic classes is limited because the compiler can assume nothing about a naked type constraint except that it derives from &lt;xref:System.Object&gt;.","pos":[7580,7772],"source":" The usefulness of naked type constraints with generic classes is limited because the compiler can assume nothing about a naked type constraint except that it derives from <xref:System.Object>."},{"content":"Use naked type constraints on generic classes in scenarios in which you wish to enforce an inheritance relationship between two type parameters.","pos":[7773,7917]},{"content":"See Also","pos":[8202,8210]},{"content":"Generics","pos":[8215,8223]}],"content":"---\ntitle: \"Constraints on Generic Type Parameters (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"where\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"where keyword [C++]\"\n  - \"constraints, C++\"\nms.assetid: eb828cc9-684f-48a3-a898-b327700c0a63\ncaps.latest.revision: 25\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Constraints on Generic Type Parameters (C++/CLI)\nIn generic type or method declarations, you can qualify a type parameter with constraints. A constraint is a requirement that types used as type arguments must satisfy. For example, a constraint might be that the type argument must implement a certain interface or inherit from a specific class.  \n  \n Constraints are optional; not specifying a constraint on a parameter is equivalent to constraining that parameter to <xref:System.Object>.  \n  \n## Syntax  \n  \n```  \n  \nwhere type-parameter: constraint list  \n```  \n  \n#### Parameters  \n *type-parameter*  \n One of the type parameters, to be constrained.  \n  \n *constraint list*  \n *constraint list* is a comma-separated list of constraint specifications. The list can include interfaces to be implemented by the type parameter.  \n  \n The list can also include a class. For the type argument to satisfy a base class constraint, it must be the same class as the constraint or derive from the constraint.  \n  \n You can also specify `gcnew()` to indicate the type argument must have a public parameterless constructor; or `ref class` to indicate the type argument must be a reference type, including any class, interface, delegate, or array type; or `value class` to indicate the type argument must be a value type. Any value type except Nullable\\<T> can be specified.  \n  \n You can also specify a generic parameter as a constraint. The type argument supplied for the type you are constraining must be or derive from the type of the constraint. This is called a naked type constraint.  \n  \n## Remarks  \n The constraint clause consists of **where** followed by a type parameter, a colon (**:**), and the constraint, which specifies the nature of the restriction on the type parameter. **where** is a context-sensitive keyword; see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md) for more information. Separate multiple **where** clauses with a space.  \n  \n Constraints are applied to type parameters to place limitations on the types that can be used as arguments for a generic type or method.  \n  \n Class and interface constraints specify that the argument types must be or inherit from a specified class or implement a specified interface.  \n  \n The application of constraints to a generic type or method allows code in that type or method to take advantage of the known features of the constrained types. For example, you can declare a generic class such that the type parameter implements the **IComparable\\<T>** interface:  \n  \n```  \n// generics_constraints_1.cpp  \n// compile with: /c /clr  \nusing namespace System;  \ngeneric <typename T>  \nwhere T : IComparable<T>  \nref class List {};  \n```  \n  \n This constraint requires that a type argument used for `T` implements `IComparable<T>` at compile time. It also allows interface methods, such as **CompareTo**, to be called. No cast is needed on an instance of the type parameter to call interface methods.  \n  \n Static methods in the type argument's class cannot be called through the type parameter; they can be called only through the actual named type.  \n  \n A constraint cannot be a value type, including built-in types such as `int` or **double**. Since value types cannot have derived classes, only one class would ever be able to satisfy the constraint. In that case, the generic can be rewritten with the type parameter replaced by the specific value type.  \n  \n Constraints are required in some cases since the compiler will not allow the use of methods or other features of an unknown type unless the constraints imply that the unknown type supports the methods or interfaces.  \n  \n Multiple constraints for the same type parameter can be specified in a comma-separated list  \n  \n```  \n// generics_constraints_2.cpp  \n// compile with: /c /clr  \nusing namespace System;  \nusing namespace System::Collections::Generic;  \ngeneric <typename T>  \nwhere T : List<T>, IComparable<T>  \nref class List {};  \n```  \n  \n With multiple type parameters, use one **where** clause for each type parameter. For example:  \n  \n```  \n// generics_constraints_3.cpp  \n// compile with: /c /clr  \nusing namespace System;  \nusing namespace System::Collections::Generic;  \n  \ngeneric <typename K, typename V>  \n   where K: IComparable<K>  \n   where V: IComparable<K>  \nref class Dictionary {};  \n```  \n  \n To summarize, use constraints in your code according to the following rules:  \n  \n-   If multiple constraints are listed, the constraints may be listed in any order.  \n  \n-   Constraints can also be class types, such as abstract base classes. However, constraints cannot be value types or sealed classes.  \n  \n-   Constraints cannot themselves be type parameters, but they can involve the type parameters in an open constructed type. For example:  \n  \n    ```  \n    // generics_constraints_4.cpp  \n    // compile with: /c /clr  \n    generic <typename T>  \n    ref class G1 {};  \n  \n    generic <typename Type1, typename Type2>  \n    where Type1 : G1<Type2>   // OK, G1 takes one type parameter  \n    ref class G2{};  \n    ```  \n  \n## Example  \n The following example demonstrates using constraints to call instance methods on type parameters.  \n  \n```  \n// generics_constraints_5.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ninterface class IAge {  \n   int Age();  \n};  \n  \nref class MyClass {  \npublic:  \n   generic <class ItemType> where ItemType : IAge   \n   bool isSenior(ItemType item) {  \n      // Because of the constraint,  \n      // the Age method can be called on ItemType.  \n      if (item->Age() >= 65)   \n         return true;  \n      else  \n         return false;  \n   }  \n};  \n  \nref class Senior : IAge {  \npublic:  \n   virtual int Age() {  \n      return 70;  \n   }  \n};  \n  \nref class Adult: IAge {  \npublic:  \n   virtual int Age() {  \n      return 30;  \n   }  \n};  \n  \nint main() {  \n   MyClass^ ageGuess = gcnew MyClass();  \n   Adult^ parent = gcnew Adult();  \n   Senior^ grandfather = gcnew Senior();  \n  \n   if (ageGuess->isSenior<Adult^>(parent))  \n      Console::WriteLine(\"\\\"parent\\\" is a senior\");  \n   else  \n      Console::WriteLine(\"\\\"parent\\\" is not a senior\");  \n  \n   if (ageGuess->isSenior<Senior^>(grandfather))  \n      Console::WriteLine(\"\\\"grandfather\\\" is a senior\");  \n   else  \n      Console::WriteLine(\"\\\"grandfather\\\" is not a senior\");  \n}  \n```  \n  \n```Output  \n\"parent\" is not a senior  \n\"grandfather\" is a senior  \n```  \n  \n## Example  \n When a generic type parameter is used as a constraint, it is called a naked type constraint. Naked type constraints are useful when a member function with its own type parameter needs to constrain that parameter to the type parameter of the containing type.  \n  \n In the following example, T is a naked type constraint in the context of the Add method.  \n  \n Naked type constraints can also be used in generic class definitions. The usefulness of naked type constraints with generic classes is limited because the compiler can assume nothing about a naked type constraint except that it derives from <xref:System.Object>. Use naked type constraints on generic classes in scenarios in which you wish to enforce an inheritance relationship between two type parameters.  \n  \n```  \n// generics_constraints_6.cpp  \n// compile with: /clr /c  \ngeneric <class T>  \nref struct List {  \n   generic <class U>  \n   where U : T  \n   void Add(List<U> items)  {}  \n};  \n  \ngeneric <class A, class B, class C>  \nwhere A : C  \nref struct SampleClass {};  \n```  \n  \n## See Also  \n [Generics](../windows/generics-cpp-component-extensions.md)"}