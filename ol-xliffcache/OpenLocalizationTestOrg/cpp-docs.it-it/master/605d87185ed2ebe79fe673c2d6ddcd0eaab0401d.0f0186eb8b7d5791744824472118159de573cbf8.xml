{"nodes":[{"pos":[12,63],"content":"Boxing  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Boxing  (C++ Component Extensions) | Microsoft Docs","pos":[0,51]}]},{"content":"Boxing  (C++ Component Extensions)","pos":[602,636]},{"pos":[637,792],"content":"The Visual C++ compiler can convert value types to objects in a process called <bpt id=\"p1\">*</bpt>boxing<ept id=\"p1\">*</ept>, and convert objects to value types in a process called <bpt id=\"p2\">*</bpt>unboxing<ept id=\"p2\">*</ept>.","source":"The Visual C++ compiler can convert value types to objects in a process called *boxing*, and convert objects to value types in a process called *unboxing*."},{"content":"All Runtimes","pos":[801,813]},{"content":"(There are no remarks for this language feature that apply to all runtimes.)","pos":[817,893]},{"content":"Windows Runtime","pos":[902,917]},{"content":"supports a shorthand syntax for boxing value types and unboxing reference types.","pos":[994,1074]},{"content":"A value type is boxed when it is assigned to a variable of type <ph id=\"ph1\">`Object`</ph>.","pos":[1075,1148],"source":" A value type is boxed when it is assigned to a variable of type `Object`."},{"content":"An <ph id=\"ph1\">`Object`</ph> variable is unboxed when it is assigned to a value type variable and the unboxed type is specified in parentheses; that is, when the object variable is cast to a value type.","pos":[1149,1334],"source":" An `Object` variable is unboxed when it is assigned to a value type variable and the unboxed type is specified in parentheses; that is, when the object variable is cast to a value type."},{"content":"Requirements","pos":[1475,1487]},{"pos":[1491,1515],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Examples","pos":[1525,1533]},{"content":"The following code example boxes and unboxes a <ph id=\"ph1\">`DateTime`</ph> value.","pos":[1537,1601],"source":"The following code example boxes and unboxes a `DateTime` value."},{"content":"First, the example obtains a DateTime value that represents the current date and time and assigns it to a DateTime variable.","pos":[1602,1726]},{"content":"Then the DateTime is boxed by assigning it to an Object variable.","pos":[1727,1792]},{"content":"Finally, the boxed value is unboxed by assigning it to another DateTime variable.","pos":[1793,1874]},{"content":"To test the example, create a BlankApplication project, replace the BlankPage::OnNavigatedTo() method, and then specify breakpoints at the closing bracket and the assignment to variable str1.","pos":[1881,2072]},{"content":"When the example reaches the closing bracket, examine str1.","pos":[2073,2132]},{"pos":[3209,3315],"content":"For more information, see <bpt id=\"p1\">[</bpt>Boxing (C++/CX)<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/hh969554.aspx)</ept>.","source":"For more information, see [Boxing (C++/CX)](http://msdn.microsoft.com/library/windows/apps/hh969554.aspx)."},{"content":"Common Language Runtime","pos":[3324,3347]},{"content":"The Visual C++ compiler now boxes value types to &lt;xref:System.Object&gt;.","pos":[3351,3421],"source":"The Visual C++ compiler now boxes value types to <xref:System.Object>."},{"content":"This is possible because of a compiler-defined conversion to convert value types to &lt;xref:System.Object&gt;.","pos":[3423,3528],"source":"  This is possible because of a compiler-defined conversion to convert value types to <xref:System.Object>."},{"content":"Boxing and unboxing enable value types to be treated as objects.","pos":[3535,3599]},{"content":"Value types, including both struct types and built-in types such as int, can be converted to and from the type &lt;xref:System.Object&gt;.","pos":[3600,3732],"source":" Value types, including both struct types and built-in types such as int, can be converted to and from the type <xref:System.Object>."},{"content":"For more information, see:","pos":[3739,3765]},{"content":"How to: Explicitly Request Boxing","pos":[3776,3809]},{"content":"How to: Use gcnew to Create Value Types and Use Implicit Boxing","pos":[3868,3931]},{"content":"How to: Unbox","pos":[4020,4033]},{"content":"Standard Conversions and Implicit Boxing","pos":[4072,4112]},{"content":"Requirements","pos":[4178,4190]},{"pos":[4194,4219],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[4229,4237]},{"content":"Example","pos":[4243,4250]},{"content":"The following sample shows how implicit boxing works.","pos":[4259,4312]},{"content":"Output","pos":[6388,6394]},{"content":"See Also","pos":[6645,6653]},{"content":"Component Extensions for Runtime Platforms","pos":[6658,6700]}],"content":"---\ntitle: \"Boxing  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"boxing, Visual C++\"\nms.assetid: b5fd2c98-c578-4f83-8257-6dd663478665\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Boxing  (C++ Component Extensions)\nThe Visual C++ compiler can convert value types to objects in a process called *boxing*, and convert objects to value types in a process called *unboxing*.  \n  \n## All Runtimes  \n (There are no remarks for this language feature that apply to all runtimes.)  \n  \n## Windows Runtime  \n [!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)] supports a shorthand syntax for boxing value types and unboxing reference types. A value type is boxed when it is assigned to a variable of type `Object`. An `Object` variable is unboxed when it is assigned to a value type variable and the unboxed type is specified in parentheses; that is, when the object variable is cast to a value type.  \n  \n```  \n  \n  Platform::Object^  \n  object_variable  = value_variable;  \nvalue_variable = (value_type) object_variable;  \n  \n```  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n### Examples  \n The following code example boxes and unboxes a `DateTime` value. First, the example obtains a DateTime value that represents the current date and time and assigns it to a DateTime variable. Then the DateTime is boxed by assigning it to an Object variable. Finally, the boxed value is unboxed by assigning it to another DateTime variable.  \n  \n To test the example, create a BlankApplication project, replace the BlankPage::OnNavigatedTo() method, and then specify breakpoints at the closing bracket and the assignment to variable str1. When the example reaches the closing bracket, examine str1.  \n  \n```  \n  \nvoid BlankPage::OnNavigatedTo(NavigationEventArgs^ e)  \n{  \n    using namespace Windows::Globalization::DateTimeFormatting;  \n  \n    Windows::Foundation::DateTime dt, dtAnother;  \n    Platform::Object^ obj1;  \n  \n    Windows::Globalization::Calendar^ c =   \n        ref new Windows::Globalization::Calendar;  \n    c->SetToNow();  \n    dt = c->GetDateTime();  \n    auto dtf = ref new DateTimeFormatter(  \n                           YearFormat::Full,   \n                           MonthFormat::Numeric,   \n                           DayFormat::Default,   \n                           DayOfWeekFormat::None);  \n    String^ str1 = dtf->Format(dt);  \n    OutputDebugString(str1->Data());  \n    OutputDebugString(L\"\\r\\n\");  \n  \n    // Box the value type and assign to a reference type.  \n    obj1 = dt;  \n    // Unbox the reference type and assign to a value type.  \n    dtAnother = (Windows::Foundation::DateTime) obj1;  \n  \n    // Format the DateTime for display.  \n    String^ str2 = dtf->Format(dtAnother);  \n    OutputDebugString(str2->Data());  \n}  \n  \n```  \n  \n For more information, see [Boxing (C++/CX)](http://msdn.microsoft.com/library/windows/apps/hh969554.aspx).  \n  \n## Common Language Runtime  \n The Visual C++ compiler now boxes value types to <xref:System.Object>.  This is possible because of a compiler-defined conversion to convert value types to <xref:System.Object>.  \n  \n Boxing and unboxing enable value types to be treated as objects. Value types, including both struct types and built-in types such as int, can be converted to and from the type <xref:System.Object>.  \n  \n For more information, see:  \n  \n-   [How to: Explicitly Request Boxing](../dotnet/how-to-explicitly-request-boxing.md)  \n  \n-   [How to: Use gcnew to Create Value Types and Use Implicit Boxing](../dotnet/how-to-use-gcnew-to-create-value-types-and-use-implicit-boxing.md)  \n  \n-   [How to: Unbox](../dotnet/how-to-unbox.md)  \n  \n-   [Standard Conversions and Implicit Boxing](../dotnet/standard-conversions-and-implicit-boxing.md)  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following sample shows how implicit boxing works.  \n  \n```cpp  \n// vcmcppv2_explicit_boxing2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class A {  \npublic:  \n   void func(System::Object^ o){Console::WriteLine(\"in A\");}  \n};  \n  \nvalue class V {};  \n  \ninterface struct IFace {  \n   void func();  \n};  \n  \nvalue class V1 : public IFace {  \npublic:  \n   virtual void func() {  \n      Console::WriteLine(\"Interface function\");  \n   }  \n};  \n  \nvalue struct V2 {  \n   // conversion operator to System::Object  \n   static operator System::Object^(V2 v2) {  \n      Console::WriteLine(\"operator System::Object^\");  \n      return (V2^)v2;  \n   }  \n};  \n  \nvoid func1(System::Object^){Console::WriteLine(\"in void func1(System::Object^)\");}  \nvoid func1(V2^){Console::WriteLine(\"in func1(V2^)\");}  \n  \nvoid func2(System::ValueType^){Console::WriteLine(\"in func2(System::ValueType^)\");}  \nvoid func2(System::Object^){Console::WriteLine(\"in func2(System::Object^)\");}  \n  \nint main() {  \n   // example 1 simple implicit boxing  \n   Int32^ bi = 1;  \n   Console::WriteLine(bi);  \n  \n   // example 2 calling a member with implicit boxing  \n   Int32 n = 10;  \n   Console::WriteLine(\"xx = {0}\", n.ToString());  \n  \n   // example 3 implicit boxing for function calls  \n   A^ a = gcnew A;  \n   a->func(n);  \n  \n   // example 4 implicit boxing for WriteLine function call  \n   V v;  \n   Console::WriteLine(\"Class {0} passed using implicit boxing\", v);  \n   Console::WriteLine(\"Class {0} passed with forced boxing\", (V^)(v));   // force boxing  \n  \n   // example 5 casting to a base with implicit boxing  \n   V1 v1;  \n   IFace ^ iface = v1;  \n   iface->func();  \n  \n   // example 6 user-defined conversion preferred over implicit boxing for function-call parameter matching  \n   V2 v2;  \n   func1(v2);   // user defined conversion from V2 to System::Object preferred over implicit boxing  \n                // Will call void func1(System::Object^);  \n  \n   func2(v2);   // OK: Calls \"static V2::operator System::Object^(V2 v2)\"  \n   func2((V2^)v2);   // Using explicit boxing: calls func2(System::ValueType^)  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n1  \n  \nxx = 10  \n  \nin A  \n  \nClass V passed using implicit boxing  \n  \nClass V passed with forced boxing  \n  \nInterface function  \n  \nin func1(V2^)  \n  \nin func2(System::ValueType^)  \n  \nin func2(System::ValueType^)  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}