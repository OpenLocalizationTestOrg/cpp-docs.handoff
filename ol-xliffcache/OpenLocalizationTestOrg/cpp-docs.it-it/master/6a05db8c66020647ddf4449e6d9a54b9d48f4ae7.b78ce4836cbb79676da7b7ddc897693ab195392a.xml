{"nodes":[{"pos":[12,71],"content":"Errors and Exception Handling (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Errors and Exception Handling (Modern C++) | Microsoft Docs","pos":[0,59]}]},{"content":"Errors and Exception Handling (Modern C++)","pos":[552,594]},{"content":"In modern C++, in most scenarios, the preferred way to report and handle both logic errors and runtime errors is to use exceptions.","pos":[595,726]},{"content":"This is especially true when the stack might contain several function calls between the function that detects the error and the function that has the context to know how to handle it.","pos":[727,910]},{"content":"Exceptions provide a formal, well-defined way for code that detects errors to pass the information up the call stack.","pos":[911,1028]},{"content":"Program errors are generally divided into two categories: logic errors that are caused by programming mistakes, for example, an \"index out of range\" error, and runtime errors that are beyond the control of programmer, for example, a \"network service unavailable\" error.","pos":[1035,1304]},{"content":"In C-style programming and in COM, error reporting is managed either by returning a value that represents an error code or a status code for a particular function, or by setting a global variable that the caller may optionally retrieve after every function call to see whether errors were reported.","pos":[1305,1603]},{"content":"For example, COM programming uses the HRESULT return value to communicate errors to the caller, and the Win32 API has the GetLastError function to retrieve the last error that was reported by the call stack.","pos":[1604,1811]},{"content":"In both of these cases, it's up to the caller to recognize the code and respond to it appropriately.","pos":[1812,1912]},{"content":"If the caller doesn't explicitly handle the error code, the program might crash without warning, or continue to execute with bad data and produce incorrect results.","pos":[1913,2077]},{"content":"Exceptions are preferred in modern C++ for the following reasons:","pos":[2084,2149]},{"content":"An exception forces calling code to recognize an error condition and handle it.","pos":[2159,2238]},{"content":"Unhandled exceptions stop program execution.","pos":[2239,2283]},{"content":"An exception jumps to the point in the call stack that can handle the error.","pos":[2293,2369]},{"content":"Intermediate functions can let the exception propagate.","pos":[2370,2425]},{"content":"They do not have to coordinate with other layers.","pos":[2426,2475]},{"content":"The exception stack-unwinding mechanism destroys all objects in scope according to well-defined rules after an exception is thrown.","pos":[2485,2616]},{"content":"An exception enables a clean separation between the code that detects the error and the code that handles the error.","pos":[2626,2742]},{"content":"The following simplified example shows the necessary syntax for throwing and catching exceptions in C++.","pos":[2749,2853]},{"content":"Exceptions in C++ resemble those in languages such as C# and Java.","pos":[3398,3464]},{"content":"In the <ph id=\"ph1\">`try`</ph> block, if an exception is <bpt id=\"p1\">*</bpt>thrown<ept id=\"p1\">*</ept> it will be <bpt id=\"p2\">*</bpt>caught<ept id=\"p2\">*</ept> by the first associated <ph id=\"ph2\">`catch`</ph> block whose type matches that of the exception.","pos":[3465,3612],"source":" In the `try` block, if an exception is *thrown* it will be *caught* by the first associated `catch` block whose type matches that of the exception."},{"content":"In other words, execution jumps from the <ph id=\"ph1\">`throw`</ph> statement to the <ph id=\"ph2\">`catch`</ph> statement.","pos":[3613,3697],"source":" In other words, execution jumps from the `throw` statement to the `catch` statement."},{"content":"If no usable catch block is found, <ph id=\"ph1\">`std::terminate`</ph> is invoked and the program exits.","pos":[3698,3783],"source":" If no usable catch block is found, `std::terminate` is invoked and the program exits."},{"content":"In C++, any type may be thrown; however, we recommend that you throw a type that derives directly or indirectly from <ph id=\"ph1\">`std::exception`</ph>.","pos":[3784,3918],"source":" In C++, any type may be thrown; however, we recommend that you throw a type that derives directly or indirectly from `std::exception`."},{"content":"In the previous example, the exception type, <bpt id=\"p1\">[</bpt>invalid_argument<ept id=\"p1\">](../standard-library/invalid-argument-class.md)</ept>, is defined in the standard library in the <bpt id=\"p2\">[</bpt><ph id=\"ph1\">\\&lt;</ph>stdexcept&gt;<ept id=\"p2\">](../standard-library/stdexcept.md)</ept> header file.","pos":[3919,4134],"source":" In the previous example, the exception type, [invalid_argument](../standard-library/invalid-argument-class.md), is defined in the standard library in the [\\<stdexcept>](../standard-library/stdexcept.md) header file."},{"content":"C++ does not provide, and does not require, a <ph id=\"ph1\">`finally`</ph> block to make sure that all resources are released if an exception is thrown.","pos":[4135,4268],"source":" C++ does not provide, and does not require, a `finally` block to make sure that all resources are released if an exception is thrown."},{"content":"The resource acquisition is initialization (RAII) idiom, which uses smart pointers, provides the required functionality for resource cleanup.","pos":[4269,4410]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Design for Exception Safety<ept id=\"p1\">](../cpp/how-to-design-for-exception-safety.md)</ept>.","pos":[4411,4521],"source":" For more information, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md)."},{"content":"For information about the C++ stack-unwinding mechanism, see <bpt id=\"p1\">[</bpt>Exceptions and Stack Unwinding<ept id=\"p1\">](../cpp/exceptions-and-stack-unwinding-in-cpp.md)</ept>.","pos":[4522,4665],"source":" For information about the C++ stack-unwinding mechanism, see [Exceptions and Stack Unwinding](../cpp/exceptions-and-stack-unwinding-in-cpp.md)."},{"content":"Basic guidelines","pos":[4674,4690]},{"content":"Robust error handling is challenging in any programming language.","pos":[4694,4759]},{"content":"Although exceptions provide several features that support good error handling, they can't do all the work for you.","pos":[4760,4874]},{"content":"To realize the benefits of the exception mechanism, keep exceptions in mind as you design your code.","pos":[4875,4975]},{"content":"Use asserts to check for errors that should never occur.","pos":[4985,5041]},{"content":"Use exceptions to check for errors that might occur, for example, errors in input validation on parameters of public functions.","pos":[5042,5169]},{"content":"For more information, see the section titled <bpt id=\"p1\">**</bpt>Exceptions vs. Assertions<ept id=\"p1\">**</ept>.","pos":[5170,5245],"source":" For more information, see the section titled **Exceptions vs. Assertions**."},{"content":"Use exceptions when the code that handles the error might be separated from the code that detects the error by one or more intervening function calls.","pos":[5255,5405]},{"content":"Consider whether to use error codes instead in performance-critical loops when code that handles the error is tightly-coupled to the code that detects it.","pos":[5406,5560]},{"content":"For every function that might throw or propagate an exception, provide one of the three exception guarantees: the strong guarantee, the basic guarantee, or the nothrow (noexcept) guarantee.","pos":[5569,5758]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Design for Exception Safety<ept id=\"p1\">](../cpp/how-to-design-for-exception-safety.md)</ept>.","pos":[5759,5869],"source":" For more information, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md)."},{"content":"Throw exceptions by value, catch them by reference.","pos":[5879,5930]},{"content":"Donâ€™t catch what you can't handle.","pos":[5931,5965]},{"content":"Don't use exception specifications, which are deprecated in C++11.","pos":[5974,6040]},{"content":"For more information, see the section titled <bpt id=\"p1\">**</bpt>Exception specifications and noexcept<ept id=\"p1\">**</ept>.","pos":[6041,6128],"source":" For more information, see the section titled **Exception specifications and noexcept**."},{"content":"Use standard library exception types when they apply.","pos":[6138,6191]},{"content":"Derive custom exception types from the <bpt id=\"p1\">[</bpt>exception Class<ept id=\"p1\">](../standard-library/exception-class.md)</ept> hierarchy.","pos":[6192,6299],"source":" Derive custom exception types from the [exception Class](../standard-library/exception-class.md) hierarchy."},{"content":"Don't allow exceptions to escape from destructors or memory-deallocation functions.","pos":[6309,6392]},{"content":"Exceptions and performance","pos":[6401,6427]},{"content":"The exception mechanism has a very minimal performance cost if no exception is thrown.","pos":[6431,6517]},{"content":"If an exception is thrown, the cost of the stack traversal and unwinding is roughly comparable to the cost of a function call.","pos":[6518,6644]},{"content":"Additional data structures are required to track the call stack after a <ph id=\"ph1\">`try`</ph> block is entered, and additional instructions are required to unwind the stack if an exception is thrown.","pos":[6645,6828],"source":" Additional data structures are required to track the call stack after a `try` block is entered, and additional instructions are required to unwind the stack if an exception is thrown."},{"content":"However, in most scenarios, the cost in performance and memory footprint is not significant.","pos":[6829,6921]},{"content":"The adverse effect of exceptions on performance is likely to be significant only on very memory-constrained systems, or in performance-critical loops where an error is likely to occur regularly and the code to handle it is tightly coupled to the code that reports it.","pos":[6922,7189]},{"content":"In any case, it's impossible to know the actual cost of exceptions without profiling and measuring.","pos":[7190,7289]},{"content":"Even in those rare cases when the cost is significant, you can weigh it against the increased correctness, easier maintainability, and other advantages that are provided by a well-designed exception policy.","pos":[7290,7496]},{"content":"Exceptions vs. assertions","pos":[7505,7530]},{"content":"Exceptions and asserts are two distinct mechanisms for detecting run-time errors in a program.","pos":[7534,7628]},{"content":"Use asserts to test for conditions during development that should never be true if all your code is correct.","pos":[7629,7737]},{"content":"There is no point in handling such an error by using an exception because the error indicates that something in the code has to be fixed, and doesn't represent a condition that the program has to recover from at run time.","pos":[7738,7959]},{"content":"An assert stops execution at the statement so that you can inspect the program state in the debugger; an exception continues execution from the first appropriate catch handler.","pos":[7960,8136]},{"content":"Use exceptions to check error conditions that might occur at run time even if your code is correct, for example, \"file not found\" or \"out of memory.\"","pos":[8137,8286]},{"content":"You might want to recover from these conditions, even if the recovery just outputs a message to a log and ends the program.","pos":[8287,8410]},{"content":"Always check arguments to public functions by using exceptions.","pos":[8411,8474]},{"content":"Even if your function is error-free, you might not have complete control over arguments that a user might pass to it.","pos":[8475,8592]},{"content":"C++ exceptions versus Windows SEH exceptions","pos":[8601,8645]},{"content":"Both C and C++ programs can use the structured exception handling (SEH) mechanism in the Windows operating system.","pos":[8649,8763]},{"content":"The concepts in SEH resemble those in C++ exceptions, except that SEH uses the <ph id=\"ph1\">`__try`</ph>, <ph id=\"ph2\">`__except`</ph>, and <ph id=\"ph3\">`__finally`</ph> constructs instead of <ph id=\"ph4\">`try`</ph> and <ph id=\"ph5\">`catch`</ph>.","pos":[8764,8920],"source":" The concepts in SEH resemble those in C++ exceptions, except that SEH uses the `__try`, `__except`, and `__finally` constructs instead of `try` and `catch`."},{"content":"In Visual C++, C++ exceptions are implemented for SEH.","pos":[8921,8975]},{"content":"However, when you write C++ code, use the C++ exception syntax.","pos":[8976,9039]},{"pos":[9046,9169],"content":"For more information about SEH, see <bpt id=\"p1\">[</bpt>Structured Exception Handling (C/C++)<ept id=\"p1\">](../cpp/structured-exception-handling-c-cpp.md)</ept>.","source":"For more information about SEH, see [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)."},{"content":"Exception specifications and noexcept","pos":[9178,9215]},{"content":"Exception specifications were introduced in C++ as a way to specify the exceptions that a function might throw.","pos":[9219,9330]},{"content":"However, exception specifications proved problematic in practice, and are deprecated in the C++11 draft standard.","pos":[9331,9444]},{"content":"We recommend that you do not use exception specifications except for <ph id=\"ph1\">`throw()`</ph>, which indicates that the exception allows no exceptions to escape.","pos":[9445,9591],"source":" We recommend that you do not use exception specifications except for `throw()`, which indicates that the exception allows no exceptions to escape."},{"content":"If you must use exception specifications of the type <ph id=\"ph1\">`throw(`</ph><bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept><ph id=\"ph2\">`)`</ph>, be aware that <ph id=\"ph3\">[!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)]</ph> departs from the standard in certain ways.","pos":[9592,9771],"source":" If you must use exception specifications of the type `throw(`*type*`)`, be aware that [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] departs from the standard in certain ways."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Specifications (throw)<ept id=\"p1\">](../cpp/exception-specifications-throw-cpp.md)</ept>.","pos":[9772,9879],"source":" For more information, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md)."},{"content":"The <ph id=\"ph1\">`noexcept`</ph> specifier is introduced in C++11 as the preferred alternative to <ph id=\"ph2\">`throw()`</ph>.","pos":[9880,9970],"source":" The `noexcept` specifier is introduced in C++11 as the preferred alternative to `throw()`."},{"content":"See Also","pos":[9979,9987]},{"content":"How to: Interface Between Exceptional and Non-Exceptional Code","pos":[9992,10054]},{"content":"Welcome Back to C++","pos":[10134,10153]},{"content":"C++ Language Reference","pos":[10202,10224]},{"content":"C++ Standard Library","pos":[10265,10285]}],"content":"---\ntitle: \"Errors and Exception Handling (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7\ncaps.latest.revision: 19\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Errors and Exception Handling (Modern C++)\nIn modern C++, in most scenarios, the preferred way to report and handle both logic errors and runtime errors is to use exceptions. This is especially true when the stack might contain several function calls between the function that detects the error and the function that has the context to know how to handle it. Exceptions provide a formal, well-defined way for code that detects errors to pass the information up the call stack.  \n  \n Program errors are generally divided into two categories: logic errors that are caused by programming mistakes, for example, an \"index out of range\" error, and runtime errors that are beyond the control of programmer, for example, a \"network service unavailable\" error. In C-style programming and in COM, error reporting is managed either by returning a value that represents an error code or a status code for a particular function, or by setting a global variable that the caller may optionally retrieve after every function call to see whether errors were reported. For example, COM programming uses the HRESULT return value to communicate errors to the caller, and the Win32 API has the GetLastError function to retrieve the last error that was reported by the call stack. In both of these cases, it's up to the caller to recognize the code and respond to it appropriately. If the caller doesn't explicitly handle the error code, the program might crash without warning, or continue to execute with bad data and produce incorrect results.  \n  \n Exceptions are preferred in modern C++ for the following reasons:  \n  \n-   An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.  \n  \n-   An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They do not have to coordinate with other layers.  \n  \n-   The exception stack-unwinding mechanism destroys all objects in scope according to well-defined rules after an exception is thrown.  \n  \n-   An exception enables a clean separation between the code that detects the error and the code that handles the error.  \n  \n The following simplified example shows the necessary syntax for throwing and catching exceptions in C++.  \n  \n```cpp  \n  \n#include <stdexcept>  \n#include <limits>  \n#include <iostream>  \n  \nusing namespace std;  \nclass MyClass  \n{  \npublic:  \n   void MyFunc(char c)  \n   {  \n      if(c < numeric_limits<char>::max())  \n         throw invalid_argument(\"MyFunc argument too large.\");  \n      //...  \n   }  \n};  \n  \nint main()  \n{  \n   try  \n   {  \n      MyFunc(256); //cause an exception to throw  \n   }  \n  \n   catch(invalid_argument& e)  \n   {  \n      cerr << e.what() << endl;  \n      return -1;  \n   }  \n   //...  \n   return 0;  \n}  \n  \n```  \n  \n Exceptions in C++ resemble those in languages such as C# and Java. In the `try` block, if an exception is *thrown* it will be *caught* by the first associated `catch` block whose type matches that of the exception. In other words, execution jumps from the `throw` statement to the `catch` statement. If no usable catch block is found, `std::terminate` is invoked and the program exits. In C++, any type may be thrown; however, we recommend that you throw a type that derives directly or indirectly from `std::exception`. In the previous example, the exception type, [invalid_argument](../standard-library/invalid-argument-class.md), is defined in the standard library in the [\\<stdexcept>](../standard-library/stdexcept.md) header file. C++ does not provide, and does not require, a `finally` block to make sure that all resources are released if an exception is thrown. The resource acquisition is initialization (RAII) idiom, which uses smart pointers, provides the required functionality for resource cleanup. For more information, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md). For information about the C++ stack-unwinding mechanism, see [Exceptions and Stack Unwinding](../cpp/exceptions-and-stack-unwinding-in-cpp.md).  \n  \n## Basic guidelines  \n Robust error handling is challenging in any programming language. Although exceptions provide several features that support good error handling, they can't do all the work for you. To realize the benefits of the exception mechanism, keep exceptions in mind as you design your code.  \n  \n-   Use asserts to check for errors that should never occur. Use exceptions to check for errors that might occur, for example, errors in input validation on parameters of public functions. For more information, see the section titled **Exceptions vs. Assertions**.  \n  \n-   Use exceptions when the code that handles the error might be separated from the code that detects the error by one or more intervening function calls. Consider whether to use error codes instead in performance-critical loops when code that handles the error is tightly-coupled to the code that detects it. \n  \n-   For every function that might throw or propagate an exception, provide one of the three exception guarantees: the strong guarantee, the basic guarantee, or the nothrow (noexcept) guarantee. For more information, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md).  \n  \n-   Throw exceptions by value, catch them by reference. Donâ€™t catch what you can't handle. \n  \n-   Don't use exception specifications, which are deprecated in C++11. For more information, see the section titled **Exception specifications and noexcept**.  \n  \n-   Use standard library exception types when they apply. Derive custom exception types from the [exception Class](../standard-library/exception-class.md) hierarchy.  \n  \n-   Don't allow exceptions to escape from destructors or memory-deallocation functions.  \n  \n## Exceptions and performance  \n The exception mechanism has a very minimal performance cost if no exception is thrown. If an exception is thrown, the cost of the stack traversal and unwinding is roughly comparable to the cost of a function call. Additional data structures are required to track the call stack after a `try` block is entered, and additional instructions are required to unwind the stack if an exception is thrown. However, in most scenarios, the cost in performance and memory footprint is not significant. The adverse effect of exceptions on performance is likely to be significant only on very memory-constrained systems, or in performance-critical loops where an error is likely to occur regularly and the code to handle it is tightly coupled to the code that reports it. In any case, it's impossible to know the actual cost of exceptions without profiling and measuring. Even in those rare cases when the cost is significant, you can weigh it against the increased correctness, easier maintainability, and other advantages that are provided by a well-designed exception policy.  \n  \n## Exceptions vs. assertions  \n Exceptions and asserts are two distinct mechanisms for detecting run-time errors in a program. Use asserts to test for conditions during development that should never be true if all your code is correct. There is no point in handling such an error by using an exception because the error indicates that something in the code has to be fixed, and doesn't represent a condition that the program has to recover from at run time. An assert stops execution at the statement so that you can inspect the program state in the debugger; an exception continues execution from the first appropriate catch handler. Use exceptions to check error conditions that might occur at run time even if your code is correct, for example, \"file not found\" or \"out of memory.\" You might want to recover from these conditions, even if the recovery just outputs a message to a log and ends the program. Always check arguments to public functions by using exceptions. Even if your function is error-free, you might not have complete control over arguments that a user might pass to it.  \n  \n## C++ exceptions versus Windows SEH exceptions  \n Both C and C++ programs can use the structured exception handling (SEH) mechanism in the Windows operating system. The concepts in SEH resemble those in C++ exceptions, except that SEH uses the `__try`, `__except`, and `__finally` constructs instead of `try` and `catch`. In Visual C++, C++ exceptions are implemented for SEH. However, when you write C++ code, use the C++ exception syntax.  \n  \n For more information about SEH, see [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md).  \n  \n## Exception specifications and noexcept  \n Exception specifications were introduced in C++ as a way to specify the exceptions that a function might throw. However, exception specifications proved problematic in practice, and are deprecated in the C++11 draft standard. We recommend that you do not use exception specifications except for `throw()`, which indicates that the exception allows no exceptions to escape. If you must use exception specifications of the type `throw(`*type*`)`, be aware that [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] departs from the standard in certain ways. For more information, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md). The `noexcept` specifier is introduced in C++11 as the preferred alternative to `throw()`.  \n  \n## See Also  \n [How to: Interface Between Exceptional and Non-Exceptional Code](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)   \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}