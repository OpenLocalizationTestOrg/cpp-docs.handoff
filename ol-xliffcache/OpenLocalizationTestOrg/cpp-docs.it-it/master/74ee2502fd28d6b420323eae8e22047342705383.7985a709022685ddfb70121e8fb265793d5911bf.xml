{"nodes":[{"pos":[12,60],"content":"Using Operators in __asm Blocks | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using Operators in __asm Blocks | Microsoft Docs","pos":[0,48]}]},{"content":"Using Operators in __asm Blocks","pos":[762,793]},{"content":"Microsoft Specific","pos":[797,815]},{"content":"An <ph id=\"ph1\">`__asm`</ph> block cannot use C or C++ specific operators, such as the <bpt id=\"p1\">**</bpt><ph id=\"ph2\">&lt;&lt;</ph><ept id=\"p1\">**</ept> operator.","pos":[819,904],"source":"An `__asm` block cannot use C or C++ specific operators, such as the **<<** operator."},{"content":"However, operators shared by C and MASM, such as the <ph id=\"ph1\">\\*</ph> operator, are interpreted as assembly-language operators.","pos":[905,1018],"source":" However, operators shared by C and MASM, such as the \\* operator, are interpreted as assembly-language operators."},{"content":"For instance, outside an <ph id=\"ph1\">`__asm`</ph> block, square brackets (<bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept>) are interpreted as enclosing array subscripts, which C automatically scales to the size of an element in the array.","pos":[1019,1200],"source":" For instance, outside an `__asm` block, square brackets (**[ ]**) are interpreted as enclosing array subscripts, which C automatically scales to the size of an element in the array."},{"content":"Inside an <ph id=\"ph1\">`__asm`</ph> block, they are seen as the MASM index operator, which yields an unscaled byte offset from any data object or label (not just an array).","pos":[1201,1355],"source":" Inside an `__asm` block, they are seen as the MASM index operator, which yields an unscaled byte offset from any data object or label (not just an array)."},{"content":"The following code illustrates the difference:","pos":[1356,1402]},{"content":"The first reference to <ph id=\"ph1\">`array`</ph> is not scaled, but the second is.","pos":[1567,1631],"source":"The first reference to `array` is not scaled, but the second is."},{"content":"Note that you can use the <bpt id=\"p1\">**</bpt>TYPE<ept id=\"p1\">**</ept> operator to achieve scaling based on a constant.","pos":[1632,1715],"source":" Note that you can use the **TYPE** operator to achieve scaling based on a constant."},{"content":"For example, the following statements are equivalent:","pos":[1716,1769]},{"content":"END Microsoft Specific","pos":[1917,1939]},{"content":"See Also","pos":[1950,1958]},{"content":"Using C or C++ in __asm Blocks","pos":[1963,1993]}],"content":"---\ntitle: \"Using Operators in __asm Blocks | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"brackets [ ]\"\n  - \"brackets [ ], __asm blocks\"\n  - \"__asm keyword [C++], operators\"\n  - \"square brackets [ ], __asm blocks\"\n  - \"operators [C++], using in __asm blocks\"\n  - \"square brackets [ ]\"\nms.assetid: a26ccfd4-40ae-4a61-952f-c417982aa8dd\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using Operators in __asm Blocks\n## Microsoft Specific  \n An `__asm` block cannot use C or C++ specific operators, such as the **<<** operator. However, operators shared by C and MASM, such as the \\* operator, are interpreted as assembly-language operators. For instance, outside an `__asm` block, square brackets (**[ ]**) are interpreted as enclosing array subscripts, which C automatically scales to the size of an element in the array. Inside an `__asm` block, they are seen as the MASM index operator, which yields an unscaled byte offset from any data object or label (not just an array). The following code illustrates the difference:  \n  \n```  \nint array[10];  \n  \n__asm mov array[6], bx ;  Store BX at array+6 (not scaled)  \n  \narray[6] = 0;         /* Store 0 at array+24 (scaled) */  \n```  \n  \n The first reference to `array` is not scaled, but the second is. Note that you can use the **TYPE** operator to achieve scaling based on a constant. For example, the following statements are equivalent:  \n  \n```  \n__asm mov array[6 * TYPE int], 0 ; Store 0 at array + 24  \n  \narray[6] = 0;                   /* Store 0 at array + 24 */  \n```  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Using C or C++ in __asm Blocks](../../assembler/inline/using-c-or-cpp-in-asm-blocks.md)"}