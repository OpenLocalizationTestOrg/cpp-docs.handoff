{"nodes":[{"pos":[12,78],"content":"How to: Hold Object Reference in Unmanaged Memory | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Hold Object Reference in Unmanaged Memory | Microsoft Docs","pos":[0,66]}]},{"content":"How to: Hold Object Reference in Unmanaged Memory","pos":[802,851]},{"content":"You can use gcroot.h, which wraps &lt;xref:System.Runtime.InteropServices.GCHandle&gt;, to hold a CLR object reference in unmanaged memory.","pos":[852,985],"source":"You can use gcroot.h, which wraps <xref:System.Runtime.InteropServices.GCHandle>, to hold a CLR object reference in unmanaged memory."},{"content":"Alternatively, you can use <ph id=\"ph1\">`GCHandle`</ph> directly.","pos":[986,1033],"source":" Alternatively, you can use `GCHandle` directly."},{"content":"Example","pos":[1042,1049]},{"content":"Example","pos":[1654,1661]},{"content":"gives you a means to hold a managed object reference in unmanaged memory.","pos":[1676,1749]},{"content":"You use the &lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%2A&gt; method to create an opaque handle to a managed object and &lt;xref:System.Runtime.InteropServices.GCHandle.Free%2A&gt; to release it.","pos":[1751,1946],"source":"  You use the <xref:System.Runtime.InteropServices.GCHandle.Alloc%2A> method to create an opaque handle to a managed object and <xref:System.Runtime.InteropServices.GCHandle.Free%2A> to release it."},{"content":"Also, the &lt;xref:System.Runtime.InteropServices.GCHandle.Target%2A&gt; method allows you to obtain the object reference back from the handle in managed code.","pos":[1947,2100],"source":" Also, the <xref:System.Runtime.InteropServices.GCHandle.Target%2A> method allows you to obtain the object reference back from the handle in managed code."},{"content":"See Also","pos":[2918,2926]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[2931,2967]}],"content":"---\ntitle: \"How to: Hold Object Reference in Unmanaged Memory | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"object references, in native functions\"\n  - \"objects [C++], reference in native functions\"\n  - \"references, to objects in native functions\"\n  - \"gcroot keyword [C++], object reference in native function\"\nms.assetid: a61eb8ce-3982-477d-8d3d-2173fd57166d\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Hold Object Reference in Unmanaged Memory\nYou can use gcroot.h, which wraps <xref:System.Runtime.InteropServices.GCHandle>, to hold a CLR object reference in unmanaged memory. Alternatively, you can use `GCHandle` directly.  \n  \n## Example  \n  \n```  \n// hold_object_reference.cpp  \n// compile with: /clr  \n#include \"gcroot.h\"  \nusing namespace System;  \n  \n#pragma managed  \nclass StringWrapper {  \n  \nprivate:  \n   gcroot<String ^ > x;  \n  \npublic:  \n   StringWrapper() {  \n      String ^ str = gcnew String(\"ManagedString\");  \n      x = str;  \n   }  \n  \n   void PrintString() {  \n      String ^ targetStr = x;  \n      Console::WriteLine(\"StringWrapper::x == {0}\", targetStr);  \n   }  \n};  \n#pragma unmanaged  \nint main() {  \n   StringWrapper s;  \n   s.PrintString();  \n}  \n```  \n  \n```Output  \nStringWrapper::x == ManagedString  \n```  \n  \n## Example  \n `GCHandle` gives you a means to hold a managed object reference in unmanaged memory.  You use the <xref:System.Runtime.InteropServices.GCHandle.Alloc%2A> method to create an opaque handle to a managed object and <xref:System.Runtime.InteropServices.GCHandle.Free%2A> to release it. Also, the <xref:System.Runtime.InteropServices.GCHandle.Target%2A> method allows you to obtain the object reference back from the handle in managed code.  \n  \n```  \n// hold_object_reference_2.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma managed  \nclass StringWrapper {  \n   IntPtr m_handle;  \npublic:  \n   StringWrapper() {  \n      String ^ str = gcnew String(\"ManagedString\");  \n      m_handle = static_cast<IntPtr>(GCHandle::Alloc(str));  \n   }  \n   ~StringWrapper() {  \n      static_cast<GCHandle>(m_handle).Free();  \n   }  \n  \n   void PrintString() {  \n      String ^ targetStr = safe_cast< String ^ >(static_cast<GCHandle>(m_handle).Target);  \n      Console::WriteLine(\"StringWrapper::m_handle == {0}\", targetStr);  \n   }  \n};  \n  \n#pragma unmanaged  \nint main() {  \n   StringWrapper s;   \n   s.PrintString();  \n}  \n```  \n  \n```Output  \nStringWrapper::m_handle == ManagedString  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}