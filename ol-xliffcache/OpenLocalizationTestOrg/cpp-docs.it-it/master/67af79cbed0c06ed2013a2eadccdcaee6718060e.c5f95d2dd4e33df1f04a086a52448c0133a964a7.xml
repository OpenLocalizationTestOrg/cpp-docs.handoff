{"nodes":[{"pos":[12,47],"content":"__cpuid, __cpuidex | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__cpuid, __cpuidex | Microsoft Docs","pos":[0,35]}]},{"content":"__cpuid, __cpuidex","pos":[666,684]},{"content":"Microsoft Specific","pos":[687,705]},{"content":"Generates the <ph id=\"ph1\">`cpuid`</ph> instruction that is available on x86 and <ph id=\"ph2\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph>.","pos":[714,841],"source":"Generates the `cpuid` instruction that is available on x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]."},{"content":"This instruction queries the processor for information about supported features and the CPU type.","pos":[842,939]},{"content":"Syntax","pos":[948,954]},{"content":"Parameters","pos":[1136,1146]},{"content":"[out]","pos":[1150,1155]},{"content":"An array of four integers that contains the information returned in EAX, EBX, ECX, and EDX about supported features of the CPU.","pos":[1169,1296]},{"content":"[in]","pos":[1303,1307]},{"content":"A code that specifies the information to retrieve, passed in EAX.","pos":[1325,1390]},{"content":"[in]","pos":[1397,1401]},{"content":"An additional code that specifies information to retrieve, passed in ECX.","pos":[1422,1495]},{"content":"Requirements","pos":[1504,1516]},{"content":"Intrinsic","pos":[1523,1532]},{"content":"Architecture","pos":[1533,1545]},{"pos":[1599,1603],"content":"x86,"},{"pos":[1684,1688],"content":"x86,"},{"pos":[1760,1787],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1796,1803]},{"content":"This intrinsic stores the supported features and CPU information returned by the <ph id=\"ph1\">`cpuid`</ph> instruction in <ph id=\"ph2\">`cpuInfo`</ph>, an array of four 32-bit integers that is filled with the values of the EAX, EBX, ECX, and EDX registers (in that order).","pos":[1807,2042],"source":"This intrinsic stores the supported features and CPU information returned by the `cpuid` instruction in `cpuInfo`, an array of four 32-bit integers that is filled with the values of the EAX, EBX, ECX, and EDX registers (in that order)."},{"content":"The information returned has a different meaning depending on the value passed as the <ph id=\"ph1\">`function_id`</ph> parameter.","pos":[2043,2153],"source":" The information returned has a different meaning depending on the value passed as the `function_id` parameter."},{"content":"The information returned with various values of <ph id=\"ph1\">`function_id`</ph> is processor-dependent.","pos":[2154,2239],"source":" The information returned with various values of `function_id` is processor-dependent."},{"content":"The <ph id=\"ph1\">`__cpuid`</ph> intrinsic clears the ECX register before calling the <ph id=\"ph2\">`cpuid`</ph> instruction.","pos":[2246,2333],"source":"The `__cpuid` intrinsic clears the ECX register before calling the `cpuid` instruction."},{"content":"The <ph id=\"ph1\">`__cpuidex`</ph> intrinsic sets the value of the ECX register to <ph id=\"ph2\">`subfunction_id`</ph> before it generates the <ph id=\"ph3\">`cpuid`</ph> instruction.","pos":[2334,2459],"source":" The `__cpuidex` intrinsic sets the value of the ECX register to `subfunction_id` before it generates the `cpuid` instruction."},{"content":"This enables you to gather additional information about the processor.","pos":[2460,2530]},{"content":"For more information about the specific parameters to use and the values returned by these intrinsics on Intel processors, see the documentation for the <ph id=\"ph1\">`cpuid`</ph> instruction in <bpt id=\"p1\">[</bpt>Intel 64 and IA-32 Architectures Software Developers Manual Volume 2: Instruction Set Reference<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=510021)</ept> and <bpt id=\"p2\">[</bpt>Intel Architecture Instruction Set Extensions Programming Reference<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=506627)</ept>.","pos":[2537,2983],"source":"For more information about the specific parameters to use and the values returned by these intrinsics on Intel processors, see the documentation for the `cpuid` instruction in [Intel 64 and IA-32 Architectures Software Developers Manual Volume 2: Instruction Set Reference](http://go.microsoft.com/fwlink/p/?LinkID=510021) and [Intel Architecture Instruction Set Extensions Programming Reference](http://go.microsoft.com/fwlink/p/?LinkID=506627)."},{"content":"Intel documentation uses the terms \"leaf\" and \"subleaf\" for the <ph id=\"ph1\">`function_id`</ph> and <ph id=\"ph2\">`subfunction_id`</ph> parameters passed in EAX and ECX.","pos":[2984,3116],"source":" Intel documentation uses the terms \"leaf\" and \"subleaf\" for the `function_id` and `subfunction_id` parameters passed in EAX and ECX."},{"content":"For more information about the specific parameters to use and the values returned by these intrinsics on AMD processors, see the documentation for the <ph id=\"ph1\">`cpuid`</ph> instruction in <bpt id=\"p1\">[</bpt>AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=510023)</ept> and in the <bpt id=\"p2\">[</bpt>Revision Guides<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkId=510023)</ept> for specific processor families.","pos":[3123,3547],"source":"For more information about the specific parameters to use and the values returned by these intrinsics on AMD processors, see the documentation for the `cpuid` instruction in [AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions](http://go.microsoft.com/fwlink/p/?LinkId=510023) and in the [Revision Guides](http://go.microsoft.com/fwlink/p/?LinkId=510023) for specific processor families."},{"content":"AMD documentation uses the terms \"function number\" and \"subfunction number\" for the <ph id=\"ph1\">`function_id`</ph> and <ph id=\"ph2\">`subfunction_id`</ph> parameters passed in EAX and ECX.","pos":[3548,3700],"source":" AMD documentation uses the terms \"function number\" and \"subfunction number\" for the `function_id` and `subfunction_id` parameters passed in EAX and ECX."},{"content":"When the <ph id=\"ph1\">`function_id`</ph> argument is 0, <ph id=\"ph2\">`cpuInfo[0]`</ph> returns the highest available non-extended <ph id=\"ph3\">`function_id`</ph> supported by the processor.","pos":[3707,3842],"source":"When the `function_id` argument is 0, `cpuInfo[0]` returns the highest available non-extended `function_id` supported by the processor."},{"content":"The processor manufacturer is encoded in <ph id=\"ph1\">`cpuInfo[1]`</ph>, <ph id=\"ph2\">`cpuInfo[2]`</ph>, and cpuInfo[3].","pos":[3843,3927],"source":" The processor manufacturer is encoded in `cpuInfo[1]`, `cpuInfo[2]`, and cpuInfo[3]."},{"content":"Support for specific instruction set extensions and CPU features is encoded in the <ph id=\"ph1\">`cpuInfo`</ph> results returned for higher function_id values.","pos":[3934,4074],"source":"Support for specific instruction set extensions and CPU features is encoded in the `cpuInfo` results returned for higher function_id values."},{"content":"For more information, see the manuals linked above, and the following example code.","pos":[4075,4158]},{"content":"Some processors support Extended Function CPUID information.","pos":[4165,4225]},{"content":"If this is supported, <ph id=\"ph1\">`function_id`</ph> values from 0x80000000 might be used to return information.","pos":[4226,4321],"source":" If this is supported, `function_id` values from 0x80000000 might be used to return information."},{"content":"To determine the maximum meaningful value allowed, set <ph id=\"ph1\">`function_id`</ph> to 0x80000000.","pos":[4322,4405],"source":" To determine the maximum meaningful value allowed, set `function_id` to 0x80000000."},{"content":"The maximum value of <ph id=\"ph1\">`function_id`</ph> supported for extended functions will be written to <ph id=\"ph2\">`cpuInfo[0]`</ph>.","pos":[4406,4506],"source":" The maximum value of `function_id` supported for extended functions will be written to `cpuInfo[0]`."},{"content":"Example","pos":[4515,4522]},{"content":"This example shows some of the information available through the <ph id=\"ph1\">`__cpuid`</ph> and <ph id=\"ph2\">`__cpuidex`</ph> intrinsics.","pos":[4526,4628],"source":"This example shows some of the information available through the `__cpuid` and `__cpuidex` intrinsics."},{"content":"The app lists the instruction set extensions supported by the current processor.","pos":[4629,4709]},{"content":"The output shows a possible result for a particular processor.","pos":[4710,4772]},{"content":"END Microsoft Specific","pos":[17386,17408]},{"content":"See Also","pos":[17417,17425]},{"content":"Compiler Intrinsics","pos":[17430,17449]}],"content":"---\ntitle: \"__cpuid, __cpuidex | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__cpuid_cpp\"\n  - \"__cpuid\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__cpuid intrinsic\"\n  - \"cpuid instruction\"\n  - \"cpuid intrinsic\"\nms.assetid: f8c344d3-91bf-405f-8622-cb0e337a6bdc\ncaps.latest.revision: 38\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# __cpuid, __cpuidex\n**Microsoft Specific**  \n  \n Generates the `cpuid` instruction that is available on x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]. This instruction queries the processor for information about supported features and the CPU type.  \n  \n## Syntax  \n  \n```  \nvoid __cpuid(  \n   int cpuInfo[4],  \n   int function_id  \n);  \n  \nvoid __cpuidex(  \n   int cpuInfo[4],  \n   int function_id,  \n   int subfunction_id  \n);  \n```  \n  \n#### Parameters  \n [out] `cpuInfo`  \n An array of four integers that contains the information returned in EAX, EBX, ECX, and EDX about supported features of the CPU.  \n  \n [in] `function_id`  \n A code that specifies the information to retrieve, passed in EAX.  \n  \n [in] `subfunction_id`  \n An additional code that specifies information to retrieve, passed in ECX.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`__cpuid`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n|`__cpuidex`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n This intrinsic stores the supported features and CPU information returned by the `cpuid` instruction in `cpuInfo`, an array of four 32-bit integers that is filled with the values of the EAX, EBX, ECX, and EDX registers (in that order). The information returned has a different meaning depending on the value passed as the `function_id` parameter. The information returned with various values of `function_id` is processor-dependent.  \n  \n The `__cpuid` intrinsic clears the ECX register before calling the `cpuid` instruction. The `__cpuidex` intrinsic sets the value of the ECX register to `subfunction_id` before it generates the `cpuid` instruction. This enables you to gather additional information about the processor.  \n  \n For more information about the specific parameters to use and the values returned by these intrinsics on Intel processors, see the documentation for the `cpuid` instruction in [Intel 64 and IA-32 Architectures Software Developers Manual Volume 2: Instruction Set Reference](http://go.microsoft.com/fwlink/p/?LinkID=510021) and [Intel Architecture Instruction Set Extensions Programming Reference](http://go.microsoft.com/fwlink/p/?LinkID=506627). Intel documentation uses the terms \"leaf\" and \"subleaf\" for the `function_id` and `subfunction_id` parameters passed in EAX and ECX.  \n  \n For more information about the specific parameters to use and the values returned by these intrinsics on AMD processors, see the documentation for the `cpuid` instruction in [AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions](http://go.microsoft.com/fwlink/p/?LinkId=510023) and in the [Revision Guides](http://go.microsoft.com/fwlink/p/?LinkId=510023) for specific processor families. AMD documentation uses the terms \"function number\" and \"subfunction number\" for the `function_id` and `subfunction_id` parameters passed in EAX and ECX.  \n  \n When the `function_id` argument is 0, `cpuInfo[0]` returns the highest available non-extended `function_id` supported by the processor. The processor manufacturer is encoded in `cpuInfo[1]`, `cpuInfo[2]`, and cpuInfo[3].  \n  \n Support for specific instruction set extensions and CPU features is encoded in the `cpuInfo` results returned for higher function_id values. For more information, see the manuals linked above, and the following example code.  \n  \n Some processors support Extended Function CPUID information. If this is supported, `function_id` values from 0x80000000 might be used to return information. To determine the maximum meaningful value allowed, set `function_id` to 0x80000000. The maximum value of `function_id` supported for extended functions will be written to `cpuInfo[0]`.  \n  \n## Example  \n This example shows some of the information available through the `__cpuid` and `__cpuidex` intrinsics. The app lists the instruction set extensions supported by the current processor. The output shows a possible result for a particular processor.  \n  \n```  \n// InstructionSet.cpp   \n// Compile by using: cl /EHsc /W4 InstructionSet.cpp  \n// processor: x86, x64  \n// Uses the __cpuid intrinsic to get information about   \n// CPU extended instruction set support.  \n  \n#include <iostream>  \n#include <vector>  \n#include <bitset>  \n#include <array>  \n#include <string>  \n#include <intrin.h>  \n  \nclass InstructionSet  \n{  \n    // forward declarations  \n    class InstructionSet_Internal;  \n  \npublic:  \n    // getters  \n    static std::string Vendor(void) { return CPU_Rep.vendor_; }  \n    static std::string Brand(void) { return CPU_Rep.brand_; }  \n  \n    static bool SSE3(void) { return CPU_Rep.f_1_ECX_[0]; }  \n    static bool PCLMULQDQ(void) { return CPU_Rep.f_1_ECX_[1]; }  \n    static bool MONITOR(void) { return CPU_Rep.f_1_ECX_[3]; }  \n    static bool SSSE3(void) { return CPU_Rep.f_1_ECX_[9]; }  \n    static bool FMA(void) { return CPU_Rep.f_1_ECX_[12]; }  \n    static bool CMPXCHG16B(void) { return CPU_Rep.f_1_ECX_[13]; }  \n    static bool SSE41(void) { return CPU_Rep.f_1_ECX_[19]; }  \n    static bool SSE42(void) { return CPU_Rep.f_1_ECX_[20]; }  \n    static bool MOVBE(void) { return CPU_Rep.f_1_ECX_[22]; }  \n    static bool POPCNT(void) { return CPU_Rep.f_1_ECX_[23]; }  \n    static bool AES(void) { return CPU_Rep.f_1_ECX_[25]; }  \n    static bool XSAVE(void) { return CPU_Rep.f_1_ECX_[26]; }  \n    static bool OSXSAVE(void) { return CPU_Rep.f_1_ECX_[27]; }  \n    static bool AVX(void) { return CPU_Rep.f_1_ECX_[28]; }  \n    static bool F16C(void) { return CPU_Rep.f_1_ECX_[29]; }  \n    static bool RDRAND(void) { return CPU_Rep.f_1_ECX_[30]; }  \n  \n    static bool MSR(void) { return CPU_Rep.f_1_EDX_[5]; }  \n    static bool CX8(void) { return CPU_Rep.f_1_EDX_[8]; }  \n    static bool SEP(void) { return CPU_Rep.f_1_EDX_[11]; }  \n    static bool CMOV(void) { return CPU_Rep.f_1_EDX_[15]; }  \n    static bool CLFSH(void) { return CPU_Rep.f_1_EDX_[19]; }  \n    static bool MMX(void) { return CPU_Rep.f_1_EDX_[23]; }  \n    static bool FXSR(void) { return CPU_Rep.f_1_EDX_[24]; }  \n    static bool SSE(void) { return CPU_Rep.f_1_EDX_[25]; }  \n    static bool SSE2(void) { return CPU_Rep.f_1_EDX_[26]; }  \n  \n    static bool FSGSBASE(void) { return CPU_Rep.f_7_EBX_[0]; }  \n    static bool BMI1(void) { return CPU_Rep.f_7_EBX_[3]; }  \n    static bool HLE(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_7_EBX_[4]; }  \n    static bool AVX2(void) { return CPU_Rep.f_7_EBX_[5]; }  \n    static bool BMI2(void) { return CPU_Rep.f_7_EBX_[8]; }  \n    static bool ERMS(void) { return CPU_Rep.f_7_EBX_[9]; }  \n    static bool INVPCID(void) { return CPU_Rep.f_7_EBX_[10]; }  \n    static bool RTM(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_7_EBX_[11]; }  \n    static bool AVX512F(void) { return CPU_Rep.f_7_EBX_[16]; }  \n    static bool RDSEED(void) { return CPU_Rep.f_7_EBX_[18]; }  \n    static bool ADX(void) { return CPU_Rep.f_7_EBX_[19]; }  \n    static bool AVX512PF(void) { return CPU_Rep.f_7_EBX_[26]; }  \n    static bool AVX512ER(void) { return CPU_Rep.f_7_EBX_[27]; }  \n    static bool AVX512CD(void) { return CPU_Rep.f_7_EBX_[28]; }  \n    static bool SHA(void) { return CPU_Rep.f_7_EBX_[29]; }  \n  \n    static bool PREFETCHWT1(void) { return CPU_Rep.f_7_ECX_[0]; }  \n  \n    static bool LAHF(void) { return CPU_Rep.f_81_ECX_[0]; }  \n    static bool LZCNT(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_ECX_[5]; }  \n    static bool ABM(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[5]; }  \n    static bool SSE4a(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[6]; }  \n    static bool XOP(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[11]; }  \n    static bool TBM(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[21]; }  \n  \n    static bool SYSCALL(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_EDX_[11]; }  \n    static bool MMXEXT(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[22]; }  \n    static bool RDTSCP(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_EDX_[27]; }  \n    static bool _3DNOWEXT(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[30]; }  \n    static bool _3DNOW(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[31]; }  \n  \nprivate:  \n    static const InstructionSet_Internal CPU_Rep;  \n  \n    class InstructionSet_Internal  \n    {  \n    public:  \n        InstructionSet_Internal()  \n            : nIds_{ 0 },  \n            nExIds_{ 0 },  \n            isIntel_{ false },  \n            isAMD_{ false },  \n            f_1_ECX_{ 0 },  \n            f_1_EDX_{ 0 },  \n            f_7_EBX_{ 0 },  \n            f_7_ECX_{ 0 },  \n            f_81_ECX_{ 0 },  \n            f_81_EDX_{ 0 },  \n            data_{},  \n            extdata_{}  \n        {  \n            //int cpuInfo[4] = {-1};  \n            std::array<int, 4> cpui;  \n  \n            // Calling __cpuid with 0x0 as the function_id argument  \n            // gets the number of the highest valid function ID.  \n            __cpuid(cpui.data(), 0);  \n            nIds_ = cpui[0];  \n  \n            for (int i = 0; i <= nIds_; ++i)  \n            {  \n                __cpuidex(cpui.data(), i, 0);  \n                data_.push_back(cpui);  \n            }  \n  \n            // Capture vendor string  \n            char vendor[0x20];  \n            memset(vendor, 0, sizeof(vendor));  \n            *reinterpret_cast<int*>(vendor) = data_[0][1];  \n            *reinterpret_cast<int*>(vendor + 4) = data_[0][3];  \n            *reinterpret_cast<int*>(vendor + 8) = data_[0][2];  \n            vendor_ = vendor;  \n            if (vendor_ == \"GenuineIntel\")  \n            {  \n                isIntel_ = true;  \n            }  \n            else if (vendor_ == \"AuthenticAMD\")  \n            {  \n                isAMD_ = true;  \n            }  \n  \n            // load bitset with flags for function 0x00000001  \n            if (nIds_ >= 1)  \n            {  \n                f_1_ECX_ = data_[1][2];  \n                f_1_EDX_ = data_[1][3];  \n            }  \n  \n            // load bitset with flags for function 0x00000007  \n            if (nIds_ >= 7)  \n            {  \n                f_7_EBX_ = data_[7][1];  \n                f_7_ECX_ = data_[7][2];  \n            }  \n  \n            // Calling __cpuid with 0x80000000 as the function_id argument  \n            // gets the number of the highest valid extended ID.  \n            __cpuid(cpui.data(), 0x80000000);  \n            nExIds_ = cpui[0];  \n  \n            char brand[0x40];  \n            memset(brand, 0, sizeof(brand));  \n  \n            for (int i = 0x80000000; i <= nExIds_; ++i)  \n            {  \n                __cpuidex(cpui.data(), i, 0);  \n                extdata_.push_back(cpui);  \n            }  \n  \n            // load bitset with flags for function 0x80000001  \n            if (nExIds_ >= 0x80000001)  \n            {  \n                f_81_ECX_ = extdata_[1][2];  \n                f_81_EDX_ = extdata_[1][3];  \n            }  \n  \n            // Interpret CPU brand string if reported  \n            if (nExIds_ >= 0x80000004)  \n            {  \n                memcpy(brand, extdata_[2].data(), sizeof(cpui));  \n                memcpy(brand + 16, extdata_[3].data(), sizeof(cpui));  \n                memcpy(brand + 32, extdata_[4].data(), sizeof(cpui));  \n                brand_ = brand;  \n            }  \n        };  \n  \n        int nIds_;  \n        int nExIds_;  \n        std::string vendor_;  \n        std::string brand_;  \n        bool isIntel_;  \n        bool isAMD_;  \n        std::bitset<32> f_1_ECX_;  \n        std::bitset<32> f_1_EDX_;  \n        std::bitset<32> f_7_EBX_;  \n        std::bitset<32> f_7_ECX_;  \n        std::bitset<32> f_81_ECX_;  \n        std::bitset<32> f_81_EDX_;  \n        std::vector<std::array<int, 4>> data_;  \n        std::vector<std::array<int, 4>> extdata_;  \n    };  \n};  \n  \n// Initialize static member data  \nconst InstructionSet::InstructionSet_Internal InstructionSet::CPU_Rep;  \n  \n// Print out supported instruction set extensions  \nint main()  \n{  \n    auto& outstream = std::cout;  \n  \n    auto support_message = [&outstream](std::string isa_feature, bool is_supported) {  \n        outstream << isa_feature << (is_supported ? \" supported\" : \" not supported\") << std::endl;  \n    };  \n  \n    std::cout << InstructionSet::Vendor() << std::endl;  \n    std::cout << InstructionSet::Brand() << std::endl;  \n  \n    support_message(\"3DNOW\",       InstructionSet::_3DNOW());  \n    support_message(\"3DNOWEXT\",    InstructionSet::_3DNOWEXT());  \n    support_message(\"ABM\",         InstructionSet::ABM());  \n    support_message(\"ADX\",         InstructionSet::ADX());  \n    support_message(\"AES\",         InstructionSet::AES());  \n    support_message(\"AVX\",         InstructionSet::AVX());  \n    support_message(\"AVX2\",        InstructionSet::AVX2());  \n    support_message(\"AVX512CD\",    InstructionSet::AVX512CD());  \n    support_message(\"AVX512ER\",    InstructionSet::AVX512ER());  \n    support_message(\"AVX512F\",     InstructionSet::AVX512F());  \n    support_message(\"AVX512PF\",    InstructionSet::AVX512PF());  \n    support_message(\"BMI1\",        InstructionSet::BMI1());  \n    support_message(\"BMI2\",        InstructionSet::BMI2());  \n    support_message(\"CLFSH\",       InstructionSet::CLFSH());  \n    support_message(\"CMPXCHG16B\",  InstructionSet::CMPXCHG16B());  \n    support_message(\"CX8\",         InstructionSet::CX8());  \n    support_message(\"ERMS\",        InstructionSet::ERMS());  \n    support_message(\"F16C\",        InstructionSet::F16C());  \n    support_message(\"FMA\",         InstructionSet::FMA());  \n    support_message(\"FSGSBASE\",    InstructionSet::FSGSBASE());  \n    support_message(\"FXSR\",        InstructionSet::FXSR());  \n    support_message(\"HLE\",         InstructionSet::HLE());  \n    support_message(\"INVPCID\",     InstructionSet::INVPCID());  \n    support_message(\"LAHF\",        InstructionSet::LAHF());  \n    support_message(\"LZCNT\",       InstructionSet::LZCNT());  \n    support_message(\"MMX\",         InstructionSet::MMX());  \n    support_message(\"MMXEXT\",      InstructionSet::MMXEXT());  \n    support_message(\"MONITOR\",     InstructionSet::MONITOR());  \n    support_message(\"MOVBE\",       InstructionSet::MOVBE());  \n    support_message(\"MSR\",         InstructionSet::MSR());  \n    support_message(\"OSXSAVE\",     InstructionSet::OSXSAVE());  \n    support_message(\"PCLMULQDQ\",   InstructionSet::PCLMULQDQ());  \n    support_message(\"POPCNT\",      InstructionSet::POPCNT());  \n    support_message(\"PREFETCHWT1\", InstructionSet::PREFETCHWT1());  \n    support_message(\"RDRAND\",      InstructionSet::RDRAND());  \n    support_message(\"RDSEED\",      InstructionSet::RDSEED());  \n    support_message(\"RDTSCP\",      InstructionSet::RDTSCP());  \n    support_message(\"RTM\",         InstructionSet::RTM());  \n    support_message(\"SEP\",         InstructionSet::SEP());  \n    support_message(\"SHA\",         InstructionSet::SHA());  \n    support_message(\"SSE\",         InstructionSet::SSE());  \n    support_message(\"SSE2\",        InstructionSet::SSE2());  \n    support_message(\"SSE3\",        InstructionSet::SSE3());  \n    support_message(\"SSE4.1\",      InstructionSet::SSE41());  \n    support_message(\"SSE4.2\",      InstructionSet::SSE42());  \n    support_message(\"SSE4a\",       InstructionSet::SSE4a());  \n    support_message(\"SSSE3\",       InstructionSet::SSSE3());  \n    support_message(\"SYSCALL\",     InstructionSet::SYSCALL());  \n    support_message(\"TBM\",         InstructionSet::TBM());  \n    support_message(\"XOP\",         InstructionSet::XOP());  \n    support_message(\"XSAVE\",       InstructionSet::XSAVE());  \n}  \n```  \n  \n```Output  \nGenuineIntel  \n        Intel(R) Core(TM) i5-2500 CPU @ 3.30GHz  \n3DNOW not supported  \n3DNOWEXT not supported  \nABM not supported  \nADX not supported  \nAES supported  \nAVX supported  \nAVX2 not supported  \nAVX512CD not supported  \nAVX512ER not supported  \nAVX512F not supported  \nAVX512PF not supported  \nBMI1 not supported  \nBMI2 not supported  \nCLFSH supported  \nCMPXCHG16B supported  \nCX8 supported  \nERMS not supported  \nF16C not supported  \nFMA not supported  \nFSGSBASE not supported  \nFXSR supported  \nHLE not supported  \nINVPCID not supported  \nLAHF supported  \nLZCNT not supported  \nMMX supported  \nMMXEXT not supported  \nMONITOR not supported  \nMOVBE not supported  \nMSR supported  \nOSXSAVE supported  \nPCLMULQDQ supported  \nPOPCNT supported  \nPREFETCHWT1 not supported  \nRDRAND not supported  \nRDSEED not supported  \nRDTSCP supported  \nRTM not supported  \nSEP supported  \nSHA not supported  \nSSE supported  \nSSE2 supported  \nSSE3 supported  \nSSE4.1 supported  \nSSE4.2 supported  \nSSE4a not supported  \nSSSE3 supported  \nSYSCALL supported  \nTBM not supported  \nXOP not supported  \nXSAVE supported  \n  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}