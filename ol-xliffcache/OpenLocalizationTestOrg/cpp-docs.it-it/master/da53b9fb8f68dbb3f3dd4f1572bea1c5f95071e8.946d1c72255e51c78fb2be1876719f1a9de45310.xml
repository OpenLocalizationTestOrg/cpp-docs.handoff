{"nodes":[{"pos":[12,47],"content":"managed, unmanaged | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"managed, unmanaged | Microsoft Docs","pos":[0,35]}]},{"content":"managed, unmanaged","pos":[752,770]},{"content":"Enable function-level control for compiling functions as managed or unmanaged.","pos":[771,849]},{"content":"Syntax","pos":[858,864]},{"content":"Remarks","pos":[994,1001]},{"pos":[1005,1180],"content":"The <bpt id=\"p1\">[</bpt>/clr<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler option provides module-level control for compiling functions either as managed or unmanaged.","source":"The [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler option provides module-level control for compiling functions either as managed or unmanaged."},{"content":"An unmanaged function will be compiled for the native platform, and execution of that portion of the program will be passed to the native platform by the common language runtime.","pos":[1187,1365]},{"pos":[1372,1439],"content":"Functions are compiled as managed by default when <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is used.","source":"Functions are compiled as managed by default when **/clr** is used."},{"content":"When applying these pragmas:","pos":[1446,1474]},{"content":"Add the pragma preceding a function but not within a function body.","pos":[1484,1551]},{"content":"Add the pragma after <ph id=\"ph1\">`#include`</ph> statements.","pos":[1561,1604],"source":"Add the pragma after `#include` statements."},{"content":"Do not use these pragmas before <ph id=\"ph1\">`#include`</ph> statements.","pos":[1605,1659],"source":" Do not use these pragmas before `#include` statements."},{"pos":[1666,1768],"content":"The compiler ignores the <ph id=\"ph1\">`managed`</ph> and <ph id=\"ph2\">`unmanaged`</ph> pragmas if <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is not used in the compilation.","source":"The compiler ignores the `managed` and `unmanaged` pragmas if **/clr** is not used in the compilation."},{"content":"When a template function is instantiated, the pragma state at the time of definition for the template determines if it is managed or unmanaged.","pos":[1775,1918]},{"pos":[1925,2037],"content":"For more information, see <bpt id=\"p1\">[</bpt>Initialization of Mixed Assemblies<ept id=\"p1\">](../dotnet/initialization-of-mixed-assemblies.md)</ept>.","source":"For more information, see [Initialization of Mixed Assemblies](../dotnet/initialization-of-mixed-assemblies.md)."},{"content":"Example","pos":[2046,2053]},{"content":"See Also","pos":[2661,2669]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[2674,2716]}],"content":"---\ntitle: \"managed, unmanaged | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-pragma.unmanaged\"\n  - \"managed_CPP\"\n  - \"unmanaged_CPP\"\n  - \"vc-pragma.managed\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"managed pragma\"\n  - \"pragmas, unmanaged\"\n  - \"pragmas, managed\"\n  - \"unmanaged pragma\"\nms.assetid: f072ddcc-e1ec-408a-8ce1-326ddb60e4a4\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# managed, unmanaged\nEnable function-level control for compiling functions as managed or unmanaged.  \n  \n## Syntax  \n  \n```  \n  \n      #pragma managed  \n#pragma unmanaged  \n#pragma managed([push,] on | off)  \n#pragma managed(pop)  \n```  \n  \n## Remarks  \n The [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler option provides module-level control for compiling functions either as managed or unmanaged.  \n  \n An unmanaged function will be compiled for the native platform, and execution of that portion of the program will be passed to the native platform by the common language runtime.  \n  \n Functions are compiled as managed by default when **/clr** is used.  \n  \n When applying these pragmas:  \n  \n-   Add the pragma preceding a function but not within a function body.  \n  \n-   Add the pragma after `#include` statements. Do not use these pragmas before `#include` statements.  \n  \n The compiler ignores the `managed` and `unmanaged` pragmas if **/clr** is not used in the compilation.  \n  \n When a template function is instantiated, the pragma state at the time of definition for the template determines if it is managed or unmanaged.  \n  \n For more information, see [Initialization of Mixed Assemblies](../dotnet/initialization-of-mixed-assemblies.md).  \n  \n## Example  \n  \n```  \n// pragma_directives_managed_unmanaged.cpp  \n// compile with: /clr  \n#include <stdio.h>  \n  \n// func1 is managed  \nvoid func1() {  \n   System::Console::WriteLine(\"In managed function.\");  \n}  \n  \n// #pragma unmanaged  \n// push managed state on to stack and set unmanaged state  \n#pragma managed(push, off)  \n  \n// func2 is unmanaged  \nvoid func2() {  \n   printf(\"In unmanaged function.\\n\");  \n}  \n  \n// #pragma managed  \n#pragma managed(pop)  \n  \n// main is managed  \nint main() {  \n   func1();  \n   func2();  \n}  \n```  \n  \n```Output  \nIn managed function.  \nIn unmanaged function.  \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}