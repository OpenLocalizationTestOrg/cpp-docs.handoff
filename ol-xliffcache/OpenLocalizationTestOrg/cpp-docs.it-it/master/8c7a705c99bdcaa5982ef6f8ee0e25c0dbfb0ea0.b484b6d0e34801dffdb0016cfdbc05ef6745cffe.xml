{"nodes":[{"pos":[12,66],"content":"-fp (Specify Floating-Point Behavior) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"-fp (Specify Floating-Point Behavior) | Microsoft Docs","pos":[0,54]}]},{"content":"/fp (Specify Floating-Point Behavior)","pos":[885,922]},{"content":"Specifies floating-point behavior in a source code file.","pos":[923,979]},{"content":"Syntax","pos":[988,994]},{"content":"Flags","pos":[1063,1068]},{"content":"precise","pos":[1074,1081]},{"content":"The default.","pos":[1087,1099]},{"content":"Improves the consistency of floating-point tests for equality and inequality by disabling optimizations that could change the precision of floating-point calculations.","pos":[1106,1273]},{"content":"(Maintaining specific precision is required for strict ANSI conformance.) By default, in code for x86 architectures the compiler uses the coprocessor's 80-bit registers to hold the intermediate results of floating-point calculations.","pos":[1274,1507]},{"content":"This increases program speed and decreases program size.","pos":[1508,1564]},{"content":"However, because the calculation involves floating-point data types that are represented in memory by less than 80 bits, carrying the extra bits of precision—80 bits minus the number of bits in a smaller floating-point type—through a lengthy calculation can produce inconsistent results.","pos":[1565,1852]},{"content":"With <bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> on x86 processors, the compiler performs rounding on variables of type <ph id=\"ph1\">`float`</ph> to the correct precision for assignments and casts and when parameters are passed to a function.","pos":[1859,2055],"source":"With **/fp:precise** on x86 processors, the compiler performs rounding on variables of type `float` to the correct precision for assignments and casts and when parameters are passed to a function."},{"content":"This rounding guarantees that the data does not retain any significance greater than the capacity of its type.","pos":[2056,2166]},{"content":"A program compiled with <bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> can be slower and larger than one compiled without <bpt id=\"p2\">**</bpt>/fp:precise<ept id=\"p2\">**</ept>.","pos":[2167,2274],"source":" A program compiled with **/fp:precise** can be slower and larger than one compiled without **/fp:precise**."},{"content":"<bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> disables intrinsics; the standard run-time library routines are used instead.","pos":[2275,2368],"source":"**/fp:precise** disables intrinsics; the standard run-time library routines are used instead."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/Oi (Generate Intrinsic Functions)<ept id=\"p1\">](../../build/reference/oi-generate-intrinsic-functions.md)</ept>.","pos":[2369,2490],"source":" For more information, see [/Oi (Generate Intrinsic Functions)](../../build/reference/oi-generate-intrinsic-functions.md)."},{"pos":[2497,2567],"content":"The following floating-point behavior is enabled with <bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept>:","source":"The following floating-point behavior is enabled with **/fp:precise**:"},{"content":"Contractions—that is, using a composite operation that has just one rounding at the end to replace multiple operations.","pos":[2577,2696]},{"content":"Expression optimizations that are invalid for special values (NaN, +infinity, -infinity, +0, -0) are not allowed.","pos":[2706,2819]},{"content":"The optimizations x-x =&gt; 0, x*0 =&gt; 0, x-0 =&gt; x, x+0 =&gt; x, and 0-x =&gt; -x are invalid for various reasons.","pos":[2820,2924],"source":" The optimizations x-x => 0, x*0 => 0, x-0 => x, x+0 => x, and 0-x => -x are invalid for various reasons."},{"content":"(See IEEE 754 and the C99 standard.)","pos":[2925,2961]},{"content":"The compiler correctly handles comparisons that involve NaN.","pos":[2971,3031]},{"content":"For example, x != x evaluates to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if <ph id=\"ph1\">`x`</ph> is NaN and ordered comparisons involving NaN raise an exception.","pos":[3032,3145],"source":" For example, x != x evaluates to **true** if `x` is NaN and ordered comparisons involving NaN raise an exception."},{"content":"Expression evaluation follows the C99 FLT_EVAL_METHOD=2, with this exception: When you program for x86 processors, because the FPU is set to 53-bit precision, this is considered long-double precision.","pos":[3155,3355]},{"content":"Multiplication by exactly 1.0 transformed into a use of the other factor.","pos":[3365,3438]},{"content":"x*y<ph id=\"ph1\">\\*</ph>1.0 is transformed into x<ph id=\"ph2\">\\*</ph>y.","pos":[3439,3473],"source":" x*y\\*1.0 is transformed into x\\*y."},{"content":"Similarly, x<ph id=\"ph1\">\\*</ph>1.0<ph id=\"ph2\">\\*</ph>y is transformed into x<ph id=\"ph3\">\\*</ph>y.","pos":[3474,3520],"source":" Similarly, x\\*1.0\\*y is transformed into x\\*y."},{"content":"Division by exactly 1.0 is transformed into a use of the dividend.","pos":[3530,3596]},{"content":"x*y/1.0 is transformed into x<ph id=\"ph1\">\\*</ph>y.","pos":[3597,3630],"source":" x*y/1.0 is transformed into x\\*y."},{"content":"Similarly, x/1.0<ph id=\"ph1\">\\*</ph>y is transformed into x<ph id=\"ph2\">\\*</ph>y.","pos":[3631,3676],"source":" Similarly, x/1.0\\*y is transformed into x\\*y."},{"content":"Using <bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> when <bpt id=\"p2\">[</bpt>fenv_access<ept id=\"p2\">](../../preprocessor/fenv-access.md)</ept> is ON disables optimizations such as compile-time evaluations of floating-point expressions.","pos":[3683,3851],"source":"Using **/fp:precise** when [fenv_access](../../preprocessor/fenv-access.md) is ON disables optimizations such as compile-time evaluations of floating-point expressions."},{"content":"For example, if you use <bpt id=\"p1\">[</bpt>_control87, _controlfp, <ph id=\"ph1\">\\_</ph>_control87_2<ept id=\"p1\">](../../c-runtime-library/reference/control87-controlfp-control87-2.md)</ept> to change the rounding mode, and the compiler performs a floating-point calculation, the rounding mode you specified is not in effect unless <ph id=\"ph2\">`fenv_access`</ph> is ON.","pos":[3852,4148],"source":" For example, if you use [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md) to change the rounding mode, and the compiler performs a floating-point calculation, the rounding mode you specified is not in effect unless `fenv_access` is ON."},{"pos":[4155,4208],"content":"<bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> replaces the <bpt id=\"p2\">**</bpt>/Op<ept id=\"p2\">**</ept> compiler option.","source":"**/fp:precise** replaces the **/Op** compiler option."},{"pos":[4215,5213],"content":"**fast**  \nCreates the fastest code in most cases by relaxing the rules for optimizing floating-point operations. This enables the compiler to optimize floating-point code for speed at the expense of accuracy and correctness. When **/fp:fast** is specified, the compiler may not round correctly at assignment statements, typecasts, or function calls, and may not perform rounding of intermediate expressions. The compiler may reorder operations or perform algebraic transforms—for example, by following associative and distributive rules—without regard to the effect on finite precision results. The compiler may change operations and operands to single-precision instead of following the C++ type promotion rules. Floating-point-specific contraction optimizations are always enabled ([fp_contract](../../preprocessor/fp-contract.md) is ON). Floating-point exceptions and FPU environment access are disabled (**/fp:except-** is implied and [fenv_access](../../preprocessor/fenv-access.md) is OFF).","leadings":[""," "],"nodes":[{"content":"fast","pos":[2,6]},{"content":"Creates the fastest code in most cases by relaxing the rules for optimizing floating-point operations. This enables the compiler to optimize floating-point code for speed at the expense of accuracy and correctness. When **/fp:fast** is specified, the compiler may not round correctly at assignment statements, typecasts, or function calls, and may not perform rounding of intermediate expressions. The compiler may reorder operations or perform algebraic transforms—for example, by following associative and distributive rules—without regard to the effect on finite precision results. The compiler may change operations and operands to single-precision instead of following the C++ type promotion rules. Floating-point-specific contraction optimizations are always enabled ([fp_contract](../../preprocessor/fp-contract.md) is ON). Floating-point exceptions and FPU environment access are disabled (**/fp:except-** is implied and [fenv_access](../../preprocessor/fenv-access.md) is OFF).","pos":[11,997],"nodes":[{"content":"Creates the fastest code in most cases by relaxing the rules for optimizing floating-point operations.","pos":[0,102]},{"content":"This enables the compiler to optimize floating-point code for speed at the expense of accuracy and correctness.","pos":[103,214]},{"content":"When <bpt id=\"p1\">**</bpt>/fp:fast<ept id=\"p1\">**</ept> is specified, the compiler may not round correctly at assignment statements, typecasts, or function calls, and may not perform rounding of intermediate expressions.","pos":[215,397],"source":" When **/fp:fast** is specified, the compiler may not round correctly at assignment statements, typecasts, or function calls, and may not perform rounding of intermediate expressions."},{"content":"The compiler may reorder operations or perform algebraic transforms—for example, by following associative and distributive rules—without regard to the effect on finite precision results.","pos":[398,584]},{"content":"The compiler may change operations and operands to single-precision instead of following the C++ type promotion rules.","pos":[585,703]},{"content":"Floating-point-specific contraction optimizations are always enabled (<bpt id=\"p1\">[</bpt>fp_contract<ept id=\"p1\">](../../preprocessor/fp-contract.md)</ept> is ON).","pos":[704,830],"source":" Floating-point-specific contraction optimizations are always enabled ([fp_contract](../../preprocessor/fp-contract.md) is ON)."},{"content":"Floating-point exceptions and FPU environment access are disabled (<bpt id=\"p1\">**</bpt>/fp:except-<ept id=\"p1\">**</ept> is implied and <bpt id=\"p2\">[</bpt>fenv_access<ept id=\"p2\">](../../preprocessor/fenv-access.md)</ept> is OFF).","pos":[831,986],"source":" Floating-point exceptions and FPU environment access are disabled (**/fp:except-** is implied and [fenv_access](../../preprocessor/fenv-access.md) is OFF)."}]}]},{"content":"<bpt id=\"p1\">**</bpt>/fp:fast<ept id=\"p1\">**</ept> cannot be used with <bpt id=\"p2\">**</bpt>/fp:strict<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>/fp:precise<ept id=\"p3\">**</ept>.","pos":[5220,5287],"source":"**/fp:fast** cannot be used with **/fp:strict** or **/fp:precise**."},{"content":"The last option specified on the command line is used.","pos":[5288,5342]},{"content":"Specifying both <bpt id=\"p1\">**</bpt>/fp:fast<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/fp:except<ept id=\"p2\">**</ept> generates a compiler error.","pos":[5343,5418],"source":" Specifying both **/fp:fast** and **/fp:except** generates a compiler error."},{"content":"Specifying <bpt id=\"p1\">[</bpt>/Za, /Ze (Disable Language Extensions)<ept id=\"p1\">](../../build/reference/za-ze-disable-language-extensions.md)</ept> (ANSI compatibility) and <bpt id=\"p2\">**</bpt>/fp:fast<ept id=\"p2\">**</ept> may cause unexpected behavior.","pos":[5425,5605],"source":"Specifying [/Za, /Ze (Disable Language Extensions)](../../build/reference/za-ze-disable-language-extensions.md) (ANSI compatibility) and **/fp:fast** may cause unexpected behavior."},{"content":"For example, single-precision floating-point operations may not be rounded to single precision.","pos":[5606,5701]},{"pos":[5708,5918],"content":"**except[-]**  \nReliable floating-point exception model. Exceptions are raised immediately after they are triggered. By default, this option is off. Appending a minus sign to the option explicitly disables it.","leadings":[""," "],"nodes":[{"content":"except[-]","pos":[2,11]},{"content":"Reliable floating-point exception model. Exceptions are raised immediately after they are triggered. By default, this option is off. Appending a minus sign to the option explicitly disables it.","pos":[16,209],"nodes":[{"content":"Reliable floating-point exception model.","pos":[0,40]},{"content":"Exceptions are raised immediately after they are triggered.","pos":[41,100]},{"content":"By default, this option is off.","pos":[101,132]},{"content":"Appending a minus sign to the option explicitly disables it.","pos":[133,193]}]}]},{"pos":[5925,6338],"content":"**strict**  \nThe strictest floating-point model. **/fp:strict** causes [fp_contract](../../preprocessor/fp-contract.md) to be OFF and [fenv_access](../../preprocessor/fenv-access.md) to be ON. **/fp:except** is implied and can be disabled by explicitly specifying **/fp:except-**. When used with **/fp:except-**, **/fp:strict** enforces strict floating-point semantics but without respect for exceptional events.","leadings":[""," "],"nodes":[{"content":"strict","pos":[2,8]},{"content":"The strictest floating-point model. **/fp:strict** causes [fp_contract](../../preprocessor/fp-contract.md) to be OFF and [fenv_access](../../preprocessor/fenv-access.md) to be ON. **/fp:except** is implied and can be disabled by explicitly specifying **/fp:except-**. When used with **/fp:except-**, **/fp:strict** enforces strict floating-point semantics but without respect for exceptional events.","pos":[13,412],"nodes":[{"content":"The strictest floating-point model.","pos":[0,35]},{"content":"<bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> causes <bpt id=\"p2\">[</bpt>fp_contract<ept id=\"p2\">](../../preprocessor/fp-contract.md)</ept> to be OFF and <bpt id=\"p3\">[</bpt>fenv_access<ept id=\"p3\">](../../preprocessor/fenv-access.md)</ept> to be ON.","pos":[36,179],"source":"**/fp:strict** causes [fp_contract](../../preprocessor/fp-contract.md) to be OFF and [fenv_access](../../preprocessor/fenv-access.md) to be ON."},{"content":"<bpt id=\"p1\">**</bpt>/fp:except<ept id=\"p1\">**</ept> is implied and can be disabled by explicitly specifying <bpt id=\"p2\">**</bpt>/fp:except-<ept id=\"p2\">**</ept>.","pos":[180,267],"source":"**/fp:except** is implied and can be disabled by explicitly specifying **/fp:except-**."},{"content":"When used with <bpt id=\"p1\">**</bpt>/fp:except-<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/fp:strict<ept id=\"p2\">**</ept> enforces strict floating-point semantics but without respect for exceptional events.","pos":[268,399],"source":" When used with **/fp:except-**, **/fp:strict** enforces strict floating-point semantics but without respect for exceptional events."}]}]},{"content":"Remarks","pos":[6347,6354]},{"pos":[6358,6424],"content":"Multiple <bpt id=\"p1\">**</bpt>/fp<ept id=\"p1\">**</ept> options can be specified in the same compilation.","source":"Multiple **/fp** options can be specified in the same compilation."},{"content":"To control floating-point behavior by function, see the <bpt id=\"p1\">[</bpt>float_control<ept id=\"p1\">](../../preprocessor/float-control.md)</ept> pragma.","pos":[6431,6547],"source":"To control floating-point behavior by function, see the [float_control](../../preprocessor/float-control.md) pragma."},{"content":"This overrides the <bpt id=\"p1\">**</bpt>/fp<ept id=\"p1\">**</ept> compiler setting.","pos":[6548,6592],"source":" This overrides the **/fp** compiler setting."},{"content":"We recommend you save and restore local floating-point behavior as good engineering practice:","pos":[6593,6686]},{"content":"Most of the floating-point optimizations related to <bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/fp:except<ept id=\"p2\">**</ept> (and its corresponding pragmas), and the <ph id=\"ph1\">`fp_contract`</ph> pragma are machine-dependent.","pos":[6820,6987],"source":"Most of the floating-point optimizations related to **/fp:strict**, **/fp:except** (and its corresponding pragmas), and the `fp_contract` pragma are machine-dependent."},{"content":"<bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/fp:except<ept id=\"p2\">**</ept> are not compatible with <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept>.","pos":[6988,7055],"source":"**/fp:strict** and **/fp:except** are not compatible with **/clr**."},{"content":"<bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> should address most of an application's floating-point requirements.","pos":[7062,7146],"source":"**/fp:precise** should address most of an application's floating-point requirements."},{"content":"You can use <bpt id=\"p1\">**</bpt>/fp:except<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/fp:strict<ept id=\"p2\">**</ept>, but there may be some decrease in performance.","pos":[7147,7240],"source":" You can use **/fp:except** and **/fp:strict**, but there may be some decrease in performance."},{"content":"If performance is most important, consider whether to use <bpt id=\"p1\">**</bpt>/fp:fast<ept id=\"p1\">**</ept>.","pos":[7241,7312],"source":" If performance is most important, consider whether to use **/fp:fast**."},{"content":"<bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/fp:fast<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>/fp:precise<ept id=\"p3\">**</ept> are precision (correctness) modes.","pos":[7319,7403],"source":"**/fp:strict**, **/fp:fast**, and **/fp:precise** are precision (correctness) modes."},{"content":"Only one can be in effect at a time.","pos":[7404,7440]},{"content":"If both <bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/fp:precise<ept id=\"p2\">**</ept> are specified, the compiler uses the one that it processes last.","pos":[7441,7548],"source":" If both **/fp:strict** and **/fp:precise** are specified, the compiler uses the one that it processes last."},{"content":"Both <bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/fp:fast<ept id=\"p2\">**</ept> cannot be specified.","pos":[7549,7606],"source":" Both **/fp:strict** and **/fp:fast** cannot be specified."},{"pos":[7613,7739],"content":"For more information, see <bpt id=\"p1\">[</bpt>Microsoft Visual C++ Floating-Point Optimization<ept id=\"p1\">](http://msdn.microsoft.com/library/aa289157.aspx)</ept>.","source":"For more information, see [Microsoft Visual C++ Floating-Point Optimization](http://msdn.microsoft.com/library/aa289157.aspx)."},{"content":"To set this compiler option in the Visual Studio development environment","pos":[7749,7821]},{"content":"Open the project's <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept> dialog box.","pos":[7831,7880],"source":"Open the project's **Property Pages** dialog box."},{"content":"For details, see <bpt id=\"p1\">[</bpt>Working with Project Properties<ept id=\"p1\">](../../ide/working-with-project-properties.md)</ept>.","pos":[7881,7978],"source":" For details, see [Working with Project Properties](../../ide/working-with-project-properties.md)."},{"pos":[7988,8033],"content":"Expand the <bpt id=\"p1\">**</bpt>Configuration Properties<ept id=\"p1\">**</ept> node.","source":"Expand the **Configuration Properties** node."},{"pos":[8043,8069],"content":"Expand the <bpt id=\"p1\">**</bpt>C/C++<ept id=\"p1\">**</ept> node.","source":"Expand the **C/C++** node."},{"pos":[8079,8124],"content":"Select the <bpt id=\"p1\">**</bpt>Code Generation<ept id=\"p1\">**</ept> property page.","source":"Select the **Code Generation** property page."},{"pos":[8134,8179],"content":"Modify the <bpt id=\"p1\">**</bpt>Floating Point Model<ept id=\"p1\">**</ept> property.","source":"Modify the **Floating Point Model** property."},{"content":"To set this compiler option programmatically","pos":[8189,8233]},{"content":"See &lt;xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A&gt;.","pos":[8243,8332],"source":"See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A>."},{"content":"See Also","pos":[8341,8349]},{"content":"Compiler Options","pos":[8354,8370]},{"content":"Setting Compiler Options","pos":[8420,8444]},{"content":"Microsoft Visual C++ Floating Point Optimization","pos":[8502,8550]}],"content":"---\ntitle: \"-fp (Specify Floating-Point Behavior) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"VC.Project.VCCLCompilerTool.floatingPointModel\"\n  - \"VC.Project.VCCLWCECompilerTool.FloatingPointExceptions\"\n  - \"/fp\"\n  - \"VC.Project.VCCLWCECompilerTool.floatingPointModel\"\n  - \"VC.Project.VCCLCompilerTool.FloatingPointExceptions\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"-fp compiler option [C++]\"\n  - \"/fp compiler option [C++]\"\nms.assetid: 10469d6b-e68b-4268-8075-d073f4f5d57e\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# /fp (Specify Floating-Point Behavior)\nSpecifies floating-point behavior in a source code file.  \n  \n## Syntax  \n  \n```  \n/fp:[precise | except[-] | fast | strict ]  \n```  \n  \n## Flags  \n **precise**  \n The default.  \n  \n Improves the consistency of floating-point tests for equality and inequality by disabling optimizations that could change the precision of floating-point calculations. (Maintaining specific precision is required for strict ANSI conformance.) By default, in code for x86 architectures the compiler uses the coprocessor's 80-bit registers to hold the intermediate results of floating-point calculations. This increases program speed and decreases program size. However, because the calculation involves floating-point data types that are represented in memory by less than 80 bits, carrying the extra bits of precision—80 bits minus the number of bits in a smaller floating-point type—through a lengthy calculation can produce inconsistent results.  \n  \n With **/fp:precise** on x86 processors, the compiler performs rounding on variables of type `float` to the correct precision for assignments and casts and when parameters are passed to a function. This rounding guarantees that the data does not retain any significance greater than the capacity of its type. A program compiled with **/fp:precise** can be slower and larger than one compiled without **/fp:precise**. **/fp:precise** disables intrinsics; the standard run-time library routines are used instead. For more information, see [/Oi (Generate Intrinsic Functions)](../../build/reference/oi-generate-intrinsic-functions.md).  \n  \n The following floating-point behavior is enabled with **/fp:precise**:  \n  \n-   Contractions—that is, using a composite operation that has just one rounding at the end to replace multiple operations.  \n  \n-   Expression optimizations that are invalid for special values (NaN, +infinity, -infinity, +0, -0) are not allowed. The optimizations x-x => 0, x*0 => 0, x-0 => x, x+0 => x, and 0-x => -x are invalid for various reasons. (See IEEE 754 and the C99 standard.)  \n  \n-   The compiler correctly handles comparisons that involve NaN. For example, x != x evaluates to **true** if `x` is NaN and ordered comparisons involving NaN raise an exception.  \n  \n-   Expression evaluation follows the C99 FLT_EVAL_METHOD=2, with this exception: When you program for x86 processors, because the FPU is set to 53-bit precision, this is considered long-double precision.  \n  \n-   Multiplication by exactly 1.0 transformed into a use of the other factor. x*y\\*1.0 is transformed into x\\*y. Similarly, x\\*1.0\\*y is transformed into x\\*y.  \n  \n-   Division by exactly 1.0 is transformed into a use of the dividend. x*y/1.0 is transformed into x\\*y. Similarly, x/1.0\\*y is transformed into x\\*y.  \n  \n Using **/fp:precise** when [fenv_access](../../preprocessor/fenv-access.md) is ON disables optimizations such as compile-time evaluations of floating-point expressions. For example, if you use [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md) to change the rounding mode, and the compiler performs a floating-point calculation, the rounding mode you specified is not in effect unless `fenv_access` is ON.  \n  \n **/fp:precise** replaces the **/Op** compiler option.  \n  \n **fast**  \n Creates the fastest code in most cases by relaxing the rules for optimizing floating-point operations. This enables the compiler to optimize floating-point code for speed at the expense of accuracy and correctness. When **/fp:fast** is specified, the compiler may not round correctly at assignment statements, typecasts, or function calls, and may not perform rounding of intermediate expressions. The compiler may reorder operations or perform algebraic transforms—for example, by following associative and distributive rules—without regard to the effect on finite precision results. The compiler may change operations and operands to single-precision instead of following the C++ type promotion rules. Floating-point-specific contraction optimizations are always enabled ([fp_contract](../../preprocessor/fp-contract.md) is ON). Floating-point exceptions and FPU environment access are disabled (**/fp:except-** is implied and [fenv_access](../../preprocessor/fenv-access.md) is OFF).  \n  \n **/fp:fast** cannot be used with **/fp:strict** or **/fp:precise**. The last option specified on the command line is used. Specifying both **/fp:fast** and **/fp:except** generates a compiler error.  \n  \n Specifying [/Za, /Ze (Disable Language Extensions)](../../build/reference/za-ze-disable-language-extensions.md) (ANSI compatibility) and **/fp:fast** may cause unexpected behavior. For example, single-precision floating-point operations may not be rounded to single precision.  \n  \n **except[-]**  \n Reliable floating-point exception model. Exceptions are raised immediately after they are triggered. By default, this option is off. Appending a minus sign to the option explicitly disables it.  \n  \n **strict**  \n The strictest floating-point model. **/fp:strict** causes [fp_contract](../../preprocessor/fp-contract.md) to be OFF and [fenv_access](../../preprocessor/fenv-access.md) to be ON. **/fp:except** is implied and can be disabled by explicitly specifying **/fp:except-**. When used with **/fp:except-**, **/fp:strict** enforces strict floating-point semantics but without respect for exceptional events.  \n  \n## Remarks  \n Multiple **/fp** options can be specified in the same compilation.  \n  \n To control floating-point behavior by function, see the [float_control](../../preprocessor/float-control.md) pragma. This overrides the **/fp** compiler setting. We recommend you save and restore local floating-point behavior as good engineering practice:  \n  \n```css  \n#pragma float_control(precise, on, push)  \n// Code that uses /fp:precise mode  \n#pragma float_control(pop)  \n```  \n  \n Most of the floating-point optimizations related to **/fp:strict**, **/fp:except** (and its corresponding pragmas), and the `fp_contract` pragma are machine-dependent. **/fp:strict** and **/fp:except** are not compatible with **/clr**.  \n  \n **/fp:precise** should address most of an application's floating-point requirements. You can use **/fp:except** and **/fp:strict**, but there may be some decrease in performance. If performance is most important, consider whether to use **/fp:fast**.  \n  \n **/fp:strict**, **/fp:fast**, and **/fp:precise** are precision (correctness) modes. Only one can be in effect at a time. If both **/fp:strict** and **/fp:precise** are specified, the compiler uses the one that it processes last. Both **/fp:strict** and **/fp:fast** cannot be specified.  \n  \n For more information, see [Microsoft Visual C++ Floating-Point Optimization](http://msdn.microsoft.com/library/aa289157.aspx).  \n  \n### To set this compiler option in the Visual Studio development environment  \n  \n1.  Open the project's **Property Pages** dialog box. For details, see [Working with Project Properties](../../ide/working-with-project-properties.md).  \n  \n2.  Expand the **Configuration Properties** node.  \n  \n3.  Expand the **C/C++** node.  \n  \n4.  Select the **Code Generation** property page.  \n  \n5.  Modify the **Floating Point Model** property.  \n  \n### To set this compiler option programmatically  \n  \n-   See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A>.  \n  \n## See Also  \n [Compiler Options](../../build/reference/compiler-options.md)   \n [Setting Compiler Options](../../build/reference/setting-compiler-options.md)   \n [Microsoft Visual C++ Floating Point Optimization](http://msdn.microsoft.com/library/aa289157.aspx)"}