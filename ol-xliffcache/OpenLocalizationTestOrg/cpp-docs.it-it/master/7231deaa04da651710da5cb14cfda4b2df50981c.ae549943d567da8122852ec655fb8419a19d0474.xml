{"nodes":[{"pos":[12,67],"content":"Regular DLLs Dynamically Linked to MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Regular DLLs Dynamically Linked to MFC | Microsoft Docs","pos":[0,55]}]},{"content":"Regular DLLs Dynamically Linked to MFC","pos":[744,782]},{"content":"A regular DLL dynamically linked to MFC is a DLL that uses MFC internally, and the exported functions in the DLL can be called by either MFC or non-MFC executables.","pos":[783,947]},{"content":"As the name describes, this kind of DLL is built using the dynamic-link library version of MFC (also known as the shared version of MFC).","pos":[948,1085]},{"content":"Functions are usually exported from a regular DLL using the standard C interface.","pos":[1086,1167]},{"content":"You must add the <ph id=\"ph1\">`AFX_MANAGE_STATE`</ph> macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC to set the current module state to the one for the DLL.","pos":[1174,1363],"source":"You must add the `AFX_MANAGE_STATE` macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC to set the current module state to the one for the DLL."},{"content":"This is done by adding the following line of code to the beginning of functions exported from the DLL:","pos":[1364,1466]},{"content":"A regular DLL, dynamically linked to MFC has the following features:","pos":[1535,1603]},{"content":"This is a new type of DLL introduced by Visual C++ 4.0.","pos":[1613,1668]},{"content":"The client executable can be written in any language that supports the use of DLLs (C, C++, Pascal, Visual Basic, and so on); it does not have to be an MFC application.","pos":[1678,1846]},{"content":"Unlike the statically linked regular DLL, this type of DLL is dynamically linked to the MFC DLL (also known as the shared MFC DLL).","pos":[1856,1987]},{"content":"The MFC import library linked to this type of DLL is the same one used for extension DLLs or applications using the MFC DLL: MFCxx(D).lib.","pos":[1997,2135]},{"content":"A regular DLL, dynamically linked to MFC has the following requirements:","pos":[2142,2214]},{"content":"These DLLs are compiled with <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> defined, just like an executable that is dynamically linked to the MFC DLL.","pos":[2224,2340],"source":"These DLLs are compiled with **_AFXDLL** defined, just like an executable that is dynamically linked to the MFC DLL."},{"content":"But <bpt id=\"p1\">**</bpt>_USRDLL<ept id=\"p1\">**</ept> is also defined, just like a regular DLL that is statically linked to MFC.","pos":[2341,2431],"source":" But **_USRDLL** is also defined, just like a regular DLL that is statically linked to MFC."},{"pos":[2441,2501],"content":"This type of DLL must instantiate a <ph id=\"ph1\">`CWinApp`</ph>-derived class.","source":"This type of DLL must instantiate a `CWinApp`-derived class."},{"content":"This type of DLL uses the <ph id=\"ph1\">`DllMain`</ph> provided by MFC.","pos":[2511,2563],"source":"This type of DLL uses the `DllMain` provided by MFC."},{"content":"Place all DLL-specific initialization code in the <ph id=\"ph1\">`InitInstance`</ph> member function and termination code in <ph id=\"ph2\">`ExitInstance`</ph> as in a normal MFC application.","pos":[2564,2715],"source":" Place all DLL-specific initialization code in the `InitInstance` member function and termination code in `ExitInstance` as in a normal MFC application."},{"content":"Because this kind of DLL uses the dynamic-link library version of MFC, you must explicitly set the current module state to the one for the DLL.","pos":[2722,2865]},{"content":"To do this, use the <bpt id=\"p1\">[</bpt>AFX_MANAGE_STATE<ept id=\"p1\">](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606)</ept> macro at the beginning of every function exported from the DLL.","pos":[2866,3040],"source":" To do this, use the [AFX_MANAGE_STATE](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606) macro at the beginning of every function exported from the DLL."},{"content":"Regular DLLs must have a <ph id=\"ph1\">`CWinApp`</ph>-derived class and a single object of that application class, as does an MFC application.","pos":[3047,3170],"source":"Regular DLLs must have a `CWinApp`-derived class and a single object of that application class, as does an MFC application."},{"content":"However, the <ph id=\"ph1\">`CWinApp`</ph> object of the DLL does not have a main message pump, as does the <ph id=\"ph2\">`CWinApp`</ph> object of an application.","pos":[3171,3294],"source":" However, the `CWinApp` object of the DLL does not have a main message pump, as does the `CWinApp` object of an application."},{"content":"Note that the <ph id=\"ph1\">`CWinApp::Run`</ph> mechanism does not apply to a DLL, because the application owns the main message pump.","pos":[3301,3416],"source":"Note that the `CWinApp::Run` mechanism does not apply to a DLL, because the application owns the main message pump."},{"content":"If your DLL brings up modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls <ph id=\"ph1\">`CWinApp::PreTranslateMessage`</ph>.","pos":[3417,3607],"source":" If your DLL brings up modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls `CWinApp::PreTranslateMessage`."},{"content":"Place all DLL-specific initialization in the <ph id=\"ph1\">`CWinApp::InitInstance`</ph> member function as in a normal MFC application.","pos":[3614,3730],"source":"Place all DLL-specific initialization in the `CWinApp::InitInstance` member function as in a normal MFC application."},{"content":"The <ph id=\"ph1\">`CWinApp::ExitInstance`</ph> member function of your <ph id=\"ph2\">`CWinApp`</ph> derived class is called from the MFC provided <ph id=\"ph3\">`DllMain`</ph> function before the DLL is unloaded.","pos":[3731,3885],"source":" The `CWinApp::ExitInstance` member function of your `CWinApp` derived class is called from the MFC provided `DllMain` function before the DLL is unloaded."},{"content":"You must distribute the shared DLLs MFCx0.dll and Msvcr*0.dll (or similar files) with your application.","pos":[3892,3995]},{"content":"A DLL that is dynamically linked to MFC cannot also statically link to MFC.","pos":[4002,4077]},{"content":"Applications link to regular DLLs dynamically linked to MFC it just like any other DLL.","pos":[4078,4165]},{"content":"Symbols are usually exported from a regular DLL using the standard C interface.","pos":[4172,4251]},{"content":"The declaration of a function exported from a regular DLL looks something like this:","pos":[4252,4336]},{"content":"All memory allocations within a regular DLL should stay within the DLL; the DLL should not pass to or receive from the calling executable any of the following:","pos":[4416,4575]},{"content":"pointers to MFC objects","pos":[4585,4608]},{"content":"pointers to memory allocated by MFC","pos":[4618,4653]},{"content":"If you need to do any of the above, or if you need to pass MFC-derived objects between the calling executable and the DLL, then you must build an extension DLL.","pos":[4660,4820]},{"content":"It is safe to pass pointers to memory that were allocated by the C run-time libraries between an application and a DLL only if you make a copy of the data.","pos":[4827,4982]},{"content":"You must not delete or resize these pointers or use them without making a copy of the memory.","pos":[4983,5076]},{"content":"When building a regular DLL that dynamically links to MFC, you need to use the macro <bpt id=\"p1\">[</bpt>AFX_MANAGE_STATE<ept id=\"p1\">](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606)</ept> to switch the MFC module state correctly.","pos":[5083,5300],"source":"When building a regular DLL that dynamically links to MFC, you need to use the macro [AFX_MANAGE_STATE](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606) to switch the MFC module state correctly."},{"content":"This is done by adding the following line of code to the beginning of functions exported from the DLL:","pos":[5301,5403]},{"content":"The <bpt id=\"p1\">**</bpt>AFX_MANAGE_STATE<ept id=\"p1\">**</ept> macro should not be used in regular DLLs that statically link to MFC or in extension DLLs.","pos":[5472,5587],"source":"The **AFX_MANAGE_STATE** macro should not be used in regular DLLs that statically link to MFC or in extension DLLs."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Managing the State Data of MFC Modules<ept id=\"p1\">](../mfc/managing-the-state-data-of-mfc-modules.md)</ept>.","pos":[5588,5705],"source":" For more information, see [Managing the State Data of MFC Modules](../mfc/managing-the-state-data-of-mfc-modules.md)."},{"content":"For an example of how to write, build, and use a regular DLL, see the sample <bpt id=\"p1\">[</bpt>DLLScreenCap<ept id=\"p1\">](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a)</ept>.","pos":[5712,5874],"source":"For an example of how to write, build, and use a regular DLL, see the sample [DLLScreenCap](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a)."},{"content":"For more information about regular DLLs that dynamically link to MFC, see the section titled \"Converting DLLScreenCap to Dynamically Link with the MFC DLL\" in the abstract for the sample.","pos":[5875,6062]},{"content":"What do you want to do?","pos":[6071,6094]},{"content":"Initialize regular DLLs","pos":[6105,6128]},{"content":"What do you want to know more about?","pos":[6177,6213]},{"content":"The module states of a regular DLL dynamically linked to MFC","pos":[6224,6284]},{"content":"Managing the state data of MFC modules","pos":[6366,6404]},{"content":"Using Database, OLE, and Sockets Extension DLLs in Regular DLLs","pos":[6466,6529]},{"content":"Using MFC as Part of a DLL","pos":[6616,6642]},{"content":"See Also","pos":[6696,6704]},{"content":"Kinds of DLLs","pos":[6709,6722]}],"content":"---\ntitle: \"Regular DLLs Dynamically Linked to MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regular DLLs [C++], dynamically linked to MFC\"\n  - \"AFX_MANAGE_STATE macro\"\n  - \"DLLs [C++], regular\"\n  - \"shared DLL versions [C++]\"\n  - \"dynamically linked DLLs [C++]\"\nms.assetid: b4f7ab92-8723-42a5-890e-214f4e29dcd0\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Regular DLLs Dynamically Linked to MFC\nA regular DLL dynamically linked to MFC is a DLL that uses MFC internally, and the exported functions in the DLL can be called by either MFC or non-MFC executables. As the name describes, this kind of DLL is built using the dynamic-link library version of MFC (also known as the shared version of MFC). Functions are usually exported from a regular DLL using the standard C interface.  \n  \n You must add the `AFX_MANAGE_STATE` macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC to set the current module state to the one for the DLL. This is done by adding the following line of code to the beginning of functions exported from the DLL:  \n  \n```  \nAFX_MANAGE_STATE(AfxGetStaticModuleState( ))  \n```  \n  \n A regular DLL, dynamically linked to MFC has the following features:  \n  \n-   This is a new type of DLL introduced by Visual C++ 4.0.  \n  \n-   The client executable can be written in any language that supports the use of DLLs (C, C++, Pascal, Visual Basic, and so on); it does not have to be an MFC application.  \n  \n-   Unlike the statically linked regular DLL, this type of DLL is dynamically linked to the MFC DLL (also known as the shared MFC DLL).  \n  \n-   The MFC import library linked to this type of DLL is the same one used for extension DLLs or applications using the MFC DLL: MFCxx(D).lib.  \n  \n A regular DLL, dynamically linked to MFC has the following requirements:  \n  \n-   These DLLs are compiled with **_AFXDLL** defined, just like an executable that is dynamically linked to the MFC DLL. But **_USRDLL** is also defined, just like a regular DLL that is statically linked to MFC.  \n  \n-   This type of DLL must instantiate a `CWinApp`-derived class.  \n  \n-   This type of DLL uses the `DllMain` provided by MFC. Place all DLL-specific initialization code in the `InitInstance` member function and termination code in `ExitInstance` as in a normal MFC application.  \n  \n Because this kind of DLL uses the dynamic-link library version of MFC, you must explicitly set the current module state to the one for the DLL. To do this, use the [AFX_MANAGE_STATE](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606) macro at the beginning of every function exported from the DLL.  \n  \n Regular DLLs must have a `CWinApp`-derived class and a single object of that application class, as does an MFC application. However, the `CWinApp` object of the DLL does not have a main message pump, as does the `CWinApp` object of an application.  \n  \n Note that the `CWinApp::Run` mechanism does not apply to a DLL, because the application owns the main message pump. If your DLL brings up modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls `CWinApp::PreTranslateMessage`.  \n  \n Place all DLL-specific initialization in the `CWinApp::InitInstance` member function as in a normal MFC application. The `CWinApp::ExitInstance` member function of your `CWinApp` derived class is called from the MFC provided `DllMain` function before the DLL is unloaded.  \n  \n You must distribute the shared DLLs MFCx0.dll and Msvcr*0.dll (or similar files) with your application.  \n  \n A DLL that is dynamically linked to MFC cannot also statically link to MFC. Applications link to regular DLLs dynamically linked to MFC it just like any other DLL.  \n  \n Symbols are usually exported from a regular DLL using the standard C interface. The declaration of a function exported from a regular DLL looks something like this:  \n  \n```  \nextern \"C\" __declspec(dllexport) MyExportedFunction( );  \n```  \n  \n All memory allocations within a regular DLL should stay within the DLL; the DLL should not pass to or receive from the calling executable any of the following:  \n  \n-   pointers to MFC objects  \n  \n-   pointers to memory allocated by MFC  \n  \n If you need to do any of the above, or if you need to pass MFC-derived objects between the calling executable and the DLL, then you must build an extension DLL.  \n  \n It is safe to pass pointers to memory that were allocated by the C run-time libraries between an application and a DLL only if you make a copy of the data. You must not delete or resize these pointers or use them without making a copy of the memory.  \n  \n When building a regular DLL that dynamically links to MFC, you need to use the macro [AFX_MANAGE_STATE](http://msdn.microsoft.com/Library/620cb840-4227-4a75-b36d-f7d507f44606) to switch the MFC module state correctly. This is done by adding the following line of code to the beginning of functions exported from the DLL:  \n  \n```  \nAFX_MANAGE_STATE(AfxGetStaticModuleState( ))  \n```  \n  \n The **AFX_MANAGE_STATE** macro should not be used in regular DLLs that statically link to MFC or in extension DLLs. For more information, see [Managing the State Data of MFC Modules](../mfc/managing-the-state-data-of-mfc-modules.md).  \n  \n For an example of how to write, build, and use a regular DLL, see the sample [DLLScreenCap](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a). For more information about regular DLLs that dynamically link to MFC, see the section titled \"Converting DLLScreenCap to Dynamically Link with the MFC DLL\" in the abstract for the sample.  \n  \n## What do you want to do?  \n  \n-   [Initialize regular DLLs](../build/initializing-regular-dlls.md)  \n  \n## What do you want to know more about?  \n  \n-   [The module states of a regular DLL dynamically linked to MFC](../build/module-states-of-a-regular-dll-dynamically-linked-to-mfc.md)  \n  \n-   [Managing the state data of MFC modules](../mfc/managing-the-state-data-of-mfc-modules.md)  \n  \n-   [Using Database, OLE, and Sockets Extension DLLs in Regular DLLs](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  \n  \n-   [Using MFC as Part of a DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md)  \n  \n## See Also  \n [Kinds of DLLs](../build/kinds-of-dlls.md)"}