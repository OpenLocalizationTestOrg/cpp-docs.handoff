{"nodes":[{"pos":[12,54],"content":"TN033: DLL Version of MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN033: DLL Version of MFC | Microsoft Docs","pos":[0,42]}]},{"content":"TN033: DLL Version of MFC","pos":[719,744]},{"content":"This note describes how you can use the MFCxx.DLL and MFCxxD.DLL (where x is the MFC version number) shared dynamic link libraries with MFC applications and extension DLLs.","pos":[745,917]},{"content":"For more information about regular DLLs, see <bpt id=\"p1\">[</bpt>Using MFC as Part of a DLL<ept id=\"p1\">](../mfc/tn011-using-mfc-as-part-of-a-dll.md)</ept>.","pos":[918,1036],"source":" For more information about regular DLLs, see [Using MFC as Part of a DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md)."},{"content":"This technical note covers three aspects of DLLs.","pos":[1043,1092]},{"content":"The last two are for the more advanced users:","pos":[1093,1138]},{"content":"How you build an MFC Extension DLL","pos":[1147,1181]},{"content":"How you build an MFC application that uses the DLL version of MFC","pos":[1237,1302]},{"content":"How the MFC shared dynamic-link libraries are implemented","pos":[1373,1430]},{"pos":[1483,1681],"content":"If you are interested in building a DLL using MFC that can be used with non-MFC applications (this is called a regular DLL), refer to <bpt id=\"p1\">[</bpt>Technical Note 11<ept id=\"p1\">](../mfc/tn011-using-mfc-as-part-of-a-dll.md)</ept>.","source":"If you are interested in building a DLL using MFC that can be used with non-MFC applications (this is called a regular DLL), refer to [Technical Note 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md)."},{"content":"Overview of MFCxx.DLL Support: Terminology and Files","pos":[1690,1742]},{"content":"<bpt id=\"p1\">**</bpt>Regular DLL<ept id=\"p1\">**</ept>: You use a regular DLL to build a stand-alone DLL using some of the MFC classes.","pos":[1746,1842],"source":"**Regular DLL**: You use a regular DLL to build a stand-alone DLL using some of the MFC classes."},{"content":"Interfaces across the App/DLL boundary are \"C\" interfaces, and the client application does not have to be an MFC application.","pos":[1843,1968]},{"content":"This is the version of DLL support supported in MFC 1.0.","pos":[1975,2031]},{"content":"It is described in <bpt id=\"p1\">[</bpt>Technical Note 11<ept id=\"p1\">](../mfc/tn011-using-mfc-as-part-of-a-dll.md)</ept> and the MFC Advanced Concepts sample <bpt id=\"p2\">[</bpt>DLLScreenCap<ept id=\"p2\">](../visual-cpp-samples.md)</ept>.","pos":[2032,2193],"source":" It is described in [Technical Note 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) and the MFC Advanced Concepts sample [DLLScreenCap](../visual-cpp-samples.md)."},{"pos":[2201,2406],"content":"[!NOTE]\n As of Visual C++ version 4.0, the term **USRDLL** is obsolete and has been replaced by a regular DLL that statically links to MFC. You may also build a regular DLL that dynamically links to MFC.","leadings":["","> "],"nodes":[{"content":" As of Visual C++ version 4.0, the term **USRDLL** is obsolete and has been replaced by a regular DLL that statically links to MFC. You may also build a regular DLL that dynamically links to MFC.","pos":[8,203],"nodes":[{"content":"As of Visual C++ version 4.0, the term <bpt id=\"p1\">**</bpt>USRDLL<ept id=\"p1\">**</ept> is obsolete and has been replaced by a regular DLL that statically links to MFC.","pos":[1,131],"source":" As of Visual C++ version 4.0, the term **USRDLL** is obsolete and has been replaced by a regular DLL that statically links to MFC."},{"content":"You may also build a regular DLL that dynamically links to MFC.","pos":[132,195]}]}]},{"content":"MFC 3.0 (and above) supports regular DLLs with all the new functionality including the OLE and Database classes.","pos":[2413,2525]},{"content":"<bpt id=\"p1\">**</bpt>AFXDLL<ept id=\"p1\">**</ept>: This is also referred to as the shared version of the MFC libraries.","pos":[2532,2612],"source":"**AFXDLL**: This is also referred to as the shared version of the MFC libraries."},{"content":"This is the new DLL support added in MFC 2.0.","pos":[2613,2658]},{"content":"The MFC library itself is in a number of DLLs (described below) and a client application or DLL dynamically links the DLLs that it requires.","pos":[2659,2799]},{"content":"Interfaces across the application/DLL boundary are C++/MFC class interfaces.","pos":[2800,2876]},{"content":"The client application MUST be an MFC application.","pos":[2877,2927]},{"content":"This supports all MFC 3.0 functionality (exception: UNICODE is not supported for the database classes).","pos":[2928,3031]},{"pos":[3039,3134],"content":"[!NOTE]\n As of Visual C++ version 4.0, this type of DLL is referred to as an \"Extension DLL.\"","leadings":["","> "],"nodes":[{"content":"As of Visual C++ version 4.0, this type of DLL is referred to as an \"Extension DLL.\"","pos":[9,93]}]},{"content":"This note will use MFCxx.DLL to refer to the entire MFC DLL set, which includes:","pos":[3141,3221]},{"content":"Debug: MFCxxD.DLL (combined) and MFCSxxD.LIB (static).","pos":[3231,3285]},{"content":"Release: MFCxx.DLL (combined) and MFCSxx.LIB (static).","pos":[3295,3349]},{"content":"Unicode Debug: MFCxxUD.DLL (combined) and MFCSxxD.LIB (static).","pos":[3359,3422]},{"content":"Unicode Release: MFCxxU.DLL (combined) and MFCSxxU.LIB (static).","pos":[3432,3496]},{"pos":[3504,3682],"content":"[!NOTE]\n The MFCSxx[U][D].LIB libraries are used in conjunction with the MFC shared DLLs. These libraries contain code that must be statically linked to the application or DLL.","leadings":["","> "],"nodes":[{"content":" The MFCSxx[U][D].LIB libraries are used in conjunction with the MFC shared DLLs. These libraries contain code that must be statically linked to the application or DLL.","pos":[8,176],"nodes":[{"content":"The MFCSxx[U][D].LIB libraries are used in conjunction with the MFC shared DLLs.","pos":[1,81]},{"content":"These libraries contain code that must be statically linked to the application or DLL.","pos":[82,168]}]}]},{"content":"An application links to the corresponding import libraries:","pos":[3689,3748]},{"content":"Debug: MFCxxD.LIB","pos":[3758,3775]},{"content":"Release: MFCxx.LIB","pos":[3785,3803]},{"content":"Unicode Debug: MFCxxUD.LIB","pos":[3813,3839]},{"content":"Unicode Release: MFCxxU.LIB","pos":[3849,3876]},{"content":"An \"MFC Extension DLL\" is a DLL built upon MFCxx.DLL (and/or the other MFC shared DLLs).","pos":[3883,3971]},{"content":"Here the MFC component architecture kicks in.","pos":[3972,4017]},{"content":"If you derive a useful class from an MFC class, or build another MFC-like toolkit, you can place it in a DLL.","pos":[4018,4127]},{"content":"That DLL uses MFCxx.DLL, as does the ultimate client application.","pos":[4128,4193]},{"content":"This permits reusable leaf classes, reusable base classes, and reusable view/document classes.","pos":[4194,4288]},{"content":"Pros and Cons","pos":[4297,4310]},{"content":"Why should you use the shared version of MFC","pos":[4314,4358]},{"content":"Using the shared library can result in smaller applications (a minimal application that uses most of the MFC library is less than 10K).","pos":[4368,4503]},{"content":"The shared version of MFC supports MFC Extension DLLs and regular DLLs.","pos":[4513,4584]},{"content":"Building an application that uses the shared MFC libraries is faster than building a statically linked MFC application because it is not necessary to link MFC itself.","pos":[4594,4760]},{"content":"This is especially true in <bpt id=\"p1\">**</bpt>DEBUG<ept id=\"p1\">**</ept> builds where the linker must compact the debug information — by linking with a DLL that already contains the debug information, there is less debug information to compact within your application.","pos":[4761,4993],"source":" This is especially true in **DEBUG** builds where the linker must compact the debug information — by linking with a DLL that already contains the debug information, there is less debug information to compact within your application."},{"content":"Why should you not use the shared version of MFC:","pos":[5000,5049]},{"content":"Shipping an application that uses the shared library requires that you ship the MFCxx.DLL (and others) library with your program.","pos":[5059,5188]},{"content":"MFCxx.DLL is freely redistributable like many DLLs, but you still must install the DLL in your SETUP program.","pos":[5189,5298]},{"content":"In addition, you must ship the MSVCRTxx.DLL, which contains the C-runtime library which is used both by your program and the MFC DLLs themselves.","pos":[5299,5444]},{"pos":[5513,5546],"content":"How to Write an MFC Extension DLL"},{"content":"An MFC Extension DLL is a DLL containing classes and functions written to embellish the functionality of the MFC classes.","pos":[5550,5671]},{"content":"An MFC Extension DLL uses the shared MFC DLLs in the same way an application uses it, with a few additional considerations:","pos":[5672,5795]},{"content":"The build process is similar to building an application that uses the shared MFC libraries with a few additional compiler and linker options.","pos":[5805,5946]},{"pos":[5956,6017],"content":"An MFC Extension DLL does not have a <ph id=\"ph1\">`CWinApp`</ph>-derived class.","source":"An MFC Extension DLL does not have a `CWinApp`-derived class."},{"content":"An MFC Extension DLL must provide a special <ph id=\"ph1\">`DllMain`</ph>.","pos":[6027,6081],"source":"An MFC Extension DLL must provide a special `DllMain`."},{"content":"AppWizard supplies a <ph id=\"ph1\">`DllMain`</ph> function that you can modify.","pos":[6082,6142],"source":" AppWizard supplies a `DllMain` function that you can modify."},{"content":"An MFC Extension DLL will usually provide an initialization routine to create a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> if the extension DLL wishes to export <ph id=\"ph1\">`CRuntimeClass`</ph>es or resources to the application.","pos":[6152,6340],"source":"An MFC Extension DLL will usually provide an initialization routine to create a **CDynLinkLibrary** if the extension DLL wishes to export `CRuntimeClass`es or resources to the application."},{"content":"A derived class of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> may be used if per-application data must be maintained by the extension DLL.","pos":[6341,6456],"source":" A derived class of **CDynLinkLibrary** may be used if per-application data must be maintained by the extension DLL."},{"content":"These considerations are described in more detail below.","pos":[6463,6519]},{"content":"You should also refer to the MFC Advanced Concepts sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](../visual-cpp-samples.md)</ept> since it illustrates:","pos":[6520,6635],"source":" You should also refer to the MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md) since it illustrates:"},{"content":"Building an application using the shared libraries.","pos":[6645,6696]},{"content":"(DLLHUSK.EXE is an MFC application that dynamically links to the MFC libraries as well as other DLLs.)","pos":[6697,6799]},{"content":"Building an MFC Extension DLL.","pos":[6809,6839]},{"content":"(Note the special flags such as <ph id=\"ph1\">`_AFXEXT`</ph> that are used in building an extension DLL)","pos":[6840,6925],"source":" (Note the special flags such as `_AFXEXT` that are used in building an extension DLL)"},{"content":"Two examples of MFC Extension DLLs.","pos":[6935,6970]},{"content":"One shows the basic structure of an MFC Extension DLL with limited exports (TESTDLL1) and the other shows exporting an entire class interface (TESTDLL2).","pos":[6971,7124]},{"content":"Both the client application and any extension DLLs must use the same version of MFCxx.DLL.","pos":[7131,7221]},{"content":"You should follow the convention of MFC DLL and provide both a debug and retail (/release) version of your extension DLL.","pos":[7222,7343]},{"content":"This permits client programs to build both debug and retail versions of their applications and link them with the appropriate debug or retail version of all DLLs.","pos":[7344,7506]},{"pos":[7514,7830],"content":"[!NOTE]\n Because C++ name mangling and export issues, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCxx.DLL has about 2000 exported entry points; the debug MFCxxD.DLL has about 3000 exported entry points.","leadings":["","> "],"nodes":[{"content":" Because C++ name mangling and export issues, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCxx.DLL has about 2000 exported entry points; the debug MFCxxD.DLL has about 3000 exported entry points.","pos":[8,314],"nodes":[{"content":"Because C++ name mangling and export issues, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms.","pos":[1,188]},{"content":"The retail MFCxx.DLL has about 2000 exported entry points; the debug MFCxxD.DLL has about 3000 exported entry points.","pos":[189,306]}]}]},{"content":"Quick Note on Memory Management","pos":[7840,7871]},{"content":"The section titled \"Memory Management,\" near the end of this technical note, describes the implementation of the MFCxx.DLL with the shared version of MFC.","pos":[7875,8029]},{"content":"The information you need to know to implement just an extension DLL is described here.","pos":[8030,8116]},{"content":"MFCxx.DLL and all extension DLLs loaded into a client application's address space will use the same memory allocator, resource loading and other MFC \"global\" states as if they were in the same application.","pos":[8123,8328]},{"content":"This is significant because the non-MFC DLL libraries and regular DLLs that statically link to MFC do the exact opposite and have each DLL allocating out of its own memory pool.","pos":[8329,8506]},{"content":"If an extension DLL allocates memory, then that memory can freely intermix with any other application-allocated object.","pos":[8513,8632]},{"content":"Also, if an application that uses the shared MFC libraries crashes, the protection of the operating system will maintain the integrity of any other MFC application sharing the DLL.","pos":[8633,8813]},{"content":"Similarly other \"global\" MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCxx.DLL itself.","pos":[8820,9016]},{"content":"Building an Extension DLL","pos":[9026,9051]},{"content":"You can use AppWizard to create an MFC extension DLL project, and it will automatically generate the appropriate compiler and linker settings.","pos":[9055,9197]},{"content":"It was also generate a <ph id=\"ph1\">`DllMain`</ph> function that you can modify.","pos":[9198,9260],"source":" It was also generate a `DllMain` function that you can modify."},{"content":"If you are converting an existing project to an MFC extension DLL, start with the standard rules for building an application using the shared version of MFC, then do the following:","pos":[9267,9447]},{"content":"Add <bpt id=\"p1\">**</bpt>/D_AFXEXT<ept id=\"p1\">**</ept> to the compiler flags.","pos":[9457,9497],"source":"Add **/D_AFXEXT** to the compiler flags."},{"content":"On the Project Properties dialog, select the C/C++ node.","pos":[9498,9554]},{"content":"Then select the Preprocessor category.","pos":[9555,9593]},{"content":"Add <ph id=\"ph1\">`_AFXEXT`</ph> to the Define Macros field, separating each of the items with semicolons.","pos":[9594,9681],"source":" Add `_AFXEXT` to the Define Macros field, separating each of the items with semicolons."},{"content":"Remove the <bpt id=\"p1\">**</bpt>/Gy<ept id=\"p1\">**</ept> compiler switch.","pos":[9691,9726],"source":"Remove the **/Gy** compiler switch."},{"content":"On the Project Properties dialog, select the C/C++ node.","pos":[9727,9783]},{"content":"Then select the Code Generation category.","pos":[9784,9825]},{"content":"Ensure that the \"Enable Function-Level Linking\" option is not enabled.","pos":[9826,9896]},{"content":"This will make it easier to export classes because the linker will not remove unreferenced functions.","pos":[9897,9998]},{"content":"If the original project is used to build a Regular DLL statically linked to MFC, change the <bpt id=\"p1\">**</bpt>/MT[d]<ept id=\"p1\">**</ept> compiler option to <bpt id=\"p2\">**</bpt>/MD[d]<ept id=\"p2\">**</ept>.","pos":[9999,10132],"source":" If the original project is used to build a Regular DLL statically linked to MFC, change the **/MT[d]** compiler option to **/MD[d]**."},{"content":"Build an export library with the <bpt id=\"p1\">**</bpt>/DLL<ept id=\"p1\">**</ept> option to LINK.","pos":[10142,10199],"source":"Build an export library with the **/DLL** option to LINK."},{"content":"This will be set when you create a new target, specifying Win32 Dynamic-Link Library as the target type.","pos":[10200,10304]},{"content":"Changing your Header Files","pos":[10314,10340]},{"content":"The goal of an extension DLL is usually to export some common functionality to one or more applications that can use that functionality.","pos":[10344,10480]},{"content":"This boils down to exporting classes and global functions that are available for your client applications.","pos":[10481,10587]},{"content":"In order to do this you must insure that each of the member functions is marked as import or export as appropriate.","pos":[10594,10709]},{"content":"This requires special declarations: <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>__declspec(dllimport)<ept id=\"p2\">**</ept>.","pos":[10710,10802],"source":" This requires special declarations: **__declspec(dllexport)** and **__declspec(dllimport)**."},{"content":"When your classes are used by the client applications, you want them to be declared as <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept>.","pos":[10803,10916],"source":" When your classes are used by the client applications, you want them to be declared as **__declspec(dllimport)**."},{"content":"When the extension DLL itself is being built, they should be declared as <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept>.","pos":[10917,11016],"source":" When the extension DLL itself is being built, they should be declared as **__declspec(dllexport)**."},{"content":"In addition, the functions must be actually exported, so that the client programs bind to them at load time.","pos":[11017,11125]},{"content":"To export your entire class, use <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> in the class definition.","pos":[11132,11207],"source":"To export your entire class, use **AFX_EXT_CLASS** in the class definition."},{"content":"This macro is defined by the framework as <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> when <bpt id=\"p2\">**</bpt>_AFXDLL<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`_AFXEXT`</ph> is defined, but defined as <bpt id=\"p3\">**</bpt>__declspec(dllimport)<ept id=\"p3\">**</ept> when <ph id=\"ph2\">`_AFXEXT`</ph> is not defined.","pos":[11208,11390],"source":" This macro is defined by the framework as **__declspec(dllexport)** when **_AFXDLL** and `_AFXEXT` is defined, but defined as **__declspec(dllimport)** when `_AFXEXT` is not defined."},{"content":"as described above, is only defined when building your extension DLL.","pos":[11401,11470]},{"content":"For example:","pos":[11471,11483]},{"content":"Not Exporting the Entire Class","pos":[11594,11624]},{"content":"Sometimes you may want to export just the individual necessary members of your class.","pos":[11628,11713]},{"content":"For example, if you are exporting a <ph id=\"ph1\">`CDialog`</ph>-derived class, you might only need to export the constructor and the <ph id=\"ph2\">`DoModal`</ph> call.","pos":[11714,11844],"source":" For example, if you are exporting a `CDialog`-derived class, you might only need to export the constructor and the `DoModal` call."},{"content":"You can export these members using the DLL's .DEF file, but you can also use <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> in much the same way on the individual members you need to export.","pos":[11845,12006],"source":" You can export these members using the DLL's .DEF file, but you can also use **AFX_EXT_CLASS** in much the same way on the individual members you need to export."},{"content":"For example:","pos":[12013,12025]},{"content":"When you do this, you may run into an additional problem because you are no longer exporting all members of the class.","pos":[12217,12335]},{"content":"The problem is in the way that MFC macros work.","pos":[12336,12383]},{"content":"Several of MFC's helper macros actually declare or define data members.","pos":[12384,12455]},{"content":"Therefore, these data members will also need to be exported from your DLL.","pos":[12456,12530]},{"pos":[12537,12631],"content":"For example, the <ph id=\"ph1\">`DECLARE_DYNAMIC`</ph> macro is defined as follows when building an extension DLL:","source":"For example, the `DECLARE_DYNAMIC` macro is defined as follows when building an extension DLL:"},{"content":"The line that begins \"static <ph id=\"ph1\">`AFX_DATA`</ph>\" is declaring a static object inside of your class.","pos":[12893,12984],"source":"The line that begins \"static `AFX_DATA`\" is declaring a static object inside of your class."},{"content":"To export this class correctly and access the runtime information from a client .EXE, you need to export this static object.","pos":[12985,13109]},{"content":"Because the static object is declared with the modifier <ph id=\"ph1\">`AFX_DATA`</ph>, you only need to define <ph id=\"ph2\">`AFX_DATA`</ph> to be <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> when building your DLL and define it as <bpt id=\"p2\">**</bpt>__declspec(dllimport)<ept id=\"p2\">**</ept> when building your client executable.","pos":[13110,13348],"source":" Because the static object is declared with the modifier `AFX_DATA`, you only need to define `AFX_DATA` to be **__declspec(dllexport)** when building your DLL and define it as **__declspec(dllimport)** when building your client executable."},{"content":"As discussed above, <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is already defined in this way.","pos":[13355,13424],"source":"As discussed above, **AFX_EXT_CLASS** is already defined in this way."},{"content":"You just need to re-define <ph id=\"ph1\">`AFX_DATA`</ph> to be the same as <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> around your class definition.","pos":[13425,13528],"source":" You just need to re-define `AFX_DATA` to be the same as **AFX_EXT_CLASS** around your class definition."},{"content":"For example:","pos":[13535,13547]},{"content":"MFC always uses the <ph id=\"ph1\">`AFX_DATA`</ph> symbol on data items it defines within its macros, so this technique will work for all such scenarios.","pos":[13757,13890],"source":"MFC always uses the `AFX_DATA` symbol on data items it defines within its macros, so this technique will work for all such scenarios."},{"content":"For example, it will work for <ph id=\"ph1\">`DECLARE_MESSAGE_MAP`</ph>.","pos":[13891,13943],"source":" For example, it will work for `DECLARE_MESSAGE_MAP`."},{"pos":[13951,14090],"content":"[!NOTE]\n If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.","leadings":["","> "],"nodes":[{"content":"If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.","pos":[9,137]}]},{"content":"You can use the same technique to automatically export the <ph id=\"ph1\">`CArchive`</ph> extraction operator for classes that use the <ph id=\"ph2\">`DECLARE_SERIAL`</ph> and <ph id=\"ph3\">`IMPLEMENT_SERIAL`</ph> macros.","pos":[14097,14259],"source":"You can use the same technique to automatically export the `CArchive` extraction operator for classes that use the `DECLARE_SERIAL` and `IMPLEMENT_SERIAL` macros."},{"content":"Export the archive operator by bracketing the class declarations (located in the .H file) with the following code:","pos":[14260,14374]},{"content":"Limitations of _AFXEXT","pos":[14520,14542]},{"content":"You can use the _<bpt id=\"p1\">**</bpt>AFXEXT<ept id=\"p1\">**</ept> pre-processor symbol for your extension DLLs as long as you do not have multiple layers of extension DLLs.","pos":[14546,14680],"source":"You can use the _**AFXEXT** pre-processor symbol for your extension DLLs as long as you do not have multiple layers of extension DLLs."},{"content":"If you have extension DLLs that call or derive from classes in your own extension DLLs, which then derive from the MFC classes, you must use your own preprocessor symbol to avoid ambiguity.","pos":[14681,14870]},{"content":"The problem is that in Win32, you must explicitly declare any data as <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> if it is to be exported from a DLL, and <bpt id=\"p2\">**</bpt>__declspec(dllimport)<ept id=\"p2\">**</ept> if it is to be imported from a DLL.","pos":[14877,15074],"source":"The problem is that in Win32, you must explicitly declare any data as **__declspec(dllexport)** if it is to be exported from a DLL, and **__declspec(dllimport)** if it is to be imported from a DLL."},{"content":"When you define <ph id=\"ph1\">`_AFXEXT`</ph>, the MFC headers make sure that <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is defined correctly.","pos":[15075,15172],"source":" When you define `_AFXEXT`, the MFC headers make sure that **AFX_EXT_CLASS** is defined correctly."},{"content":"When you have multiple layers, one symbol such as <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is not sufficient, since an extension DLL may be exporting new classes as well as importing other classes from another extension DLL.","pos":[15179,15380],"source":"When you have multiple layers, one symbol such as **AFX_EXT_CLASS** is not sufficient, since an extension DLL may be exporting new classes as well as importing other classes from another extension DLL."},{"content":"In order to deal with this problem, use a special preprocessor symbol that indicates that you are building the DLL itself versus using the DLL.","pos":[15381,15524]},{"content":"For example, imagine two extension DLLs, A.DLL, and B.DLL.","pos":[15525,15583]},{"content":"They each export some classes in A.H and B.H, respectively.","pos":[15584,15643]},{"content":"B.DLL uses the classes from A.DLL.","pos":[15644,15678]},{"content":"The header files would look something like this:","pos":[15679,15727]},{"content":"When A.DLL is built, it is built with <bpt id=\"p1\">**</bpt>/D A_IMPL<ept id=\"p1\">**</ept> and when B.DLL is built, it is built with <bpt id=\"p2\">**</bpt>/D B_IMPL<ept id=\"p2\">**</ept>.","pos":[16198,16306],"source":"When A.DLL is built, it is built with **/D A_IMPL** and when B.DLL is built, it is built with **/D B_IMPL**."},{"content":"By using separate symbols for each DLL, CExampleB is exported and CExampleA is imported when building B.DLL.","pos":[16307,16415]},{"content":"CExampleA is exported when building A.DLL and imported when used by B.DLL (or some other client).","pos":[16416,16513]},{"content":"This type of layering cannot be done when using the built-in <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`_AFXEXT`</ph> preprocessor symbols.","pos":[16520,16634],"source":"This type of layering cannot be done when using the built-in **AFX_EXT_CLASS** and `_AFXEXT` preprocessor symbols."},{"content":"The technique described above solves this problem in a manner not unlike the mechanism MFC itself uses when building its OLE, Database, and Network extension DLLs.","pos":[16635,16798]},{"content":"Not Exporting the Entire Class","pos":[16808,16838]},{"content":"Again, you will have to take special care when you are not exporting an entire class.","pos":[16842,16927]},{"content":"You have to ensure that the necessary data items created by the MFC macros are exported correctly.","pos":[16928,17026]},{"content":"This can be done by re-defining <bpt id=\"p1\">**</bpt>AFX_DATA<ept id=\"p1\">**</ept> to your specific class' macro.","pos":[17027,17102],"source":" This can be done by re-defining **AFX_DATA** to your specific class' macro."},{"content":"This should be done any time you are not exporting the entire class.","pos":[17103,17171]},{"content":"For example:","pos":[17178,17190]},{"content":"DllMain","pos":[17586,17593]},{"content":"The following is the exact code you should place in your main source file for your extension DLL.","pos":[17597,17694]},{"content":"It should come after the standard includes.","pos":[17695,17738]},{"content":"Note that when you use AppWizard to create starter files for an extension DLL, it supplies a <ph id=\"ph1\">`DllMain`</ph> for you.","pos":[17739,17850],"source":" Note that when you use AppWizard to create starter files for an extension DLL, it supplies a `DllMain` for you."},{"content":"The call to <ph id=\"ph1\">`AfxInitExtensionModule`</ph> captures the modules runtime-classes (<ph id=\"ph2\">`CRuntimeClass`</ph> structures) as well as its object factories (<ph id=\"ph3\">`COleObjectFactory`</ph> objects) for use later when the <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object is created.","pos":[18534,18760],"source":"The call to `AfxInitExtensionModule` captures the modules runtime-classes (`CRuntimeClass` structures) as well as its object factories (`COleObjectFactory` objects) for use later when the **CDynLinkLibrary** object is created."},{"content":"The (optional) call to <ph id=\"ph1\">`AfxTermExtensionModule`</ph> allows MFC to cleanup the extension DLL when each process detaches (which happens when the process exits, or when the DLL is unloaded as a result of a <bpt id=\"p1\">**</bpt>FreeLibrary<ept id=\"p1\">**</ept> call) from the extension DLL.","pos":[18761,19005],"source":" The (optional) call to `AfxTermExtensionModule` allows MFC to cleanup the extension DLL when each process detaches (which happens when the process exits, or when the DLL is unloaded as a result of a **FreeLibrary** call) from the extension DLL."},{"content":"Since most extension DLLs are not dynamically loaded (usually, they are linked via their import libraries), the call to <ph id=\"ph1\">`AfxTermExtensionModule`</ph> is usually not necessary.","pos":[19006,19176],"source":" Since most extension DLLs are not dynamically loaded (usually, they are linked via their import libraries), the call to `AfxTermExtensionModule` is usually not necessary."},{"content":"If your application loads and frees extension DLLs dynamically, be sure to call <ph id=\"ph1\">`AfxTermExtensionModule`</ph> as shown above.","pos":[19183,19303],"source":"If your application loads and frees extension DLLs dynamically, be sure to call `AfxTermExtensionModule` as shown above."},{"content":"Also be sure to use <ph id=\"ph1\">`AfxLoadLibrary`</ph> and <ph id=\"ph2\">`AfxFreeLibrary`</ph> (instead of Win32 functions <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>FreeLibrary<ept id=\"p2\">**</ept>) if your application uses multiple threads or if it dynamically loads an extension DLL.","pos":[19304,19513],"source":" Also be sure to use `AfxLoadLibrary` and `AfxFreeLibrary` (instead of Win32 functions **LoadLibrary** and **FreeLibrary**) if your application uses multiple threads or if it dynamically loads an extension DLL."},{"content":"Using <ph id=\"ph1\">`AfxLoadLibrary`</ph> and <ph id=\"ph2\">`AfxFreeLibrary`</ph> insures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state.","pos":[19514,19699],"source":" Using `AfxLoadLibrary` and `AfxFreeLibrary` insures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state."},{"pos":[19706,19874],"content":"The header file AFXDLLX.H contains special definitions for structures used in extension DLLs, such as the definition for <ph id=\"ph1\">`AFX_EXTENSION_MODULE`</ph> and <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept>.","source":"The header file AFXDLLX.H contains special definitions for structures used in extension DLLs, such as the definition for `AFX_EXTENSION_MODULE` and **CDynLinkLibrary**."},{"content":"The global <bpt id=\"p1\">*</bpt>extensionDLL<ept id=\"p1\">*</ept> must be declared as shown.","pos":[19881,19933],"source":"The global *extensionDLL* must be declared as shown."},{"content":"Unlike the 16-bit version of MFC, you can allocate memory and call MFC functions during this time, since the MFCxx.DLL is fully initialized by the time your <ph id=\"ph1\">`DllMain`</ph> is called.","pos":[19934,20111],"source":" Unlike the 16-bit version of MFC, you can allocate memory and call MFC functions during this time, since the MFCxx.DLL is fully initialized by the time your `DllMain` is called."},{"content":"Sharing Resources and Classes","pos":[20121,20150]},{"content":"Simple MFC extension DLLs need only export a few low-bandwidth functions to the client application and nothing more.","pos":[20154,20270]},{"content":"More user-interface intensive DLLs may want to export resources and C++ classes to the client application.","pos":[20271,20377]},{"content":"Exporting resources is done through a resource list.","pos":[20384,20436]},{"content":"In each application is a singly linked list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects.","pos":[20437,20512],"source":" In each application is a singly linked list of **CDynLinkLibrary** objects."},{"content":"When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (<ph id=\"ph1\">`AfxGetResourceHandle`</ph>) and if not found walk the list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects attempting to load the requested resource.","pos":[20513,20774],"source":" When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (`AfxGetResourceHandle`) and if not found walk the list of **CDynLinkLibrary** objects attempting to load the requested resource."},{"content":"Dynamic creation of C++ objects given a C++ class name is similar.","pos":[20781,20847]},{"content":"The MFC object deserialization mechanism needs to have all of the <ph id=\"ph1\">`CRuntimeClass`</ph> objects registered so that it can reconstruct by dynamically creating C++ object of the required type based on what was stored earlier.","pos":[20848,21065],"source":" The MFC object deserialization mechanism needs to have all of the `CRuntimeClass` objects registered so that it can reconstruct by dynamically creating C++ object of the required type based on what was stored earlier."},{"content":"If you want the client application to use classes in your extension DLL that are <ph id=\"ph1\">`DECLARE_SERIAL`</ph>, then you will need to export your classes to be visible to the client application.","pos":[21072,21253],"source":"If you want the client application to use classes in your extension DLL that are `DECLARE_SERIAL`, then you will need to export your classes to be visible to the client application."},{"content":"This is also done by walking the <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> list.","pos":[21254,21312],"source":" This is also done by walking the **CDynLinkLibrary** list."},{"pos":[21319,21434],"content":"In the case of the MFC Advanced Concepts sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](../visual-cpp-samples.md)</ept>, the list looks something like:","source":"In the case of the MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md), the list looks something like:"},{"content":"The MFCxx.DLL is usually last on the resource and class list.","pos":[21642,21703]},{"content":"MFCxx.DLL includes all of the standard MFC resources, including prompt strings for all the standard command IDs.","pos":[21704,21816]},{"content":"Placing it at the tail of the list allows DLLs and the client application itself to not have a their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.DLL instead.","pos":[21817,22019]},{"content":"Merging the resources and class names of all DLLs into the client application's name space has the disadvantage that you have to be careful what IDs or names you pick.","pos":[22026,22193]},{"content":"You can of course disable this feature by not exporting either your resources or a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object to the client application.","pos":[22194,22330],"source":" You can of course disable this feature by not exporting either your resources or a **CDynLinkLibrary** object to the client application."},{"content":"The <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](../visual-cpp-samples.md)</ept> sample manages the shared resource name space by using multiple header files.","pos":[22331,22448],"source":" The [DLLHUSK](../visual-cpp-samples.md) sample manages the shared resource name space by using multiple header files."},{"content":"See <bpt id=\"p1\">[</bpt>Technical Note 35<ept id=\"p1\">](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md)</ept> for more tips on using shared resource files.","pos":[22449,22598],"source":" See [Technical Note 35](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md) for more tips on using shared resource files."},{"content":"Initializing the DLL","pos":[22608,22628]},{"content":"As mentioned above, you will usually want to create a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object in order to export your resources and classes to the client application.","pos":[22632,22785],"source":"As mentioned above, you will usually want to create a **CDynLinkLibrary** object in order to export your resources and classes to the client application."},{"content":"You will need to provide an exported entry point to initialize the DLL.","pos":[22786,22857]},{"content":"Minimally, this is a void routine that takes no arguments and returns nothing, but it can be anything you like.","pos":[22858,22969]},{"content":"Each client application that wants to use your DLL must call this initialization routine, if you use this approach.","pos":[22976,23091]},{"content":"You may also allocate this <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object in your <ph id=\"ph1\">`DllMain`</ph> just after calling <ph id=\"ph2\">`AfxInitExtensionModule`</ph>.","pos":[23092,23208],"source":" You may also allocate this **CDynLinkLibrary** object in your `DllMain` just after calling `AfxInitExtensionModule`."},{"content":"The initialization routine must create a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object in the current application's heap, wired up to your extension DLL information.","pos":[23215,23361],"source":"The initialization routine must create a **CDynLinkLibrary** object in the current application's heap, wired up to your extension DLL information."},{"content":"This can be done with the following:","pos":[23362,23398]},{"content":"The routine name, <bpt id=\"p1\">*</bpt>InitXxxDLL<ept id=\"p1\">*</ept> in this example, can be anything you want.","pos":[23513,23586],"source":"The routine name, *InitXxxDLL* in this example, can be anything you want."},{"content":"It does not need to be <ph id=\"ph1\">`extern \"C\"`</ph>, but doing so makes the export list easier to maintain.","pos":[23587,23678],"source":" It does not need to be `extern \"C\"`, but doing so makes the export list easier to maintain."},{"pos":[23686,23895],"content":"[!NOTE]\n If you use your extension DLL from a regular DLL, you must export this initialization function. This function must be called from the regular DLL before using any extension DLL classes or resources.","leadings":["","> "],"nodes":[{"content":" If you use your extension DLL from a regular DLL, you must export this initialization function. This function must be called from the regular DLL before using any extension DLL classes or resources.","pos":[8,207],"nodes":[{"content":"If you use your extension DLL from a regular DLL, you must export this initialization function.","pos":[1,96]},{"content":"This function must be called from the regular DLL before using any extension DLL classes or resources.","pos":[97,199]}]}]},{"content":"Exporting Entries","pos":[23905,23922]},{"content":"The simple way to export your classes is to use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>__declspec(dllexport)<ept id=\"p2\">**</ept> on each class and global function you wish to export.","pos":[23926,24083],"source":"The simple way to export your classes is to use **__declspec(dllimport)** and **__declspec(dllexport)** on each class and global function you wish to export."},{"content":"This makes it a lot easier, but is less efficient than naming each entry point (described below) since you have less control over what functions are exported and you cannot export the functions by ordinal.","pos":[24084,24289]},{"content":"TESTDLL1 and TESTDLL2 use this method to export their entries.","pos":[24290,24352]},{"content":"A more efficient method (and the method used by MFCxx.DLL) is to export each entry by hand by naming each entry in the .DEF file.","pos":[24359,24488]},{"content":"Since we are exporting selective exports from our DLL (that is, not everything), we must decide which particular interfaces we wish to export.","pos":[24489,24631]},{"content":"This is difficult since you must specify the mangled names to the linker in the form of entries in the .DEF file.","pos":[24632,24745]},{"content":"Don't export any C++ classes unless you really need to have a symbolic link for it.","pos":[24746,24829]},{"content":"If you have tried exporting C++ classes with a .DEF file before, you may want to develop a tool to generate this list automatically.","pos":[24836,24968]},{"content":"This can be done using a two-stage link process.","pos":[24969,25017]},{"content":"Link your DLL once with no exports, and allow the linker to generate a .MAP file.","pos":[25018,25099]},{"content":"The .MAP file can be used to generate a list of functions that should be exported, so with some rearranging, it can be used to generate your EXPORT entries for your .DEF file.","pos":[25100,25275]},{"content":"The export list for MFCxx.DLL and the OLE and Database extension DLLs, several thousand in number, was generated with such a process (although it is not completely automatic and requires some hand tuning every once in a while).","pos":[25276,25503]},{"content":"CWinApp vs. CDynLinkLibrary","pos":[25513,25540]},{"content":"An MFC Extension DLL does not have a <ph id=\"ph1\">`CWinApp`</ph>-derived object of its own; instead it must work with the <ph id=\"ph2\">`CWinApp`</ph>-derived object of the client application.","pos":[25544,25699],"source":"An MFC Extension DLL does not have a `CWinApp`-derived object of its own; instead it must work with the `CWinApp`-derived object of the client application."},{"content":"This means that the client application owns the main message pump, the idle loop and so on.","pos":[25700,25791]},{"content":"If your MFC Extension DLL needs to maintain extra data for each application, you can derive a new class from <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> and create it in the InitXxxDLL routine describe above.","pos":[25798,25982],"source":"If your MFC Extension DLL needs to maintain extra data for each application, you can derive a new class from **CDynLinkLibrary** and create it in the InitXxxDLL routine describe above."},{"content":"When running, the DLL can check the current application's list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects to find the one for that particular extension DLL.","pos":[25983,26127],"source":" When running, the DLL can check the current application's list of **CDynLinkLibrary** objects to find the one for that particular extension DLL."},{"content":"Using Resources in Your DLL Implementation","pos":[26137,26179]},{"content":"As mentioned above, the default resource load will walk the list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects looking for the first EXE or DLL that has the requested resource.","pos":[26183,26344],"source":"As mentioned above, the default resource load will walk the list of **CDynLinkLibrary** objects looking for the first EXE or DLL that has the requested resource."},{"content":"All MFC APIs as well as all the internal code uses <ph id=\"ph1\">`AfxFindResourceHandle`</ph> to walk the resource list to find any resource, no matter where it may reside.","pos":[26345,26498],"source":" All MFC APIs as well as all the internal code uses `AfxFindResourceHandle` to walk the resource list to find any resource, no matter where it may reside."},{"content":"If you wish to only load resources from a specific place, use the APIs <ph id=\"ph1\">`AfxGetResourceHandle`</ph> and <ph id=\"ph2\">`AfxSetResourceHandle`</ph> to save the old handle and set the new handle.","pos":[26505,26672],"source":"If you wish to only load resources from a specific place, use the APIs `AfxGetResourceHandle` and `AfxSetResourceHandle` to save the old handle and set the new handle."},{"content":"Be sure to restore the old resource handle before you return to the client application.","pos":[26673,26760]},{"content":"The sample TESTDLL2 uses this approach for explicitly loading a menu.","pos":[26761,26830]},{"content":"Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges.","pos":[26837,26944]},{"content":"It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle.","pos":[26945,27113]},{"content":"is an API used for walking the resource list to look for a given match.","pos":[27138,27209]},{"content":"It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).","pos":[27210,27318]},{"pos":[27402,27450],"content":"Writing an Application That Uses the DLL Version"},{"content":"Application Requirements","pos":[27460,27484]},{"content":"An application that uses the shared version of MFC must follow a few simple rules:","pos":[27488,27570]},{"pos":[27580,27661],"content":"It must have a <ph id=\"ph1\">`CWinApp`</ph> object and follow the standard rules for a message pump.","source":"It must have a `CWinApp` object and follow the standard rules for a message pump."},{"content":"It must be compiled with a set of required compiler flags (see below).","pos":[27671,27741]},{"content":"It must link with the MFCxx import libraries.","pos":[27751,27796]},{"content":"By setting the required compiler flags, the MFC headers determine at link time which library the application should link with.","pos":[27797,27923]},{"content":"To run the executable, MFCxx.DLL must be on the path or in the Windows system directory.","pos":[27933,28021]},{"content":"Building with the Development Environment","pos":[28031,28072]},{"content":"If you are using the internal makefile with most of the standard defaults, you can easily change the project to build the DLL version.","pos":[28076,28210]},{"content":"The following step assumes you have a correctly functioning MFC application linked with NAFXCWD.LIB (for debug) and NAFXCW.LIB (for retail) and you want to convert it to use the shared version of the MFC library.","pos":[28217,28429]},{"content":"You are running the Visual C++ environment and have an internal project file.","pos":[28430,28507]},{"content":"On the <bpt id=\"p1\">**</bpt>Projects<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>Properties<ept id=\"p2\">**</ept>.","pos":[28517,28564],"source":"On the **Projects** menu, click **Properties**."},{"content":"In the <bpt id=\"p1\">**</bpt>General<ept id=\"p1\">**</ept> page under <bpt id=\"p2\">**</bpt>Project Defaults<ept id=\"p2\">**</ept>, set Microsoft Foundation Classes to <bpt id=\"p3\">**</bpt>Use MFC in a Shared DLL<ept id=\"p3\">**</ept> (MFCxx(d).dll).","pos":[28565,28696],"source":" In the **General** page under **Project Defaults**, set Microsoft Foundation Classes to **Use MFC in a Shared DLL** (MFCxx(d).dll)."},{"content":"Building with NMAKE","pos":[28706,28725]},{"content":"If you are using the external makefile feature of the Visual C++, or are using NMAKE directly, you will have to edit your makefile to support compiler and linker options","pos":[28729,28898]},{"content":"Required compiler flags:","pos":[28905,28929]},{"content":"/D_AFXDLL /MD","pos":[28938,28951]},{"content":"/D_AFXDLL","pos":[28959,28968]},{"content":"The standard MFC headers need this symbol to be defined:","pos":[28977,29033]},{"content":"/MD","pos":[29042,29045]},{"content":"The application must use the DLL version of the C run-time library","pos":[29051,29117]},{"content":"All other compiler flags follow the MFC defaults (for example, _DEBUG for debug).","pos":[29124,29205]},{"content":"Edit the linker list of libraries.","pos":[29212,29246]},{"content":"Change NAFXCWD.LIB to MFCxxD.LIB and change NAFXCW.LIB to MFCxx.LIB.","pos":[29247,29315]},{"content":"Replace LIBC.LIB with MSVCRT.LIB.","pos":[29316,29349]},{"content":"As with any other MFC library it is important that MFCxxD.LIB is placed <bpt id=\"p1\">**</bpt>before<ept id=\"p1\">**</ept> any C-runtime libraries.","pos":[29350,29457],"source":" As with any other MFC library it is important that MFCxxD.LIB is placed **before** any C-runtime libraries."},{"content":"Optionally add <bpt id=\"p1\">**</bpt>/D_AFXDLL<ept id=\"p1\">**</ept> to both your retail and debug resource compiler options (the one that actually compiles the resources with <bpt id=\"p2\">**</bpt>/R<ept id=\"p2\">**</ept>).","pos":[29464,29608],"source":"Optionally add **/D_AFXDLL** to both your retail and debug resource compiler options (the one that actually compiles the resources with **/R**)."},{"content":"This makes your final executable smaller by sharing the resources that are present in the MFC DLLs.","pos":[29609,29708]},{"content":"A full rebuild is required after these changes are made.","pos":[29715,29771]},{"content":"Building the Samples","pos":[29781,29801]},{"content":"Most of the MFC sample programs can be built from Visual C++ or from a shared NMAKE-compatible MAKEFILE from the command line.","pos":[29805,29931]},{"content":"To convert any of these samples to use MFCxx.DLL, you can load the .MAK file into the Visual C++ and set the Project options as described above.","pos":[29938,30082]},{"content":"If you are using the NMAKE build, you can specify \"AFXDLL=1\" on the NMAKE command line and that will build the sample using the shared MFC libraries.","pos":[30083,30232]},{"content":"The MFC Advanced Concepts sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](../visual-cpp-samples.md)</ept> is built with the DLL version of MFC.","pos":[30239,30345],"source":"The MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md) is built with the DLL version of MFC."},{"content":"This sample not only illustrates how to build an application linked with MFCxx.DLL, but it also illustrates other features of the MFC DLL packaging option such as MFC Extension DLLs described later in this technical note.","pos":[30346,30567]},{"content":"Packaging Notes","pos":[30577,30592]},{"content":"The retail version of the DLLs (MFCxx[U].DLL) are freely redistributable.","pos":[30596,30669]},{"content":"The debug version of the DLLs are not freely redistributable and should be used only during the development of your application.","pos":[30670,30798]},{"content":"The debug DLLs are provided with debugging information.","pos":[30805,30860]},{"content":"By using the Visual C++ debugger, you can trace execution of your application as well as the DLL.","pos":[30861,30958]},{"content":"The Release DLLs (MFCxx[U].DLL) do not contain debugging information.","pos":[30959,31028]},{"content":"If you customize or rebuild the DLLs, then you should call them something other than \"MFCxx\" The MFC SRC file MFCDLL.MAK describes build options and contains the logic for renaming the DLL.","pos":[31035,31224]},{"content":"Renaming the files is necessary, since these DLLs are potentially shared by many MFC applications.","pos":[31225,31323]},{"content":"Having your custom version of the MFC DLLs replace those installed on the system may break another MFC application using the shared MFC DLLs.","pos":[31324,31465]},{"content":"Rebuilding the MFC DLLs is not recommended.","pos":[31472,31515]},{"pos":[31583,31615],"content":"How the MFCxx.DLL Is Implemented"},{"content":"The following section describes how the MFC DLL (MFCxx.DLL and MFCxxD.DLL) is implemented.","pos":[31619,31709]},{"content":"Understanding the details here are also not important if all you want to do is use the MFC DLL with your application.","pos":[31710,31827]},{"content":"The details here are not essential for understanding how to write an MFC extension DLL, but understanding this implementation may help you write your own DLL.","pos":[31828,31986]},{"content":"Implementation Overview","pos":[31996,32019]},{"content":"The MFC DLL is really a special case of an MFC Extension DLL as described above.","pos":[32023,32103]},{"content":"It has a very large number of exports for a large number of classes.","pos":[32104,32172]},{"content":"There are a few additional things we do in the MFC DLL that make it even more special than a regular Extension DLL.","pos":[32173,32288]},{"content":"Win32 Does Most of the Work","pos":[32298,32325]},{"content":"The 16-bit version of MFC needed a number of special techniques including per-app data on the stack segment, special segments created by some 80x86 assembly code, per-process exception contexts, and other techniques.","pos":[32329,32545]},{"content":"Win32 directly supports per-process data in a DLL, which is what you want most of the time.","pos":[32546,32637]},{"content":"For the most part MFCxx.DLL is just NAFXCW.LIB packaged in a DLL.","pos":[32638,32703]},{"content":"If you look at the MFC source code, you'll find very few #ifdef _AFXDLL, since there are very few special cases that need to be made.","pos":[32704,32837]},{"content":"The special cases that are there are specifically to deal with Win32 on Windows 3.1 (otherwise known as Win32s).","pos":[32838,32950]},{"content":"Win32s does not support per-process DLL data directly so the MFC DLL must use the thread-local storage (TLS) Win32 APIs to obtain process local data.","pos":[32951,33100]},{"content":"Impact on Library Sources, Additional Files","pos":[33110,33153]},{"content":"The impact of the <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> version on the normal MFC class library sources and headers is relatively minor.","pos":[33157,33267],"source":"The impact of the **_AFXDLL** version on the normal MFC class library sources and headers is relatively minor."},{"content":"There is a special version file (AFXV_DLL.H) as well as an additional header file (AFXDLL_.H) included by the main AFXWIN.H header.","pos":[33268,33399]},{"content":"The AFXDLL_.H header includes the <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> class and other implementation details of both <bpt id=\"p2\">**</bpt>_AFXDLL<ept id=\"p2\">**</ept> applications and MFC Extension DLLs.","pos":[33400,33549],"source":" The AFXDLL_.H header includes the **CDynLinkLibrary** class and other implementation details of both **_AFXDLL** applications and MFC Extension DLLs."},{"content":"The AFXDLLX.H header is provided for building MFC Extension DLLs (see above for details).","pos":[33550,33639]},{"content":"The regular sources to the MFC library in MFC SRC have some additional conditional code under the <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> #ifdef.","pos":[33646,33763],"source":"The regular sources to the MFC library in MFC SRC have some additional conditional code under the **_AFXDLL** #ifdef."},{"content":"An additional source file (DLLINIT.CPP) contains the extra DLL initialization code and other glue for the shared version of MFC.","pos":[33764,33892]},{"content":"In order to build the shared version of MFC, additional files are provided.","pos":[33899,33974]},{"content":"(See below for details on how to build the DLL.)","pos":[33975,34023]},{"content":"Two .DEF files are used for exporting the MFC DLL entry points for debug (MFCxxD.DEF) and release (MFCxx.DEF) versions of the DLL.","pos":[34033,34163]},{"content":"An .RC file (MFCDLL.RC) contains all the standard MFC resources and a VERSIONINFO resource for the DLL.","pos":[34173,34276]},{"content":"A .CLW file (MFCDLL.CLW) is provided to allow browsing the MFC classes using ClassWizard.","pos":[34286,34375]},{"content":"Note: this feature is not particular to the DLL version of MFC.","pos":[34376,34439]},{"content":"Memory Management","pos":[34449,34466]},{"content":"An application using MFCxx.DLL uses a common memory allocator provided by MSVCRTxx.DLL, the shared C-runtime DLL.","pos":[34470,34583]},{"content":"The application, any extension DLLs, and well as the MFC DLLs themselves use this shared memory allocator.","pos":[34584,34690]},{"content":"By using a shared DLL for memory allocation, the MFC DLLs can allocate memory that is later freed by the application or vice versa.","pos":[34691,34822]},{"content":"Because both the application and the DLL must use the same allocator, you should not override the C++ global <ph id=\"ph1\">`operator new`</ph> or <ph id=\"ph2\">`operator delete`</ph>.","pos":[34823,34968],"source":" Because both the application and the DLL must use the same allocator, you should not override the C++ global `operator new` or `operator delete`."},{"content":"The same rules apply to the rest of the C run-time memory allocation routines (such as <ph id=\"ph1\">`malloc`</ph>, <ph id=\"ph2\">`realloc`</ph>, <bpt id=\"p1\">**</bpt>free<ept id=\"p1\">**</ept>, and others).","pos":[34969,35099],"source":" The same rules apply to the rest of the C run-time memory allocation routines (such as `malloc`, `realloc`, **free**, and others)."},{"content":"Ordinals and class __declspec(dllexport) and DLL naming","pos":[35109,35164]},{"content":"We do not use the <ph id=\"ph1\">`class`</ph> <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> functionality of the C++ compiler.","pos":[35168,35254],"source":"We do not use the `class` **__declspec(dllexport)** functionality of the C++ compiler."},{"content":"Instead, a list of exports is included with the class library sources (MFCxx.DEF and MFCxxD.DEF).","pos":[35255,35352]},{"content":"Only these select set of entry points (functions and data) are exported.","pos":[35353,35425]},{"content":"Other symbols, such as MFC private implementation functions or classes, are not exported All exports are done by ordinal without a string name in the resident or non-resident name table.","pos":[35426,35612]},{"pos":[35619,35822],"content":"Using <ph id=\"ph1\">`class`</ph> <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> may be a viable alternative for building smaller DLLs, but in the case of a large DLL like MFC, the default exporting mechanism has efficiency and capacity limits.","source":"Using `class` **__declspec(dllexport)** may be a viable alternative for building smaller DLLs, but in the case of a large DLL like MFC, the default exporting mechanism has efficiency and capacity limits."},{"content":"What this all means is that we can package a large amount of functionality in the release MFCxx.DLL that is only around 800 KB without compromising much execution or loading speed.","pos":[35829,36009]},{"content":"MFCxx.DLL would have been 100K larger had this technique not been used.","pos":[36010,36081]},{"content":"This also makes it possible to add additional entry points at the end of the .DEF file to allow simple versioning without compromising the speed and size efficiency of exporting by ordinal.","pos":[36082,36271]},{"content":"Major version revisions in the MFC class library will change the library name.","pos":[36272,36350]},{"content":"That is, MFC30.DLL is the redistributable DLL containing version 3.0 of the MFC class library.","pos":[36351,36445]},{"content":"An upgrade of this DLL, say, in a hypothetical MFC 3.1, the DLL would be named MFC31.DLL instead.","pos":[36446,36543]},{"content":"Again, if you modify the MFC source code to produce a custom version of the MFC DLL, use a different name (and preferably one without \"MFC\" in the name).","pos":[36544,36697]},{"content":"See Also","pos":[36706,36714]},{"content":"Technical Notes by Number","pos":[36719,36744]},{"content":"Technical Notes by Category","pos":[36788,36815]}],"content":"---\ntitle: \"TN033: DLL Version of MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.dll\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC DLLs [C++], writing extension DLLS\"\n  - \"AFXDLL library\"\n  - \"DLLs [C++], MFC\"\n  - \"DLL version of MFC [C++]\"\n  - \"TN033\"\nms.assetid: b6f1080b-b66b-4b1e-8fb1-926c5816392c\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN033: DLL Version of MFC\nThis note describes how you can use the MFCxx.DLL and MFCxxD.DLL (where x is the MFC version number) shared dynamic link libraries with MFC applications and extension DLLs. For more information about regular DLLs, see [Using MFC as Part of a DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md).  \n  \n This technical note covers three aspects of DLLs. The last two are for the more advanced users:  \n  \n- [How you build an MFC Extension DLL](#_mfcnotes_how_to_write_an_mfc_extension_dll)  \n  \n- [How you build an MFC application that uses the DLL version of MFC](#_mfcnotes_writing_an_application_that_uses_the_dll_version)  \n  \n- [How the MFC shared dynamic-link libraries are implemented](#_mfcnotes_how_the_mfc30.dll_is_implemented)  \n  \n If you are interested in building a DLL using MFC that can be used with non-MFC applications (this is called a regular DLL), refer to [Technical Note 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md).  \n  \n## Overview of MFCxx.DLL Support: Terminology and Files  \n **Regular DLL**: You use a regular DLL to build a stand-alone DLL using some of the MFC classes. Interfaces across the App/DLL boundary are \"C\" interfaces, and the client application does not have to be an MFC application.  \n  \n This is the version of DLL support supported in MFC 1.0. It is described in [Technical Note 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) and the MFC Advanced Concepts sample [DLLScreenCap](../visual-cpp-samples.md).  \n  \n> [!NOTE]\n>  As of Visual C++ version 4.0, the term **USRDLL** is obsolete and has been replaced by a regular DLL that statically links to MFC. You may also build a regular DLL that dynamically links to MFC.  \n  \n MFC 3.0 (and above) supports regular DLLs with all the new functionality including the OLE and Database classes.  \n  \n **AFXDLL**: This is also referred to as the shared version of the MFC libraries. This is the new DLL support added in MFC 2.0. The MFC library itself is in a number of DLLs (described below) and a client application or DLL dynamically links the DLLs that it requires. Interfaces across the application/DLL boundary are C++/MFC class interfaces. The client application MUST be an MFC application. This supports all MFC 3.0 functionality (exception: UNICODE is not supported for the database classes).  \n  \n> [!NOTE]\n>  As of Visual C++ version 4.0, this type of DLL is referred to as an \"Extension DLL.\"  \n  \n This note will use MFCxx.DLL to refer to the entire MFC DLL set, which includes:  \n  \n-   Debug: MFCxxD.DLL (combined) and MFCSxxD.LIB (static).  \n  \n-   Release: MFCxx.DLL (combined) and MFCSxx.LIB (static).  \n  \n-   Unicode Debug: MFCxxUD.DLL (combined) and MFCSxxD.LIB (static).  \n  \n-   Unicode Release: MFCxxU.DLL (combined) and MFCSxxU.LIB (static).  \n  \n> [!NOTE]\n>  The MFCSxx[U][D].LIB libraries are used in conjunction with the MFC shared DLLs. These libraries contain code that must be statically linked to the application or DLL.  \n  \n An application links to the corresponding import libraries:  \n  \n-   Debug: MFCxxD.LIB  \n  \n-   Release: MFCxx.LIB  \n  \n-   Unicode Debug: MFCxxUD.LIB  \n  \n-   Unicode Release: MFCxxU.LIB  \n  \n An \"MFC Extension DLL\" is a DLL built upon MFCxx.DLL (and/or the other MFC shared DLLs). Here the MFC component architecture kicks in. If you derive a useful class from an MFC class, or build another MFC-like toolkit, you can place it in a DLL. That DLL uses MFCxx.DLL, as does the ultimate client application. This permits reusable leaf classes, reusable base classes, and reusable view/document classes.  \n  \n## Pros and Cons  \n Why should you use the shared version of MFC  \n  \n-   Using the shared library can result in smaller applications (a minimal application that uses most of the MFC library is less than 10K).  \n  \n-   The shared version of MFC supports MFC Extension DLLs and regular DLLs.  \n  \n-   Building an application that uses the shared MFC libraries is faster than building a statically linked MFC application because it is not necessary to link MFC itself. This is especially true in **DEBUG** builds where the linker must compact the debug information — by linking with a DLL that already contains the debug information, there is less debug information to compact within your application.  \n  \n Why should you not use the shared version of MFC:  \n  \n-   Shipping an application that uses the shared library requires that you ship the MFCxx.DLL (and others) library with your program. MFCxx.DLL is freely redistributable like many DLLs, but you still must install the DLL in your SETUP program. In addition, you must ship the MSVCRTxx.DLL, which contains the C-runtime library which is used both by your program and the MFC DLLs themselves.  \n  \n##  <a name=\"_mfcnotes_how_to_write_an_mfc_extension_dll\"></a> How to Write an MFC Extension DLL  \n An MFC Extension DLL is a DLL containing classes and functions written to embellish the functionality of the MFC classes. An MFC Extension DLL uses the shared MFC DLLs in the same way an application uses it, with a few additional considerations:  \n  \n-   The build process is similar to building an application that uses the shared MFC libraries with a few additional compiler and linker options.  \n  \n-   An MFC Extension DLL does not have a `CWinApp`-derived class.  \n  \n-   An MFC Extension DLL must provide a special `DllMain`. AppWizard supplies a `DllMain` function that you can modify.  \n  \n-   An MFC Extension DLL will usually provide an initialization routine to create a **CDynLinkLibrary** if the extension DLL wishes to export `CRuntimeClass`es or resources to the application. A derived class of **CDynLinkLibrary** may be used if per-application data must be maintained by the extension DLL.  \n  \n These considerations are described in more detail below. You should also refer to the MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md) since it illustrates:  \n  \n-   Building an application using the shared libraries. (DLLHUSK.EXE is an MFC application that dynamically links to the MFC libraries as well as other DLLs.)  \n  \n-   Building an MFC Extension DLL. (Note the special flags such as `_AFXEXT` that are used in building an extension DLL)  \n  \n-   Two examples of MFC Extension DLLs. One shows the basic structure of an MFC Extension DLL with limited exports (TESTDLL1) and the other shows exporting an entire class interface (TESTDLL2).  \n  \n Both the client application and any extension DLLs must use the same version of MFCxx.DLL. You should follow the convention of MFC DLL and provide both a debug and retail (/release) version of your extension DLL. This permits client programs to build both debug and retail versions of their applications and link them with the appropriate debug or retail version of all DLLs.  \n  \n> [!NOTE]\n>  Because C++ name mangling and export issues, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCxx.DLL has about 2000 exported entry points; the debug MFCxxD.DLL has about 3000 exported entry points.  \n  \n### Quick Note on Memory Management  \n The section titled \"Memory Management,\" near the end of this technical note, describes the implementation of the MFCxx.DLL with the shared version of MFC. The information you need to know to implement just an extension DLL is described here.  \n  \n MFCxx.DLL and all extension DLLs loaded into a client application's address space will use the same memory allocator, resource loading and other MFC \"global\" states as if they were in the same application. This is significant because the non-MFC DLL libraries and regular DLLs that statically link to MFC do the exact opposite and have each DLL allocating out of its own memory pool.  \n  \n If an extension DLL allocates memory, then that memory can freely intermix with any other application-allocated object. Also, if an application that uses the shared MFC libraries crashes, the protection of the operating system will maintain the integrity of any other MFC application sharing the DLL.  \n  \n Similarly other \"global\" MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCxx.DLL itself.  \n  \n### Building an Extension DLL  \n You can use AppWizard to create an MFC extension DLL project, and it will automatically generate the appropriate compiler and linker settings. It was also generate a `DllMain` function that you can modify.  \n  \n If you are converting an existing project to an MFC extension DLL, start with the standard rules for building an application using the shared version of MFC, then do the following:  \n  \n-   Add **/D_AFXEXT** to the compiler flags. On the Project Properties dialog, select the C/C++ node. Then select the Preprocessor category. Add `_AFXEXT` to the Define Macros field, separating each of the items with semicolons.  \n  \n-   Remove the **/Gy** compiler switch. On the Project Properties dialog, select the C/C++ node. Then select the Code Generation category. Ensure that the \"Enable Function-Level Linking\" option is not enabled. This will make it easier to export classes because the linker will not remove unreferenced functions. If the original project is used to build a Regular DLL statically linked to MFC, change the **/MT[d]** compiler option to **/MD[d]**.  \n  \n-   Build an export library with the **/DLL** option to LINK. This will be set when you create a new target, specifying Win32 Dynamic-Link Library as the target type.  \n  \n### Changing your Header Files  \n The goal of an extension DLL is usually to export some common functionality to one or more applications that can use that functionality. This boils down to exporting classes and global functions that are available for your client applications.  \n  \n In order to do this you must insure that each of the member functions is marked as import or export as appropriate. This requires special declarations: **__declspec(dllexport)** and **__declspec(dllimport)**. When your classes are used by the client applications, you want them to be declared as **__declspec(dllimport)**. When the extension DLL itself is being built, they should be declared as **__declspec(dllexport)**. In addition, the functions must be actually exported, so that the client programs bind to them at load time.  \n  \n To export your entire class, use **AFX_EXT_CLASS** in the class definition. This macro is defined by the framework as **__declspec(dllexport)** when **_AFXDLL** and `_AFXEXT` is defined, but defined as **__declspec(dllimport)** when `_AFXEXT` is not defined. `_AFXEXT` as described above, is only defined when building your extension DLL. For example:  \n  \n```  \nclass AFX_EXT_CLASS CExampleExport : public CObject  \n{ ... class definition ... };  \n```  \n  \n### Not Exporting the Entire Class  \n Sometimes you may want to export just the individual necessary members of your class. For example, if you are exporting a `CDialog`-derived class, you might only need to export the constructor and the `DoModal` call. You can export these members using the DLL's .DEF file, but you can also use **AFX_EXT_CLASS** in much the same way on the individual members you need to export.  \n  \n For example:  \n  \n```  \nclass CExampleDialog : public CDialog  \n{  \npublic:  \n    AFX_EXT_CLASS CExampleDialog();\nAFX_EXT_CLASS int DoModal();\n*// rest of class definition  \n .  \n .  \n .  \n};  \n```  \n  \n When you do this, you may run into an additional problem because you are no longer exporting all members of the class. The problem is in the way that MFC macros work. Several of MFC's helper macros actually declare or define data members. Therefore, these data members will also need to be exported from your DLL.  \n  \n For example, the `DECLARE_DYNAMIC` macro is defined as follows when building an extension DLL:  \n  \n```  \n#define DECLARE_DYNAMIC(class_name) \\  \nprotected: \\  \n    static CRuntimeClass* PASCAL _GetBaseClass();\n\n\\  \n    public: \\  \n    static AFX_DATA CRuntimeClass class##class_name; \\  \n    virtual CRuntimeClass* GetRuntimeClass() const;\n\n\\  \n```  \n  \n The line that begins \"static `AFX_DATA`\" is declaring a static object inside of your class. To export this class correctly and access the runtime information from a client .EXE, you need to export this static object. Because the static object is declared with the modifier `AFX_DATA`, you only need to define `AFX_DATA` to be **__declspec(dllexport)** when building your DLL and define it as **__declspec(dllimport)** when building your client executable.  \n  \n As discussed above, **AFX_EXT_CLASS** is already defined in this way. You just need to re-define `AFX_DATA` to be the same as **AFX_EXT_CLASS** around your class definition.  \n  \n For example:  \n  \n```  \n#undef  AFX_DATA  \n#define AFX_DATA AFX_EXT_CLASS  \nclass CExampleView : public CView  \n{  \n    DECLARE_DYNAMIC() *// ... class definition ...  \n};  \n#undef  AFX_DATA  \n#define AFX_DATA  \n```  \n  \n MFC always uses the `AFX_DATA` symbol on data items it defines within its macros, so this technique will work for all such scenarios. For example, it will work for `DECLARE_MESSAGE_MAP`.  \n  \n> [!NOTE]\n>  If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.  \n  \n You can use the same technique to automatically export the `CArchive` extraction operator for classes that use the `DECLARE_SERIAL` and `IMPLEMENT_SERIAL` macros. Export the archive operator by bracketing the class declarations (located in the .H file) with the following code:  \n  \n```  \n#undef AFX_API  \n#define AFX_API AFX_EXT_CLASS  \n \n<your class declarations here>  \n \n#undef AFX_API  \n#define AFX_API  \n```  \n  \n### Limitations of _AFXEXT  \n You can use the _**AFXEXT** pre-processor symbol for your extension DLLs as long as you do not have multiple layers of extension DLLs. If you have extension DLLs that call or derive from classes in your own extension DLLs, which then derive from the MFC classes, you must use your own preprocessor symbol to avoid ambiguity.  \n  \n The problem is that in Win32, you must explicitly declare any data as **__declspec(dllexport)** if it is to be exported from a DLL, and **__declspec(dllimport)** if it is to be imported from a DLL. When you define `_AFXEXT`, the MFC headers make sure that **AFX_EXT_CLASS** is defined correctly.  \n  \n When you have multiple layers, one symbol such as **AFX_EXT_CLASS** is not sufficient, since an extension DLL may be exporting new classes as well as importing other classes from another extension DLL. In order to deal with this problem, use a special preprocessor symbol that indicates that you are building the DLL itself versus using the DLL. For example, imagine two extension DLLs, A.DLL, and B.DLL. They each export some classes in A.H and B.H, respectively. B.DLL uses the classes from A.DLL. The header files would look something like this:  \n  \n```  \n/* A.H */  \n#ifdef A_IMPL  \n #define CLASS_DECL_A   __declspec(dllexport)  \n#else  \n #define CLASS_DECL_A   __declspec(dllimport)  \n#endif  \n \nclass CLASS_DECL_A CExampleA : public CObject  \n{ ... class definition ... };  \n \n/* B.H */  \n#ifdef B_IMPL  \n #define CLASS_DECL_B   __declspec(dllexport)  \n#else  \n #define CLASS_DECL_B   __declspec(dllimport)  \n#endif  \n \nclass CLASS_DECL_B CExampleB : public CExampleA  \n{ ... class definition .. };  \n```  \n  \n When A.DLL is built, it is built with **/D A_IMPL** and when B.DLL is built, it is built with **/D B_IMPL**. By using separate symbols for each DLL, CExampleB is exported and CExampleA is imported when building B.DLL. CExampleA is exported when building A.DLL and imported when used by B.DLL (or some other client).  \n  \n This type of layering cannot be done when using the built-in **AFX_EXT_CLASS** and `_AFXEXT` preprocessor symbols. The technique described above solves this problem in a manner not unlike the mechanism MFC itself uses when building its OLE, Database, and Network extension DLLs.  \n  \n### Not Exporting the Entire Class  \n Again, you will have to take special care when you are not exporting an entire class. You have to ensure that the necessary data items created by the MFC macros are exported correctly. This can be done by re-defining **AFX_DATA** to your specific class' macro. This should be done any time you are not exporting the entire class.  \n  \n For example:  \n  \n```  \n// A.H  \n#ifdef A_IMPL  \n #define CLASS_DECL_A  _declspec(dllexport)  \n#else  \n #define CLASS_DECL_A  _declspec(dllimport)  \n #endif  \n \n#undef  AFX_DATA  \n#define AFX_DATA CLASS_DECL_A  \n \nclass CExampleA : public CObject  \n{  \n    DECLARE_DYNAMIC() \n    CLASS_DECL_A int SomeFunction();\n*//class definition   \n .  \n .  \n .  \n};  \n \n#undef AFX_DATA  \n#define AFX_DATA  \n```  \n  \n### DllMain  \n The following is the exact code you should place in your main source file for your extension DLL. It should come after the standard includes. Note that when you use AppWizard to create starter files for an extension DLL, it supplies a `DllMain` for you.  \n  \n```  \n#include \"afxdllx.h\"  \n  \nstatic AFX_EXTENSION_MODULE extensionDLL;  \n  \nextern \"C\" int APIENTRY   \nDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)  \n{  \n   if (dwReason == DLL_PROCESS_ATTACH)  \n   {  \n      // Extension DLL one-time initialization   \n      if (!AfxInitExtensionModule(  \n             extensionDLL, hInstance))  \n         return 0;  \n  \n      // TODO: perform other initialization tasks here  \n   }  \n   else if (dwReason == DLL_PROCESS_DETACH)  \n   {  \n      // Extension DLL per-process termination  \n      AfxTermExtensionModule(extensionDLL);  \n  \n          // TODO: perform other cleanup tasks here  \n   }  \n   return 1;   // ok  \n}  \n```  \n  \n The call to `AfxInitExtensionModule` captures the modules runtime-classes (`CRuntimeClass` structures) as well as its object factories (`COleObjectFactory` objects) for use later when the **CDynLinkLibrary** object is created. The (optional) call to `AfxTermExtensionModule` allows MFC to cleanup the extension DLL when each process detaches (which happens when the process exits, or when the DLL is unloaded as a result of a **FreeLibrary** call) from the extension DLL. Since most extension DLLs are not dynamically loaded (usually, they are linked via their import libraries), the call to `AfxTermExtensionModule` is usually not necessary.  \n  \n If your application loads and frees extension DLLs dynamically, be sure to call `AfxTermExtensionModule` as shown above. Also be sure to use `AfxLoadLibrary` and `AfxFreeLibrary` (instead of Win32 functions **LoadLibrary** and **FreeLibrary**) if your application uses multiple threads or if it dynamically loads an extension DLL. Using `AfxLoadLibrary` and `AfxFreeLibrary` insures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state.  \n  \n The header file AFXDLLX.H contains special definitions for structures used in extension DLLs, such as the definition for `AFX_EXTENSION_MODULE` and **CDynLinkLibrary**.  \n  \n The global *extensionDLL* must be declared as shown. Unlike the 16-bit version of MFC, you can allocate memory and call MFC functions during this time, since the MFCxx.DLL is fully initialized by the time your `DllMain` is called.  \n  \n### Sharing Resources and Classes  \n Simple MFC extension DLLs need only export a few low-bandwidth functions to the client application and nothing more. More user-interface intensive DLLs may want to export resources and C++ classes to the client application.  \n  \n Exporting resources is done through a resource list. In each application is a singly linked list of **CDynLinkLibrary** objects. When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (`AfxGetResourceHandle`) and if not found walk the list of **CDynLinkLibrary** objects attempting to load the requested resource.  \n  \n Dynamic creation of C++ objects given a C++ class name is similar. The MFC object deserialization mechanism needs to have all of the `CRuntimeClass` objects registered so that it can reconstruct by dynamically creating C++ object of the required type based on what was stored earlier.  \n  \n If you want the client application to use classes in your extension DLL that are `DECLARE_SERIAL`, then you will need to export your classes to be visible to the client application. This is also done by walking the **CDynLinkLibrary** list.  \n  \n In the case of the MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md), the list looks something like:  \n  \n```  \nhead ->   DLLHUSK.EXE   - or -   DLLHUSK.EXE  \n |      |  \n    TESTDLL2.DLL TESTDLL2.DLL  \n |      |  \n    TESTDLL1.DLL TESTDLL1.DLL  \n |      |  \n |      |  \n    MFC90D.DLL MFC90.DLL  \n```  \n  \n The MFCxx.DLL is usually last on the resource and class list. MFCxx.DLL includes all of the standard MFC resources, including prompt strings for all the standard command IDs. Placing it at the tail of the list allows DLLs and the client application itself to not have a their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.DLL instead.  \n  \n Merging the resources and class names of all DLLs into the client application's name space has the disadvantage that you have to be careful what IDs or names you pick. You can of course disable this feature by not exporting either your resources or a **CDynLinkLibrary** object to the client application. The [DLLHUSK](../visual-cpp-samples.md) sample manages the shared resource name space by using multiple header files. See [Technical Note 35](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md) for more tips on using shared resource files.  \n  \n### Initializing the DLL  \n As mentioned above, you will usually want to create a **CDynLinkLibrary** object in order to export your resources and classes to the client application. You will need to provide an exported entry point to initialize the DLL. Minimally, this is a void routine that takes no arguments and returns nothing, but it can be anything you like.  \n  \n Each client application that wants to use your DLL must call this initialization routine, if you use this approach. You may also allocate this **CDynLinkLibrary** object in your `DllMain` just after calling `AfxInitExtensionModule`.  \n  \n The initialization routine must create a **CDynLinkLibrary** object in the current application's heap, wired up to your extension DLL information. This can be done with the following:  \n  \n```  \nextern \"C\" extern void WINAPI InitXxxDLL()  \n{  \n    new CDynLinkLibrary(extensionDLL);\n\n}  \n```  \n  \n The routine name, *InitXxxDLL* in this example, can be anything you want. It does not need to be `extern \"C\"`, but doing so makes the export list easier to maintain.  \n  \n> [!NOTE]\n>  If you use your extension DLL from a regular DLL, you must export this initialization function. This function must be called from the regular DLL before using any extension DLL classes or resources.  \n  \n### Exporting Entries  \n The simple way to export your classes is to use **__declspec(dllimport)** and **__declspec(dllexport)** on each class and global function you wish to export. This makes it a lot easier, but is less efficient than naming each entry point (described below) since you have less control over what functions are exported and you cannot export the functions by ordinal. TESTDLL1 and TESTDLL2 use this method to export their entries.  \n  \n A more efficient method (and the method used by MFCxx.DLL) is to export each entry by hand by naming each entry in the .DEF file. Since we are exporting selective exports from our DLL (that is, not everything), we must decide which particular interfaces we wish to export. This is difficult since you must specify the mangled names to the linker in the form of entries in the .DEF file. Don't export any C++ classes unless you really need to have a symbolic link for it.  \n  \n If you have tried exporting C++ classes with a .DEF file before, you may want to develop a tool to generate this list automatically. This can be done using a two-stage link process. Link your DLL once with no exports, and allow the linker to generate a .MAP file. The .MAP file can be used to generate a list of functions that should be exported, so with some rearranging, it can be used to generate your EXPORT entries for your .DEF file. The export list for MFCxx.DLL and the OLE and Database extension DLLs, several thousand in number, was generated with such a process (although it is not completely automatic and requires some hand tuning every once in a while).  \n  \n### CWinApp vs. CDynLinkLibrary  \n An MFC Extension DLL does not have a `CWinApp`-derived object of its own; instead it must work with the `CWinApp`-derived object of the client application. This means that the client application owns the main message pump, the idle loop and so on.  \n  \n If your MFC Extension DLL needs to maintain extra data for each application, you can derive a new class from **CDynLinkLibrary** and create it in the InitXxxDLL routine describe above. When running, the DLL can check the current application's list of **CDynLinkLibrary** objects to find the one for that particular extension DLL.  \n  \n### Using Resources in Your DLL Implementation  \n As mentioned above, the default resource load will walk the list of **CDynLinkLibrary** objects looking for the first EXE or DLL that has the requested resource. All MFC APIs as well as all the internal code uses `AfxFindResourceHandle` to walk the resource list to find any resource, no matter where it may reside.  \n  \n If you wish to only load resources from a specific place, use the APIs `AfxGetResourceHandle` and `AfxSetResourceHandle` to save the old handle and set the new handle. Be sure to restore the old resource handle before you return to the client application. The sample TESTDLL2 uses this approach for explicitly loading a menu.  \n  \n Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges. It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle. `AfxFindResourceHandle` is an API used for walking the resource list to look for a given match. It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).  \n  \n##  <a name=\"_mfcnotes_writing_an_application_that_uses_the_dll_version\"></a> Writing an Application That Uses the DLL Version  \n  \n### Application Requirements  \n An application that uses the shared version of MFC must follow a few simple rules:  \n  \n-   It must have a `CWinApp` object and follow the standard rules for a message pump.  \n  \n-   It must be compiled with a set of required compiler flags (see below).  \n  \n-   It must link with the MFCxx import libraries. By setting the required compiler flags, the MFC headers determine at link time which library the application should link with.  \n  \n-   To run the executable, MFCxx.DLL must be on the path or in the Windows system directory.  \n  \n### Building with the Development Environment  \n If you are using the internal makefile with most of the standard defaults, you can easily change the project to build the DLL version.  \n  \n The following step assumes you have a correctly functioning MFC application linked with NAFXCWD.LIB (for debug) and NAFXCW.LIB (for retail) and you want to convert it to use the shared version of the MFC library. You are running the Visual C++ environment and have an internal project file.  \n  \n1.  On the **Projects** menu, click **Properties**. In the **General** page under **Project Defaults**, set Microsoft Foundation Classes to **Use MFC in a Shared DLL** (MFCxx(d).dll).  \n  \n### Building with NMAKE  \n If you are using the external makefile feature of the Visual C++, or are using NMAKE directly, you will have to edit your makefile to support compiler and linker options  \n  \n Required compiler flags:  \n  \n **/D_AFXDLL /MD**  \n **/D_AFXDLL**  \n  \n The standard MFC headers need this symbol to be defined:  \n  \n **/MD**  \n The application must use the DLL version of the C run-time library  \n  \n All other compiler flags follow the MFC defaults (for example, _DEBUG for debug).  \n  \n Edit the linker list of libraries. Change NAFXCWD.LIB to MFCxxD.LIB and change NAFXCW.LIB to MFCxx.LIB. Replace LIBC.LIB with MSVCRT.LIB. As with any other MFC library it is important that MFCxxD.LIB is placed **before** any C-runtime libraries.  \n  \n Optionally add **/D_AFXDLL** to both your retail and debug resource compiler options (the one that actually compiles the resources with **/R**). This makes your final executable smaller by sharing the resources that are present in the MFC DLLs.  \n  \n A full rebuild is required after these changes are made.  \n  \n### Building the Samples  \n Most of the MFC sample programs can be built from Visual C++ or from a shared NMAKE-compatible MAKEFILE from the command line.  \n  \n To convert any of these samples to use MFCxx.DLL, you can load the .MAK file into the Visual C++ and set the Project options as described above. If you are using the NMAKE build, you can specify \"AFXDLL=1\" on the NMAKE command line and that will build the sample using the shared MFC libraries.  \n  \n The MFC Advanced Concepts sample [DLLHUSK](../visual-cpp-samples.md) is built with the DLL version of MFC. This sample not only illustrates how to build an application linked with MFCxx.DLL, but it also illustrates other features of the MFC DLL packaging option such as MFC Extension DLLs described later in this technical note.  \n  \n### Packaging Notes  \n The retail version of the DLLs (MFCxx[U].DLL) are freely redistributable. The debug version of the DLLs are not freely redistributable and should be used only during the development of your application.  \n  \n The debug DLLs are provided with debugging information. By using the Visual C++ debugger, you can trace execution of your application as well as the DLL. The Release DLLs (MFCxx[U].DLL) do not contain debugging information.  \n  \n If you customize or rebuild the DLLs, then you should call them something other than \"MFCxx\" The MFC SRC file MFCDLL.MAK describes build options and contains the logic for renaming the DLL. Renaming the files is necessary, since these DLLs are potentially shared by many MFC applications. Having your custom version of the MFC DLLs replace those installed on the system may break another MFC application using the shared MFC DLLs.  \n  \n Rebuilding the MFC DLLs is not recommended.  \n  \n##  <a name=\"_mfcnotes_how_the_mfc30.dll_is_implemented\"></a> How the MFCxx.DLL Is Implemented  \n The following section describes how the MFC DLL (MFCxx.DLL and MFCxxD.DLL) is implemented. Understanding the details here are also not important if all you want to do is use the MFC DLL with your application. The details here are not essential for understanding how to write an MFC extension DLL, but understanding this implementation may help you write your own DLL.  \n  \n### Implementation Overview  \n The MFC DLL is really a special case of an MFC Extension DLL as described above. It has a very large number of exports for a large number of classes. There are a few additional things we do in the MFC DLL that make it even more special than a regular Extension DLL.  \n  \n### Win32 Does Most of the Work  \n The 16-bit version of MFC needed a number of special techniques including per-app data on the stack segment, special segments created by some 80x86 assembly code, per-process exception contexts, and other techniques. Win32 directly supports per-process data in a DLL, which is what you want most of the time. For the most part MFCxx.DLL is just NAFXCW.LIB packaged in a DLL. If you look at the MFC source code, you'll find very few #ifdef _AFXDLL, since there are very few special cases that need to be made. The special cases that are there are specifically to deal with Win32 on Windows 3.1 (otherwise known as Win32s). Win32s does not support per-process DLL data directly so the MFC DLL must use the thread-local storage (TLS) Win32 APIs to obtain process local data.  \n  \n### Impact on Library Sources, Additional Files  \n The impact of the **_AFXDLL** version on the normal MFC class library sources and headers is relatively minor. There is a special version file (AFXV_DLL.H) as well as an additional header file (AFXDLL_.H) included by the main AFXWIN.H header. The AFXDLL_.H header includes the **CDynLinkLibrary** class and other implementation details of both **_AFXDLL** applications and MFC Extension DLLs. The AFXDLLX.H header is provided for building MFC Extension DLLs (see above for details).  \n  \n The regular sources to the MFC library in MFC SRC have some additional conditional code under the **_AFXDLL** #ifdef. An additional source file (DLLINIT.CPP) contains the extra DLL initialization code and other glue for the shared version of MFC.  \n  \n In order to build the shared version of MFC, additional files are provided. (See below for details on how to build the DLL.)  \n  \n-   Two .DEF files are used for exporting the MFC DLL entry points for debug (MFCxxD.DEF) and release (MFCxx.DEF) versions of the DLL.  \n  \n-   An .RC file (MFCDLL.RC) contains all the standard MFC resources and a VERSIONINFO resource for the DLL.  \n  \n-   A .CLW file (MFCDLL.CLW) is provided to allow browsing the MFC classes using ClassWizard. Note: this feature is not particular to the DLL version of MFC.  \n  \n### Memory Management  \n An application using MFCxx.DLL uses a common memory allocator provided by MSVCRTxx.DLL, the shared C-runtime DLL. The application, any extension DLLs, and well as the MFC DLLs themselves use this shared memory allocator. By using a shared DLL for memory allocation, the MFC DLLs can allocate memory that is later freed by the application or vice versa. Because both the application and the DLL must use the same allocator, you should not override the C++ global `operator new` or `operator delete`. The same rules apply to the rest of the C run-time memory allocation routines (such as `malloc`, `realloc`, **free**, and others).  \n  \n### Ordinals and class __declspec(dllexport) and DLL naming  \n We do not use the `class` **__declspec(dllexport)** functionality of the C++ compiler. Instead, a list of exports is included with the class library sources (MFCxx.DEF and MFCxxD.DEF). Only these select set of entry points (functions and data) are exported. Other symbols, such as MFC private implementation functions or classes, are not exported All exports are done by ordinal without a string name in the resident or non-resident name table.  \n  \n Using `class` **__declspec(dllexport)** may be a viable alternative for building smaller DLLs, but in the case of a large DLL like MFC, the default exporting mechanism has efficiency and capacity limits.  \n  \n What this all means is that we can package a large amount of functionality in the release MFCxx.DLL that is only around 800 KB without compromising much execution or loading speed. MFCxx.DLL would have been 100K larger had this technique not been used. This also makes it possible to add additional entry points at the end of the .DEF file to allow simple versioning without compromising the speed and size efficiency of exporting by ordinal. Major version revisions in the MFC class library will change the library name. That is, MFC30.DLL is the redistributable DLL containing version 3.0 of the MFC class library. An upgrade of this DLL, say, in a hypothetical MFC 3.1, the DLL would be named MFC31.DLL instead. Again, if you modify the MFC source code to produce a custom version of the MFC DLL, use a different name (and preferably one without \"MFC\" in the name).  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}