{"nodes":[{"pos":[12,46],"content":"using Declaration | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"using Declaration | Microsoft Docs","pos":[0,34]}]},{"content":"using Declaration","pos":[822,839]},{"pos":[840,951],"content":"The <ph id=\"ph1\">`using`</ph> declaration introduces a name into the declarative region in which the <ph id=\"ph2\">`using`</ph> declaration appears.","source":"The `using` declaration introduces a name into the declarative region in which the `using` declaration appears."},{"content":"Syntax","pos":[960,966]},{"content":"Remarks","pos":[1085,1092]},{"content":"The name becomes a synonym for an entity declared elsewhere.","pos":[1096,1156]},{"content":"It allows an <bpt id=\"p1\">*</bpt>individual<ept id=\"p1\">*</ept> name from a specific namespace to be used without explicit qualification.","pos":[1157,1256],"source":" It allows an *individual* name from a specific namespace to be used without explicit qualification."},{"content":"This is in contrast to the <ph id=\"ph1\">`using`</ph> directive, which allows <bpt id=\"p1\">*</bpt>all<ept id=\"p1\">*</ept> the names in a namespace to be used without qualification.","pos":[1257,1380],"source":" This is in contrast to the `using` directive, which allows *all* the names in a namespace to be used without qualification."},{"content":"See <bpt id=\"p1\">[</bpt>using directives<ept id=\"p1\">](../cpp/namespaces-cpp.md#using_directives)</ept> for more information.","pos":[1381,1468],"source":" See [using directives](../cpp/namespaces-cpp.md#using_directives) for more information."},{"content":"This keyword is also used for <bpt id=\"p1\">[</bpt>type aliases<ept id=\"p1\">](../cpp/aliases-and-typedefs-cpp.md)</ept>.","pos":[1469,1550],"source":" This keyword is also used for [type aliases](../cpp/aliases-and-typedefs-cpp.md)."},{"content":"Example","pos":[1559,1566]},{"content":"A using declaration can be used in a class definition.","pos":[1570,1624]},{"content":"Example","pos":[2194,2201]},{"content":"When used to declare a member, a using declaration must refer to a member of a base class.","pos":[2205,2295]},{"content":"Example","pos":[2794,2801]},{"content":"Members declared with a using declaration can be referenced using explicit qualification.","pos":[2805,2894]},{"content":"The <ph id=\"ph1\">`::`</ph> prefix refers to the global namespace.","pos":[2895,2942],"source":" The `::` prefix refers to the global namespace."},{"content":"Example","pos":[3400,3407]},{"content":"When a using declaration is made, the synonym created by the declaration refers only to definitions that are valid at the point of the using declaration.","pos":[3411,3564]},{"content":"Definitions added to a namespace after the using declaration are not valid synonyms.","pos":[3565,3649]},{"content":"A name defined by a using declaration is an alias for its original name.","pos":[3656,3728]},{"content":"It does not affect the type, linkage or other attributes of the original declaration.","pos":[3729,3814]},{"content":"Example","pos":[4251,4258]},{"content":"With respect to functions in namespaces, if a set of local declarations and using declarations for a single name are given in a declarative region, they must all refer to the same entity, or they must all refer to functions.","pos":[4262,4486]},{"content":"In the example above, the <ph id=\"ph1\">`using B::i`</ph> statement causes a second <ph id=\"ph2\">`int i`</ph> to be declared in the <ph id=\"ph3\">`g()`</ph> function.","pos":[4787,4897],"source":"In the example above, the `using B::i` statement causes a second `int i` to be declared in the `g()` function."},{"content":"The <ph id=\"ph1\">`using B::f`</ph> statement does not conflict with the <ph id=\"ph2\">`f(char)`</ph> function because the function names introduced by <ph id=\"ph3\">`B::f`</ph> have different parameter types.","pos":[4898,5050],"source":" The `using B::f` statement does not conflict with the `f(char)` function because the function names introduced by `B::f` have different parameter types."},{"content":"Example","pos":[5059,5066]},{"content":"A local function declaration cannot have the same name and type as a function introduced by using declaration.","pos":[5070,5180]},{"content":"For example:","pos":[5181,5193]},{"content":"Example","pos":[5770,5777]},{"content":"With respect to inheritance, when a using declaration introduces a name from a base class into a derived class scope, member functions in the derived class override virtual member functions with the same name and argument types in the base class.","pos":[5781,6027]},{"content":"Example","pos":[7019,7026]},{"content":"All instances of a name mentioned in a using declaration must be accessible.","pos":[7030,7106]},{"content":"In particular, if a derived class uses a using declaration to access a member of a base class, the member name must be accessible.","pos":[7107,7237]},{"content":"If the name is that of an overloaded member function, then all functions named must be accessible.","pos":[7238,7336]},{"pos":[7343,7458],"content":"See <bpt id=\"p1\">[</bpt>Member-Access Control<ept id=\"p1\">](../cpp/member-access-control-cpp.md)</ept>, for more information on accessibility of members.","source":"See [Member-Access Control](../cpp/member-access-control-cpp.md), for more information on accessibility of members."},{"content":"See Also","pos":[7801,7809]},{"content":"Namespaces","pos":[7814,7824]},{"content":"Keywords","pos":[7857,7865]}],"content":"---\ntitle: \"using Declaration | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"using declaration\"\n  - \"declaring namespaces, unqualified names in namespaces\"\n  - \"declarations [C++], using-declaration\"\n  - \"namespaces [C++], unqualified names in\"\n  - \"using keyword [C++]\"\n  - \"declarations [C++], namespaces\"\nms.assetid: 4184e2b1-3adc-408e-b5f3-0b3f8b554723\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# using Declaration\nThe `using` declaration introduces a name into the declarative region in which the `using` declaration appears.  \n  \n## Syntax  \n  \n```  \n  \n      using [typename][::] nested-name-specifier unqualified-id  \nusing :: unqualified-id  \n```  \n  \n## Remarks  \n The name becomes a synonym for an entity declared elsewhere. It allows an *individual* name from a specific namespace to be used without explicit qualification. This is in contrast to the `using` directive, which allows *all* the names in a namespace to be used without qualification. See [using directives](../cpp/namespaces-cpp.md#using_directives) for more information. This keyword is also used for [type aliases](../cpp/aliases-and-typedefs-cpp.md).  \n  \n## Example  \n A using declaration can be used in a class definition.  \n  \n```cpp  \n// using_declaration1.cpp  \n#include <stdio.h>  \nclass B {  \npublic:  \n   void f(char) {  \n      printf_s(\"In B::f()\\n\");  \n   }  \n  \n   void g(char) {  \n      printf_s(\"In B::g()\\n\");  \n   }  \n};  \n  \nclass D : B {  \npublic:  \n   using B::f;  \n   using B::g;  \n   void f(int) {  \n      printf_s(\"In D::f()\\n\");  \n      f('c');  \n   }  \n  \n   void g(int) {  \n      printf_s(\"In D::g()\\n\");  \n      g('c');  \n   }  \n};  \n  \nint main() {  \n   D myD;  \n   myD.f(1);  \n   myD.g('a');  \n}  \n```  \n  \n```Output  \nIn D::f()  \nIn B::f()  \nIn B::g()  \n```  \n  \n## Example  \n When used to declare a member, a using declaration must refer to a member of a base class.  \n  \n```cpp  \n// using_declaration2.cpp  \n#include <stdio.h>  \n  \nclass B {  \npublic:  \n   void f(char) {  \n      printf_s(\"In B::f()\\n\");  \n   }  \n  \n   void g(char) {  \n      printf_s(\"In B::g()\\n\");  \n   }  \n};  \n  \nclass C {  \npublic:  \n   int g();  \n};  \n  \nclass D2 : public B {  \npublic:  \n   using B::f;   // ok: B is a base of D2  \n   // using C::g;   // error: C isn't a base of D2  \n};  \n  \nint main() {  \n   D2 MyD2;  \n   MyD2.f('a');  \n}  \n```  \n  \n```Output  \nIn B::f()  \n```  \n  \n## Example  \n Members declared with a using declaration can be referenced using explicit qualification. The `::` prefix refers to the global namespace.  \n  \n```cpp  \n// using_declaration3.cpp  \n#include <stdio.h>  \n  \nvoid f() {  \n   printf_s(\"In f\\n\");  \n}  \n  \nnamespace A {  \n   void g() {  \n      printf_s(\"In A::g\\n\");  \n   }  \n}  \n  \nnamespace X {  \n   using ::f;   // global f  \n   using A::g;   // A's g  \n}  \n  \nvoid h() {  \n   printf_s(\"In h\\n\");  \n   X::f();   // calls ::f  \n   X::g();   // calls A::g  \n}  \n  \nint main() {  \n   h();  \n}  \n```  \n  \n```Output  \nIn h  \nIn f  \nIn A::g  \n```  \n  \n## Example  \n When a using declaration is made, the synonym created by the declaration refers only to definitions that are valid at the point of the using declaration. Definitions added to a namespace after the using declaration are not valid synonyms.  \n  \n A name defined by a using declaration is an alias for its original name. It does not affect the type, linkage or other attributes of the original declaration.  \n  \n```cpp  \n// post_declaration_namespace_additions.cpp  \n// compile with: /c  \nnamespace A {  \n   void f(int) {}  \n}  \n  \nusing A::f;   // f is a synonym for A::f(int) only  \n  \nnamespace A {  \n   void f(char) {}  \n}  \n  \nvoid f() {  \n   f('a');   // refers to A::f(int), even though A::f(char) exists  \n}  \n  \nvoid b() {  \n   using A::f;   // refers to A::f(int) AND A::f(char)  \n   f('a');   // calls A::f(char);  \n}  \n```  \n  \n## Example  \n With respect to functions in namespaces, if a set of local declarations and using declarations for a single name are given in a declarative region, they must all refer to the same entity, or they must all refer to functions.  \n  \n```cpp  \n// functions_in_namespaces1.cpp  \n// C2874 expected  \nnamespace B {  \n    int i;  \n    void f(int);  \n    void f(double);  \n}  \n  \nvoid g() {  \n    int i;  \n    using B::i;   // error: i declared twice  \n    void f(char);  \n    using B::f;   // ok: each f is a function  \n}  \n```  \n  \n In the example above, the `using B::i` statement causes a second `int i` to be declared in the `g()` function. The `using B::f` statement does not conflict with the `f(char)` function because the function names introduced by `B::f` have different parameter types.  \n  \n## Example  \n A local function declaration cannot have the same name and type as a function introduced by using declaration. For example:  \n  \n```cpp  \n// functions_in_namespaces2.cpp  \n// C2668 expected  \nnamespace B {  \n    void f(int);  \n    void f(double);  \n}  \n  \nnamespace C {  \n    void f(int);  \n    void f(double);  \n    void f(char);  \n}  \n  \nvoid h() {  \n    using B::f;          // introduces B::f(int) and B::f(double)  \n    using C::f;          // C::f(int), C::f(double), and C::f(char)  \n    f('h');              // calls C::f(char)  \n    f(1);                // C2668 ambiguous: B::f(int) or C::f(int)?  \n    void f(int);         // C2883 conflicts with B::f(int) and C::f(int)  \n}  \n```  \n  \n## Example  \n With respect to inheritance, when a using declaration introduces a name from a base class into a derived class scope, member functions in the derived class override virtual member functions with the same name and argument types in the base class.  \n  \n```cpp  \n// using_declaration_inheritance1.cpp  \n#include <stdio.h>  \nstruct B {  \n   virtual void f(int) {  \n      printf_s(\"In B::f(int)\\n\");  \n   }  \n  \n   virtual void f(char) {  \n      printf_s(\"In B::f(char)\\n\");  \n   }  \n  \n   void g(int) {  \n      printf_s(\"In B::g\\n\");  \n   }  \n  \n   void h(int);  \n};  \n  \nstruct D : B {  \n   using B::f;  \n   void f(int) {   // ok: D::f(int) overrides B::f(int)  \n      printf_s(\"In D::f(int)\\n\");  \n   }  \n  \n   using B::g;  \n   void g(char) {   // ok: there is no B::g(char)  \n      printf_s(\"In D::g(char)\\n\");  \n   }  \n  \n   using B::h;  \n   void h(int) {}   // Note: D::h(int) hides non-virtual B::h(int)  \n};  \n  \nvoid f(D* pd) {  \n   pd->f(1);   // calls D::f(int)  \n   pd->f('a');   // calls B::f(char)  \n   pd->g(1);   // calls B::g(int)  \n   pd->g('a');   // calls D::g(char)  \n}  \n  \nint main() {  \n   D * myd = new D();  \n   f(myd);  \n}  \n```  \n  \n```Output  \nIn D::f(int)  \nIn B::f(char)  \nIn B::g  \nIn D::g(char)  \n```  \n  \n## Example  \n All instances of a name mentioned in a using declaration must be accessible. In particular, if a derived class uses a using declaration to access a member of a base class, the member name must be accessible. If the name is that of an overloaded member function, then all functions named must be accessible.  \n  \n See [Member-Access Control](../cpp/member-access-control-cpp.md), for more information on accessibility of members.  \n  \n```cpp  \n// using_declaration_inheritance2.cpp  \n// C2876 expected  \nclass A {  \nprivate:  \n   void f(char);  \npublic:  \n   void f(int);  \nprotected:  \n   void g();  \n};  \n  \nclass B : public A {  \n   using A::f;   // C2876: A::f(char) is inaccessible  \npublic:  \n   using A::g;   // B::g is a public synonym for A::g  \n};  \n```  \n  \n## See Also  \n [Namespaces](../cpp/namespaces-cpp.md)   \n [Keywords](../cpp/keywords-cpp.md)"}