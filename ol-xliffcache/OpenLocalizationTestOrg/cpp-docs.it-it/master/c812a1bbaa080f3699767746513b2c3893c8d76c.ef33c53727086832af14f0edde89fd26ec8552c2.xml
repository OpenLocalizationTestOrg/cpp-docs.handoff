{"nodes":[{"pos":[12,49],"content":"Compiler Error C2660 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2660 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C2660","pos":[624,644]},{"content":"'function' : function does not take number parameters","pos":[645,698]},{"content":"The function is called with an incorrect number of parameters.","pos":[705,767]},{"content":"C2660 can occur if you accidentally call a Windows API function rather than an MFC member function of the same name.","pos":[774,890]},{"content":"To solve this problem:","pos":[891,913]},{"content":"Adjust the function call to conform to the format of the member function call.","pos":[923,1001]},{"pos":[1011,1124],"content":"Use the scope resolution operator (<ph id=\"ph1\">`::`</ph>) to tell the compiler to seek the function name in the global name space.","source":"Use the scope resolution operator (`::`) to tell the compiler to seek the function name in the global name space."},{"content":"Example","pos":[1133,1140]},{"content":"The following sample generates C2660.","pos":[1144,1181]},{"content":"Example","pos":[1348,1355]},{"content":"C2660 can also occur if you attempt to directly call the Dispose method of a managed type.","pos":[1359,1449]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Destructors and finalizers<ept id=\"p1\">](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)</ept>.","pos":[1450,1608],"source":" For more information, see [Destructors and finalizers](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)."},{"content":"The following sample generates C2660.","pos":[1609,1646]},{"content":"Example","pos":[2132,2139]},{"content":"C2660 will occur if a derived class hides a function.","pos":[2143,2196]},{"content":"Example","pos":[2662,2669]},{"content":"C2660 can occur if you invoke an indexed property incorrectly.","pos":[2673,2735]},{"content":"Example","pos":[3156,3163]},{"content":"C2660 can occur if you invoke an indexed property incorrectly.","pos":[3167,3229]},{"content":"Example","pos":[3540,3547]},{"content":"C2660 can occur if you define a new operator in a template class, but where the new operator creates an object whose type is other than the enclosing type.","pos":[3551,3706]}],"content":"---\ntitle: \"Compiler Error C2660 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2660\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2660\"\nms.assetid: 2e01a1db-4f00-4df6-a04d-cb6f70a6922b\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Error C2660\n'function' : function does not take number parameters  \n  \n The function is called with an incorrect number of parameters.  \n  \n C2660 can occur if you accidentally call a Windows API function rather than an MFC member function of the same name. To solve this problem:  \n  \n-   Adjust the function call to conform to the format of the member function call.  \n  \n-   Use the scope resolution operator (`::`) to tell the compiler to seek the function name in the global name space.  \n  \n## Example  \n The following sample generates C2660.  \n  \n```  \n// C2660.cpp  \nvoid func( int, int ) {}  \n  \nint main() {  \n   func( 1 );   // C2660 func( int ) not declared  \n   func( 1, 0 );   // OK  \n}  \n```  \n  \n## Example  \n C2660 can also occur if you attempt to directly call the Dispose method of a managed type. For more information, see [Destructors and finalizers](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers). The following sample generates C2660.  \n  \n```  \n// C2660_a.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Threading;  \n  \nvoid CheckStatus( Object^ stateInfo ) {}  \n  \nint main() {  \n   ManualResetEvent^ event = gcnew ManualResetEvent( false );     \n   TimerCallback^ timerDelegate = gcnew TimerCallback( &CheckStatus );  \n   Timer^ stateTimer = gcnew Timer( timerDelegate, event, 1000, 250 );  \n  \n   stateTimer->Dispose();   // C2660  \n   stateTimer->~Timer();   // OK  \n}  \n```  \n  \n## Example  \n C2660 will occur if a derived class hides a function.  \n  \n```  \n// C2660b.cpp  \n// C2660 expected  \n#include <stdio.h>  \n  \nclass f {  \npublic:  \n   void bar() {  \n      printf_s(\"in f::bar\\n\");  \n    }  \n};  \n  \nclass f2 : public f {  \npublic:  \n   void bar(int i){printf(\"in f2::bar\\n\");}  \n   // Uncomment the following line to resolve.  \n   // using f::bar;   // - using declaration added  \n   // or  \n   // void bar(){__super::bar();}  \n};  \n  \nint main() {  \n   f2 fObject;  \n   fObject.bar();  \n}  \n```  \n  \n## Example  \n C2660 can occur if you invoke an indexed property incorrectly.  \n  \n```  \n// C2660c.cpp  \n// compile with: /clr  \nref class X {  \n   double d;  \npublic:  \n   X() : d(1.9) {}  \n   property double MyProp[] {  \n      double get(int i) {  \n         return d;  \n      }  \n   }   // end MyProp definition  \n};  \n  \nint main() {  \n   X ^ MyX = gcnew X();  \n   System::Console::WriteLine(MyX->MyProp(1));   // C2660  \n   System::Console::WriteLine(MyX->MyProp[1]);   // OK  \n}  \n```  \n  \n## Example  \n C2660 can occur if you invoke an indexed property incorrectly.  \n  \n```  \n// C2660d.cpp  \n// compile with: /clr  \nref class A{  \npublic:  \n   property int default[int,int] {  \n      int get(int a, int b) {  \n         return a + b;  \n      }  \n   }  \n};  \n  \nint main() {  \n   A^ a = gcnew A;  \n   int x = a[3][5];   // C2660  \n   int x2 = a[3,5];   // OK  \n}  \n```  \n  \n## Example  \n C2660 can occur if you define a new operator in a template class, but where the new operator creates an object whose type is other than the enclosing type.  \n  \n```  \n// C2660e.cpp  \n// compile with: /c  \n#include <malloc.h>  \n  \ntemplate <class T> class CA {  \nprivate:  \n    static T** line;  \n   void* operator new (size_t, int i) {   \n      return 0;  \n   }  \n   void operator delete(void* pMem, int i) {  \n      free(pMem);  \n   }  \n  \npublic:  \n   CA () { new (1) T(); }   // C2660  \n   // try the following line instead  \n   // CA () { new (1) CA<int>(); }  \n};  \n  \ntypedef CA <int> int_CA;  \n  \nvoid AAA() {  \n   int_CA  list;  \n}  \n```"}