{"nodes":[{"pos":[12,57],"content":"User-Defined Literals  (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"User-Defined Literals  (C++) | Microsoft Docs","pos":[0,45]}]},{"content":"User-Defined Literals  (C++)","pos":[548,576]},{"content":"There are five major categories of literals:  integer,  character,  floating-point,  string, boolean and pointer.","pos":[577,690]},{"content":"Starting in C++ 11 you can define your own literals based on these categories to provide syntactic shortcuts for common idioms and increase type safety.","pos":[692,844]},{"content":"For example, let's say you have a Distance class.","pos":[845,894]},{"content":"You could define a literal for kilometers and another one for miles, and encourage the user to be explicit about the units of measure by simply writing: auto d = 42.0_km or auto d = 42.0_mi.","pos":[895,1085]},{"content":"There is no performance advantage or disadvantage to user-defined literals; they are primarily for convenience or for compile-time type deduction.","pos":[1086,1232]},{"content":"The Standard Library has user-defined literals for std:string, for std::complex, and for units in time and duration operations in the <ph id=\"ph1\">\\&lt;</ph>chrono&gt; header:","pos":[1233,1384],"source":" The Standard Library has user-defined literals for std:string, for std::complex, and for units in time and duration operations in the \\<chrono> header:"},{"content":"User-defined literal operator signatures","pos":[1744,1784]},{"pos":[1788,1904],"content":"You implement a user-defined literal by defining an <ph id=\"ph1\">`operator\"\"`</ph> at namespace scope with one of the following forms:","source":"You implement a user-defined literal by defining an `operator\"\"` at namespace scope with one of the following forms:"},{"content":"The operator names in the previous example are placeholders for whatever name you provide; however, the leading underscore is required.","pos":[3175,3310]},{"content":"(Only the Standard Library is allowed to define literals without the underscore.) The return type is where you customize the conversion or other operation that the literal performs.","pos":[3311,3492]},{"content":"Also, any of these operators can be defined as <ph id=\"ph1\">`constexpr`</ph>.","pos":[3493,3552],"source":" Also, any of these operators can be defined as `constexpr`."},{"content":"Cooked literals","pos":[3561,3576]},{"content":"In source code any literal whether user-defined or not is essentially a sequence of alphanumeric characters, such as <ph id=\"ph1\">`101`</ph>, or <ph id=\"ph2\">`54.7`</ph>, or <ph id=\"ph3\">`\"hello\"`</ph> or <ph id=\"ph4\">`true`</ph>.","pos":[3580,3738],"source":"In source code any literal whether user-defined or not is essentially a sequence of alphanumeric characters, such as `101`, or `54.7`, or `\"hello\"` or `true`."},{"content":"The compiler interprets the sequence as an integer, float, const char<ph id=\"ph1\">\\*</ph> string, and so on.","pos":[3739,3829],"source":" The compiler interprets the sequence as an integer, float, const char\\* string, and so on."},{"content":"A user-defined literal that accepts as input whatever type the compiler assigned to the literal value is informally known as a <bpt id=\"p1\">*</bpt>cooked literal<ept id=\"p1\">*</ept>.","pos":[3830,3974],"source":" A user-defined literal that accepts as input whatever type the compiler assigned to the literal value is informally known as a *cooked literal*."},{"content":"All the operators above except <ph id=\"ph1\">`_r`</ph> and <ph id=\"ph2\">`_t`</ph> are cooked literals.","pos":[3975,4040],"source":" All the operators above except `_r` and `_t` are cooked literals."},{"content":"For example, a literal <ph id=\"ph1\">`42.0_km`</ph> would bind to an operator named _km that had a signature similar to _b and the literal <ph id=\"ph2\">`42_km`</ph> would bind to an operator with a signature similar to _a.","pos":[4041,4226],"source":" For example, a literal `42.0_km` would bind to an operator named _km that had a signature similar to _b and the literal `42_km` would bind to an operator with a signature similar to _a."},{"content":"The following example shows how user-defined literals can encourage callers to be explicit about their input.","pos":[4233,4342]},{"content":"To construct a <ph id=\"ph1\">`Distance`</ph>, the user must explicitly specify kilometers or miles by using the appropriate user-defined literal.","pos":[4343,4469],"source":" To construct a `Distance`, the user must explicitly specify kilometers or miles by using the appropriate user-defined literal."},{"content":"Of course you can also achieve the same result in other ways, but user-defined literals are less verbose than the alternatives.","pos":[4470,4597]},{"content":"Note that the literal number must use a decimal, otherwise the number would be interpreted as an integer and the type would not be compatible with the operator.","pos":[5912,6072]},{"content":"Also note that for floating point input, the type must be <ph id=\"ph1\">`long double`</ph>, and for integral types it must be <ph id=\"ph2\">`long long`</ph>.","pos":[6073,6192],"source":" Also note that for floating point input, the type must be `long double`, and for integral types it must be `long long`."},{"content":"Raw literals","pos":[6201,6213]},{"content":"In a raw user-defined literal, the operator that you define accepts the literal as a sequence of char values and it is up to you to interpret that sequence as a number or string or other type.","pos":[6217,6409]},{"content":"In the list of operators shown earlier in this page, <ph id=\"ph1\">`_r`</ph> and <ph id=\"ph2\">`_t`</ph> can be used to define raw literals:","pos":[6410,6512],"source":" In the list of operators shown earlier in this page, `_r` and `_t` can be used to define raw literals:"},{"content":"You can use raw literals to provide a custom interpretation of an input sequence that is different than what the compiler would perform.","pos":[6697,6833]},{"content":"For example, you could define a literal that converts the sequence <ph id=\"ph1\">`4.75987`</ph> into a custom Decimal type instead of an IEEE 754 floating point type.","pos":[6834,6981],"source":" For example, you could define a literal that converts the sequence `4.75987` into a custom Decimal type instead of an IEEE 754 floating point type."},{"content":"Raw literals, like cooked literals, can also be used to perform compile-time validation of input sequences.","pos":[6982,7089]},{"content":"Example","pos":[7099,7106]},{"content":"Limitations of raw literals","pos":[7116,7143]},{"content":"The raw literal operator and literal operator template only work for integral and floating-point user-defined literals, as shown by the following example:","pos":[7147,7301]}],"content":"---\ntitle: \"User-Defined Literals  (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: ff4a5bec-f795-4705-a2c0-53788fd57609\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# User-Defined Literals  (C++)\nThere are five major categories of literals:  integer,  character,  floating-point,  string, boolean and pointer.  Starting in C++ 11 you can define your own literals based on these categories to provide syntactic shortcuts for common idioms and increase type safety. For example, let's say you have a Distance class. You could define a literal for kilometers and another one for miles, and encourage the user to be explicit about the units of measure by simply writing: auto d = 42.0_km or auto d = 42.0_mi. There is no performance advantage or disadvantage to user-defined literals; they are primarily for convenience or for compile-time type deduction. The Standard Library has user-defined literals for std:string, for std::complex, and for units in time and duration operations in the \\<chrono> header:  \n  \n```  \nDistance d = 36.0_mi + 42.0_km;         // Custom UDL (see below)  \n    std::string str = \"hello\"s + \"World\"s;  // Standard Library <string> UDL  \n    complex<double> num =   \n        (2.0 + 3.01i) * (5.0 + 4.3i);       // Standard Library <complex> UDL  \n    auto duration = 15ms + 42h;             // Standard Library <chrono> UDLs  \n```  \n  \n## User-defined literal operator signatures  \n You implement a user-defined literal by defining an `operator\"\"` at namespace scope with one of the following forms:  \n  \n```  \nReturnType operator \"\" _a(unsigned long long int);   // Literal operator for user-defined INTEGRAL literal  \nReturnType operator \"\" _b(long double);              // Literal operator for user-defined FLOATING literal  \nReturnType operator \"\" _c(char);                     // Literal operator for user-defined CHARACTER literal  \nReturnType operator \"\" _d(wchar_t);                  // Literal operator for user-defined CHARACTER literal  \nReturnType operator \"\" _e(char16_t);                 // Literal operator for user-defined CHARACTER literal  \nReturnType operator \"\" _f(char32_t);                 // Literal operator for user-defined CHARACTER literal  \nReturnType operator \"\" _g(const     char*, size_t);  // Literal operator for user-defined STRING literal  \nReturnType operator \"\" _h(const  wchar_t*, size_t);  // Literal operator for user-defined STRING literal  \nReturnType operator \"\" _i(const char16_t*, size_t);  // Literal operator for user-defined STRING literal  \nReturnType operator \"\" _g(const char32_t*, size_t);  // Literal operator for user-defined STRING literal  \nReturnType operator \"\" _r(const char*);              // Raw literal operator  \ntemplate<char...> ReturnType operator \"\" _t();       // Literal operator template  \n```  \n  \n The operator names in the previous example are placeholders for whatever name you provide; however, the leading underscore is required. (Only the Standard Library is allowed to define literals without the underscore.) The return type is where you customize the conversion or other operation that the literal performs. Also, any of these operators can be defined as `constexpr`.  \n  \n## Cooked literals  \n In source code any literal whether user-defined or not is essentially a sequence of alphanumeric characters, such as `101`, or `54.7`, or `\"hello\"` or `true`. The compiler interprets the sequence as an integer, float, const char\\* string, and so on. A user-defined literal that accepts as input whatever type the compiler assigned to the literal value is informally known as a *cooked literal*. All the operators above except `_r` and `_t` are cooked literals. For example, a literal `42.0_km` would bind to an operator named _km that had a signature similar to _b and the literal `42_km` would bind to an operator with a signature similar to _a.  \n  \n The following example shows how user-defined literals can encourage callers to be explicit about their input. To construct a `Distance`, the user must explicitly specify kilometers or miles by using the appropriate user-defined literal. Of course you can also achieve the same result in other ways, but user-defined literals are less verbose than the alternatives.  \n  \n```  \nstruct Distance  \n{  \nprivate:  \n    explicit Distance(long double val) : kilometers(val)  \n    {}  \n  \n    friend Distance operator\"\" _km(long double  val);  \n    friend Distance operator\"\" _mi(long double val);  \n    long double kilometers{ 0 };  \npublic:  \n    long double get_kilometers() { return kilometers; }  \n    Distance operator+(Distance& other)  \n    {  \n        return Distance(get_kilometers() + other.get_kilometers());  \n    }  \n};  \n  \nDistance operator\"\" _km(long double  val)  \n{  \n    return Distance(val);  \n}  \n  \nDistance operator\"\" _mi(long double val)  \n{  \n    return Distance(val * 1.6);  \n}  \nint main(int argc, char* argv[])  \n{  \n    // Must have a decimal point to bind to the operator we defined!  \n    Distance d{ 402.0_km }; // construct using kilometers  \n    cout << \"Kilometers in d: \" << d.get_kilometers() << endl; // 402  \n  \n    Distance d2{ 402.0_mi }; // construct using miles  \n    cout << \"Kilometers in d2: \" << d2.get_kilometers() << endl;  //643.2  \n  \n    // add distances constructed with different units  \n    Distance d3 = 36.0_mi + 42.0_km;  \n    cout << \"d3 value = \" << d3.get_kilometers() << endl; // 99.6  \n  \n   // Distance d4(90.0); // error constructor not accessible  \n  \n    string s;  \n    getline(cin, s);  \n    return 0;  \n}  \n```  \n  \n Note that the literal number must use a decimal, otherwise the number would be interpreted as an integer and the type would not be compatible with the operator. Also note that for floating point input, the type must be `long double`, and for integral types it must be `long long`.  \n  \n## Raw literals  \n In a raw user-defined literal, the operator that you define accepts the literal as a sequence of char values and it is up to you to interpret that sequence as a number or string or other type. In the list of operators shown earlier in this page, `_r` and `_t` can be used to define raw literals:  \n  \n```  \nReturnType operator \"\" _r(const char*);              // Raw literal operator  \ntemplate<char...> ReturnType operator \"\" _t();       // Literal operator template  \n```  \n  \n You can use raw literals to provide a custom interpretation of an input sequence that is different than what the compiler would perform. For example, you could define a literal that converts the sequence `4.75987` into a custom Decimal type instead of an IEEE 754 floating point type. Raw literals, like cooked literals, can also be used to perform compile-time validation of input sequences.  \n  \n### Example  \n  \n### Limitations of raw literals  \n The raw literal operator and literal operator template only work for integral and floating-point user-defined literals, as shown by the following example:  \n  \n```  \n#include <cstddef>  \n#include <cstdio>  \n  \nvoid operator \"\" _dump(unsigned long long int lit)  { printf(\"operator \\\"\\\" _dump(unsigned long long int) : ===>%llu<===\\n\", lit); };  // Literal operator for user-defined INTEGRAL literal  \nvoid operator \"\" _dump(long double lit)             { printf(\"operator \\\"\\\" _dump(long double)            : ===>%Lf<===\\n\",  lit); };  // Literal operator for user-defined FLOATING literal  \nvoid operator \"\" _dump(char lit)                    { printf(\"operator \\\"\\\" _dump(char)                   : ===>%c<===\\n\",   lit); };  // Literal operator for user-defined CHARACTER literal  \nvoid operator \"\" _dump(wchar_t lit)                 { printf(\"operator \\\"\\\" _dump(wchar_t)                : ===>%d<===\\n\",   lit); };  // Literal operator for user-defined CHARACTER literal  \nvoid operator \"\" _dump(char16_t lit)                { printf(\"operator \\\"\\\" _dump(char16_t)               : ===>%d<===\\n\",   lit); };  // Literal operator for user-defined CHARACTER literal  \nvoid operator \"\" _dump(char32_t lit)                { printf(\"operator \\\"\\\" _dump(char32_t)               : ===>%d<===\\n\",   lit); };  // Literal operator for user-defined CHARACTER literal  \nvoid operator \"\" _dump(const     char* lit, size_t) { printf(\"operator \\\"\\\" _dump(const     char*, size_t): ===>%s<===\\n\",   lit); };  // Literal operator for user-defined STRING literal  \nvoid operator \"\" _dump(const  wchar_t* lit, size_t) { printf(\"operator \\\"\\\" _dump(const  wchar_t*, size_t): ===>%ls<===\\n\",  lit); };  // Literal operator for user-defined STRING literal  \nvoid operator \"\" _dump(const char16_t* lit, size_t) { printf(\"operator \\\"\\\" _dump(const char16_t*, size_t):\\n\"                  ); };  // Literal operator for user-defined STRING literal  \nvoid operator \"\" _dump(const char32_t* lit, size_t) { printf(\"operator \\\"\\\" _dump(const char32_t*, size_t):\\n\"                  ); };  // Literal operator for user-defined STRING literal  \nvoid operator \"\" _dump_raw(const char* lit)         { printf(\"operator \\\"\\\" _dump_raw(const char*)        : ===>%s<===\\n\",   lit); };  // Raw literal operator  \n  \ntemplate<char...> void operator \"\" _dump_template();       // Literal operator template  \n  \nint main(int argc, const char* argv[])  \n{  \n    42_dump;  \n    3.1415926_dump;  \n    3.14e+25_dump;  \n     'A'_dump;  \n    L'B'_dump;  \n    u'C'_dump;  \n    U'D'_dump;  \n      \"Hello World\"_dump;  \n     L\"Wide String\"_dump;  \n    u8\"UTF-8 String\"_dump;  \n     u\"UTF-16 String\"_dump;  \n     U\"UTF-32 String\"_dump;  \n  \n    42_dump_raw;  \n    3.1415926_dump_raw;  \n    3.14e+25_dump_raw;  \n    // 'A'_dump_raw;               // There is no raw literal operator or literal operator template support on this type  \n    //L'B'_dump_raw;              // There is no raw literal operator or literal operator template support on this type  \n    //u'C'_dump_raw;              // There is no raw literal operator or literal operator template support on this type  \n    //U'D'_dump_raw;              // There is no raw literal operator or literal operator template support on this type  \n    //  \"Hello World\"_dump_raw;   // There is no raw literal operator or literal operator template support on this type  \n    // L\"Wide String\"_dump_raw;   // There is no raw literal operator or literal operator template support on this type  \n    //u8\"UTF-8 String\"_dump_raw;   // There is no raw literal operator or literal operator template support on this type  \n    // u\"UTF-16 String\"_dump_raw;  // There is no raw literal operator or literal operator template support on this type  \n    // U\"UTF-32 String\"_dump_raw;  // There is no raw literal operator or literal operator template support on this type  \n}  \n/*****  \nOutput:  \noperator \"\" _dump(unsigned long long int) : ===>42<===  \noperator \"\" _dump(long double)            : ===>3.141593<===  \noperator \"\" _dump(long double)            : ===>31399999999999998506827776.000000<===  \noperator \"\" _dump(char)                   : ===>A<===  \noperator \"\" _dump(wchar_t)                : ===>66<===  \noperator \"\" _dump(char16_t)               : ===>67<===  \noperator \"\" _dump(char32_t)               : ===>68<===  \noperator \"\" _dump(const     char*, size_t): ===>Hello World<===  \noperator \"\" _dump(const  wchar_t*, size_t): ===>Wide String<===  \noperator \"\" _dump(const     char*, size_t): ===>UTF-8 String<===  \noperator \"\" _dump(const char16_t*, size_t):  \noperator \"\" _dump(const char32_t*, size_t):  \noperator \"\" _dump_raw(const char*)        : ===>42<===  \noperator \"\" _dump_raw(const char*)        : ===>3.1415926<===  \noperator \"\" _dump_raw(const char*)        : ===>3.14e+25<===   \n*****/  \n  \n```"}