{"nodes":[{"pos":[12,47],"content":"&lt;allocators&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>allocators<ph id=\"ph2\">&amp;gt;</ph> | Microsoft Docs","pos":[0,35],"source":"&lt;allocators&gt; | Microsoft Docs"}]},{"pos":[696,714],"content":"&lt;allocators&gt;","linkify":"&lt;allocators&gt;","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>allocators<ph id=\"ph2\">&amp;gt;</ph>","pos":[0,18],"source":"&lt;allocators&gt;"}]},{"content":"Defines several templates that help allocate and free memory blocks for node-based containers.","pos":[715,809]},{"pos":[818,824],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[872,879],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">\\&lt;</ph>allocators&gt; header provides six allocator templates that can be used to select memory-management strategies for node-based containers.","pos":[883,1023],"source":"The \\<allocators> header provides six allocator templates that can be used to select memory-management strategies for node-based containers."},{"content":"For use with these templates, it also provides several different synchronization filters to tailor the memory-management strategy to a variety of different multithreading schemes (including none).","pos":[1024,1220]},{"content":"Matching a memory management strategy to the known memory usage patterns, and synchronization requirements, of a particular application can often increase the speed or reduce the overall memory requirements of an application.","pos":[1221,1446]},{"content":"The allocator templates are implemented with reusable components that can be customized or replaced to provide additional memory-management strategies.","pos":[1453,1604]},{"content":"The node-based containers in the Standard C++ library (std::list, std::set, std::multiset, std::map and std::multimap) store their elements in individual nodes.","pos":[1611,1771]},{"content":"All the nodes for a particular container type are the same size, so the flexibility of a general-purpose memory manager is not needed.","pos":[1772,1906]},{"content":"Because the size of each memory block is known at compile time, the memory manager can be much simpler and faster.","pos":[1907,2021]},{"content":"When used with containers that are not node-based (such as the Standard C++ library containers std::vector std::deque, and std::basic_string), the alllocator templates will work correctly, but are not likely to provide any performance improvement over the default allocator.","pos":[2028,2302]},{"content":"An allocator is a template class that describes an object that manages storage allocation and freeing for objects and arrays of objects of a designated type.","pos":[2309,2466]},{"content":"Allocator objects are used by several container template classes in the Standard C++ library.","pos":[2467,2560]},{"content":"The allocators are all templates of this type:","pos":[2567,2613]},{"pos":[2620,2647],"content":"<ph id=\"ph1\">`template&lt;class`</ph> <ph id=\"ph2\">`Type`</ph> <ph id=\"ph3\">`&gt;`</ph>","source":"`template<class` `Type` `>`"},{"content":"where the template argument <ph id=\"ph1\">`Type`</ph> is the type managed by the allocator instance.","pos":[2679,2760],"source":"where the template argument `Type` is the type managed by the allocator instance."},{"content":"The Standard C++ library provides a default allocator, template class <bpt id=\"p1\">[</bpt>allocator<ept id=\"p1\">](../standard-library/allocator-class.md)</ept>, which is defined in <bpt id=\"p2\">[</bpt><ph id=\"ph1\">\\&lt;</ph>memory&gt;<ept id=\"p2\">](../standard-library/memory.md)</ept>.","pos":[2761,2947],"source":" The Standard C++ library provides a default allocator, template class [allocator](../standard-library/allocator-class.md), which is defined in [\\<memory>](../standard-library/memory.md)."},{"content":"The <ph id=\"ph1\">\\&lt;</ph>allocators&gt; header provides the following allocators:","pos":[2948,3007],"source":" The \\<allocators> header provides the following allocators:"},{"pos":[3015,3080],"content":"<bpt id=\"p1\">[</bpt>allocator_newdel<ept id=\"p1\">](../standard-library/allocator-newdel-class.md)</ept>","source":"[allocator_newdel](../standard-library/allocator-newdel-class.md)"},{"pos":[3088,3159],"content":"<bpt id=\"p1\">[</bpt>allocator_unbounded<ept id=\"p1\">](../standard-library/allocator-unbounded-class.md)</ept>","source":"[allocator_unbounded](../standard-library/allocator-unbounded-class.md)"},{"pos":[3167,3240],"content":"<bpt id=\"p1\">[</bpt>allocator_fixed_size<ept id=\"p1\">](../standard-library/allocator-fixed-size-class.md)</ept>","source":"[allocator_fixed_size](../standard-library/allocator-fixed-size-class.md)"},{"pos":[3248,3327],"content":"<bpt id=\"p1\">[</bpt>allocator_variable_size<ept id=\"p1\">](../standard-library/allocator-variable-size-class.md)</ept>","source":"[allocator_variable_size](../standard-library/allocator-variable-size-class.md)"},{"pos":[3335,3404],"content":"<bpt id=\"p1\">[</bpt>allocator_suballoc<ept id=\"p1\">](../standard-library/allocator-suballoc-class.md)</ept>","source":"[allocator_suballoc](../standard-library/allocator-suballoc-class.md)"},{"pos":[3412,3483],"content":"<bpt id=\"p1\">[</bpt>allocator_chunklist<ept id=\"p1\">](../standard-library/allocator-chunklist-class.md)</ept>","source":"[allocator_chunklist](../standard-library/allocator-chunklist-class.md)"},{"content":"Use an appropriate instantiation of an allocator as the second type argument when creating a container, such as the following code example.","pos":[3490,3629]},{"pos":[3768,3857],"content":"_List0 allocates nodes with <ph id=\"ph1\">`allocator_chunklist`</ph> and the default synchronization filter.","source":"_List0 allocates nodes with `allocator_chunklist` and the default synchronization filter."},{"pos":[3864,4037],"content":"Use the macro <bpt id=\"p1\">[</bpt>ALLOCATOR_DECL<ept id=\"p1\">](../standard-library/allocators-functions.md#allocator_decl)</ept> to create allocator templates with synchronization filters other than the default:","source":"Use the macro [ALLOCATOR_DECL](../standard-library/allocators-functions.md#allocator_decl) to create allocator templates with synchronization filters other than the default:"},{"pos":[4227,4371],"content":"_Lst1 allocates nodes with <ph id=\"ph1\">`allocator_chunklist`</ph> and the <bpt id=\"p1\">[</bpt>sync_per_thread<ept id=\"p1\">](../standard-library/sync-per-thread-class.md)</ept> synchronization filter.","source":"_Lst1 allocates nodes with `allocator_chunklist` and the [sync_per_thread](../standard-library/sync-per-thread-class.md) synchronization filter."},{"content":"A block allocator is a cache or a filter.","pos":[4378,4419]},{"content":"A cache is a template class that takes one argument of type std::size_t.","pos":[4420,4492]},{"content":"It defines a block allocator that allocates and deallocates memory blocks of a single size.","pos":[4493,4584]},{"content":"It must obtain memory using operator <ph id=\"ph1\">`new`</ph>, but it need not make a separate call to operator <ph id=\"ph2\">`new`</ph> for each block.","pos":[4585,4699],"source":" It must obtain memory using operator `new`, but it need not make a separate call to operator `new` for each block."},{"content":"It may, for example, suballocate from a larger block or cache deallocated blocks for subsequent reallocation.","pos":[4700,4809]},{"content":"With a compiler that cannot compile rebind the value of the std::size_t argument used when the template was instantiated is not necessarily the value of the argument _Sz passed to a cache's member functions allocate and deallocate.","pos":[4816,5047]},{"content":"<ph id=\"ph1\">\\&lt;</ph>allocators&gt; provides the following cache templates:","pos":[5054,5107],"source":"\\<allocators> provides the following cache templates:"},{"pos":[5115,5176],"content":"<bpt id=\"p1\">[</bpt>cache_freelist<ept id=\"p1\">](../standard-library/cache-freelist-class.md)</ept>","source":"[cache_freelist](../standard-library/cache-freelist-class.md)"},{"pos":[5184,5245],"content":"<bpt id=\"p1\">[</bpt>cache_suballoc<ept id=\"p1\">](../standard-library/cache-suballoc-class.md)</ept>","source":"[cache_suballoc](../standard-library/cache-suballoc-class.md)"},{"pos":[5253,5316],"content":"<bpt id=\"p1\">[</bpt>cache_chunklist<ept id=\"p1\">](../standard-library/cache-chunklist-class.md)</ept>","source":"[cache_chunklist](../standard-library/cache-chunklist-class.md)"},{"content":"A filter is a block allocator that implements its member functions using another block allocator which is passed to it as a template argument.","pos":[5323,5465]},{"content":"The most common form of filter is a synchronization filter, which applies a synchronization policy to control access to the member functions of an instance of another block allocator.","pos":[5466,5649]},{"content":"<ph id=\"ph1\">\\&lt;</ph>allocators&gt; provides the following synchronization filters:","pos":[5650,5711],"source":"\\<allocators> provides the following synchronization filters:"},{"pos":[5719,5770],"content":"<bpt id=\"p1\">[</bpt>sync_none<ept id=\"p1\">](../standard-library/sync-none-class.md)</ept>","source":"[sync_none](../standard-library/sync-none-class.md)"},{"pos":[5778,5847],"content":"<bpt id=\"p1\">[</bpt>sync_per_container<ept id=\"p1\">](../standard-library/sync-per-container-class.md)</ept>","source":"[sync_per_container](../standard-library/sync-per-container-class.md)"},{"pos":[5855,5918],"content":"<bpt id=\"p1\">[</bpt>sync_per_thread<ept id=\"p1\">](../standard-library/sync-per-thread-class.md)</ept>","source":"[sync_per_thread](../standard-library/sync-per-thread-class.md)"},{"pos":[5926,5981],"content":"<bpt id=\"p1\">[</bpt>sync_shared<ept id=\"p1\">](../standard-library/sync-shared-class.md)</ept>","source":"[sync_shared](../standard-library/sync-shared-class.md)"},{"content":"<ph id=\"ph1\">\\&lt;</ph>allocators&gt; also provides the filter <bpt id=\"p1\">[</bpt>rts_alloc<ept id=\"p1\">](../standard-library/rts-alloc-class.md)</ept>, which holds multiple block allocator instances and determines which instance to use for allocation or deallocation at runtime instead of at compile time.","pos":[5988,6233],"source":"\\<allocators> also provides the filter [rts_alloc](../standard-library/rts-alloc-class.md), which holds multiple block allocator instances and determines which instance to use for allocation or deallocation at runtime instead of at compile time."},{"content":"It is used with compilers that cannot compile rebind.","pos":[6234,6287]},{"content":"A synchronization policy determines how an allocator instance handles simultaneous allocation and deallocation requests from multiple threads.","pos":[6294,6436]},{"content":"The simplest policy is to pass all requests directly through to the underlying cache object, leaving synchronization management to the user.","pos":[6437,6577]},{"content":"A more complex policy could be to use a mutex to serialize access to the underlying cache object.","pos":[6578,6675]},{"pos":[6682,6893],"content":"If a compiler supports compiling both single-threaded and multi-threaded applications, the default synchronization filter for single-threaded applications is <ph id=\"ph1\">`sync_none`</ph>; for all other cases it is <ph id=\"ph2\">`sync_shared`</ph>.","source":"If a compiler supports compiling both single-threaded and multi-threaded applications, the default synchronization filter for single-threaded applications is `sync_none`; for all other cases it is `sync_shared`."},{"pos":[6900,7041],"content":"The cache template <ph id=\"ph1\">`cache_freelist`</ph> takes a max class argument which determines the maximum number of elements to be stored in the free list.","source":"The cache template `cache_freelist` takes a max class argument which determines the maximum number of elements to be stored in the free list."},{"content":"<ph id=\"ph1\">\\&lt;</ph>allocators&gt; provides the following max classes:","pos":[7048,7097],"source":"\\<allocators> provides the following max classes:"},{"pos":[7105,7154],"content":"<bpt id=\"p1\">[</bpt>max_none<ept id=\"p1\">](../standard-library/max-none-class.md)</ept>","source":"[max_none](../standard-library/max-none-class.md)"},{"pos":[7162,7221],"content":"<bpt id=\"p1\">[</bpt>max_unbounded<ept id=\"p1\">](../standard-library/max-unbounded-class.md)</ept>","source":"[max_unbounded](../standard-library/max-unbounded-class.md)"},{"pos":[7229,7290],"content":"<bpt id=\"p1\">[</bpt>max_fixed_size<ept id=\"p1\">](../standard-library/max-fixed-size-class.md)</ept>","source":"[max_fixed_size](../standard-library/max-fixed-size-class.md)"},{"pos":[7298,7365],"content":"<bpt id=\"p1\">[</bpt>max_variable_size<ept id=\"p1\">](../standard-library/max-variable-size-class.md)</ept>","source":"[max_variable_size](../standard-library/max-variable-size-class.md)"},{"pos":[7375,7381],"content":"Macros","linkify":"Macros","nodes":[{"content":"Macros","pos":[0,6]}]},{"pos":[7402,7478],"content":"<bpt id=\"p1\">[</bpt>ALLOCATOR_DECL<ept id=\"p1\">](../standard-library/allocators-functions.md#allocator_decl)</ept>","source":"[ALLOCATOR_DECL](../standard-library/allocators-functions.md#allocator_decl)"},{"content":"Yields an allocator template class.","pos":[7479,7514]},{"pos":[7519,7597],"content":"<bpt id=\"p1\">[</bpt>CACHE_CHUNKLIST<ept id=\"p1\">](../standard-library/allocators-functions.md#cache_chunklist)</ept>","source":"[CACHE_CHUNKLIST](../standard-library/allocators-functions.md#cache_chunklist)"},{"pos":[7598,7657],"content":"Yields <ph id=\"ph1\">`stdext::allocators::cache_chunklist&lt;sizeof(Type)&gt;`</ph>.","source":"Yields `stdext::allocators::cache_chunklist<sizeof(Type)>`."},{"pos":[7662,7738],"content":"<bpt id=\"p1\">[</bpt>CACHE_FREELIST<ept id=\"p1\">](../standard-library/allocators-functions.md#cache_freelist)</ept>","source":"[CACHE_FREELIST](../standard-library/allocators-functions.md#cache_freelist)"},{"pos":[7739,7802],"content":"Yields <ph id=\"ph1\">`stdext::allocators::cache_freelist&lt;sizeof(Type), max&gt;`</ph>.","source":"Yields `stdext::allocators::cache_freelist<sizeof(Type), max>`."},{"pos":[7807,7883],"content":"<bpt id=\"p1\">[</bpt>CACHE_SUBALLOC<ept id=\"p1\">](../standard-library/allocators-functions.md#cache_suballoc)</ept>","source":"[CACHE_SUBALLOC](../standard-library/allocators-functions.md#cache_suballoc)"},{"pos":[7884,7942],"content":"Yields <ph id=\"ph1\">`stdext::allocators::cache_suballoc&lt;sizeof(Type)&gt;`</ph>.","source":"Yields `stdext::allocators::cache_suballoc<sizeof(Type)>`."},{"pos":[7947,8019],"content":"<bpt id=\"p1\">[</bpt>SYNC_DEFAULT<ept id=\"p1\">](../standard-library/allocators-functions.md#sync_default)</ept>","source":"[SYNC_DEFAULT](../standard-library/allocators-functions.md#sync_default)"},{"content":"Yields a synchronization filter.","pos":[8020,8052]},{"pos":[8063,8072],"content":"Operators","linkify":"Operators","nodes":[{"content":"Operators","pos":[0,9]}]},{"pos":[8093,8179],"content":"<bpt id=\"p1\">[</bpt>operator!= (<ph id=\"ph1\">\\&lt;</ph>allocators&gt;)<ept id=\"p1\">](../standard-library/allocators-operators.md#operator_neq)</ept>","source":"[operator!= (\\<allocators>)](../standard-library/allocators-operators.md#operator_neq)"},{"content":"Tests for inequality between allocator objects of a specified class.","pos":[8180,8248]},{"pos":[8253,8341],"content":"<bpt id=\"p1\">[</bpt>operator== (<ph id=\"ph1\">\\&lt;</ph>allocators&gt;)<ept id=\"p1\">](../standard-library/allocators-operators.md#operator_eq_eq)</ept>","source":"[operator== (\\<allocators>)](../standard-library/allocators-operators.md#operator_eq_eq)"},{"content":"Tests for equality between allocator objects of a specified class.","pos":[8342,8408]},{"pos":[8419,8426],"content":"Classes","linkify":"Classes","nodes":[{"content":"Classes","pos":[0,7]}]},{"pos":[8447,8508],"content":"<bpt id=\"p1\">[</bpt>allocator_base<ept id=\"p1\">](../standard-library/allocator-base-class.md)</ept>","source":"[allocator_base](../standard-library/allocator-base-class.md)"},{"content":"Defines the base class and common functions needed to create a user-defined allocator from a synchronization filter.","pos":[8509,8625]},{"pos":[8630,8701],"content":"<bpt id=\"p1\">[</bpt>allocator_chunklist<ept id=\"p1\">](../standard-library/allocator-chunklist-class.md)</ept>","source":"[allocator_chunklist](../standard-library/allocator-chunklist-class.md)"},{"pos":[8702,8864],"content":"Describes an object that manages storage allocation and freeing for objects using a cache of type <bpt id=\"p1\">[</bpt>cache_chunklist<ept id=\"p1\">](../standard-library/cache-chunklist-class.md)</ept>.","source":"Describes an object that manages storage allocation and freeing for objects using a cache of type [cache_chunklist](../standard-library/cache-chunklist-class.md)."},{"pos":[8869,8942],"content":"<bpt id=\"p1\">[</bpt>allocator_fixed_size<ept id=\"p1\">](../standard-library/allocator-fixed-size-class.md)</ept>","source":"[allocator_fixed_size](../standard-library/allocator-fixed-size-class.md)"},{"pos":[8943,9205],"content":"Describes an object that manages storage allocation and freeing for objects of type <ph id=\"ph1\">`Type`</ph> using a cache of type <bpt id=\"p1\">[</bpt>cache_freelist<ept id=\"p1\">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id=\"p2\">[</bpt>max_fixed_size<ept id=\"p2\">](../standard-library/max-fixed-size-class.md)</ept>.","source":"Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_fixed_size](../standard-library/max-fixed-size-class.md)."},{"pos":[9210,9275],"content":"<bpt id=\"p1\">[</bpt>allocator_newdel<ept id=\"p1\">](../standard-library/allocator-newdel-class.md)</ept>","source":"[allocator_newdel](../standard-library/allocator-newdel-class.md)"},{"pos":[9276,9403],"content":"Implements an allocator that uses <ph id=\"ph1\">`operator delete`</ph> to deallocate a memory block and <ph id=\"ph2\">`operator new`</ph> to allocate a memory block.","source":"Implements an allocator that uses `operator delete` to deallocate a memory block and `operator new` to allocate a memory block."},{"pos":[9408,9477],"content":"<bpt id=\"p1\">[</bpt>allocator_suballoc<ept id=\"p1\">](../standard-library/allocator-suballoc-class.md)</ept>","source":"[allocator_suballoc](../standard-library/allocator-suballoc-class.md)"},{"pos":[9478,9653],"content":"Describes an object that manages storage allocation and freeing for objects of type <ph id=\"ph1\">`Type`</ph> using a cache of type <bpt id=\"p1\">[</bpt>cache_suballoc<ept id=\"p1\">](../standard-library/cache-suballoc-class.md)</ept>.","source":"Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_suballoc](../standard-library/cache-suballoc-class.md)."},{"pos":[9658,9729],"content":"<bpt id=\"p1\">[</bpt>allocator_unbounded<ept id=\"p1\">](../standard-library/allocator-unbounded-class.md)</ept>","source":"[allocator_unbounded](../standard-library/allocator-unbounded-class.md)"},{"pos":[9730,9990],"content":"Describes an object that manages storage allocation and freeing for objects of type <ph id=\"ph1\">`Type`</ph> using a cache of type <bpt id=\"p1\">[</bpt>cache_freelist<ept id=\"p1\">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id=\"p2\">[</bpt>max_unbounded<ept id=\"p2\">](../standard-library/max-unbounded-class.md)</ept>.","source":"Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_unbounded](../standard-library/max-unbounded-class.md)."},{"pos":[9995,10074],"content":"<bpt id=\"p1\">[</bpt>allocator_variable_size<ept id=\"p1\">](../standard-library/allocator-variable-size-class.md)</ept>","source":"[allocator_variable_size](../standard-library/allocator-variable-size-class.md)"},{"pos":[10075,10343],"content":"Describes an object that manages storage allocation and freeing for objects of type <ph id=\"ph1\">`Type`</ph> using a cache of type <bpt id=\"p1\">[</bpt>cache_freelist<ept id=\"p1\">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id=\"p2\">[</bpt>max_variable_size<ept id=\"p2\">](../standard-library/max-variable-size-class.md)</ept>.","source":"Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_variable_size](../standard-library/max-variable-size-class.md)."},{"pos":[10348,10411],"content":"<bpt id=\"p1\">[</bpt>cache_chunklist<ept id=\"p1\">](../standard-library/cache-chunklist-class.md)</ept>","source":"[cache_chunklist](../standard-library/cache-chunklist-class.md)"},{"content":"Defines a block allocator that allocates and deallocates memory blocks of a single size.","pos":[10412,10500]},{"pos":[10505,10566],"content":"<bpt id=\"p1\">[</bpt>cache_freelist<ept id=\"p1\">](../standard-library/cache-freelist-class.md)</ept>","source":"[cache_freelist](../standard-library/cache-freelist-class.md)"},{"content":"Defines a block allocator that allocates and deallocates memory blocks of a single size.","pos":[10567,10655]},{"pos":[10660,10721],"content":"<bpt id=\"p1\">[</bpt>cache_suballoc<ept id=\"p1\">](../standard-library/cache-suballoc-class.md)</ept>","source":"[cache_suballoc](../standard-library/cache-suballoc-class.md)"},{"content":"Defines a block allocator that allocates and deallocates memory blocks of a single size.","pos":[10722,10810]},{"pos":[10815,10864],"content":"<bpt id=\"p1\">[</bpt>freelist<ept id=\"p1\">](../standard-library/freelist-class.md)</ept>","source":"[freelist](../standard-library/freelist-class.md)"},{"content":"Manages a list of memory blocks.","pos":[10865,10897]},{"pos":[10902,10963],"content":"<bpt id=\"p1\">[</bpt>max_fixed_size<ept id=\"p1\">](../standard-library/max-fixed-size-class.md)</ept>","source":"[max_fixed_size](../standard-library/max-fixed-size-class.md)"},{"pos":[10964,11090],"content":"Describes a max class object that limits a <bpt id=\"p1\">[</bpt>freelist<ept id=\"p1\">](../standard-library/freelist-class.md)</ept> object to a fixed maximum length.","source":"Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a fixed maximum length."},{"pos":[11095,11144],"content":"<bpt id=\"p1\">[</bpt>max_none<ept id=\"p1\">](../standard-library/max-none-class.md)</ept>","source":"[max_none](../standard-library/max-none-class.md)"},{"pos":[11145,11273],"content":"Describes a max class object that limits a <bpt id=\"p1\">[</bpt>freelist<ept id=\"p1\">](../standard-library/freelist-class.md)</ept> object to a maximum length of zero.","source":"Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a maximum length of zero."},{"pos":[11278,11337],"content":"<bpt id=\"p1\">[</bpt>max_unbounded<ept id=\"p1\">](../standard-library/max-unbounded-class.md)</ept>","source":"[max_unbounded](../standard-library/max-unbounded-class.md)"},{"pos":[11338,11468],"content":"Describes a max class object that does not limit the maximum length of a <bpt id=\"p1\">[</bpt>freelist<ept id=\"p1\">](../standard-library/freelist-class.md)</ept> object.","source":"Describes a max class object that does not limit the maximum length of a [freelist](../standard-library/freelist-class.md) object."},{"pos":[11473,11540],"content":"<bpt id=\"p1\">[</bpt>max_variable_size<ept id=\"p1\">](../standard-library/max-variable-size-class.md)</ept>","source":"[max_variable_size](../standard-library/max-variable-size-class.md)"},{"pos":[11541,11731],"content":"Describes a max class object that limits a <bpt id=\"p1\">[</bpt>freelist<ept id=\"p1\">](../standard-library/freelist-class.md)</ept> object to a maximum length that is roughly proportional to the number of allocated memory blocks.","source":"Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a maximum length that is roughly proportional to the number of allocated memory blocks."},{"pos":[11736,11787],"content":"<bpt id=\"p1\">[</bpt>rts_alloc<ept id=\"p1\">](../standard-library/rts-alloc-class.md)</ept>","source":"[rts_alloc](../standard-library/rts-alloc-class.md)"},{"pos":[11788,12026],"content":"The rts_alloc template class describes a <bpt id=\"p1\">[</bpt>filter<ept id=\"p1\">](../standard-library/allocators-header.md)</ept> that holds an array of cache instances and determines which instance to use for allocation and deallocation at runtime instead of at compile time.","source":"The rts_alloc template class describes a [filter](../standard-library/allocators-header.md) that holds an array of cache instances and determines which instance to use for allocation and deallocation at runtime instead of at compile time."},{"pos":[12031,12082],"content":"<bpt id=\"p1\">[</bpt>sync_none<ept id=\"p1\">](../standard-library/sync-none-class.md)</ept>","source":"[sync_none](../standard-library/sync-none-class.md)"},{"content":"Describes a synchronization filter that provides no synchronization.","pos":[12083,12151]},{"pos":[12156,12225],"content":"<bpt id=\"p1\">[</bpt>sync_per_container<ept id=\"p1\">](../standard-library/sync-per-container-class.md)</ept>","source":"[sync_per_container](../standard-library/sync-per-container-class.md)"},{"content":"Describes a synchronization filter that provides a separate cache object for each allocator object.","pos":[12226,12325]},{"pos":[12330,12393],"content":"<bpt id=\"p1\">[</bpt>sync_per_thread<ept id=\"p1\">](../standard-library/sync-per-thread-class.md)</ept>","source":"[sync_per_thread](../standard-library/sync-per-thread-class.md)"},{"content":"Describes a synchronization filter that provides a separate cache object for each thread.","pos":[12394,12483]},{"pos":[12488,12543],"content":"<bpt id=\"p1\">[</bpt>sync_shared<ept id=\"p1\">](../standard-library/sync-shared-class.md)</ept>","source":"[sync_shared](../standard-library/sync-shared-class.md)"},{"content":"Describes a synchronization filter that uses a mutex to control access to a cache object that is shared by all allocators.","pos":[12544,12666]},{"pos":[12676,12688],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[12692,12717],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>allocators&gt;","source":"**Header:** \\<allocators>"},{"pos":[12724,12745],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> stdext","source":"**Namespace:** stdext"},{"pos":[12754,12762],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[12766,12848],"content":"<bpt id=\"p1\">[</bpt>Header Files Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-header-files.md)</ept>","source":"[Header Files Reference](../standard-library/cpp-standard-library-header-files.md)"}],"content":"---\ntitle: \"&lt;allocators&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"stdext::<allocators>\"\n  - \"allocators/stdext::allocators\"\n  - \"<allocators>\"\n  - \"stdext.<allocators>\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"allocators header\"\nms.assetid: 4393a607-4df8-4278-bbb2-c8ec52e60b83\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;allocators&gt;\nDefines several templates that help allocate and free memory blocks for node-based containers.  \n  \n## Syntax  \n  \n```  \n#include <allocators>  \n```  \n  \n## Remarks  \n The \\<allocators> header provides six allocator templates that can be used to select memory-management strategies for node-based containers. For use with these templates, it also provides several different synchronization filters to tailor the memory-management strategy to a variety of different multithreading schemes (including none). Matching a memory management strategy to the known memory usage patterns, and synchronization requirements, of a particular application can often increase the speed or reduce the overall memory requirements of an application.  \n  \n The allocator templates are implemented with reusable components that can be customized or replaced to provide additional memory-management strategies.  \n  \n The node-based containers in the Standard C++ library (std::list, std::set, std::multiset, std::map and std::multimap) store their elements in individual nodes. All the nodes for a particular container type are the same size, so the flexibility of a general-purpose memory manager is not needed. Because the size of each memory block is known at compile time, the memory manager can be much simpler and faster.  \n  \n When used with containers that are not node-based (such as the Standard C++ library containers std::vector std::deque, and std::basic_string), the alllocator templates will work correctly, but are not likely to provide any performance improvement over the default allocator.  \n  \n An allocator is a template class that describes an object that manages storage allocation and freeing for objects and arrays of objects of a designated type. Allocator objects are used by several container template classes in the Standard C++ library.  \n  \n The allocators are all templates of this type:  \n  \n `template<class` `Type` `>`  \n  \n `class allocator;`  \n  \n where the template argument `Type` is the type managed by the allocator instance. The Standard C++ library provides a default allocator, template class [allocator](../standard-library/allocator-class.md), which is defined in [\\<memory>](../standard-library/memory.md). The \\<allocators> header provides the following allocators:  \n  \n- [allocator_newdel](../standard-library/allocator-newdel-class.md)  \n  \n- [allocator_unbounded](../standard-library/allocator-unbounded-class.md)  \n  \n- [allocator_fixed_size](../standard-library/allocator-fixed-size-class.md)  \n  \n- [allocator_variable_size](../standard-library/allocator-variable-size-class.md)  \n  \n- [allocator_suballoc](../standard-library/allocator-suballoc-class.md)  \n  \n- [allocator_chunklist](../standard-library/allocator-chunklist-class.md)  \n  \n Use an appropriate instantiation of an allocator as the second type argument when creating a container, such as the following code example.  \n  \n `#include <list>`  \n  \n `#include <allocators>`  \n  \n `std::list<int, stdext::allocators::allocator_chunklist<int> > _List0;`  \n  \n _List0 allocates nodes with `allocator_chunklist` and the default synchronization filter.  \n  \n Use the macro [ALLOCATOR_DECL](../standard-library/allocators-functions.md#allocator_decl) to create allocator templates with synchronization filters other than the default:  \n  \n `#include <list>`  \n  \n `#include <allocators>`  \n  \n `ALLOCATOR_DECL(CACHE_CHUNKLIST, stdext::allocators::sync_per_thread, Alloc);`  \n  \n `std::list<int, alloc<int> > _List1;`  \n  \n _Lst1 allocates nodes with `allocator_chunklist` and the [sync_per_thread](../standard-library/sync-per-thread-class.md) synchronization filter.  \n  \n A block allocator is a cache or a filter. A cache is a template class that takes one argument of type std::size_t. It defines a block allocator that allocates and deallocates memory blocks of a single size. It must obtain memory using operator `new`, but it need not make a separate call to operator `new` for each block. It may, for example, suballocate from a larger block or cache deallocated blocks for subsequent reallocation.  \n  \n With a compiler that cannot compile rebind the value of the std::size_t argument used when the template was instantiated is not necessarily the value of the argument _Sz passed to a cache's member functions allocate and deallocate.  \n  \n \\<allocators> provides the following cache templates:  \n  \n- [cache_freelist](../standard-library/cache-freelist-class.md)  \n  \n- [cache_suballoc](../standard-library/cache-suballoc-class.md)  \n  \n- [cache_chunklist](../standard-library/cache-chunklist-class.md)  \n  \n A filter is a block allocator that implements its member functions using another block allocator which is passed to it as a template argument. The most common form of filter is a synchronization filter, which applies a synchronization policy to control access to the member functions of an instance of another block allocator. \\<allocators> provides the following synchronization filters:  \n  \n- [sync_none](../standard-library/sync-none-class.md)  \n  \n- [sync_per_container](../standard-library/sync-per-container-class.md)  \n  \n- [sync_per_thread](../standard-library/sync-per-thread-class.md)  \n  \n- [sync_shared](../standard-library/sync-shared-class.md)  \n  \n \\<allocators> also provides the filter [rts_alloc](../standard-library/rts-alloc-class.md), which holds multiple block allocator instances and determines which instance to use for allocation or deallocation at runtime instead of at compile time. It is used with compilers that cannot compile rebind.  \n  \n A synchronization policy determines how an allocator instance handles simultaneous allocation and deallocation requests from multiple threads. The simplest policy is to pass all requests directly through to the underlying cache object, leaving synchronization management to the user. A more complex policy could be to use a mutex to serialize access to the underlying cache object.  \n  \n If a compiler supports compiling both single-threaded and multi-threaded applications, the default synchronization filter for single-threaded applications is `sync_none`; for all other cases it is `sync_shared`.  \n  \n The cache template `cache_freelist` takes a max class argument which determines the maximum number of elements to be stored in the free list.  \n  \n \\<allocators> provides the following max classes:  \n  \n- [max_none](../standard-library/max-none-class.md)  \n  \n- [max_unbounded](../standard-library/max-unbounded-class.md)  \n  \n- [max_fixed_size](../standard-library/max-fixed-size-class.md)  \n  \n- [max_variable_size](../standard-library/max-variable-size-class.md)  \n  \n### Macros  \n  \n|||  \n|-|-|  \n|[ALLOCATOR_DECL](../standard-library/allocators-functions.md#allocator_decl)|Yields an allocator template class.|  \n|[CACHE_CHUNKLIST](../standard-library/allocators-functions.md#cache_chunklist)|Yields `stdext::allocators::cache_chunklist<sizeof(Type)>`.|  \n|[CACHE_FREELIST](../standard-library/allocators-functions.md#cache_freelist)|Yields `stdext::allocators::cache_freelist<sizeof(Type), max>`.|  \n|[CACHE_SUBALLOC](../standard-library/allocators-functions.md#cache_suballoc)|Yields `stdext::allocators::cache_suballoc<sizeof(Type)>`.|  \n|[SYNC_DEFAULT](../standard-library/allocators-functions.md#sync_default)|Yields a synchronization filter.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator!= (\\<allocators>)](../standard-library/allocators-operators.md#operator_neq)|Tests for inequality between allocator objects of a specified class.|  \n|[operator== (\\<allocators>)](../standard-library/allocators-operators.md#operator_eq_eq)|Tests for equality between allocator objects of a specified class.|  \n  \n### Classes  \n  \n|||  \n|-|-|  \n|[allocator_base](../standard-library/allocator-base-class.md)|Defines the base class and common functions needed to create a user-defined allocator from a synchronization filter.|  \n|[allocator_chunklist](../standard-library/allocator-chunklist-class.md)|Describes an object that manages storage allocation and freeing for objects using a cache of type [cache_chunklist](../standard-library/cache-chunklist-class.md).|  \n|[allocator_fixed_size](../standard-library/allocator-fixed-size-class.md)|Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_fixed_size](../standard-library/max-fixed-size-class.md).|  \n|[allocator_newdel](../standard-library/allocator-newdel-class.md)|Implements an allocator that uses `operator delete` to deallocate a memory block and `operator new` to allocate a memory block.|  \n|[allocator_suballoc](../standard-library/allocator-suballoc-class.md)|Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_suballoc](../standard-library/cache-suballoc-class.md).|  \n|[allocator_unbounded](../standard-library/allocator-unbounded-class.md)|Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_unbounded](../standard-library/max-unbounded-class.md).|  \n|[allocator_variable_size](../standard-library/allocator-variable-size-class.md)|Describes an object that manages storage allocation and freeing for objects of type `Type` using a cache of type [cache_freelist](../standard-library/cache-freelist-class.md) with a length managed by [max_variable_size](../standard-library/max-variable-size-class.md).|  \n|[cache_chunklist](../standard-library/cache-chunklist-class.md)|Defines a block allocator that allocates and deallocates memory blocks of a single size.|  \n|[cache_freelist](../standard-library/cache-freelist-class.md)|Defines a block allocator that allocates and deallocates memory blocks of a single size.|  \n|[cache_suballoc](../standard-library/cache-suballoc-class.md)|Defines a block allocator that allocates and deallocates memory blocks of a single size.|  \n|[freelist](../standard-library/freelist-class.md)|Manages a list of memory blocks.|  \n|[max_fixed_size](../standard-library/max-fixed-size-class.md)|Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a fixed maximum length.|  \n|[max_none](../standard-library/max-none-class.md)|Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a maximum length of zero.|  \n|[max_unbounded](../standard-library/max-unbounded-class.md)|Describes a max class object that does not limit the maximum length of a [freelist](../standard-library/freelist-class.md) object.|  \n|[max_variable_size](../standard-library/max-variable-size-class.md)|Describes a max class object that limits a [freelist](../standard-library/freelist-class.md) object to a maximum length that is roughly proportional to the number of allocated memory blocks.|  \n|[rts_alloc](../standard-library/rts-alloc-class.md)|The rts_alloc template class describes a [filter](../standard-library/allocators-header.md) that holds an array of cache instances and determines which instance to use for allocation and deallocation at runtime instead of at compile time.|  \n|[sync_none](../standard-library/sync-none-class.md)|Describes a synchronization filter that provides no synchronization.|  \n|[sync_per_container](../standard-library/sync-per-container-class.md)|Describes a synchronization filter that provides a separate cache object for each allocator object.|  \n|[sync_per_thread](../standard-library/sync-per-thread-class.md)|Describes a synchronization filter that provides a separate cache object for each thread.|  \n|[sync_shared](../standard-library/sync-shared-class.md)|Describes a synchronization filter that uses a mutex to control access to a cache object that is shared by all allocators.|  \n  \n## Requirements  \n **Header:** \\<allocators>  \n  \n **Namespace:** stdext  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)\n\n\n\n"}