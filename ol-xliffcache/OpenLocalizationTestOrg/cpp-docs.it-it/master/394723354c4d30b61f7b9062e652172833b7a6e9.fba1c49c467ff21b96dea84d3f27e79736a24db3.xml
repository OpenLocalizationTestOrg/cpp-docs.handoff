{"nodes":[{"pos":[12,59],"content":"Testing the Read-Only Provider | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Testing the Read-Only Provider | Microsoft Docs","pos":[0,47]}]},{"content":"Testing the Read-Only Provider","pos":[681,711]},{"content":"To test a provider, you need a consumer.","pos":[712,752]},{"content":"It helps if the consumer can match up with the provider.","pos":[753,809]},{"content":"The OLE DB consumer templates are a thin wrapper around OLE DB and match with the provider COM objects.","pos":[810,913]},{"content":"Because the source is shipped with the consumer templates, it is easy to debug a provider with them.","pos":[914,1014]},{"content":"The consumer templates are also a very small and fast way to develop consumer applications.","pos":[1015,1106]},{"content":"The example in this topic creates a default MFC Application Wizard application for a test consumer.","pos":[1113,1212]},{"content":"The test application is a simple dialog with OLE DB consumer template code added.","pos":[1213,1294]},{"content":"To create the test application","pos":[1304,1334]},{"pos":[1344,1408],"content":"On the <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept>, and then click <bpt id=\"p3\">**</bpt>Project<ept id=\"p3\">**</ept>.","source":"On the **File** menu, click **New**, and then click **Project**."},{"content":"In the Project Types pane, select the <bpt id=\"p1\">**</bpt>Visual C++ Projects<ept id=\"p1\">**</ept> folder.","pos":[1418,1487],"source":"In the Project Types pane, select the **Visual C++ Projects** folder."},{"content":"In the Templates pane, select <bpt id=\"p1\">**</bpt>MFC Application<ept id=\"p1\">**</ept>.","pos":[1488,1538],"source":" In the Templates pane, select **MFC Application**."},{"pos":[1548,1612],"content":"For the project name, enter <bpt id=\"p1\">**</bpt>TestProv<ept id=\"p1\">**</ept>, and then click <bpt id=\"p2\">**</bpt>OK<ept id=\"p2\">**</ept>.","source":"For the project name, enter **TestProv**, and then click **OK**."},{"content":"The MFC Application Wizard appears.","pos":[1623,1658]},{"pos":[1668,1726],"content":"On the <bpt id=\"p1\">**</bpt>Application Type<ept id=\"p1\">**</ept> page, select <bpt id=\"p2\">**</bpt>Dialog based<ept id=\"p2\">**</ept>.","source":"On the **Application Type** page, select **Dialog based**."},{"pos":[1736,1820],"content":"On the <bpt id=\"p1\">**</bpt>Advanced Features<ept id=\"p1\">**</ept> page, select <bpt id=\"p2\">**</bpt>Automation<ept id=\"p2\">**</ept>, and then click <bpt id=\"p3\">**</bpt>Finish<ept id=\"p3\">**</ept>.","source":"On the **Advanced Features** page, select **Automation**, and then click **Finish**."},{"pos":[1828,1953],"content":"[!NOTE]\n The application does not require Automation support if you add **CoInitialize** in **CTestProvApp::InitInstance**.","leadings":["","> "],"nodes":[{"content":"The application does not require Automation support if you add <bpt id=\"p1\">**</bpt>CoInitialize<ept id=\"p1\">**</ept> in <bpt id=\"p2\">**</bpt>CTestProvApp::InitInstance<ept id=\"p2\">**</ept>.","pos":[9,123],"source":" The application does not require Automation support if you add **CoInitialize** in **CTestProvApp::InitInstance**."}]},{"content":"You can view and edit the TestProv dialog box (IDD_TESTPROV_DIALOG) by selecting it in Resource View.","pos":[1960,2061]},{"content":"Place two list boxes, one for each string in the rowset, in the dialog box.","pos":[2062,2137]},{"content":"Turn off the sort property for both list boxes by pressing ALT+Enter when a list box is selected, clicking the <bpt id=\"p1\">**</bpt>Styles<ept id=\"p1\">**</ept> tab, and clearing the <bpt id=\"p2\">**</bpt>Sort<ept id=\"p2\">**</ept> check box.","pos":[2138,2301],"source":" Turn off the sort property for both list boxes by pressing ALT+Enter when a list box is selected, clicking the **Styles** tab, and clearing the **Sort** check box."},{"content":"Also, place a <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> button on the dialog box to fetch the file.","pos":[2302,2367],"source":" Also, place a **Run** button on the dialog box to fetch the file."},{"content":"The finished TestProv dialog box should have two list boxes labeled \"String 1\" and \"String 2\", respectively; it also has <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Cancel<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Run<ept id=\"p3\">**</ept> buttons.","pos":[2368,2529],"source":" The finished TestProv dialog box should have two list boxes labeled \"String 1\" and \"String 2\", respectively; it also has **OK**, **Cancel**, and **Run** buttons."},{"content":"Open the header file for the dialog class (in this case TestProvDlg.h).","pos":[2536,2607]},{"content":"Add the following code to the header file (outside of any class declarations):","pos":[2608,2686]},{"content":"The code represents a user record that defines what columns will be in the rowset.","pos":[3046,3128]},{"content":"When the client calls <bpt id=\"p1\">**</bpt>IAccessor::CreateAccessor<ept id=\"p1\">**</ept>, it uses these entries to specify which columns to bind.","pos":[3129,3237],"source":" When the client calls **IAccessor::CreateAccessor**, it uses these entries to specify which columns to bind."},{"content":"The OLE DB consumer templates also allow you to bind columns dynamically.","pos":[3238,3311]},{"content":"The COLUMN_ENTRY macros are the client-side version of the PROVIDER_COLUMN_ENTRY macros.","pos":[3312,3400]},{"content":"The two COLUMN_ENTRY macros specify the ordinal, type, length, and data member for the two strings.","pos":[3401,3500]},{"content":"Add a handler function for the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> button by pressing CTRL and double-clicking the <bpt id=\"p2\">**</bpt>Run<ept id=\"p2\">**</ept> button.","pos":[3507,3609],"source":"Add a handler function for the **Run** button by pressing CTRL and double-clicking the **Run** button."},{"content":"Place the following code in the function:","pos":[3610,3651]},{"content":"The <ph id=\"ph1\">`CCommand`</ph>, <ph id=\"ph2\">`CDataSource`</ph>, and <ph id=\"ph3\">`CSession`</ph> classes all belong to the OLE DB consumer templates.","pos":[4289,4387],"source":"The `CCommand`, `CDataSource`, and `CSession` classes all belong to the OLE DB consumer templates."},{"content":"Each class mimics a COM object in the provider.","pos":[4388,4435]},{"content":"The <ph id=\"ph1\">`CCommand`</ph> object takes the <ph id=\"ph2\">`CProvider`</ph> class, declared in the header file, as a template parameter.","pos":[4436,4540],"source":" The `CCommand` object takes the `CProvider` class, declared in the header file, as a template parameter."},{"content":"The <ph id=\"ph1\">`CProvider`</ph> parameter represents bindings that you use to access the data from the provider.","pos":[4541,4637],"source":" The `CProvider` parameter represents bindings that you use to access the data from the provider."},{"content":"Here is the <ph id=\"ph1\">`Open`</ph> code for the data source, session, and command:","pos":[4638,4704],"source":" Here is the `Open` code for the data source, session, and command:"},{"content":"The lines to open each of the classes create each COM object in the provider.","pos":[4941,5018]},{"content":"To locate the provider, use the ProgID of the provider.","pos":[5019,5074]},{"content":"You can get the ProgID from the system registry or by looking in the MyProvider.rgs file (open the provider's directory and search for the ProgID key).","pos":[5075,5226]},{"content":"The MyData.txt file is included with the MyProv sample.","pos":[5233,5288]},{"content":"To create a file of your own, use an editor and type an even number of strings, pressing ENTER between each string.","pos":[5289,5404]},{"content":"Change the path name if you move the file.","pos":[5405,5447]},{"content":"Pass in the string \"c:<ph id=\"ph1\">\\\\</ph>\\samples<ph id=\"ph2\">\\\\</ph>\\myprov<ph id=\"ph3\">\\\\</ph>\\MyData.txt\" in the <ph id=\"ph4\">`table.Open`</ph> line.","pos":[5454,5535],"source":"Pass in the string \"c:\\\\\\samples\\\\\\myprov\\\\\\MyData.txt\" in the `table.Open` line."},{"content":"If you step into the <ph id=\"ph1\">`Open`</ph> call, you see that this string is passed to the <ph id=\"ph2\">`SetCommandText`</ph> method in the provider.","pos":[5536,5652],"source":" If you step into the `Open` call, you see that this string is passed to the `SetCommandText` method in the provider."},{"content":"Note that the <ph id=\"ph1\">`ICommandText::Execute`</ph> method used that string.","pos":[5653,5715],"source":" Note that the `ICommandText::Execute` method used that string."},{"content":"To fetch the data, call <ph id=\"ph1\">`MoveNext`</ph> on the table.","pos":[5722,5770],"source":"To fetch the data, call `MoveNext` on the table."},{"content":"calls the <bpt id=\"p1\">**</bpt>IRowset::GetNextRows<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`GetRowCount`</ph>, and <ph id=\"ph2\">`GetData`</ph> functions.","pos":[5782,5857],"source":" calls the **IRowset::GetNextRows**, `GetRowCount`, and `GetData` functions."},{"content":"When there are no more rows (that is, the current position in the rowset is greater than <ph id=\"ph1\">`GetRowCount`</ph>), the loop terminates:","pos":[5858,5983],"source":" When there are no more rows (that is, the current position in the rowset is greater than `GetRowCount`), the loop terminates:"},{"content":"Note that when there are no more rows, providers return <bpt id=\"p1\">**</bpt>DB_S_ENDOFROWSET<ept id=\"p1\">**</ept>.","pos":[6138,6215],"source":"Note that when there are no more rows, providers return **DB_S_ENDOFROWSET**."},{"content":"The <bpt id=\"p1\">**</bpt>DB_S_ENDOFROWSET<ept id=\"p1\">**</ept> value is not an error.","pos":[6216,6263],"source":" The **DB_S_ENDOFROWSET** value is not an error."},{"content":"You should always check against <ph id=\"ph1\">`S_OK`</ph> to cancel a data fetch loop and not use the SUCCEEDED macro.","pos":[6264,6363],"source":" You should always check against `S_OK` to cancel a data fetch loop and not use the SUCCEEDED macro."},{"content":"You should now be able to build and test the program.","pos":[6370,6423]},{"content":"See Also","pos":[6432,6440]},{"content":"Enhancing the Simple Read-Only Provider","pos":[6445,6484]}],"content":"---\ntitle: \"Testing the Read-Only Provider | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"testing, OLE DB providers\"\n  - \"testing providers\"\n  - \"OLE DB providers, calling\"\n  - \"OLE DB providers, testing\"\nms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Testing the Read-Only Provider\nTo test a provider, you need a consumer. It helps if the consumer can match up with the provider. The OLE DB consumer templates are a thin wrapper around OLE DB and match with the provider COM objects. Because the source is shipped with the consumer templates, it is easy to debug a provider with them. The consumer templates are also a very small and fast way to develop consumer applications.  \n  \n The example in this topic creates a default MFC Application Wizard application for a test consumer. The test application is a simple dialog with OLE DB consumer template code added.  \n  \n### To create the test application  \n  \n1.  On the **File** menu, click **New**, and then click **Project**.  \n  \n2.  In the Project Types pane, select the **Visual C++ Projects** folder. In the Templates pane, select **MFC Application**.  \n  \n3.  For the project name, enter **TestProv**, and then click **OK**.  \n  \n     The MFC Application Wizard appears.  \n  \n4.  On the **Application Type** page, select **Dialog based**.  \n  \n5.  On the **Advanced Features** page, select **Automation**, and then click **Finish**.  \n  \n> [!NOTE]\n>  The application does not require Automation support if you add **CoInitialize** in **CTestProvApp::InitInstance**.  \n  \n You can view and edit the TestProv dialog box (IDD_TESTPROV_DIALOG) by selecting it in Resource View. Place two list boxes, one for each string in the rowset, in the dialog box. Turn off the sort property for both list boxes by pressing ALT+Enter when a list box is selected, clicking the **Styles** tab, and clearing the **Sort** check box. Also, place a **Run** button on the dialog box to fetch the file. The finished TestProv dialog box should have two list boxes labeled \"String 1\" and \"String 2\", respectively; it also has **OK**, **Cancel**, and **Run** buttons.  \n  \n Open the header file for the dialog class (in this case TestProvDlg.h). Add the following code to the header file (outside of any class declarations):  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// TestProvDlg.h  \n  \nclass CProvider   \n{  \n// Attributes  \npublic:  \n   char   szField1[16];  \n   char   szField2[16];  \n  \n   // Binding Maps  \nBEGIN_COLUMN_MAP(CProvider)  \n   COLUMN_ENTRY(1, szField1)  \n   COLUMN_ENTRY(2, szField2)  \nEND_COLUMN_MAP()  \n};  \n```  \n  \n The code represents a user record that defines what columns will be in the rowset. When the client calls **IAccessor::CreateAccessor**, it uses these entries to specify which columns to bind. The OLE DB consumer templates also allow you to bind columns dynamically. The COLUMN_ENTRY macros are the client-side version of the PROVIDER_COLUMN_ENTRY macros. The two COLUMN_ENTRY macros specify the ordinal, type, length, and data member for the two strings.  \n  \n Add a handler function for the **Run** button by pressing CTRL and double-clicking the **Run** button. Place the following code in the function:  \n  \n```  \n///////////////////////////////////////////////////////////////////////  \n// TestProvDlg.cpp  \n  \nvoid CtestProvDlg::OnRun()  \n{  \n   CCommand<CAccessor<CProvider> > table;  \n   CDataSource source;  \n   CSession   session;  \n  \n   if (source.Open(\"MyProvider.MyProvider.1\", NULL) != S_OK)  \n      return;  \n  \n   if (session.Open(source) != S_OK)  \n      return;  \n  \n   if (table.Open(session, _T(\"c:\\\\samples\\\\myprov\\\\myData.txt\")) != S_OK)  \n      return;  \n  \n   while (table.MoveNext() == S_OK)  \n   {  \n      m_ctlString1.AddString(table.szField1);  \n      m_ctlString2.AddString(table.szField2);  \n   }  \n}  \n```  \n  \n The `CCommand`, `CDataSource`, and `CSession` classes all belong to the OLE DB consumer templates. Each class mimics a COM object in the provider. The `CCommand` object takes the `CProvider` class, declared in the header file, as a template parameter. The `CProvider` parameter represents bindings that you use to access the data from the provider. Here is the `Open` code for the data source, session, and command:  \n  \n```  \nif (source.Open(\"MyProvider.MyProvider.1\", NULL) != S_OK)  \n   return;  \n  \nif (session.Open(source) != S_OK)  \n   return;  \n  \nif (table.Open(session, _T(\"c:\\\\samples\\\\myprov\\\\myData.txt\")) != S_OK)  \n   return;  \n```  \n  \n The lines to open each of the classes create each COM object in the provider. To locate the provider, use the ProgID of the provider. You can get the ProgID from the system registry or by looking in the MyProvider.rgs file (open the provider's directory and search for the ProgID key).  \n  \n The MyData.txt file is included with the MyProv sample. To create a file of your own, use an editor and type an even number of strings, pressing ENTER between each string. Change the path name if you move the file.  \n  \n Pass in the string \"c:\\\\\\samples\\\\\\myprov\\\\\\MyData.txt\" in the `table.Open` line. If you step into the `Open` call, you see that this string is passed to the `SetCommandText` method in the provider. Note that the `ICommandText::Execute` method used that string.  \n  \n To fetch the data, call `MoveNext` on the table. `MoveNext` calls the **IRowset::GetNextRows**, `GetRowCount`, and `GetData` functions. When there are no more rows (that is, the current position in the rowset is greater than `GetRowCount`), the loop terminates:  \n  \n```  \nwhile (table.MoveNext() == S_OK)  \n{  \n   m_ctlString1.AddString(table.szField1);  \n   m_ctlString2.AddString(table.szField2);  \n}  \n```  \n  \n Note that when there are no more rows, providers return **DB_S_ENDOFROWSET**. The **DB_S_ENDOFROWSET** value is not an error. You should always check against `S_OK` to cancel a data fetch loop and not use the SUCCEEDED macro.  \n  \n You should now be able to build and test the program.  \n  \n## See Also  \n [Enhancing the Simple Read-Only Provider](../../data/oledb/enhancing-the-simple-read-only-provider.md)"}