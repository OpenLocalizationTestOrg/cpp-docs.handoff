{"nodes":[{"pos":[12,54],"content":"&lt;complex&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"complex<ph id=\"ph1\">&amp;gt;</ph> operators | Microsoft Docs","pos":[4,42],"source":"complex&gt; operators | Microsoft Docs"}]},{"content":"complex<ph id=\"ph1\">&amp;gt;</ph> operators","pos":[261,282],"source":"complex&gt; operators"},{"content":"operator!=","pos":[302,312]},{"content":"operator","pos":[330,338]},{"content":"operator","pos":[368,376]},{"content":"operator*","pos":[410,419]},{"content":"operator+","pos":[438,447]},{"content":"operator-","pos":[465,474]},{"content":"operator/","pos":[493,502]},{"content":"operator==","pos":[517,527]},{"pos":[585,595],"content":"operator!="},{"content":"Tests for inequality between two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[599,740]},{"content":"Parameters","pos":[1072,1082]},{"content":"A complex number or object of its parameter type to be tested for inequality.","pos":[1097,1174]},{"content":"A complex number or object of its parameter type to be tested for inequality.","pos":[1193,1270]},{"content":"Return Value","pos":[1280,1292]},{"pos":[1296,1366],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the numbers are not equal; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if numbers are equal.","source":"**true** if the numbers are not equal; **false** if numbers are equal."},{"content":"Remarks","pos":[1376,1383]},{"content":"Two complex numbers are equal if and only if their real parts are equal and their imaginary parts are equal.","pos":[1387,1495]},{"content":"Otherwise, they are unequal.","pos":[1496,1524]},{"content":"The operation is overloaded so that comparison tests can be executed without the conversion of the data to a particular format.","pos":[1531,1658]},{"content":"Example","pos":[1668,1675]},{"pos":[5446,5455],"content":"operator*"},{"content":"Multiplies two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[5459,5582]},{"content":"Parameters","pos":[5938,5948]},{"content":"The first of two complex numbers or a number that is of the parameter type for a complex number that is to be multiplied by the * operation.","pos":[5963,6103]},{"content":"The second of two complex numbers or a number that is of the parameter type for a complex number that is to be multiplied by the * operation.","pos":[6122,6263]},{"content":"Return Value","pos":[6273,6285]},{"content":"The complex number that results from the multiplication of the two numbers whose value and type are specified by the parameter inputs.","pos":[6289,6423]},{"content":"Remarks","pos":[6433,6440]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[6444,6583]},{"content":"Example","pos":[6593,6600]},{"pos":[8935,8944],"content":"operator+"},{"content":"Adds two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[8948,9065]},{"content":"Parameters","pos":[9498,9508]},{"content":"The first of two complex numbers or a number that is of the parameter type for a complex number that is to be added by the + operation.","pos":[9523,9658]},{"content":"The second of two complex numbers or a number that is of the parameter type for a complex number that is to be added by the + operation.","pos":[9677,9813]},{"content":"Return Value","pos":[9823,9835]},{"content":"The complex number that results from the addition of the two numbers whose value and type are specified by the parameter inputs.","pos":[9839,9967]},{"content":"Remarks","pos":[9977,9984]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[9988,10127]},{"content":"The unary operator returns","pos":[10128,10154]},{"content":"Example","pos":[10173,10180]},{"pos":[14118,14127],"content":"operator-"},{"content":"Subtracts two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[14131,14253]},{"content":"Parameters","pos":[14685,14695]},{"content":"The first of two complex numbers or a number that is of the parameter type for a complex number that is to be subtracted by the - operation.","pos":[14710,14850]},{"content":"The second of two complex numbers or a number that is of the parameter type for a complex number that is to be subtracted by the - operation.","pos":[14869,15010]},{"content":"Return Value","pos":[15020,15032]},{"pos":[15036,15182],"content":"The complex number that results from the subtraction of <ph id=\"ph1\">` right`</ph> from <ph id=\"ph2\">` left`</ph>, the two numbers whose values are specified by the parameter inputs.","source":"The complex number that results from the subtraction of ` right` from ` left`, the two numbers whose values are specified by the parameter inputs."},{"content":"Remarks","pos":[15192,15199]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[15203,15342]},{"content":"The unary operator changes the sign of a complex number and returns a value whose real part is the negative of the real part of the number input and whose imaginary part is the negative of the imaginary part of the number input.","pos":[15349,15577]},{"content":"Example","pos":[15587,15594]},{"pos":[19533,19542],"content":"operator/"},{"content":"Divides two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[19546,19666]},{"content":"Parameters","pos":[20021,20031]},{"content":"A complex number or a number that is of the parameter type for a complex number that is the numerator to be divided by the denominator with the / operation.","pos":[20046,20202]},{"content":"A complex number or a number that is of the parameter type for a complex number that is the denominator to be used to divide the numerator with the / operation.","pos":[20221,20381]},{"content":"Return Value","pos":[20391,20403]},{"content":"The complex number that results from the division of the numerator by the denominator, the values of which are specified by the parameter inputs.","pos":[20407,20552]},{"content":"Remarks","pos":[20562,20569]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[20573,20712]},{"content":"Example","pos":[20722,20729]},{"pos":[24037,24045],"content":"operator"},{"content":"Inserts a complex number specified into the output stream.","pos":[24057,24115]},{"content":"Parameters","pos":[24306,24316]},{"content":"The output stream into which the complex number is being entered.","pos":[24330,24395]},{"content":"The complex number to be entered into the output stream","pos":[24414,24469]},{"content":"Return Value","pos":[24479,24491]},{"pos":[24495,24613],"content":"Writes the value of the specified complex number to the <ph id=\"ph1\">`Ostr`</ph> in a Cartesian format: ( <bpt id=\"p1\">*</bpt>real part, imaginary part<ept id=\"p1\">*</ept> ).","source":"Writes the value of the specified complex number to the `Ostr` in a Cartesian format: ( *real part, imaginary part* )."},{"content":"Remarks","pos":[24623,24630]},{"content":"The output stream is overloaded so that it will accept any form of a complex number, and its default output format is the Cartesian format.","pos":[24634,24773]},{"content":"Example","pos":[24783,24790]},{"pos":[25691,25701],"content":"operator=="},{"content":"Tests for equality between two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.","pos":[25705,25844]},{"content":"Parameters","pos":[26176,26186]},{"content":"A complex number or object of its parameter type to be tested for inequality.","pos":[26201,26278]},{"content":"A complex number or object of its parameter type to be tested for inequality.","pos":[26297,26374]},{"content":"Return Value","pos":[26384,26396]},{"pos":[26400,26470],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the numbers are equal; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if numbers are not equal.","source":"**true** if the numbers are equal; **false** if numbers are not equal."},{"content":"Remarks","pos":[26480,26487]},{"content":"Two complex numbers are equal if and only if their real parts are equal and their imaginary parts are equal.","pos":[26491,26599]},{"content":"Otherwise, they are unequal.","pos":[26600,26628]},{"content":"The operation is overloaded so that comparison tests can be executed without the conversion of the data to a particular format.","pos":[26635,26762]},{"content":"Example","pos":[26772,26779]},{"pos":[30554,30562],"content":"operator"},{"content":"Extracts a complex value from the input stream.","pos":[30574,30621]},{"content":"Parameters","pos":[30805,30815]},{"content":"The input stream from which the complex number is being extracted.","pos":[30829,30895]},{"content":"The complex number that is being extracted from the input stream.","pos":[30914,30979]},{"content":"Return Value","pos":[30989,31001]},{"pos":[31005,31084],"content":"Reads the value of the specified complex number from <ph id=\"ph1\">`Istr`</ph> and returns it into","source":"Reads the value of the specified complex number from `Istr` and returns it into "},{"content":"Remarks","pos":[31104,31111]},{"content":"The valid input formats are","pos":[31115,31142]},{"content":"( real part, imaginary part )","pos":[31151,31180]},{"content":"( real part )","pos":[31190,31203]},{"content":"real part","pos":[31213,31222]},{"content":"Example","pos":[31233,31240]},{"content":"See Also","pos":[31606,31614]},{"content":"complex&gt;","pos":[31621,31629],"source":"complex>"}],"content":"---\ntitle: \"&lt;complex&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: aa282604-dcb9-46a2-bf1d-34c50aa6c4ba\ncaps.latest.revision: 11\nmanager: \"ghogen\"\n---\n# &lt;complex&gt; operators\n||||  \n|-|-|-|  \n|[operator!=](#operator_neq)|[operator&gt;&gt;](#operator_gt__gt_)|[operator&lt;&lt;](#operator_lt__lt_)|  \n|[operator*](#operator_star)|[operator+](#operator_add)|[operator-](#operator-)|  \n|[operator/](#operator_)|[operator==](#operator_eq_eq)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Tests for inequality between two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```  \n \ntemplate <class Type>  \nbool operator!=(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \nbool operator!=(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \nbool operator!=(\n    const Type& left,  \n    const complex<Type>& right);\n```  \n  \n### Parameters  \n ` left`  \n A complex number or object of its parameter type to be tested for inequality.  \n  \n ` right`  \n A complex number or object of its parameter type to be tested for inequality.  \n  \n### Return Value  \n **true** if the numbers are not equal; **false** if numbers are equal.  \n  \n### Remarks  \n Two complex numbers are equal if and only if their real parts are equal and their imaginary parts are equal. Otherwise, they are unequal.  \n  \n The operation is overloaded so that comparison tests can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_NE.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> compared with type complex<double>  \n   complex <double> cl1 ( polar (3.0, pi / 6 ) );  \n   complex <double> cr1a ( polar (3.0, pi /6 ) );  \n   complex <double> cr1b ( polar (2.0, pi / 3 ) );  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The 1st right-side complex number is cr1a = \" << cr1a << endl;  \n   cout << \"The 2nd right-side complex number is cr1b = \" << cr1b << endl;  \n   if ( cl1 != cr1a )  \n      cout << \"The complex numbers cl1 & cr1a are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl1 & cr1a are equal.\" << endl;  \n   if ( cl1 != cr1b )  \n      cout << \"The complex numbers cl1 & cr1b are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl1 & cr1b are equal.\" << endl;  \n   cout << endl;  \n  \n   // Example of the second member function  \n   // type complex<int> compared with type int  \n   complex <int> cl2a ( 3, 4 );  \n   complex <int> cl2b ( 5,0 );  \n   int cr2a =3;  \n   int cr2b =5;  \n  \n   cout << \"The 1st left-side complex number is cl2a = \" << cl2a << endl;  \n   cout << \"The 1st right-side complex number is cr2a = \" << cr2a << endl;  \n   if ( cl2a != cr2a )  \n      cout << \"The complex numbers cl2a & cr2a are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl2a & cr2a are equal.\" << endl;  \n  \n   cout << \"The 2nd left-side complex number is cl2b = \" << cl2b << endl;  \n   cout << \"The 2nd right-side complex number is cr2b = \" << cr2b << endl;  \n   if ( cl2b != cr2b )  \n      cout << \"The complex numbers cl2b & cr2b are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl2b & cr2b are equal.\" << endl;  \n   cout << endl;  \n  \n   // Example of the third member function  \n   // type double compared with type complex<double>  \n   double cl3a =3;  \n   double cl3b =5;  \n   complex <double> cr3a ( 3, 4 );  \n   complex <double> cr3b ( 5,0 );  \n  \n   cout << \"The 1st left-side complex number is cl3a = \" << cl3a << endl;  \n   cout << \"The 1st right-side complex number is cr3a = \" << cr3a << endl;  \n   if ( cl3a != cr3a )  \n      cout << \"The complex numbers cl3a & cr3a are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl3a & cr3a are equal.\" << endl;  \n  \n   cout << \"The 2nd left-side complex number is cl3b = \" << cl3b << endl;  \n   cout << \"The 2nd right-side complex number is cr3b = \" << cr3b << endl;  \n   if ( cl3b != cr3b )  \n      cout << \"The complex numbers cl3b & cr3b are not equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl3b & cr3b are equal.\" << endl;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (2.59808,1.5)  \nThe 1st right-side complex number is cr1a = (2.59808,1.5)  \nThe 2nd right-side complex number is cr1b = (1,1.73205)  \nThe complex numbers cl1 & cr1a are equal.  \nThe complex numbers cl1 & cr1b are not equal.  \n  \nThe 1st left-side complex number is cl2a = (3,4)  \nThe 1st right-side complex number is cr2a = 3  \nThe complex numbers cl2a & cr2a are not equal.  \nThe 2nd left-side complex number is cl2b = (5,0)  \nThe 2nd right-side complex number is cr2b = 5  \nThe complex numbers cl2b & cr2b are equal.  \n  \nThe 1st left-side complex number is cl3a = 3  \nThe 1st right-side complex number is cr3a = (3,4)  \nThe complex numbers cl3a & cr3a are not equal.  \nThe 2nd left-side complex number is cl3b = 5  \nThe 2nd right-side complex number is cr3b = (5,0)  \nThe complex numbers cl3b & cr3b are equal.  \n```  \n  \n##  <a name=\"operator_star\"></a>  operator*  \n Multiplies two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```  \n \ntemplate <class Type>  \ncomplex<Type> operator*(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator*(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \ncomplex<Type> operator*(\n    const Type& left,  \n    const complex<Type>& right);\n```  \n  \n### Parameters  \n ` left`  \n The first of two complex numbers or a number that is of the parameter type for a complex number that is to be multiplied by the * operation.  \n  \n ` right`  \n The second of two complex numbers or a number that is of the parameter type for a complex number that is to be multiplied by the * operation.  \n  \n### Return Value  \n The complex number that results from the multiplication of the two numbers whose value and type are specified by the parameter inputs.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_mult.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> times type complex<double>  \n   complex <double> cl1 ( polar (3.0, pi / 6 ) );  \n   complex <double> cr1 ( polar (2.0, pi / 3 ) );  \n   complex <double> cs1 = cl1 * cr1;  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n   cout << \"Product of two complex numbers is: cs1 = \" << cs1 << endl;  \n   double abscs1 = abs ( cs1 );  \n   double argcs1 = arg ( cs1 );  \n   cout << \"The modulus of cs1 is: \" << abscs1 << endl;  \n   cout << \"The argument of cs1 is: \"<< argcs1 << \" radians, which is \"  \n        << argcs1 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Example of the second member function  \n   // type complex<double> times type double  \n   complex <double> cl2 ( polar ( 3.0, pi / 6 ) );  \n   double cr2 =5;  \n   complex <double> cs2 = cl2 * cr2;  \n  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n   cout << \"Product of two complex numbers is: cs2 = \" << cs2 << endl;  \n   double abscs2 = abs ( cs2 );  \n   double argcs2 = arg ( cs2 );  \n   cout << \"The modulus of cs2 is: \" << abscs2 << endl;  \n   cout << \"The argument of cs2 is: \"<< argcs2 << \" radians, which is \"  \n        << argcs2 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Example of the third member function  \n   // type double times type complex<double>  \n   double cl3 = 5;  \n   complex <double> cr3 ( polar (3.0, pi / 6 ) );  \n   complex <double> cs3 = cl3 * cr3;  \n  \n   cout << \"The left-side complex number is cl3 = \" << cl3 << endl;  \n   cout << \"The right-side complex number is cr3 = \" << cr3 << endl;  \n   cout << \"Product of two complex numbers is: cs3 = \" << cs3 << endl;  \n   double abscs3 = abs ( cs3 );  \n   double argcs3 = arg ( cs3 );  \n   cout << \"The modulus of cs3 is: \" << abscs3 << endl;  \n   cout << \"The argument of cs3 is: \"<< argcs3 << \" radians, which is \"  \n        << argcs3 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n##  <a name=\"operator_add\"></a>  operator+  \n Adds two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```  \n \ntemplate <class Type>  \ncomplex<Type> operator+(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator+(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \ncomplex<Type> operator+(\n    const Type& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator+(const complex<Type>& left);\n```  \n  \n### Parameters  \n ` left`  \n The first of two complex numbers or a number that is of the parameter type for a complex number that is to be added by the + operation.  \n  \n ` right`  \n The second of two complex numbers or a number that is of the parameter type for a complex number that is to be added by the + operation.  \n  \n### Return Value  \n The complex number that results from the addition of the two numbers whose value and type are specified by the parameter inputs.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format. The unary operator returns ` left.`  \n  \n### Example  \n  \n```cpp  \n// complex_op_add.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> plus type complex<double>  \n   complex <double> cl1 ( 3.0, 4.0 );  \n   complex <double> cr1 ( 2.0, 5.0 );  \n   complex <double> cs1 = cl1 + cr1;  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n   cout << \"The sum of the two complex numbers is: cs1 = \" << cs1 << endl;  \n   double abscs1 = abs ( cs1 );  \n   double argcs1 = arg ( cs1 );  \n   cout << \"The modulus of cs1 is: \" << abscs1 << endl;  \n   cout << \"The argument of cs1 is: \"<< argcs1 << \" radians, which is \"   \n        << argcs1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type complex<double> plus type double  \n   complex <double> cl2 ( 3.0, 4.0 );  \n   double cr2 =5.0;  \n   complex <double> cs2 = cl2 + cr2;  \n  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n   cout << \"The sum of the two complex numbers is: cs2 = \" << cs2 << endl;  \n   double abscs2 = abs ( cs2 );  \n   double argcs2 = arg ( cs2 );  \n   cout << \"The modulus of cs2 is: \" << abscs2 << endl;  \n   cout << \"The argument of cs2 is: \"<< argcs2 << \" radians, which is \"   \n        << argcs2 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Example of the third member function  \n   // type double plus type complex<double>  \n   double cl3 = 5.0;  \n   complex <double> cr3 ( 3.0, 4.0 );  \n   complex <double> cs3 = cl3 + cr3;  \n  \n   cout << \"The left-side complex number is cl3 = \" << cl3 << endl;  \n   cout << \"The right-side complex number is cr3 = \" << cr3 << endl;  \n   cout << \"The sum of the two complex numbers is: cs3 = \" << cs3 << endl;  \n   double abscs3 = abs ( cs3 );  \n   double argcs3 = arg ( cs3 );  \n   cout << \"The modulus of cs3 is: \" << abscs3 << endl;  \n   cout << \"The argument of cs3 is: \"<< argcs3 << \" radians, which is \"   \n        << argcs3 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the fourth member function  \n   // plus type complex<double>  \n   complex <double> cr4 ( 3.0, 4.0 );  \n   complex <double> cs4 = + cr4;  \n  \n   cout << \"The right-side complex number is cr4 = \" << cr4 << endl;  \n   cout << \"The result of the unary application of + to the right-side\"  \n        << \"\\n complex number is: cs4 = \" << cs4 << endl;  \n   double abscs4 = abs ( cs4 );  \n   double argcs4 = arg ( cs4 );  \n   cout << \"The modulus of cs4 is: \" << abscs4 << endl;  \n   cout << \"The argument of cs4 is: \"<< argcs4 << \" radians, which is \"   \n        << argcs4 * 180 / pi << \" degrees.\" << endl << endl;    \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (3,4)  \nThe right-side complex number is cr1 = (2,5)  \nThe sum of the two complex numbers is: cs1 = (5,9)  \nThe modulus of cs1 is: 10.2956  \nThe argument of cs1 is: 1.0637 radians, which is 60.9454 degrees.  \n  \nThe left-side complex number is cl2 = (3,4)  \nThe right-side complex number is cr2 = 5  \nThe sum of the two complex numbers is: cs2 = (8,4)  \nThe modulus of cs2 is: 8.94427  \nThe argument of cs2 is: 0.463648 radians, which is 26.5651 degrees.  \n  \nThe left-side complex number is cl3 = 5  \nThe right-side complex number is cr3 = (3,4)  \nThe sum of the two complex numbers is: cs3 = (8,4)  \nThe modulus of cs3 is: 8.94427  \nThe argument of cs3 is: 0.463648 radians, which is 26.5651 degrees.  \n  \nThe right-side complex number is cr4 = (3,4)  \nThe result of the unary application of + to the right-side  \n complex number is: cs4 = (3,4)  \nThe modulus of cs4 is: 5  \nThe argument of cs4 is: 0.927295 radians, which is 53.1301 degrees.  \n```  \n  \n##  <a name=\"operator-\"></a>  operator-  \n Subtracts two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```   \ntemplate <class Type>  \ncomplex<Type> operator-(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator-(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \ncomplex<Type> operator-(\n    const Type& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator-(const complex<Type>& left);\n```  \n  \n### Parameters  \n ` left`  \n The first of two complex numbers or a number that is of the parameter type for a complex number that is to be subtracted by the - operation.  \n  \n ` right`  \n The second of two complex numbers or a number that is of the parameter type for a complex number that is to be subtracted by the - operation.  \n  \n### Return Value  \n The complex number that results from the subtraction of ` right` from ` left`, the two numbers whose values are specified by the parameter inputs.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n The unary operator changes the sign of a complex number and returns a value whose real part is the negative of the real part of the number input and whose imaginary part is the negative of the imaginary part of the number input.  \n  \n### Example  \n  \n```cpp  \n// complex_op_sub.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> minus type complex<double>  \n   complex <double> cl1 ( 3.0, 4.0 );  \n   complex <double> cr1 ( 2.0, 5.0 );  \n   complex <double> cs1 = cl1 - cr1;  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n   cout << \"Difference of two complex numbers is: cs1 = \" << cs1 << endl;  \n   double abscs1 = abs ( cs1 );  \n   double argcs1 = arg ( cs1 );  \n   cout << \"The modulus of cs1 is: \" << abscs1 << endl;  \n   cout << \"The argument of cs1 is: \"<< argcs1 << \" radians, which is \"   \n        << argcs1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type complex<double> minus type double  \n   complex <double> cl2 ( 3.0, 4.0 );  \n   double cr2 =5.0;  \n   complex <double> cs2 = cl2 - cr2;  \n  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n   cout << \"Difference of two complex numbers is: cs2 = \" << cs2 << endl;  \n   double abscs2 = abs ( cs2 );  \n   double argcs2 = arg ( cs2 );  \n   cout << \"The modulus of cs2 is: \" << abscs2 << endl;  \n   cout << \"The argument of cs2 is: \"<< argcs2 << \" radians, which is \"   \n        << argcs2 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Example of the third member function  \n   // type double minus type complex<double>  \n   double cl3 = 5.0;  \n   complex <double> cr3 ( 3.0, 4.0 );  \n   complex <double> cs3 = cl3 - cr3;  \n  \n   cout << \"The left-side complex number is cl3 = \" << cl3 << endl;  \n   cout << \"The right-side complex number is cr3 = \" << cr3 << endl;  \n   cout << \"Difference of two complex numbers is: cs3 = \" << cs3 << endl;  \n   double abscs3 = abs ( cs3 );  \n   double argcs3 = arg ( cs3 );  \n   cout << \"The modulus of cs3 is: \" << abscs3 << endl;  \n   cout << \"The argument of cs3 is: \"<< argcs3 << \" radians, which is \"   \n        << argcs3 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the fourth member function  \n   // minus type complex<double>  \n   complex <double> cr4 ( 3.0, 4.0 );  \n   complex <double> cs4 = - cr4;  \n  \n   cout << \"The right-side complex number is cr4 = \" << cr4 << endl;  \n   cout << \"The result of the unary application of - to the right-side\"  \n        << \"\\n complex number is: cs4 = \" << cs4 << endl;  \n   double abscs4 = abs ( cs4 );  \n   double argcs4 = arg ( cs4 );  \n   cout << \"The modulus of cs4 is: \" << abscs4 << endl;  \n   cout << \"The argument of cs4 is: \"<< argcs4 << \" radians, which is \"   \n        << argcs4 * 180 / pi << \" degrees.\" << endl << endl;    \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (3,4)  \nThe right-side complex number is cr1 = (2,5)  \nDifference of two complex numbers is: cs1 = (1,-1)  \nThe modulus of cs1 is: 1.41421  \nThe argument of cs1 is: -0.785398 radians, which is -45 degrees.  \n  \nThe left-side complex number is cl2 = (3,4)  \nThe right-side complex number is cr2 = 5  \nDifference of two complex numbers is: cs2 = (-2,4)  \nThe modulus of cs2 is: 4.47214  \nThe argument of cs2 is: 2.03444 radians, which is 116.565 degrees.  \n  \nThe left-side complex number is cl3 = 5  \nThe right-side complex number is cr3 = (3,4)  \nDifference of two complex numbers is: cs3 = (2,-4)  \nThe modulus of cs3 is: 4.47214  \nThe argument of cs3 is: -1.10715 radians, which is -63.4349 degrees.  \n  \nThe right-side complex number is cr4 = (3,4)  \nThe result of the unary application of - to the right-side  \n complex number is: cs4 = (-3,-4)  \nThe modulus of cs4 is: 5  \nThe argument of cs4 is: -2.2143 radians, which is -126.87 degrees.  \n```  \n  \n##  <a name=\"operator_\"></a>  operator/  \n Divides two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```   \ntemplate <class Type>  \ncomplex<Type> operator*(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \ncomplex<Type> operator*(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \ncomplex<Type> operator*(\n    const Type& left,  \n    const complex<Type>& right);\n```  \n  \n### Parameters  \n ` left`  \n A complex number or a number that is of the parameter type for a complex number that is the numerator to be divided by the denominator with the / operation.  \n  \n ` right`  \n A complex number or a number that is of the parameter type for a complex number that is the denominator to be used to divide the numerator with the / operation.  \n  \n### Return Value  \n The complex number that results from the division of the numerator by the denominator, the values of which are specified by the parameter inputs.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_div.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> divided by type complex<double>  \n   complex <double> cl1 ( polar ( 3.0, pi / 6 ) );  \n   complex <double> cr1 ( polar ( 2.0, pi / 3 ) );  \n   complex <double> cs1 = cl1 / cr1;  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n   cout << \"The quotient of the two complex numbers is: cs1 = cl1 /cr1 = \"  \n        << cs1 << endl;  \n   double abscs1 = abs ( cs1 );  \n   double argcs1 = arg ( cs1 );  \n   cout << \"The modulus of cs1 is: \" << abscs1 << endl;  \n   cout << \"The argument of cs1 is: \"<< argcs1 << \" radians, which is \"   \n        << argcs1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // example of the second member function  \n   // type complex<double> divided by type double  \n   complex <double> cl2 ( polar (3.0, pi / 6 ) );  \n   double cr2 =5;  \n   complex <double> cs2 = cl2 / cr2;  \n  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n   cout << \"The quotient of the two complex numbers is: cs2 = cl2 /cr2 = \"   \n        << cs2 << endl;  \n   double abscs2 = abs ( cs2 );  \n   double argcs2 = arg ( cs2 );  \n   cout << \"The modulus of cs2 is: \" << abscs2 << endl;  \n   cout << \"The argument of cs2 is: \"<< argcs2 << \" radians, which is \"   \n        << argcs2 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Example of the third member function  \n   // type double divided by type complex<double>  \n   double cl3 = 5;  \n   complex <double> cr3 ( polar ( 3.0, pi / 6 ) );  \n   complex <double> cs3 = cl3 / cr3;  \n  \n   cout << \"The left-side complex number is cl3 = \" << cl3 << endl;  \n   cout << \"The right-side complex number is cr3 = \" << cr3 << endl;  \n   cout << \"The quotient of the two complex numbers is: cs3 = cl3 /cr2 = \"  \n        << cs3 << endl;  \n   double abscs3 = abs ( cs3 );  \n   double argcs3 = arg ( cs3 );  \n   cout << \"The modulus of cs3 is: \" << abscs3 << endl;  \n   cout << \"The argument of cs3 is: \"<< argcs3 << \" radians, which is \"   \n        << argcs3 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (2.59808,1.5)  \nThe right-side complex number is cr1 = (1,1.73205)  \nThe quotient of the two complex numbers is: cs1 = cl1 /cr1 = (1.29904,-0.75)  \nThe modulus of cs1 is: 1.5  \nThe argument of cs1 is: -0.523599 radians, which is -30 degrees.  \n  \nThe left-side complex number is cl2 = (2.59808,1.5)  \nThe right-side complex number is cr2 = 5  \nThe quotient of the two complex numbers is: cs2 = cl2 /cr2 = (0.519615,0.3)  \nThe modulus of cs2 is: 0.6  \nThe argument of cs2 is: 0.523599 radians, which is 30 degrees.  \n  \nThe left-side complex number is cl3 = 5  \nThe right-side complex number is cr3 = (2.59808,1.5)  \nThe quotient of the two complex numbers is: cs3 = cl3 /cr2 = (1.44338,-0.833333)  \nThe modulus of cs3 is: 1.66667  \nThe argument of cs3 is: -0.523599 radians, which is -30 degrees.  \n```  \n  \n##  <a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;  \n Inserts a complex number specified into the output stream.  \n  \n```   \ntemplate <class Type, class Elem, class Traits>  \nbasic_ostream<Elem, Traits>& operator<<(\n    basic_ostream<Elem, Traits>& Ostr,  \n    const complex<Type>& right);\n```  \n  \n### Parameters  \n `Ostr`  \n The output stream into which the complex number is being entered.  \n  \n ` right`  \n The complex number to be entered into the output stream  \n  \n### Return Value  \n Writes the value of the specified complex number to the `Ostr` in a Cartesian format: ( *real part, imaginary part* ).  \n  \n### Remarks  \n The output stream is overloaded so that it will accept any form of a complex number, and its default output format is the Cartesian format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_insert.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   complex <double> c1 ( 3.0, 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   complex <double> c2  ( polar ( 2.0, pi / 6 ) );  \n   cout << \"Complex number c2 = \" << c2 << endl;  \n  \n   // To display in polar form  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = (1.73205,1)  \nThe modulus of c2 is: 2  \nThe argument of c2 is: 0.523599 radians, which is 30 degrees.  \n```  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Tests for equality between two complex numbers, one or both of which may belong to the subset of the type for the real and imaginary parts.  \n  \n```  \n \ntemplate <class Type>  \nbool operator==(\n    const complex<Type>& left,  \n    const complex<Type>& right);\n\ntemplate <class Type>  \nbool operator==(\n    const complex<Type>& left,  \n    const Type& right);\n\ntemplate <class Type>  \nbool operator==(\n    const Type& left,  \n    const complex<Type>& right);\n```  \n  \n### Parameters  \n ` left`  \n A complex number or object of its parameter type to be tested for inequality.  \n  \n ` right`  \n A complex number or object of its parameter type to be tested for inequality.  \n  \n### Return Value  \n **true** if the numbers are equal; **false** if numbers are not equal.  \n  \n### Remarks  \n Two complex numbers are equal if and only if their real parts are equal and their imaginary parts are equal. Otherwise, they are unequal.  \n  \n The operation is overloaded so that comparison tests can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_EQ.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> compared with type complex<double>  \n   complex <double> cl1 ( polar ( 3.0, pi / 6 ) );  \n   complex <double> cr1a ( polar ( 3.0, pi /6 ) );  \n   complex <double> cr1b ( polar ( 2.0, pi / 3 ) );  \n  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The 1st right-side complex number is cr1a = \" << cr1a << endl;  \n   cout << \"The 2nd right-side complex number is cr1b = \" << cr1b << endl;  \n   if ( cl1 == cr1a )  \n      cout << \"The complex numbers cl1 & cr1a are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl1 & cr1a are not equal.\" << endl;  \n   if ( cl1 == cr1b )  \n      cout << \"The complex numbers cl1 & cr1b are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl1 & cr1b are not equal.\" << endl;  \n   cout << endl;  \n  \n   // Example of the second member function  \n   // type complex<int> compared with type int  \n   complex <int> cl2a ( 3, 4 );  \n   complex <int> cl2b ( 5,0 );  \n   int cr2a =3;  \n   int cr2b =5;  \n  \n   cout << \"The 1st left-side complex number is cl2a = \" << cl2a << endl;  \n   cout << \"The 1st right-side complex number is cr2a = \" << cr2a << endl;  \n   if ( cl2a == cr2a )  \n      cout << \"The complex numbers cl2a & cr2a are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl2a & cr2a are not equal.\" << endl;  \n  \n   cout << \"The 2nd left-side complex number is cl2b = \" << cl2b << endl;  \n   cout << \"The 2nd right-side complex number is cr2b = \" << cr2b << endl;  \n   if ( cl2b == cr2b )  \n      cout << \"The complex numbers cl2b & cr2b are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl2b & cr2b are not equal.\" << endl;  \n   cout << endl;  \n  \n   // Example of the third member function  \n   // type double compared with type complex<double>  \n   double cl3a =3;  \n   double cl3b =5;  \n   complex <double> cr3a (3, 4 );  \n   complex <double> cr3b (5,0 );  \n  \n   cout << \"The 1st left-side complex number is cl3a = \" << cl3a << endl;  \n   cout << \"The 1st right-side complex number is cr3a = \" << cr3a << endl;  \n   if ( cl3a == cr3a )  \n      cout << \"The complex numbers cl3a & cr3a are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl3a & cr3a are not equal.\" << endl;  \n  \n   cout << \"The 2nd left-side complex number is cl3b = \" << cl3b << endl;  \n   cout << \"The 2nd right-side complex number is cr3b = \" << cr3b << endl;  \n   if ( cl3b == cr3b )  \n      cout << \"The complex numbers cl3b & cr3b are equal.\" << endl;  \n   else  \n      cout << \"The complex numbers cl3b & cr3b are not equal.\" << endl;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (2.59808,1.5)  \nThe 1st right-side complex number is cr1a = (2.59808,1.5)  \nThe 2nd right-side complex number is cr1b = (1,1.73205)  \nThe complex numbers cl1 & cr1a are equal.  \nThe complex numbers cl1 & cr1b are not equal.  \n  \nThe 1st left-side complex number is cl2a = (3,4)  \nThe 1st right-side complex number is cr2a = 3  \nThe complex numbers cl2a & cr2a are not equal.  \nThe 2nd left-side complex number is cl2b = (5,0)  \nThe 2nd right-side complex number is cr2b = 5  \nThe complex numbers cl2b & cr2b are equal.  \n  \nThe 1st left-side complex number is cl3a = 3  \nThe 1st right-side complex number is cr3a = (3,4)  \nThe complex numbers cl3a & cr3a are not equal.  \nThe 2nd left-side complex number is cl3b = 5  \nThe 2nd right-side complex number is cr3b = (5,0)  \nThe complex numbers cl3b & cr3b are equal.  \n```  \n  \n##  <a name=\"operator_gt__gt_\"></a>  operator&gt;&gt;  \n Extracts a complex value from the input stream.  \n  \n```  \n \ntemplate <class Type, class Elem, class Traits>  \nbasic_istream<Elem, Traits>& operator>>(\n   basic_istream<Elem, Traits>& Istr,  \n   complex<Type>& right);\n```  \n  \n### Parameters  \n `Istr`  \n The input stream from which the complex number is being extracted.  \n  \n ` right`  \n The complex number that is being extracted from the input stream.  \n  \n### Return Value  \n Reads the value of the specified complex number from `Istr` and returns it into ` right.`  \n  \n### Remarks  \n The valid input formats are  \n  \n- *( real part, imaginary part )*  \n  \n- *( real part )*  \n  \n- *real part*  \n  \n### Example  \n  \n```cpp  \n// complex_op_extract.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   complex <double> c2;  \n  \n   cout << \"Input a complex number ( try: 2.0 ): \";  \n   cin >> c2;  \n   cout << c2 << endl;  \n}  \n```  \n  \n```Output  \n  \n2.0  \n  \n```  \n  \n## See Also  \n [\\<complex>](../standard-library/complex.md)\n\n"}