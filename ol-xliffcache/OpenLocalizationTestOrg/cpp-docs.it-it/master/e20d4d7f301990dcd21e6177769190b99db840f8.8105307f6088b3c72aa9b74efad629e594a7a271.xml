{"nodes":[{"pos":[12,42],"content":"_resetstkoflw | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_resetstkoflw | Microsoft Docs","pos":[0,30]}]},{"pos":[983,996],"content":"_resetstkoflw","linkify":"_resetstkoflw","nodes":[{"content":"_resetstkoflw","pos":[0,13]}]},{"content":"Recovers from stack overflow.","pos":[997,1026]},{"pos":[1034,1254],"content":"[!IMPORTANT]\n This API cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","leadings":["","> "],"nodes":[{"content":" This API cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","pos":[13,218],"nodes":[{"content":"This API cannot be used in applications that execute in the Windows Runtime.","pos":[1,77]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CRT functions not supported with /ZW<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)</ept>.","pos":[78,205],"source":" For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)."}]}]},{"pos":[1263,1269],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1329,1341],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function succeeds, zero if it fails.","pos":[1345,1396]},{"pos":[1405,1412],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_resetstkoflw`</ph> function recovers from a stack overflow condition, allowing a program to continue instead of failing with a fatal exception error.","pos":[1416,1566],"source":"The `_resetstkoflw` function recovers from a stack overflow condition, allowing a program to continue instead of failing with a fatal exception error."},{"content":"If the <ph id=\"ph1\">`_resetstkoflw`</ph> function is not called, there are no guard pages after the previous exception.","pos":[1567,1668],"source":" If the `_resetstkoflw` function is not called, there are no guard pages after the previous exception."},{"content":"The next time that there is a stack overflow, there are no exceptions at all and the process terminates without warning.","pos":[1669,1789]},{"content":"If a thread in an application causes an <bpt id=\"p1\">**</bpt>EXCEPTION_STACK_OVERFLOW<ept id=\"p1\">**</ept> exception, the thread has left its stack in a damaged state.","pos":[1796,1925],"source":"If a thread in an application causes an **EXCEPTION_STACK_OVERFLOW** exception, the thread has left its stack in a damaged state."},{"content":"This is in contrast to other exceptions such as <bpt id=\"p1\">**</bpt>EXCEPTION_ACCESS_VIOLATION<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>EXCEPTION_INT_DIVIDE_BY_ZERO<ept id=\"p2\">**</ept>, where the stack is not damaged.","pos":[1926,2073],"source":" This is in contrast to other exceptions such as **EXCEPTION_ACCESS_VIOLATION** or **EXCEPTION_INT_DIVIDE_BY_ZERO**, where the stack is not damaged."},{"content":"The stack is set to an arbitrarily small value when the program is first loaded.","pos":[2074,2154]},{"content":"The stack then grows on demand to meet the needs of the thread.","pos":[2155,2218]},{"content":"This is implemented by placing a page with PAGE_GUARD access at the end of the current stack.","pos":[2219,2312]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating Guard Pages<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa366549)</ept>.","pos":[2313,2422],"source":" For more information, see [Creating Guard Pages](http://msdn.microsoft.com/library/windows/desktop/aa366549)."},{"content":"When the code causes the stack pointer to point to an address on this page, an exception occurs and the system does the following three things:","pos":[2429,2572]},{"content":"Removes the PAGE_GUARD protection on the guard page so that the thread can read and write data to the memory.","pos":[2582,2691]},{"content":"Allocates a new guard page that is located one page below the last one.","pos":[2701,2772]},{"content":"Reruns the instruction that raised the exception.","pos":[2782,2831]},{"content":"In this way, the system can increase the size of the stack for the thread automatically.","pos":[2838,2926]},{"content":"Each thread in a process has a maximum stack size.","pos":[2927,2977]},{"content":"The stack size is set at compile time by the <bpt id=\"p1\">[</bpt>/STACK (Stack Allocations)<ept id=\"p1\">](../../build/reference/stack-stack-allocations.md)</ept>, or by the <bpt id=\"p2\">[</bpt>STACKSIZE<ept id=\"p2\">](../../build/reference/stacksize.md)</ept> statement in the .def file for the project.","pos":[2978,3204],"source":" The stack size is set at compile time by the [/STACK (Stack Allocations)](../../build/reference/stack-stack-allocations.md), or by the [STACKSIZE](../../build/reference/stacksize.md) statement in the .def file for the project."},{"content":"When this maximum stack size is exceeded, the system does the following three things:","pos":[3211,3296]},{"content":"Removes the PAGE_GUARD protection on the guard page, as previously described.","pos":[3306,3383]},{"content":"Tries to allocate a new guard page below the last one.","pos":[3393,3447]},{"content":"However, this fails because the maximum stack size has been exceeded.","pos":[3448,3517]},{"content":"Raises an exception so that the thread can handle it in the exception block.","pos":[3527,3603]},{"content":"Note that, at that point, the stack no longer has a guard page.","pos":[3610,3673]},{"content":"The next time that the program grows the stack all the way to the end, where there should be a guard page, the program writes beyond the end of the stack and causes an access violation.","pos":[3674,3859]},{"content":"Call <ph id=\"ph1\">`_resetstkoflw`</ph> to restore the guard page whenever recovery is done after a stack overflow exception.","pos":[3866,3972],"source":"Call `_resetstkoflw` to restore the guard page whenever recovery is done after a stack overflow exception."},{"content":"This function can be called from inside the main body of an <ph id=\"ph1\">`__except`</ph> block or outside an <bpt id=\"p1\">**</bpt>__except<ept id=\"p1\">**</ept> block.","pos":[3973,4083],"source":" This function can be called from inside the main body of an `__except` block or outside an **__except** block."},{"content":"However, there are some restrictions on when it should be used.","pos":[4084,4147]},{"content":"<ph id=\"ph1\">`_resetstkoflw`</ph> should never be called from:","pos":[4148,4192],"source":"`_resetstkoflw` should never be called from:"},{"content":"A filter expression.","pos":[4202,4222]},{"content":"A filter function.","pos":[4232,4250]},{"content":"A function called from a filter function.","pos":[4260,4301]},{"pos":[4311,4329],"content":"A <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block.","source":"A **catch** block."},{"pos":[4339,4359],"content":"A <ph id=\"ph1\">`__finally`</ph> block.","source":"A `__finally` block."},{"content":"At these points, the stack is not yet sufficiently unwound.","pos":[4366,4425]},{"content":"Stack overflow exceptions are generated as structured exceptions, not C++ exceptions, so <ph id=\"ph1\">`_resetstkoflw`</ph> is not useful in an ordinary <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block because it will not catch a stack overflow exception.","pos":[4432,4635],"source":"Stack overflow exceptions are generated as structured exceptions, not C++ exceptions, so `_resetstkoflw` is not useful in an ordinary **catch** block because it will not catch a stack overflow exception."},{"content":"However, if <bpt id=\"p1\">[</bpt>_set_se_translator<ept id=\"p1\">](../../c-runtime-library/reference/set-se-translator.md)</ept> is used to implement a structured exception translator that throws C++ exceptions (as in the second example), a stack overflow exception results in a C++ exception that can be handled by a C++ catch block.","pos":[4636,4930],"source":" However, if [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) is used to implement a structured exception translator that throws C++ exceptions (as in the second example), a stack overflow exception results in a C++ exception that can be handled by a C++ catch block."},{"content":"It is not safe to call <bpt id=\"p1\">**</bpt>_resetstkoflw<ept id=\"p1\">**</ept> in a C++ catch block that is reached from an exception thrown by the structured exception translator function.","pos":[4937,5088],"source":"It is not safe to call **_resetstkoflw** in a C++ catch block that is reached from an exception thrown by the structured exception translator function."},{"content":"In this case, the stack space is not freed and the stack pointer is not reset until outside the catch block, even though destructors have been called for any destructible objects before the catch block.","pos":[5089,5291]},{"content":"This function should not be called until the stack space is freed and the stack pointer has been reset.","pos":[5292,5395]},{"content":"Therefore, it should be called only after exiting the catch block.","pos":[5396,5462]},{"content":"As little stack space as possible should be used in the catch block because a stack overflow that occurs in the catch block that is itself attempting to recover from a previous stack overflow is not recoverable and can cause the program to stop responding as the overflow in the catch block triggers an exception that itself is handled by the same catch block.","pos":[5463,5823]},{"content":"There are situations where <bpt id=\"p1\">**</bpt>_resetstkoflw<ept id=\"p1\">**</ept> can fail even if used in a correct location, such as within an <bpt id=\"p2\">**</bpt>__except<ept id=\"p2\">**</ept> block.","pos":[5830,5957],"source":"There are situations where **_resetstkoflw** can fail even if used in a correct location, such as within an **__except** block."},{"content":"If, even after unwinding the stack, there is still not enough stack space left to execute <bpt id=\"p1\">**</bpt>_resetstkoflw<ept id=\"p1\">**</ept> without writing into the last page of the stack, <bpt id=\"p2\">**</bpt>_resetstkoflw<ept id=\"p2\">**</ept> fails to reset the last page of the stack as the guard page and returns 0, indicating failure.","pos":[5958,6227],"source":" If, even after unwinding the stack, there is still not enough stack space left to execute **_resetstkoflw** without writing into the last page of the stack, **_resetstkoflw** fails to reset the last page of the stack as the guard page and returns 0, indicating failure."},{"content":"Therefore, safe usage of this function should include checking the return value instead of assuming that the stack is safe to use.","pos":[6228,6358]},{"pos":[6365,6623],"content":"Structured exception handling will not catch a <ph id=\"ph1\">`STATUS_STACK_OVERFLOW`</ph> exception when the application is compiled with <ph id=\"ph2\">`/clr`</ph> or <ph id=\"ph3\">`/clr:pure`</ph> (see <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept>).","source":"Structured exception handling will not catch a `STATUS_STACK_OVERFLOW` exception when the application is compiled with `/clr` or `/clr:pure` (see [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md))."},{"pos":[6632,6644],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[6651,6658]},{"content":"Required header","pos":[6659,6674]},{"content":"<ph id=\"ph1\">\\&lt;</ph>malloc.h&gt;","pos":[6735,6746],"source":"\\<malloc.h>"},{"pos":[6754,6852],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"pos":[6859,6966],"content":"<bpt id=\"p1\">**</bpt>Libraries:<ept id=\"p1\">**</ept> All versions of the <bpt id=\"p2\">[</bpt>CRT Library Features<ept id=\"p2\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"**Libraries:** All versions of the [CRT Library Features](../../c-runtime-library/crt-library-features.md)."},{"pos":[6975,6982],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6986,7068],"content":"The following example shows the recommended usage of the <ph id=\"ph1\">`_resetstkoflw`</ph> function.","source":"The following example shows the recommended usage of the `_resetstkoflw` function."},{"pos":[8627,8640],"content":"Sample Output","linkify":"Sample Output","nodes":[{"content":"Sample Output","pos":[0,13]}]},{"content":"With no program arguments:","pos":[8644,8670]},{"content":"The program stops responding without executing further iterations.","pos":[8702,8768]},{"content":"With program arguments:","pos":[8775,8798]},{"pos":[9194,9205],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[9209,9349],"content":"The following example shows the recommended use of <ph id=\"ph1\">`_resetstkoflw`</ph> in a program where structured exceptions are converted to C++ exceptions.","source":"The following example shows the recommended use of `_resetstkoflw` in a program where structured exceptions are converted to C++ exceptions."},{"pos":[9359,9363],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"pos":[11649,11662],"content":"Sample Output","linkify":"Sample Output","nodes":[{"content":"Sample Output","pos":[0,13]}]},{"pos":[11846,11871],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[11875,11890]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[11891,11938],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[11939,12064],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[12073,12081],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[12085,12139],"content":"<bpt id=\"p1\">[</bpt>_alloca<ept id=\"p1\">](../../c-runtime-library/reference/alloca.md)</ept>","source":"[_alloca](../../c-runtime-library/reference/alloca.md)"}],"content":"---\ntitle: \"_resetstkoflw | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_resetstkoflw\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"resetstkoflw\"\n  - \"_resetstkoflw\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"resetstkoflw function\"\n  - \"stack overflow\"\n  - \"stack, recovering\"\n  - \"_resetstkoflw function\"\nms.assetid: 319529cd-4306-4d22-810b-2063f3ad9e14\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _resetstkoflw\nRecovers from stack overflow.  \n  \n> [!IMPORTANT]\n>  This API cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).  \n  \n## Syntax  \n  \n```  \n  \nint _resetstkoflw ( void );  \n  \n```  \n  \n## Return Value  \n Nonzero if the function succeeds, zero if it fails.  \n  \n## Remarks  \n The `_resetstkoflw` function recovers from a stack overflow condition, allowing a program to continue instead of failing with a fatal exception error. If the `_resetstkoflw` function is not called, there are no guard pages after the previous exception. The next time that there is a stack overflow, there are no exceptions at all and the process terminates without warning.  \n  \n If a thread in an application causes an **EXCEPTION_STACK_OVERFLOW** exception, the thread has left its stack in a damaged state. This is in contrast to other exceptions such as **EXCEPTION_ACCESS_VIOLATION** or **EXCEPTION_INT_DIVIDE_BY_ZERO**, where the stack is not damaged. The stack is set to an arbitrarily small value when the program is first loaded. The stack then grows on demand to meet the needs of the thread. This is implemented by placing a page with PAGE_GUARD access at the end of the current stack. For more information, see [Creating Guard Pages](http://msdn.microsoft.com/library/windows/desktop/aa366549).  \n  \n When the code causes the stack pointer to point to an address on this page, an exception occurs and the system does the following three things:  \n  \n-   Removes the PAGE_GUARD protection on the guard page so that the thread can read and write data to the memory.  \n  \n-   Allocates a new guard page that is located one page below the last one.  \n  \n-   Reruns the instruction that raised the exception.  \n  \n In this way, the system can increase the size of the stack for the thread automatically. Each thread in a process has a maximum stack size. The stack size is set at compile time by the [/STACK (Stack Allocations)](../../build/reference/stack-stack-allocations.md), or by the [STACKSIZE](../../build/reference/stacksize.md) statement in the .def file for the project.  \n  \n When this maximum stack size is exceeded, the system does the following three things:  \n  \n-   Removes the PAGE_GUARD protection on the guard page, as previously described.  \n  \n-   Tries to allocate a new guard page below the last one. However, this fails because the maximum stack size has been exceeded.  \n  \n-   Raises an exception so that the thread can handle it in the exception block.  \n  \n Note that, at that point, the stack no longer has a guard page. The next time that the program grows the stack all the way to the end, where there should be a guard page, the program writes beyond the end of the stack and causes an access violation.  \n  \n Call `_resetstkoflw` to restore the guard page whenever recovery is done after a stack overflow exception. This function can be called from inside the main body of an `__except` block or outside an **__except** block. However, there are some restrictions on when it should be used. `_resetstkoflw` should never be called from:  \n  \n-   A filter expression.  \n  \n-   A filter function.  \n  \n-   A function called from a filter function.  \n  \n-   A **catch** block.  \n  \n-   A `__finally` block.  \n  \n At these points, the stack is not yet sufficiently unwound.  \n  \n Stack overflow exceptions are generated as structured exceptions, not C++ exceptions, so `_resetstkoflw` is not useful in an ordinary **catch** block because it will not catch a stack overflow exception. However, if [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) is used to implement a structured exception translator that throws C++ exceptions (as in the second example), a stack overflow exception results in a C++ exception that can be handled by a C++ catch block.  \n  \n It is not safe to call **_resetstkoflw** in a C++ catch block that is reached from an exception thrown by the structured exception translator function. In this case, the stack space is not freed and the stack pointer is not reset until outside the catch block, even though destructors have been called for any destructible objects before the catch block. This function should not be called until the stack space is freed and the stack pointer has been reset. Therefore, it should be called only after exiting the catch block. As little stack space as possible should be used in the catch block because a stack overflow that occurs in the catch block that is itself attempting to recover from a previous stack overflow is not recoverable and can cause the program to stop responding as the overflow in the catch block triggers an exception that itself is handled by the same catch block.  \n  \n There are situations where **_resetstkoflw** can fail even if used in a correct location, such as within an **__except** block. If, even after unwinding the stack, there is still not enough stack space left to execute **_resetstkoflw** without writing into the last page of the stack, **_resetstkoflw** fails to reset the last page of the stack as the guard page and returns 0, indicating failure. Therefore, safe usage of this function should include checking the return value instead of assuming that the stack is safe to use.  \n  \n Structured exception handling will not catch a `STATUS_STACK_OVERFLOW` exception when the application is compiled with `/clr` or `/clr:pure` (see [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md)).  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_resetstkoflw`|\\<malloc.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n **Libraries:** All versions of the [CRT Library Features](../../c-runtime-library/crt-library-features.md).  \n  \n## Example  \n The following example shows the recommended usage of the `_resetstkoflw` function.  \n  \n```  \n// crt_resetstkoflw.c  \n// Launch program with and without arguments to observe  \n// the difference made by calling _resetstkoflw.  \n  \n#include <malloc.h>  \n#include <stdio.h>  \n#include <windows.h>  \n  \nvoid recursive(int recurse)  \n{  \n   _alloca(2000);  \n   if (recurse)  \n      recursive(recurse);  \n}  \n  \n// Filter for the stack overflow exception.  \n// This function traps the stack overflow exception, but passes  \n// all other exceptions through.   \nint stack_overflow_exception_filter(int exception_code)  \n{  \n   if (exception_code == EXCEPTION_STACK_OVERFLOW)  \n   {  \n       // Do not call _resetstkoflw here, because  \n       // at this point, the stack is not yet unwound.  \n       // Instead, signal that the handler (the __except block)  \n       // is to be executed.  \n       return EXCEPTION_EXECUTE_HANDLER;  \n   }  \n   else  \n       return EXCEPTION_CONTINUE_SEARCH;  \n}  \n  \nint main(int ac)  \n{  \n   int i = 0;  \n   int recurse = 1, result = 0;  \n  \n   for (i = 0 ; i < 10 ; i++)  \n   {  \n      printf(\"loop #%d\\n\", i + 1);  \n      __try  \n      {  \n         recursive(recurse);  \n  \n      }  \n  \n      __except(stack_overflow_exception_filter(GetExceptionCode()))  \n      {  \n         // Here, it is safe to reset the stack.  \n  \n         if (ac >= 2)  \n         {  \n            puts(\"resetting stack overflow\");  \n            result = _resetstkoflw();  \n         }  \n      }  \n  \n      // Terminate if _resetstkoflw failed (returned 0)  \n      if (!result)  \n         return 3;  \n   }  \n  \n   return 0;  \n}  \n```  \n  \n## Sample Output  \n With no program arguments:  \n  \n```  \nloop #1  \n```  \n  \n The program stops responding without executing further iterations.  \n  \n With program arguments:  \n  \n```  \nloop #1  \nresetting stack overflow  \nloop #2  \nresetting stack overflow  \nloop #3  \nresetting stack overflow  \nloop #4  \nresetting stack overflow  \nloop #5  \nresetting stack overflow  \nloop #6  \nresetting stack overflow  \nloop #7  \nresetting stack overflow  \nloop #8  \nresetting stack overflow  \nloop #9  \nresetting stack overflow  \nloop #10  \nresetting stack overflow  \n```  \n  \n### Description  \n The following example shows the recommended use of `_resetstkoflw` in a program where structured exceptions are converted to C++ exceptions.  \n  \n### Code  \n  \n```  \n// crt_resetstkoflw2.cpp  \n// compile with: /EHa  \n// _set_se_translator requires the use of /EHa  \n#include <malloc.h>  \n#include <stdio.h>  \n#include <windows.h>  \n#include <eh.h>  \n  \nclass Exception { };  \n  \nclass StackOverflowException : Exception { };  \n  \n// Because the overflow is deliberate, disable the warning that  \n// this function will cause a stack overflow.  \n#pragma warning (disable: 4717)  \nvoid CauseStackOverflow (int i)  \n{  \n        // Overflow the stack by allocating a large stack-based array  \n        // in a recursive function.  \n        int a[10000];  \n        printf(\"%d \", i);  \n        CauseStackOverflow (i + 1);  \n}  \n  \nvoid __cdecl SEHTranslator (unsigned int code, _EXCEPTION_POINTERS*)  \n{  \n   // For stack overflow exceptions, throw our own C++   \n   // exception object.  \n   // For all other exceptions, throw a generic exception object.  \n   // Use minimal stack space in this function.  \n   // Do not call _resetstkoflw in this function.  \n  \n   if (code == EXCEPTION_STACK_OVERFLOW)  \n      throw StackOverflowException ( );  \n   else  \n      throw Exception( );  \n}  \n  \nint main ( )  \n{  \n        bool stack_reset = false;  \n        bool result = false;  \n  \n        // Set up a function to handle all structured exceptions,  \n        // including stack overflow exceptions.  \n        _set_se_translator (SEHTranslator);  \n  \n        try  \n        {  \n            CauseStackOverflow (0);  \n        }  \n        catch (StackOverflowException except)  \n        {  \n                // Use minimal stack space here.  \n                // Do not call _resetstkoflw here.  \n                printf(\"\\nStack overflow!\\n\");  \n                stack_reset = true;  \n        }  \n        catch (Exception except)  \n        {  \n                // Do not call _resetstkoflw here.  \n                printf(\"\\nUnknown Exception!\\n\");  \n        }  \n        if (stack_reset)  \n        {  \n          result = _resetstkoflw();  \n          // If stack reset failed, terminate the application.  \n          if (result == 0)  \n             exit(1);  \n        }  \n  \n        void* pv = _alloca(100000);  \n        printf(\"Recovered from stack overflow and allocated 100,000 bytes\"  \n               \" using _alloca.\");  \n  \n   return 0;  \n}  \n```  \n  \n## Sample Output  \n  \n```  \n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \nStack overflow!  \nRecovered from stack overflow and allocated 100,000 bytes using _alloca.  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [_alloca](../../c-runtime-library/reference/alloca.md)"}