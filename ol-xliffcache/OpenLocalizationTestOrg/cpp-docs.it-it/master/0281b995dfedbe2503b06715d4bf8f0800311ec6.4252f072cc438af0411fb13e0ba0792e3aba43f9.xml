{"nodes":[{"pos":[12,64],"content":"Developing Your Own Helper Function | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Developing Your Own Helper Function | Microsoft Docs","pos":[0,52]}]},{"content":"Developing Your Own Helper Function","pos":[615,650]},{"content":"You may want to provide your own version of the routine to do specific processing based on the names of the DLL or imports.","pos":[651,774]},{"content":"There are two methods of doing this: coding your own, possibly based on the supplied code, or merely hooking the supplied version using the notification hooks detailed previously.","pos":[775,954]},{"content":"Code Your Own","pos":[961,974]},{"content":"This is fairly simple since you can essentially use the supplied code as a guideline for the new one.","pos":[978,1079]},{"content":"Of course, it must adhere to the calling conventions and if it returns to the linker-generated thunks, it must return a proper function pointer.","pos":[1080,1224]},{"content":"Once in your code, you can do pretty much whatever you want in order to satisfy the call or get out of the call.","pos":[1225,1337]},{"content":"Use the Start Processing Notification Hook","pos":[1344,1386]},{"content":"It will probably be easiest to simply provide a new pointer to a user-supplied notification hook function that receives the same values as the default helper on the notification dliStartProcessing.","pos":[1390,1587]},{"content":"At that point, the hook function can essentially become the new helper function, as a successful return to the default helper will bypass all further processing in the default helper.","pos":[1588,1771]},{"content":"See Also","pos":[1780,1788]},{"content":"Linker Support for Delay-Loaded DLLs","pos":[1793,1829]}],"content":"---\ntitle: \"Developing Your Own Helper Function | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"helper functions\"\nms.assetid: a845429d-68b1-4e14-aa88-f3f5343bd490\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Developing Your Own Helper Function\nYou may want to provide your own version of the routine to do specific processing based on the names of the DLL or imports. There are two methods of doing this: coding your own, possibly based on the supplied code, or merely hooking the supplied version using the notification hooks detailed previously.  \n  \n Code Your Own  \n This is fairly simple since you can essentially use the supplied code as a guideline for the new one. Of course, it must adhere to the calling conventions and if it returns to the linker-generated thunks, it must return a proper function pointer. Once in your code, you can do pretty much whatever you want in order to satisfy the call or get out of the call.  \n  \n Use the Start Processing Notification Hook  \n It will probably be easiest to simply provide a new pointer to a user-supplied notification hook function that receives the same values as the default helper on the notification dliStartProcessing. At that point, the hook function can essentially become the new helper function, as a successful return to the default helper will bypass all further processing in the default helper.  \n  \n## See Also  \n [Linker Support for Delay-Loaded DLLs](../../build/reference/linker-support-for-delay-loaded-dlls.md)"}