{"nodes":[{"pos":[12,88],"content":"Compiler Support for Type Traits (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Support for Type Traits (C++ Component Extensions) | Microsoft Docs","pos":[0,76]}]},{"content":"Compiler Support for Type Traits (C++ Component Extensions)","pos":[2300,2359]},{"pos":[2360,2462],"content":"The compiler supports <bpt id=\"p1\">*</bpt>type traits<ept id=\"p1\">*</ept>, which indicate various characteristics of a type at compile time.","source":"The compiler supports *type traits*, which indicate various characteristics of a type at compile time."},{"content":"All Runtimes","pos":[2471,2483]},{"content":"Remarks","pos":[2489,2496]},{"content":"Type traits are especially useful to programmers who write libraries.","pos":[2505,2574]},{"content":"The following list contains the type traits that are supported by the compiler.","pos":[2581,2660]},{"content":"All type traits return <ph id=\"ph1\">`false`</ph> if the condition specified by the name of the type trait is not met.","pos":[2661,2760],"source":" All type traits return `false` if the condition specified by the name of the type trait is not met."},{"content":"(In the following list, code examples are written only in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>.","pos":[2767,2886],"source":"(In the following list, code examples are written only in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]."},{"content":"But the corresponding type trait is also supported in <ph id=\"ph1\">[!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)]</ph> unless stated otherwise.","pos":[2887,3026],"source":" But the corresponding type trait is also supported in [!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)] unless stated otherwise."},{"content":"The term, \"platform type\" refers to either <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> types or common language runtime types.)","pos":[3027,3163],"source":" The term, \"platform type\" refers to either [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] types or common language runtime types.)"},{"content":"Returns true if the platform or native type has a copy assignment operator.","pos":[3210,3285]},{"content":"Returns true if the platform or native type has a copy constructor.","pos":[3500,3567]},{"content":"(Not supported in <ph id=\"ph1\">[!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)]</ph>.) Returns true if the CLR type has a finalizer.","pos":[3772,3898],"source":"(Not supported in [!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)].) Returns true if the CLR type has a finalizer."},{"content":"See <bpt id=\"p1\">[</bpt>Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)<ept id=\"p1\">](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)</ept> for more information.","pos":[3899,4113],"source":" See [Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers) for more information."},{"content":"Returns true if a copy assignment operator has an empty exception specification.","pos":[4378,4458]},{"content":"Returns true if the default constructor has an empty exception specification.","pos":[4750,4827]},{"content":"Returns true if the copy constructor has an empty exception specification.","pos":[5100,5174]},{"content":"Returns true if the type has a trivial, compiler-generated assignment operator.","pos":[5446,5525]},{"content":"Returns true if the type has a trivial, compiler-generated constructor.","pos":[5772,5843]},{"content":"Returns true if the type has a trivial, compiler-generated copy constructor.","pos":[6088,6164]},{"content":"Returns true if the type has a trivial, compiler-generated destructor.","pos":[6408,6478]},{"content":"Returns true if the platform or native type has a user-declared destructor.","pos":[6761,6836]},{"content":"Returns true if the type has a virtual destructor.","pos":[7115,7165]},{"pos":[7203,7308],"content":"also works on platform types, and any user-defined destructor in a platform type is a virtual destructor."},{"content":"Returns true if the type is an abstract type.","pos":[7612,7657]},{"content":"For more information on native abstract types, see <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../windows/abstract-cpp-component-extensions.md)</ept>.","pos":[7658,7769],"source":" For more information on native abstract types, see [abstract](../windows/abstract-cpp-component-extensions.md)."},{"content":"also works for platform types.","pos":[7796,7826]},{"content":"An interface with at least one member is an abstract type, as is a reference type with at least one abstract member.","pos":[7827,7943]},{"content":"For more information on abstract platform types, see <bpt id=\"p1\">[</bpt>Abstract Classes<ept id=\"p1\">](../cpp/abstract-classes-cpp.md)</ept>","pos":[7944,8047],"source":" For more information on abstract platform types, see [Abstract Classes](../cpp/abstract-classes-cpp.md)"},{"content":"Returns true if the first type is a base class of the second type, of if both types are the same.","pos":[8351,8448]},{"content":"also works on platform types.","pos":[8474,8503]},{"content":"For example, it will return true if the first type is an <bpt id=\"p1\">[</bpt>interface class<ept id=\"p1\">](../windows/interface-class-cpp-component-extensions.md)</ept> and the second type implements the interface.","pos":[8504,8680],"source":" For example, it will return true if the first type is an [interface class](../windows/interface-class-cpp-component-extensions.md) and the second type implements the interface."},{"content":"Returns true if the type is a native class or struct.","pos":[9043,9096]},{"content":"Returns true if the first type can be converted to the second type.","pos":[9337,9404]},{"content":"Returns true if <ph id=\"ph1\">`type`</ph> is a delegate.","pos":[9726,9763],"source":"Returns true if `type` is a delegate."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>delegate  (C++ Component Extensions)<ept id=\"p1\">](../windows/delegate-cpp-component-extensions.md)</ept>.","pos":[9764,9878],"source":" For more information, see [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md)."},{"content":"Returns true if the type has no instance data members.","pos":[10064,10118]},{"content":"Returns true if the type is a native enum.","pos":[10383,10425]},{"content":"Returns true if passed a platform interface.","pos":[10814,10858]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>interface class<ept id=\"p1\">](../windows/interface-class-cpp-component-extensions.md)</ept>.","pos":[10859,10959],"source":" For more information, see [interface class](../windows/interface-class-cpp-component-extensions.md)."},{"content":"Returns true if the type is a class or union with no constructor or private or protected non-static members, no base classes, and no virtual functions.","pos":[11202,11353]},{"content":"See the C++ standard, sections 8.5.1/1, 9/4, and 3.9/10 for more information on PODs.","pos":[11354,11439]},{"pos":[11461,11500],"content":"will return false on fundamental types."},{"content":"Returns true if a native type has virtual functions.","pos":[11726,11778]},{"content":"Returns true if passed a platform array.","pos":[12045,12085]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Arrays<ept id=\"p1\">](../windows/arrays-cpp-component-extensions.md)</ept>.","pos":[12086,12168],"source":" For more information, see [Arrays](../windows/arrays-cpp-component-extensions.md)."},{"content":"Returns true if passed a reference class.","pos":[12401,12442]},{"content":"For more information on user-defined reference types, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>.","pos":[12443,12583],"source":" For more information on user-defined reference types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)."},{"content":"Returns true if passed a platform or native type marked sealed.","pos":[12832,12895]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../windows/sealed-cpp-component-extensions.md)</ept>.","pos":[12896,12978],"source":" For more information, see [sealed](../windows/sealed-cpp-component-extensions.md)."},{"content":"Returns true if passed a value type that contains no references to the garbage-collected heap.","pos":[13170,13264]},{"content":"For more information on user-defined value types, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>.","pos":[13265,13401],"source":" For more information on user-defined value types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)."},{"content":"Returns true if a type is a union.","pos":[13767,13801]},{"content":"Returns true if passed a value type.","pos":[14063,14099]},{"content":"For more information on user-defined value types, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>.","pos":[14100,14236],"source":" For more information on user-defined value types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)."},{"content":"Remarks","pos":[14442,14449]},{"pos":[14458,14568],"content":"The <ph id=\"ph1\">`__has_finalizer(`</ph><bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept><ph id=\"ph2\">`)`</ph> type trait is not supported because this platform does not support finalizers.","source":"The `__has_finalizer(`*type*`)` type trait is not supported because this platform does not support finalizers."},{"content":"Requirements","pos":[14578,14590]},{"pos":[14594,14618],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Remarks","pos":[14704,14711]},{"content":"(There are no platform-specific remarks for this feature.)","pos":[14720,14778]},{"content":"Requirements","pos":[14788,14800]},{"pos":[14804,14829],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[14839,14847]},{"content":"Example","pos":[14853,14860]},{"content":"The following code example shows how to use a class template to expose a compiler type trait for a <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compilation.","pos":[14869,14989],"source":"The following code example shows how to use a class template to expose a compiler type trait for a **/clr** compilation."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Runtime and Managed Templates<ept id=\"p1\">](../windows/windows-runtime-and-managed-templates-cpp-component-extensions.md)</ept>.","pos":[14990,15134],"source":" For more information, see [Windows Runtime and Managed Templates](../windows/windows-runtime-and-managed-templates-cpp-component-extensions.md)."},{"content":"Output","pos":[15519,15525]},{"content":"See Also","pos":[15576,15584]},{"content":"Component Extensions for Runtime Platforms","pos":[15589,15631]}],"content":"---\ntitle: \"Compiler Support for Type Traits (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__is_simple_value_class\"\n  - \"__has_trivial_destructor\"\n  - \"__has_assign\"\n  - \"__is_union\"\n  - \"__is_class\"\n  - \"__is_abstract\"\n  - \"__has_trivial_assign\"\n  - \"__has_virtual_destructor\"\n  - \"__is_ref_array\"\n  - \"__is_base_of\"\n  - \"__has_copy\"\n  - \"__is_polymorphic\"\n  - \"__has_nothrow_constructor\"\n  - \"__is_ref_class\"\n  - \"__is_delegate\"\n  - \"__is_convertible_to\"\n  - \"__is_value_class\"\n  - \"__is_interface_class\"\n  - \"__has_nothrow_copy\"\n  - \"__is_sealed\"\n  - \"__has_trivial_constructor\"\n  - \"__has_trivial_copy\"\n  - \"__is_enum\"\n  - \"__has_nothrow_assign\"\n  - \"__has_finalizer\"\n  - \"__is_empty\"\n  - \"__is_pod\"\n  - \"__has_user_destructor\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__is_class keyword [C++]\"\n  - \"__is_pod keyword [C++]\"\n  - \"__is_delegate keyword [C++]\"\n  - \"__is_value_class keyword [C++]\"\n  - \"__has_copy keyword [C++]\"\n  - \"__has_nothrow_copy keyword [C++]\"\n  - \"__is_interface_class keyword [C++]\"\n  - \"__is_sealed keyword [C++]\"\n  - \"__is_convertible_to keyword [C++]\"\n  - \"__is_ref_class keyword [C++]\"\n  - \"__has_trivial_copy keyword [C++]\"\n  - \"__has_user_destructor keyword [C++]\"\n  - \"__is_abstract keyword [C++]\"\n  - \"__is_empty keyword [C++]\"\n  - \"__has_trivial_assign keyword [C++]\"\n  - \"__has_nothrow_constructor keyword [C++]\"\n  - \"__is_ref_array keyword [C++]\"\n  - \"__is_base_of keyword [C++]\"\n  - \"__has_nothrow_assign keyword [C++]\"\n  - \"__has_virtual_destructor keyword [C++]\"\n  - \"__has_finalizer keyword [C++]\"\n  - \"__is_union keyword [C++]\"\n  - \"__has_assign keyword [C++]\"\n  - \"__has_trivial_destructor keyword [C++]\"\n  - \"__is_polymorphic keyword [C++]\"\n  - \"__is_enum keyword [C++]\"\n  - \"__is_simple_value_class keyword [C++]\"\n  - \"__has_trivial_constructor keyword [C++]\"\nms.assetid: cd440630-0394-48c0-a16b-1580b6ef5844\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Support for Type Traits (C++ Component Extensions)\nThe compiler supports *type traits*, which indicate various characteristics of a type at compile time.  \n  \n## All Runtimes  \n **Remarks**  \n  \n Type traits are especially useful to programmers who write libraries.  \n  \n The following list contains the type traits that are supported by the compiler. All type traits return `false` if the condition specified by the name of the type trait is not met.  \n  \n (In the following list, code examples are written only in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]. But the corresponding type trait is also supported in [!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)] unless stated otherwise. The term, \"platform type\" refers to either [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] types or common language runtime types.)  \n  \n-   `__has_assign(` `type` `)`  \n  \n     Returns true if the platform or native type has a copy assignment operator.  \n  \n    ```  \n  \n    ref struct R {  \n    void operator=(R% r) {}  \n    };  \n  \n    int main() {  \n    System::Console::WriteLine(__has_assign(R));  \n    }  \n  \n    ```  \n  \n-   `__has_copy(` `type` `)`  \n  \n     Returns true if the platform or native type has a copy constructor.  \n  \n    ```  \n  \n    ref struct R {  \n    R(R% r) {}  \n    };  \n  \n    int main() {  \n    System::Console::WriteLine(__has_copy(R));  \n    }  \n  \n    ```  \n  \n-   `__has_finalizer(` `type` `)`  \n  \n     (Not supported in [!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)].) Returns true if the CLR type has a finalizer. See [Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers) for more information.  \n  \n    ```  \n  \n    using namespace System;  \n    ref struct R {  \n    ~R() {}  \n    protected:  \n    !R() {}  \n    };  \n  \n    int main() {  \n    Console::WriteLine(__has_finalizer(R));  \n    }  \n  \n    ```  \n  \n-   `__has_nothrow_assign(` `type` `)`  \n  \n     Returns true if a copy assignment operator has an empty exception specification.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {  \n    void operator=(S& r) throw() {}  \n    };  \n  \n    int main() {  \n    __has_nothrow_assign(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_nothrow_constructor(` `type` `)`  \n  \n     Returns true if the default constructor has an empty exception specification.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {  \n    S() throw() {}  \n    };  \n  \n    int main() {  \n    __has_nothrow_constructor(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_nothrow_copy(` `type` `)`  \n  \n     Returns true if the copy constructor has an empty exception specification.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {  \n    S(S& r) throw() {}  \n    };  \n  \n    int main() {  \n    __has_nothrow_copy(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_trivial_assign(` `type` `)`  \n  \n     Returns true if the type has a trivial, compiler-generated assignment operator.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __has_trivial_assign(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_trivial_constructor(` `type` `)`  \n  \n     Returns true if the type has a trivial, compiler-generated constructor.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __has_trivial_constructor(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_trivial_copy(` `type` `)`  \n  \n     Returns true if the type has a trivial, compiler-generated copy constructor.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __has_trivial_copy(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_trivial_destructor(` `type` `)`  \n  \n     Returns true if the type has a trivial, compiler-generated destructor.  \n  \n    ```  \n  \n    // has_trivial_destructor.cpp  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __has_trivial_destructor(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__has_user_destructor(` `type` `)`  \n  \n     Returns true if the platform or native type has a user-declared destructor.  \n  \n    ```  \n  \n    // has_user_destructor.cpp  \n  \n    using namespace System;  \n    ref class R {  \n    ~R() {}  \n    };  \n  \n    int main() {  \n    Console::WriteLine(__has_user_destructor(R));  \n    }  \n  \n    ```  \n  \n-   `__has_virtual_destructor(` `type` `)`  \n  \n     Returns true if the type has a virtual destructor.  \n  \n     `__has_virtual_destructor` also works on platform types, and any user-defined destructor in a platform type is a virtual destructor.  \n  \n    ```  \n  \n    // has_virtual_destructor.cpp  \n    #include <stdio.h>  \n    struct S {  \n    virtual ~S() {}  \n    };  \n  \n    int main() {  \n    __has_virtual_destructor(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_abstract(` `type` `)`  \n  \n     Returns true if the type is an abstract type. For more information on native abstract types, see [abstract](../windows/abstract-cpp-component-extensions.md).  \n  \n     `__is_abstract` also works for platform types. An interface with at least one member is an abstract type, as is a reference type with at least one abstract member. For more information on abstract platform types, see [Abstract Classes](../cpp/abstract-classes-cpp.md)  \n  \n    ```  \n  \n    // is_abstract.cpp  \n    #include <stdio.h>  \n    struct S {  \n    virtual void Test() = 0;  \n    };  \n  \n    int main() {  \n    __is_abstract(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_base_of(` `base` `,` `derived` `)`  \n  \n     Returns true if the first type is a base class of the second type, of if both types are the same.  \n  \n     `__is_base_of` also works on platform types. For example, it will return true if the first type is an [interface class](../windows/interface-class-cpp-component-extensions.md) and the second type implements the interface.  \n  \n    ```  \n  \n    // is_base_of.cpp  \n    #include <stdio.h>  \n    struct S {};  \n    struct T : public S {};  \n  \n    int main() {  \n    __is_base_of(S, T) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n  \n    __is_base_of(S, S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_class(` `type` `)`  \n  \n     Returns true if the type is a native class or struct.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __is_class(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_convertible_to(` `from` `,`  `to` `)`  \n  \n     Returns true if the first type can be converted to the second type.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n    struct T : public S {};  \n  \n    int main() {  \n    S * s = new S;  \n    T * t = new T;  \n    s = t;  \n    __is_convertible_to(T, S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_delegate(` `type` `)`  \n  \n     Returns true if `type` is a delegate. For more information, see [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md).  \n  \n    ```  \n  \n    delegate void MyDel();  \n    int main() {  \n    System::Console::WriteLine(__is_delegate(MyDel));  \n    }  \n  \n    ```  \n  \n-   `__is_empty(` `type` `)`  \n  \n     Returns true if the type has no instance data members.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {  \n    int Test() {}  \n    static int i;  \n    };  \n    int main() {  \n    __is_empty(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_enum(` `type` `)`  \n  \n     Returns true if the type is a native enum.  \n  \n    ```  \n  \n    // is_enum.cpp  \n    #include <stdio.h>  \n    enum E { a, b };  \n  \n    struct S {  \n    enum E2 { c, d };  \n    };  \n  \n    int main() {  \n    __is_enum(E) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n  \n    __is_enum(S::E2) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_interface_class(` `type` `)`  \n  \n     Returns true if passed a platform interface. For more information, see [interface class](../windows/interface-class-cpp-component-extensions.md).  \n  \n    ```  \n  \n    // is_interface_class.cpp  \n  \n    using namespace System;  \n    interface class I {};  \n    int main() {  \n    Console::WriteLine(__is_interface_class(I));  \n    }  \n  \n    ```  \n  \n-   `__is_pod(` `type` `)`  \n  \n     Returns true if the type is a class or union with no constructor or private or protected non-static members, no base classes, and no virtual functions. See the C++ standard, sections 8.5.1/1, 9/4, and 3.9/10 for more information on PODs.  \n  \n     `__is_pod` will return false on fundamental types.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {};  \n  \n    int main() {  \n    __is_pod(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_polymorphic(` `type` `)`  \n  \n     Returns true if a native type has virtual functions.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    struct S {  \n    virtual void Test(){}  \n    };  \n  \n    int main() {  \n    __is_polymorphic(S) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_ref_array(` `type` `)`  \n  \n     Returns true if passed a platform array. For more information, see [Arrays](../windows/arrays-cpp-component-extensions.md).  \n  \n    ```  \n  \n    using namespace System;  \n    int main() {  \n    array<int>^ x = gcnew array<int>(10);  \n    Console::WriteLine(__is_ref_array(array<int>));  \n    }  \n  \n    ```  \n  \n-   `__is_ref_class(` `type` `)`  \n  \n     Returns true if passed a reference class. For more information on user-defined reference types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md).  \n  \n    ```  \n  \n    using namespace System;  \n    ref class R {};  \n    int main() {  \n    Console::WriteLine(__is_ref_class(Buffer));  \n    Console::WriteLine(__is_ref_class(R));  \n    }  \n  \n    ```  \n  \n-   `__is_sealed(` `type` `)`  \n  \n     Returns true if passed a platform or native type marked sealed. For more information, see [sealed](../windows/sealed-cpp-component-extensions.md).  \n  \n    ```  \n  \n    ref class R sealed{};  \n    int main() {  \n    System::Console::WriteLine(__is_sealed(R));  \n    }  \n  \n    ```  \n  \n-   `__is_simple_value_class(` `type` `)`  \n  \n     Returns true if passed a value type that contains no references to the garbage-collected heap. For more information on user-defined value types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md).  \n  \n    ```  \n  \n    using namespace System;  \n    ref class R {};  \n    value struct V {};  \n    value struct V2 {  \n    R ^ r;   // not a simnple value type  \n    };  \n  \n    int main() {  \n    Console::WriteLine(__is_simple_value_class(V));  \n    Console::WriteLine(__is_simple_value_class(V2));  \n    }  \n  \n    ```  \n  \n-   `__is_union(` `type` `)`  \n  \n     Returns true if a type is a union.  \n  \n    ```  \n  \n    #include <stdio.h>  \n    union A {  \n    int i;  \n    float f;  \n    };  \n  \n    int main() {  \n    __is_union(A) == true ?  \n    printf(\"true\\n\") : printf(\"false\\n\");  \n    }  \n  \n    ```  \n  \n-   `__is_value_class(` `type` `)`  \n  \n     Returns true if passed a value type. For more information on user-defined value types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md).  \n  \n    ```  \n  \n    value struct V {};  \n  \n    int main() {  \n    System::Console::WriteLine(__is_value_class(V));  \n    }  \n  \n    ```  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Remarks**  \n  \n The `__has_finalizer(`*type*`)` type trait is not supported because this platform does not support finalizers.  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Remarks**  \n  \n (There are no platform-specific remarks for this feature.)  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code example shows how to use a class template to expose a compiler type trait for a **/clr** compilation. For more information, see [Windows Runtime and Managed Templates](../windows/windows-runtime-and-managed-templates-cpp-component-extensions.md).  \n  \n```  \n// compiler_type_traits.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ntemplate <class T>  \nref struct is_class {  \n   literal bool value = __is_ref_class(T);  \n};  \n  \nref class R {};  \n  \nint main () {  \n   if (is_class<R>::value)  \n      Console::WriteLine(\"R is a ref class\");  \n   else  \n      Console::WriteLine(\"R is not a ref class\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nR is a ref class  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}