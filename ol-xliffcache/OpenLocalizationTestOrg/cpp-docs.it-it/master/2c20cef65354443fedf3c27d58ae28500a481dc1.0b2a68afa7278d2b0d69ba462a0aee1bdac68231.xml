{"nodes":[{"pos":[12,69],"content":"Reading Strings into the OLE DB Provider | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Reading Strings into the OLE DB Provider | Microsoft Docs","pos":[0,57]}]},{"content":"Reading Strings into the OLE DB Provider","pos":[617,657]},{"content":"The <ph id=\"ph1\">`RMyProviderRowset::Execute`</ph> function opens a file and reads strings.","pos":[658,731],"source":"The `RMyProviderRowset::Execute` function opens a file and reads strings."},{"content":"The consumer passes the file name to the provider by calling <bpt id=\"p1\">[</bpt>ICommandText::SetCommandText<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/ms709757.aspx)</ept>.","pos":[732,880],"source":" The consumer passes the file name to the provider by calling [ICommandText::SetCommandText](https://msdn.microsoft.com/en-us/library/ms709757.aspx)."},{"content":"The provider receives the file name and stores it in the member variable <ph id=\"ph1\">`m_szCommandText`</ph>.","pos":[881,972],"source":" The provider receives the file name and stores it in the member variable `m_szCommandText`."},{"content":"reads the file name from <ph id=\"ph1\">`m_szCommandText`</ph>.","pos":[983,1026],"source":" reads the file name from `m_szCommandText`."},{"content":"If the file name is invalid or the file is unavailable, <ph id=\"ph1\">`Execute`</ph> returns an error.","pos":[1027,1110],"source":" If the file name is invalid or the file is unavailable, `Execute` returns an error."},{"content":"Otherwise, it opens the file and calls <ph id=\"ph1\">`fgets`</ph> to retrieve the strings.","pos":[1111,1182],"source":" Otherwise, it opens the file and calls `fgets` to retrieve the strings."},{"content":"For each set of strings it reads, <ph id=\"ph1\">`Execute`</ph> creates an instance of the user record (<ph id=\"ph2\">`CAgentMan`</ph>) and places it into an array.","pos":[1183,1308],"source":" For each set of strings it reads, `Execute` creates an instance of the user record (`CAgentMan`) and places it into an array."},{"content":"If the file cannot be opened, <ph id=\"ph1\">`Execute`</ph> must return <bpt id=\"p1\">**</bpt>DB_E_NOTABLE<ept id=\"p1\">**</ept>.","pos":[1315,1384],"source":"If the file cannot be opened, `Execute` must return **DB_E_NOTABLE**."},{"content":"If it returns <bpt id=\"p1\">**</bpt>E_FAIL<ept id=\"p1\">**</ept> instead, the provider will not work with many consumers and will not pass the OLE DB <bpt id=\"p2\">[</bpt>conformance tests<ept id=\"p2\">](../../data/oledb/testing-your-provider.md)</ept>.","pos":[1385,1558],"source":" If it returns **E_FAIL** instead, the provider will not work with many consumers and will not pass the OLE DB [conformance tests](../../data/oledb/testing-your-provider.md)."},{"content":"Example","pos":[1567,1574]},{"content":"Description","pos":[1584,1595]},{"pos":[1599,1645],"content":"The edited <ph id=\"ph1\">`Execute`</ph> function looks like this:","source":"The edited `Execute` function looks like this:"},{"content":"Code","pos":[1655,1659]},{"content":"See Also","pos":[4059,4067]},{"content":"Implementing the Simple Read-Only Provider","pos":[4072,4114]}],"content":"---\ntitle: \"Reading Strings into the OLE DB Provider | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"OLE DB providers, reading strings into\"\nms.assetid: 517f322c-f37e-4eed-bf5e-dd9a412c2f98\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Reading Strings into the OLE DB Provider\nThe `RMyProviderRowset::Execute` function opens a file and reads strings. The consumer passes the file name to the provider by calling [ICommandText::SetCommandText](https://msdn.microsoft.com/en-us/library/ms709757.aspx). The provider receives the file name and stores it in the member variable `m_szCommandText`. `Execute` reads the file name from `m_szCommandText`. If the file name is invalid or the file is unavailable, `Execute` returns an error. Otherwise, it opens the file and calls `fgets` to retrieve the strings. For each set of strings it reads, `Execute` creates an instance of the user record (`CAgentMan`) and places it into an array.  \n  \n If the file cannot be opened, `Execute` must return **DB_E_NOTABLE**. If it returns **E_FAIL** instead, the provider will not work with many consumers and will not pass the OLE DB [conformance tests](../../data/oledb/testing-your-provider.md).  \n  \n## Example  \n  \n### Description  \n The edited `Execute` function looks like this:  \n  \n### Code  \n  \n```  \n/////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.h  \nclass RMyProviderRowset : public CRowsetImpl< RMyProviderRowset, CAgentMan, CRMyProviderCommand>  \n{  \npublic:  \n    HRESULT Execute(DBPARAMS * pParams, LONG* pcRowsAffected)  \n    {  \n        enum {  \n            sizeOfBuffer = 256,  \n            sizeOfFile = MAX_PATH  \n        };  \n        USES_CONVERSION;  \n        FILE* pFile = NULL;  \n        TCHAR szString[sizeOfBuffer];  \n        TCHAR szFile[sizeOfFile];  \n        size_t nLength;        errcodeerr;  \n  \n        ObjectLock lock(this);  \n  \n        // From a filename, passed in as a command text, scan the file  \n        // placing data in the data array.  \n        if (!m_szCommandText)  \n        {  \n            ATLTRACE(\"No filename specified\");  \n            return E_FAIL;  \n        }  \n  \n        // Open the file  \n        _tcscpy_s(szFile, sizeOfFile, m_szCommandText);  \n        if (szFile[0] == _T('\\0') ||   \n            ((err = fopen_s(&pFile, &szFile[0], \"r\")) == 0))  \n        {  \n            ATLTRACE(\"Could not open file\");  \n            return DB_E_NOTABLE;  \n        }  \n  \n        // Scan and parse the file.  \n        // The file should contain two strings per record  \n        LONG cFiles = 0;  \n        while (fgets(szString, sizeOfBuffer, pFile) != NULL)  \n        {  \n            nLength = strnlen(szString, sizeOfBuffer);  \n            szString[nLength-1] = '\\0';   // Strip off trailing CR/LF  \n            CAgentMan am;  \n            _tcscpy_s(am.szCommand, am.sizeOfCommand, szString);  \n            _tcscpy_s(am.szCommand2, am.sizeOfCommand2, szString);  \n  \n            if (fgets(szString, sizeOfBuffer, pFile) != NULL)  \n            {  \n                nLength = strnlen(szString, sizeOfBuffer);  \n                szString[nLength-1] = '\\0'; // Strip off trailing CR/LF  \n                _tcscpy_s(am.szText, am.sizeOfText, szString);  \n                _tcscpy_s(am.szText2, am.sizeOfText2, szString);  \n            }  \n  \n            am.dwBookmark = ++cFiles;  \n            if (!m_rgRowData.Add(am))  \n            {  \n                ATLTRACE(\"Couldn't add data to array\");  \n                fclose(pFile);  \n                return E_FAIL;  \n            }  \n        }  \n  \n        if (pcRowsAffected != NULL)  \n            *pcRowsAffected = cFiles;  \n        return S_OK;  \n    }  \n}  \n```  \n  \n## See Also  \n [Implementing the Simple Read-Only Provider](../../data/oledb/implementing-the-simple-read-only-provider.md)"}