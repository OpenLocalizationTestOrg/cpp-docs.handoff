{"nodes":[{"pos":[12,58],"content":"How to: Use Events in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Events in C++-CLI | Microsoft Docs","pos":[0,46]}]},{"content":"How to: Use Events in C++/CLI","pos":[605,634]},{"content":"This article shows how to use an interface that declares an event and a function to invoke that event, and the class and event handler that implement the interface.","pos":[635,799]},{"content":"Interface events","pos":[808,824]},{"content":"The following code example adds an event handler, invokes the event—which causes the event handler to write its name to the console—and then removes the event handler.","pos":[828,995]},{"content":"Output","pos":[2032,2038]},{"content":"Custom accessor methods","pos":[2095,2118]},{"content":"The following sample shows how to define an event's behavior when handlers are added or removed, and when an event is raised.","pos":[2122,2247]},{"content":"Output","pos":[4262,4268]},{"content":"Override default access on add, remove, and raise accessors","pos":[4364,4423]},{"content":"This sample shows how to override the default access on the add, remove, and raise events methods:","pos":[4427,4525]},{"content":"Output","pos":[5398,5404]},{"content":"Multiple event handlers","pos":[5441,5464]},{"content":"An event receiver, or any other client code, can add one or more handlers to an event.","pos":[5468,5554]},{"content":"Output","pos":[7290,7296]},{"content":"Static events","pos":[7412,7425]},{"content":"The following sample shows how to define and use static events.","pos":[7429,7492]},{"content":"Output","pos":[9528,9534]},{"content":"Virtual events","pos":[9700,9714]},{"content":"This sample implements virtual, managed events in an interface and class:","pos":[9718,9791]},{"content":"Output","pos":[11599,11605]},{"content":"A simple event cannot be specified to override or hide a base class event.","pos":[11687,11761]},{"content":"You must define all of the event's accessor functions, and then specify the <ph id=\"ph1\">`new`</ph> or <ph id=\"ph2\">`override`</ph> keyword on each accessor function.","pos":[11763,11893],"source":"  You must define all of the event's accessor functions, and then specify the `new` or `override` keyword on each accessor function."},{"content":"Abstract events","pos":[12510,12525]},{"content":"The following sample shows how to implement an abstract event.","pos":[12529,12591]},{"content":"Output","pos":[14212,14218]},{"content":"Raising events that are defined in a different assembly","pos":[14275,14330]},{"content":"An event and event handler can be defined in one assembly, and consumed by another assembly.","pos":[14334,14426]},{"content":"This client code consumes the event:","pos":[14690,14726]},{"content":"Output","pos":[15346,15352]},{"content":"See Also","pos":[15400,15408]},{"content":"event","pos":[15413,15418]}],"content":"---\ntitle: \"How to: Use Events in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"events [C++], accessing in interfaces\"\nms.assetid: fbf452dc-2dd7-4322-adc0-656512d654d1\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Use Events in C++/CLI\nThis article shows how to use an interface that declares an event and a function to invoke that event, and the class and event handler that implement the interface.  \n  \n## Interface events  \n The following code example adds an event handler, invokes the event—which causes the event handler to write its name to the console—and then removes the event handler.  \n  \n```  \n// mcppv2_events2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ndelegate void Del(int, float);  \n  \n// interface that has an event and a function to invoke the event  \ninterface struct I {  \npublic:  \n   event Del ^ E;  \n   void fire(int, float);     \n};  \n  \n// class that implements the interface event and function  \nref class EventSource: public I {  \npublic:  \n   virtual event Del^ E;  \n   virtual void fire(int i, float f) {  \n      E(i, f);  \n   }  \n};  \n  \n// class that defines the event handler  \nref class EventReceiver {  \npublic:  \n   void Handler(int i , float f) {  \n      Console::WriteLine(\"EventReceiver::Handler\");  \n   }  \n};  \n  \nint main () {  \n   I^ es = gcnew EventSource();  \n   EventReceiver^ er = gcnew EventReceiver();  \n  \n   // hook the handler to the event  \n   es->E += gcnew Del(er, &EventReceiver::Handler);  \n  \n   // call the event  \n   es -> fire(1, 3.14);  \n  \n   // unhook the handler from the event  \n   es->E -= gcnew Del(er, &EventReceiver::Handler);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nEventReceiver::Handler  \n```  \n  \n## Custom accessor methods  \n The following sample shows how to define an event's behavior when handlers are added or removed, and when an event is raised.  \n  \n```  \n// mcppv2_events6.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic delegate void MyDel();  \npublic delegate int MyDel2(int, float);  \n  \nref class EventSource {  \npublic:  \n   MyDel ^ pE;  \n   MyDel2 ^ pE2;  \n  \n   event MyDel^ E {  \n      void add(MyDel^ p) {  \n         pE = static_cast<MyDel^> (Delegate::Combine(pE, p));   \n         // cannot refer directly to the event  \n         // E = static_cast<MyDel^> (Delegate::Combine(pE, p));   // error  \n      }  \n  \n      void remove(MyDel^ p) {  \n         pE = static_cast<MyDel^> (Delegate::Remove(pE, p));  \n      }  \n  \n      void raise() {  \n         if (pE != nullptr)  \n            pE->Invoke();  \n      }  \n   }  // E event block  \n  \n   event MyDel2^ E2 {  \n      void add(MyDel2^ p2) {  \n         pE2 = static_cast<MyDel2^> (Delegate::Combine(pE2, p2));   \n      }  \n  \n      void remove(MyDel2^ p2) {  \n         pE2 = static_cast<MyDel2^> (Delegate::Remove(pE2, p2));  \n      }  \n  \n      int raise(int i, float f) {  \n         if (pE2 != nullptr) {  \n            return pE2->Invoke(i, f);  \n         }  \n         return 1;  \n      }  \n   } // E2 event block  \n};  \n  \npublic ref struct EventReceiver {  \n   void H1() {  \n      Console::WriteLine(\"In event handler H1\");  \n   }  \n  \n   int H2(int i, float f) {  \n      Console::WriteLine(\"In event handler H2 with args {0} and {1}\", i.ToString(), f.ToString());  \n      return 0;  \n   }  \n};  \n  \nint main() {  \n   EventSource ^ pE = gcnew EventSource;  \n   EventReceiver ^ pR = gcnew EventReceiver;  \n  \n   // hook event handlers  \n   pE->E += gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 += gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events  \n   pE->E();  \n   pE->E2::raise(1, 2.2);   // call event through scope path  \n  \n   // unhook event handlers  \n   pE->E -= gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 -= gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events, but no handlers  \n   pE->E();  \n   pE->E2::raise(1, 2.5);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nIn event handler H1  \nIn event handler H2 with args 1 and 2.2  \n```  \n  \n## Override default access on add, remove, and raise accessors  \n This sample shows how to override the default access on the add, remove, and raise events methods:  \n  \n```  \n// mcppv2_events3.cpp  \n// compile with: /clr  \npublic delegate void f(int);  \n  \npublic ref struct E {  \n   f ^ _E;  \npublic:  \n   void handler(int i) {  \n      System::Console::WriteLine(i);  \n   }  \n  \n   E() {  \n      _E = nullptr;  \n   }  \n  \n   event f^ Event {  \n      void add(f ^ d) {  \n         _E += d;  \n      }  \n   private:  \n      void remove(f ^ d) {  \n        _E -= d;  \n      }  \n  \n   protected:  \n      void raise(int i) {  \n         if (_E) {  \n            _E->Invoke(i);  \n         }  \n      }  \n   }  \n  \n   // a member function to access all event methods  \n   static void Go() {  \n      E^ pE = gcnew E;  \n      pE->Event += gcnew f(pE, &E::handler);  \n      pE->Event(17);   // prints 17  \n      pE->Event -= gcnew f(pE, &E::handler);  \n      pE->Event(17);   // no output  \n   }  \n};  \n  \nint main() {  \n   E::Go();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n17  \n```  \n  \n## Multiple event handlers  \n An event receiver, or any other client code, can add one or more handlers to an event.  \n  \n```  \n// mcppv2_events4.cpp  \n// compile with: /clr  \nusing namespace System;  \n#include <stdio.h>  \n  \ndelegate void ClickEventHandler(int, double);  \ndelegate void DblClickEventHandler(String^);  \n  \nref class EventSource {  \npublic:  \n   event ClickEventHandler^ OnClick;  \n   event DblClickEventHandler^ OnDblClick;  \n  \n   void FireEvents() {  \n      OnClick(7, 3.14159);  \n      OnDblClick(\"Started\");  \n   }  \n};  \n  \nref struct EventReceiver {  \npublic:  \n   void Handler1(int x, double y) {  \n      System::Console::Write(\"Click(x={0},y={1})\\n\", x, y);  \n   };  \n  \n   void Handler2(String^ s) {  \n      System::Console::Write(\"DblClick(s={0})\\n\", s);  \n   }  \n  \n   void Handler3(String^ s) {  \n      System::Console::WriteLine(\"DblClickAgain(s={0})\\n\", s);  \n   }  \n  \n   void AddHandlers(EventSource^ pES) {  \n      pES->OnClick +=   \n         gcnew ClickEventHandler(this,&EventReceiver::Handler1);  \n      pES->OnDblClick +=   \n         gcnew DblClickEventHandler(this,&EventReceiver::Handler2);  \n      pES->OnDblClick +=   \n         gcnew DblClickEventHandler(this, &EventReceiver::Handler3);  \n   }  \n  \n   void RemoveHandlers(EventSource^ pES) {  \n      pES->OnClick -=   \n         gcnew ClickEventHandler(this, &EventReceiver::Handler1);  \n      pES->OnDblClick -=   \n         gcnew DblClickEventHandler(this, &EventReceiver::Handler2);  \n      pES->OnDblClick -=   \n         gcnew DblClickEventHandler(this, &EventReceiver::Handler3);  \n   }  \n};  \n  \nint main() {  \n   EventSource^ pES = gcnew EventSource;  \n   EventReceiver^ pER = gcnew EventReceiver;  \n  \n   // add handlers  \n   pER->AddHandlers(pES);  \n  \n   pES->FireEvents();  \n  \n   // remove handlers  \n   pER->RemoveHandlers(pES);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nClick(x=7,y=3.14159)  \nDblClick(s=System.Char[])  \nDblClickAgain(s=System.Char[])  \n```  \n  \n## Static events  \n The following sample shows how to define and use static events.  \n  \n```  \n// mcppv2_events7.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic delegate void MyDel();  \npublic delegate int MyDel2(int, float);  \n  \nref class EventSource {  \npublic:  \n   static MyDel ^ psE;  \n   static event MyDel2 ^ E2;   // event keyword, compiler generates add,   \n                               // remove, and Invoke  \n  \n   static event MyDel ^ E {  \n      static void add(MyDel ^ p) {  \n         psE = static_cast<MyDel^> (Delegate::Combine(psE, p));  \n      }  \n  \n      static void remove(MyDel^ p) {  \n         psE = static_cast<MyDel^> (Delegate::Remove(psE, p));  \n      }  \n  \n      static void raise() {  \n         if (psE != nullptr)   //psE!=0 -> C2679, use nullptr  \n            psE->Invoke();   \n      }  \n   }  \n  \n   static int Fire_E2(int i, float f) {  \n      return E2(i, f);  \n   }  \n};  \n  \npublic ref struct EventReceiver {  \n   void H1() {  \n      Console::WriteLine(\"In event handler H1\");  \n   }  \n  \n   int H2(int i, float f) {  \n      Console::WriteLine(\"In event handler H2 with args {0} and {1}\", i.ToString(), f.ToString());  \n      return 0;  \n   }  \n};  \n  \nint main() {  \n   EventSource^ pE = gcnew EventSource;  \n   EventReceiver^ pR = gcnew EventReceiver;  \n  \n   // Called with \"this\"  \n   // hook event handlers  \n   pE->E += gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 += gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events  \n   pE->E();  \n   pE->Fire_E2(11, 11.11);  \n  \n   // unhook event handlers  \n   pE->E -= gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 -= gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // Not called with \"this\"  \n   // hook event handler  \n   EventSource::E += gcnew MyDel(pR, &EventReceiver::H1);  \n   EventSource::E2 += gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events  \n   EventSource::E();  \n   EventSource::Fire_E2(22, 22.22);  \n  \n   // unhook event handlers  \n   EventSource::E -= gcnew MyDel(pR, &EventReceiver::H1);  \n   EventSource::E2 -= gcnew MyDel2(pR, &EventReceiver::H2);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nIn event handler H1  \nIn event handler H2 with args 11 and 11.11  \nIn event handler H1  \nIn event handler H2 with args 22 and 22.22  \n```  \n  \n## Virtual events  \n This sample implements virtual, managed events in an interface and class:  \n  \n```  \n// mcppv2_events5.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic delegate void MyDel();  \npublic delegate int MyDel2(int, float);  \n  \n// managed class that has a virtual event  \nref class IEFace {  \npublic:  \n   virtual event MyDel ^ E;   // declares three accessors (add, remove, and raise)  \n};  \n  \n// managed interface that has a virtual event  \npublic interface struct IEFace2 {  \npublic:  \n   event MyDel2 ^ E2;   // declares two accessors (add and remove)  \n};  \n  \n// implement virtual events  \nref class EventSource : public IEFace, public IEFace2 {  \npublic:  \n   virtual event MyDel2 ^ E2;  \n  \n   void Fire_E() {  \n      E();  \n   }  \n  \n   int Fire_E2(int i, float f) {  \n      try {  \n         return E2(i, f);  \n      }  \n      catch(System::NullReferenceException^) {  \n         return 0;   // no handlers  \n      }  \n   }  \n};  \n  \n// class to hold event handlers, the event receiver  \npublic ref struct EventReceiver {  \n   // first handler  \n   void H1() {  \n      Console::WriteLine(\"In handler H1\");  \n   }  \n  \n   // second handler  \n   int H2(int i, float f) {  \n      Console::WriteLine(\"In handler H2 with args {0} and {1}\", i.ToString(), f.ToString());  \n      return 0;  \n   }  \n};  \n  \nint main() {  \n   EventSource ^ pE = gcnew EventSource;  \n   EventReceiver ^ pR = gcnew EventReceiver;  \n  \n   // add event handlers  \n   pE->E += gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 += gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events  \n   pE->Fire_E();  \n   pE->Fire_E2(1, 2.2);  \n  \n   // remove event handlers  \n   pE->E -= gcnew MyDel(pR, &EventReceiver::H1);  \n   pE->E2 -= gcnew MyDel2(pR, &EventReceiver::H2);  \n  \n   // raise events, but no handlers; so, no effect  \n   pE->Fire_E();  \n   pE->Fire_E2(1, 2.5);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nIn handler H1  \nIn handler H2 with args 1 and 2.2  \n```  \n  \n A simple event cannot be specified to override or hide a base class event.  You must define all of the event's accessor functions, and then specify the `new` or `override` keyword on each accessor function.  \n  \n```  \n// mcppv2_events5_a.cpp  \n// compile with: /clr /c  \ndelegate void Del();  \n  \nref struct A {  \n   virtual event Del ^E;  \n   virtual event Del ^E2;  \n};  \n  \nref struct B : A {  \n   virtual event Del ^E override;   // C3797  \n   virtual event Del ^E2 new;   // C3797  \n};  \n  \nref struct C : B {  \n   virtual event Del ^E {   // OK  \n      void raise() override {}  \n      void add(Del ^) override {}  \n      void remove(Del^) override {}  \n   }  \n  \n   virtual event Del ^E2 {   // OK  \n      void raise() new {}  \n      void add(Del ^) new {}  \n      void remove(Del^) new {}  \n   }  \n};  \n```  \n  \n## Abstract events  \n The following sample shows how to implement an abstract event.  \n  \n```  \n// mcppv2_events10.cpp  \n// compile with: /clr /W1  \nusing namespace System;  \npublic delegate void Del();  \npublic delegate void Del2(String^ s);  \n  \ninterface struct IEvent {  \npublic:  \n   // in this case, no raised method is defined  \n   event Del^ Event1;  \n  \n   event Del2^ Event2 {  \n   public:  \n      void add(Del2^ _d);  \n      void remove(Del2^ _d);  \n      void raise(String^ s);  \n   }  \n  \n   void fire();  \n};  \n  \nref class EventSource: public IEvent {  \npublic:  \n   virtual event Del^ Event1;  \n   event Del2^ Event2 {  \n      virtual void add(Del2^ _d) {  \n         d = safe_cast<Del2^>(System::Delegate::Combine(d, _d));  \n      }  \n  \n      virtual void remove(Del2^ _d) {  \n         d = safe_cast<Del2^>(System::Delegate::Remove(d, _d));  \n      }  \n  \n      virtual void raise(String^ s) {  \n         if (d) {  \n            d->Invoke(s);  \n         }  \n      }  \n   }  \n  \n   virtual void fire() {  \n      return Event1();  \n   }  \n  \nprivate:  \n   Del2^ d;  \n};  \n  \nref class EventReceiver {  \npublic:  \n   void func() {  \n      Console::WriteLine(\"hi\");  \n   }  \n  \n   void func(String^ str) {  \n      Console::WriteLine(str);  \n   }  \n};  \n  \nint main () {  \n   IEvent^ es = gcnew EventSource;  \n   EventReceiver^ er = gcnew EventReceiver;  \n   es->Event1 += gcnew Del(er, &EventReceiver::func);  \n   es->Event2 += gcnew Del2(er, &EventReceiver::func);  \n  \n   es->fire();  \n   es->Event2(\"hello from Event2\");  \n   es->Event1 -= gcnew Del(er, &EventReceiver::func);  \n   es->Event2 -= gcnew Del2(er, &EventReceiver::func);  \n   es->Event2(\"hello from Event2\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nhi  \nhello from Event2  \n```  \n  \n## Raising events that are defined in a different assembly  \n An event and event handler can be defined in one assembly, and consumed by another assembly.  \n  \n```  \n// mcppv2_events8.cpp  \n// compile with: /LD /clr  \nusing namespace System;  \n  \npublic delegate void Del(String^ s);  \n  \npublic ref class Source {  \npublic:  \n   event Del^ Event;  \n   void Fire(String^ s) {  \n      Event(s);  \n   }  \n};  \n```  \n  \n This client code consumes the event:  \n  \n```  \n// mcppv2_events9.cpp  \n// compile with: /clr  \n#using \"mcppv2_events8.dll\"  \nusing namespace System;  \n  \nref class Receiver {  \npublic:  \n   void Handler(String^ s) {  \n      Console::WriteLine(s);  \n   }  \n};  \n  \nint main() {  \n   Source^ src = gcnew Source;  \n   Receiver^ rc1 = gcnew Receiver;  \n   Receiver^ rc2 = gcnew Receiver;  \n   src -> Event += gcnew Del(rc1, &Receiver::Handler);  \n   src -> Event += gcnew Del(rc2, &Receiver::Handler);  \n   src->Fire(\"hello\");  \n   src -> Event -= gcnew Del(rc1, &Receiver::Handler);  \n   src -> Event -= gcnew Del(rc2, &Receiver::Handler);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nhello  \nhello  \n```  \n  \n## See Also  \n [event](../windows/event-cpp-component-extensions.md)"}