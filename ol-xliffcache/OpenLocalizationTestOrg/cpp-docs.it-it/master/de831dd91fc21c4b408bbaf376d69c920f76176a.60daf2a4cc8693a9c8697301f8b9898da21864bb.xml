{"nodes":[{"pos":[12,68],"content":"Rvalue Reference Declarator: &amp;&amp; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Rvalue Reference Declarator: <ph id=\"ph1\">&amp;amp;&amp;amp;</ph> | Microsoft Docs","pos":[0,56],"source":"Rvalue Reference Declarator: &amp;&amp; | Microsoft Docs"}]},{"content":"Rvalue Reference Declarator:","pos":[642,670]},{"content":"Holds a reference to an rvalue expression.","pos":[682,724]},{"content":"Syntax","pos":[733,739]},{"content":"Remarks","pos":[795,802]},{"content":"Rvalue references enable you to distinguish an lvalue from an rvalue.","pos":[806,875]},{"content":"Lvalue references and rvalue references are syntactically and semantically similar, but they follow somewhat different rules.","pos":[876,1001]},{"content":"For more information about lvalues and rvalues, see <bpt id=\"p1\">[</bpt>Lvalues and Rvalues<ept id=\"p1\">](../cpp/lvalues-and-rvalues-visual-cpp.md)</ept>.","pos":[1002,1118],"source":" For more information about lvalues and rvalues, see [Lvalues and Rvalues](../cpp/lvalues-and-rvalues-visual-cpp.md)."},{"content":"For more information about lvalue references, see <bpt id=\"p1\">[</bpt>Lvalue Reference Declarator: &amp;<ept id=\"p1\">](../cpp/lvalue-reference-declarator-amp.md)</ept>.","pos":[1119,1245],"source":" For more information about lvalue references, see [Lvalue Reference Declarator: &](../cpp/lvalue-reference-declarator-amp.md)."},{"pos":[1252,1378],"content":"The following sections describe how rvalue references support the implementation of <bpt id=\"p1\">*</bpt>move semantics<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>perfect forwarding<ept id=\"p2\">*</ept>.","source":"The following sections describe how rvalue references support the implementation of *move semantics* and *perfect forwarding*."},{"content":"Move Semantics","pos":[1387,1401]},{"content":"Rvalue references support the implementation of <bpt id=\"p1\">*</bpt>move semantics<ept id=\"p1\">*</ept>, which can significantly increase the performance of your applications.","pos":[1405,1541],"source":"Rvalue references support the implementation of *move semantics*, which can significantly increase the performance of your applications."},{"content":"Move semantics enables you to write code that transfers resources (such as dynamically allocated memory) from one object to another.","pos":[1542,1674]},{"content":"Move semantics works because it enables resources to be transferred from temporary objects that cannot be referenced elsewhere in the program.","pos":[1675,1817]},{"content":"To implement move semantics, you typically provide a <bpt id=\"p1\">*</bpt>move constructor,<ept id=\"p1\">*</ept> and optionally a move assignment operator (<ph id=\"ph1\">`operator=`</ph>), to your class.","pos":[1824,1968],"source":"To implement move semantics, you typically provide a *move constructor,* and optionally a move assignment operator (`operator=`), to your class."},{"content":"Copy and assignment operations whose sources are rvalues then automatically take advantage of move semantics.","pos":[1969,2078]},{"content":"Unlike the default copy constructor, the compiler does not provide a default move constructor.","pos":[2079,2173]},{"content":"For more information about how to write a move constructor and how to use it in your application, see <bpt id=\"p1\">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id=\"p1\">](../cpp/move-constructors-and-move-assignment-operators-cpp.md)</ept>.","pos":[2174,2395],"source":" For more information about how to write a move constructor and how to use it in your application, see [Move Constructors and Move Assignment Operators (C++)](../cpp/move-constructors-and-move-assignment-operators-cpp.md)."},{"content":"You can also overload ordinary functions and operators to take advantage of move semantics.","pos":[2402,2493]},{"content":"introduces move semantics into the Standard Template Library (STL).","pos":[2561,2628]},{"content":"For example, the <ph id=\"ph1\">`string`</ph> class implements operations that perform move semantics.","pos":[2629,2711],"source":" For example, the `string` class implements operations that perform move semantics."},{"content":"Consider the following example that concatenates several strings and prints the result:","pos":[2712,2799]},{"content":"Before <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph>, each call to <ph id=\"ph2\">`operator+`</ph> allocates and returns a new temporary <ph id=\"ph3\">`string`</ph> object (an rvalue).","pos":[3037,3203],"source":"Before [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], each call to `operator+` allocates and returns a new temporary `string` object (an rvalue)."},{"content":"cannot append one string to the other because it does not know whether the source strings are lvalues or rvalues.","pos":[3216,3329]},{"content":"If the source strings are both lvalues, they might be referenced elsewhere in the program and therefore must not be modified.","pos":[3330,3455]},{"content":"By using rvalue references, <ph id=\"ph1\">`operator+`</ph> can be modified to take rvalues, which cannot be referenced elsewhere in the program.","pos":[3456,3581],"source":" By using rvalue references, `operator+` can be modified to take rvalues, which cannot be referenced elsewhere in the program."},{"content":"Therefore, <ph id=\"ph1\">`operator+`</ph> can now append one string to another.","pos":[3582,3642],"source":" Therefore, `operator+` can now append one string to another."},{"content":"This can significantly reduce the number of dynamic memory allocations that the <ph id=\"ph1\">`string`</ph> class must perform.","pos":[3643,3751],"source":" This can significantly reduce the number of dynamic memory allocations that the `string` class must perform."},{"content":"For more information about the <ph id=\"ph1\">`string`</ph> class, see <bpt id=\"p1\">[</bpt>basic_string Class<ept id=\"p1\">](../standard-library/basic-string-class.md)</ept>.","pos":[3752,3867],"source":" For more information about the `string` class, see [basic_string Class](../standard-library/basic-string-class.md)."},{"content":"Move semantics also helps when the compiler cannot use Return Value Optimization (RVO) or Named Return Value Optimization (NRVO).","pos":[3874,4003]},{"content":"In these cases, the compiler calls the move constructor if the type defines it.","pos":[4004,4083]},{"content":"For more information about Named Return Value Optimization, see <bpt id=\"p1\">[</bpt>Named Return Value Optimization in Visual C++ 2005<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=131571)</ept>.","pos":[4084,4248],"source":" For more information about Named Return Value Optimization, see [Named Return Value Optimization in Visual C++ 2005](http://go.microsoft.com/fwlink/?LinkId=131571)."},{"content":"To better understand move semantics, consider the example of inserting an element into a <ph id=\"ph1\">`vector`</ph> object.","pos":[4255,4360],"source":"To better understand move semantics, consider the example of inserting an element into a `vector` object."},{"content":"If the capacity of the <ph id=\"ph1\">`vector`</ph> object is exceeded, the <ph id=\"ph2\">`vector`</ph> object must reallocate memory for its elements and then copy each element to another memory location to make room for the inserted element.","pos":[4361,4565],"source":" If the capacity of the `vector` object is exceeded, the `vector` object must reallocate memory for its elements and then copy each element to another memory location to make room for the inserted element."},{"content":"When an insertion operation copies an element, it creates a new element, calls the copy constructor to copy the data from the previous element to the new element, and then destroys the previous element.","pos":[4566,4768]},{"content":"Move semantics enables you to move objects directly without having to perform expensive memory allocation and copy operations.","pos":[4769,4895]},{"pos":[4902,5036],"content":"To take advantage of move semantics in the <ph id=\"ph1\">`vector`</ph> example, you can write a move constructor to move data from one object to another.","source":"To take advantage of move semantics in the `vector` example, you can write a move constructor to move data from one object to another."},{"pos":[5043,5271],"content":"For more information about the introduction of move semantics into the STL in <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph>, see <bpt id=\"p1\">[</bpt>C++ Standard Library<ept id=\"p1\">](../standard-library/cpp-standard-library-reference.md)</ept>.","source":"For more information about the introduction of move semantics into the STL in [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], see [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)."},{"content":"Perfect Forwarding","pos":[5280,5298]},{"content":"Perfect forwarding reduces the need for overloaded functions and helps avoid the forwarding problem.","pos":[5302,5402]},{"content":"The <bpt id=\"p1\">*</bpt>forwarding problem<ept id=\"p1\">*</ept> can occur when you write a generic function that takes references as its parameters and it passes (or <bpt id=\"p2\">*</bpt>forwards<ept id=\"p2\">*</ept>) these parameters to another function.","pos":[5403,5579],"source":" The *forwarding problem* can occur when you write a generic function that takes references as its parameters and it passes (or *forwards*) these parameters to another function."},{"content":"For example, if the generic function takes a parameter of type <ph id=\"ph1\">`const T&amp;`</ph>, then the called function cannot modify the value of that parameter.","pos":[5580,5722],"source":" For example, if the generic function takes a parameter of type `const T&`, then the called function cannot modify the value of that parameter."},{"content":"If the generic function takes a parameter of type <ph id=\"ph1\">`T&amp;`</ph>, then the function cannot be called by using an rvalue (such as a temporary object or integer literal).","pos":[5723,5881],"source":" If the generic function takes a parameter of type `T&`, then the function cannot be called by using an rvalue (such as a temporary object or integer literal)."},{"content":"Ordinarily, to solve this problem, you must provide overloaded versions of the generic function that take both <ph id=\"ph1\">`T&amp;`</ph> and <ph id=\"ph2\">`const T&amp;`</ph> for each of its parameters.","pos":[5888,6046],"source":"Ordinarily, to solve this problem, you must provide overloaded versions of the generic function that take both `T&` and `const T&` for each of its parameters."},{"content":"As a result, the number of overloaded functions increases exponentially with the number of parameters.","pos":[6047,6149]},{"content":"Rvalue references enable you to write one version of a function that accepts arbitrary arguments and forwards them to another function as if the other function had been called directly.","pos":[6150,6335]},{"content":"Consider the following example that declares four types, <ph id=\"ph1\">`W`</ph>, <ph id=\"ph2\">`X`</ph>, <ph id=\"ph3\">`Y`</ph>, and <ph id=\"ph4\">`Z`</ph>.","pos":[6342,6422],"source":"Consider the following example that declares four types, `W`, `X`, `Y`, and `Z`."},{"content":"The constructor for each type takes a different combination of <ph id=\"ph1\">`const`</ph> and non-<ph id=\"ph2\">`const`</ph> lvalue references as its parameters.","pos":[6423,6546],"source":" The constructor for each type takes a different combination of `const` and non-`const` lvalue references as its parameters."},{"content":"Suppose you want to write a generic function that generates objects.","pos":[6769,6837]},{"content":"The following example shows one way to write this function:","pos":[6838,6897]},{"pos":[7033,7100],"content":"The following example shows a valid call to the <ph id=\"ph1\">`factory`</ph> function:","source":"The following example shows a valid call to the `factory` function:"},{"pos":[7170,7372],"content":"However, the following example does not contain a valid call to the <ph id=\"ph1\">`factory`</ph> function because <ph id=\"ph2\">`factory`</ph> takes lvalue references that are modifiable as its parameters, but it is called by using rvalues:","source":"However, the following example does not contain a valid call to the `factory` function because `factory` takes lvalue references that are modifiable as its parameters, but it is called by using rvalues:"},{"content":"Ordinarily, to solve this problem, you must create an overloaded version of the <ph id=\"ph1\">`factory`</ph> function for every combination of <ph id=\"ph2\">`A&amp;`</ph> and <ph id=\"ph3\">`const A&amp;`</ph> parameters.","pos":[7422,7577],"source":"Ordinarily, to solve this problem, you must create an overloaded version of the `factory` function for every combination of `A&` and `const A&` parameters."},{"content":"Rvalue references enable you to write one version of the <ph id=\"ph1\">`factory`</ph> function, as shown in the following example:","pos":[7578,7689],"source":" Rvalue references enable you to write one version of the `factory` function, as shown in the following example:"},{"content":"This example uses rvalue references as the parameters to the <ph id=\"ph1\">`factory`</ph> function.","pos":[7863,7943],"source":"This example uses rvalue references as the parameters to the `factory` function."},{"content":"The purpose of the <bpt id=\"p1\">[</bpt>std::forward<ept id=\"p1\">](../standard-library/utility-functions.md#forward)</ept> function is to forward the parameters of the factory function to the constructor of the template class.","pos":[7944,8131],"source":" The purpose of the [std::forward](../standard-library/utility-functions.md#forward) function is to forward the parameters of the factory function to the constructor of the template class."},{"content":"The following example shows the <ph id=\"ph1\">`main`</ph> function that uses the revised <ph id=\"ph2\">`factory`</ph> function to create instances of the <ph id=\"ph3\">`W`</ph>, <ph id=\"ph4\">`X`</ph>, <ph id=\"ph5\">`Y`</ph>, and <ph id=\"ph6\">`Z`</ph> classes.","pos":[8138,8285],"source":"The following example shows the `main` function that uses the revised `factory` function to create instances of the `W`, `X`, `Y`, and `Z` classes."},{"content":"The revised <ph id=\"ph1\">`factory`</ph> function forwards its parameters (either lvalues or rvalues) to the appropriate class constructor.","pos":[8286,8406],"source":" The revised `factory` function forwards its parameters (either lvalues or rvalues) to the appropriate class constructor."},{"content":"Additional Properties of Rvalue References","pos":[8665,8707]},{"content":"You can overload a function to take an lvalue reference and an rvalue reference.","pos":[8713,8793]},{"content":"By overloading a function to take a <ph id=\"ph1\">`const`</ph> lvalue reference or an rvalue reference, you can write code that distinguishes between non-modifiable objects (lvalues) and modifiable temporary values (rvalues).","pos":[8802,9008],"source":"By overloading a function to take a `const` lvalue reference or an rvalue reference, you can write code that distinguishes between non-modifiable objects (lvalues) and modifiable temporary values (rvalues)."},{"content":"You can pass an object to a function that takes an rvalue reference unless the object is marked as <ph id=\"ph1\">`const`</ph>.","pos":[9009,9116],"source":" You can pass an object to a function that takes an rvalue reference unless the object is marked as `const`."},{"content":"The following example shows the function <ph id=\"ph1\">`f`</ph>, which is overloaded to take an lvalue reference and an rvalue reference.","pos":[9117,9235],"source":" The following example shows the function `f`, which is overloaded to take an lvalue reference and an rvalue reference."},{"content":"The <ph id=\"ph1\">`main`</ph> function calls <ph id=\"ph2\">`f`</ph> with both lvalues and an rvalue.","pos":[9236,9298],"source":" The `main` function calls `f` with both lvalues and an rvalue."},{"content":"This example produces the following output:","pos":[9881,9924]},{"content":"In this example, the first call to <ph id=\"ph1\">`f`</ph> passes a local variable (an lvalue) as its argument.","pos":[10078,10169],"source":"In this example, the first call to `f` passes a local variable (an lvalue) as its argument."},{"content":"The second call to <ph id=\"ph1\">`f`</ph> passes a temporary object as its argument.","pos":[10170,10235],"source":" The second call to `f` passes a temporary object as its argument."},{"content":"Because the temporary object cannot be referenced elsewhere in the program, the call binds to the overloaded version of <ph id=\"ph1\">`f`</ph> that takes an rvalue reference, which is free to modify the object.","pos":[10236,10427],"source":" Because the temporary object cannot be referenced elsewhere in the program, the call binds to the overloaded version of `f` that takes an rvalue reference, which is free to modify the object."},{"content":"The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue.","pos":[10436,10539]},{"content":"When you write a function that takes an rvalue reference as its parameter, that parameter is treated as an lvalue in the body of the function.","pos":[10548,10690]},{"content":"The compiler treats a named rvalue reference as an lvalue because a named object can be referenced by several parts of a program; it would be dangerous to allow multiple parts of a program to modify or remove resources from that object.","pos":[10691,10927]},{"content":"For example, if multiple parts of a program try to transfer resources from the same object, only the first part will successfully transfer the resource.","pos":[10928,11080]},{"content":"The following example shows the function <ph id=\"ph1\">`g`</ph>, which is overloaded to take an lvalue reference and an rvalue reference.","pos":[11087,11205],"source":"The following example shows the function `g`, which is overloaded to take an lvalue reference and an rvalue reference."},{"content":"The function <ph id=\"ph1\">`f`</ph> takes an rvalue reference as its parameter (a named rvalue reference) and returns an rvalue reference (an unnamed rvalue reference).","pos":[11206,11355],"source":" The function `f` takes an rvalue reference as its parameter (a named rvalue reference) and returns an rvalue reference (an unnamed rvalue reference)."},{"content":"In the call to <ph id=\"ph1\">`g`</ph> from <ph id=\"ph2\">`f`</ph>, overload resolution selects the version of <ph id=\"ph3\">`g`</ph> that takes an lvalue reference because the body of <ph id=\"ph4\">`f`</ph> treats its parameter as an lvalue.","pos":[11356,11521],"source":" In the call to `g` from `f`, overload resolution selects the version of `g` that takes an lvalue reference because the body of `f` treats its parameter as an lvalue."},{"content":"In the call to <ph id=\"ph1\">`g`</ph> from <ph id=\"ph2\">`main`</ph>, overload resolution selects the version of <ph id=\"ph3\">`g`</ph> that takes an rvalue reference because <ph id=\"ph4\">`f`</ph> returns an rvalue reference.","pos":[11522,11672],"source":" In the call to `g` from `main`, overload resolution selects the version of `g` that takes an rvalue reference because `f` returns an rvalue reference."},{"content":"This example produces the following output:","pos":[12221,12264]},{"content":"In this example, the <ph id=\"ph1\">`main`</ph> function passes an rvalue to <ph id=\"ph2\">`f`</ph>.","pos":[12337,12398],"source":"In this example, the `main` function passes an rvalue to `f`."},{"content":"The body of <ph id=\"ph1\">`f`</ph> treats its named parameter as an lvalue.","pos":[12399,12455],"source":" The body of `f` treats its named parameter as an lvalue."},{"content":"The call from <ph id=\"ph1\">`f`</ph> to <ph id=\"ph2\">`g`</ph> binds the parameter to an lvalue reference (the first overloaded version of <ph id=\"ph3\">`g`</ph>).","pos":[12456,12562],"source":" The call from `f` to `g` binds the parameter to an lvalue reference (the first overloaded version of `g`)."},{"content":"You can cast an lvalue to an rvalue reference.","pos":[12574,12620]},{"content":"The STL <bpt id=\"p1\">[</bpt>std::move<ept id=\"p1\">](../standard-library/utility-functions.md#move)</ept> function enables you to convert an object to an rvalue reference to that object.","pos":[12629,12776],"source":"The STL [std::move](../standard-library/utility-functions.md#move) function enables you to convert an object to an rvalue reference to that object."},{"content":"Alternatively, you can use the <ph id=\"ph1\">`static_cast`</ph> keyword to cast an lvalue to an rvalue reference, as shown in the following example:","pos":[12777,12906],"source":" Alternatively, you can use the `static_cast` keyword to cast an lvalue to an rvalue reference, as shown in the following example:"},{"content":"This example produces the following output:","pos":[13426,13469]},{"content":"Function templates deduce their template argument types and then use reference collapsing rules.","pos":[13544,13640]},{"content":"It is common to write a function template that passes (or <bpt id=\"p1\">*</bpt>forwards<ept id=\"p1\">*</ept>) its parameters to another function.","pos":[13649,13754],"source":"It is common to write a function template that passes (or *forwards*) its parameters to another function."},{"content":"It is important to understand how template type deduction works for function templates that take rvalue references.","pos":[13755,13870]},{"content":"If the function argument is an rvalue, the compiler deduces the argument to be an rvalue reference.","pos":[13877,13976]},{"content":"For example, if you pass an rvalue reference to an object of type <ph id=\"ph1\">`X`</ph> to a template function that takes type <ph id=\"ph2\">`T&amp;&amp;`</ph> as its parameter, template argument deduction deduces <ph id=\"ph3\">`T`</ph> to be <ph id=\"ph4\">`X`</ph>.","pos":[13977,14160],"source":" For example, if you pass an rvalue reference to an object of type `X` to a template function that takes type `T&&` as its parameter, template argument deduction deduces `T` to be `X`."},{"content":"Therefore, the parameter has type <ph id=\"ph1\">`X&amp;&amp;`</ph>.","pos":[14161,14201],"source":" Therefore, the parameter has type `X&&`."},{"content":"If the function argument is an lvalue or <ph id=\"ph1\">`const`</ph> lvalue, the compiler deduces its type to be an lvalue reference or <ph id=\"ph2\">`const`</ph> lvalue reference of that type.","pos":[14202,14356],"source":" If the function argument is an lvalue or `const` lvalue, the compiler deduces its type to be an lvalue reference or `const` lvalue reference of that type."},{"content":"The following example declares one structure template and then specializes it for various reference types.","pos":[14363,14469]},{"content":"The <ph id=\"ph1\">`print_type_and_value`</ph> function takes an rvalue reference as its parameter and forwards it to the appropriate specialized version of the <ph id=\"ph2\">`S::print`</ph> method.","pos":[14470,14629],"source":" The `print_type_and_value` function takes an rvalue reference as its parameter and forwards it to the appropriate specialized version of the `S::print` method."},{"content":"The <ph id=\"ph1\">`main`</ph> function demonstrates the various ways to call the <ph id=\"ph2\">`S::print`</ph> method.","pos":[14630,14710],"source":" The `main` function demonstrates the various ways to call the `S::print` method."},{"content":"This example produces the following output:","pos":[16854,16897]},{"content":"To resolve each call to the <ph id=\"ph1\">`print_type_and_value`</ph> function, the compiler first performs template argument deduction.","pos":[17011,17128],"source":"To resolve each call to the `print_type_and_value` function, the compiler first performs template argument deduction."},{"content":"The compiler then applies reference collapsing rules when it substitutes the deduced template arguments for the parameter types.","pos":[17129,17257]},{"content":"For example, passing the local variable <ph id=\"ph1\">`s1`</ph> to the <ph id=\"ph2\">`print_type_and_value`</ph> function causes the compiler to produce the following function signature:","pos":[17258,17406],"source":" For example, passing the local variable `s1` to the `print_type_and_value` function causes the compiler to produce the following function signature:"},{"content":"The compiler uses reference collapsing rules to reduce the signature to the following:","pos":[17474,17560]},{"pos":[17625,17765],"content":"This version of the <ph id=\"ph1\">`print_type_and_value`</ph> function then forwards its parameter to the correct specialized version of the <ph id=\"ph2\">`S::print`</ph> method.","source":"This version of the `print_type_and_value` function then forwards its parameter to the correct specialized version of the `S::print` method."},{"content":"The following table summarizes the reference collapsing rules for template argument type deduction:","pos":[17772,17871]},{"content":"Expanded type","pos":[17892,17905]},{"content":"Collapsed type","pos":[17906,17920]},{"content":"Template argument deduction is an important element of implementing perfect forwarding.","pos":[17997,18084]},{"content":"The section Perfect Forwarding, which is presented earlier in this topic, describes perfect forwarding in more detail.","pos":[18085,18203]},{"content":"Summary","pos":[18212,18219]},{"content":"Rvalue references distinguish lvalues from rvalues.","pos":[18223,18274]},{"content":"They can help you improve the performance of your applications by eliminating the need for unnecessary memory allocations and copy operations.","pos":[18275,18417]},{"content":"They also enable you to write one version of a function that accepts arbitrary arguments and forwards them to another function as if the other function had been called directly.","pos":[18418,18595]},{"content":"See Also","pos":[18604,18612]},{"content":"Expressions with Unary Operators","pos":[18617,18649]},{"content":"Lvalue Reference Declarator: &amp;","pos":[18700,18730],"source":"Lvalue Reference Declarator: &"},{"content":"Lvalues and Rvalues","pos":[18780,18799]},{"content":"Move Constructors and Move Assignment Operators (C++)","pos":[18848,18901]},{"content":"C++ Standard Library","pos":[18971,18991]}],"content":"---\ntitle: \"Rvalue Reference Declarator: &amp;&amp; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"&&\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"&& rvalue reference declarator\"\nms.assetid: eab0ce3a-c5a3-4992-aa70-6a8ab1f7491d\ncaps.latest.revision: 22\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Rvalue Reference Declarator: &amp;&amp;\nHolds a reference to an rvalue expression.  \n  \n## Syntax  \n  \n```  \n  \ntype-id && cast-expression  \n```  \n  \n## Remarks  \n Rvalue references enable you to distinguish an lvalue from an rvalue. Lvalue references and rvalue references are syntactically and semantically similar, but they follow somewhat different rules. For more information about lvalues and rvalues, see [Lvalues and Rvalues](../cpp/lvalues-and-rvalues-visual-cpp.md). For more information about lvalue references, see [Lvalue Reference Declarator: &](../cpp/lvalue-reference-declarator-amp.md).  \n  \n The following sections describe how rvalue references support the implementation of *move semantics* and *perfect forwarding*.  \n  \n## Move Semantics  \n Rvalue references support the implementation of *move semantics*, which can significantly increase the performance of your applications. Move semantics enables you to write code that transfers resources (such as dynamically allocated memory) from one object to another. Move semantics works because it enables resources to be transferred from temporary objects that cannot be referenced elsewhere in the program.  \n  \n To implement move semantics, you typically provide a *move constructor,* and optionally a move assignment operator (`operator=`), to your class. Copy and assignment operations whose sources are rvalues then automatically take advantage of move semantics. Unlike the default copy constructor, the compiler does not provide a default move constructor. For more information about how to write a move constructor and how to use it in your application, see [Move Constructors and Move Assignment Operators (C++)](../cpp/move-constructors-and-move-assignment-operators-cpp.md).  \n  \n You can also overload ordinary functions and operators to take advantage of move semantics. [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)] introduces move semantics into the Standard Template Library (STL). For example, the `string` class implements operations that perform move semantics. Consider the following example that concatenates several strings and prints the result:  \n  \n```  \n// string_concatenation.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <string>  \nusing namespace std;  \n  \nint main()  \n{  \n   string s = string(\"h\") + \"e\" + \"ll\" + \"o\";  \n   cout << s << endl;  \n}  \n```  \n  \n Before [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], each call to `operator+` allocates and returns a new temporary `string` object (an rvalue). `operator+` cannot append one string to the other because it does not know whether the source strings are lvalues or rvalues. If the source strings are both lvalues, they might be referenced elsewhere in the program and therefore must not be modified. By using rvalue references, `operator+` can be modified to take rvalues, which cannot be referenced elsewhere in the program. Therefore, `operator+` can now append one string to another. This can significantly reduce the number of dynamic memory allocations that the `string` class must perform. For more information about the `string` class, see [basic_string Class](../standard-library/basic-string-class.md).  \n  \n Move semantics also helps when the compiler cannot use Return Value Optimization (RVO) or Named Return Value Optimization (NRVO). In these cases, the compiler calls the move constructor if the type defines it. For more information about Named Return Value Optimization, see [Named Return Value Optimization in Visual C++ 2005](http://go.microsoft.com/fwlink/?LinkId=131571).  \n  \n To better understand move semantics, consider the example of inserting an element into a `vector` object. If the capacity of the `vector` object is exceeded, the `vector` object must reallocate memory for its elements and then copy each element to another memory location to make room for the inserted element. When an insertion operation copies an element, it creates a new element, calls the copy constructor to copy the data from the previous element to the new element, and then destroys the previous element. Move semantics enables you to move objects directly without having to perform expensive memory allocation and copy operations.  \n  \n To take advantage of move semantics in the `vector` example, you can write a move constructor to move data from one object to another.  \n  \n For more information about the introduction of move semantics into the STL in [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], see [C++ Standard Library](../standard-library/cpp-standard-library-reference.md).  \n  \n## Perfect Forwarding  \n Perfect forwarding reduces the need for overloaded functions and helps avoid the forwarding problem. The *forwarding problem* can occur when you write a generic function that takes references as its parameters and it passes (or *forwards*) these parameters to another function. For example, if the generic function takes a parameter of type `const T&`, then the called function cannot modify the value of that parameter. If the generic function takes a parameter of type `T&`, then the function cannot be called by using an rvalue (such as a temporary object or integer literal).  \n  \n Ordinarily, to solve this problem, you must provide overloaded versions of the generic function that take both `T&` and `const T&` for each of its parameters. As a result, the number of overloaded functions increases exponentially with the number of parameters. Rvalue references enable you to write one version of a function that accepts arbitrary arguments and forwards them to another function as if the other function had been called directly.  \n  \n Consider the following example that declares four types, `W`, `X`, `Y`, and `Z`. The constructor for each type takes a different combination of `const` and non-`const` lvalue references as its parameters.  \n  \n```  \nstruct W  \n{  \n   W(int&, int&) {}  \n};  \n  \nstruct X  \n{  \n   X(const int&, int&) {}  \n};  \n  \nstruct Y  \n{  \n   Y(int&, const int&) {}  \n};  \n  \nstruct Z  \n{  \n   Z(const int&, const int&) {}  \n};  \n```  \n  \n Suppose you want to write a generic function that generates objects. The following example shows one way to write this function:  \n  \n```  \ntemplate <typename T, typename A1, typename A2>  \nT* factory(A1& a1, A2& a2)  \n{  \n   return new T(a1, a2);  \n}  \n```  \n  \n The following example shows a valid call to the `factory` function:  \n  \n```  \nint a = 4, b = 5;  \nW* pw = factory<W>(a, b);  \n```  \n  \n However, the following example does not contain a valid call to the `factory` function because `factory` takes lvalue references that are modifiable as its parameters, but it is called by using rvalues:  \n  \n```  \nZ* pz = factory<Z>(2, 2);  \n```  \n  \n Ordinarily, to solve this problem, you must create an overloaded version of the `factory` function for every combination of `A&` and `const A&` parameters. Rvalue references enable you to write one version of the `factory` function, as shown in the following example:  \n  \n```  \ntemplate <typename T, typename A1, typename A2>  \nT* factory(A1&& a1, A2&& a2)  \n{  \n   return new T(std::forward<A1>(a1), std::forward<A2>(a2));  \n}  \n```  \n  \n This example uses rvalue references as the parameters to the `factory` function. The purpose of the [std::forward](../standard-library/utility-functions.md#forward) function is to forward the parameters of the factory function to the constructor of the template class.  \n  \n The following example shows the `main` function that uses the revised `factory` function to create instances of the `W`, `X`, `Y`, and `Z` classes. The revised `factory` function forwards its parameters (either lvalues or rvalues) to the appropriate class constructor.  \n  \n```  \nint main()  \n{  \n   int a = 4, b = 5;  \n   W* pw = factory<W>(a, b);  \n   X* px = factory<X>(2, b);  \n   Y* py = factory<Y>(a, 2);  \n   Z* pz = factory<Z>(2, 2);  \n  \n   delete pw;  \n   delete px;  \n   delete py;  \n   delete pz;  \n}  \n```  \n  \n## Additional Properties of Rvalue References  \n **You can overload a function to take an lvalue reference and an rvalue reference.**  \n  \n By overloading a function to take a `const` lvalue reference or an rvalue reference, you can write code that distinguishes between non-modifiable objects (lvalues) and modifiable temporary values (rvalues). You can pass an object to a function that takes an rvalue reference unless the object is marked as `const`. The following example shows the function `f`, which is overloaded to take an lvalue reference and an rvalue reference. The `main` function calls `f` with both lvalues and an rvalue.  \n  \n```  \n// reference-overload.cpp  \n// Compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \n// A class that contains a memory resource.  \nclass MemoryBlock  \n{  \n   // TODO: Add resources for the class here.  \n};  \n  \nvoid f(const MemoryBlock&)  \n{  \n   cout << \"In f(const MemoryBlock&). This version cannot modify the parameter.\" << endl;  \n}  \n  \nvoid f(MemoryBlock&&)  \n{  \n   cout << \"In f(MemoryBlock&&). This version can modify the parameter.\" << endl;  \n}  \n  \nint main()  \n{  \n   MemoryBlock block;  \n   f(block);  \n   f(MemoryBlock());  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nIn f(const MemoryBlock&). This version cannot modify the parameter.  \nIn f(MemoryBlock&&). This version can modify the parameter.  \n```  \n  \n In this example, the first call to `f` passes a local variable (an lvalue) as its argument. The second call to `f` passes a temporary object as its argument. Because the temporary object cannot be referenced elsewhere in the program, the call binds to the overloaded version of `f` that takes an rvalue reference, which is free to modify the object.  \n  \n **The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue.**  \n  \n When you write a function that takes an rvalue reference as its parameter, that parameter is treated as an lvalue in the body of the function. The compiler treats a named rvalue reference as an lvalue because a named object can be referenced by several parts of a program; it would be dangerous to allow multiple parts of a program to modify or remove resources from that object. For example, if multiple parts of a program try to transfer resources from the same object, only the first part will successfully transfer the resource.  \n  \n The following example shows the function `g`, which is overloaded to take an lvalue reference and an rvalue reference. The function `f` takes an rvalue reference as its parameter (a named rvalue reference) and returns an rvalue reference (an unnamed rvalue reference). In the call to `g` from `f`, overload resolution selects the version of `g` that takes an lvalue reference because the body of `f` treats its parameter as an lvalue. In the call to `g` from `main`, overload resolution selects the version of `g` that takes an rvalue reference because `f` returns an rvalue reference.  \n  \n```  \n// named-reference.cpp  \n// Compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \n// A class that contains a memory resource.  \nclass MemoryBlock  \n{  \n   // TODO: Add resources for the class here.  \n};  \n  \nvoid g(const MemoryBlock&)   \n{  \n   cout << \"In g(const MemoryBlock&).\" << endl;  \n}  \n  \nvoid g(MemoryBlock&&)   \n{  \n   cout << \"In g(MemoryBlock&&).\" << endl;  \n}  \n  \nMemoryBlock&& f(MemoryBlock&& block)  \n{  \n   g(block);  \n   return block;  \n}  \n  \nint main()  \n{  \n   g(f(MemoryBlock()));  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nIn g(const MemoryBlock&).  \nIn g(MemoryBlock&&).  \n```  \n  \n In this example, the `main` function passes an rvalue to `f`. The body of `f` treats its named parameter as an lvalue. The call from `f` to `g` binds the parameter to an lvalue reference (the first overloaded version of `g`).  \n  \n-   **You can cast an lvalue to an rvalue reference.**  \n  \n The STL [std::move](../standard-library/utility-functions.md#move) function enables you to convert an object to an rvalue reference to that object. Alternatively, you can use the `static_cast` keyword to cast an lvalue to an rvalue reference, as shown in the following example:  \n  \n```  \n// cast-reference.cpp  \n// Compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \n// A class that contains a memory resource.  \nclass MemoryBlock  \n{  \n   // TODO: Add resources for the class here.  \n};  \n  \nvoid g(const MemoryBlock&)   \n{  \n   cout << \"In g(const MemoryBlock&).\" << endl;  \n}  \n  \nvoid g(MemoryBlock&&)   \n{  \n   cout << \"In g(MemoryBlock&&).\" << endl;  \n}  \n  \nint main()  \n{  \n   MemoryBlock block;  \n   g(block);  \n   g(static_cast<MemoryBlock&&>(block));  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nIn g(const MemoryBlock&).  \nIn g(MemoryBlock&&).  \n```  \n  \n **Function templates deduce their template argument types and then use reference collapsing rules.**  \n  \n It is common to write a function template that passes (or *forwards*) its parameters to another function. It is important to understand how template type deduction works for function templates that take rvalue references.  \n  \n If the function argument is an rvalue, the compiler deduces the argument to be an rvalue reference. For example, if you pass an rvalue reference to an object of type `X` to a template function that takes type `T&&` as its parameter, template argument deduction deduces `T` to be `X`. Therefore, the parameter has type `X&&`. If the function argument is an lvalue or `const` lvalue, the compiler deduces its type to be an lvalue reference or `const` lvalue reference of that type.  \n  \n The following example declares one structure template and then specializes it for various reference types. The `print_type_and_value` function takes an rvalue reference as its parameter and forwards it to the appropriate specialized version of the `S::print` method. The `main` function demonstrates the various ways to call the `S::print` method.  \n  \n```  \n// template-type-deduction.cpp  \n// Compile with: /EHsc  \n#include <iostream>  \n#include <string>  \nusing namespace std;  \n  \ntemplate<typename T> struct S;  \n  \n// The following structures specialize S by   \n// lvalue reference (T&), const lvalue reference (const T&),   \n// rvalue reference (T&&), and const rvalue reference (const T&&).  \n// Each structure provides a print method that prints the type of   \n// the structure and its parameter.  \n  \ntemplate<typename T> struct S<T&> {  \n   static void print(T& t)  \n   {  \n      cout << \"print<T&>: \" << t << endl;  \n   }  \n};  \n  \ntemplate<typename T> struct S<const T&> {  \n   static void print(const T& t)  \n   {  \n      cout << \"print<const T&>: \" << t << endl;  \n   }  \n};  \n  \ntemplate<typename T> struct S<T&&> {  \n   static void print(T&& t)  \n   {  \n      cout << \"print<T&&>: \" << t << endl;  \n   }  \n};  \n  \ntemplate<typename T> struct S<const T&&> {  \n   static void print(const T&& t)  \n   {  \n      cout << \"print<const T&&>: \" << t << endl;  \n   }  \n};  \n  \n// This function forwards its parameter to a specialized  \n// version of the S type.  \ntemplate <typename T> void print_type_and_value(T&& t)   \n{  \n   S<T&&>::print(std::forward<T>(t));  \n}  \n  \n// This function returns the constant string \"fourth\".  \nconst string fourth() { return string(\"fourth\"); }  \n  \nint main()  \n{  \n   // The following call resolves to:  \n   // print_type_and_value<string&>(string& && t)  \n   // Which collapses to:  \n   // print_type_and_value<string&>(string& t)  \n   string s1(\"first\");  \n   print_type_and_value(s1);   \n  \n   // The following call resolves to:  \n   // print_type_and_value<const string&>(const string& && t)  \n   // Which collapses to:  \n   // print_type_and_value<const string&>(const string& t)  \n   const string s2(\"second\");  \n   print_type_and_value(s2);  \n  \n   // The following call resolves to:  \n   // print_type_and_value<string&&>(string&& t)  \n   print_type_and_value(string(\"third\"));  \n  \n   // The following call resolves to:  \n   // print_type_and_value<const string&&>(const string&& t)  \n   print_type_and_value(fourth());  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nprint<T&>: first  \nprint<const T&>: second  \nprint<T&&>: third  \nprint<const T&&>: fourth  \n```  \n  \n To resolve each call to the `print_type_and_value` function, the compiler first performs template argument deduction. The compiler then applies reference collapsing rules when it substitutes the deduced template arguments for the parameter types. For example, passing the local variable `s1` to the `print_type_and_value` function causes the compiler to produce the following function signature:  \n  \n```  \nprint_type_and_value<string&>(string& && t)  \n```  \n  \n The compiler uses reference collapsing rules to reduce the signature to the following:  \n  \n```  \nprint_type_and_value<string&>(string& t)  \n```  \n  \n This version of the `print_type_and_value` function then forwards its parameter to the correct specialized version of the `S::print` method.  \n  \n The following table summarizes the reference collapsing rules for template argument type deduction:  \n  \n|||  \n|-|-|  \n|Expanded type|Collapsed type|  \n|`T& &`|`T&`|  \n|`T& &&`|`T&`|  \n|`T&& &`|`T&`|  \n|`T&& &&`|`T&&`|  \n  \n Template argument deduction is an important element of implementing perfect forwarding. The section Perfect Forwarding, which is presented earlier in this topic, describes perfect forwarding in more detail.  \n  \n## Summary  \n Rvalue references distinguish lvalues from rvalues. They can help you improve the performance of your applications by eliminating the need for unnecessary memory allocations and copy operations. They also enable you to write one version of a function that accepts arbitrary arguments and forwards them to another function as if the other function had been called directly.  \n  \n## See Also  \n [Expressions with Unary Operators](../cpp/expressions-with-unary-operators.md)   \n [Lvalue Reference Declarator: &](../cpp/lvalue-reference-declarator-amp.md)   \n [Lvalues and Rvalues](../cpp/lvalues-and-rvalues-visual-cpp.md)   \n [Move Constructors and Move Assignment Operators (C++)](../cpp/move-constructors-and-move-assignment-operators-cpp.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)   \n"}