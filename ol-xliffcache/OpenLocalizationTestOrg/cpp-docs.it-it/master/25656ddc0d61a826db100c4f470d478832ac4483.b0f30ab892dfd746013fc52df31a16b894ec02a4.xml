{"nodes":[{"pos":[12,63],"content":"SQL: SQL and C++ Data Types (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"SQL: SQL and C++ Data Types (ODBC) | Microsoft Docs","pos":[0,51]}]},{"content":"SQL: SQL and C++ Data Types (ODBC)","pos":[664,698]},{"pos":[701,896],"content":"[!NOTE]\n This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","leadings":["","> "],"nodes":[{"content":" This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","pos":[8,193],"nodes":[{"content":"This information applies to the MFC ODBC classes.","pos":[1,50]},{"content":"If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","pos":[51,185]}]}]},{"content":"The following table maps ANSI SQL data types to C++ data types.","pos":[903,966]},{"content":"This augments the C language information given in Appendix D of the <bpt id=\"p1\">*</bpt>ODBC SDK<ept id=\"p1\">*</ept> <bpt id=\"p2\">*</bpt>Programmer's Reference<ept id=\"p2\">*</ept> on the MSDN Library CD.","pos":[967,1094],"source":" This augments the C language information given in Appendix D of the *ODBC SDK* *Programmer's Reference* on the MSDN Library CD."},{"content":"The wizards manage most data type mapping for you.","pos":[1095,1145]},{"content":"If you do not use a wizard, you can use the mapping information to help you write the field exchange code manually.","pos":[1146,1261]},{"content":"ANSI SQL Data Types Mapped to C++ Data Types","pos":[1271,1315]},{"content":"ANSI SQL data type","pos":[1322,1340]},{"content":"C++ data type","pos":[1341,1354]},{"content":"CHAR","pos":[1412,1416]},{"content":"DECIMAL","pos":[1435,1442]},{"pos":[1455,1456],"content":"1"},{"content":"SMALLINT","pos":[1463,1471]},{"content":"float","pos":[1493,1498]},{"content":"INTEGER","pos":[1507,1514]},{"content":"long","pos":[1519,1523]},{"content":"FLOAT","pos":[1532,1537]},{"content":"double","pos":[1542,1548]},{"content":"DOUBLE","pos":[1557,1563]},{"content":"double","pos":[1568,1574]},{"content":"NUMERIC","pos":[1583,1590]},{"pos":[1603,1604],"content":"1"},{"content":"VARCHAR","pos":[1611,1618]},{"content":"LONGVARCHAR","pos":[1637,1648]},{"pos":[1664,1677],"content":", <ph id=\"ph1\">`CString`</ph> 2","source":", `CString` 2"},{"content":"BIT","pos":[1684,1687]},{"content":"BOOL","pos":[1692,1696]},{"content":"TINYINT","pos":[1705,1712]},{"content":"BYTE","pos":[1717,1721]},{"content":"BIGINT","pos":[1730,1736]},{"pos":[1749,1750],"content":"1"},{"content":"BINARY","pos":[1757,1763]},{"content":"VARBINARY","pos":[1785,1794]},{"content":"LONGVARBINARY","pos":[1816,1829]},{"pos":[1845,1861],"content":", <ph id=\"ph1\">`CByteArray`</ph> 3","source":", `CByteArray` 3"},{"content":"DATE","pos":[1868,1872]},{"pos":[1882,1883],"content":","},{"content":"TIME","pos":[1900,1904]},{"content":"CTime, CString","pos":[1909,1923]},{"content":"TIMESTAMP","pos":[1932,1941]},{"content":"CTime, CString","pos":[1946,1960]},{"pos":[1973,2080],"content":"ANSI <bpt id=\"p1\">**</bpt>DECIMAL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>NUMERIC<ept id=\"p2\">**</ept> map to <ph id=\"ph1\">`CString`</ph> because <bpt id=\"p3\">**</bpt>SQL_C_CHAR<ept id=\"p3\">**</ept> is the default ODBC transfer type.","source":"ANSI **DECIMAL** and **NUMERIC** map to `CString` because **SQL_C_CHAR** is the default ODBC transfer type."},{"content":"Character data beyond 255 characters is truncated by default when mapped to <ph id=\"ph1\">`CString`</ph>.","pos":[2090,2176],"source":"Character data beyond 255 characters is truncated by default when mapped to `CString`."},{"content":"You can extend the truncation length by explicitly setting the <ph id=\"ph1\">`nMaxLength`</ph> argument of <ph id=\"ph2\">`RFX_Text`</ph>.","pos":[2177,2276],"source":" You can extend the truncation length by explicitly setting the `nMaxLength` argument of `RFX_Text`."},{"content":"Binary data beyond 255 characters is truncated by default when mapped to <ph id=\"ph1\">`CByteArray`</ph>.","pos":[2286,2372],"source":"Binary data beyond 255 characters is truncated by default when mapped to `CByteArray`."},{"content":"You can extend the truncation length by explicitly setting the <ph id=\"ph1\">`nMaxLength`</ph> argument of <ph id=\"ph2\">`RFX_Binary`</ph>.","pos":[2373,2474],"source":" You can extend the truncation length by explicitly setting the `nMaxLength` argument of `RFX_Binary`."},{"content":"If you are not using the ODBC cursor library, you might encounter a problem when attempting to update two or more long variable-length fields using the Microsoft SQL Server ODBC driver and the MFC ODBC database classes.","pos":[2481,2700]},{"content":"The ODBC types, <bpt id=\"p1\">**</bpt>SQL_LONGVARCHAR<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>SQL_LONGVARBINARY<ept id=\"p2\">**</ept>, map to text and image SQL Server types.","pos":[2701,2803],"source":" The ODBC types, **SQL_LONGVARCHAR** and **SQL_LONGVARBINARY**, map to text and image SQL Server types."},{"content":"A <ph id=\"ph1\">`CDBException`</ph> is thrown if you update two or more long variable-length fields on the same call to <ph id=\"ph2\">`CRecordset::Update`</ph>.","pos":[2804,2926],"source":" A `CDBException` is thrown if you update two or more long variable-length fields on the same call to `CRecordset::Update`."},{"content":"Therefore, do not update multiple long columns simultaneously with <ph id=\"ph1\">`CRecordset::Update`</ph>.","pos":[2927,3015],"source":" Therefore, do not update multiple long columns simultaneously with `CRecordset::Update`."},{"content":"You can update multiple long columns simultaneously with the ODBC API <bpt id=\"p1\">**</bpt>SQLPutData<ept id=\"p1\">**</ept>.","pos":[3016,3101],"source":" You can update multiple long columns simultaneously with the ODBC API **SQLPutData**."},{"content":"You can also use the ODBC cursor library, but this is not recommended for drivers, like the SQL Server driver, that support cursors and do not need the cursor library.","pos":[3102,3269]},{"content":"If you are using the ODBC cursor library with the MFC ODBC database classes and the Microsoft SQL Server ODBC driver, an <bpt id=\"p1\">**</bpt>ASSERT<ept id=\"p1\">**</ept> might occur along with a <ph id=\"ph1\">`CDBException`</ph> if a call to <ph id=\"ph2\">`CRecordset::Update`</ph> follows a call to <ph id=\"ph3\">`CRecordset::Requery`</ph>.","pos":[3276,3522],"source":"If you are using the ODBC cursor library with the MFC ODBC database classes and the Microsoft SQL Server ODBC driver, an **ASSERT** might occur along with a `CDBException` if a call to `CRecordset::Update` follows a call to `CRecordset::Requery`."},{"content":"Instead, call <ph id=\"ph1\">`CRecordset::Close`</ph> and <ph id=\"ph2\">`CRecordset::Open`</ph> rather than <ph id=\"ph3\">`CRecordset::Requery`</ph>.","pos":[3523,3614],"source":" Instead, call `CRecordset::Close` and `CRecordset::Open` rather than `CRecordset::Requery`."},{"content":"Another solution is not to use the ODBC cursor library, because the SQL Server and the SQL Server ODBC driver provide native support for cursors natively and the ODBC cursor library is not needed.","pos":[3615,3811]},{"content":"See Also","pos":[3820,3828]},{"content":"SQL","pos":[3833,3836]},{"content":"SQL: Making Direct SQL Calls (ODBC)","pos":[3867,3902]}],"content":"---\ntitle: \"SQL: SQL and C++ Data Types (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"data types [C++], SQL vs. C++\"\n  - \"SQL data types [C++]\"\n  - \"SQL [C++], vs. C++ data types\"\nms.assetid: 066e0070-d4da-435c-9c4b-f7cab3352c86\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# SQL: SQL and C++ Data Types (ODBC)\n> [!NOTE]\n>  This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.  \n  \n The following table maps ANSI SQL data types to C++ data types. This augments the C language information given in Appendix D of the *ODBC SDK* *Programmer's Reference* on the MSDN Library CD. The wizards manage most data type mapping for you. If you do not use a wizard, you can use the mapping information to help you write the field exchange code manually.  \n  \n### ANSI SQL Data Types Mapped to C++ Data Types  \n  \n|ANSI SQL data type|C++ data type|  \n|------------------------|---------------------|  \n|**CHAR**|`CString`|  \n|**DECIMAL**|`CString` 1|  \n|**SMALLINT**|`int`|  \n|`REAL`|**float**|  \n|**INTEGER**|**long**|  \n|**FLOAT**|**double**|  \n|**DOUBLE**|**double**|  \n|**NUMERIC**|`CString` 1|  \n|**VARCHAR**|`CString`|  \n|**LONGVARCHAR**|`CLongBinary`, `CString` 2|  \n|**BIT**|**BOOL**|  \n|**TINYINT**|**BYTE**|  \n|**BIGINT**|`CString` 1|  \n|**BINARY**|`CByteArray`|  \n|**VARBINARY**|`CByteArray`|  \n|**LONGVARBINARY**|`CLongBinary`, `CByteArray` 3|  \n|**DATE**|`CTime`, `CString`|  \n|**TIME**|**CTime, CString**|  \n|**TIMESTAMP**|**CTime, CString**|  \n  \n 1. ANSI **DECIMAL** and **NUMERIC** map to `CString` because **SQL_C_CHAR** is the default ODBC transfer type.  \n  \n 2. Character data beyond 255 characters is truncated by default when mapped to `CString`. You can extend the truncation length by explicitly setting the `nMaxLength` argument of `RFX_Text`.  \n  \n 3. Binary data beyond 255 characters is truncated by default when mapped to `CByteArray`. You can extend the truncation length by explicitly setting the `nMaxLength` argument of `RFX_Binary`.  \n  \n If you are not using the ODBC cursor library, you might encounter a problem when attempting to update two or more long variable-length fields using the Microsoft SQL Server ODBC driver and the MFC ODBC database classes. The ODBC types, **SQL_LONGVARCHAR** and **SQL_LONGVARBINARY**, map to text and image SQL Server types. A `CDBException` is thrown if you update two or more long variable-length fields on the same call to `CRecordset::Update`. Therefore, do not update multiple long columns simultaneously with `CRecordset::Update`. You can update multiple long columns simultaneously with the ODBC API **SQLPutData**. You can also use the ODBC cursor library, but this is not recommended for drivers, like the SQL Server driver, that support cursors and do not need the cursor library.  \n  \n If you are using the ODBC cursor library with the MFC ODBC database classes and the Microsoft SQL Server ODBC driver, an **ASSERT** might occur along with a `CDBException` if a call to `CRecordset::Update` follows a call to `CRecordset::Requery`. Instead, call `CRecordset::Close` and `CRecordset::Open` rather than `CRecordset::Requery`. Another solution is not to use the ODBC cursor library, because the SQL Server and the SQL Server ODBC driver provide native support for cursors natively and the ODBC cursor library is not needed.  \n  \n## See Also  \n [SQL](../../data/odbc/sql.md)   \n [SQL: Making Direct SQL Calls (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)"}