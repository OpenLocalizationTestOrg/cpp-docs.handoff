{"nodes":[{"pos":[12,44],"content":"setjmp-longjump | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"setjmp-longjump | Microsoft Docs","pos":[0,32]}]},{"content":"setjmp/longjump","pos":[524,539]},{"content":"When you include setjmpex.h or setjmp.h, all calls to <bpt id=\"p1\">[</bpt>setjmp<ept id=\"p1\">](../c-runtime-library/reference/setjmp.md)</ept> or <bpt id=\"p2\">[</bpt>longjmp<ept id=\"p2\">](../c-runtime-library/reference/longjmp.md)</ept> will result in an unwind that invokes destructors and finally calls.","pos":[540,769],"source":"When you include setjmpex.h or setjmp.h, all calls to [setjmp](../c-runtime-library/reference/setjmp.md) or [longjmp](../c-runtime-library/reference/longjmp.md) will result in an unwind that invokes destructors and finally calls."},{"content":"This differs from x86, where including setjmp.h results in finally clauses and destructors not being invoked.","pos":[771,880]},{"content":"A call to <ph id=\"ph1\">`setjmp`</ph> preserves the current stack pointer, non-volatile registers, and MxCsr registers.","pos":[887,987],"source":"A call to `setjmp` preserves the current stack pointer, non-volatile registers, and MxCsr registers."},{"content":"Calls to <ph id=\"ph1\">`longjmp`</ph> return to the most recent <ph id=\"ph2\">`setjmp`</ph> call site and resets the stack pointer, non-volatile registers, and MxCsr registers, back to the state as preserved by the most recent <ph id=\"ph3\">`setjmp`</ph> call.","pos":[989,1192],"source":"  Calls to `longjmp` return to the most recent `setjmp` call site and resets the stack pointer, non-volatile registers, and MxCsr registers, back to the state as preserved by the most recent `setjmp` call."},{"content":"See Also","pos":[1201,1209]},{"content":"Calling Convention","pos":[1214,1232]}],"content":"---\ntitle: \"setjmp-longjump | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: b0e21902-095d-4198-8f9a-b6326525721a\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# setjmp/longjump\nWhen you include setjmpex.h or setjmp.h, all calls to [setjmp](../c-runtime-library/reference/setjmp.md) or [longjmp](../c-runtime-library/reference/longjmp.md) will result in an unwind that invokes destructors and finally calls.  This differs from x86, where including setjmp.h results in finally clauses and destructors not being invoked.  \n  \n A call to `setjmp` preserves the current stack pointer, non-volatile registers, and MxCsr registers.  Calls to `longjmp` return to the most recent `setjmp` call site and resets the stack pointer, non-volatile registers, and MxCsr registers, back to the state as preserved by the most recent `setjmp` call.  \n  \n## See Also  \n [Calling Convention](../build/calling-convention.md)"}