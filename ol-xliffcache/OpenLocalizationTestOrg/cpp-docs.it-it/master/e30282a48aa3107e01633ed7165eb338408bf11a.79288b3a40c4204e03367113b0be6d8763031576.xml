{"nodes":[{"pos":[12,65],"content":"_bittestandreset, _bittestandreset64 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_bittestandreset, _bittestandreset64 | Microsoft Docs","pos":[0,53]}]},{"content":"_bittestandreset, _bittestandreset64","pos":[776,812]},{"content":"Microsoft Specific","pos":[815,833]},{"pos":[842,961],"content":"Generate the instruction which examines bit <ph id=\"ph1\">`b`</ph> of the address <ph id=\"ph2\">`a`</ph>, returns its current value, and resets the bit to 0.","source":"Generate the instruction which examines bit `b` of the address `a`, returns its current value, and resets the bit to 0."},{"content":"Syntax","pos":[970,976]},{"content":"Parameters","pos":[1140,1150]},{"content":"[in, out]","pos":[1154,1163]},{"content":"A pointer to the memory to examine.","pos":[1171,1206]},{"content":"[in]","pos":[1213,1217]},{"content":"The bit position to test.","pos":[1225,1250]},{"content":"Return Value","pos":[1259,1271]},{"content":"The bit at the position specified.","pos":[1275,1309]},{"content":"Requirements","pos":[1318,1330]},{"content":"Intrinsic","pos":[1337,1346]},{"content":"Architecture","pos":[1347,1359]},{"pos":[1422,1431],"content":"x86, ARM,"},{"pos":[1592,1619],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1628,1635]},{"content":"This routine is only available as an intrinsic.","pos":[1639,1686]},{"content":"Example","pos":[1695,1702]},{"content":"END Microsoft Specific","pos":[2477,2499]},{"content":"See Also","pos":[2508,2516]},{"content":"Compiler Intrinsics","pos":[2521,2540]}],"content":"---\ntitle: \"_bittestandreset, _bittestandreset64 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_bittestandreset64_cpp\"\n  - \"_bittestandreset\"\n  - \"_bittestandreset_cpp\"\n  - \"_bittestandreset64\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"btr instruction\"\n  - \"_bittestandreset intrinsic\"\n  - \"_bittestandreset64 intrinsic\"\nms.assetid: 8dad63bb-a051-4cd7-a793-3357537dfeaf\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _bittestandreset, _bittestandreset64\n**Microsoft Specific**  \n  \n Generate the instruction which examines bit `b` of the address `a`, returns its current value, and resets the bit to 0.  \n  \n## Syntax  \n  \n```  \nunsigned char _bittestandreset(  \n   long *a,  \n   long b  \n);  \nunsigned char _bittestandreset64(  \n   __int64 *a,  \n   __int64 b  \n);  \n```  \n  \n#### Parameters  \n [in, out] `a`  \n A pointer to the memory to examine.  \n  \n [in] `b`  \n The bit position to test.  \n  \n## Return Value  \n The bit at the position specified.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`_bittestandreset`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n|`_bittestandreset64`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n This routine is only available as an intrinsic.  \n  \n## Example  \n  \n```  \n// bittestandreset.cpp  \n// processor: x86, IPF, x64  \n#include <stdio.h>  \n#include <limits.h>  \n#include <intrin.h>  \n  \n#pragma intrinsic(_bittestandreset)  \n  \n// Check the sign bit and reset to 0 (taking the absolute value)  \n// Returns 0 if the number is positive or zero  \n// Returns 1 if the number is negative  \nunsigned char absolute_value(long* p)  \n{  \n   const int SIGN_BIT = 31;  \n   return _bittestandreset(p, SIGN_BIT);  \n}  \n  \nint main()  \n{  \n    long i = -112;  \n    unsigned char result;  \n  \n    // Check the sign bit and reset to 0 (taking the absolute value)  \n  \n    result = absolute_value(&i);  \n    if (result == 1)  \n        printf_s(\"The number was negative.\\n\");     \n}  \n```  \n  \n```Output  \nThe number was negative.  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}