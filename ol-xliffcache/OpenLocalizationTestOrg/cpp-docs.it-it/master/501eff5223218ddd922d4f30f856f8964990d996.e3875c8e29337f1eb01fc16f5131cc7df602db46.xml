{"nodes":[{"pos":[12,56],"content":"Optimization Best Practices | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Optimization Best Practices | Microsoft Docs","pos":[0,44]}]},{"content":"Optimization Best Practices","pos":[650,677]},{"content":"This document describes some best practices for optimization in Visual C++.","pos":[678,753]},{"content":"The following topics are discussed:","pos":[754,789]},{"content":"Compiler and Linker Options","pos":[799,826]},{"content":"Profile-Guided Optimization","pos":[840,867]},{"content":"Which Level of Optimization Should I Use?","pos":[881,922]},{"content":"Floating Point Switches","pos":[936,959]},{"content":"Optimization Declspecs","pos":[969,991]},{"content":"Optimization Pragmas","pos":[1001,1021]},{"content":"__restrict and <ph id=\"ph1\">\\_</ph>_assume","pos":[1031,1055],"source":"__restrict and \\__assume"},{"content":"Intrinsic Support","pos":[1065,1082]},{"content":"Exceptions","pos":[1092,1102]},{"content":"Compiler and Linker Options","pos":[1111,1138]},{"content":"Profile-Guided Optimization","pos":[1148,1175]},{"content":"Visual C++ supports profile-guided optimization (PGO).","pos":[1179,1233]},{"content":"This optimization uses profile data from past executions of an instrumented version of an application to drive later optimization of the application.","pos":[1234,1383]},{"content":"Using PGO can be time consuming, so it may not be something that every developer uses, but we do recommend using PGO for the final release build of a product.","pos":[1384,1542]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Profile-Guided Optimizations<ept id=\"p1\">](../../build/reference/profile-guided-optimizations.md)</ept>.","pos":[1543,1655],"source":" For more information, see [Profile-Guided Optimizations](../../build/reference/profile-guided-optimizations.md)."},{"content":"In addition, Whole Program Optimization (also knows as Link Time Code Generation) and the <bpt id=\"p1\">**</bpt>/O1<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/O2<ept id=\"p2\">**</ept> optimizations has been improved.","pos":[1662,1804],"source":"In addition, Whole Program Optimization (also knows as Link Time Code Generation) and the **/O1** and **/O2** optimizations has been improved."},{"content":"In general, an application compiled with one of these options will be faster than the same application compiled with an earlier compiler.","pos":[1805,1942]},{"pos":[1949,2174],"content":"For more information, see <bpt id=\"p1\">[</bpt>/GL (Whole Program Optimization)<ept id=\"p1\">](../../build/reference/gl-whole-program-optimization.md)</ept> and <bpt id=\"p2\">[</bpt>/O1, /O2 (Minimize Size, Maximize Speed)<ept id=\"p2\">](../../build/reference/o1-o2-minimize-size-maximize-speed.md)</ept>.","source":"For more information, see [/GL (Whole Program Optimization)](../../build/reference/gl-whole-program-optimization.md) and [/O1, /O2 (Minimize Size, Maximize Speed)](../../build/reference/o1-o2-minimize-size-maximize-speed.md)."},{"content":"Which Level of Optimization Should I Use?","pos":[2184,2225]},{"content":"If at all possible, final release builds should be compiled with Profile Guided Optimizations.","pos":[2229,2323]},{"content":"If it is not possible to build with PGO, whether due to insufficient infrastructure for running the instrumented builds or not having access to scenarios, then we suggest building with Whole Program Optimization.","pos":[2324,2536]},{"content":"The <bpt id=\"p1\">**</bpt>/Gy<ept id=\"p1\">**</ept> switch is also very useful.","pos":[2543,2582],"source":"The **/Gy** switch is also very useful."},{"content":"It generates a separate COMDAT for each function, giving the linker more flexibility when it comes to removing unreferenced COMDATs and COMDAT folding.","pos":[2583,2734]},{"content":"The only downside to using <bpt id=\"p1\">**</bpt>/Gy<ept id=\"p1\">**</ept> is that it can have a minor effect on build time.","pos":[2735,2819],"source":" The only downside to using **/Gy** is that it can have a minor effect on build time."},{"content":"Therefore, it is generally recommended to use it.","pos":[2820,2869]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/Gy (Enable Function-Level Linking)<ept id=\"p1\">](../../build/reference/gy-enable-function-level-linking.md)</ept>.","pos":[2870,2993],"source":" For more information, see [/Gy (Enable Function-Level Linking)](../../build/reference/gy-enable-function-level-linking.md)."},{"content":"For linking in 64-bit environments, it is recommended to use the <bpt id=\"p1\">**</bpt>/OPT:REF,ICF<ept id=\"p1\">**</ept> linker option, and in 32-bit environments, <bpt id=\"p2\">**</bpt>/OPT:REF<ept id=\"p2\">**</ept> is recommended.","pos":[3000,3153],"source":"For linking in 64-bit environments, it is recommended to use the **/OPT:REF,ICF** linker option, and in 32-bit environments, **/OPT:REF** is recommended."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/OPT (Optimizations)<ept id=\"p1\">](../../build/reference/opt-optimizations.md)</ept>.","pos":[3154,3247],"source":" For more information, see [/OPT (Optimizations)](../../build/reference/opt-optimizations.md)."},{"content":"It is also strongly recommended to generate debug symbols, even with optimized release builds.","pos":[3254,3348]},{"content":"It doesn’t effect the generated code, and it makes it a lot easier to debug your application, if need be.","pos":[3349,3454]},{"content":"Floating Point Switches","pos":[3464,3487]},{"pos":[3491,3635],"content":"The <bpt id=\"p1\">**</bpt>/Op<ept id=\"p1\">**</ept> compiler option has been removed, and the following four compiler options dealing with floating point optimizations have been added:","source":"The **/Op** compiler option has been removed, and the following four compiler options dealing with floating point optimizations have been added:"},{"content":"/fp:precise","pos":[3658,3669]},{"content":"This is the default recommendation and should be used in most cases.","pos":[3672,3740]},{"content":"/fp:fast","pos":[3747,3755]},{"content":"Recommended if performance is of the utmost importance, for example in games.","pos":[3758,3835]},{"content":"This will result in the fastest performance.","pos":[3836,3880]},{"content":"/fp:strict","pos":[3887,3897]},{"content":"Recommended if precise floating-point exceptions and IEEE behavior is desired.","pos":[3900,3978]},{"content":"This will result in the slowest performance.","pos":[3979,4023]},{"content":"/fp:except[-]","pos":[4030,4043]},{"pos":[4046,4134],"content":"Can be used in conjunction with <bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/fp:precise<ept id=\"p2\">**</ept>, but not <bpt id=\"p3\">**</bpt>/fp:fast<ept id=\"p3\">**</ept>.","source":"Can be used in conjunction with **/fp:strict** or **/fp:precise**, but not **/fp:fast**."},{"pos":[4142,4269],"content":"For more information, see <bpt id=\"p1\">[</bpt>/fp (Specify Floating-Point Behavior)<ept id=\"p1\">](../../build/reference/fp-specify-floating-point-behavior.md)</ept>.","source":"For more information, see [/fp (Specify Floating-Point Behavior)](../../build/reference/fp-specify-floating-point-behavior.md)."},{"content":"Optimization Declspecs","pos":[4278,4300]},{"pos":[4304,4449],"content":"In this section we will look at two declspecs that can be used in programs to help performance: <ph id=\"ph1\">`__declspec(restrict)`</ph> and <ph id=\"ph2\">`__declspec(noalias)`</ph>.","source":"In this section we will look at two declspecs that can be used in programs to help performance: `__declspec(restrict)` and `__declspec(noalias)`."},{"pos":[4456,4555],"content":"The <ph id=\"ph1\">`restrict`</ph> declspec can only be applied to function declarations that return a pointer, such as","source":"The `restrict` declspec can only be applied to function declarations that return a pointer, such as "},{"content":"The <ph id=\"ph1\">`restrict`</ph> declspec is used on functions that return unaliased pointers.","pos":[4612,4688],"source":"The `restrict` declspec is used on functions that return unaliased pointers."},{"content":"This keyword is used for the C-Runtime Library implementation of <ph id=\"ph1\">`malloc`</ph> since it will never return a pointer value that is already in use in the current program (unless you are doing something illegal, such as using memory after it has been freed).","pos":[4689,4939],"source":" This keyword is used for the C-Runtime Library implementation of `malloc` since it will never return a pointer value that is already in use in the current program (unless you are doing something illegal, such as using memory after it has been freed)."},{"content":"The <ph id=\"ph1\">`restrict`</ph> declspec gives the compiler more information for performing compiler optimizations.","pos":[4946,5044],"source":"The `restrict` declspec gives the compiler more information for performing compiler optimizations."},{"content":"One of the hardest things for a compiler to determine is what pointers alias other pointers, and using this information greatly helps the compiler.","pos":[5045,5192]},{"content":"It is worth pointing out that this is a promise to the compiler, not something that the compiler will verify.","pos":[5199,5308]},{"content":"If your program uses this <ph id=\"ph1\">`restrict`</ph> declspec inappropriately, your program may have incorrect behavior.","pos":[5309,5413],"source":" If your program uses this `restrict` declspec inappropriately, your program may have incorrect behavior."},{"pos":[5420,5480],"content":"For more information, see <bpt id=\"p1\">[</bpt>restrict<ept id=\"p1\">](../../cpp/restrict.md)</ept>.","source":"For more information, see [restrict](../../cpp/restrict.md)."},{"content":"The <ph id=\"ph1\">`noalias`</ph> declspec is also applied only to functions, and indicates that the function is a semi-pure function.","pos":[5487,5601],"source":"The `noalias` declspec is also applied only to functions, and indicates that the function is a semi-pure function."},{"content":"A semi-pure function is one that references or modifies only locals, arguments, and first-level indirections of arguments.","pos":[5602,5724]},{"content":"This declspec is a promise to the compiler, and if the function references globals or second-level indirections of pointer arguments then the compiler may generate code that breaks the application.","pos":[5725,5922]},{"pos":[5929,5987],"content":"For more information, see <bpt id=\"p1\">[</bpt>noalias<ept id=\"p1\">](../../cpp/noalias.md)</ept>.","source":"For more information, see [noalias](../../cpp/noalias.md)."},{"content":"Optimization Pragmas","pos":[5996,6016]},{"content":"There are also several useful pragmas for helping optimize code.","pos":[6020,6084]},{"content":"The first one we’ll discuss is <ph id=\"ph1\">`#pragma optimize`</ph>:","pos":[6085,6135],"source":" The first one we’ll discuss is `#pragma optimize`:"},{"content":"This pragma allows you to set a given optimization level on a function-by-function basis.","pos":[6200,6289]},{"content":"This is ideal for those rare occasions where your application crashes when a given function is compiled with optimization.","pos":[6290,6412]},{"content":"You can use this to turn off optimizations for a single function:","pos":[6413,6478]},{"pos":[6576,6645],"content":"For more information, see <bpt id=\"p1\">[</bpt>optimize<ept id=\"p1\">](../../preprocessor/optimize.md)</ept>.","source":"For more information, see [optimize](../../preprocessor/optimize.md)."},{"content":"Inlining is one of the most important optimizations that the compiler performs and here we talk about a couple of the pragmas that help modify this behavior.","pos":[6652,6809]},{"content":"is useful for specifying whether or not you want the application to be able to inline a recursive call.","pos":[6843,6946]},{"content":"By default it is off.","pos":[6947,6968]},{"content":"For shallow recursion of small functions you may to turn this on.","pos":[6969,7034]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>inline_recursion<ept id=\"p1\">](../../preprocessor/inline-recursion.md)</ept>.","pos":[7035,7120],"source":" For more information, see [inline_recursion](../../preprocessor/inline-recursion.md)."},{"content":"Another useful pragma for limiting the depth of inlining is <ph id=\"ph1\">`#pragma inline_depth`</ph>.","pos":[7127,7210],"source":"Another useful pragma for limiting the depth of inlining is `#pragma inline_depth`."},{"content":"This is typically useful in situations where you’re trying to limit the size of a program or function.","pos":[7211,7313]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>inline_depth<ept id=\"p1\">](../../preprocessor/inline-depth.md)</ept>.","pos":[7314,7391],"source":" For more information, see [inline_depth](../../preprocessor/inline-depth.md)."},{"content":"__restrict and <ph id=\"ph1\">\\_</ph>_assume","pos":[7400,7424],"source":"__restrict and \\__assume"},{"pos":[7428,7589],"content":"There are a couple of keywords in Visual C++ that can help performance: <bpt id=\"p1\">[</bpt>__restrict<ept id=\"p1\">](../../cpp/extension-restrict.md)</ept> and <bpt id=\"p2\">[</bpt>__assume<ept id=\"p2\">](../../intrinsics/assume.md)</ept>.","source":"There are a couple of keywords in Visual C++ that can help performance: [__restrict](../../cpp/extension-restrict.md) and [__assume](../../intrinsics/assume.md)."},{"content":"First, it should be noted that <ph id=\"ph1\">`__restrict`</ph> and <ph id=\"ph2\">`__declspec(restrict)`</ph> are two different things.","pos":[7596,7692],"source":"First, it should be noted that `__restrict` and `__declspec(restrict)` are two different things."},{"content":"While they are somewhat related, their semantics are different.","pos":[7693,7756]},{"content":"is a type qualifier, like <ph id=\"ph1\">`const`</ph> or <ph id=\"ph2\">`volatile`</ph>, but exclusively for pointer types.","pos":[7770,7853],"source":" is a type qualifier, like `const` or `volatile`, but exclusively for pointer types."},{"content":"A pointer that is modified with <ph id=\"ph1\">`__restrict`</ph> is referred to as a <bpt id=\"p1\">*</bpt>__restrict pointer<ept id=\"p1\">*</ept>.","pos":[7860,7946],"source":"A pointer that is modified with `__restrict` is referred to as a *__restrict pointer*."},{"content":"A __restrict pointer is a pointer that can only be accessed through the <ph id=\"ph1\">\\_</ph>_restrict pointer.","pos":[7947,8039],"source":" A __restrict pointer is a pointer that can only be accessed through the \\__restrict pointer."},{"content":"In other words, another pointer cannot be used to access the data pointed to by the <ph id=\"ph1\">\\_</ph>_restrict pointer.","pos":[8040,8144],"source":" In other words, another pointer cannot be used to access the data pointed to by the \\__restrict pointer."},{"content":"can be a powerful tool for the Visual C++ optimizer, but use it with great care.","pos":[8164,8244]},{"content":"If used improperly, the optimizer might perform an optimization that would break your application.","pos":[8245,8343]},{"pos":[8350,8426],"content":"The <ph id=\"ph1\">`__restrict`</ph> keyword replaces the <bpt id=\"p1\">**</bpt>/Oa<ept id=\"p1\">**</ept> switch from previous versions.","source":"The `__restrict` keyword replaces the **/Oa** switch from previous versions."},{"pos":[8433,8537],"content":"With <ph id=\"ph1\">`__assume,`</ph> a developer can tell the compiler to make assumptions about the value of some variable.","source":"With `__assume,` a developer can tell the compiler to make assumptions about the value of some variable."},{"content":"For example <ph id=\"ph1\">`__assume(a &lt; 5);`</ph> tells the optimizer that at that line of code the variable <ph id=\"ph2\">`a`</ph> is less than 5.","pos":[8544,8653],"source":"For example `__assume(a < 5);` tells the optimizer that at that line of code the variable `a` is less than 5."},{"content":"Again this is a promise to the compiler.","pos":[8654,8694]},{"content":"If <ph id=\"ph1\">`a`</ph> is actually 6 at this point in the program then the behavior of the program after the compiler has optimized may not be what you would expect.","pos":[8695,8844],"source":" If `a` is actually 6 at this point in the program then the behavior of the program after the compiler has optimized may not be what you would expect."},{"content":"is most useful prior to switch statements and/or conditional expressions.","pos":[8856,8929]},{"content":"There are some limitations to <ph id=\"ph1\">`__assume`</ph>.","pos":[8936,8977],"source":"There are some limitations to `__assume`."},{"content":"First, like <ph id=\"ph1\">`__restrict`</ph>, it is only a suggestion, so the compiler is free to ignore it.","pos":[8978,9066],"source":" First, like `__restrict`, it is only a suggestion, so the compiler is free to ignore it."},{"content":"Also, <ph id=\"ph1\">`__assume`</ph> currently works only with variable inequalities against constants.","pos":[9067,9150],"source":" Also, `__assume` currently works only with variable inequalities against constants."},{"content":"It does not propagate symbolic inequalities, for example, assume(a &lt; b).","pos":[9151,9223],"source":" It does not propagate symbolic inequalities, for example, assume(a < b)."},{"content":"Intrinsic Support","pos":[9232,9249]},{"content":"Intrinsics are function calls where the compiler has intrinsic knowledge about the call, and rather than calling a function in a library, it emits code for that function.","pos":[9253,9423]},{"content":"The header file intrin.h located at &lt;Installation_Directory&gt;\\VC\\include\\intrin.h contains all of the available intrinsics for each of the three supported platforms (x86, x64, and ARM).","pos":[9424,9608],"source":" The header file intrin.h located at <Installation_Directory>\\VC\\include\\intrin.h contains all of the available intrinsics for each of the three supported platforms (x86, x64, and ARM)."},{"content":"Intrinsics give the programmer the ability to go deep into the code without having to use assembly.","pos":[9615,9714]},{"content":"There are several benefits to using intrinsics:","pos":[9715,9762]},{"content":"Your code is more portable.","pos":[9772,9799]},{"content":"Several of the intrinsics are available on multiple CPU architectures.","pos":[9800,9870]},{"content":"Your code is easier to read, since the code is still written in C/C++.","pos":[9880,9950]},{"content":"Your code gets the benefit of compiler optimizations.","pos":[9960,10013]},{"content":"As the compiler gets better, the code generation for the intrinsics improves.","pos":[10014,10091]},{"pos":[10098,10292],"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Intrinsics<ept id=\"p1\">](../../intrinsics/compiler-intrinsics.md)</ept> and <bpt id=\"p2\">[</bpt>Benefits of Using Intrinsics<ept id=\"p2\">](http://msdn.microsoft.com/en-us/57af8920-527f-44af-a741-a07cbe80bf02)</ept>.","source":"For more information, see [Compiler Intrinsics](../../intrinsics/compiler-intrinsics.md) and [Benefits of Using Intrinsics](http://msdn.microsoft.com/en-us/57af8920-527f-44af-a741-a07cbe80bf02)."},{"content":"Exceptions","pos":[10301,10311]},{"content":"There is a performance hit associated with using exceptions.","pos":[10315,10375]},{"content":"Some restrictions are introduced when using try blocks that inhibit the compiler from performing certain optimizations.","pos":[10376,10495]},{"content":"On x86 platforms there is additional performance degradation from try blocks due to additional state information that must be generated during code execution.","pos":[10496,10654]},{"content":"On the 64-bit platforms, try blocks do not degrade performance as much, but once an exception is thrown, the process of finding the handler and unwinding the stack can be expensive.","pos":[10655,10836]},{"content":"Therefore, it is recommended to avoid introducing try/catch blocks into code that does not really need it.","pos":[10843,10949]},{"content":"If you must use exceptions, use synchronous exceptions if possible.","pos":[10950,11017]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Structured Exception Handling (C/C++)<ept id=\"p1\">](../../cpp/structured-exception-handling-c-cpp.md)</ept>.","pos":[11018,11134],"source":" For more information, see [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)."},{"content":"Lastly, throw exceptions for exceptional cases only.","pos":[11141,11193]},{"content":"Using exceptions for general control flow will likely make performance suffer.","pos":[11194,11272]},{"content":"See Also","pos":[11281,11289]},{"content":"Optimizing Your Code","pos":[11294,11314]}],"content":"---\ntitle: \"Optimization Best Practices | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Visual C++, optimization\"\n  - \"optimization, best practices\"\nms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Optimization Best Practices\nThis document describes some best practices for optimization in Visual C++. The following topics are discussed:  \n  \n-   Compiler and Linker Options  \n  \n    -   Profile-Guided Optimization  \n  \n    -   Which Level of Optimization Should I Use?  \n  \n    -   Floating Point Switches  \n  \n-   Optimization Declspecs  \n  \n-   Optimization Pragmas  \n  \n-   __restrict and \\__assume  \n  \n-   Intrinsic Support  \n  \n-   Exceptions  \n  \n## Compiler and Linker Options  \n  \n### Profile-Guided Optimization  \n Visual C++ supports profile-guided optimization (PGO). This optimization uses profile data from past executions of an instrumented version of an application to drive later optimization of the application. Using PGO can be time consuming, so it may not be something that every developer uses, but we do recommend using PGO for the final release build of a product. For more information, see [Profile-Guided Optimizations](../../build/reference/profile-guided-optimizations.md).  \n  \n In addition, Whole Program Optimization (also knows as Link Time Code Generation) and the **/O1** and **/O2** optimizations has been improved. In general, an application compiled with one of these options will be faster than the same application compiled with an earlier compiler.  \n  \n For more information, see [/GL (Whole Program Optimization)](../../build/reference/gl-whole-program-optimization.md) and [/O1, /O2 (Minimize Size, Maximize Speed)](../../build/reference/o1-o2-minimize-size-maximize-speed.md).  \n  \n### Which Level of Optimization Should I Use?  \n If at all possible, final release builds should be compiled with Profile Guided Optimizations. If it is not possible to build with PGO, whether due to insufficient infrastructure for running the instrumented builds or not having access to scenarios, then we suggest building with Whole Program Optimization.  \n  \n The **/Gy** switch is also very useful. It generates a separate COMDAT for each function, giving the linker more flexibility when it comes to removing unreferenced COMDATs and COMDAT folding. The only downside to using **/Gy** is that it can have a minor effect on build time. Therefore, it is generally recommended to use it. For more information, see [/Gy (Enable Function-Level Linking)](../../build/reference/gy-enable-function-level-linking.md).  \n  \n For linking in 64-bit environments, it is recommended to use the **/OPT:REF,ICF** linker option, and in 32-bit environments, **/OPT:REF** is recommended. For more information, see [/OPT (Optimizations)](../../build/reference/opt-optimizations.md).  \n  \n It is also strongly recommended to generate debug symbols, even with optimized release builds. It doesn’t effect the generated code, and it makes it a lot easier to debug your application, if need be.  \n  \n### Floating Point Switches  \n The **/Op** compiler option has been removed, and the following four compiler options dealing with floating point optimizations have been added:  \n  \n|||  \n|-|-|  \n|**/fp:precise**|This is the default recommendation and should be used in most cases.|  \n|**/fp:fast**|Recommended if performance is of the utmost importance, for example in games. This will result in the fastest performance.|  \n|**/fp:strict**|Recommended if precise floating-point exceptions and IEEE behavior is desired. This will result in the slowest performance.|  \n|**/fp:except[-]**|Can be used in conjunction with **/fp:strict** or **/fp:precise**, but not **/fp:fast**.|  \n  \n For more information, see [/fp (Specify Floating-Point Behavior)](../../build/reference/fp-specify-floating-point-behavior.md).  \n  \n## Optimization Declspecs  \n In this section we will look at two declspecs that can be used in programs to help performance: `__declspec(restrict)` and `__declspec(noalias)`.  \n  \n The `restrict` declspec can only be applied to function declarations that return a pointer, such as `__declspec(restrict) void *malloc(size_t size);`  \n  \n The `restrict` declspec is used on functions that return unaliased pointers. This keyword is used for the C-Runtime Library implementation of `malloc` since it will never return a pointer value that is already in use in the current program (unless you are doing something illegal, such as using memory after it has been freed).  \n  \n The `restrict` declspec gives the compiler more information for performing compiler optimizations. One of the hardest things for a compiler to determine is what pointers alias other pointers, and using this information greatly helps the compiler.  \n  \n It is worth pointing out that this is a promise to the compiler, not something that the compiler will verify. If your program uses this `restrict` declspec inappropriately, your program may have incorrect behavior.  \n  \n For more information, see [restrict](../../cpp/restrict.md).  \n  \n The `noalias` declspec is also applied only to functions, and indicates that the function is a semi-pure function. A semi-pure function is one that references or modifies only locals, arguments, and first-level indirections of arguments. This declspec is a promise to the compiler, and if the function references globals or second-level indirections of pointer arguments then the compiler may generate code that breaks the application.  \n  \n For more information, see [noalias](../../cpp/noalias.md).  \n  \n## Optimization Pragmas  \n There are also several useful pragmas for helping optimize code. The first one we’ll discuss is `#pragma optimize`:  \n  \n```  \n#pragma optimize(\"{opt-list}\", on | off)  \n```  \n  \n This pragma allows you to set a given optimization level on a function-by-function basis. This is ideal for those rare occasions where your application crashes when a given function is compiled with optimization. You can use this to turn off optimizations for a single function:  \n  \n```  \n#pragma optimize(\"\", off)  \nint myFunc() {...}  \n#pragma optimize(\"\", on)  \n```  \n  \n For more information, see [optimize](../../preprocessor/optimize.md).  \n  \n Inlining is one of the most important optimizations that the compiler performs and here we talk about a couple of the pragmas that help modify this behavior.  \n  \n `#pragma inline_recursion` is useful for specifying whether or not you want the application to be able to inline a recursive call. By default it is off. For shallow recursion of small functions you may to turn this on. For more information, see [inline_recursion](../../preprocessor/inline-recursion.md).  \n  \n Another useful pragma for limiting the depth of inlining is `#pragma inline_depth`. This is typically useful in situations where you’re trying to limit the size of a program or function. For more information, see [inline_depth](../../preprocessor/inline-depth.md).  \n  \n## __restrict and \\__assume  \n There are a couple of keywords in Visual C++ that can help performance: [__restrict](../../cpp/extension-restrict.md) and [__assume](../../intrinsics/assume.md).  \n  \n First, it should be noted that `__restrict` and `__declspec(restrict)` are two different things. While they are somewhat related, their semantics are different. `__restrict` is a type qualifier, like `const` or `volatile`, but exclusively for pointer types.  \n  \n A pointer that is modified with `__restrict` is referred to as a *__restrict pointer*. A __restrict pointer is a pointer that can only be accessed through the \\__restrict pointer. In other words, another pointer cannot be used to access the data pointed to by the \\__restrict pointer.  \n  \n `__restrict` can be a powerful tool for the Visual C++ optimizer, but use it with great care. If used improperly, the optimizer might perform an optimization that would break your application.  \n  \n The `__restrict` keyword replaces the **/Oa** switch from previous versions.  \n  \n With `__assume,` a developer can tell the compiler to make assumptions about the value of some variable.  \n  \n For example `__assume(a < 5);` tells the optimizer that at that line of code the variable `a` is less than 5. Again this is a promise to the compiler. If `a` is actually 6 at this point in the program then the behavior of the program after the compiler has optimized may not be what you would expect. `__assume` is most useful prior to switch statements and/or conditional expressions.  \n  \n There are some limitations to `__assume`. First, like `__restrict`, it is only a suggestion, so the compiler is free to ignore it. Also, `__assume` currently works only with variable inequalities against constants. It does not propagate symbolic inequalities, for example, assume(a < b).  \n  \n## Intrinsic Support  \n Intrinsics are function calls where the compiler has intrinsic knowledge about the call, and rather than calling a function in a library, it emits code for that function. The header file intrin.h located at <Installation_Directory>\\VC\\include\\intrin.h contains all of the available intrinsics for each of the three supported platforms (x86, x64, and ARM).  \n  \n Intrinsics give the programmer the ability to go deep into the code without having to use assembly. There are several benefits to using intrinsics:  \n  \n1.  Your code is more portable. Several of the intrinsics are available on multiple CPU architectures.  \n  \n2.  Your code is easier to read, since the code is still written in C/C++.  \n  \n3.  Your code gets the benefit of compiler optimizations. As the compiler gets better, the code generation for the intrinsics improves.  \n  \n For more information, see [Compiler Intrinsics](../../intrinsics/compiler-intrinsics.md) and [Benefits of Using Intrinsics](http://msdn.microsoft.com/en-us/57af8920-527f-44af-a741-a07cbe80bf02).  \n  \n## Exceptions  \n There is a performance hit associated with using exceptions. Some restrictions are introduced when using try blocks that inhibit the compiler from performing certain optimizations. On x86 platforms there is additional performance degradation from try blocks due to additional state information that must be generated during code execution. On the 64-bit platforms, try blocks do not degrade performance as much, but once an exception is thrown, the process of finding the handler and unwinding the stack can be expensive.  \n  \n Therefore, it is recommended to avoid introducing try/catch blocks into code that does not really need it. If you must use exceptions, use synchronous exceptions if possible. For more information, see [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md).  \n  \n Lastly, throw exceptions for exceptional cases only. Using exceptions for general control flow will likely make performance suffer.  \n  \n## See Also  \n [Optimizing Your Code](../../build/reference/optimizing-your-code.md)"}