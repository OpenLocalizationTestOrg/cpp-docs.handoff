{"nodes":[{"pos":[12,50],"content":"CReBar vs. CReBarCtrl | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CReBar vs. CReBarCtrl | Microsoft Docs","pos":[0,38]}]},{"content":"CReBar vs. CReBarCtrl","pos":[696,717]},{"content":"MFC provides two classes to create rebars: <bpt id=\"p1\">[</bpt>CReBar<ept id=\"p1\">](../mfc/reference/crebar-class.md)</ept> and <bpt id=\"p2\">[</bpt>CReBarCtrl<ept id=\"p2\">](../mfc/reference/crebarctrl-class.md)</ept> (which wraps the Windows common control API).","pos":[718,904],"source":"MFC provides two classes to create rebars: [CReBar](../mfc/reference/crebar-class.md) and [CReBarCtrl](../mfc/reference/crebarctrl-class.md) (which wraps the Windows common control API)."},{"content":"<bpt id=\"p1\">**</bpt>CReBar<ept id=\"p1\">**</ept> provides all of the functionality of the rebar common control, and it handles many of the required common control settings and structures for you.","pos":[905,1062],"source":"**CReBar** provides all of the functionality of the rebar common control, and it handles many of the required common control settings and structures for you."},{"content":"is a wrapper class for the Win32 rebar control, and therefore may be easier to implement if you do not intend to integrate the rebar into the MFC architecture.","pos":[1082,1241]},{"content":"If you plan to use <ph id=\"ph1\">`CReBarCtrl`</ph> and integrate the rebar into the MFC architecture, you must take additional care to communicate rebar control manipulations to MFC.","pos":[1242,1405],"source":" If you plan to use `CReBarCtrl` and integrate the rebar into the MFC architecture, you must take additional care to communicate rebar control manipulations to MFC."},{"content":"This communication is not difficult; however, it is additional work that is unneeded when you use <bpt id=\"p1\">**</bpt>CReBar<ept id=\"p1\">**</ept>.","pos":[1406,1515],"source":" This communication is not difficult; however, it is additional work that is unneeded when you use **CReBar**."},{"content":"Visual C++ provides two ways to take advantage of the rebar common control.","pos":[1522,1597]},{"pos":[1607,1785],"content":"Create the rebar using <bpt id=\"p1\">**</bpt>CReBar<ept id=\"p1\">**</ept>, and then call <bpt id=\"p2\">[</bpt>CReBar::GetReBarCtrl<ept id=\"p2\">](../mfc/reference/crebar-class.md#crebar__getrebarctrl)</ept> to get access to the <ph id=\"ph1\">`CReBarCtrl`</ph> member functions.","source":"Create the rebar using **CReBar**, and then call [CReBar::GetReBarCtrl](../mfc/reference/crebar-class.md#crebar__getrebarctrl) to get access to the `CReBarCtrl` member functions."},{"pos":[1797,1981],"content":"[!NOTE]\n `CReBar::GetReBarCtrl` is an inline member function that casts the **this** pointer of the rebar object. This means that, at run time, the function call has no overhead.","leadings":["","    > "],"nodes":[{"content":" is an inline member function that casts the **this** pointer of the rebar object. This means that, at run time, the function call has no overhead.","pos":[31,178],"nodes":[{"content":"is an inline member function that casts the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> pointer of the rebar object.","pos":[1,82],"source":" is an inline member function that casts the **this** pointer of the rebar object."},{"content":"This means that, at run time, the function call has no overhead.","pos":[83,147]}]}]},{"pos":[1991,2079],"content":"Create the rebar using <bpt id=\"p1\">[</bpt>CReBarCtrl<ept id=\"p1\">](../mfc/reference/crebarctrl-class.md)</ept>'s constructor.","source":"Create the rebar using [CReBarCtrl](../mfc/reference/crebarctrl-class.md)'s constructor."},{"content":"Either method will give you access to the member functions of the rebar control.","pos":[2086,2166]},{"content":"When you call <ph id=\"ph1\">`CReBar::GetReBarCtrl`</ph>, it returns a reference to a <ph id=\"ph2\">`CReBarCtrl`</ph> object so you can use either set of member functions.","pos":[2167,2299],"source":" When you call `CReBar::GetReBarCtrl`, it returns a reference to a `CReBarCtrl` object so you can use either set of member functions."},{"content":"See <bpt id=\"p1\">[</bpt>CReBar<ept id=\"p1\">](../mfc/reference/crebar-class.md)</ept> for information on constructing and creating a rebar using <bpt id=\"p2\">**</bpt>CReBar<ept id=\"p2\">**</ept>.","pos":[2300,2417],"source":" See [CReBar](../mfc/reference/crebar-class.md) for information on constructing and creating a rebar using **CReBar**."},{"content":"See Also","pos":[2426,2434]},{"content":"Using CReBarCtrl","pos":[2439,2455]},{"content":"Controls","pos":[2490,2498]}],"content":"---\ntitle: \"CReBar vs. CReBarCtrl | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"CReBar\"\n  - \"CReBarCtrl\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CReBar class, vs. CReBarCtrl\"\n  - \"rebar controls, CReBarCtrl class\"\n  - \"GetReBarCtrl class\"\nms.assetid: 7f9c1d7e-5d5f-4956-843c-69ed3df688d0\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CReBar vs. CReBarCtrl\nMFC provides two classes to create rebars: [CReBar](../mfc/reference/crebar-class.md) and [CReBarCtrl](../mfc/reference/crebarctrl-class.md) (which wraps the Windows common control API). **CReBar** provides all of the functionality of the rebar common control, and it handles many of the required common control settings and structures for you.  \n  \n `CReBarCtrl` is a wrapper class for the Win32 rebar control, and therefore may be easier to implement if you do not intend to integrate the rebar into the MFC architecture. If you plan to use `CReBarCtrl` and integrate the rebar into the MFC architecture, you must take additional care to communicate rebar control manipulations to MFC. This communication is not difficult; however, it is additional work that is unneeded when you use **CReBar**.  \n  \n Visual C++ provides two ways to take advantage of the rebar common control.  \n  \n-   Create the rebar using **CReBar**, and then call [CReBar::GetReBarCtrl](../mfc/reference/crebar-class.md#crebar__getrebarctrl) to get access to the `CReBarCtrl` member functions.  \n  \n    > [!NOTE]\n    >  `CReBar::GetReBarCtrl` is an inline member function that casts the **this** pointer of the rebar object. This means that, at run time, the function call has no overhead.  \n  \n-   Create the rebar using [CReBarCtrl](../mfc/reference/crebarctrl-class.md)'s constructor.  \n  \n Either method will give you access to the member functions of the rebar control. When you call `CReBar::GetReBarCtrl`, it returns a reference to a `CReBarCtrl` object so you can use either set of member functions. See [CReBar](../mfc/reference/crebar-class.md) for information on constructing and creating a rebar using **CReBar**.  \n  \n## See Also  \n [Using CReBarCtrl](../mfc/using-crebarctrl.md)   \n [Controls](../mfc/controls-mfc.md)\n\n"}