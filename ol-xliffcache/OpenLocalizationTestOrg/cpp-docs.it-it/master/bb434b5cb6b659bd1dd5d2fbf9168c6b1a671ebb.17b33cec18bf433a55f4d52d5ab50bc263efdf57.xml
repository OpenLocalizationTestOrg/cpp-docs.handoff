{"nodes":[{"pos":[12,64],"content":"Using C++ AMP in Windows Store Apps | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using C++ AMP in Windows Store Apps | Microsoft Docs","pos":[0,52]}]},{"content":"Using C++ AMP in Windows Store Apps","pos":[545,580]},{"content":"You can use C++ AMP (C++ Accelerated Massive Parallelism) in your <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app to perform calculations on the GPU (Graphics Processing Unit) or other computational accelerators.","pos":[581,825],"source":"You can use C++ AMP (C++ Accelerated Massive Parallelism) in your [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app to perform calculations on the GPU (Graphics Processing Unit) or other computational accelerators."},{"content":"However, C++ AMP doesn't provide APIs for working directly with Windows Runtime types, and the Windows Runtime doesn't provide a wrapper for C++ AMP.","pos":[826,975]},{"content":"When you use Windows Runtime types in your code—including those that you've created yourself—you must convert them to types that are compatible with C++ AMP.","pos":[976,1133]},{"content":"Performance considerations","pos":[1142,1168]},{"content":"If you're using <ph id=\"ph1\">[!INCLUDE[cppwrt](../../build/reference/includes/cppwrt_md.md)]</ph> (<ph id=\"ph2\">[!INCLUDE[cppwrt_short](../../build/reference/includes/cppwrt_short_md.md)]</ph>) to create your <ph id=\"ph3\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, we recommend that you use plain-old-data (POD) types together with contiguous storage—for example, <ph id=\"ph4\">`std::vector`</ph> or C-style arrays—for data that will be used with C++ AMP.","pos":[1172,1597],"source":"If you're using [!INCLUDE[cppwrt](../../build/reference/includes/cppwrt_md.md)] ([!INCLUDE[cppwrt_short](../../build/reference/includes/cppwrt_short_md.md)]) to create your [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, we recommend that you use plain-old-data (POD) types together with contiguous storage—for example, `std::vector` or C-style arrays—for data that will be used with C++ AMP."},{"content":"This can help you achieve higher performance than by using non-POD types or Windows RT containers because no marshaling has to occur.","pos":[1598,1731]},{"pos":[1738,1948],"content":"In a C++ AMP kernel, to access data that’s stored in this way, just wrap the <ph id=\"ph1\">`std::vector`</ph> or array storage in a <ph id=\"ph2\">`concurrency::array_view`</ph> and then use the array view in a <ph id=\"ph3\">`concurrency::parallel_for_each`</ph> loop:","source":"In a C++ AMP kernel, to access data that’s stored in this way, just wrap the `std::vector` or array storage in a `concurrency::array_view` and then use the array view in a `concurrency::parallel_for_each` loop:"},{"content":"Marshaling Windows Runtime types","pos":[2469,2501]},{"content":"When you work with Windows Runtime APIs, you might want to use C++ AMP on data that's stored in a Windows Runtime container such as a <ph id=\"ph1\">`Platform::Array&lt;T&gt;^`</ph> or in complex data types such as classes or structs that are declared by using the <ph id=\"ph2\">`ref`</ph> keyword or the <ph id=\"ph3\">`value`</ph> keyword.","pos":[2505,2781],"source":"When you work with Windows Runtime APIs, you might want to use C++ AMP on data that's stored in a Windows Runtime container such as a `Platform::Array<T>^` or in complex data types such as classes or structs that are declared by using the `ref` keyword or the `value` keyword."},{"content":"In these situations, you have to do some extra work to make the data available to C++ AMP.","pos":[2782,2872]},{"content":"Platform::Array<ph id=\"ph1\">\\&lt;</ph>T&gt;^, where T is a POD type","pos":[2882,2925],"source":"Platform::Array\\<T>^, where T is a POD type"},{"pos":[2929,3071],"content":"When you encounter a <ph id=\"ph1\">`Platform::Array&lt;T&gt;^`</ph> and T is a POD type, you can access its underlying storage just by using the <ph id=\"ph2\">`get`</ph> member function:","source":"When you encounter a `Platform::Array<T>^` and T is a POD type, you can access its underlying storage just by using the `get` member function:"},{"content":"If T is not a POD type, use the technique that's described in the following section to use the data with C++ AMP.","pos":[3253,3366]},{"content":"Windows Runtime types: ref classes and value classes","pos":[3376,3428]},{"content":"C++ AMP doesn't support complex data types.","pos":[3432,3475]},{"content":"This includes non-POD types and any types that are declared by using the <ph id=\"ph1\">`ref`</ph> keyword or the <ph id=\"ph2\">`value`</ph> keyword.","pos":[3476,3586],"source":" This includes non-POD types and any types that are declared by using the `ref` keyword or the `value` keyword."},{"content":"If an unsupported type is used in a <ph id=\"ph1\">`restrict(amp)`</ph> context, a compile-time error is generated.","pos":[3587,3682],"source":" If an unsupported type is used in a `restrict(amp)` context, a compile-time error is generated."},{"content":"When you encounter an unsupported type, you can copy interesting parts of its data into a <ph id=\"ph1\">`concurrency::array`</ph> object.","pos":[3689,3807],"source":"When you encounter an unsupported type, you can copy interesting parts of its data into a `concurrency::array` object."},{"content":"In addition to making the data available for C++ AMP to consume, this manual-copy approach can also improve performance by maximizing data locality, and by ensuring that data that won't be used isn't copied to the accelerator.","pos":[3808,4034]},{"content":"You can improve performance further by using a <bpt id=\"p1\">*</bpt>staging array<ept id=\"p1\">*</ept>, which is a special form of <ph id=\"ph1\">`concurrency::array`</ph> that provides a hint to the AMP runtime that the array should be optimized for frequent transfer between it and other arrays on the specified accelerator.","pos":[4035,4301],"source":" You can improve performance further by using a *staging array*, which is a special form of `concurrency::array` that provides a hint to the AMP runtime that the array should be optimized for frequent transfer between it and other arrays on the specified accelerator."},{"content":"See Also","pos":[5844,5852]},{"content":"Create your first Windows Store app using C++","pos":[5857,5902]},{"content":"Creating Windows Runtime Components in C++","pos":[5957,5999]}],"content":"---\ntitle: \"Using C++ AMP in Windows Store Apps | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 85577298-2c28-4209-9470-eb21048615db\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using C++ AMP in Windows Store Apps\nYou can use C++ AMP (C++ Accelerated Massive Parallelism) in your [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app to perform calculations on the GPU (Graphics Processing Unit) or other computational accelerators. However, C++ AMP doesn't provide APIs for working directly with Windows Runtime types, and the Windows Runtime doesn't provide a wrapper for C++ AMP. When you use Windows Runtime types in your code—including those that you've created yourself—you must convert them to types that are compatible with C++ AMP.  \n  \n## Performance considerations  \n If you're using [!INCLUDE[cppwrt](../../build/reference/includes/cppwrt_md.md)] ([!INCLUDE[cppwrt_short](../../build/reference/includes/cppwrt_short_md.md)]) to create your [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, we recommend that you use plain-old-data (POD) types together with contiguous storage—for example, `std::vector` or C-style arrays—for data that will be used with C++ AMP. This can help you achieve higher performance than by using non-POD types or Windows RT containers because no marshaling has to occur.  \n  \n In a C++ AMP kernel, to access data that’s stored in this way, just wrap the `std::vector` or array storage in a `concurrency::array_view` and then use the array view in a `concurrency::parallel_for_each` loop:  \n  \n```cpp  \n *// simple vector addition example  \nstd::vector<int> data0(1024, 1);\n\nstd::vector<int> data1(1024, 2);\n\nstd::vector<int> data_out(data0.size(), 0);\n\n \nconcurrency::array_view<int, 1> av0(data0.size(), data0);\n\nconcurrency::array_view<int, 1> av1(data1.size(), data1);\n\nconcurrency::array_view<int, 1> av2(data_out.size(), data2);\n\n \nav2.discard_data();\n\n \nconcurrency::parallel_for_each(av0.extent, [=](concurrency::index<1> idx) restrict(amp)  \n{  \n    av2[idx] = av0[idx] + av1[idx];  \n});\n```  \n  \n## Marshaling Windows Runtime types  \n When you work with Windows Runtime APIs, you might want to use C++ AMP on data that's stored in a Windows Runtime container such as a `Platform::Array<T>^` or in complex data types such as classes or structs that are declared by using the `ref` keyword or the `value` keyword. In these situations, you have to do some extra work to make the data available to C++ AMP.  \n  \n### Platform::Array\\<T>^, where T is a POD type  \n When you encounter a `Platform::Array<T>^` and T is a POD type, you can access its underlying storage just by using the `get` member function:  \n  \n```cpp  \nPlatform::Array<float>^ arr; // Assume that this was returned by a Windows Runtime API  \nconcurrency::array_view<float, 1> av(arr->Length, &arr->get(0));\n\n \n```  \n  \n If T is not a POD type, use the technique that's described in the following section to use the data with C++ AMP.  \n  \n### Windows Runtime types: ref classes and value classes  \n C++ AMP doesn't support complex data types. This includes non-POD types and any types that are declared by using the `ref` keyword or the `value` keyword. If an unsupported type is used in a `restrict(amp)` context, a compile-time error is generated.  \n  \n When you encounter an unsupported type, you can copy interesting parts of its data into a `concurrency::array` object. In addition to making the data available for C++ AMP to consume, this manual-copy approach can also improve performance by maximizing data locality, and by ensuring that data that won't be used isn't copied to the accelerator. You can improve performance further by using a *staging array*, which is a special form of `concurrency::array` that provides a hint to the AMP runtime that the array should be optimized for frequent transfer between it and other arrays on the specified accelerator.  \n  \n```cpp  \n// pixel_color.h  \nref class pixel_color sealed  \n{  \n    public: \n    pixel_color(Platform::String^ color_name, int red, int green, int blue)   \n {  \n    name = color_name;  \n    r = red;  \n    g = green;  \n    b = blue;  \n }  \n \n    property Platform::String^ name;   \n    property int r;  \n    property int g;  \n..property int b;  \n};  \n \n// Some other file  \nstd::vector<pixel_color^> pixels (256);\n\n \nfor(pixel_color ^pixel : pixels)   \n{  \n    pixels.push_back(ref new pixel_color(\"blue\", 0, 0, 255));\n\n}  \n// Create the accelerators  \nauto cpuAccelerator = concurrency::accelerator(concurrency::accelerator::cpu_accelerator);\n\nauto devAccelerator = concurrency::accelerator(concurrency::accelerator::default_accelerator);\n\n \n// Create the staging arrays  \nconcurrency::array<float, 1> red_vec(256, cpuAccelerator.default_view, devAccelerator.default_view);\n\nconcurrency::array<float, 1>  blue_vec(256, cpuAccelerator.default_view, devAccelerator.default_view);\n\n \n// Extract data from the complex array of structs into staging arrays.  \nconcurrency::parallel_for(0, 256, [&](int i)  \n{   \n    red_vec[i] = pixels[i]->r;blue_vec[i] = pixels[i]->b;  \n});\n\n \n// Array views are still used to copy data to the accelerator  \nconcurrency::array_view<float, 1> av_red(red_vec);\n\nconcurrency::array_view<float, 1> av_blue(blue_vec);\n\n \n// Change all pixels from blue to red.  \nconcurrency::parallel_for_each(av_red.extent, [=](index<1> idx) restrict(amp)  \n{  \n    av_red[idx] = 255;  \n    av_blue[idx] = 0;  \n});\n\n \n```  \n  \n## See Also  \n [Create your first Windows Store app using C++](http://go.microsoft.com/fwlink/p/linkid=249073)   \n [Creating Windows Runtime Components in C++](http://go.microsoft.com/fwlink/p/linkid=249076)\n\n\n\n"}