{"nodes":[{"pos":[12,60],"content":"Parallel Containers and Objects | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Parallel Containers and Objects | Microsoft Docs","pos":[0,48]}]},{"content":"Parallel Containers and Objects","pos":[640,671]},{"content":"The Parallel Patterns Library (PPL) includes several containers and objects that provide thread-safe access to their elements.","pos":[672,798]},{"content":"A <bpt id=\"p1\">*</bpt>concurrent container<ept id=\"p1\">*</ept> provides concurrency-safe access to the most important operations.","pos":[805,896],"source":"A *concurrent container* provides concurrency-safe access to the most important operations."},{"content":"The functionality of these containers resembles those that are provided by the Standard Template Library (STL).","pos":[897,1008]},{"content":"For example, the <bpt id=\"p1\">[</bpt>concurrency::concurrent_vector<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-vector-class.md)</ept> class resembles the <bpt id=\"p2\">[</bpt>std::vector<ept id=\"p2\">](../../standard-library/vector-class.md)</ept> class, except that the <ph id=\"ph1\">`concurrent_vector`</ph> class lets you append elements in parallel.","pos":[1009,1279],"source":" For example, the [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) class resembles the [std::vector](../../standard-library/vector-class.md) class, except that the `concurrent_vector` class lets you append elements in parallel."},{"content":"Use concurrent containers when you have parallel code that requires both read and write access to the same container.","pos":[1280,1397]},{"content":"A <bpt id=\"p1\">*</bpt>concurrent object<ept id=\"p1\">*</ept> is shared concurrently among components.","pos":[1404,1466],"source":"A *concurrent object* is shared concurrently among components."},{"content":"A process that computes the state of a concurrent object in parallel produces the same result as another process that computes the same state serially.","pos":[1467,1618]},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::combinable<ept id=\"p1\">](../../parallel/concrt/reference/combinable-class.md)</ept> class is one example of a concurrent object type.","pos":[1619,1751],"source":" The [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) class is one example of a concurrent object type."},{"content":"The <ph id=\"ph1\">`combinable`</ph> class lets you perform computations in parallel, and then combine those computations into a final result.","pos":[1752,1874],"source":" The `combinable` class lets you perform computations in parallel, and then combine those computations into a final result."},{"content":"Use concurrent objects when you would otherwise use a synchronization mechanism, for example, a mutex, to synchronize access to a shared variable or resource.","pos":[1875,2033]},{"pos":[2062,2070],"content":"Sections"},{"content":"This topic describes the following parallel containers and objects in detail.","pos":[2074,2151]},{"content":"Concurrent containers:","pos":[2158,2180]},{"content":"concurrent_vector Class","pos":[2191,2214]},{"content":"Differences Between concurrent_vector and vector","pos":[2237,2285]},{"content":"Concurrency-Safe Operations","pos":[2308,2335]},{"content":"Exception Safety","pos":[2358,2374]},{"content":"concurrent_queue Class","pos":[2393,2415]},{"content":"Differences Between concurrent_queue and queue","pos":[2439,2485]},{"content":"Concurrency-Safe Operations","pos":[2521,2548]},{"content":"Iterator Support","pos":[2579,2595]},{"content":"concurrent_unordered_map Class","pos":[2625,2655]},{"content":"Differences Between concurrent_unordered_map and unordered_map","pos":[2687,2749]},{"content":"Concurrency-Safe Operations","pos":[2783,2810]},{"content":"concurrent_unordered_multimap Class","pos":[2835,2870]},{"content":"concurrent_unordered_set Class","pos":[2903,2933]},{"content":"concurrent_unordered_multiset Class","pos":[2961,2996]},{"content":"Concurrent objects:","pos":[3025,3044]},{"content":"combinable Class","pos":[3055,3071]},{"content":"Methods and Features","pos":[3100,3120]},{"content":"Examples","pos":[3158,3166]},{"pos":[3221,3244],"content":"concurrent_vector Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::concurrent_vector<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-vector-class.md)</ept> class is a sequence container class that, just like the <bpt id=\"p2\">[</bpt>std::vector<ept id=\"p2\">](../../standard-library/vector-class.md)</ept> class, lets you randomly access its elements.","pos":[3248,3500],"source":"The [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) class is a sequence container class that, just like the [std::vector](../../standard-library/vector-class.md) class, lets you randomly access its elements."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class enables concurrency-safe append and element access operations.","pos":[3501,3593],"source":" The `concurrent_vector` class enables concurrency-safe append and element access operations."},{"content":"Append operations do not invalidate existing pointers or iterators.","pos":[3594,3661]},{"content":"Iterator access and traversal operations are also concurrency-safe.","pos":[3662,3729]},{"pos":[3774,3822],"content":"Differences Between concurrent_vector and vector"},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class closely resembles the <ph id=\"ph2\">`vector`</ph> class.","pos":[3826,3893],"source":"The `concurrent_vector` class closely resembles the `vector` class."},{"content":"The complexity of append, element access, and iterator access operations on a <ph id=\"ph1\">`concurrent_vector`</ph> object are the same as for a <ph id=\"ph2\">`vector`</ph> object.","pos":[3894,4037],"source":" The complexity of append, element access, and iterator access operations on a `concurrent_vector` object are the same as for a `vector` object."},{"content":"The following points illustrate where <ph id=\"ph1\">`concurrent_vector`</ph> differs from <ph id=\"ph2\">`vector`</ph>:","pos":[4038,4118],"source":" The following points illustrate where `concurrent_vector` differs from `vector`:"},{"pos":[4128,4256],"content":"Append, element access, iterator access, and iterator traversal operations on a <ph id=\"ph1\">`concurrent_vector`</ph> object are concurrency-safe.","source":"Append, element access, iterator access, and iterator traversal operations on a `concurrent_vector` object are concurrency-safe."},{"content":"You can add elements only to the end of a <ph id=\"ph1\">`concurrent_vector`</ph> object.","pos":[4266,4335],"source":"You can add elements only to the end of a `concurrent_vector` object."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class does not provide the <ph id=\"ph2\">`insert`</ph> method.","pos":[4336,4403],"source":" The `concurrent_vector` class does not provide the `insert` method."},{"pos":[4413,4544],"content":"A <ph id=\"ph1\">`concurrent_vector`</ph> object does not use <bpt id=\"p1\">[</bpt>move semantics<ept id=\"p1\">](../../cpp/rvalue-reference-declarator-amp-amp.md)</ept> when you append to it.","source":"A `concurrent_vector` object does not use [move semantics](../../cpp/rvalue-reference-declarator-amp-amp.md) when you append to it."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class does not provide the <ph id=\"ph2\">`erase`</ph> or <ph id=\"ph3\">`pop_back`</ph> methods.","pos":[4555,4636],"source":"The `concurrent_vector` class does not provide the `erase` or `pop_back` methods."},{"content":"As with <ph id=\"ph1\">`vector`</ph>, use the <bpt id=\"p1\">[</bpt>clear<ept id=\"p1\">](reference/concurrent-vector-class.md#clear)</ept> method to remove all elements from a <ph id=\"ph2\">`concurrent_vector`</ph> object.","pos":[4637,4779],"source":" As with `vector`, use the [clear](reference/concurrent-vector-class.md#clear) method to remove all elements from a `concurrent_vector` object."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class does not store its elements contiguously in memory.","pos":[4789,4870],"source":"The `concurrent_vector` class does not store its elements contiguously in memory."},{"content":"Therefore, you cannot use the <ph id=\"ph1\">`concurrent_vector`</ph> class in all the ways that you can use an array.","pos":[4871,4969],"source":" Therefore, you cannot use the `concurrent_vector` class in all the ways that you can use an array."},{"content":"For example, for a variable named <ph id=\"ph1\">`v`</ph> of type <ph id=\"ph2\">`concurrent_vector`</ph>, the expression <ph id=\"ph3\">`&amp;v[0]+2`</ph> produces undefined behavior.","pos":[4970,5090],"source":" For example, for a variable named `v` of type `concurrent_vector`, the expression `&v[0]+2` produces undefined behavior."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class defines the <bpt id=\"p1\">[</bpt>grow_by<ept id=\"p1\">](reference/concurrent-vector-class.md#grow_by)</ept> and <bpt id=\"p2\">[</bpt>grow_to_at_least<ept id=\"p2\">](reference/concurrent-vector-class.md#grow_to_at_least)</ept> methods.","pos":[5100,5284],"source":"The `concurrent_vector` class defines the [grow_by](reference/concurrent-vector-class.md#grow_by) and [grow_to_at_least](reference/concurrent-vector-class.md#grow_to_at_least) methods."},{"content":"These methods resemble the <bpt id=\"p1\">[</bpt>resize<ept id=\"p1\">](reference/concurrent-vector-class.md#resize)</ept> method, except that they are concurrency-safe.","pos":[5285,5412],"source":" These methods resemble the [resize](reference/concurrent-vector-class.md#resize) method, except that they are concurrency-safe."},{"content":"A <ph id=\"ph1\">`concurrent_vector`</ph> object does not relocate its elements when you append to it or resize it.","pos":[5422,5517],"source":"A `concurrent_vector` object does not relocate its elements when you append to it or resize it."},{"content":"This enables existing pointers and iterators to remain valid during concurrent operations.","pos":[5518,5608]},{"pos":[5618,5707],"content":"The runtime does not define a specialized version of <ph id=\"ph1\">`concurrent_vector`</ph> for type <ph id=\"ph2\">`bool`</ph>.","source":"The runtime does not define a specialized version of `concurrent_vector` for type `bool`."},{"pos":[5747,5774],"content":"Concurrency-Safe Operations"},{"content":"All methods that append to or increase the size of a <ph id=\"ph1\">`concurrent_vector`</ph> object, or access an element in a <ph id=\"ph2\">`concurrent_vector`</ph> object, are concurrency-safe.","pos":[5778,5934],"source":"All methods that append to or increase the size of a `concurrent_vector` object, or access an element in a `concurrent_vector` object, are concurrency-safe."},{"content":"The exception to this rule is the <ph id=\"ph1\">`resize`</ph> method.","pos":[5935,5985],"source":" The exception to this rule is the `resize` method."},{"pos":[5992,6097],"content":"The following table shows the common <ph id=\"ph1\">`concurrent_vector`</ph> methods and operators that are concurrency-safe.","source":"The following table shows the common `concurrent_vector` methods and operators that are concurrency-safe."},{"content":"<bpt id=\"p1\">[</bpt>at<ept id=\"p1\">](reference/concurrent-vector-class.md#at)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>end<ept id=\"p2\">](reference/concurrent-vector-class.md#end)</ept><ph id=\"ph2\">|</ph><bpt id=\"p3\">[</bpt>operator&amp;#91;&amp;#93;<ept id=\"p3\">](reference/concurrent-vector-class.md#operator_at)</ept>","pos":[6122,6286],"source":"[at](reference/concurrent-vector-class.md#at)|[end](reference/concurrent-vector-class.md#end)|[operator&#91;&#93;](reference/concurrent-vector-class.md#operator_at)"},{"content":"<bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](reference/concurrent-vector-class.md#begin)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>front<ept id=\"p2\">](reference/concurrent-vector-class.md#front)</ept><ph id=\"ph2\">|</ph><bpt id=\"p3\">[</bpt>push_back<ept id=\"p3\">](reference/concurrent-vector-class.md#push_back)</ept>","pos":[6291,6454],"source":"[begin](reference/concurrent-vector-class.md#begin)|[front](reference/concurrent-vector-class.md#front)|[push_back](reference/concurrent-vector-class.md#push_back)"},{"content":"<bpt id=\"p1\">[</bpt>back<ept id=\"p1\">](reference/concurrent-vector-class.md#back)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>grow_by<ept id=\"p2\">](reference/concurrent-vector-class.md#grow_by)</ept><ph id=\"ph2\">|</ph><bpt id=\"p3\">[</bpt>rbegin<ept id=\"p3\">](reference/concurrent-vector-class.md#rbegin)</ept>","pos":[6459,6618],"source":"[back](reference/concurrent-vector-class.md#back)|[grow_by](reference/concurrent-vector-class.md#grow_by)|[rbegin](reference/concurrent-vector-class.md#rbegin)"},{"content":"<bpt id=\"p1\">[</bpt>capacity<ept id=\"p1\">](reference/concurrent-vector-class.md#capacity)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>grow_to_at_least<ept id=\"p2\">](reference/concurrent-vector-class.md#grow_to_at_least)</ept><ph id=\"ph2\">|</ph><bpt id=\"p3\">[</bpt>rend<ept id=\"p3\">](reference/concurrent-vector-class.md#rend)</ept>","pos":[6623,6804],"source":"[capacity](reference/concurrent-vector-class.md#capacity)|[grow_to_at_least](reference/concurrent-vector-class.md#grow_to_at_least)|[rend](reference/concurrent-vector-class.md#rend)"},{"content":"<bpt id=\"p1\">[</bpt>empty<ept id=\"p1\">](reference/concurrent-vector-class.md#empty)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>max_size<ept id=\"p2\">](reference/concurrent-vector-class.md#max_size)</ept><ph id=\"ph2\">|</ph><bpt id=\"p3\">[</bpt>size<ept id=\"p3\">](reference/concurrent-vector-class.md#size)</ept>","pos":[6809,6968],"source":"[empty](reference/concurrent-vector-class.md#empty)|[max_size](reference/concurrent-vector-class.md#max_size)|[size](reference/concurrent-vector-class.md#size)"},{"content":"Operations that the runtime provides for compatibility with the STL, for example, <ph id=\"ph1\">`reserve`</ph>, are not concurrency-safe.","pos":[6977,7095],"source":"Operations that the runtime provides for compatibility with the STL, for example, `reserve`, are not concurrency-safe."},{"content":"The following table shows the common methods and operators that are not concurrency-safe.","pos":[7096,7185]},{"content":"<bpt id=\"p1\">[</bpt>assign<ept id=\"p1\">](reference/concurrent-vector-class.md#assign)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>reserve<ept id=\"p2\">](reference/concurrent-vector-class.md#reserve)</ept>","pos":[7207,7316],"source":"[assign](reference/concurrent-vector-class.md#assign)|[reserve](reference/concurrent-vector-class.md#reserve)"},{"content":"<bpt id=\"p1\">[</bpt>clear<ept id=\"p1\">](reference/concurrent-vector-class.md#clear)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>resize<ept id=\"p2\">](reference/concurrent-vector-class.md#resize)</ept>","pos":[7321,7426],"source":"[clear](reference/concurrent-vector-class.md#clear)|[resize](reference/concurrent-vector-class.md#resize)"},{"content":"<bpt id=\"p1\">[</bpt>operator=<ept id=\"p1\">](reference/concurrent-vector-class.md#operator_eq)</ept><ph id=\"ph1\">|</ph><bpt id=\"p2\">[</bpt>shrink_to_fit<ept id=\"p2\">](reference/concurrent-vector-class.md#shrink_to_fit)</ept>","pos":[7431,7560],"source":"[operator=](reference/concurrent-vector-class.md#operator_eq)|[shrink_to_fit](reference/concurrent-vector-class.md#shrink_to_fit)"},{"content":"Operations that modify the value of existing elements are not concurrency-safe.","pos":[7568,7647]},{"content":"Use a synchronization object such as a <bpt id=\"p1\">[</bpt>reader_writer_lock<ept id=\"p1\">](../../parallel/concrt/reference/reader-writer-lock-class.md)</ept> object to synchronize concurrent read and write operations to the same data element.","pos":[7648,7853],"source":" Use a synchronization object such as a [reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) object to synchronize concurrent read and write operations to the same data element."},{"content":"For more information about synchronization objects, see <bpt id=\"p1\">[</bpt>Synchronization Data Structures<ept id=\"p1\">](../../parallel/concrt/synchronization-data-structures.md)</ept>.","pos":[7854,8002],"source":" For more information about synchronization objects, see [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md)."},{"content":"When you convert existing code that uses <ph id=\"ph1\">`vector`</ph> to use <ph id=\"ph2\">`concurrent_vector`</ph>, concurrent operations can cause the behavior of your application to change.","pos":[8009,8162],"source":"When you convert existing code that uses `vector` to use `concurrent_vector`, concurrent operations can cause the behavior of your application to change."},{"content":"For example, consider the following program that concurrently performs two tasks on a <ph id=\"ph1\">`concurrent_vector`</ph> object.","pos":[8163,8276],"source":" For example, consider the following program that concurrently performs two tasks on a `concurrent_vector` object."},{"content":"The first task appends additional elements to a <ph id=\"ph1\">`concurrent_vector`</ph> object.","pos":[8277,8352],"source":" The first task appends additional elements to a `concurrent_vector` object."},{"content":"The second task computes the sum of all elements in the same object.","pos":[8353,8421]},{"pos":[8439,8461],"content":"concrt-vector-safety#1"},{"content":"Although the <ph id=\"ph1\">`end`</ph> method is concurrency-safe, a concurrent call to the <bpt id=\"p1\">[</bpt>push_back<ept id=\"p1\">](reference/concurrent-vector-class.md#push_back)</ept> method causes the value that is returned by <ph id=\"ph2\">`end`</ph> to change.","pos":[8548,8740],"source":"Although the `end` method is concurrency-safe, a concurrent call to the [push_back](reference/concurrent-vector-class.md#push_back) method causes the value that is returned by `end` to change."},{"content":"The number of elements that the iterator traverses is indeterminate.","pos":[8741,8809]},{"content":"Therefore, this program can produce a different result each time that you run it.","pos":[8810,8891]},{"pos":[8935,8951],"content":"Exception Safety"},{"content":"If a growth or assignment operation throws an exception, the state of the <ph id=\"ph1\">`concurrent_vector`</ph> object becomes invalid.","pos":[8955,9072],"source":"If a growth or assignment operation throws an exception, the state of the `concurrent_vector` object becomes invalid."},{"content":"The behavior of a <ph id=\"ph1\">`concurrent_vector`</ph> object that is in an invalid state is undefined unless stated otherwise.","pos":[9073,9183],"source":" The behavior of a `concurrent_vector` object that is in an invalid state is undefined unless stated otherwise."},{"content":"However, the destructor always frees the memory that the object allocates, even if the object is in an invalid state.","pos":[9184,9301]},{"content":"The data type of the vector elements, <ph id=\"ph1\">`T`</ph>, must meet the following requirements.","pos":[9308,9388],"source":"The data type of the vector elements, `T`, must meet the following requirements."},{"content":"Otherwise, the behavior of the <ph id=\"ph1\">`concurrent_vector`</ph> class is undefined.","pos":[9389,9459],"source":" Otherwise, the behavior of the `concurrent_vector` class is undefined."},{"content":"The destructor must not throw.","pos":[9469,9499]},{"pos":[9509,9675],"content":"If the default or copy constructor throws, the destructor must not be declared by using the <ph id=\"ph1\">`virtual`</ph> keyword and it must work correctly with zero-initialized memory.","source":"If the default or copy constructor throws, the destructor must not be declared by using the `virtual` keyword and it must work correctly with zero-initialized memory."},{"pos":[9682,9695],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[9726,9748],"content":"concurrent_queue Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::concurrent_queue<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-queue-class.md)</ept> class, just like the <bpt id=\"p2\">[</bpt>std::queue<ept id=\"p2\">](../../standard-library/queue-class.md)</ept> class, lets you access its front and back elements.","pos":[9752,9971],"source":"The [concurrency::concurrent_queue](../../parallel/concrt/reference/concurrent-queue-class.md) class, just like the [std::queue](../../standard-library/queue-class.md) class, lets you access its front and back elements."},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class enables concurrency-safe enqueue and dequeue operations.","pos":[9972,10057],"source":" The `concurrent_queue` class enables concurrency-safe enqueue and dequeue operations."},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class also provides iterator support that is not concurrency-safe.","pos":[10058,10147],"source":" The `concurrent_queue` class also provides iterator support that is not concurrency-safe."},{"pos":[10191,10237],"content":"Differences Between concurrent_queue and queue"},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class closely resembles the <ph id=\"ph2\">`queue`</ph> class.","pos":[10241,10306],"source":"The `concurrent_queue` class closely resembles the `queue` class."},{"content":"The following points illustrate where <ph id=\"ph1\">`concurrent_queue`</ph> differs from <ph id=\"ph2\">`queue`</ph>:","pos":[10307,10385],"source":" The following points illustrate where `concurrent_queue` differs from `queue`:"},{"pos":[10395,10478],"content":"Enqueue and dequeue operations on a <ph id=\"ph1\">`concurrent_queue`</ph> object are concurrency-safe.","source":"Enqueue and dequeue operations on a `concurrent_queue` object are concurrency-safe."},{"pos":[10488,10572],"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class provides iterator support that is not concurrency-safe.","source":"The `concurrent_queue` class provides iterator support that is not concurrency-safe."},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class does not provide the <ph id=\"ph2\">`front`</ph> or <ph id=\"ph3\">`pop`</ph> methods.","pos":[10583,10658],"source":"The `concurrent_queue` class does not provide the `front` or `pop` methods."},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class replaces these methods by defining the <bpt id=\"p1\">[</bpt>try_pop<ept id=\"p1\">](reference/concurrent-queue-class.md#try_pop)</ept> method.","pos":[10659,10789],"source":" The `concurrent_queue` class replaces these methods by defining the [try_pop](reference/concurrent-queue-class.md#try_pop) method."},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class does not provide the <ph id=\"ph2\">`back`</ph> method.","pos":[10799,10863],"source":"The `concurrent_queue` class does not provide the `back` method."},{"content":"Therefore, you cannot reference the end of the queue.","pos":[10864,10917]},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> class provides the <bpt id=\"p1\">[</bpt>unsafe_size<ept id=\"p1\">](reference/concurrent-queue-class.md#unsafe_size)</ept> method instead of the <ph id=\"ph2\">`size`</ph> method.","pos":[10927,11068],"source":"The `concurrent_queue` class provides the [unsafe_size](reference/concurrent-queue-class.md#unsafe_size) method instead of the `size` method."},{"content":"The <ph id=\"ph1\">`unsafe_size`</ph> method is not concurrency-safe.","pos":[11069,11118],"source":" The `unsafe_size` method is not concurrency-safe."},{"pos":[11158,11185],"content":"Concurrency-Safe Operations"},{"pos":[11189,11282],"content":"All methods that enqueue to or dequeue from a <ph id=\"ph1\">`concurrent_queue`</ph> object are concurrency-safe.","source":"All methods that enqueue to or dequeue from a `concurrent_queue` object are concurrency-safe."},{"pos":[11289,11393],"content":"The following table shows the common <ph id=\"ph1\">`concurrent_queue`</ph> methods and operators that are concurrency-safe.","source":"The following table shows the common `concurrent_queue` methods and operators that are concurrency-safe."},{"content":"empty","pos":[11415,11420]},{"content":"push","pos":[11466,11470]},{"content":"get_allocator","pos":[11519,11532]},{"content":"try_pop","pos":[11586,11593]},{"pos":[11649,11793],"content":"Although the <ph id=\"ph1\">`empty`</ph> method is concurrency-safe, a concurrent operation may cause the queue to grow or shrink before the <ph id=\"ph2\">`empty`</ph> method returns.","source":"Although the `empty` method is concurrency-safe, a concurrent operation may cause the queue to grow or shrink before the `empty` method returns."},{"content":"The following table shows the common methods and operators that are not concurrency-safe.","pos":[11800,11889]},{"content":"clear","pos":[11911,11916]},{"content":"unsafe_end","pos":[11962,11972]},{"content":"unsafe_begin","pos":[12027,12039]},{"content":"unsafe_size","pos":[12092,12103]},{"pos":[12198,12214],"content":"Iterator Support"},{"content":"The <ph id=\"ph1\">`concurrent_queue`</ph> provides iterators that are not concurrency-safe.","pos":[12218,12290],"source":"The `concurrent_queue` provides iterators that are not concurrency-safe."},{"content":"We recommend that you use these iterators for debugging only.","pos":[12291,12352]},{"content":"A <ph id=\"ph1\">`concurrent_queue`</ph> iterator traverses elements in the forward direction only.","pos":[12359,12438],"source":"A `concurrent_queue` iterator traverses elements in the forward direction only."},{"content":"The following table shows the operators that each iterator supports.","pos":[12439,12507]},{"content":"Operator","pos":[12514,12522]},{"content":"Description","pos":[12523,12534]},{"content":"operator++","pos":[12577,12587]},{"content":"Advances to next item in the queue.","pos":[12659,12694]},{"content":"This operator is overloaded to provide both pre-increment and post-increment semantics.","pos":[12695,12782]},{"content":"operator*","pos":[12788,12797]},{"content":"Retrieves a reference to the current item.","pos":[12869,12911]},{"content":"operator-&gt;","pos":[12917,12927],"source":"operator->"},{"content":"Retrieves a pointer to the current item.","pos":[12999,13039]},{"pos":[13047,13060],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[13099,13129],"content":"concurrent_unordered_map Class"},{"content":"The <bpt id=\"p1\">[</bpt>HYPERLINK \"file:///C:<ph id=\"ph1\">\\\\</ph>\\Users<ph id=\"ph2\">\\\\</ph>\\thompet<ph id=\"ph3\">\\\\</ph>\\AppData<ph id=\"ph4\">\\\\</ph>\\Local<ph id=\"ph5\">\\\\</ph>\\Temp<ph id=\"ph6\">\\\\</ph>\\DxEditor<ph id=\"ph7\">\\\\</ph>\\DduePreview<ph id=\"ph8\">\\\\</ph>\\Default<ph id=\"ph9\">\\\\</ph>\\798d7037-df37-4310-858b-6f590bbf6ebf<ph id=\"ph10\">\\\\</ph>\\HTM<ph id=\"ph11\">\\\\</ph>\\html<ph id=\"ph12\">\\\\</ph>\\a217b4ac-af2b-4d41-94eb-09a75ee28622\" concurrency::concurrent_unordered_map<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-unordered-map-class.md)</ept> class is an associative container class that, just like the <bpt id=\"p2\">[</bpt>std::unordered_map<ept id=\"p2\">](../../standard-library/unordered-map-class.md)</ept> class, controls a varying-length sequence of elements of type <bpt id=\"p3\">[</bpt>std::pair<ph id=\"ph13\">\\&lt;</ph>const Key, Ty&gt;<ept id=\"p3\">](../../standard-library/pair-structure.md)</ept>.","pos":[13133,13696],"source":"The [HYPERLINK \"file:///C:\\\\\\Users\\\\\\thompet\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\DxEditor\\\\\\DduePreview\\\\\\Default\\\\\\798d7037-df37-4310-858b-6f590bbf6ebf\\\\\\HTM\\\\\\html\\\\\\a217b4ac-af2b-4d41-94eb-09a75ee28622\" concurrency::concurrent_unordered_map](../../parallel/concrt/reference/concurrent-unordered-map-class.md) class is an associative container class that, just like the [std::unordered_map](../../standard-library/unordered-map-class.md) class, controls a varying-length sequence of elements of type [std::pair\\<const Key, Ty>](../../standard-library/pair-structure.md)."},{"content":"Think of an unordered map as a dictionary that you can add a key and value pair to or look up a value by key.","pos":[13697,13806]},{"content":"This class is useful when you have multiple threads or tasks that have to concurrently access a shared container, insert into it, or update it.","pos":[13807,13950]},{"content":"The following example shows the basic structure for using <ph id=\"ph1\">`concurrent_unordered_map`</ph>.","pos":[13957,14042],"source":"The following example shows the basic structure for using `concurrent_unordered_map`."},{"content":"This example inserts character keys in the range ['a', 'i'].","pos":[14043,14103]},{"content":"Because the order of operations is undetermined, the final value for each key is also undetermined.","pos":[14104,14203]},{"content":"However, it is safe to perform the insertions in parallel.","pos":[14204,14262]},{"pos":[14280,14312],"content":"concrt-unordered-map-structure#1"},{"pos":[14398,14640],"content":"For an example that uses <ph id=\"ph1\">`concurrent_unordered_map`</ph> to perform a map and reduce operation in parallel, see <bpt id=\"p1\">[</bpt>How to: Perform Map and Reduce Operations in Parallel<ept id=\"p1\">](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)</ept>.","source":"For an example that uses `concurrent_unordered_map` to perform a map and reduce operation in parallel, see [How to: Perform Map and Reduce Operations in Parallel](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)."},{"pos":[14682,14744],"content":"Differences Between concurrent_unordered_map and unordered_map"},{"content":"The <ph id=\"ph1\">`concurrent_unordered_map`</ph> class closely resembles the <ph id=\"ph2\">`unordered_map`</ph> class.","pos":[14748,14829],"source":"The `concurrent_unordered_map` class closely resembles the `unordered_map` class."},{"content":"The following points illustrate where <ph id=\"ph1\">`concurrent_unordered_map`</ph> differs from <ph id=\"ph2\">`unordered_map`</ph>:","pos":[14830,14924],"source":" The following points illustrate where `concurrent_unordered_map` differs from `unordered_map`:"},{"content":"The <ph id=\"ph1\">`erase`</ph>, <ph id=\"ph2\">`bucket`</ph>, <ph id=\"ph3\">`bucket_count`</ph>, and <ph id=\"ph4\">`bucket_size`</ph> methods are named <ph id=\"ph5\">`unsafe_erase`</ph>, <ph id=\"ph6\">`unsafe_bucket`</ph>, <ph id=\"ph7\">`unsafe_bucket_count`</ph>, and <ph id=\"ph8\">`unsafe_bucket_size`</ph>, respectively.","pos":[14934,15104],"source":"The `erase`, `bucket`, `bucket_count`, and `bucket_size` methods are named `unsafe_erase`, `unsafe_bucket`, `unsafe_bucket_count`, and `unsafe_bucket_size`, respectively."},{"content":"The <ph id=\"ph1\">`unsafe_`</ph> naming convention indicates that these methods are not concurrency-safe.","pos":[15105,15191],"source":" The `unsafe_` naming convention indicates that these methods are not concurrency-safe."},{"content":"For more information about concurrency safety, see <bpt id=\"p1\">[</bpt>Concurrency-Safe Operations<ept id=\"p1\">](#map-safety)</ept>.","pos":[15192,15286],"source":" For more information about concurrency safety, see [Concurrency-Safe Operations](#map-safety)."},{"content":"Insert operations do not invalidate existing pointers or iterators, nor do they change the order of items that already exist in the map.","pos":[15296,15432]},{"content":"Insert and traverse operations can occur concurrently.","pos":[15433,15487]},{"pos":[15524,15556],"content":"supports forward iteration only."},{"content":"Insertion does not invalidate or update the iterators that are returned by <ph id=\"ph1\">`equal_range`</ph>.","pos":[15566,15655],"source":"Insertion does not invalidate or update the iterators that are returned by `equal_range`."},{"content":"Insertion can append unequal items to the end of the range.","pos":[15656,15715]},{"content":"The begin iterator points to an equal item.","pos":[15716,15759]},{"content":"To help avoid deadlock, no method of <ph id=\"ph1\">`concurrent_unordered_map`</ph> holds a lock when it calls the memory allocator, hash functions, or other user-defined code.","pos":[15766,15922],"source":"To help avoid deadlock, no method of `concurrent_unordered_map` holds a lock when it calls the memory allocator, hash functions, or other user-defined code."},{"content":"Also, you must ensure that the hash function always evaluates equal keys to the same value.","pos":[15923,16014]},{"content":"The best hash functions distribute keys uniformly across the hash code space.","pos":[16015,16092]},{"pos":[16129,16156],"content":"Concurrency-Safe Operations"},{"content":"The <ph id=\"ph1\">`concurrent_unordered_map`</ph> class enables concurrency-safe insert and element-access operations.","pos":[16160,16259],"source":"The `concurrent_unordered_map` class enables concurrency-safe insert and element-access operations."},{"content":"Insert operations do not invalidate existing pointers or iterators.","pos":[16260,16327]},{"content":"Iterator access and traversal operations are also concurrency-safe.","pos":[16328,16395]},{"content":"The following table shows the commonly used <ph id=\"ph1\">`concurrent_unordered_map`</ph> methods and operators that are concurrency-safe.","pos":[16396,16515],"source":" The following table shows the commonly used `concurrent_unordered_map` methods and operators that are concurrency-safe."},{"content":"at","pos":[16543,16545]},{"content":"key_eq","pos":[16611,16617]},{"content":"operator&amp;#91;&amp;#93;","pos":[16754,16772],"source":"operator&#91;&#93;"},{"content":"insert","pos":[16857,16863]},{"pos":[16931,17124],"content":"Although the <ph id=\"ph1\">`count`</ph> method can be called safely from concurrently running threads, different threads can receive different results if a new value is simultaneously inserted into the container.","source":"Although the `count` method can be called safely from concurrently running threads, different threads can receive different results if a new value is simultaneously inserted into the container."},{"content":"The following table shows the commonly used methods and operators that are not concurrency-safe.","pos":[17131,17227]},{"content":"operator=","pos":[17305,17314]},{"pos":[17380,17477],"content":"In addition to these methods, any method that begins with <ph id=\"ph1\">`unsafe_`</ph> is also not concurrency-safe.","source":"In addition to these methods, any method that begins with `unsafe_` is also not concurrency-safe."},{"pos":[17484,17497],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[17541,17576],"content":"concurrent_unordered_multimap Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::concurrent_unordered_multimap<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-unordered-multimap-class.md)</ept> class closely resembles the <ph id=\"ph1\">`concurrent_unordered_map`</ph> class except that it allows for multiple values to map to the same key.","pos":[17580,17827],"source":"The [concurrency::concurrent_unordered_multimap](../../parallel/concrt/reference/concurrent-unordered-multimap-class.md) class closely resembles the `concurrent_unordered_map` class except that it allows for multiple values to map to the same key."},{"content":"It also differs from <ph id=\"ph1\">`concurrent_unordered_map`</ph> in the following ways:","pos":[17828,17898],"source":" It also differs from `concurrent_unordered_map` in the following ways:"},{"pos":[17908,18075],"content":"The <bpt id=\"p1\">[</bpt>concurrent_unordered_multimap::insert<ept id=\"p1\">](reference/concurrent-unordered-multimap-class.md#insert)</ept> method returns an iterator instead of <ph id=\"ph1\">`std::pair&lt;iterator, bool&gt;`</ph>.","source":"The [concurrent_unordered_multimap::insert](reference/concurrent-unordered-multimap-class.md#insert) method returns an iterator instead of `std::pair<iterator, bool>`."},{"pos":[18086,18178],"content":"The <ph id=\"ph1\">`concurrent_unordered_multimap`</ph> class does not provide <ph id=\"ph2\">`operator[]`</ph> nor the <ph id=\"ph3\">`at`</ph> method.","source":"The `concurrent_unordered_multimap` class does not provide `operator[]` nor the `at` method."},{"content":"The following example shows the basic structure for using <ph id=\"ph1\">`concurrent_unordered_multimap`</ph>.","pos":[18185,18275],"source":"The following example shows the basic structure for using `concurrent_unordered_multimap`."},{"content":"This example inserts character keys in the range ['a', 'i'].","pos":[18276,18336]},{"content":"enables a key to have multiple values.","pos":[18369,18407]},{"pos":[18425,18462],"content":"concrt-unordered-multimap-structure#1"},{"pos":[18548,18561],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[18600,18630],"content":"concurrent_unordered_set Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::concurrent_unordered_set<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-unordered-set-class.md)</ept> class closely resembles the <ph id=\"ph1\">`concurrent_unordered_map`</ph> class except that it manages values instead of key and value pairs.","pos":[18634,18867],"source":"The [concurrency::concurrent_unordered_set](../../parallel/concrt/reference/concurrent-unordered-set-class.md) class closely resembles the `concurrent_unordered_map` class except that it manages values instead of key and value pairs."},{"content":"The <ph id=\"ph1\">`concurrent_unordered_set`</ph> class does not provide <ph id=\"ph2\">`operator[]`</ph> nor the <ph id=\"ph3\">`at`</ph> method.","pos":[18868,18955],"source":" The `concurrent_unordered_set` class does not provide `operator[]` nor the `at` method."},{"content":"The following example shows the basic structure for using <ph id=\"ph1\">`concurrent_unordered_set`</ph>.","pos":[18962,19047],"source":"The following example shows the basic structure for using `concurrent_unordered_set`."},{"content":"This example inserts character values in the range ['a', 'i'].","pos":[19048,19110]},{"content":"It is safe to perform the insertions in parallel.","pos":[19111,19160]},{"pos":[19178,19200],"content":"concrt-unordered-set#1"},{"pos":[19286,19299],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[19343,19378],"content":"concurrent_unordered_multiset Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::concurrent_unordered_multiset<ept id=\"p1\">](../../parallel/concrt/reference/concurrent-unordered-multiset-class.md)</ept> class closely resembles the <ph id=\"ph1\">`concurrent_unordered_set`</ph> class except that it allows for duplicate values.","pos":[19382,19607],"source":"The [concurrency::concurrent_unordered_multiset](../../parallel/concrt/reference/concurrent-unordered-multiset-class.md) class closely resembles the `concurrent_unordered_set` class except that it allows for duplicate values."},{"content":"It also differs from <ph id=\"ph1\">`concurrent_unordered_set`</ph> in the following ways:","pos":[19608,19678],"source":" It also differs from `concurrent_unordered_set` in the following ways:"},{"pos":[19689,19856],"content":"The <bpt id=\"p1\">[</bpt>concurrent_unordered_multiset::insert<ept id=\"p1\">](reference/concurrent-unordered-multiset-class.md#insert)</ept> method returns an iterator instead of <ph id=\"ph1\">`std::pair&lt;iterator, bool&gt;`</ph>.","source":"The [concurrent_unordered_multiset::insert](reference/concurrent-unordered-multiset-class.md#insert) method returns an iterator instead of `std::pair<iterator, bool>`."},{"pos":[19867,19959],"content":"The <ph id=\"ph1\">`concurrent_unordered_multiset`</ph> class does not provide <ph id=\"ph2\">`operator[]`</ph> nor the <ph id=\"ph3\">`at`</ph> method.","source":"The `concurrent_unordered_multiset` class does not provide `operator[]` nor the `at` method."},{"content":"The following example shows the basic structure for using <ph id=\"ph1\">`concurrent_unordered_multiset`</ph>.","pos":[19966,20056],"source":"The following example shows the basic structure for using `concurrent_unordered_multiset`."},{"content":"This example inserts character values in the range ['a', 'i'].","pos":[20057,20119]},{"content":"enables a value to occur multiple times.","pos":[20152,20192]},{"pos":[20210,20237],"content":"concrt-unordered-multiset#1"},{"pos":[20323,20336],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[20372,20388],"content":"combinable Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::combinable<ept id=\"p1\">](../../parallel/concrt/reference/combinable-class.md)</ept> class provides reusable, thread-local storage that lets you perform fine-grained computations and then merge those computations into a final result.","pos":[20392,20623],"source":"The [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) class provides reusable, thread-local storage that lets you perform fine-grained computations and then merge those computations into a final result."},{"content":"You can think of a <ph id=\"ph1\">`combinable`</ph> object as a reduction variable.","pos":[20624,20687],"source":" You can think of a `combinable` object as a reduction variable."},{"content":"The <ph id=\"ph1\">`combinable`</ph> class is useful when you have a resource that is shared among several threads or tasks.","pos":[20694,20798],"source":"The `combinable` class is useful when you have a resource that is shared among several threads or tasks."},{"content":"The <ph id=\"ph1\">`combinable`</ph> class helps you eliminate shared state by providing access to shared resources in a lock-free manner.","pos":[20799,20917],"source":" The `combinable` class helps you eliminate shared state by providing access to shared resources in a lock-free manner."},{"content":"Therefore, this class provides an alternative to using a synchronization mechanism, for example, a mutex, to synchronize access to shared data from multiple threads.","pos":[20918,21083]},{"pos":[21129,21149],"content":"Methods and Features"},{"content":"The following table shows some of the important methods of the <ph id=\"ph1\">`combinable`</ph> class.","pos":[21153,21235],"source":"The following table shows some of the important methods of the `combinable` class."},{"content":"For more information about all the <ph id=\"ph1\">`combinable`</ph> class methods, see <bpt id=\"p1\">[</bpt>combinable Class<ept id=\"p1\">](../../parallel/concrt/reference/combinable-class.md)</ept>.","pos":[21236,21375],"source":" For more information about all the `combinable` class methods, see [combinable Class](../../parallel/concrt/reference/combinable-class.md)."},{"content":"Method","pos":[21382,21388]},{"content":"Description","pos":[21389,21400]},{"content":"local","pos":[21441,21446]},{"content":"Retrieves a reference to the local variable that is associated with the current thread context.","pos":[21485,21580]},{"content":"clear","pos":[21586,21591]},{"pos":[21630,21694],"content":"Removes all thread-local variables from the <ph id=\"ph1\">`combinable`</ph> object.","source":"Removes all thread-local variables from the `combinable` object."},{"content":"combine","pos":[21700,21707]},{"content":"combine_each","pos":[21761,21773]},{"content":"Uses the provided combine function to generate a final value from the set of all thread-local computations.","pos":[21819,21926]},{"content":"The <ph id=\"ph1\">`combinable`</ph> class is a template class that is parameterized on the final merged result.","pos":[21934,22026],"source":"The `combinable` class is a template class that is parameterized on the final merged result."},{"content":"If you call the default constructor, the <ph id=\"ph1\">`T`</ph> template parameter type must have a default constructor and a copy constructor.","pos":[22027,22151],"source":" If you call the default constructor, the `T` template parameter type must have a default constructor and a copy constructor."},{"content":"If the <ph id=\"ph1\">`T`</ph> template parameter type does not have a default constructor, call the overloaded version of the constructor that takes an initialization function as its parameter.","pos":[22152,22326],"source":" If the `T` template parameter type does not have a default constructor, call the overloaded version of the constructor that takes an initialization function as its parameter."},{"content":"You can store additional data in a <ph id=\"ph1\">`combinable`</ph> object after you call the <bpt id=\"p1\">[</bpt>combine<ept id=\"p1\">](reference/combinable-class.md#combine)</ept> or <bpt id=\"p2\">[</bpt>combine_each<ept id=\"p2\">](reference/combinable-class.md#combine_each)</ept> methods.","pos":[22333,22526],"source":"You can store additional data in a `combinable` object after you call the [combine](reference/combinable-class.md#combine) or [combine_each](reference/combinable-class.md#combine_each) methods."},{"content":"You can also call the <ph id=\"ph1\">`combine`</ph> and <ph id=\"ph2\">`combine_each`</ph> methods multiple times.","pos":[22527,22601],"source":" You can also call the `combine` and `combine_each` methods multiple times."},{"content":"If no local value in a <ph id=\"ph1\">`combinable`</ph> object changes, the <ph id=\"ph2\">`combine`</ph> and <ph id=\"ph3\">`combine_each`</ph> methods produce the same result every time that they are called.","pos":[22602,22751],"source":" If no local value in a `combinable` object changes, the `combine` and `combine_each` methods produce the same result every time that they are called."},{"pos":[22797,22805],"content":"Examples"},{"pos":[22809,22888],"content":"For examples about how to use the <ph id=\"ph1\">`combinable`</ph> class, see the following topics:","source":"For examples about how to use the `combinable` class, see the following topics:"},{"content":"How to: Use combinable to Improve Performance","pos":[22899,22944]},{"content":"How to: Use combinable to Combine Sets","pos":[23027,23065]},{"pos":[23137,23150],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"Related Topics","pos":[23159,23173]},{"content":"How to: Use Parallel Containers to Increase Efficiency","pos":[23178,23232]},{"content":"Shows how to use parallel containers to efficiently store and access data in parallel.","pos":[23317,23403]},{"content":"How to: Use combinable to Improve Performance","pos":[23411,23456]},{"content":"Shows how to use the <ph id=\"ph1\">`combinable`</ph> class to eliminate shared state, and thereby improve performance.","pos":[23532,23631],"source":" Shows how to use the `combinable` class to eliminate shared state, and thereby improve performance."},{"content":"How to: Use combinable to Combine Sets","pos":[23639,23677]},{"content":"Shows how to use a <ph id=\"ph1\">`combine`</ph> function to merge thread-local sets of data.","pos":[23746,23819],"source":" Shows how to use a `combine` function to merge thread-local sets of data."},{"content":"Parallel Patterns Library (PPL)","pos":[23827,23858]},{"content":"Describes the PPL, which provides an imperative programming model that promotes scalability and ease-of-use for developing concurrent applications.","pos":[23919,24066]},{"content":"Reference","pos":[24075,24084]},{"content":"concurrent_vector Class","pos":[24089,24112]},{"content":"concurrent_queue Class","pos":[24181,24203]},{"content":"concurrent_unordered_map Class","pos":[24271,24301]},{"content":"concurrent_unordered_multimap Class","pos":[24377,24412]},{"content":"concurrent_unordered_set Class","pos":[24493,24523]},{"content":"concurrent_unordered_multiset Class","pos":[24599,24634]},{"content":"combinable Class","pos":[24715,24731]}],"content":"---\ntitle: \"Parallel Containers and Objects | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"parallel objects\"\n  - \"parallel containers\"\n  - \"concurrent containers\"\nms.assetid: 90ab715c-29cd-48eb-8e76-528619aab466\ncaps.latest.revision: 34\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Parallel Containers and Objects\nThe Parallel Patterns Library (PPL) includes several containers and objects that provide thread-safe access to their elements.  \n  \n A *concurrent container* provides concurrency-safe access to the most important operations. The functionality of these containers resembles those that are provided by the Standard Template Library (STL). For example, the [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) class resembles the [std::vector](../../standard-library/vector-class.md) class, except that the `concurrent_vector` class lets you append elements in parallel. Use concurrent containers when you have parallel code that requires both read and write access to the same container.  \n  \n A *concurrent object* is shared concurrently among components. A process that computes the state of a concurrent object in parallel produces the same result as another process that computes the same state serially. The [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) class is one example of a concurrent object type. The `combinable` class lets you perform computations in parallel, and then combine those computations into a final result. Use concurrent objects when you would otherwise use a synchronization mechanism, for example, a mutex, to synchronize access to a shared variable or resource.  \n  \n##  <a name=\"top\"></a> Sections  \n This topic describes the following parallel containers and objects in detail.  \n  \n Concurrent containers:  \n  \n-   [concurrent_vector Class](#ctor)  \n  \n    -   [Differences Between concurrent_vector and vector](#ctor)  \n  \n    -   [Concurrency-Safe Operations](#ctor)  \n  \n    -   [Exception Safety](#ctor)  \n  \n-   [concurrent_queue Class](#queue)  \n  \n    -   [Differences Between concurrent_queue and queue](#queue-differences)  \n  \n    -   [Concurrency-Safe Operations](#queue-safety)  \n  \n    -   [Iterator Support](#queue-iterators)  \n  \n-   [concurrent_unordered_map Class](#unordered_map)  \n  \n    -   [Differences Between concurrent_unordered_map and unordered_map](#map-differences)  \n  \n    -   [Concurrency-Safe Operations](#map-safety)  \n  \n-   [concurrent_unordered_multimap Class](#unordered_multimap)  \n  \n-   [concurrent_unordered_set Class](#unordered_set)  \n  \n-   [concurrent_unordered_multiset Class](#unordered_multiset)  \n  \n Concurrent objects:  \n  \n-   [combinable Class](#combinable)  \n  \n    -   [Methods and Features](#combinable-features)  \n  \n    -   [Examples](#combinable-examples)  \n  \n##  <a name=\"vector\"></a> concurrent_vector Class  \n The [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) class is a sequence container class that, just like the [std::vector](../../standard-library/vector-class.md) class, lets you randomly access its elements. The `concurrent_vector` class enables concurrency-safe append and element access operations. Append operations do not invalidate existing pointers or iterators. Iterator access and traversal operations are also concurrency-safe.  \n  \n###  <a name=\"vector-differences\"></a> Differences Between concurrent_vector and vector  \n The `concurrent_vector` class closely resembles the `vector` class. The complexity of append, element access, and iterator access operations on a `concurrent_vector` object are the same as for a `vector` object. The following points illustrate where `concurrent_vector` differs from `vector`:  \n  \n-   Append, element access, iterator access, and iterator traversal operations on a `concurrent_vector` object are concurrency-safe.  \n  \n-   You can add elements only to the end of a `concurrent_vector` object. The `concurrent_vector` class does not provide the `insert` method.  \n  \n-   A `concurrent_vector` object does not use [move semantics](../../cpp/rvalue-reference-declarator-amp-amp.md) when you append to it.  \n  \n\n-   The `concurrent_vector` class does not provide the `erase` or `pop_back` methods. As with `vector`, use the [clear](reference/concurrent-vector-class.md#clear) method to remove all elements from a `concurrent_vector` object.  \n  \n-   The `concurrent_vector` class does not store its elements contiguously in memory. Therefore, you cannot use the `concurrent_vector` class in all the ways that you can use an array. For example, for a variable named `v` of type `concurrent_vector`, the expression `&v[0]+2` produces undefined behavior.  \n  \n-   The `concurrent_vector` class defines the [grow_by](reference/concurrent-vector-class.md#grow_by) and [grow_to_at_least](reference/concurrent-vector-class.md#grow_to_at_least) methods. These methods resemble the [resize](reference/concurrent-vector-class.md#resize) method, except that they are concurrency-safe.  \n  \n-   A `concurrent_vector` object does not relocate its elements when you append to it or resize it. This enables existing pointers and iterators to remain valid during concurrent operations.  \n  \n-   The runtime does not define a specialized version of `concurrent_vector` for type `bool`.  \n  \n###  <a name=\"vector-safety\"></a> Concurrency-Safe Operations  \n All methods that append to or increase the size of a `concurrent_vector` object, or access an element in a `concurrent_vector` object, are concurrency-safe. The exception to this rule is the `resize` method.  \n  \n The following table shows the common `concurrent_vector` methods and operators that are concurrency-safe.  \n  \n||||  \n|-|-|-|  \n\n|[at](reference/concurrent-vector-class.md#at)|[end](reference/concurrent-vector-class.md#end)|[operator&#91;&#93;](reference/concurrent-vector-class.md#operator_at)|  \n|[begin](reference/concurrent-vector-class.md#begin)|[front](reference/concurrent-vector-class.md#front)|[push_back](reference/concurrent-vector-class.md#push_back)|  \n|[back](reference/concurrent-vector-class.md#back)|[grow_by](reference/concurrent-vector-class.md#grow_by)|[rbegin](reference/concurrent-vector-class.md#rbegin)|  \n|[capacity](reference/concurrent-vector-class.md#capacity)|[grow_to_at_least](reference/concurrent-vector-class.md#grow_to_at_least)|[rend](reference/concurrent-vector-class.md#rend)|  \n|[empty](reference/concurrent-vector-class.md#empty)|[max_size](reference/concurrent-vector-class.md#max_size)|[size](reference/concurrent-vector-class.md#size)|  \n\n  \n Operations that the runtime provides for compatibility with the STL, for example, `reserve`, are not concurrency-safe. The following table shows the common methods and operators that are not concurrency-safe.  \n  \n|||  \n|-|-|  \n\n|[assign](reference/concurrent-vector-class.md#assign)|[reserve](reference/concurrent-vector-class.md#reserve)|  \n|[clear](reference/concurrent-vector-class.md#clear)|[resize](reference/concurrent-vector-class.md#resize)|  \n|[operator=](reference/concurrent-vector-class.md#operator_eq)|[shrink_to_fit](reference/concurrent-vector-class.md#shrink_to_fit)|  \n  \n Operations that modify the value of existing elements are not concurrency-safe. Use a synchronization object such as a [reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) object to synchronize concurrent read and write operations to the same data element. For more information about synchronization objects, see [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md).  \n  \n When you convert existing code that uses `vector` to use `concurrent_vector`, concurrent operations can cause the behavior of your application to change. For example, consider the following program that concurrently performs two tasks on a `concurrent_vector` object. The first task appends additional elements to a `concurrent_vector` object. The second task computes the sum of all elements in the same object.  \n  \n [!code-cpp[concrt-vector-safety#1](../../parallel/concrt/codesnippet/cpp/parallel-containers-and-objects_1.cpp)]  \n  \n\n Although the `end` method is concurrency-safe, a concurrent call to the [push_back](reference/concurrent-vector-class.md#push_back) method causes the value that is returned by `end` to change. The number of elements that the iterator traverses is indeterminate. Therefore, this program can produce a different result each time that you run it.  \n  \n###  <a name=\"vector-exceptions\"></a> Exception Safety  \n If a growth or assignment operation throws an exception, the state of the `concurrent_vector` object becomes invalid. The behavior of a `concurrent_vector` object that is in an invalid state is undefined unless stated otherwise. However, the destructor always frees the memory that the object allocates, even if the object is in an invalid state.  \n  \n The data type of the vector elements, `T`, must meet the following requirements. Otherwise, the behavior of the `concurrent_vector` class is undefined.  \n  \n-   The destructor must not throw.  \n  \n-   If the default or copy constructor throws, the destructor must not be declared by using the `virtual` keyword and it must work correctly with zero-initialized memory.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"queue\"></a> concurrent_queue Class  \n The [concurrency::concurrent_queue](../../parallel/concrt/reference/concurrent-queue-class.md) class, just like the [std::queue](../../standard-library/queue-class.md) class, lets you access its front and back elements. The `concurrent_queue` class enables concurrency-safe enqueue and dequeue operations. The `concurrent_queue` class also provides iterator support that is not concurrency-safe.  \n  \n###  <a name=\"queue-differences\"></a> Differences Between concurrent_queue and queue  \n The `concurrent_queue` class closely resembles the `queue` class. The following points illustrate where `concurrent_queue` differs from `queue`:  \n  \n-   Enqueue and dequeue operations on a `concurrent_queue` object are concurrency-safe.  \n  \n-   The `concurrent_queue` class provides iterator support that is not concurrency-safe.  \n  \n\n-   The `concurrent_queue` class does not provide the `front` or `pop` methods. The `concurrent_queue` class replaces these methods by defining the [try_pop](reference/concurrent-queue-class.md#try_pop) method.  \n  \n-   The `concurrent_queue` class does not provide the `back` method. Therefore, you cannot reference the end of the queue.  \n  \n-   The `concurrent_queue` class provides the [unsafe_size](reference/concurrent-queue-class.md#unsafe_size) method instead of the `size` method. The `unsafe_size` method is not concurrency-safe.  \n\n  \n###  <a name=\"queue-safety\"></a> Concurrency-Safe Operations  \n All methods that enqueue to or dequeue from a `concurrent_queue` object are concurrency-safe.  \n  \n The following table shows the common `concurrent_queue` methods and operators that are concurrency-safe.  \n  \n|||  \n|-|-|  \n|[empty](reference/concurrent-queue-class.md#empty)|[push](reference/concurrent-queue-class.md#push)|  \n|[get_allocator](reference/concurrent-queue-class.md#get_allocator)|[try_pop](reference/concurrent-queue-class.md#try_pop)|  \n\n\n  \n Although the `empty` method is concurrency-safe, a concurrent operation may cause the queue to grow or shrink before the `empty` method returns.  \n  \n The following table shows the common methods and operators that are not concurrency-safe.  \n  \n|||  \n|-|-|  \n|[clear](reference/concurrent-queue-class.md#clear)|[unsafe_end](reference/concurrent-queue-class.md#unsafe_end)|  \n|[unsafe_begin](reference/concurrent-queue-class.md#unsafe_begin)|[unsafe_size](reference/concurrent-queue-class.md#unsafe_size)|  \n\n\n  \n###  <a name=\"queue-iterators\"></a> Iterator Support  \n The `concurrent_queue` provides iterators that are not concurrency-safe. We recommend that you use these iterators for debugging only.  \n  \n A `concurrent_queue` iterator traverses elements in the forward direction only. The following table shows the operators that each iterator supports.  \n  \n|Operator|Description|  \n|--------------|-----------------|  \n|[operator++](http://msdn.microsoft.com/en-us/4cfdd07e-927a-42f8-aaa0-d6881687f413)|Advances to next item in the queue. This operator is overloaded to provide both pre-increment and post-increment semantics.|  \n|[operator*](http://msdn.microsoft.com/en-us/a0e671fc-76e6-4fb4-b95c-ced4dd2b2017)|Retrieves a reference to the current item.|  \n|[operator->](http://msdn.microsoft.com/en-us/41fa393d-ae1e-4a38-bb4b-19e8df709ca9)|Retrieves a pointer to the current item.|  \n  \n [[Top](#top)]  \n  \n##  <a name=\"unordered_map\"></a> concurrent_unordered_map Class  \n The [HYPERLINK \"file:///C:\\\\\\Users\\\\\\thompet\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\DxEditor\\\\\\DduePreview\\\\\\Default\\\\\\798d7037-df37-4310-858b-6f590bbf6ebf\\\\\\HTM\\\\\\html\\\\\\a217b4ac-af2b-4d41-94eb-09a75ee28622\" concurrency::concurrent_unordered_map](../../parallel/concrt/reference/concurrent-unordered-map-class.md) class is an associative container class that, just like the [std::unordered_map](../../standard-library/unordered-map-class.md) class, controls a varying-length sequence of elements of type [std::pair\\<const Key, Ty>](../../standard-library/pair-structure.md). Think of an unordered map as a dictionary that you can add a key and value pair to or look up a value by key. This class is useful when you have multiple threads or tasks that have to concurrently access a shared container, insert into it, or update it.  \n  \n The following example shows the basic structure for using `concurrent_unordered_map`. This example inserts character keys in the range ['a', 'i']. Because the order of operations is undetermined, the final value for each key is also undetermined. However, it is safe to perform the insertions in parallel.  \n  \n [!code-cpp[concrt-unordered-map-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-containers-and-objects_2.cpp)]  \n  \n For an example that uses `concurrent_unordered_map` to perform a map and reduce operation in parallel, see [How to: Perform Map and Reduce Operations in Parallel](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md).  \n  \n###  <a name=\"map-differences\"></a> Differences Between concurrent_unordered_map and unordered_map  \n The `concurrent_unordered_map` class closely resembles the `unordered_map` class. The following points illustrate where `concurrent_unordered_map` differs from `unordered_map`:  \n  \n-   The `erase`, `bucket`, `bucket_count`, and `bucket_size` methods are named `unsafe_erase`, `unsafe_bucket`, `unsafe_bucket_count`, and `unsafe_bucket_size`, respectively. The `unsafe_` naming convention indicates that these methods are not concurrency-safe. For more information about concurrency safety, see [Concurrency-Safe Operations](#map-safety).  \n  \n-   Insert operations do not invalidate existing pointers or iterators, nor do they change the order of items that already exist in the map. Insert and traverse operations can occur concurrently.  \n  \n-   `concurrent_unordered_map` supports forward iteration only.  \n  \n-   Insertion does not invalidate or update the iterators that are returned by `equal_range`. Insertion can append unequal items to the end of the range. The begin iterator points to an equal item.  \n  \n To help avoid deadlock, no method of `concurrent_unordered_map` holds a lock when it calls the memory allocator, hash functions, or other user-defined code. Also, you must ensure that the hash function always evaluates equal keys to the same value. The best hash functions distribute keys uniformly across the hash code space.  \n  \n###  <a name=\"map-safety\"></a> Concurrency-Safe Operations  \n The `concurrent_unordered_map` class enables concurrency-safe insert and element-access operations. Insert operations do not invalidate existing pointers or iterators. Iterator access and traversal operations are also concurrency-safe. The following table shows the commonly used `concurrent_unordered_map` methods and operators that are concurrency-safe.  \n  \n|||||  \n|-|-|-|-|  \n|[at](reference/concurrent-unordered-map-class.md#at)|`count`|`find`|[key_eq](reference/concurrent-unordered-map-class.md#key_eq)|  \n|`begin`|`empty`|`get_allocator`|`max_size`|  \n|`cbegin`|`end`|`hash_function`|[operator&#91;&#93;](reference/concurrent-unordered-map-class.md#operator_at)|  \n|`cend`|`equal_range`|[insert](reference/concurrent-unordered-map-class.md#insert)|`size`|  \n  \n Although the `count` method can be called safely from concurrently running threads, different threads can receive different results if a new value is simultaneously inserted into the container.  \n  \n The following table shows the commonly used methods and operators that are not concurrency-safe.  \n  \n||||  \n|-|-|-|  \n|`clear`|`max_load_factor`|`rehash`|  \n|`load_factor`|[operator=](reference/concurrent-unordered-map-class.md#operator_eq) \n\n\n  \n In addition to these methods, any method that begins with `unsafe_` is also not concurrency-safe.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"unordered_multimap\"></a> concurrent_unordered_multimap Class  \n The [concurrency::concurrent_unordered_multimap](../../parallel/concrt/reference/concurrent-unordered-multimap-class.md) class closely resembles the `concurrent_unordered_map` class except that it allows for multiple values to map to the same key. It also differs from `concurrent_unordered_map` in the following ways:  \n  \n-   The [concurrent_unordered_multimap::insert](reference/concurrent-unordered-multimap-class.md#insert) method returns an iterator instead of `std::pair<iterator, bool>`.  \n\n  \n-   The `concurrent_unordered_multimap` class does not provide `operator[]` nor the `at` method.  \n  \n The following example shows the basic structure for using `concurrent_unordered_multimap`. This example inserts character keys in the range ['a', 'i']. `concurrent_unordered_multimap` enables a key to have multiple values.  \n  \n [!code-cpp[concrt-unordered-multimap-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-containers-and-objects_3.cpp)]  \n  \n [[Top](#top)]  \n  \n##  <a name=\"unordered_set\"></a> concurrent_unordered_set Class  \n The [concurrency::concurrent_unordered_set](../../parallel/concrt/reference/concurrent-unordered-set-class.md) class closely resembles the `concurrent_unordered_map` class except that it manages values instead of key and value pairs. The `concurrent_unordered_set` class does not provide `operator[]` nor the `at` method.  \n  \n The following example shows the basic structure for using `concurrent_unordered_set`. This example inserts character values in the range ['a', 'i']. It is safe to perform the insertions in parallel.  \n  \n [!code-cpp[concrt-unordered-set#1](../../parallel/concrt/codesnippet/cpp/parallel-containers-and-objects_4.cpp)]  \n  \n [[Top](#top)]  \n  \n##  <a name=\"unordered_multiset\"></a> concurrent_unordered_multiset Class  \n The [concurrency::concurrent_unordered_multiset](../../parallel/concrt/reference/concurrent-unordered-multiset-class.md) class closely resembles the `concurrent_unordered_set` class except that it allows for duplicate values. It also differs from `concurrent_unordered_set` in the following ways:  \n  \n\n-   The [concurrent_unordered_multiset::insert](reference/concurrent-unordered-multiset-class.md#insert) method returns an iterator instead of `std::pair<iterator, bool>`.  \n\n  \n-   The `concurrent_unordered_multiset` class does not provide `operator[]` nor the `at` method.  \n  \n The following example shows the basic structure for using `concurrent_unordered_multiset`. This example inserts character values in the range ['a', 'i']. `concurrent_unordered_multiset` enables a value to occur multiple times.  \n  \n [!code-cpp[concrt-unordered-multiset#1](../../parallel/concrt/codesnippet/cpp/parallel-containers-and-objects_5.cpp)]  \n  \n [[Top](#top)]  \n  \n##  <a name=\"combinable\"></a> combinable Class  \n The [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) class provides reusable, thread-local storage that lets you perform fine-grained computations and then merge those computations into a final result. You can think of a `combinable` object as a reduction variable.  \n  \n The `combinable` class is useful when you have a resource that is shared among several threads or tasks. The `combinable` class helps you eliminate shared state by providing access to shared resources in a lock-free manner. Therefore, this class provides an alternative to using a synchronization mechanism, for example, a mutex, to synchronize access to shared data from multiple threads.  \n  \n###  <a name=\"combinable-features\"></a> Methods and Features  \n The following table shows some of the important methods of the `combinable` class. For more information about all the `combinable` class methods, see [combinable Class](../../parallel/concrt/reference/combinable-class.md).  \n  \n|Method|Description|  \n|------------|-----------------|  \n|[local](reference/combinable-class.md#local)|Retrieves a reference to the local variable that is associated with the current thread context.|  \n|[clear](reference/combinable-class.md#clear)|Removes all thread-local variables from the `combinable` object.|  \n|[combine](reference/combinable-class.md#combine)<br /><br /> [combine_each](reference/combinable-class.md#combine_each)|Uses the provided combine function to generate a final value from the set of all thread-local computations.|  \n  \n The `combinable` class is a template class that is parameterized on the final merged result. If you call the default constructor, the `T` template parameter type must have a default constructor and a copy constructor. If the `T` template parameter type does not have a default constructor, call the overloaded version of the constructor that takes an initialization function as its parameter.  \n  \n You can store additional data in a `combinable` object after you call the [combine](reference/combinable-class.md#combine) or [combine_each](reference/combinable-class.md#combine_each) methods. You can also call the `combine` and `combine_each` methods multiple times. If no local value in a `combinable` object changes, the `combine` and `combine_each` methods produce the same result every time that they are called.  \n  \n###  <a name=\"combinable-examples\"></a> Examples  \n For examples about how to use the `combinable` class, see the following topics:  \n  \n-   [How to: Use combinable to Improve Performance](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md)  \n  \n-   [How to: Use combinable to Combine Sets](../../parallel/concrt/how-to-use-combinable-to-combine-sets.md)  \n  \n [[Top](#top)]  \n  \n## Related Topics  \n [How to: Use Parallel Containers to Increase Efficiency](../../parallel/concrt/how-to-use-parallel-containers-to-increase-efficiency.md)  \n Shows how to use parallel containers to efficiently store and access data in parallel.  \n  \n [How to: Use combinable to Improve Performance](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md)  \n Shows how to use the `combinable` class to eliminate shared state, and thereby improve performance.  \n  \n [How to: Use combinable to Combine Sets](../../parallel/concrt/how-to-use-combinable-to-combine-sets.md)  \n Shows how to use a `combine` function to merge thread-local sets of data.  \n  \n [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)  \n Describes the PPL, which provides an imperative programming model that promotes scalability and ease-of-use for developing concurrent applications.  \n  \n## Reference  \n [concurrent_vector Class](../../parallel/concrt/reference/concurrent-vector-class.md)  \n  \n [concurrent_queue Class](../../parallel/concrt/reference/concurrent-queue-class.md)  \n  \n [concurrent_unordered_map Class](../../parallel/concrt/reference/concurrent-unordered-map-class.md)  \n  \n [concurrent_unordered_multimap Class](../../parallel/concrt/reference/concurrent-unordered-multimap-class.md)  \n  \n [concurrent_unordered_set Class](../../parallel/concrt/reference/concurrent-unordered-set-class.md)  \n  \n [concurrent_unordered_multiset Class](../../parallel/concrt/reference/concurrent-unordered-multiset-class.md)  \n  \n [combinable Class](../../parallel/concrt/reference/combinable-class.md)\n"}