{"nodes":[{"pos":[12,42],"content":"codecvt Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"codecvt Class | Microsoft Docs","pos":[0,30]}]},{"pos":[657,670],"content":"codecvt Class","linkify":"codecvt Class","nodes":[{"content":"codecvt Class","pos":[0,13]}]},{"content":"A template class that describes an object that can serve as a locale facet.","pos":[671,746]},{"content":"It is able to control conversions between a sequence of values used to encode characters within the program and a sequence of values used to encode characters outside the program.","pos":[747,926]},{"pos":[935,941],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1078,1088],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type used within a program to encode characters.","pos":[1106,1158]},{"content":"A type used to encode characters outside a program.","pos":[1175,1226]},{"content":"A type that can be used to represent intermediate states of a conversion between internal and external types of character representations.","pos":[1248,1386]},{"pos":[1395,1402],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes an object that can serve as a <bpt id=\"p1\">[</bpt>locale facet<ept id=\"p1\">](../standard-library/locale-class.md#facet_class)</ept>, to control conversions between a sequence of values of type <ph id=\"ph1\">`CharType`</ph> and a sequence of values of type <ph id=\"ph2\">`Byte`</ph>.","pos":[1406,1641],"source":"The template class describes an object that can serve as a [locale facet](../standard-library/locale-class.md#facet_class), to control conversions between a sequence of values of type `CharType` and a sequence of values of type `Byte`."},{"content":"The class <ph id=\"ph1\">`StateType`</ph> characterizes the transformation -- and an object of class <ph id=\"ph2\">`StateType`</ph> stores any necessary state information during a conversion.","pos":[1642,1794],"source":" The class `StateType` characterizes the transformation -- and an object of class `StateType` stores any necessary state information during a conversion."},{"pos":[1801,1934],"content":"The internal encoding uses a representation with a fixed number of bytes per character, usually either type <ph id=\"ph1\">`char`</ph> or type <ph id=\"ph2\">`wchar_t`</ph>.","source":"The internal encoding uses a representation with a fixed number of bytes per character, usually either type `char` or type `wchar_t`."},{"content":"As with any locale facet, the static object <ph id=\"ph1\">`id`</ph> has an initial stored value of zero.","pos":[1941,2026],"source":"As with any locale facet, the static object `id` has an initial stored value of zero."},{"content":"The first attempt to access its stored value stores a unique positive value in <ph id=\"ph1\">`id`</ph>.","pos":[2027,2111],"source":" The first attempt to access its stored value stores a unique positive value in `id`."},{"pos":[2118,2236],"content":"The template versions of <bpt id=\"p1\">[</bpt>do_in<ept id=\"p1\">](#codecvt__do_in)</ept> and <bpt id=\"p2\">[</bpt>do_out<ept id=\"p2\">](#codecvt__do_out)</ept> always return <ph id=\"ph1\">`codecvt_base::noconv`</ph>.","source":"The template versions of [do_in](#codecvt__do_in) and [do_out](#codecvt__do_out) always return `codecvt_base::noconv`."},{"content":"The Standard C++ Library defines several explicit specializations:","pos":[2243,2309]},{"pos":[2377,2425],"content":"converts between <ph id=\"ph1\">`wchar_t`</ph> and <ph id=\"ph2\">`char`</ph> sequences.","source":"converts between `wchar_t` and `char` sequences."},{"pos":[2494,2588],"content":"converts between <ph id=\"ph1\">`char16_t`</ph> sequences encoded as UTF-16 and <ph id=\"ph2\">`char`</ph> sequences encoded as UTF-8.","source":"converts between `char16_t` sequences encoded as UTF-16 and `char` sequences encoded as UTF-8."},{"pos":[2657,2759],"content":"converts between <ph id=\"ph1\">`char32_t`</ph> sequences encoded as UTF-32 (UCS-4) and <ph id=\"ph2\">`char`</ph> sequences encoded as UTF-8.","source":"converts between `char32_t` sequences encoded as UTF-32 (UCS-4) and `char` sequences encoded as UTF-8."},{"pos":[2769,2781],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[2802,2830],"content":"<bpt id=\"p1\">[</bpt>codecvt<ept id=\"p1\">](#codecvt__codecvt)</ept>","source":"[codecvt](#codecvt__codecvt)"},{"pos":[2831,2930],"content":"The constructor for objects of class <ph id=\"ph1\">`codecvt`</ph> that serves as a locale facet to handle conversions.","source":"The constructor for objects of class `codecvt` that serves as a locale facet to handle conversions."},{"pos":[2941,2949],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[2970,3006],"content":"<bpt id=\"p1\">[</bpt>extern_type<ept id=\"p1\">](#codecvt__extern_type)</ept>","source":"[extern_type](#codecvt__extern_type)"},{"content":"A character type that is used for external representations.","pos":[3007,3066]},{"pos":[3071,3107],"content":"<bpt id=\"p1\">[</bpt>intern_type<ept id=\"p1\">](#codecvt__intern_type)</ept>","source":"[intern_type](#codecvt__intern_type)"},{"content":"A character type that is used for internal representations.","pos":[3108,3167]},{"pos":[3172,3206],"content":"<bpt id=\"p1\">[</bpt>state_type<ept id=\"p1\">](#codecvt__state_type)</ept>","source":"[state_type](#codecvt__state_type)"},{"content":"A character type that is used to represent intermediate states during conversions between internal and external representations.","pos":[3207,3335]},{"pos":[3346,3362],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[3383,3423],"content":"<bpt id=\"p1\">[</bpt>always_noconv<ept id=\"p1\">](#codecvt__always_noconv)</ept>","source":"[always_noconv](#codecvt__always_noconv)"},{"content":"Tests whether no conversions need be done.","pos":[3424,3466]},{"pos":[3471,3517],"content":"<bpt id=\"p1\">[</bpt>do_always_noconv<ept id=\"p1\">](#codecvt__do_always_noconv)</ept>","source":"[do_always_noconv](#codecvt__do_always_noconv)"},{"content":"A virtual function called to test whether no conversions need be done.","pos":[3518,3588]},{"pos":[3593,3629],"content":"<bpt id=\"p1\">[</bpt>do_encoding<ept id=\"p1\">](#codecvt__do_encoding)</ept>","source":"[do_encoding](#codecvt__do_encoding)"},{"pos":[3630,3849],"content":"A virtual function that tests if the encoding of the <ph id=\"ph1\">`Byte`</ph> stream is state dependent, whether the ratio between the <ph id=\"ph2\">`Byte`</ph>s used and the <ph id=\"ph3\">`CharType`</ph>s produced is constant, and, if so, determines the value of that ratio.","source":"A virtual function that tests if the encoding of the `Byte` stream is state dependent, whether the ratio between the `Byte`s used and the `CharType`s produced is constant, and, if so, determines the value of that ratio."},{"pos":[3854,3878],"content":"<bpt id=\"p1\">[</bpt>do_in<ept id=\"p1\">](#codecvt__do_in)</ept>","source":"[do_in](#codecvt__do_in)"},{"pos":[3879,3985],"content":"A virtual function called to convert a sequence of internal <ph id=\"ph1\">`Byte`</ph>s to a sequence of external <ph id=\"ph2\">`CharType`</ph>s.","source":"A virtual function called to convert a sequence of internal `Byte`s to a sequence of external `CharType`s."},{"pos":[3990,4022],"content":"<bpt id=\"p1\">[</bpt>do_length<ept id=\"p1\">](#codecvt__do_length)</ept>","source":"[do_length](#codecvt__do_length)"},{"pos":[4023,4213],"content":"A virtual function that determines how many <ph id=\"ph1\">`Byte`</ph>s from a given sequence of external <ph id=\"ph2\">`Byte`</ph>s produce not more than a given number of internal <ph id=\"ph3\">`CharType`</ph>s and returns that number of <ph id=\"ph4\">`Byte`</ph>s.","source":"A virtual function that determines how many `Byte`s from a given sequence of external `Byte`s produce not more than a given number of internal `CharType`s and returns that number of `Byte`s."},{"pos":[4218,4258],"content":"<bpt id=\"p1\">[</bpt>do_max_length<ept id=\"p1\">](#codecvt__do_max_length)</ept>","source":"[do_max_length](#codecvt__do_max_length)"},{"pos":[4259,4373],"content":"A virtual function that returns the maximum number of external Bytes necessary to produce one internal <ph id=\"ph1\">`CharType`</ph>.","source":"A virtual function that returns the maximum number of external Bytes necessary to produce one internal `CharType`."},{"pos":[4378,4404],"content":"<bpt id=\"p1\">[</bpt>do_out<ept id=\"p1\">](#codecvt__do_out)</ept>","source":"[do_out](#codecvt__do_out)"},{"pos":[4405,4509],"content":"A virtual function called to convert a sequence of internal <ph id=\"ph1\">`CharType`</ph>s to a sequence of external Bytes.","source":"A virtual function called to convert a sequence of internal `CharType`s to a sequence of external Bytes."},{"pos":[4514,4548],"content":"<bpt id=\"p1\">[</bpt>do_unshift<ept id=\"p1\">](#codecvt__do_unshift)</ept>","source":"[do_unshift](#codecvt__do_unshift)"},{"pos":[4549,4693],"content":"A virtual function called to provide the <ph id=\"ph1\">`Byte`</ph>s needed in a state-dependent conversion to complete the last character in a sequence of <ph id=\"ph2\">`Byte`</ph>s.","source":"A virtual function called to provide the `Byte`s needed in a state-dependent conversion to complete the last character in a sequence of `Byte`s."},{"pos":[4698,4728],"content":"<bpt id=\"p1\">[</bpt>encoding<ept id=\"p1\">](#codecvt__encoding)</ept>","source":"[encoding](#codecvt__encoding)"},{"pos":[4729,4924],"content":"Tests if the encoding of the <ph id=\"ph1\">`Byte`</ph> stream is state dependent, whether the ratio between the <ph id=\"ph2\">`Byte`</ph>s used and the <ph id=\"ph3\">`CharType`</ph>s produced is constant, and, if so, determines the value of that ratio.","source":"Tests if the encoding of the `Byte` stream is state dependent, whether the ratio between the `Byte`s used and the `CharType`s produced is constant, and, if so, determines the value of that ratio."},{"pos":[4929,4947],"content":"<bpt id=\"p1\">[</bpt>in<ept id=\"p1\">](#codecvt__in)</ept>","source":"[in](#codecvt__in)"},{"pos":[4948,5068],"content":"Converts an external representation of a sequence of <ph id=\"ph1\">`Byte`</ph>s to an internal representation of a sequence of <ph id=\"ph2\">`CharType`</ph>s.","source":"Converts an external representation of a sequence of `Byte`s to an internal representation of a sequence of `CharType`s."},{"pos":[5073,5099],"content":"<bpt id=\"p1\">[</bpt>length<ept id=\"p1\">](#codecvt__length)</ept>","source":"[length](#codecvt__length)"},{"pos":[5100,5266],"content":"Determines how many <ph id=\"ph1\">`Byte`</ph>s from a given sequence of external <ph id=\"ph2\">`Byte`</ph>s produce not more than a given number of internal <ph id=\"ph3\">`CharType`</ph>s and returns that number of <ph id=\"ph4\">`Byte`</ph>s.","source":"Determines how many `Byte`s from a given sequence of external `Byte`s produce not more than a given number of internal `CharType`s and returns that number of `Byte`s."},{"pos":[5271,5305],"content":"<bpt id=\"p1\">[</bpt>max_length<ept id=\"p1\">](#codecvt__max_length)</ept>","source":"[max_length](#codecvt__max_length)"},{"pos":[5306,5398],"content":"Returns the maximum number of external <ph id=\"ph1\">`Byte`</ph>s necessary to produce one internal <ph id=\"ph2\">`CharType`</ph>.","source":"Returns the maximum number of external `Byte`s necessary to produce one internal `CharType`."},{"pos":[5403,5423],"content":"<bpt id=\"p1\">[</bpt>out<ept id=\"p1\">](#codecvt__out)</ept>","source":"[out](#codecvt__out)"},{"pos":[5424,5502],"content":"Converts a sequence of internal <ph id=\"ph1\">`CharType`</ph>s to a sequence of external <ph id=\"ph2\">`Byte`</ph>s.","source":"Converts a sequence of internal `CharType`s to a sequence of external `Byte`s."},{"pos":[5507,5535],"content":"<bpt id=\"p1\">[</bpt>unshift<ept id=\"p1\">](#codecvt__unshift)</ept>","source":"[unshift](#codecvt__unshift)"},{"pos":[5536,5663],"content":"Provides the external <ph id=\"ph1\">`Byte`</ph>s needed in a state-dependent conversion to complete the last character in the sequence of <ph id=\"ph2\">`Byte`</ph>s.","source":"Provides the external `Byte`s needed in a state-dependent conversion to complete the last character in the sequence of `Byte`s."},{"pos":[5673,5685],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5689,5710],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>locale&gt;","source":"**Header:** \\<locale>"},{"pos":[5717,5735],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[5745,5806],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__always_noconv\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::always_noconv","linkify":"<a name=\"codecvt__always_noconv\"></a>  codecvt::always_noconv","source":"<a name=\"codecvt__always_noconv\"></a>  codecvt::always_noconv"},{"content":"Tests whether no conversions need be done.","pos":[5810,5852]},{"pos":[5913,5925],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[5929,6037],"content":"A Boolean value that is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if no conversions need be done; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> is at least one needs to be done.","source":"A Boolean value that is **true** if no conversions need be done; **false** is at least one needs to be done."},{"pos":[6047,6054],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6058,6133],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_always_noconv<ept id=\"p1\">](#codecvt__do_always_noconv)</ept>.","source":"The member function returns [do_always_noconv](#codecvt__do_always_noconv)."},{"pos":[6143,6150],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6952,7001],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__codecvt\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::codecvt","linkify":"<a name=\"codecvt__codecvt\"></a>  codecvt::codecvt","source":"<a name=\"codecvt__codecvt\"></a>  codecvt::codecvt"},{"content":"The constructor for objects of class codecvt that serves as a locale facet to handle conversions.","pos":[7005,7102]},{"pos":[7163,7173],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Integer value used to specify the type of memory management for the object.","pos":[7188,7263]},{"pos":[7273,7280],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7284,7357],"content":"The possible values for the <ph id=\"ph1\">`_Refs`</ph> parameter and their significance are:","source":"The possible values for the `_Refs` parameter and their significance are:"},{"content":"0: The lifetime of the object is managed by the locales that contain it.","pos":[7367,7439]},{"content":"1: The lifetime of the object must be manually managed.","pos":[7449,7504]},{"content":"<ph id=\"ph1\">\\&gt;</ph> 0: These values are not defined.","pos":[7514,7549],"source":"\\> 0: These values are not defined."},{"pos":[7556,7703],"content":"The constructor initializes its <ph id=\"ph1\">`locale::facet`</ph> base object with <bpt id=\"p1\">**</bpt>locale::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>facet<ept id=\"p2\">](../standard-library/locale-class.md#facet_class)</ept>( <ph id=\"ph2\">`_Refs`</ph>) <bpt id=\"p3\">*</bpt>.<ept id=\"p3\">*</ept>","source":"The constructor initializes its `locale::facet` base object with **locale::**[facet](../standard-library/locale-class.md#facet_class)( `_Refs`) *.*"},{"pos":[7713,7780],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_always_noconv\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_always_noconv","linkify":"<a name=\"codecvt__do_always_noconv\"></a>  codecvt::do_always_noconv","source":"<a name=\"codecvt__do_always_noconv\"></a>  codecvt::do_always_noconv"},{"content":"A virtual function called to test whether no conversions need be done.","pos":[7784,7854]},{"pos":[7926,7938],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[7942,8093],"content":"The protected virtual member function returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> only if every call to <bpt id=\"p2\">[</bpt>do_in<ept id=\"p2\">](#codecvt__do_in)</ept> or <bpt id=\"p3\">[</bpt>do_out<ept id=\"p3\">](#codecvt__do_out)</ept> returns <bpt id=\"p4\">**</bpt>noconv<ept id=\"p4\">**</ept>.","source":"The protected virtual member function returns **true** only if every call to [do_in](#codecvt__do_in) or [do_out](#codecvt__do_out) returns **noconv**."},{"pos":[8100,8145],"content":"The template version always returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>.","source":"The template version always returns **true**."},{"pos":[8155,8162],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8167,8260],"content":"See the example for <bpt id=\"p1\">[</bpt>always_noconv<ept id=\"p1\">](#codecvt__always_noconv)</ept>, which calls <ph id=\"ph1\">`do_always_noconv`</ph>.","source":"See the example for [always_noconv](#codecvt__always_noconv), which calls `do_always_noconv`."},{"pos":[8270,8327],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_encoding\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_encoding","linkify":"<a name=\"codecvt__do_encoding\"></a>  codecvt::do_encoding","source":"<a name=\"codecvt__do_encoding\"></a>  codecvt::do_encoding"},{"pos":[8331,8555],"content":"A virtual function that tests if the encoding of the <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept> stream is state dependent, whether the ratio between the <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s used and the <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>s produced is constant and, if so, determines the value of that ratio.","source":"A virtual function that tests if the encoding of the **Byte** stream is state dependent, whether the ratio between the **Byte**s used and the **CharType**s produced is constant and, if so, determines the value of that ratio."},{"pos":[8621,8633],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The protected virtual member function returns:","pos":[8637,8683]},{"pos":[8693,8767],"content":"–1, if the encoding of sequences of type <ph id=\"ph1\">`extern_type`</ph> is state dependent.","source":"–1, if the encoding of sequences of type `extern_type` is state dependent."},{"content":"0, if the encoding involves sequences of varying lengths.","pos":[8777,8834]},{"pos":[8842,8900],"content":"<bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept>, if the encoding involves only sequences of length <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept>","source":"*N*, if the encoding involves only sequences of length *N*"},{"pos":[8910,8917],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8922,9000],"content":"See the example for <bpt id=\"p1\">[</bpt>encoding<ept id=\"p1\">](#codecvt__encoding)</ept>, which calls <ph id=\"ph1\">`do_encoding`</ph>.","source":"See the example for [encoding](#codecvt__encoding), which calls `do_encoding`."},{"pos":[9010,9055],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_in\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_in","linkify":"<a name=\"codecvt__do_in\"></a>  codecvt::do_in","source":"<a name=\"codecvt__do_in\"></a>  codecvt::do_in"},{"pos":[9059,9169],"content":"A virtual function called to convert a sequence of external <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s to a sequence of internal <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>s.","source":"A virtual function called to convert a sequence of external **Byte**s to a sequence of internal **CharType**s."},{"pos":[9397,9407],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[9423,9500]},{"content":"Pointer to the beginning of the sequence to be converted.","pos":[9520,9577]},{"content":"Pointer to the end of the sequence to be converted.","pos":[9596,9647]},{"content":"Pointer beyond the end of the converted sequence, to the first unconverted character.","pos":[9666,9751]},{"content":"Pointer to the beginning of the converted sequence.","pos":[9771,9822]},{"content":"Pointer to the end of the converted sequence.","pos":[9841,9886]},{"content":"Pointer to the <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> that comes after the last converted <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>, to the first unaltered character in the destination sequence.","pos":[9905,10044],"source":" Pointer to the **CharType** that comes after the last converted **CharType**, to the first unaltered character in the destination sequence."},{"pos":[10054,10066],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A return that indicates the success, partial success, or failure of the operation.","pos":[10070,10152]},{"content":"The function returns:","pos":[10153,10174]},{"pos":[10182,10243],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::error<ept id=\"p1\">**</ept> if the source sequence is ill formed.","source":"**codecvt_base::error** if the source sequence is ill formed."},{"pos":[10251,10313],"content":"<ph id=\"ph1\">`codecvt_base::noconv`</ph> if the function performs no conversion.","source":"`codecvt_base::noconv` if the function performs no conversion."},{"pos":[10321,10369],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::ok<ept id=\"p1\">**</ept> if the conversion succeeds.","source":"**codecvt_base::ok** if the conversion succeeds."},{"pos":[10377,10506],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::partial<ept id=\"p1\">**</ept> if the source is insufficient or if the destination is not large enough, for the conversion to succeed.","source":"**codecvt_base::partial** if the source is insufficient or if the destination is not large enough, for the conversion to succeed."},{"pos":[10516,10523],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`_State`</ph> must represent the initial conversion state at the beginning of a new source sequence.","pos":[10527,10622],"source":"`_State` must represent the initial conversion state at the beginning of a new source sequence."},{"content":"The function alters its stored value as needed to reflect the current state of a successful conversion.","pos":[10623,10726]},{"content":"Its stored value is otherwise unspecified.","pos":[10727,10769]},{"pos":[10779,10786],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10791,10851],"content":"See the example for <bpt id=\"p1\">[</bpt>in<ept id=\"p1\">](#codecvt__in)</ept>, which calls <ph id=\"ph1\">`do_in`</ph>.","source":"See the example for [in](#codecvt__in), which calls `do_in`."},{"pos":[10861,10914],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_length","linkify":"<a name=\"codecvt__do_length\"></a>  codecvt::do_length","source":"<a name=\"codecvt__do_length\"></a>  codecvt::do_length"},{"pos":[10918,11116],"content":"A virtual function that determines how many <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s from a given sequence of external <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s produce not more than a given number of internal <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>s and returns that number of <bpt id=\"p4\">**</bpt>Byte<ept id=\"p4\">**</ept>s.","source":"A virtual function that determines how many **Byte**s from a given sequence of external **Byte**s produce not more than a given number of internal **CharType**s and returns that number of **Byte**s."},{"pos":[11272,11282],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[11298,11375]},{"content":"Pointer to the beginning of the external sequence.","pos":[11395,11445]},{"content":"Pointer to the end of the external sequence.","pos":[11464,11508]},{"content":"The maximum number of <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s that can be returned by the member function.","pos":[11526,11602],"source":" The maximum number of **Byte**s that can be returned by the member function."},{"pos":[11612,11624],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[11628,11793],"content":"An integer that represents a count of the maximum number of conversions, not greater than <ph id=\"ph1\">`_Len2`</ph>, defined by the external source sequence at [ <ph id=\"ph2\">` first1`</ph>, <ph id=\"ph3\">` last1`</ph>).","source":"An integer that represents a count of the maximum number of conversions, not greater than `_Len2`, defined by the external source sequence at [ ` first1`, ` last1`)."},{"pos":[11803,11810],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11814,12042],"content":"The protected virtual member function effectively calls <ph id=\"ph1\">`do_in`</ph>( <ph id=\"ph2\">`_State`</ph>, <ph id=\"ph3\">` first1`</ph>, <ph id=\"ph4\">` last1`</ph>, <ph id=\"ph5\">` next1`</ph>, <ph id=\"ph6\">`_Buf`</ph>, <ph id=\"ph7\">`_Buf`</ph><ph id=\"ph8\"> + </ph><ph id=\"ph9\">`_Len2`</ph>, <ph id=\"ph10\">` next2`</ph>) for <ph id=\"ph11\">`_State`</ph> (a copy of state), some buffer <ph id=\"ph12\">`_Buf`</ph>, and pointers <ph id=\"ph13\">` next1`</ph>and <ph id=\"ph14\">` next2`</ph>.","source":"The protected virtual member function effectively calls `do_in`( `_State`, ` first1`, ` last1`, ` next1`, `_Buf`, `_Buf` + `_Len2`, ` next2`) for `_State` (a copy of state), some buffer `_Buf`, and pointers ` next1`and ` next2`."},{"content":"It then returns <ph id=\"ph1\">` next2`</ph> – <bpt id=\"p1\">**</bpt>buf<ept id=\"p1\">**</ept>.","pos":[12049,12084],"source":"It then returns ` next2` – **buf**."},{"content":"Thus, it counts the maximum number of conversions, not greater than <ph id=\"ph1\">`_Len2`</ph>, defined by the source sequence at [ <ph id=\"ph2\">` first1`</ph>, <ph id=\"ph3\">` last1`</ph>).","pos":[12085,12219],"source":" Thus, it counts the maximum number of conversions, not greater than `_Len2`, defined by the source sequence at [ ` first1`, ` last1`)."},{"pos":[12226,12309],"content":"The template version always returns the lesser of <ph id=\"ph1\">` last1`</ph> – <ph id=\"ph2\">` first1`</ph> and <ph id=\"ph3\">`_Len2`</ph>.","source":"The template version always returns the lesser of ` last1` – ` first1` and `_Len2`."},{"pos":[12319,12326],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12331,12405],"content":"See the example for <bpt id=\"p1\">[</bpt>length<ept id=\"p1\">](#codecvt__length)</ept>, which calls <bpt id=\"p2\">**</bpt>do_length<ept id=\"p2\">**</ept>.","source":"See the example for [length](#codecvt__length), which calls **do_length**."},{"pos":[12415,12476],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_max_length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_max_length","linkify":"<a name=\"codecvt__do_max_length\"></a>  codecvt::do_max_length","source":"<a name=\"codecvt__do_max_length\"></a>  codecvt::do_max_length"},{"pos":[12480,12600],"content":"A virtual function that returns the maximum number of external <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s necessary to produce one internal <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>.","source":"A virtual function that returns the maximum number of external **Byte**s necessary to produce one internal **CharType**."},{"pos":[12668,12680],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[12684,12754],"content":"The maximum number of <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s necessary to produce one <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>.","source":"The maximum number of **Byte**s necessary to produce one **CharType**."},{"pos":[12764,12771],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12775,12986],"content":"The protected virtual member function returns the largest permissible value that can be returned by <bpt id=\"p1\">[</bpt>do_length<ept id=\"p1\">](#codecvt__do_length)</ept>( <ph id=\"ph1\">` first1`</ph>, <ph id=\"ph2\">` last1`</ph>, 1) for arbitrary valid values of <ph id=\"ph3\">` first1`</ph> and <ph id=\"ph4\">` last1`</ph>.","source":"The protected virtual member function returns the largest permissible value that can be returned by [do_length](#codecvt__do_length)( ` first1`, ` last1`, 1) for arbitrary valid values of ` first1` and ` last1`."},{"pos":[12996,13003],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13008,13092],"content":"See the example for <bpt id=\"p1\">[</bpt>max_length<ept id=\"p1\">](#codecvt__max_length)</ept>, which calls <ph id=\"ph1\">`do_max_length`</ph>.","source":"See the example for [max_length](#codecvt__max_length), which calls `do_max_length`."},{"pos":[13102,13149],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_out\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_out","linkify":"<a name=\"codecvt__do_out\"></a>  codecvt::do_out","source":"<a name=\"codecvt__do_out\"></a>  codecvt::do_out"},{"pos":[13153,13263],"content":"A virtual function called to convert a sequence of internal <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>s to a sequence of external <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s.","source":"A virtual function called to convert a sequence of internal **CharType**s to a sequence of external **Byte**s."},{"pos":[13492,13502],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[13518,13595]},{"content":"Pointer to the beginning of the sequence to be converted.","pos":[13615,13672]},{"content":"Pointer to the end of the sequence to be converted.","pos":[13691,13742]},{"content":"Reference to a pointer to the first unconverted <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>, after the last <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept> converted.","pos":[13761,13861],"source":" Reference to a pointer to the first unconverted **CharType**, after the last **CharType** converted."},{"content":"Pointer to the beginning of the converted sequence.","pos":[13881,13932]},{"content":"Pointer to the end of the converted sequence.","pos":[13951,13996]},{"content":"Reference to a pointer to the first unconverted <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>, after the last <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept> converted.","pos":[14015,14107],"source":" Reference to a pointer to the first unconverted **Byte**, after the last **Byte** converted."},{"pos":[14117,14129],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The function returns:","pos":[14133,14154]},{"pos":[14162,14223],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::error<ept id=\"p1\">**</ept> if the source sequence is ill formed.","source":"**codecvt_base::error** if the source sequence is ill formed."},{"pos":[14231,14293],"content":"<ph id=\"ph1\">`codecvt_base::noconv`</ph> if the function performs no conversion.","source":"`codecvt_base::noconv` if the function performs no conversion."},{"pos":[14301,14349],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::ok<ept id=\"p1\">**</ept> if the conversion succeeds.","source":"**codecvt_base::ok** if the conversion succeeds."},{"pos":[14357,14485],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::partial<ept id=\"p1\">**</ept> if the source is insufficient or if the destination is not large enough for the conversion to succeed.","source":"**codecvt_base::partial** if the source is insufficient or if the destination is not large enough for the conversion to succeed."},{"pos":[14495,14502],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`_State`</ph> must represent the initial conversion state at the beginning of a new source sequence.","pos":[14506,14601],"source":"`_State` must represent the initial conversion state at the beginning of a new source sequence."},{"content":"The function alters its stored value as needed to reflect the current state of a successful conversion.","pos":[14602,14705]},{"content":"Its stored value is otherwise unspecified.","pos":[14706,14748]},{"pos":[14758,14765],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14770,14833],"content":"See the example for <bpt id=\"p1\">[</bpt>out<ept id=\"p1\">](#codecvt__out)</ept>, which calls <ph id=\"ph1\">`do_out`</ph>.","source":"See the example for [out](#codecvt__out), which calls `do_out`."},{"pos":[14843,14898],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__do_unshift\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::do_unshift","linkify":"<a name=\"codecvt__do_unshift\"></a>  codecvt::do_unshift","source":"<a name=\"codecvt__do_unshift\"></a>  codecvt::do_unshift"},{"pos":[14902,15050],"content":"A virtual function called to provide the <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s needed in a state-dependent conversion to complete the last character in a sequence of <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s.","source":"A virtual function called to provide the **Byte**s needed in a state-dependent conversion to complete the last character in a sequence of **Byte**s."},{"pos":[15193,15203],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[15219,15296]},{"content":"Pointer to the first position in the destination range.","pos":[15316,15371]},{"content":"Pointer to the last position in the destination range.","pos":[15390,15444]},{"content":"Pointer to the first unaltered element in the destination sequence.","pos":[15463,15530]},{"pos":[15540,15552],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The function returns:","pos":[15556,15577]},{"pos":[15585,15649],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::error<ept id=\"p1\">**</ept> if _ <bpt id=\"p2\">*</bpt>State<ept id=\"p2\">*</ept> represents an invalid state","source":"**codecvt_base::error** if _ *State* represents an invalid state"},{"pos":[15657,15718],"content":"<ph id=\"ph1\">`codecvt_base::noconv`</ph> if the function performs no conversion","source":"`codecvt_base::noconv` if the function performs no conversion"},{"pos":[15726,15773],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::ok<ept id=\"p1\">**</ept> if the conversion succeeds","source":"**codecvt_base::ok** if the conversion succeeds"},{"pos":[15781,15875],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::partial<ept id=\"p1\">**</ept> if the destination is not large enough for the conversion to succeed","source":"**codecvt_base::partial** if the destination is not large enough for the conversion to succeed"},{"pos":[15885,15892],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function tries to convert the source element <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>(0) to a destination sequence that it stores within [ <ph id=\"ph1\">` first2`</ph>, <ph id=\"ph2\">` last2`</ph>), except for the terminating element <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>(0).","pos":[15896,16105],"source":"The protected virtual member function tries to convert the source element **CharType**(0) to a destination sequence that it stores within [ ` first2`, ` last2`), except for the terminating element **Byte**(0)."},{"content":"It always stores in <ph id=\"ph1\">` next2`</ph> a pointer to the first unaltered element in the destination sequence.","pos":[16106,16204],"source":" It always stores in ` next2` a pointer to the first unaltered element in the destination sequence."},{"content":"_ <bpt id=\"p1\">*</bpt>State<ept id=\"p1\">*</ept> must represent the initial conversion state at the beginning of a new source sequence.","pos":[16211,16307],"source":"_ *State* must represent the initial conversion state at the beginning of a new source sequence."},{"content":"The function alters its stored value as needed to reflect the current state of a successful conversion.","pos":[16308,16411]},{"content":"Typically, converting the source element <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>(0) leaves the current state in the initial conversion state.","pos":[16412,16526],"source":" Typically, converting the source element **CharType**(0) leaves the current state in the initial conversion state."},{"pos":[16536,16543],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16548,16623],"content":"See the example for <bpt id=\"p1\">[</bpt>unshift<ept id=\"p1\">](#codecvt__unshift)</ept>, which calls <ph id=\"ph1\">`do_unshift`</ph>.","source":"See the example for [unshift](#codecvt__unshift), which calls `do_unshift`."},{"pos":[16633,16684],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__encoding\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::encoding","linkify":"<a name=\"codecvt__encoding\"></a>  codecvt::encoding","source":"<a name=\"codecvt__encoding\"></a>  codecvt::encoding"},{"pos":[16688,16889],"content":"Tests if the encoding of the <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept> stream is state dependent, whether the ratio between the <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s used and the <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>s produced is constant, and, if so, determines the value of that ratio.","source":"Tests if the encoding of the **Byte** stream is state dependent, whether the ratio between the **Byte**s used and the **CharType**s produced is constant, and, if so, determines the value of that ratio."},{"pos":[16944,16956],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[16960,17101],"content":"If the return value is positive then that value is the constant number of <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept> characters required to produce the <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept> character.","source":"If the return value is positive then that value is the constant number of **Byte** characters required to produce the **CharType** character."},{"content":"The protected virtual member function returns:","pos":[17108,17154]},{"pos":[17164,17238],"content":"–1, if the encoding of sequences of type <ph id=\"ph1\">`extern_type`</ph> is state dependent.","source":"–1, if the encoding of sequences of type `extern_type` is state dependent."},{"content":"0, if the encoding involves sequences of varying lengths.","pos":[17248,17305]},{"pos":[17313,17372],"content":"<bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept>, if the encoding involves only sequences of length <bpt id=\"p2\">*</bpt>N.<ept id=\"p2\">*</ept>","source":"*N*, if the encoding involves only sequences of length *N.*"},{"pos":[17382,17389],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[17393,17458],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_encoding<ept id=\"p1\">](#codecvt__do_encoding)</ept>.","source":"The member function returns [do_encoding](#codecvt__do_encoding)."},{"pos":[17468,17475],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[18056,18113],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__extern_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::extern_type","linkify":"<a name=\"codecvt__extern_type\"></a>  codecvt::extern_type","source":"<a name=\"codecvt__extern_type\"></a>  codecvt::extern_type"},{"content":"A character type that is used for external representations.","pos":[18117,18176]},{"pos":[18229,18236],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18240,18298],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **Byte**."},{"pos":[18308,18347],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__in\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::in","linkify":"<a name=\"codecvt__in\"></a>  codecvt::in","source":"<a name=\"codecvt__in\"></a>  codecvt::in"},{"pos":[18351,18475],"content":"Converts an external representation of a sequence of <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s to an internal representation of a sequence of <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>s.","source":"Converts an external representation of a sequence of **Byte**s to an internal representation of a sequence of **CharType**s."},{"pos":[18692,18702],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[18718,18795]},{"content":"Pointer to the beginning of the sequence to be converted.","pos":[18815,18872]},{"content":"Pointer to the end of the sequence to be converted.","pos":[18891,18942]},{"content":"Pointer beyond the end of the converted sequence to the first unconverted character.","pos":[18961,19045]},{"content":"Pointer to the beginning of the converted sequence.","pos":[19065,19116]},{"content":"Pointer to the end of the converted sequence.","pos":[19135,19180]},{"content":"Pointer to the <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> that comes after the last converted <bpt id=\"p2\">**</bpt>Chartype<ept id=\"p2\">**</ept> to the first unaltered character in the destination sequence.","pos":[19199,19337],"source":" Pointer to the **CharType** that comes after the last converted **Chartype** to the first unaltered character in the destination sequence."},{"pos":[19347,19359],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A return that indicates the success, partial success or failure of the operation.","pos":[19363,19444]},{"content":"The function returns:","pos":[19445,19466]},{"pos":[19474,19535],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::error<ept id=\"p1\">**</ept> if the source sequence is ill formed.","source":"**codecvt_base::error** if the source sequence is ill formed."},{"pos":[19543,19605],"content":"<ph id=\"ph1\">`codecvt_base::noconv`</ph> if the function performs no conversion.","source":"`codecvt_base::noconv` if the function performs no conversion."},{"pos":[19613,19661],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::ok<ept id=\"p1\">**</ept> if the conversion succeeds.","source":"**codecvt_base::ok** if the conversion succeeds."},{"pos":[19669,19797],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::partial<ept id=\"p1\">**</ept> if the source is insufficient or if the destination is not large enough for the conversion to succeed.","source":"**codecvt_base::partial** if the source is insufficient or if the destination is not large enough for the conversion to succeed."},{"pos":[19807,19814],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`_State`</ph> must represent the initial conversion state at the beginning of a new source sequence.","pos":[19818,19913],"source":"`_State` must represent the initial conversion state at the beginning of a new source sequence."},{"content":"The function alters its stored value, as needed, to reflect the current state of a successful conversion.","pos":[19914,20019]},{"content":"After a partial conversion, <ph id=\"ph1\">`_State`</ph> must be set so as to allow the conversion to resume when new characters arrive.","pos":[20020,20136],"source":" After a partial conversion, `_State` must be set so as to allow the conversion to resume when new characters arrive."},{"pos":[20143,20260],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_in<ept id=\"p1\">](#codecvt__do_in)</ept>( <ph id=\"ph1\">`_State`</ph>, _ <bpt id=\"p2\">*</bpt>First1,  last1,  next1, First2, _Llast2,  next2<ept id=\"p2\">*</ept>).","source":"The member function returns [do_in](#codecvt__do_in)( `_State`, _ *First1,  last1,  next1, First2, _Llast2,  next2*)."},{"pos":[20270,20277],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[21268,21325],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__intern_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::intern_type","linkify":"<a name=\"codecvt__intern_type\"></a>  codecvt::intern_type","source":"<a name=\"codecvt__intern_type\"></a>  codecvt::intern_type"},{"content":"A character type that is used for internal representations.","pos":[21329,21388]},{"pos":[21445,21452],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[21456,21518],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **CharType**."},{"pos":[21528,21575],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::length","linkify":"<a name=\"codecvt__length\"></a>  codecvt::length","source":"<a name=\"codecvt__length\"></a>  codecvt::length"},{"pos":[21579,21753],"content":"Determines how many <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s from a given sequence of external <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s produce not more than a given number of internal <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>s and returns that number of <bpt id=\"p4\">**</bpt>Byte<ept id=\"p4\">**</ept>s.","source":"Determines how many **Byte**s from a given sequence of external **Byte**s produce not more than a given number of internal **CharType**s and returns that number of **Byte**s."},{"pos":[21898,21908],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[21924,22001]},{"content":"Pointer to the beginning of the external sequence.","pos":[22021,22071]},{"content":"Pointer to the end of the external sequence.","pos":[22090,22134]},{"content":"The maximum number of Bytes that can be returned by the member function.","pos":[22152,22224]},{"pos":[22234,22246],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[22250,22415],"content":"An integer that represents a count of the maximum number of conversions, not greater than <ph id=\"ph1\">`_Len2`</ph>, defined by the external source sequence at [ <ph id=\"ph2\">` first1`</ph>, <ph id=\"ph3\">` last1`</ph>).","source":"An integer that represents a count of the maximum number of conversions, not greater than `_Len2`, defined by the external source sequence at [ ` first1`, ` last1`)."},{"pos":[22425,22432],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[22436,22536],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_length<ept id=\"p1\">](#codecvt__do_length)</ept>( <bpt id=\"p2\">*</bpt>_State,  first1<ept id=\"p2\">*</ept>, <ph id=\"ph1\">` last1`</ph>, <ph id=\"ph2\">`_Len2`</ph>).","source":"The member function returns [do_length](#codecvt__do_length)( *_State,  first1*, ` last1`, `_Len2`)."},{"pos":[22546,22553],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[23218,23273],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__max_length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::max_length","linkify":"<a name=\"codecvt__max_length\"></a>  codecvt::max_length","source":"<a name=\"codecvt__max_length\"></a>  codecvt::max_length"},{"pos":[23277,23373],"content":"Returns the maximum number of external <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s necessary to produce one internal <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>.","source":"Returns the maximum number of external **Byte**s necessary to produce one internal **CharType**."},{"pos":[23430,23442],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[23446,23516],"content":"The maximum number of <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s necessary to produce one <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept>.","source":"The maximum number of **Byte**s necessary to produce one **CharType**."},{"pos":[23526,23533],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[23537,23606],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_max_length<ept id=\"p1\">](#codecvt__do_max_length)</ept>.","source":"The member function returns [do_max_length](#codecvt__do_max_length)."},{"pos":[23616,23623],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[24013,24054],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__out\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::out","linkify":"<a name=\"codecvt__out\"></a>  codecvt::out","source":"<a name=\"codecvt__out\"></a>  codecvt::out"},{"pos":[24058,24140],"content":"Converts a sequence of internal <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>s to a sequence of external <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s.","source":"Converts a sequence of internal **CharType**s to a sequence of external **Byte**s."},{"pos":[24358,24368],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[24384,24461]},{"content":"Pointer to the beginning of the sequence to be converted.","pos":[24481,24538]},{"content":"Pointer to the end of the sequence to be converted.","pos":[24557,24608]},{"content":"Reference to a pointer to the first unconverted <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> after the last <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept> converted.","pos":[24627,24726],"source":" Reference to a pointer to the first unconverted **CharType** after the last **CharType** converted."},{"content":"Pointer to the beginning of the converted sequence.","pos":[24746,24797]},{"content":"Pointer to the end of the converted sequence.","pos":[24816,24861]},{"content":"Reference to a pointer to the first unconverted <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept> after the last converted <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>.","pos":[24880,24971],"source":" Reference to a pointer to the first unconverted **Byte** after the last converted **Byte**."},{"pos":[24981,24993],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[24997,25125],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_out<ept id=\"p1\">](#codecvt__do_out)</ept>( <ph id=\"ph1\">`_State`</ph>, <ph id=\"ph2\">` first1`</ph>, <ph id=\"ph3\">` last1`</ph>, <ph id=\"ph4\">` next1`</ph>, <ph id=\"ph5\">` first2`</ph>, <ph id=\"ph6\">` last2`</ph>, <ph id=\"ph7\">` next2`</ph>).","source":"The member function returns [do_out](#codecvt__do_out)( `_State`, ` first1`, ` last1`, ` next1`, ` first2`, ` last2`, ` next2`)."},{"pos":[25135,25142],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25146,25208],"content":"For more information, see <bpt id=\"p1\">[</bpt>codecvt::do_out<ept id=\"p1\">](#codecvt__do_out)</ept>.","source":"For more information, see [codecvt::do_out](#codecvt__do_out)."},{"pos":[25218,25225],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[26236,26291],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__state_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::state_type","linkify":"<a name=\"codecvt__state_type\"></a>  codecvt::state_type","source":"<a name=\"codecvt__state_type\"></a>  codecvt::state_type"},{"content":"A character type that is used to represent intermediate states during conversions between internal and external representations.","pos":[26295,26423]},{"pos":[26480,26487],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[26491,26554],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>StateType<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **StateType**."},{"pos":[26564,26613],"content":"<bpt id=\"p1\">&lt;a name=\"codecvt__unshift\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  codecvt::unshift","linkify":"<a name=\"codecvt__unshift\"></a>  codecvt::unshift","source":"<a name=\"codecvt__unshift\"></a>  codecvt::unshift"},{"pos":[26617,26737],"content":"Provides the <bpt id=\"p1\">**</bpt>Byte<ept id=\"p1\">**</ept>s needed in a state-dependent conversion to complete the last character in a sequence of <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>s.","source":"Provides the **Byte**s needed in a state-dependent conversion to complete the last character in a sequence of **Byte**s."},{"pos":[26869,26879],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The conversion state that is maintained between calls to the member function.","pos":[26895,26972]},{"content":"Pointer to the first position in the destination range.","pos":[26992,27047]},{"content":"Pointer to the last position in the destination range.","pos":[27066,27120]},{"content":"Pointer to the first unaltered element in the destination sequence.","pos":[27139,27206]},{"pos":[27216,27228],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The function returns:","pos":[27232,27253]},{"pos":[27261,27322],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::error<ept id=\"p1\">**</ept> if state represents an invalid state.","source":"**codecvt_base::error** if state represents an invalid state."},{"pos":[27330,27392],"content":"<ph id=\"ph1\">`codecvt_base::noconv`</ph> if the function performs no conversion.","source":"`codecvt_base::noconv` if the function performs no conversion."},{"pos":[27400,27448],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::ok<ept id=\"p1\">**</ept> if the conversion succeeds.","source":"**codecvt_base::ok** if the conversion succeeds."},{"pos":[27456,27551],"content":"<bpt id=\"p1\">**</bpt>codecvt_base::partial<ept id=\"p1\">**</ept> if the destination is not large enough for the conversion to succeed.","source":"**codecvt_base::partial** if the destination is not large enough for the conversion to succeed."},{"pos":[27561,27568],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function tries to convert the source element <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>(0) to a destination sequence that it stores within [ <ph id=\"ph1\">` first2`</ph>, <ph id=\"ph2\">` last2`</ph>), except for the terminating element <bpt id=\"p2\">**</bpt>Byte<ept id=\"p2\">**</ept>(0).","pos":[27572,27781],"source":"The protected virtual member function tries to convert the source element **CharType**(0) to a destination sequence that it stores within [ ` first2`, ` last2`), except for the terminating element **Byte**(0)."},{"content":"It always stores in <ph id=\"ph1\">` next2`</ph> a pointer to the first unaltered element in the destination sequence.","pos":[27782,27880],"source":" It always stores in ` next2` a pointer to the first unaltered element in the destination sequence."},{"content":"<ph id=\"ph1\">`_State`</ph> must represent the initial conversion state at the beginning of a new source sequence.","pos":[27887,27982],"source":"`_State` must represent the initial conversion state at the beginning of a new source sequence."},{"content":"The function alters its stored value, as needed, to reflect the current state of a successful conversion.","pos":[27983,28088]},{"content":"Typically, converting the source element <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>(0) leaves the current state in the initial conversion state.","pos":[28089,28203],"source":" Typically, converting the source element **CharType**(0) leaves the current state in the initial conversion state."},{"pos":[28210,28316],"content":"The member function returns <bpt id=\"p1\">[</bpt>do_unshift<ept id=\"p1\">](#codecvt__do_unshift)</ept>( <ph id=\"ph1\">`_State`</ph>, <ph id=\"ph2\">` first2`</ph>, <ph id=\"ph3\">` last2`</ph>, <ph id=\"ph4\">` next2`</ph> ).","source":"The member function returns [do_unshift](#codecvt__do_unshift)( `_State`, ` first2`, ` last2`, ` next2` )."},{"pos":[28325,28333],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>locale&gt;<ept id=\"p1\">](../standard-library/locale.md)</ept><ph id=\"ph2\"> </ph>","pos":[28337,28380],"source":"[\\<locale>](../standard-library/locale.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Code Pages<ept id=\"p1\">](../c-runtime-library/code-pages.md)</ept><ph id=\"ph1\"> </ph>","pos":[28383,28433],"source":" [Code Pages](../c-runtime-library/code-pages.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Locale Names, Languages, and Country/Region Strings<ept id=\"p1\">](../c-runtime-library/locale-names-languages-and-country-region-strings.md)</ept><ph id=\"ph1\"> </ph>","pos":[28436,28566],"source":" [Locale Names, Languages, and Country/Region Strings](../c-runtime-library/locale-names-languages-and-country-region-strings.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept>","pos":[28569,28679],"source":" [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)"}],"content":"---\ntitle: \"codecvt Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"codecvt\"\n  - \"std::codecvt\"\n  - \"std.codecvt\"\n  - \"xlocale/std::codecvt\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"codecvt class\"\nms.assetid: 37d3efa1-2b7f-42b6-b04f-7a972c8c2c86\ncaps.latest.revision: 23\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# codecvt Class\nA template class that describes an object that can serve as a locale facet. It is able to control conversions between a sequence of values used to encode characters within the program and a sequence of values used to encode characters outside the program.  \n  \n## Syntax  \n  \n```  \ntemplate <class CharType, class Byte, class StateType>  \nclass codecvt : public locale::facet, codecvt_base;  \n```  \n  \n#### Parameters  \n `CharType`  \n The type used within a program to encode characters.  \n  \n `Byte`  \n A type used to encode characters outside a program.  \n  \n `StateType`  \n A type that can be used to represent intermediate states of a conversion between internal and external types of character representations.  \n  \n## Remarks  \n The template class describes an object that can serve as a [locale facet](../standard-library/locale-class.md#facet_class), to control conversions between a sequence of values of type `CharType` and a sequence of values of type `Byte`. The class `StateType` characterizes the transformation -- and an object of class `StateType` stores any necessary state information during a conversion.  \n  \n The internal encoding uses a representation with a fixed number of bytes per character, usually either type `char` or type `wchar_t`.  \n  \n As with any locale facet, the static object `id` has an initial stored value of zero. The first attempt to access its stored value stores a unique positive value in `id`.  \n  \n The template versions of [do_in](#codecvt__do_in) and [do_out](#codecvt__do_out) always return `codecvt_base::noconv`.  \n  \n The Standard C++ Library defines several explicit specializations:  \n  \n `template<>`  \n  \n `codecvt<wchar_t, char, mbstate_t>`  \n  \n converts between `wchar_t` and `char` sequences.  \n  \n `template<>`  \n  \n `codecvt<char16_t, char, mbstate_t>`  \n  \n converts between `char16_t` sequences encoded as UTF-16 and `char` sequences encoded as UTF-8.  \n  \n `template<>`  \n  \n `codecvt<char32_t, char, mbstate_t>`  \n  \n converts between `char32_t` sequences encoded as UTF-32 (UCS-4) and `char` sequences encoded as UTF-8.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[codecvt](#codecvt__codecvt)|The constructor for objects of class `codecvt` that serves as a locale facet to handle conversions.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[extern_type](#codecvt__extern_type)|A character type that is used for external representations.|  \n|[intern_type](#codecvt__intern_type)|A character type that is used for internal representations.|  \n|[state_type](#codecvt__state_type)|A character type that is used to represent intermediate states during conversions between internal and external representations.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[always_noconv](#codecvt__always_noconv)|Tests whether no conversions need be done.|  \n|[do_always_noconv](#codecvt__do_always_noconv)|A virtual function called to test whether no conversions need be done.|  \n|[do_encoding](#codecvt__do_encoding)|A virtual function that tests if the encoding of the `Byte` stream is state dependent, whether the ratio between the `Byte`s used and the `CharType`s produced is constant, and, if so, determines the value of that ratio.|  \n|[do_in](#codecvt__do_in)|A virtual function called to convert a sequence of internal `Byte`s to a sequence of external `CharType`s.|  \n|[do_length](#codecvt__do_length)|A virtual function that determines how many `Byte`s from a given sequence of external `Byte`s produce not more than a given number of internal `CharType`s and returns that number of `Byte`s.|  \n|[do_max_length](#codecvt__do_max_length)|A virtual function that returns the maximum number of external Bytes necessary to produce one internal `CharType`.|  \n|[do_out](#codecvt__do_out)|A virtual function called to convert a sequence of internal `CharType`s to a sequence of external Bytes.|  \n|[do_unshift](#codecvt__do_unshift)|A virtual function called to provide the `Byte`s needed in a state-dependent conversion to complete the last character in a sequence of `Byte`s.|  \n|[encoding](#codecvt__encoding)|Tests if the encoding of the `Byte` stream is state dependent, whether the ratio between the `Byte`s used and the `CharType`s produced is constant, and, if so, determines the value of that ratio.|  \n|[in](#codecvt__in)|Converts an external representation of a sequence of `Byte`s to an internal representation of a sequence of `CharType`s.|  \n|[length](#codecvt__length)|Determines how many `Byte`s from a given sequence of external `Byte`s produce not more than a given number of internal `CharType`s and returns that number of `Byte`s.|  \n|[max_length](#codecvt__max_length)|Returns the maximum number of external `Byte`s necessary to produce one internal `CharType`.|  \n|[out](#codecvt__out)|Converts a sequence of internal `CharType`s to a sequence of external `Byte`s.|  \n|[unshift](#codecvt__unshift)|Provides the external `Byte`s needed in a state-dependent conversion to complete the last character in the sequence of `Byte`s.|  \n  \n## Requirements  \n **Header:** \\<locale>  \n  \n **Namespace:** std  \n  \n##  <a name=\"codecvt__always_noconv\"></a>  codecvt::always_noconv  \n Tests whether no conversions need be done.  \n  \n```  \nbool always_noconv() const throw();\n```  \n  \n### Return Value  \n A Boolean value that is **true** if no conversions need be done; **false** is at least one needs to be done.  \n  \n### Remarks  \n The member function returns [do_always_noconv](#codecvt__do_always_noconv).  \n  \n### Example  \n  \n```cpp  \n// codecvt_always_noconv.cpp  \n// compile with: /EHsc  \n#include <locale>  \n#include <iostream>  \nusing namespace std;  \n  \nint main( )     \n{  \n   locale loc ( \"German_Germany\" );  \n   bool result1 = use_facet<codecvt<char, char, mbstate_t> >   \n      ( loc ).always_noconv( );  \n  \n   if ( result1 )  \n      cout << \"No conversion is needed.\" << endl;  \n   else  \n      cout << \"At least one conversion is required.\" << endl;  \n  \n   bool result2 = use_facet<codecvt<wchar_t, char, mbstate_t> >   \n      ( loc ).always_noconv( );  \n  \n   if ( result2 )  \n      cout << \"No conversion is needed.\" << endl;  \n   else  \n      cout << \"At least one conversion is required.\" << endl;  \n}  \n```  \n  \n```Output  \nNo conversion is needed.  \nAt least one conversion is required.  \n```  \n  \n##  <a name=\"codecvt__codecvt\"></a>  codecvt::codecvt  \n The constructor for objects of class codecvt that serves as a locale facet to handle conversions.  \n  \n```  \nexplicit codecvt(size_t _Refs = 0);\n```  \n  \n### Parameters  \n `_Refs`  \n Integer value used to specify the type of memory management for the object.  \n  \n### Remarks  \n The possible values for the `_Refs` parameter and their significance are:  \n  \n-   0: The lifetime of the object is managed by the locales that contain it.  \n  \n-   1: The lifetime of the object must be manually managed.  \n  \n-   \\> 0: These values are not defined.  \n  \n The constructor initializes its `locale::facet` base object with **locale::**[facet](../standard-library/locale-class.md#facet_class)( `_Refs`) *.*  \n  \n##  <a name=\"codecvt__do_always_noconv\"></a>  codecvt::do_always_noconv  \n A virtual function called to test whether no conversions need be done.  \n  \n```  \nvirtual bool do_always_noconv() const throw();\n```  \n  \n### Return Value  \n The protected virtual member function returns **true** only if every call to [do_in](#codecvt__do_in) or [do_out](#codecvt__do_out) returns **noconv**.  \n  \n The template version always returns **true**.  \n  \n### Example  \n  See the example for [always_noconv](#codecvt__always_noconv), which calls `do_always_noconv`.  \n  \n##  <a name=\"codecvt__do_encoding\"></a>  codecvt::do_encoding  \n A virtual function that tests if the encoding of the **Byte** stream is state dependent, whether the ratio between the **Byte**s used and the **CharType**s produced is constant and, if so, determines the value of that ratio.  \n  \n```  \nvirtual int do_encoding() const throw();\n```  \n  \n### Return Value  \n The protected virtual member function returns:  \n  \n-   –1, if the encoding of sequences of type `extern_type` is state dependent.  \n  \n-   0, if the encoding involves sequences of varying lengths.  \n  \n- *N*, if the encoding involves only sequences of length *N*  \n  \n### Example  \n  See the example for [encoding](#codecvt__encoding), which calls `do_encoding`.  \n  \n##  <a name=\"codecvt__do_in\"></a>  codecvt::do_in  \n A virtual function called to convert a sequence of external **Byte**s to a sequence of internal **CharType**s.  \n  \n```  \nvirtual result do_in(\n    StateType& _State,  \n    const Byte* first1,   \n    const Byte* last1,   \n    const Byte*& next1,  \n    CharType* first2,  \n    CharType* last2,  \n    CharType*& next2,) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the sequence to be converted.  \n  \n ` last1`  \n Pointer to the end of the sequence to be converted.  \n  \n ` next1`  \n Pointer beyond the end of the converted sequence, to the first unconverted character.  \n  \n ` first2`  \n Pointer to the beginning of the converted sequence.  \n  \n ` last2`  \n Pointer to the end of the converted sequence.  \n  \n ` next2`  \n Pointer to the **CharType** that comes after the last converted **CharType**, to the first unaltered character in the destination sequence.  \n  \n### Return Value  \n A return that indicates the success, partial success, or failure of the operation. The function returns:  \n  \n- **codecvt_base::error** if the source sequence is ill formed.  \n  \n- `codecvt_base::noconv` if the function performs no conversion.  \n  \n- **codecvt_base::ok** if the conversion succeeds.  \n  \n- **codecvt_base::partial** if the source is insufficient or if the destination is not large enough, for the conversion to succeed.  \n  \n### Remarks  \n `_State` must represent the initial conversion state at the beginning of a new source sequence. The function alters its stored value as needed to reflect the current state of a successful conversion. Its stored value is otherwise unspecified.  \n  \n### Example  \n  See the example for [in](#codecvt__in), which calls `do_in`.  \n  \n##  <a name=\"codecvt__do_length\"></a>  codecvt::do_length  \n A virtual function that determines how many **Byte**s from a given sequence of external **Byte**s produce not more than a given number of internal **CharType**s and returns that number of **Byte**s.  \n  \n```  \nvirtual int do_length(\n    const StateType& _State,  \n    const Byte* first1,   \n    const Byte* last1,  \n    size_t _Len2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the external sequence.  \n  \n ` last1`  \n Pointer to the end of the external sequence.  \n  \n `_Len2`  \n The maximum number of **Byte**s that can be returned by the member function.  \n  \n### Return Value  \n An integer that represents a count of the maximum number of conversions, not greater than `_Len2`, defined by the external source sequence at [ ` first1`, ` last1`).  \n  \n### Remarks  \n The protected virtual member function effectively calls `do_in`( `_State`, ` first1`, ` last1`, ` next1`, `_Buf`, `_Buf` + `_Len2`, ` next2`) for `_State` (a copy of state), some buffer `_Buf`, and pointers ` next1`and ` next2`.  \n  \n It then returns ` next2` – **buf**. Thus, it counts the maximum number of conversions, not greater than `_Len2`, defined by the source sequence at [ ` first1`, ` last1`).  \n  \n The template version always returns the lesser of ` last1` – ` first1` and `_Len2`.  \n  \n### Example  \n  See the example for [length](#codecvt__length), which calls **do_length**.  \n  \n##  <a name=\"codecvt__do_max_length\"></a>  codecvt::do_max_length  \n A virtual function that returns the maximum number of external **Byte**s necessary to produce one internal **CharType**.  \n  \n```  \nvirtual int do_max_length() const throw();\n```  \n  \n### Return Value  \n The maximum number of **Byte**s necessary to produce one **CharType**.  \n  \n### Remarks  \n The protected virtual member function returns the largest permissible value that can be returned by [do_length](#codecvt__do_length)( ` first1`, ` last1`, 1) for arbitrary valid values of ` first1` and ` last1`.  \n  \n### Example  \n  See the example for [max_length](#codecvt__max_length), which calls `do_max_length`.  \n  \n##  <a name=\"codecvt__do_out\"></a>  codecvt::do_out  \n A virtual function called to convert a sequence of internal **CharType**s to a sequence of external **Byte**s.  \n  \n```  \nvirtual result do_out(\n    StateType& _State,  \n    const CharType* first1,   \n    const CharType* last1,  \n    const CharType*& next1,  \n    Byte* first2,   \n    Byte* last2,   \n    Byte*& next2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the sequence to be converted.  \n  \n ` last1`  \n Pointer to the end of the sequence to be converted.  \n  \n ` next1`  \n Reference to a pointer to the first unconverted **CharType**, after the last **CharType** converted.  \n  \n ` first2`  \n Pointer to the beginning of the converted sequence.  \n  \n ` last2`  \n Pointer to the end of the converted sequence.  \n  \n ` next2`  \n Reference to a pointer to the first unconverted **Byte**, after the last **Byte** converted.  \n  \n### Return Value  \n The function returns:  \n  \n- **codecvt_base::error** if the source sequence is ill formed.  \n  \n- `codecvt_base::noconv` if the function performs no conversion.  \n  \n- **codecvt_base::ok** if the conversion succeeds.  \n  \n- **codecvt_base::partial** if the source is insufficient or if the destination is not large enough for the conversion to succeed.  \n  \n### Remarks  \n `_State` must represent the initial conversion state at the beginning of a new source sequence. The function alters its stored value as needed to reflect the current state of a successful conversion. Its stored value is otherwise unspecified.  \n  \n### Example  \n  See the example for [out](#codecvt__out), which calls `do_out`.  \n  \n##  <a name=\"codecvt__do_unshift\"></a>  codecvt::do_unshift  \n A virtual function called to provide the **Byte**s needed in a state-dependent conversion to complete the last character in a sequence of **Byte**s.  \n  \n```  \nvirtual result do_unshift(\n    StateType& _State,  \n    Byte* first2,   \n    Byte* last2,   \n    Byte*& next2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first2`  \n Pointer to the first position in the destination range.  \n  \n ` last2`  \n Pointer to the last position in the destination range.  \n  \n ` next2`  \n Pointer to the first unaltered element in the destination sequence.  \n  \n### Return Value  \n The function returns:  \n  \n- **codecvt_base::error** if _ *State* represents an invalid state  \n  \n- `codecvt_base::noconv` if the function performs no conversion  \n  \n- **codecvt_base::ok** if the conversion succeeds  \n  \n- **codecvt_base::partial** if the destination is not large enough for the conversion to succeed  \n  \n### Remarks  \n The protected virtual member function tries to convert the source element **CharType**(0) to a destination sequence that it stores within [ ` first2`, ` last2`), except for the terminating element **Byte**(0). It always stores in ` next2` a pointer to the first unaltered element in the destination sequence.  \n  \n _ *State* must represent the initial conversion state at the beginning of a new source sequence. The function alters its stored value as needed to reflect the current state of a successful conversion. Typically, converting the source element **CharType**(0) leaves the current state in the initial conversion state.  \n  \n### Example  \n  See the example for [unshift](#codecvt__unshift), which calls `do_unshift`.  \n  \n##  <a name=\"codecvt__encoding\"></a>  codecvt::encoding  \n Tests if the encoding of the **Byte** stream is state dependent, whether the ratio between the **Byte**s used and the **CharType**s produced is constant, and, if so, determines the value of that ratio.  \n  \n```  \nint encoding() const throw();\n```  \n  \n### Return Value  \n If the return value is positive then that value is the constant number of **Byte** characters required to produce the **CharType** character.  \n  \n The protected virtual member function returns:  \n  \n-   –1, if the encoding of sequences of type `extern_type` is state dependent.  \n  \n-   0, if the encoding involves sequences of varying lengths.  \n  \n- *N*, if the encoding involves only sequences of length *N.*  \n  \n### Remarks  \n The member function returns [do_encoding](#codecvt__do_encoding).  \n  \n### Example  \n  \n```cpp  \n// codecvt_encoding.cpp  \n// compile with: /EHsc  \n#include <locale>  \n#include <iostream>  \nusing namespace std;  \n  \nint main( )     \n{  \n   locale loc ( \"German_Germany\" );  \n   int result1 = use_facet<codecvt<char, char, mbstate_t> > ( loc ).encoding ( );  \n   cout << result1 << endl;  \n   result1 = use_facet<codecvt<wchar_t, char, mbstate_t> > ( loc ).encoding( );  \n   cout << result1 << endl;  \n   result1 = use_facet<codecvt<char, wchar_t, mbstate_t> > ( loc ).encoding( );  \n   cout << result1 << endl;  \n}  \n```  \n  \n```Output  \n1  \n1  \n1  \n```  \n  \n##  <a name=\"codecvt__extern_type\"></a>  codecvt::extern_type  \n A character type that is used for external representations.  \n  \n```  \ntypedef Byte extern_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **Byte**.  \n  \n##  <a name=\"codecvt__in\"></a>  codecvt::in  \n Converts an external representation of a sequence of **Byte**s to an internal representation of a sequence of **CharType**s.  \n  \n```  \nresult in(\n    StateType& _State,  \n    const Byte* first1,   \n    const Byte* last1,   \n    const Byte*& next1,  \n    CharType* first2,  \n    CharType* last2,  \n    CharType*& next2,) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the sequence to be converted.  \n  \n ` last1`  \n Pointer to the end of the sequence to be converted.  \n  \n ` next1`  \n Pointer beyond the end of the converted sequence to the first unconverted character.  \n  \n ` first2`  \n Pointer to the beginning of the converted sequence.  \n  \n ` last2`  \n Pointer to the end of the converted sequence.  \n  \n ` next2`  \n Pointer to the **CharType** that comes after the last converted **Chartype** to the first unaltered character in the destination sequence.  \n  \n### Return Value  \n A return that indicates the success, partial success or failure of the operation. The function returns:  \n  \n- **codecvt_base::error** if the source sequence is ill formed.  \n  \n- `codecvt_base::noconv` if the function performs no conversion.  \n  \n- **codecvt_base::ok** if the conversion succeeds.  \n  \n- **codecvt_base::partial** if the source is insufficient or if the destination is not large enough for the conversion to succeed.  \n  \n### Remarks  \n `_State` must represent the initial conversion state at the beginning of a new source sequence. The function alters its stored value, as needed, to reflect the current state of a successful conversion. After a partial conversion, `_State` must be set so as to allow the conversion to resume when new characters arrive.  \n  \n The member function returns [do_in](#codecvt__do_in)( `_State`, _ *First1,  last1,  next1, First2, _Llast2,  next2*).  \n  \n### Example  \n  \n```cpp  \n// codecvt_in.cpp  \n// compile with: /EHsc  \n#define _INTL  \n#include <locale>  \n#include <iostream>  \nusing namespace std;  \n#define LEN 90  \nint main( )     \n{  \n   char* pszExt = \"This is the string to be converted!\";  \n   wchar_t pwszInt [LEN+1];  \n   memset(&pwszInt[0], 0, (sizeof(wchar_t))*(LEN+1));  \n   const char* pszNext;  \n   wchar_t* pwszNext;  \n   mbstate_t state = {0};  \n   locale loc(\"C\");//English_Britain\");//German_Germany  \n   int res = use_facet<codecvt<wchar_t, char, mbstate_t> >  \n     ( loc ).in( state,  \n          pszExt, &pszExt[strlen(pszExt)], pszNext,  \n          pwszInt, &pwszInt[strlen(pszExt)], pwszNext );  \n   pwszInt[strlen(pszExt)] = 0;  \n   wcout << ( (res!=codecvt_base::error)  L\"It worked! \" : L\"It didn't work! \" )  \n   << L\"The converted string is:\\n [\"  \n   << &pwszInt[0]  \n   << L\"]\" << endl;  \n   exit(-1);  \n}  \n```  \n  \n```Output  \nIt worked! The converted string is:  \n [This is the string to be converted!]  \n```  \n  \n##  <a name=\"codecvt__intern_type\"></a>  codecvt::intern_type  \n A character type that is used for internal representations.  \n  \n```  \ntypedef CharType intern_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **CharType**.  \n  \n##  <a name=\"codecvt__length\"></a>  codecvt::length  \n Determines how many **Byte**s from a given sequence of external **Byte**s produce not more than a given number of internal **CharType**s and returns that number of **Byte**s.  \n  \n```  \nint length(\n    const StateType& _State,  \n    const Byte* first1,   \n    const Byte* last1,  \n    size_t _Len2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the external sequence.  \n  \n ` last1`  \n Pointer to the end of the external sequence.  \n  \n `_Len2`  \n The maximum number of Bytes that can be returned by the member function.  \n  \n### Return Value  \n An integer that represents a count of the maximum number of conversions, not greater than `_Len2`, defined by the external source sequence at [ ` first1`, ` last1`).  \n  \n### Remarks  \n The member function returns [do_length](#codecvt__do_length)( *_State,  first1*, ` last1`, `_Len2`).  \n  \n### Example  \n  \n```cpp  \n// codecvt_length.cpp  \n// compile with: /EHsc  \n#define _INTL  \n#include <locale>  \n#include <iostream>  \nusing namespace std;  \n#define LEN 90  \nint main( )     \n{  \n   char* pszExt = \"This is the string whose length is to be measured!\";  \n   mbstate_t state = {0};  \n   locale loc(\"C\");//English_Britain\");//German_Germany  \n   int res = use_facet<codecvt<wchar_t, char, mbstate_t> >  \n     ( loc ).length( state,  \n          pszExt, &pszExt[strlen(pszExt)], LEN );  \n   cout << \"The length of the string is: \";  \n   wcout << res;  \n   cout << \".\" << endl;  \n   exit(-1);  \n}  \n```  \n  \n```Output  \nThe length of the string is: 50.  \n```  \n  \n##  <a name=\"codecvt__max_length\"></a>  codecvt::max_length  \n Returns the maximum number of external **Byte**s necessary to produce one internal **CharType**.  \n  \n```  \nint max_length() const throw();\n```  \n  \n### Return Value  \n The maximum number of **Byte**s necessary to produce one **CharType**.  \n  \n### Remarks  \n The member function returns [do_max_length](#codecvt__do_max_length).  \n  \n### Example  \n  \n```cpp  \n// codecvt_max_length.cpp  \n// compile with: /EHsc  \n#define _INTL  \n#include <locale>  \n#include <iostream>  \nusing namespace std;  \n  \nint main( )     \n{  \n   locale loc( \"C\");//English_Britain\" );//German_Germany  \n   int res = use_facet<codecvt<char, char, mbstate_t> >  \n     ( loc ).max_length( );  \n   wcout << res << endl;  \n}  \n```  \n  \n```Output  \n1  \n```  \n  \n##  <a name=\"codecvt__out\"></a>  codecvt::out  \n Converts a sequence of internal **CharType**s to a sequence of external **Byte**s.  \n  \n```  \nresult out(\n    StateType& _State,  \n    const CharType* first1,   \n    const CharType* last1,  \n    const CharType*& next1,  \n    Byte* first2,   \n    Byte* last2,   \n    Byte*& next2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first1`  \n Pointer to the beginning of the sequence to be converted.  \n  \n ` last1`  \n Pointer to the end of the sequence to be converted.  \n  \n ` next1`  \n Reference to a pointer to the first unconverted **CharType** after the last **CharType** converted.  \n  \n ` first2`  \n Pointer to the beginning of the converted sequence.  \n  \n ` last2`  \n Pointer to the end of the converted sequence.  \n  \n ` next2`  \n Reference to a pointer to the first unconverted **Byte** after the last converted **Byte**.  \n  \n### Return Value  \n The member function returns [do_out](#codecvt__do_out)( `_State`, ` first1`, ` last1`, ` next1`, ` first2`, ` last2`, ` next2`).  \n  \n### Remarks  \n For more information, see [codecvt::do_out](#codecvt__do_out).  \n  \n### Example  \n  \n```cpp  \n// codecvt_out.cpp  \n// compile with: /EHsc  \n#define _INTL  \n#include <locale>  \n#include <iostream>  \n#include <wchar.h>  \nusing namespace std;  \n#define LEN 90  \nint main( )     \n{  \n   char pszExt[LEN+1];  \n   wchar_t *pwszInt = L\"This is the wchar_t string to be converted.\";  \n   memset( &pszExt[0], 0, ( sizeof( char ) )*( LEN+1 ) );  \n   char* pszNext;  \n   const wchar_t* pwszNext;  \n   mbstate_t state;  \n   locale loc(\"C\");//English_Britain\");//German_Germany  \n   int res = use_facet<codecvt<wchar_t, char, mbstate_t> >  \n      ( loc ).out( state,  \n      pwszInt, &pwszInt[wcslen( pwszInt )], pwszNext ,  \n      pszExt, &pszExt[wcslen( pwszInt )], pszNext );  \n   pszExt[wcslen( pwszInt )] = 0;  \n   cout << ( ( res!=codecvt_base::error )  \"It worked: \" : \"It didn't work: \" )  \n   << \"The converted string is:\\n [\"  \n   << &pszExt[0]  \n   << \"]\" << endl;  \n}  \n```  \n  \n```Output  \nIt worked: The converted string is:  \n [This is the wchar_t string to be converted.]  \n```  \n  \n##  <a name=\"codecvt__state_type\"></a>  codecvt::state_type  \n A character type that is used to represent intermediate states during conversions between internal and external representations.  \n  \n```  \ntypedef StateType state_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **StateType**.  \n  \n##  <a name=\"codecvt__unshift\"></a>  codecvt::unshift  \n Provides the **Byte**s needed in a state-dependent conversion to complete the last character in a sequence of **Byte**s.  \n  \n```  \nresult unshift(\n    StateType& _State,  \n    Byte* first2,   \n    Byte* last2,   \n    Byte*& next2) const;\n```  \n  \n### Parameters  \n `_State`  \n The conversion state that is maintained between calls to the member function.  \n  \n ` first2`  \n Pointer to the first position in the destination range.  \n  \n ` last2`  \n Pointer to the last position in the destination range.  \n  \n ` next2`  \n Pointer to the first unaltered element in the destination sequence.  \n  \n### Return Value  \n The function returns:  \n  \n- **codecvt_base::error** if state represents an invalid state.  \n  \n- `codecvt_base::noconv` if the function performs no conversion.  \n  \n- **codecvt_base::ok** if the conversion succeeds.  \n  \n- **codecvt_base::partial** if the destination is not large enough for the conversion to succeed.  \n  \n### Remarks  \n The protected virtual member function tries to convert the source element **CharType**(0) to a destination sequence that it stores within [ ` first2`, ` last2`), except for the terminating element **Byte**(0). It always stores in ` next2` a pointer to the first unaltered element in the destination sequence.  \n  \n `_State` must represent the initial conversion state at the beginning of a new source sequence. The function alters its stored value, as needed, to reflect the current state of a successful conversion. Typically, converting the source element **CharType**(0) leaves the current state in the initial conversion state.  \n  \n The member function returns [do_unshift](#codecvt__do_unshift)( `_State`, ` first2`, ` last2`, ` next2` ).  \n  \n## See Also  \n [\\<locale>](../standard-library/locale.md)   \n [Code Pages](../c-runtime-library/code-pages.md)   \n [Locale Names, Languages, and Country/Region Strings](../c-runtime-library/locale-names-languages-and-country-region-strings.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}