{"nodes":[{"pos":[12,68],"content":"How to: Wrap Native Class for Use by C# | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Wrap Native Class for Use by C# | Microsoft Docs","pos":[0,56]}]},{"content":"How to: Wrap Native Class for Use by C","pos":[656,694]},{"content":"This sample shows how to wrap a native C++ class so it can be consumed by code authored in C#, or other .NET language.","pos":[696,814]},{"content":"Example","pos":[823,830]},{"content":"See Also","pos":[1927,1935]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[1940,1976]}],"content":"---\ntitle: \"How to: Wrap Native Class for Use by C# | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"native code [C++], Visual C# and\"\n  - \"classes [C++], Visual C# and\"\nms.assetid: 988819ae-cc6a-4453-8ff5-be369210d962\ncaps.latest.revision: 3\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Wrap Native Class for Use by C#\nThis sample shows how to wrap a native C++ class so it can be consumed by code authored in C#, or other .NET language.  \n  \n## Example  \n  \n```  \n// wrap_native_class_for_mgd_consumption.cpp  \n// compile with: /clr /LD  \n#include <windows.h>  \n#include <vcclr.h>  \n#using <System.dll>  \n  \nusing namespace System;  \n  \nclass UnmanagedClass {  \npublic:  \n   LPCWSTR GetPropertyA() { return 0; }  \n   void MethodB( LPCWSTR ) {}  \n};  \n  \npublic ref class ManagedClass {  \npublic:  \n   // Allocate the native object on the C++ Heap via a constructor  \n   ManagedClass() : m_Impl( new UnmanagedClass ) {}  \n  \n   // Deallocate the native object on a destructor  \n   ~ManagedClass() {  \n      delete m_Impl;  \n   }  \n  \nprotected:  \n   // Deallocate the native object on the finalizer just in case no destructor is called  \n   !ManagedClass() {  \n      delete m_Impl;  \n   }  \n  \npublic:  \n   property String ^  get_PropertyA {  \n      String ^ get() {  \n         return gcnew String( m_Impl->GetPropertyA());  \n      }  \n   }  \n  \n   void MethodB( String ^ theString ) {  \n      pin_ptr<const WCHAR> str = PtrToStringChars(theString);  \n      m_Impl->MethodB(str);  \n   }  \n  \nprivate:  \n   UnmanagedClass * m_Impl;  \n};  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}