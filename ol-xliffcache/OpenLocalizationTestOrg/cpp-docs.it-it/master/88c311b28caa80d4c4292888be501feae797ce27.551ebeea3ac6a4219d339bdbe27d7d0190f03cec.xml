{"nodes":[{"pos":[12,54],"content":"&lt;numeric&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>numeric<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,42],"source":"&lt;numeric&gt; functions | Microsoft Docs"}]},{"pos":[257,282],"content":"&lt;numeric&gt; functions","linkify":"&lt;numeric&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>numeric<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,25],"source":"&lt;numeric&gt; functions"}]},{"pos":[301,326],"content":"<bpt id=\"p1\">[</bpt>accumulate<ept id=\"p1\">](#accumulate)</ept>","source":"[accumulate](#accumulate)"},{"pos":[327,370],"content":"<bpt id=\"p1\">[</bpt>adjacent_difference<ept id=\"p1\">](#adjacent_difference)</ept>","source":"[adjacent_difference](#adjacent_difference)"},{"pos":[371,402],"content":"<bpt id=\"p1\">[</bpt>inner_product<ept id=\"p1\">](#inner_product)</ept>","source":"[inner_product](#inner_product)"},{"pos":[407,420],"content":"<bpt id=\"p1\">[</bpt>iota<ept id=\"p1\">](#iota)</ept>","source":"[iota](#iota)"},{"pos":[421,448],"content":"<bpt id=\"p1\">[</bpt>partial_sum<ept id=\"p1\">](#partial_sum)</ept>","source":"[partial_sum](#partial_sum)"},{"pos":[459,496],"content":"<bpt id=\"p1\">&lt;a name=\"accumulate\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  accumulate","linkify":"<a name=\"accumulate\"></a>  accumulate","source":"<a name=\"accumulate\"></a>  accumulate"},{"content":"Computes the sum of all the elements in a specified range including some initial value by computing successive partial sums or computes the result of successive partial results similarly obtained from using a specified binary operation other than the sum.","pos":[500,755]},{"pos":[1077,1087],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator addressing the first element in the range to be summed or combined according to a specified binary operation.","pos":[1104,1231]},{"content":"An input iterator addressing the last element in the range to be summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.","pos":[1249,1468]},{"content":"An initial value to which each element is in turn added or combined with according to a specified binary operation.","pos":[1485,1600]},{"content":"The binary operation that is to be applied to the each element in the specified range and the result of its previous applications.","pos":[1622,1752]},{"pos":[1762,1774],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[1778,2167],"content":"The sum of <ph id=\"ph1\">` val`</ph> and all the elements in the specified range for the first template function, or, for the second template function, the result of applying the binary operation specified, instead of the sum operation, to ( <bpt id=\"p1\">*</bpt>PartialResult, <ph id=\"ph2\">\\*</ph>Iter<ept id=\"p1\">*</ept>), where <bpt id=\"p2\">*</bpt>PartialResult<ept id=\"p2\">*</ept> is the result of previous applications of the operation and <ph id=\"ph3\">`Iter`</ph> is an iterator pointing to an element in the range.","source":"The sum of ` val` and all the elements in the specified range for the first template function, or, for the second template function, the result of applying the binary operation specified, instead of the sum operation, to ( *PartialResult, \\*Iter*), where *PartialResult* is the result of previous applications of the operation and `Iter` is an iterator pointing to an element in the range."},{"pos":[2177,2184],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The initial value insures that there will be a well-defined result when the range is empty, in which case <ph id=\"ph1\">` val`</ph> is returned.","pos":[2188,2313],"source":"The initial value insures that there will be a well-defined result when the range is empty, in which case ` val` is returned."},{"content":"The binary operation does not need to be associative or commutative.","pos":[2314,2382]},{"content":"The result is initialized to the initial value <ph id=\"ph1\">` val`</ph> and then <bpt id=\"p1\">*</bpt>result<ept id=\"p1\">*</ept><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`binary_op`</ph> ( <bpt id=\"p2\">*</bpt>result<ept id=\"p2\">*</ept>, <bpt id=\"p3\">**</bpt><ph id=\"ph4\">\\*</ph><ept id=\"p3\">**</ept><ph id=\"ph5\">`Iter`</ph>) is calculated iteratively through the range, where <ph id=\"ph6\">`Iter`</ph> is an iterator pointing to successive element in the range.","pos":[2383,2612],"source":" The result is initialized to the initial value ` val` and then *result* = `binary_op` ( *result*, **\\***`Iter`) is calculated iteratively through the range, where `Iter` is an iterator pointing to successive element in the range."},{"content":"The range must be valid and the complexity is linear with the size of the range.","pos":[2613,2693]},{"content":"The return type of the binary operator must be convertible to <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> to ensure closure during the iteration.","pos":[2694,2804],"source":" The return type of the binary operator must be convertible to **Type** to ensure closure during the iteration."},{"pos":[2814,2821],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5494,5549],"content":"<bpt id=\"p1\">&lt;a name=\"adjacent_difference\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  adjacent_difference","linkify":"<a name=\"adjacent_difference\"></a>  adjacent_difference","source":"<a name=\"adjacent_difference\"></a>  adjacent_difference"},{"content":"Computes the successive differences between each element and its predecessor in an input range and outputs the results to a destination range or computes the result of a generalized procedure where the difference operation is replaced by another, specified binary operation.","pos":[5553,5827]},{"pos":[6242,6252],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator addressing the first element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.","pos":[6268,6493]},{"content":"An input iterator addressing the last element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.","pos":[6511,6735]},{"content":"An output iterator addressing the first element a destination range where the series of differences or the results of the specified operation is to be stored.","pos":[6754,6912]},{"content":"The binary operation that is to be applied in the generalized operation replacing the operation of subtraction in the differencing procedure.","pos":[6934,7075]},{"pos":[7085,7097],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[7101,7198],"content":"An output iterator addressing the end of the destination range: <ph id=\"ph1\">`result`</ph> + ( <ph id=\"ph2\">` last`</ph><ph id=\"ph3\"> - </ph><ph id=\"ph4\">` first`</ph>).","source":"An output iterator addressing the end of the destination range: `result` + ( ` last` - ` first`)."},{"pos":[7208,7215],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7219,7373],"content":"The output iterator _ <bpt id=\"p1\">*</bpt>result<ept id=\"p1\">*</ept> is allowed to be the same iterator as the input iterator <bpt id=\"p2\">*</bpt> first,<ept id=\"p2\">*</ept> so that <ph id=\"ph1\">`adjacent_difference`</ph>s may be computed in place.","source":"The output iterator _ *result* is allowed to be the same iterator as the input iterator * first,* so that `adjacent_difference`s may be computed in place."},{"pos":[7380,7567],"content":"For a sequence of values <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>1, <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>2, <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>3, in an input range, the first template function stores successive <bpt id=\"p4\">**</bpt>partial_difference<ept id=\"p4\">**</ept>s <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>1, <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>2 - <bpt id=\"p7\">*</bpt>a<ept id=\"p7\">*</ept>1, a3 – <bpt id=\"p8\">*</bpt>a<ept id=\"p8\">*</ept>2, in the destination range.","source":"For a sequence of values *a*1, *a*2, *a*3, in an input range, the first template function stores successive **partial_difference**s *a*1, *a*2 - *a*1, a3 – *a*2, in the destination range."},{"pos":[7574,7784],"content":"For a sequence of values <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>1, <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>2, <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>3, in an input range, the second template function stores successive <bpt id=\"p4\">**</bpt>partial_difference<ept id=\"p4\">**</ept>s <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>1, <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>2 <ph id=\"ph1\">`binary_op`</ph> <bpt id=\"p7\">*</bpt>a<ept id=\"p7\">*</ept>1, <bpt id=\"p8\">*</bpt>a<ept id=\"p8\">*</ept>3 <ph id=\"ph2\">`binary_op`</ph> <bpt id=\"p9\">*</bpt>a<ept id=\"p9\">*</ept>2, in the destination range.","source":"For a sequence of values *a*1, *a*2, *a*3, in an input range, the second template function stores successive **partial_difference**s *a*1, *a*2 `binary_op` *a*1, *a*3 `binary_op` *a*2, in the destination range."},{"pos":[7791,7945],"content":"The binary operation <ph id=\"ph1\">`binary_op`</ph> is not required to be either associative or commutative, because the order of operations applies is completely specified.","source":"The binary operation `binary_op` is not required to be either associative or commutative, because the order of operations applies is completely specified."},{"pos":[7955,7962],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9816,9859],"content":"<bpt id=\"p1\">&lt;a name=\"inner_product\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  inner_product","linkify":"<a name=\"inner_product\"></a>  inner_product","source":"<a name=\"inner_product\"></a>  inner_product"},{"content":"Computes the sum of the element-wise product of two ranges and adds it to a specified initial value or computes the result of a generalized procedure where the sum and product binary operations are replaced by other specified binary operations.","pos":[9863,10107]},{"pos":[10659,10669],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator addressing the first element in the first range whose inner product or generalized inner product with the second range is to be computed.","pos":[10686,10841]},{"content":"An input iterator addressing the last element in the first range whose inner product or generalized inner product with the second range is to be computed.","pos":[10860,11014]},{"content":"An input iterator addressing the first element in the second range whose inner product or generalized inner product with the first range is to be computed.","pos":[11034,11189]},{"content":"An initial value to which the inner product or generalized inner product between the ranges is to be added.","pos":[11206,11313]},{"content":"<bpt id=\"p1\">*</bpt>binary_op1<ept id=\"p1\">*</ept>","pos":[11320,11332],"source":"*binary_op1*"},{"content":"The binary operation that replaces the inner product operation of sum applied to the element-wise products in the generalization of the inner product.","pos":[11336,11486]},{"content":"<bpt id=\"p1\">*</bpt>binary_op2<ept id=\"p1\">*</ept>","pos":[11493,11505],"source":"*binary_op2*"},{"content":"The binary operation that replaces the inner product element-wise operation of multiply in the generalization of the inner product.","pos":[11509,11640]},{"pos":[11650,11662],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The first member function returns the sum of the element-wise products and adds to it the specified initial value.","pos":[11666,11780]},{"content":"So for ranges of values <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>i and <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept>i, it returns:","pos":[11781,11831],"source":" So for ranges of values *a*i and *b*i, it returns:"},{"pos":[11838,11884],"content":"<ph id=\"ph1\">` val`</ph> + ( <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>1 <ph id=\"ph2\">\\*</ph> <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept>1 ) + ( <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>2 <ph id=\"ph3\">\\*</ph> <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>2 ) +","source":"` val` + ( *a*1 \\* *b*1 ) + ( *a*2 \\* *b*2 ) +"},{"pos":[11891,11959],"content":"by iteratively replacing <ph id=\"ph1\">` val`</ph> with <ph id=\"ph2\">` val`</ph> + (<ph id=\"ph3\">\\*</ph> <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>i <ph id=\"ph4\">\\*</ph> <ph id=\"ph5\">\\*</ph> <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept>i ).","source":"by iteratively replacing ` val` with ` val` + (\\* *a*i \\* \\* *b*i )."},{"content":"The second member function returns:","pos":[11966,12001]},{"pos":[12008,12121],"content":"<ph id=\"ph1\">` val`</ph> _ <bpt id=\"p1\">*</bpt>Binary_op1<ept id=\"p1\">*</ept> ( <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>1 <ph id=\"ph2\">\\_</ph> <bpt id=\"p3\">*</bpt>Binary_op2<ept id=\"p3\">*</ept> <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>1 ) <ph id=\"ph3\">\\_</ph> <bpt id=\"p5\">*</bpt>Binary_op1<ept id=\"p5\">*</ept> ( <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>2 <ph id=\"ph4\">\\_</ph> <bpt id=\"p7\">*</bpt>Binary_op2<ept id=\"p7\">*</ept> <bpt id=\"p8\">*</bpt>b<ept id=\"p8\">*</ept>2 ) <ph id=\"ph5\">\\_</ph> <bpt id=\"p9\">*</bpt>Binary_op1<ept id=\"p9\">*</ept>","source":"` val` _ *Binary_op1* ( *a*1 \\_ *Binary_op2* *b*1 ) \\_ *Binary_op1* ( *a*2 \\_ *Binary_op2* *b*2 ) \\_ *Binary_op1*"},{"pos":[12128,12222],"content":"by iteratively replacing <ph id=\"ph1\">` val`</ph> with <ph id=\"ph2\">` val`</ph> _ <bpt id=\"p1\">*</bpt>Binary_op1<ept id=\"p1\">*</ept> (<ph id=\"ph3\">\\*</ph> <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>i <ph id=\"ph4\">\\_</ph> <bpt id=\"p3\">*</bpt>Binary_op2<ept id=\"p3\">*</ept> <ph id=\"ph5\">\\*</ph> <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>i ).","source":"by iteratively replacing ` val` with ` val` _ *Binary_op1* (\\* *a*i \\_ *Binary_op2* \\* *b*i )."},{"pos":[12232,12239],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The initial value ensures that there will be a well-defined result when the range is empty, in which case <ph id=\"ph1\">` val`</ph> is returned.","pos":[12243,12368],"source":"The initial value ensures that there will be a well-defined result when the range is empty, in which case ` val` is returned."},{"content":"The binary operations do not need to be associative or commutative.","pos":[12369,12436]},{"content":"The range must be valid and the complexity is linear with the size of the range.","pos":[12437,12517]},{"content":"The return type of the binary operator must be convertible to <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> to ensure closure during the iteration.","pos":[12518,12628],"source":" The return type of the binary operator must be convertible to **Type** to ensure closure during the iteration."},{"pos":[12638,12645],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15162,15187],"content":"<bpt id=\"p1\">&lt;a name=\"iota\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  iota","linkify":"<a name=\"iota\"></a>  iota","source":"<a name=\"iota\"></a>  iota"},{"pos":[15191,15374],"content":"Stores a starting value, beginning with the first element and filling with successive increments of that value ( <ph id=\"ph1\">` value++`</ph>) in each of the elements in the interval <ph id=\"ph2\">`[ first,  last)`</ph>.","source":"Stores a starting value, beginning with the first element and filling with successive increments of that value ( ` value++`) in each of the elements in the interval `[ first,  last)`."},{"pos":[15514,15524],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator that addresses the first element in the range to be filled.","pos":[15540,15617]},{"content":"An input iterator that addresses the last element in the range to be filled.","pos":[15635,15711]},{"content":"The starting value to store in the first element and to successively increment for subsequent elements.","pos":[15730,15833]},{"pos":[15843,15850],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[15860,15867],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15872,16186],"content":"The following example demonstrates some uses for the <ph id=\"ph1\">`iota`</ph> function by filling a <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list.md)</ept> of integers and then filling a <bpt id=\"p2\">[</bpt>vector<ept id=\"p2\">](../standard-library/vector.md)</ept> with the <ph id=\"ph2\">`list`</ph> so that the <bpt id=\"p3\">[</bpt>random_shuffle<ept id=\"p3\">](../standard-library/algorithm-functions.md#random_shuffle)</ept> function can be used.","source":"The following example demonstrates some uses for the `iota` function by filling a [list](../standard-library/list.md) of integers and then filling a [vector](../standard-library/vector.md) with the `list` so that the [random_shuffle](../standard-library/algorithm-functions.md#random_shuffle) function can be used."},{"pos":[17110,17149],"content":"<bpt id=\"p1\">&lt;a name=\"partial_sum\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  partial_sum","linkify":"<a name=\"partial_sum\"></a>  partial_sum","source":"<a name=\"partial_sum\"></a>  partial_sum"},{"pos":[17153,17453],"content":"Computes a series of sums in an input range from the first element through the <bpt id=\"p1\">*</bpt>i<ept id=\"p1\">*</ept>th element and stores the result of each such sum in the <bpt id=\"p2\">*</bpt>i<ept id=\"p2\">*</ept>th element of a destination range or computes the result of a generalized procedure where the sum operation is replaced by another specified binary operation.","source":"Computes a series of sums in an input range from the first element through the *i*th element and stores the result of each such sum in the *i*th element of a destination range or computes the result of a generalized procedure where the sum operation is replaced by another specified binary operation."},{"pos":[17828,17838],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator addressing the first element in the range to be partially summed or combined according to a specified binary operation.","pos":[17854,17991]},{"content":"An input iterator addressing the last element in the range to be partially summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.","pos":[18009,18238]},{"content":"An output iterator addressing the first element a destination range where the series of partial sums or the results of the specified operation is to be stored.","pos":[18257,18416]},{"content":"The binary operation that is to be applied in the generalized operation replacing the operation of sum in the partial sum procedure.","pos":[18438,18570]},{"pos":[18582,18594],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[18598,18695],"content":"An output iterator addressing the end of the destination range: <ph id=\"ph1\">`result`</ph> + ( <ph id=\"ph2\">` last`</ph><ph id=\"ph3\"> - </ph><ph id=\"ph4\">` first`</ph>),","source":"An output iterator addressing the end of the destination range: `result` + ( ` last` - ` first`),"},{"pos":[18705,18712],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18716,18858],"content":"The output iterator <ph id=\"ph1\">`result`</ph> is allowed to be the same iterator as the input iterator <ph id=\"ph2\">` first`</ph>, so that partial sums may be computed in place.","source":"The output iterator `result` is allowed to be the same iterator as the input iterator ` first`, so that partial sums may be computed in place."},{"pos":[18865,19083],"content":"For a sequence of values <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>1, <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>2, <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>3,  in an input range, the first template function stores successive partial sums in the destination range, where the <bpt id=\"p4\">*</bpt>i<ept id=\"p4\">*</ept>th element is given by (  ( ( <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>1 + <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>2) + <bpt id=\"p7\">*</bpt>a<ept id=\"p7\">*</ept>3) <bpt id=\"p8\">*</bpt>a<ept id=\"p8\">*</ept>i).","source":"For a sequence of values *a*1, *a*2, *a*3,  in an input range, the first template function stores successive partial sums in the destination range, where the *i*th element is given by (  ( ( *a*1 + *a*2) + *a*3) *a*i)."},{"pos":[19090,19328],"content":"For a sequence of values <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>1, <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept>2, <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>3,  in an input range, the second template function stores successive partial sums in the destination range, where the ith element is given by (  ( ( <bpt id=\"p4\">*</bpt>a<ept id=\"p4\">*</ept>1<ph id=\"ph1\">`binary_op`</ph> <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>2 ) <ph id=\"ph2\">`binary_op`</ph> <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>3 ) <bpt id=\"p7\">*</bpt>a<ept id=\"p7\">*</ept>i).","source":"For a sequence of values *a*1, *a*2, *a*3,  in an input range, the second template function stores successive partial sums in the destination range, where the ith element is given by (  ( ( *a*1`binary_op` *a*2 ) `binary_op` *a*3 ) *a*i)."},{"pos":[19335,19489],"content":"The binary operation <ph id=\"ph1\">`binary_op`</ph> is not required to be either associative or commutative, because the order of operations applies is completely specified.","source":"The binary operation `binary_op` is not required to be either associative or commutative, because the order of operations applies is completely specified."},{"pos":[19499,19506],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[21294,21302],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[21306,21350],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>numeric&gt;<ept id=\"p1\">](../standard-library/numeric.md)</ept>","source":"[\\<numeric>](../standard-library/numeric.md)"}],"content":"---\ntitle: \"&lt;numeric&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: a4b0449a-c80c-4a1d-8d9f-d7fcd0058f8b\ncaps.latest.revision: 13\nmanager: \"ghogen\"\n---\n# &lt;numeric&gt; functions\n||||  \n|-|-|-|  \n|[accumulate](#accumulate)|[adjacent_difference](#adjacent_difference)|[inner_product](#inner_product)|  \n|[iota](#iota)|[partial_sum](#partial_sum)|  \n  \n##  <a name=\"accumulate\"></a>  accumulate  \n Computes the sum of all the elements in a specified range including some initial value by computing successive partial sums or computes the result of successive partial results similarly obtained from using a specified binary operation other than the sum.  \n  \n```  \ntemplate <class InputIterator, class Type>  \nType accumulate(InputIterator first, InputIterator last, Type val);\n\ntemplate <class InputIterator, class Type, class BinaryOperation>  \nType accumulate(\n    InputIterator first, \n    InputIterator last, \n    Type val, \n    BinaryOperation binary_op);\n```  \n  \n### Parameters   \n ` first`  \n An input iterator addressing the first element in the range to be summed or combined according to a specified binary operation.  \n  \n ` last`  \n An input iterator addressing the last element in the range to be summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.  \n  \n ` val`  \n An initial value to which each element is in turn added or combined with according to a specified binary operation.  \n  \n `binary_op`  \n The binary operation that is to be applied to the each element in the specified range and the result of its previous applications.  \n  \n### Return Value  \n The sum of ` val` and all the elements in the specified range for the first template function, or, for the second template function, the result of applying the binary operation specified, instead of the sum operation, to ( *PartialResult, \\*Iter*), where *PartialResult* is the result of previous applications of the operation and `Iter` is an iterator pointing to an element in the range.  \n  \n### Remarks  \n The initial value insures that there will be a well-defined result when the range is empty, in which case ` val` is returned. The binary operation does not need to be associative or commutative. The result is initialized to the initial value ` val` and then *result* = `binary_op` ( *result*, **\\***`Iter`) is calculated iteratively through the range, where `Iter` is an iterator pointing to successive element in the range. The range must be valid and the complexity is linear with the size of the range. The return type of the binary operator must be convertible to **Type** to ensure closure during the iteration.  \n  \n### Example  \n  \n```cpp  \n// numeric_accum.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <numeric>  \n#include <functional>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   vector <int> v1, v2(20);  \n   vector <int>::iterator iter1, iter2;  \n  \n   int i;  \n   for (i = 1; i < 21; i++)  \n   {  \n      v1.push_back(i);  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)  \n      cout << *iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The first member function for the accumulated sum  \n   int total;  \n   total = accumulate(v1.begin(), v1.end(), 0);  \n  \n   cout << \"The sum of the integers from 1 to 20 is: \"  \n        << total << \".\" << endl;  \n  \n   // Constructing a vector of partial sums  \n   int j = 0, partotal;  \n   for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)  \n   {  \n      partotal = accumulate(v1.begin(), iter1 + 1, 0);  \n      v2[j] = partotal;  \n      j++;  \n   }  \n  \n   cout << \"The vector of partial sums is:\\n ( \" ;  \n   for (iter2 = v2.begin(); iter2 != v2.end(); iter2++)  \n      cout << *iter2 << \" \";  \n   cout << \").\" << endl << endl;  \n  \n   // The second member function for the accumulated product  \n   vector <int> v3, v4(10);  \n   vector <int>::iterator iter3, iter4;  \n  \n   int s;  \n   for (s = 1; s < 11; s++)  \n   {  \n      v3.push_back(s);  \n   }  \n  \n   cout << \"The original vector v3 is:\\n ( \" ;  \n   for (iter3 = v3.begin(); iter3 != v3.end(); iter3++)  \n      cout << *iter3 << \" \";  \n   cout << \").\" << endl;  \n  \n   int ptotal;  \n   ptotal = accumulate(v3.begin(), v3.end(), 1, multiplies<int>());  \n  \n   cout << \"The product of the integers from 1 to 10 is: \"  \n        << ptotal << \".\" << endl;  \n  \n   // Constructing a vector of partial products  \n   int k = 0, ppartotal;  \n   for (iter3 = v3.begin(); iter3 != v3.end(); iter3++) {  \n      ppartotal = accumulate(v3.begin(), iter3 + 1, 1, multiplies<int>());  \n      v4[k] = ppartotal;  \n      k++;  \n   }  \n  \n   cout << \"The vector of partial products is:\\n ( \" ;  \n   for (iter4 = v4.begin(); iter4 != v4.end(); iter4++)  \n      cout << *iter4 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ).  \nThe sum of the integers from 1 to 20 is: 210.  \nThe vector of partial sums is:  \n ( 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 ).  \n  \nThe original vector v3 is:  \n ( 1 2 3 4 5 6 7 8 9 10 ).  \nThe product of the integers from 1 to 10 is: 3628800.  \nThe vector of partial products is:  \n ( 1 2 6 24 120 720 5040 40320 362880 3628800 ).  \n```  \n  \n##  <a name=\"adjacent_difference\"></a>  adjacent_difference  \n Computes the successive differences between each element and its predecessor in an input range and outputs the results to a destination range or computes the result of a generalized procedure where the difference operation is replaced by another, specified binary operation.  \n  \n```  \ntemplate <class InputIterator, class OutIterator>  \nOutputIterator adjacent_difference(\n    InputIterator first, \n    InputIterator last, \n    OutputIterator result);\n\ntemplate <class InputIterator, class OutIterator, class BinaryOperation>  \nOutputIterator adjacent_difference(\n    InputIterator first, \n    InputIterator last, \n    OutputIterator result, \n    BinaryOperation binary_op);\n```  \n  \n### Parameters  \n ` first`  \n An input iterator addressing the first element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.  \n  \n ` last`  \n An input iterator addressing the last element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.  \n  \n `result`  \n An output iterator addressing the first element a destination range where the series of differences or the results of the specified operation is to be stored.  \n  \n `binary_op`  \n The binary operation that is to be applied in the generalized operation replacing the operation of subtraction in the differencing procedure.  \n  \n### Return Value  \n An output iterator addressing the end of the destination range: `result` + ( ` last` - ` first`).  \n  \n### Remarks  \n The output iterator _ *result* is allowed to be the same iterator as the input iterator * first,* so that `adjacent_difference`s may be computed in place.  \n  \n For a sequence of values *a*1, *a*2, *a*3, in an input range, the first template function stores successive **partial_difference**s *a*1, *a*2 - *a*1, a3 – *a*2, in the destination range.  \n  \n For a sequence of values *a*1, *a*2, *a*3, in an input range, the second template function stores successive **partial_difference**s *a*1, *a*2 `binary_op` *a*1, *a*3 `binary_op` *a*2, in the destination range.  \n  \n The binary operation `binary_op` is not required to be either associative or commutative, because the order of operations applies is completely specified.  \n  \n### Example  \n  \n```cpp  \n// numeric_adj_diff.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <numeric>  \n#include <functional>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   vector<int> V1( 10 ), V2( 10 );  \n   vector<int>::iterator VIter1, VIter2, VIterend, VIterend2;  \n  \n   list <int> L1;  \n   list <int>::iterator LIter1, LIterend, LIterend2;  \n  \n   int t;  \n   for ( t = 1 ; t <= 10 ; t++ )  \n   {  \n      L1.push_back( t * t );  \n   }  \n  \n   cout << \"The input list L1 is:\\n ( \" ;  \n   for ( LIter1 = L1.begin( ) ; LIter1 != L1.end( ) ; LIter1++ )  \n      cout << *LIter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The first member function for the adjacent_differences of  \n   // elements in a list output to a vector  \n   VIterend = adjacent_difference ( L1.begin ( ) , L1.end ( ) ,   \n      V1.begin ( ) );  \n  \n   cout << \"Output vector containing adjacent_differences is:\\n ( \" ;  \n   for ( VIter1 = V1.begin( ) ; VIter1 != VIterend ; VIter1++ )  \n      cout << *VIter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The second member function used to compute  \n   // the adjacent products of the elements in a list  \n   VIterend2 = adjacent_difference ( L1.begin ( ) , L1.end ( ) , V2.begin ( ) ,   \n      multiplies<int>( ) );  \n  \n   cout << \"The output vector with the adjacent products is:\\n ( \" ;  \n   for ( VIter2 = V2.begin( ) ; VIter2 != VIterend2 ; VIter2++ )  \n      cout << *VIter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Computation of adjacent_differences in place  \n   LIterend2 = adjacent_difference ( L1.begin ( ) , L1.end ( ) , L1.begin ( ) );  \n   cout << \"In place output adjacent_differences in list L1 is:\\n ( \" ;  \n   for ( LIter1 = L1.begin( ) ; LIter1 != LIterend2 ; LIter1++ )  \n      cout << *LIter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"inner_product\"></a>  inner_product  \n Computes the sum of the element-wise product of two ranges and adds it to a specified initial value or computes the result of a generalized procedure where the sum and product binary operations are replaced by other specified binary operations.  \n  \n```  \ntemplate <class InputIterator1, class InputIterator2, class Type>  \nType inner_product(\n    InputIterator1   first1, \n    InputIterator1   last1, \n    InputIterator2   first2, \n    Type             val);\n\ntemplate <class InputIterator1, class InputIterator2, class Type, class BinaryOperation1, class BinaryOperation2>  \nType inner_product(\n    InputIterator1   first1, \n    InputIterator1   last1, \n    InputIterator2   first2, \n    Type             val, \n    BinaryOperation1  binary_op1, \n    BinaryOperation2  binary_op2);\n```  \n  \n### Parameters  \n ` first1`  \n An input iterator addressing the first element in the first range whose inner product or generalized inner product with the second range is to be computed.  \n  \n ` last1`  \n An input iterator addressing the last element in the first range whose inner product or generalized inner product with the second range is to be computed.  \n  \n ` first2`  \n An input iterator addressing the first element in the second range whose inner product or generalized inner product with the first range is to be computed.  \n  \n ` val`  \n An initial value to which the inner product or generalized inner product between the ranges is to be added.  \n  \n *binary_op1*  \n The binary operation that replaces the inner product operation of sum applied to the element-wise products in the generalization of the inner product.  \n  \n *binary_op2*  \n The binary operation that replaces the inner product element-wise operation of multiply in the generalization of the inner product.  \n  \n### Return Value  \n The first member function returns the sum of the element-wise products and adds to it the specified initial value. So for ranges of values *a*i and *b*i, it returns:  \n  \n ` val` + ( *a*1 \\* *b*1 ) + ( *a*2 \\* *b*2 ) +  \n  \n by iteratively replacing ` val` with ` val` + (\\* *a*i \\* \\* *b*i ).  \n  \n The second member function returns:  \n  \n ` val` _ *Binary_op1* ( *a*1 \\_ *Binary_op2* *b*1 ) \\_ *Binary_op1* ( *a*2 \\_ *Binary_op2* *b*2 ) \\_ *Binary_op1*  \n  \n by iteratively replacing ` val` with ` val` _ *Binary_op1* (\\* *a*i \\_ *Binary_op2* \\* *b*i ).  \n  \n### Remarks  \n The initial value ensures that there will be a well-defined result when the range is empty, in which case ` val` is returned. The binary operations do not need to be associative or commutative. The range must be valid and the complexity is linear with the size of the range. The return type of the binary operator must be convertible to **Type** to ensure closure during the iteration.  \n  \n### Example  \n  \n```cpp  \n// numeric_inner_prod.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <numeric>  \n#include <functional>  \n#include <iostream>  \n  \nint main()  \n{  \n   using namespace std;  \n  \n   vector <int> v1, v2(7), v3(7);  \n   vector <int>::iterator iter1, iter2, iter3;  \n  \n   int i;  \n   for (i = 1; i <= 7; i++)  \n   {  \n      v1.push_back(i);  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)  \n      cout << *iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   list <int> l1, l2(7);  \n   list <int>::iterator lIter1, lIter2;  \n  \n   int t;  \n   for (t = 1; t <= 7; t++)  \n   {  \n      l1.push_back(t);  \n   }  \n  \n   cout << \"The original list l1 is:\\n ( \" ;  \n   for (lIter1 = l1.begin(); lIter1 != l1.end(); lIter1++)  \n      cout << *lIter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The first member function for the inner product  \n   int inprod;  \n   inprod = inner_product(v1.begin(), v1.end(), l1.begin(), 0);  \n  \n   cout << \"The inner_product of the vector v1 and the list l1 is: \"  \n        << inprod << \".\" << endl;  \n  \n   // Constructing a vector of partial inner_products between v1 & l1  \n   int j = 0, parinprod;  \n   for (iter1 = v1.begin(); iter1 != v1.end(); iter1++) {  \n      parinprod = inner_product(v1.begin(), iter1 + 1, l1.begin(), 0);  \n      v2[j] = parinprod;  \n      j++;  \n   }  \n  \n   cout << \"Vector of partial inner_products between v1 & l1 is:\\n ( \" ;  \n   for (iter2 = v2.begin(); iter2 != v2.end(); iter2++)  \n      cout << *iter2 << \" \";  \n   cout << \").\" << endl << endl;  \n  \n   // The second member function used to compute  \n   // the product of the element-wise sums  \n   int inprod2;  \n   inprod2 = inner_product (v1.begin(), v1.end(),  \n      l1.begin(), 1, multiplies<int>(), plus<int>());  \n  \n   cout << \"The sum of the element-wise products of v1 and l1 is: \"  \n        << inprod2 << \".\" << endl;  \n  \n   // Constructing a vector of partial sums of element-wise products  \n   int k = 0, parinprod2;  \n   for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)  \n   {  \n      parinprod2 =  \n         inner_product(v1.begin(), iter1 + 1, l1.begin(), 1,  \n         multiplies<int>(), plus<int>());  \n      v3[k] = parinprod2;  \n      k++;  \n   }  \n  \n   cout << \"Vector of partial sums of element-wise products is:\\n ( \" ;  \n   for (iter3 = v3.begin(); iter3 != v3.end(); iter3++)  \n      cout << *iter3 << \" \";  \n   cout << \").\" << endl << endl;  \n}  \n```  \n  \n##  <a name=\"iota\"></a>  iota  \n Stores a starting value, beginning with the first element and filling with successive increments of that value ( ` value++`) in each of the elements in the interval `[ first,  last)`.  \n  \n```  \ntemplate <class ForwardIterator, class Type>  \nvoid iota(ForwardIterator first, ForwardIterator last, Type value);\n```  \n  \n### Parameters  \n ` first`  \n An input iterator that addresses the first element in the range to be filled.  \n  \n ` last`  \n An input iterator that addresses the last element in the range to be filled.  \n  \n ` value`  \n The starting value to store in the first element and to successively increment for subsequent elements.  \n  \n### Remarks  \n  \n### Example  \n  The following example demonstrates some uses for the `iota` function by filling a [list](../standard-library/list.md) of integers and then filling a [vector](../standard-library/vector.md) with the `list` so that the [random_shuffle](../standard-library/algorithm-functions.md#random_shuffle) function can be used.  \n  \n```cpp  \n// compile by using: cl /EHsc /nologo /W4 /MTd  \n#include <algorithm>  \n#include <numeric>  \n#include <list>  \n#include <vector>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main(void)  \n{  \n    list <int> intList(10);  \n    vector <list<int>::iterator> intVec(intList.size());  \n  \n    // Fill the list  \n    iota(intList.begin(), intList.end(), 0);  \n  \n    // Fill the vector with the list so we can shuffle it  \n    iota(intVec.begin(), intVec.end(), intList.begin());  \n  \n    random_shuffle(intVec.begin(), intVec.end());  \n  \n    // Output results  \n    cout << \"Contents of the integer list: \" << endl;  \n    for (auto i: intList) {  \n        cout << i << ' ';  \n    }  \n    cout << endl << endl;  \n  \n    cout << \"Contents of the integer list, shuffled by using a vector: \" << endl;  \n    for (auto i: intVec) {  \n        cout << *i << ' ';  \n    }  \n    cout << endl;  \n}  \n```  \n  \n##  <a name=\"partial_sum\"></a>  partial_sum  \n Computes a series of sums in an input range from the first element through the *i*th element and stores the result of each such sum in the *i*th element of a destination range or computes the result of a generalized procedure where the sum operation is replaced by another specified binary operation.  \n  \n```  \ntemplate <class InputIterator, class OutIt>  \nOutputIterator partial_sum(\n    InputIterator first, \n    InputIterator last, \n    OutputIterator result);\n\ntemplate <class InputIterator, class OutIt, class Fn2>  \nOutputIterator partial_sum(\n    InputIterator first, \n    InputIterator last, \n    OutputIterator result, \n    BinaryOperation binary_op);\n```  \n  \n### Parameters  \n ` first`  \n An input iterator addressing the first element in the range to be partially summed or combined according to a specified binary operation.  \n  \n ` last`  \n An input iterator addressing the last element in the range to be partially summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.  \n  \n `result`  \n An output iterator addressing the first element a destination range where the series of partial sums or the results of the specified operation is to be stored.  \n  \n `binary_op`  \n The binary operation that is to be applied in the generalized operation replacing the operation of sum in the partial sum procedure.    \n  \n### Return Value  \n An output iterator addressing the end of the destination range: `result` + ( ` last` - ` first`),  \n  \n### Remarks  \n The output iterator `result` is allowed to be the same iterator as the input iterator ` first`, so that partial sums may be computed in place.  \n  \n For a sequence of values *a*1, *a*2, *a*3,  in an input range, the first template function stores successive partial sums in the destination range, where the *i*th element is given by (  ( ( *a*1 + *a*2) + *a*3) *a*i).  \n  \n For a sequence of values *a*1, *a*2, *a*3,  in an input range, the second template function stores successive partial sums in the destination range, where the ith element is given by (  ( ( *a*1`binary_op` *a*2 ) `binary_op` *a*3 ) *a*i).  \n  \n The binary operation `binary_op` is not required to be either associative or commutative, because the order of operations applies is completely specified.  \n  \n### Example  \n  \n```cpp  \n// numeric_partial_sum.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <numeric>  \n#include <functional>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;     \n   vector<int> V1( 10 ), V2( 10 );  \n   vector<int>::iterator VIter1, VIter2, VIterend, VIterend2;  \n  \n   list <int> L1;  \n   list <int>::iterator LIter1, LIterend;  \n  \n   int t;  \n   for ( t = 1 ; t <= 10 ; t++ )  \n   {  \n      L1.push_back( t );  \n   }  \n  \n   cout << \"The input list L1 is:\\n ( \" ;  \n   for ( LIter1 = L1.begin( ) ; LIter1 != L1.end( ) ; LIter1++ )  \n      cout << *LIter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The first member function for the partial sums of  \n   // elements in a list output to a vector  \n   VIterend = partial_sum ( L1.begin ( ) , L1.end ( ) ,   \n      V1.begin ( ) );  \n  \n   cout << \"The output vector containing the partial sums is:\\n ( \" ;  \n   for ( VIter1 = V1.begin( ) ; VIter1 != VIterend ; VIter1++ )  \n      cout << *VIter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The second member function used to compute  \n   // the partial product of the elements in a list  \n   VIterend2 = partial_sum ( L1.begin ( ) , L1.end ( ) , V2.begin ( ) ,   \n      multiplies<int>( ) );  \n  \n   cout << \"The output vector with the partial products is:\\n ( \" ;  \n   for ( VIter2 = V2.begin( ) ; VIter2 != VIterend2 ; VIter2++ )  \n      cout << *VIter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Computation of partial sums in place  \n   LIterend = partial_sum ( L1.begin ( ) , L1.end ( ) , L1.begin ( ) );  \n   cout << \"The in place output partial_sum list L1 is:\\n ( \" ;  \n   for ( LIter1 = L1.begin( ) ; LIter1 != LIterend ; LIter1++ )  \n      cout << *LIter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n## See Also  \n [\\<numeric>](../standard-library/numeric.md)\n\n"}