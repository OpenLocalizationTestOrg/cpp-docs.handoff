{"nodes":[{"pos":[12,64],"content":"Declaration of a Managed Class Type | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Declaration of a Managed Class Type | Microsoft Docs","pos":[0,52]}]},{"content":"Declaration of a Managed Class Type","pos":[797,832]},{"pos":[833,990],"content":"The way to declare a reference class type changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The way to declare a reference class type changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"In Managed Extensions, a reference class type is prefaced with the <ph id=\"ph1\">`__gc`</ph> keyword.","pos":[997,1079],"source":"In Managed Extensions, a reference class type is prefaced with the `__gc` keyword."},{"content":"In the new syntax, the <ph id=\"ph1\">`__gc`</ph> keyword is replaced by one of two spaced keywords: <ph id=\"ph2\">`ref class`</ph> or <ph id=\"ph3\">`ref struct`</ph>.","pos":[1080,1189],"source":" In the new syntax, the `__gc` keyword is replaced by one of two spaced keywords: `ref class` or `ref struct`."},{"content":"The choice of <ph id=\"ph1\">`struct`</ph> or <ph id=\"ph2\">`class`</ph> indicates the public (for <ph id=\"ph3\">`struct`</ph>) or private (for <ph id=\"ph4\">`class`</ph>) default access level of its members declared in an initial unlabeled section of the body of the type.","pos":[1190,1386],"source":" The choice of `struct` or `class` indicates the public (for `struct`) or private (for `class`) default access level of its members declared in an initial unlabeled section of the body of the type."},{"content":"Similarly, in Managed Extensions, a value class type is prefaced with the <ph id=\"ph1\">`__value`</ph> keyword.","pos":[1393,1485],"source":"Similarly, in Managed Extensions, a value class type is prefaced with the `__value` keyword."},{"content":"In the new syntax, the <ph id=\"ph1\">`__value`</ph> keyword is replaced by one of two spaced keywords: <ph id=\"ph2\">`value class`</ph> or <ph id=\"ph3\">`value struct`</ph>.","pos":[1486,1602],"source":" In the new syntax, the `__value` keyword is replaced by one of two spaced keywords: `value class` or `value struct`."},{"content":"An interface type, in Managed Extensions, was indicated with the keyword <ph id=\"ph1\">`__interface`</ph>.","pos":[1609,1696],"source":"An interface type, in Managed Extensions, was indicated with the keyword `__interface`."},{"content":"In the new syntax, this is replaced with <ph id=\"ph1\">`interface class`</ph>.","pos":[1697,1756],"source":" In the new syntax, this is replaced with `interface class`."},{"content":"For example, the following class declarations in Managed Extensions:","pos":[1763,1831]},{"content":"Under the new syntax these are equivalently declared as follows:","pos":[2008,2072]},{"content":"Specifying the Class as Abstract","pos":[2260,2292]},{"pos":[2296,2526],"content":"Under Managed Extensions, you put the keyword <ph id=\"ph1\">`__abstract`</ph> before the <ph id=\"ph2\">`class`</ph> keyword (either before or after the <ph id=\"ph3\">`__gc`</ph>) to indicate that the class is incomplete and that objects of the class cannot be created within the program:","source":"Under Managed Extensions, you put the keyword `__abstract` before the `class` keyword (either before or after the `__gc`) to indicate that the class is incomplete and that objects of the class cannot be created within the program:"},{"pos":[2646,2814],"content":"Under the new syntax, you specify the <ph id=\"ph1\">`abstract`</ph> contextual keyword following the class name and before either the class body, base class derivation list, or semicolon.","source":"Under the new syntax, you specify the `abstract` contextual keyword following the class name and before either the class body, base class derivation list, or semicolon."},{"content":"Of course, the semantic meaning is unchanged.","pos":[2928,2973]},{"content":"Specifying the Class as Sealed","pos":[2982,3012]},{"pos":[3016,3195],"content":"Under Managed Extensions, you put the keyword <ph id=\"ph1\">`__sealed`</ph> before the <ph id=\"ph2\">`class`</ph> keyword (either before or after <ph id=\"ph3\">`__gc`</ph>) to indicate that objects of the class cannot be inherited from:","source":"Under Managed Extensions, you put the keyword `__sealed` before the `class` keyword (either before or after `__gc`) to indicate that objects of the class cannot be inherited from:"},{"pos":[3257,3423],"content":"Under the new syntax, you specify the <ph id=\"ph1\">`sealed`</ph> contextual keyword following the class name and before either the class body, base class derivation list, or semicolon.","source":"Under the new syntax, you specify the `sealed` contextual keyword following the class name and before either the class body, base class derivation list, or semicolon."},{"content":"You can both derive a class and seal it.","pos":[3430,3470]},{"content":"For example, the <ph id=\"ph1\">`String`</ph> class is implicitly derived from <ph id=\"ph2\">`Object`</ph>.","pos":[3471,3539],"source":" For example, the `String` class is implicitly derived from `Object`."},{"content":"The benefit of sealing a class is that it supports the static resolution (that is, at compile-time) of all virtual function calls through the sealed reference class object.","pos":[3540,3712]},{"content":"This is because the <ph id=\"ph1\">`sealed`</ph> specifier guarantees that the <ph id=\"ph2\">`String`</ph> tracking handle cannot refer to a subsequently derived class that might provide an overriding instance of the virtual method being invoked.","pos":[3713,3920],"source":" This is because the `sealed` specifier guarantees that the `String` tracking handle cannot refer to a subsequently derived class that might provide an overriding instance of the virtual method being invoked."},{"content":"Here is an example of a sealed class in new syntax:","pos":[3921,3972]},{"content":"One can also specify a class as both abstract and sealed – this is a special condition that indicates a static class.","pos":[4031,4148]},{"content":"This is described in the CLR documentation as follows:","pos":[4149,4203]},{"pos":[4210,4340],"content":"\"A type that is both <ph id=\"ph1\">`abstract`</ph> and <ph id=\"ph2\">`sealed`</ph> should have only static members, and serves as what some languages call a namespace.\"","source":"\"A type that is both `abstract` and `sealed` should have only static members, and serves as what some languages call a namespace.\""},{"content":"For example, here is a declaration of an abstract sealed class using the Managed Extensions syntax:","pos":[4347,4446]},{"content":"and here is this declaration translated into the new syntax:","pos":[4629,4689]},{"content":"CLR Inheritance: Specifying the Base Class","pos":[4867,4909]},{"content":"Under the CLR object model, only public single inheritance is supported.","pos":[4913,4985]},{"content":"However, Managed Extensions retained the ISO-C++ default interpretation of a base class without an access keyword as specifying a private derivation.","pos":[4986,5135]},{"content":"This meant that each CLR inheritance declaration had to provide the <ph id=\"ph1\">`public`</ph> keyword to override the default interpretation.","pos":[5136,5260],"source":" This meant that each CLR inheritance declaration had to provide the `public` keyword to override the default interpretation."},{"content":"In the new syntax definition, the absence of an access keyword indicates a public derivation in a CLR inheritance definition.","pos":[5377,5502]},{"content":"Thus, the <ph id=\"ph1\">`public`</ph> access keyword is now optional.","pos":[5503,5553],"source":" Thus, the `public` access keyword is now optional."},{"content":"While this does not require any modification of Managed Extensions for C++ code, I list this change here for completeness.","pos":[5554,5676]},{"content":"See Also","pos":[5781,5789]},{"content":"Managed Types (C++/CL)","pos":[5794,5816]},{"content":"Classes and Structs","pos":[5858,5877]},{"content":"abstract","pos":[5944,5952]},{"content":"sealed","pos":[6008,6014]}],"content":"---\ntitle: \"Declaration of a Managed Class Type | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__gc types\"\n  - \"classes [C++], managed\"\n  - \"class keyword [C++], CLR\"\n  - \"__value keyword\"\n  - \"value types, declaring\"\n  - \"value keyword [C++]\"\n  - \"managed classes\"\n  - \"interface class keyword\"\n  - \"ref keyword [C++]\"\nms.assetid: 16de9c94-91d7-492f-8ac7-f0729cc627e9\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Declaration of a Managed Class Type\nThe way to declare a reference class type changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n In Managed Extensions, a reference class type is prefaced with the `__gc` keyword. In the new syntax, the `__gc` keyword is replaced by one of two spaced keywords: `ref class` or `ref struct`. The choice of `struct` or `class` indicates the public (for `struct`) or private (for `class`) default access level of its members declared in an initial unlabeled section of the body of the type.  \n  \n Similarly, in Managed Extensions, a value class type is prefaced with the `__value` keyword. In the new syntax, the `__value` keyword is replaced by one of two spaced keywords: `value class` or `value struct`.  \n  \n An interface type, in Managed Extensions, was indicated with the keyword `__interface`. In the new syntax, this is replaced with `interface class`.  \n  \n For example, the following class declarations in Managed Extensions:  \n  \n```  \npublic __gc class Block {};     // reference class  \npublic __value class Vector {}; // value class  \npublic __interface IFooBar {};  // interface class  \n```  \n  \n Under the new syntax these are equivalently declared as follows:  \n  \n```  \npublic ref class Block {};         // reference class  \npublic value class Vector {};      // value class  \npublic interface class IFooBar {}; // interface class  \n```  \n  \n## Specifying the Class as Abstract  \n Under Managed Extensions, you put the keyword `__abstract` before the `class` keyword (either before or after the `__gc`) to indicate that the class is incomplete and that objects of the class cannot be created within the program:  \n  \n```  \npublic __gc __abstract class Shape {};  \npublic __gc __abstract class Shape2D: public Shape {};  \n```  \n  \n Under the new syntax, you specify the `abstract` contextual keyword following the class name and before either the class body, base class derivation list, or semicolon.  \n  \n```  \npublic ref class Shape abstract {};  \npublic ref class Shape2D abstract : public Shape{};  \n```  \n  \n Of course, the semantic meaning is unchanged.  \n  \n## Specifying the Class as Sealed  \n Under Managed Extensions, you put the keyword `__sealed` before the `class` keyword (either before or after `__gc`) to indicate that objects of the class cannot be inherited from:  \n  \n```  \npublic __gc __sealed class String {};  \n```  \n  \n Under the new syntax, you specify the `sealed` contextual keyword following the class name and before either the class body, base class derivation list, or semicolon.  \n  \n You can both derive a class and seal it. For example, the `String` class is implicitly derived from `Object`. The benefit of sealing a class is that it supports the static resolution (that is, at compile-time) of all virtual function calls through the sealed reference class object. This is because the `sealed` specifier guarantees that the `String` tracking handle cannot refer to a subsequently derived class that might provide an overriding instance of the virtual method being invoked. Here is an example of a sealed class in new syntax:  \n  \n```  \npublic ref class String sealed {};  \n```  \n  \n One can also specify a class as both abstract and sealed – this is a special condition that indicates a static class. This is described in the CLR documentation as follows:  \n  \n \"A type that is both `abstract` and `sealed` should have only static members, and serves as what some languages call a namespace.\"  \n  \n For example, here is a declaration of an abstract sealed class using the Managed Extensions syntax:  \n  \n```  \npublic __gc __sealed __abstract class State {  \npublic:  \n   static State() {}  \n   static bool inParamList();  \n  \nprivate:  \n   static bool ms_inParam;  \n};  \n```  \n  \n and here is this declaration translated into the new syntax:  \n  \n```  \npublic ref class State abstract sealed {  \npublic:  \n   static State();  \n   static bool inParamList();  \n  \nprivate:  \n   static bool ms_inParam;  \n};  \n```  \n  \n## CLR Inheritance: Specifying the Base Class  \n Under the CLR object model, only public single inheritance is supported. However, Managed Extensions retained the ISO-C++ default interpretation of a base class without an access keyword as specifying a private derivation. This meant that each CLR inheritance declaration had to provide the `public` keyword to override the default interpretation.  \n  \n```  \n// Managed Extensions: error: defaults to private derivation  \n__gc class Derived : Base {};  \n```  \n  \n In the new syntax definition, the absence of an access keyword indicates a public derivation in a CLR inheritance definition. Thus, the `public` access keyword is now optional. While this does not require any modification of Managed Extensions for C++ code, I list this change here for completeness.  \n  \n```  \n// New syntax: ok: defaults to public derivation  \nref class Derived : Base{};  \n```  \n  \n## See Also  \n [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md)   \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)   \n [abstract](../windows/abstract-cpp-component-extensions.md)   \n [sealed](../windows/sealed-cpp-component-extensions.md)"}