{"nodes":[{"pos":[12,66],"content":"Accessing All Members of a Collection | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Accessing All Members of a Collection | Microsoft Docs","pos":[0,54]}]},{"content":"Accessing All Members of a Collection","pos":[1005,1042]},{"content":"The MFC array collection classes — both template-based and not — use indexes to access their elements.","pos":[1043,1145]},{"content":"The MFC list and map collection classes — both template-based and not — use an indicator of type <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> to describe a given position within the collection.","pos":[1146,1307],"source":" The MFC list and map collection classes — both template-based and not — use an indicator of type **POSITION** to describe a given position within the collection."},{"content":"To access one or more members of these collections, you first initialize the position indicator and then repeatedly pass that position to the collection and ask it to return the next element.","pos":[1308,1499]},{"content":"The collection is not responsible for maintaining state information about the progress of the iteration.","pos":[1500,1604]},{"content":"That information is kept in the position indicator.","pos":[1605,1656]},{"content":"But, given a particular position, the collection is responsible for returning the next element.","pos":[1657,1752]},{"content":"The following procedures show how to iterate over the three main types of collections provided with MFC:","pos":[1759,1863]},{"content":"Iterating an array","pos":[1874,1892]},{"content":"Iterating a list","pos":[1932,1948]},{"content":"Iterating a map","pos":[1986,2001]},{"pos":[2078,2097],"content":"To iterate an array"},{"pos":[2107,2169],"content":"Use sequential index numbers with the <ph id=\"ph1\">`GetAt`</ph> member function:","source":"Use sequential index numbers with the `GetAt` member function:"},{"pos":[2191,2212],"content":"NVC_MFCCollections#12"},{"content":"This example uses a typed pointer array that contains pointers to <ph id=\"ph1\">`CPerson`</ph> objects.","pos":[2293,2377],"source":"This example uses a typed pointer array that contains pointers to `CPerson` objects."},{"content":"The array is derived from class <ph id=\"ph1\">`CObArray`</ph>, one of the nontemplate predefined classes.","pos":[2378,2464],"source":" The array is derived from class `CObArray`, one of the nontemplate predefined classes."},{"content":"returns a pointer to a <ph id=\"ph1\">`CPerson`</ph> object.","pos":[2473,2513],"source":" returns a pointer to a `CPerson` object."},{"content":"For typed pointer collection classes — arrays or lists — the first parameter specifies the base class; the second parameter specifies the type to store.","pos":[2514,2666]},{"content":"The <ph id=\"ph1\">`CTypedPtrArray`</ph> class also overloads the <bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept> operator so that you can use the customary array-subscript syntax to access elements of an array.","pos":[2677,2828],"source":"The `CTypedPtrArray` class also overloads the **[ ]** operator so that you can use the customary array-subscript syntax to access elements of an array."},{"content":"An alternative to the statement in the body of the <ph id=\"ph1\">`for`</ph> loop above is","pos":[2829,2899],"source":" An alternative to the statement in the body of the `for` loop above is"},{"pos":[2921,2942],"content":"NVC_MFCCollections#13"},{"content":"This operator exists in both <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and non-<bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> versions.","pos":[3023,3089],"source":"This operator exists in both **const** and non-**const** versions."},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> version, which is invoked for <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> arrays, can appear only on the right side of an assignment statement.","pos":[3090,3213],"source":" The **const** version, which is invoked for **const** arrays, can appear only on the right side of an assignment statement."},{"pos":[3262,3279],"content":"To iterate a list"},{"pos":[3289,3380],"content":"Use the member functions <ph id=\"ph1\">`GetHeadPosition`</ph> and <ph id=\"ph2\">`GetNext`</ph> to work your way through the list:","source":"Use the member functions `GetHeadPosition` and `GetNext` to work your way through the list:"},{"pos":[3402,3423],"content":"NVC_MFCCollections#14"},{"content":"This example uses a typed pointer list to contain pointers to <ph id=\"ph1\">`CPerson`</ph> objects.","pos":[3504,3584],"source":"This example uses a typed pointer list to contain pointers to `CPerson` objects."},{"content":"The list declaration resembles the one for the array in the procedure <bpt id=\"p1\">[</bpt>To iterate an array<ept id=\"p1\">](#_core_to_iterate_an_array)</ept> but is derived from class <ph id=\"ph1\">`CObList`</ph>.","pos":[3585,3741],"source":" The list declaration resembles the one for the array in the procedure [To iterate an array](#_core_to_iterate_an_array) but is derived from class `CObList`."},{"content":"returns a pointer to a <ph id=\"ph1\">`CPerson`</ph> object.","pos":[3752,3792],"source":" returns a pointer to a `CPerson` object."},{"pos":[3840,3856],"content":"To iterate a map"},{"pos":[3866,4032],"content":"Use <ph id=\"ph1\">`GetStartPosition`</ph> to get to the beginning of the map and <ph id=\"ph2\">`GetNextAssoc`</ph> to repeatedly get the next key and value from the map, as shown by the following example:","source":"Use `GetStartPosition` to get to the beginning of the map and `GetNextAssoc` to repeatedly get the next key and value from the map, as shown by the following example:"},{"pos":[4054,4075],"content":"NVC_MFCCollections#15"},{"content":"This example uses a simple map template (rather than a typed pointer collection) that uses <ph id=\"ph1\">`CString`</ph> keys and stores pointers to <ph id=\"ph2\">`CPerson`</ph> objects.","pos":[4156,4303],"source":"This example uses a simple map template (rather than a typed pointer collection) that uses `CString` keys and stores pointers to `CPerson` objects."},{"content":"When you use access functions such as <ph id=\"ph1\">`GetNextAssoc`</ph>, the class provides pointers to <ph id=\"ph2\">`CPerson`</ph> objects.","pos":[4304,4407],"source":" When you use access functions such as `GetNextAssoc`, the class provides pointers to `CPerson` objects."},{"content":"If you use one of the nontemplate map collections instead, you must cast the returned <ph id=\"ph1\">`CObject`</ph> pointer to a pointer to a <ph id=\"ph2\">`CPerson`</ph>.","pos":[4408,4540],"source":" If you use one of the nontemplate map collections instead, you must cast the returned `CObject` pointer to a pointer to a `CPerson`."},{"pos":[4552,4768],"content":"[!NOTE]\n For nontemplate maps, the compiler requires a reference to a `CObject` pointer in the last parameter to `GetNextAssoc`. On input, you must cast your pointers to that type, as shown in the next example.","leadings":["","    > "],"nodes":[{"content":" For nontemplate maps, the compiler requires a reference to a `CObject` pointer in the last parameter to `GetNextAssoc`. On input, you must cast your pointers to that type, as shown in the next example.","pos":[8,210],"nodes":[{"content":"For nontemplate maps, the compiler requires a reference to a <ph id=\"ph1\">`CObject`</ph> pointer in the last parameter to <ph id=\"ph2\">`GetNextAssoc`</ph>.","pos":[1,120],"source":" For nontemplate maps, the compiler requires a reference to a `CObject` pointer in the last parameter to `GetNextAssoc`."},{"content":"On input, you must cast your pointers to that type, as shown in the next example.","pos":[121,202]}]}]},{"content":"The template solution is simpler and helps provide better type safety.","pos":[4779,4849]},{"content":"The nontemplate code is more complicated, as you can see here:","pos":[4850,4912]},{"pos":[4934,4955],"content":"NVC_MFCCollections#16"},{"pos":[5032,5161],"content":"For more information, see <bpt id=\"p1\">[</bpt>Deleting All Objects in a CObject Collection<ept id=\"p1\">](../mfc/deleting-all-objects-in-a-cobject-collection.md)</ept>.","source":"For more information, see [Deleting All Objects in a CObject Collection](../mfc/deleting-all-objects-in-a-cobject-collection.md)."},{"content":"See Also","pos":[5170,5178]},{"content":"Collections","pos":[5183,5194]}],"content":"---\ntitle: \"Accessing All Members of a Collection | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC, collections\"\n  - \"enumerations [MFC]\"\n  - \"enumerating collections\"\n  - \"collections, accessing\"\n  - \"collection classes, accessing members\"\n  - \"arrays [C++], iterating\"\n  - \"iteration, collections\"\n  - \"member access, collections\"\n  - \"list collection iterations\"\n  - \"MFC collection classes, accessing members\"\n  - \"collections, looping through\"\n  - \"loop structures, looping through collections\"\nms.assetid: 7bbae518-062e-4393-81f9-b22abd2e5f59\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Accessing All Members of a Collection\nThe MFC array collection classes — both template-based and not — use indexes to access their elements. The MFC list and map collection classes — both template-based and not — use an indicator of type **POSITION** to describe a given position within the collection. To access one or more members of these collections, you first initialize the position indicator and then repeatedly pass that position to the collection and ask it to return the next element. The collection is not responsible for maintaining state information about the progress of the iteration. That information is kept in the position indicator. But, given a particular position, the collection is responsible for returning the next element.  \n  \n The following procedures show how to iterate over the three main types of collections provided with MFC:  \n  \n-   [Iterating an array](#_core_to_iterate_an_array)  \n  \n-   [Iterating a list](#_core_to_iterate_a_list)  \n  \n-   [Iterating a map](#_core_to_iterate_a_map)  \n  \n### <a name=\"_core_to_iterate_an_array\"></a> To iterate an array  \n  \n1.  Use sequential index numbers with the `GetAt` member function:  \n  \n     [!code-cpp[NVC_MFCCollections#12](../mfc/codesnippet/cpp/accessing-all-members-of-a-collection_1.cpp)]  \n  \n     This example uses a typed pointer array that contains pointers to `CPerson` objects. The array is derived from class `CObArray`, one of the nontemplate predefined classes. `GetAt` returns a pointer to a `CPerson` object. For typed pointer collection classes — arrays or lists — the first parameter specifies the base class; the second parameter specifies the type to store.  \n  \n     The `CTypedPtrArray` class also overloads the **[ ]** operator so that you can use the customary array-subscript syntax to access elements of an array. An alternative to the statement in the body of the `for` loop above is  \n  \n     [!code-cpp[NVC_MFCCollections#13](../mfc/codesnippet/cpp/accessing-all-members-of-a-collection_2.cpp)]  \n  \n     This operator exists in both **const** and non-**const** versions. The **const** version, which is invoked for **const** arrays, can appear only on the right side of an assignment statement.  \n  \n### <a name=\"_core_to_iterate_a_list\"></a> To iterate a list  \n  \n1.  Use the member functions `GetHeadPosition` and `GetNext` to work your way through the list:  \n  \n     [!code-cpp[NVC_MFCCollections#14](../mfc/codesnippet/cpp/accessing-all-members-of-a-collection_3.cpp)]  \n  \n     This example uses a typed pointer list to contain pointers to `CPerson` objects. The list declaration resembles the one for the array in the procedure [To iterate an array](#_core_to_iterate_an_array) but is derived from class `CObList`. `GetNext` returns a pointer to a `CPerson` object.  \n  \n### <a name=\"_core_to_iterate_a_map\"></a> To iterate a map  \n  \n1.  Use `GetStartPosition` to get to the beginning of the map and `GetNextAssoc` to repeatedly get the next key and value from the map, as shown by the following example:  \n  \n     [!code-cpp[NVC_MFCCollections#15](../mfc/codesnippet/cpp/accessing-all-members-of-a-collection_4.cpp)]  \n  \n     This example uses a simple map template (rather than a typed pointer collection) that uses `CString` keys and stores pointers to `CPerson` objects. When you use access functions such as `GetNextAssoc`, the class provides pointers to `CPerson` objects. If you use one of the nontemplate map collections instead, you must cast the returned `CObject` pointer to a pointer to a `CPerson`.  \n  \n    > [!NOTE]\n    >  For nontemplate maps, the compiler requires a reference to a `CObject` pointer in the last parameter to `GetNextAssoc`. On input, you must cast your pointers to that type, as shown in the next example.  \n  \n     The template solution is simpler and helps provide better type safety. The nontemplate code is more complicated, as you can see here:  \n  \n     [!code-cpp[NVC_MFCCollections#16](../mfc/codesnippet/cpp/accessing-all-members-of-a-collection_5.cpp)]  \n  \n For more information, see [Deleting All Objects in a CObject Collection](../mfc/deleting-all-objects-in-a-cobject-collection.md).  \n  \n## See Also  \n [Collections](../mfc/collections.md)\n\n"}