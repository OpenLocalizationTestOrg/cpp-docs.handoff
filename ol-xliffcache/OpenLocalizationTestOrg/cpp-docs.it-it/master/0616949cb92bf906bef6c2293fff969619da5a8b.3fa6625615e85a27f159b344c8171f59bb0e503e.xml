{"nodes":[{"pos":[12,50],"content":"&lt;new&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>new<ph id=\"ph2\">&amp;gt;</ph> operators | Microsoft Docs","pos":[0,38],"source":"&lt;new&gt; operators | Microsoft Docs"}]},{"pos":[252,273],"content":"&lt;new&gt; operators","linkify":"&lt;new&gt; operators","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>new<ph id=\"ph2\">&amp;gt;</ph> operators","pos":[0,21],"source":"&lt;new&gt; operators"}]},{"pos":[292,327],"content":"<bpt id=\"p1\">[</bpt>operator delete<ept id=\"p1\">](#operator_delete)</ept>","source":"[operator delete](#operator_delete)"},{"pos":[328,369],"content":"<bpt id=\"p1\">[</bpt>operator delete[]<ept id=\"p1\">](#operator_delete_arr)</ept>","source":"[operator delete[]](#operator_delete_arr)"},{"pos":[370,399],"content":"<bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](#operator_new)</ept>","source":"[operator new](#operator_new)"},{"pos":[404,439],"content":"<bpt id=\"p1\">[</bpt>operator new[]<ept id=\"p1\">](#operator_new_arr)</ept>","source":"[operator new[]](#operator_new_arr)"},{"pos":[450,497],"content":"<bpt id=\"p1\">&lt;a name=\"operator_delete\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator delete","linkify":"<a name=\"operator_delete\"></a>  operator delete","source":"<a name=\"operator_delete\"></a>  operator delete"},{"content":"The function called by a delete expression to deallocate storage for individual of objects.","pos":[501,592]},{"pos":[775,785],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The pointer whose value is to be rendered invalid by the deletion.","pos":[798,864]},{"pos":[874,881],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function is called by a delete expression to render the value of <ph id=\"ph1\">`ptr`</ph> invalid.","pos":[885,974],"source":"The first function is called by a delete expression to render the value of `ptr` invalid."},{"content":"The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[975,1108]},{"content":"The required behavior is to accept a value of <ph id=\"ph1\">`ptr`</ph> that is null or that was returned by an earlier call to <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>).","pos":[1109,1296],"source":" The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to [operator new](../standard-library/new-operators.md#operator_new)( **size_t**)."},{"content":"The default behavior for a null value of <ph id=\"ph1\">`ptr`</ph> is to do nothing.","pos":[1303,1367],"source":"The default behavior for a null value of `ptr` is to do nothing."},{"content":"Any other value of <ph id=\"ph1\">`ptr`</ph> must be a value returned earlier by a call as previously described.","pos":[1368,1460],"source":" Any other value of `ptr` must be a value returned earlier by a call as previously described."},{"content":"The default behavior for such a nonnull value of <ph id=\"ph1\">`ptr`</ph> is to reclaim storage allocated by the earlier call.","pos":[1461,1568],"source":" The default behavior for such a nonnull value of `ptr` is to reclaim storage allocated by the earlier call."},{"content":"It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to <ph id=\"ph1\">`operator new`</ph>( <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>), or to any of <ph id=\"ph2\">`calloc`</ph>( <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>), <ph id=\"ph3\">`malloc`</ph>( <bpt id=\"p3\">**</bpt>size_t<ept id=\"p3\">**</ept>), or <ph id=\"ph4\">`realloc`</ph>( <bpt id=\"p4\">**</bpt>void<ph id=\"ph5\">\\*</ph><ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>size_t<ept id=\"p5\">**</ept>).","pos":[1569,1810],"source":" It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to `operator new`( **size_t**), or to any of `calloc`( **size_t**), `malloc`( **size_t**), or `realloc`( **void\\***, **size_t**)."},{"content":"The second function is called by a placement delete expression corresponding to a new expression of the form <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>( <bpt id=\"p2\">**</bpt>std::size_t<ept id=\"p2\">**</ept>).","pos":[1817,1952],"source":"The second function is called by a placement delete expression corresponding to a new expression of the form **new**( **std::size_t**)."},{"content":"It does nothing.","pos":[1953,1969]},{"content":"The third function is called by a placement delete expression corresponding to a new expression of the form <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>( <bpt id=\"p2\">**</bpt>std::size_t<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>conststd::nothrow_t&amp;<ept id=\"p3\">**</ept>).","pos":[1976,2136],"source":"The third function is called by a placement delete expression corresponding to a new expression of the form **new**( **std::size_t**, **conststd::nothrow_t&**)."},{"content":"The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[2137,2270]},{"content":"The required behavior is to accept a value of <ph id=\"ph1\">`ptr`</ph> that is null or that was returned by an earlier call to <ph id=\"ph2\">`operator new`</ph>( <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>).","pos":[2271,2407],"source":" The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to `operator new`( **size_t**)."},{"content":"The default behavior is to evaluate <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept>( <ph id=\"ph1\">`ptr`</ph>).","pos":[2408,2463],"source":" The default behavior is to evaluate **delete**( `ptr`)."},{"pos":[2473,2480],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2485,2597],"content":"See <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](../standard-library/new-operators.md#operator_new)</ept> for an example that use <ph id=\"ph1\">`operator delete`</ph>.","source":"See [operator new](../standard-library/new-operators.md#operator_new) for an example that use `operator delete`."},{"pos":[2607,2660],"content":"<bpt id=\"p1\">&lt;a name=\"operator_delete_arr\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator delete[]","linkify":"<a name=\"operator_delete_arr\"></a>  operator delete[]","source":"<a name=\"operator_delete_arr\"></a>  operator delete[]"},{"content":"The function called by a delete expression to deallocate storage for an array of objects.","pos":[2664,2753]},{"pos":[2942,2952],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The pointer whose value is to be rendered invalid by the deletion.","pos":[2965,3031]},{"pos":[3041,3048],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function is called by an <ph id=\"ph1\">`delete[]`</ph> expression to render the value of <ph id=\"ph2\">`ptr`</ph> invalid.","pos":[3052,3146],"source":"The first function is called by an `delete[]` expression to render the value of `ptr` invalid."},{"content":"The function is replaceable because the program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[3147,3316]},{"content":"The required behavior is to accept a value of <ph id=\"ph1\">`ptr`</ph> that is null or that was returned by an earlier call to <bpt id=\"p1\">[</bpt>operator new&amp;#91;&amp;#93;<ept id=\"p1\">](../standard-library/new-operators.md#operator_new_arr)</ept>( <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>).","pos":[3317,3518],"source":" The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to [operator new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr)( **size_t**)."},{"content":"The default behavior for a null value of <ph id=\"ph1\">`ptr`</ph> is to do nothing.","pos":[3519,3583],"source":" The default behavior for a null value of `ptr` is to do nothing."},{"content":"Any other value of <ph id=\"ph1\">`ptr`</ph> must be a value returned earlier by a call as previously described.","pos":[3584,3676],"source":" Any other value of `ptr` must be a value returned earlier by a call as previously described."},{"content":"The default behavior for such a nonnull value of <ph id=\"ph1\">`ptr`</ph> is to reclaim storage allocated by the earlier call.","pos":[3677,3784],"source":" The default behavior for such a nonnull value of `ptr` is to reclaim storage allocated by the earlier call."},{"content":"It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>), or to any of <ph id=\"ph1\">`calloc`</ph>( <bpt id=\"p3\">**</bpt>size_t<ept id=\"p3\">**</ept>), <ph id=\"ph2\">`malloc`</ph>( <bpt id=\"p4\">**</bpt>size_t<ept id=\"p4\">**</ept>), or <ph id=\"ph3\">`realloc`</ph>( <bpt id=\"p5\">**</bpt>void<ph id=\"ph4\">\\*</ph><ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>size_t<ept id=\"p6\">**</ept>).","pos":[3785,4077],"source":" It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to [operator new](../standard-library/new-operators.md#operator_new)( **size_t**), or to any of `calloc`( **size_t**), `malloc`( **size_t**), or `realloc`( **void\\***, **size_t**)."},{"content":"The second function is called by a placement <ph id=\"ph1\">`delete[]`</ph> expression corresponding to a <ph id=\"ph2\">`new[]`</ph> expression of the form <ph id=\"ph3\">`new[]`</ph>( <bpt id=\"p1\">**</bpt>std::size_t<ept id=\"p1\">**</ept>).","pos":[4084,4227],"source":"The second function is called by a placement `delete[]` expression corresponding to a `new[]` expression of the form `new[]`( **std::size_t**)."},{"content":"It does nothing.","pos":[4228,4244]},{"content":"The third function is called by a placement delete expression corresponding to a <ph id=\"ph1\">`new[]`</ph> expression of the form <ph id=\"ph2\">`new[]`</ph>( <bpt id=\"p1\">**</bpt>std::size_t<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>const std::nothrow_t&amp;<ept id=\"p2\">**</ept>).","pos":[4251,4416],"source":"The third function is called by a placement delete expression corresponding to a `new[]` expression of the form `new[]`( **std::size_t**, **const std::nothrow_t&**)."},{"content":"The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[4417,4550]},{"content":"The required behavior is to accept a value of <ph id=\"ph1\">`ptr`</ph> that is null or that was returned by an earlier call to operator <ph id=\"ph2\">`new[]`</ph>( <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>).","pos":[4551,4689],"source":" The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to operator `new[]`( **size_t**)."},{"content":"The default behavior is to evaluate <ph id=\"ph1\">`delete[]`</ph>( <ph id=\"ph2\">`ptr`</ph>).","pos":[4690,4745],"source":" The default behavior is to evaluate `delete[]`( `ptr`)."},{"pos":[4755,4762],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4767,4898],"content":"See <bpt id=\"p1\">[</bpt>operator new&amp;#91;&amp;#93;<ept id=\"p1\">](../standard-library/new-operators.md#operator_new_arr)</ept> for examples of the use of <ph id=\"ph1\">`operator delete[]`</ph>.","source":"See [operator new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr) for examples of the use of `operator delete[]`."},{"pos":[4908,4949],"content":"<bpt id=\"p1\">&lt;a name=\"operator_new\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator new","linkify":"<a name=\"operator_new\"></a>  operator new","source":"<a name=\"operator_new\"></a>  operator new"},{"content":"The function called by a new-expression to allocate storage for individual objects.","pos":[4953,5036]},{"pos":[5253,5263],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The number of bytes of storage to be allocated.","pos":[5278,5325]},{"content":"The pointer to be returned.","pos":[5341,5368]},{"pos":[5378,5390],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A pointer to the lowest byte address of the newly-allocated storage.","pos":[5394,5462]},{"content":"Or <ph id=\"ph1\">`ptr.`</ph>","pos":[5463,5472],"source":" Or `ptr.`"},{"pos":[5482,5489],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function is called by a new expression to allocate <ph id=\"ph1\">`count`</ph> bytes of storage suitably aligned to represent any object of that size.","pos":[5493,5633],"source":"The first function is called by a new expression to allocate `count` bytes of storage suitably aligned to represent any object of that size."},{"content":"The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.","pos":[5634,5800]},{"content":"The required behavior is to return a nonnull pointer only if storage can be allocated as requested.","pos":[5807,5906]},{"content":"Each such allocation yields a pointer to storage disjoint from any other allocated storage.","pos":[5907,5998]},{"content":"The order and contiguity of storage allocated by successive calls is unspecified.","pos":[5999,6080]},{"content":"The initial stored value is unspecified.","pos":[6081,6121]},{"content":"The returned pointer points to the start (lowest byte address) of the allocated storage.","pos":[6122,6210]},{"content":"If count is zero, the value returned does not compare equal to any other value returned by the function.","pos":[6211,6315]},{"content":"The default behavior is to execute a loop.","pos":[6322,6364]},{"content":"Within the loop, the function first attempts to allocate the requested storage.","pos":[6365,6444]},{"content":"Whether the attempt involves a call to <ph id=\"ph1\">`malloc`</ph>( <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>) is unspecified.","pos":[6445,6521],"source":" Whether the attempt involves a call to `malloc`( **size_t**) is unspecified."},{"content":"If the attempt is successful, the function returns a pointer to the allocated storage.","pos":[6522,6608]},{"content":"Otherwise, the function calls the designated <bpt id=\"p1\">[</bpt>new handler<ept id=\"p1\">](../standard-library/new-typedefs.md#new_handler)</ept>.","pos":[6609,6717],"source":" Otherwise, the function calls the designated [new handler](../standard-library/new-typedefs.md#new_handler)."},{"content":"If the called function returns, the loop repeats.","pos":[6718,6767]},{"content":"The loop terminates when an attempt to allocate the requested storage is successful or when a called function does not return.","pos":[6768,6894]},{"content":"The required behavior of a new handler is to perform one of the following operations:","pos":[6901,6986]},{"content":"Make more storage available for allocation and then return.","pos":[6996,7055]},{"pos":[7065,7107],"content":"Call either <bpt id=\"p1\">**</bpt>abort<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>exit<ept id=\"p2\">**</ept>( <ph id=\"ph1\">`int`</ph>).","source":"Call either **abort** or **exit**( `int`)."},{"pos":[7117,7155],"content":"Throw an object of type <bpt id=\"p1\">**</bpt>bad_alloc.<ept id=\"p1\">**</ept>","source":"Throw an object of type **bad_alloc.**"},{"content":"The default behavior of a <bpt id=\"p1\">[</bpt>new handler<ept id=\"p1\">](../standard-library/new-typedefs.md#new_handler)</ept> is to throw an object of type <ph id=\"ph1\">`bad_alloc`</ph>.","pos":[7162,7293],"source":"The default behavior of a [new handler](../standard-library/new-typedefs.md#new_handler) is to throw an object of type `bad_alloc`."},{"content":"A null pointer designates the default new handler.","pos":[7294,7344]},{"pos":[7351,7503],"content":"The order and contiguity of storage allocated by successive calls to <ph id=\"ph1\">`operator new`</ph>( <bpt id=\"p1\">**</bpt>size_t<ept id=\"p1\">**</ept>) is unspecified, as are the initial values stored there.","source":"The order and contiguity of storage allocated by successive calls to `operator new`( **size_t**) is unspecified, as are the initial values stored there."},{"content":"The second function is called by a placement new expression to allocate <ph id=\"ph1\">`count`</ph> bytes of storage suitably aligned to represent any object of that size.","pos":[7510,7661],"source":"The second function is called by a placement new expression to allocate `count` bytes of storage suitably aligned to represent any object of that size."},{"content":"The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.","pos":[7662,7828]},{"content":"The default behavior is to return <ph id=\"ph1\">`operator new`</ph>( <ph id=\"ph2\">`count`</ph>) if that function succeeds.","pos":[7835,7920],"source":"The default behavior is to return `operator new`( `count`) if that function succeeds."},{"content":"Otherwise, it returns a null pointer.","pos":[7921,7958]},{"content":"The third function is called by a placement <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> expression, of the form <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> ( <bpt id=\"p3\">*</bpt>args<ept id=\"p3\">*</ept>) T. Here, <bpt id=\"p4\">*</bpt>args<ept id=\"p4\">*</ept> consists of a single object pointer.","pos":[7965,8111],"source":"The third function is called by a placement **new** expression, of the form **new** ( *args*) T. Here, *args* consists of a single object pointer."},{"content":"This can be useful for constructing an object at a known address.","pos":[8112,8177]},{"content":"The function returns <bpt id=\"p1\">*</bpt>ptr<ept id=\"p1\">*</ept>.","pos":[8178,8205],"source":" The function returns *ptr*."},{"pos":[8212,8334],"content":"To free storage allocated by <ph id=\"ph1\">`operator new`</ph>, call <bpt id=\"p1\">[</bpt>operator delete<ept id=\"p1\">](../standard-library/new-operators.md#operator_delete)</ept>.","source":"To free storage allocated by `operator new`, call [operator delete](../standard-library/new-operators.md#operator_delete)."},{"pos":[8341,8472],"content":"For information on throwing or nonthrowing behavior of new, see <bpt id=\"p1\">[</bpt>The new and delete Operators<ept id=\"p1\">](../cpp/new-and-delete-operators.md)</ept>.","source":"For information on throwing or nonthrowing behavior of new, see [The new and delete Operators](../cpp/new-and-delete-operators.md)."},{"pos":[8482,8489],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9306,9353],"content":"<bpt id=\"p1\">&lt;a name=\"operator_new_arr\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator new[]","linkify":"<a name=\"operator_new_arr\"></a>  operator new[]","source":"<a name=\"operator_new_arr\"></a>  operator new[]"},{"content":"The allocation function called by a new expression to allocate storage for an array of objects.","pos":[9357,9452]},{"pos":[9680,9690],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The number of bytes of storage to be allocated for the array object.","pos":[9705,9773]},{"content":"The pointer to be returned.","pos":[9789,9816]},{"pos":[9826,9838],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A pointer to the lowest byte address of the newly-allocated storage.","pos":[9842,9910]},{"content":"Or <ph id=\"ph1\">`ptr.`</ph>","pos":[9911,9920],"source":" Or `ptr.`"},{"pos":[9930,9937],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function is called by a <ph id=\"ph1\">`new[]`</ph> expression to allocate <ph id=\"ph2\">`count`</ph> bytes of storage suitably aligned to represent any array object of that size or smaller.","pos":[9941,10102],"source":"The first function is called by a `new[]` expression to allocate `count` bytes of storage suitably aligned to represent any array object of that size or smaller."},{"content":"The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[10103,10236]},{"content":"The required behavior is the same as for <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept>).","pos":[10237,10357],"source":" The required behavior is the same as for [operator new](../standard-library/new-operators.md#operator_new)( **size_t**)."},{"content":"The default behavior is to return <ph id=\"ph1\">`operator new`</ph>( <ph id=\"ph2\">`count`</ph>).","pos":[10358,10417],"source":" The default behavior is to return `operator new`( `count`)."},{"content":"The second function is called by a placement <ph id=\"ph1\">`new[]`</ph> expression to allocate <ph id=\"ph2\">`count`</ph> bytes of storage suitably aligned to represent any array object of that size.","pos":[10424,10585],"source":"The second function is called by a placement `new[]` expression to allocate `count` bytes of storage suitably aligned to represent any array object of that size."},{"content":"The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.","pos":[10586,10719]},{"content":"The default behavior is to return <bpt id=\"p1\">**</bpt>operatornew<ept id=\"p1\">**</ept>( <ph id=\"ph1\">`count`</ph>) if that function succeeds.","pos":[10720,10806],"source":" The default behavior is to return **operatornew**( `count`) if that function succeeds."},{"content":"Otherwise, it returns a null pointer.","pos":[10807,10844]},{"content":"The third function is called by a placement <ph id=\"ph1\">`new[]`</ph> expression, of the form <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> ( <bpt id=\"p2\">*</bpt>args<ept id=\"p2\">*</ept>) <bpt id=\"p3\">**</bpt>T<ept id=\"p3\">**</ept>[ <bpt id=\"p4\">**</bpt>N<ept id=\"p4\">**</ept>].","pos":[10851,10959],"source":"The third function is called by a placement `new[]` expression, of the form **new** ( *args*) **T**[ **N**]."},{"content":"Here, <bpt id=\"p1\">*</bpt>args<ept id=\"p1\">*</ept> consists of a single object pointer.","pos":[10960,11009],"source":" Here, *args* consists of a single object pointer."},{"content":"The function returns <ph id=\"ph1\">`ptr`</ph>.","pos":[11010,11037],"source":" The function returns `ptr`."},{"pos":[11044,11182],"content":"To free storage allocated by <ph id=\"ph1\">`operator new[]`</ph>, call <bpt id=\"p1\">[</bpt>operator delete&amp;#91;&amp;#93;<ept id=\"p1\">](../standard-library/new-operators.md#operator_delete_arr)</ept>.","source":"To free storage allocated by `operator new[]`, call [operator delete&#91;&#93;](../standard-library/new-operators.md#operator_delete_arr)."},{"pos":[11189,11320],"content":"For information on throwing or nonthrowing behavior of new, see <bpt id=\"p1\">[</bpt>The new and delete Operators<ept id=\"p1\">](../cpp/new-and-delete-operators.md)</ept>.","source":"For information on throwing or nonthrowing behavior of new, see [The new and delete Operators](../cpp/new-and-delete-operators.md)."},{"pos":[11330,11337],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12202,12210],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[12214,12250],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>new&gt;<ept id=\"p1\">](../standard-library/new.md)</ept>","source":"[\\<new>](../standard-library/new.md)"}],"content":"---\ntitle: \"&lt;new&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: d1af4b56-9a95-4c65-ab01-bf43e982c7bd\ncaps.latest.revision: 8\nmanager: \"ghogen\"\n---\n# &lt;new&gt; operators\n||||  \n|-|-|-|  \n|[operator delete](#operator_delete)|[operator delete[]](#operator_delete_arr)|[operator new](#operator_new)|  \n|[operator new[]](#operator_new_arr)|  \n  \n##  <a name=\"operator_delete\"></a>  operator delete  \n The function called by a delete expression to deallocate storage for individual of objects.  \n  \n```\nvoid operator delete(void* ptr) throw();\n\nvoid operator delete(void *,\n    void*) throw();\n\nvoid operator delete(void* ptr,\n    const std::nothrow_t&) throw();\n```  \n  \n### Parameters  \n `ptr`  \n The pointer whose value is to be rendered invalid by the deletion.  \n  \n### Remarks  \n The first function is called by a delete expression to render the value of `ptr` invalid. The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to [operator new](../standard-library/new-operators.md#operator_new)( **size_t**).  \n  \n The default behavior for a null value of `ptr` is to do nothing. Any other value of `ptr` must be a value returned earlier by a call as previously described. The default behavior for such a nonnull value of `ptr` is to reclaim storage allocated by the earlier call. It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to `operator new`( **size_t**), or to any of `calloc`( **size_t**), `malloc`( **size_t**), or `realloc`( **void\\***, **size_t**).  \n  \n The second function is called by a placement delete expression corresponding to a new expression of the form **new**( **std::size_t**). It does nothing.  \n  \n The third function is called by a placement delete expression corresponding to a new expression of the form **new**( **std::size_t**, **conststd::nothrow_t&**). The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to `operator new`( **size_t**). The default behavior is to evaluate **delete**( `ptr`).  \n  \n### Example  \n  See [operator new](../standard-library/new-operators.md#operator_new) for an example that use `operator delete`.  \n  \n##  <a name=\"operator_delete_arr\"></a>  operator delete[]  \n The function called by a delete expression to deallocate storage for an array of objects.  \n  \n```\nvoid operator delete[](void* ptr) throw();\n\nvoid operator delete[](void *,\n    void*) throw();\n\nvoid operator delete[](void* ptr,\n    const std::nothrow_t&) throw();\n```  \n  \n### Parameters  \n `ptr`  \n The pointer whose value is to be rendered invalid by the deletion.  \n  \n### Remarks  \n The first function is called by an `delete[]` expression to render the value of `ptr` invalid. The function is replaceable because the program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to [operator new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr)( **size_t**). The default behavior for a null value of `ptr` is to do nothing. Any other value of `ptr` must be a value returned earlier by a call as previously described. The default behavior for such a nonnull value of `ptr` is to reclaim storage allocated by the earlier call. It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to [operator new](../standard-library/new-operators.md#operator_new)( **size_t**), or to any of `calloc`( **size_t**), `malloc`( **size_t**), or `realloc`( **void\\***, **size_t**).  \n  \n The second function is called by a placement `delete[]` expression corresponding to a `new[]` expression of the form `new[]`( **std::size_t**). It does nothing.  \n  \n The third function is called by a placement delete expression corresponding to a `new[]` expression of the form `new[]`( **std::size_t**, **const std::nothrow_t&**). The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The required behavior is to accept a value of `ptr` that is null or that was returned by an earlier call to operator `new[]`( **size_t**). The default behavior is to evaluate `delete[]`( `ptr`).  \n  \n### Example  \n  See [operator new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr) for examples of the use of `operator delete[]`.  \n  \n##  <a name=\"operator_new\"></a>  operator new  \n The function called by a new-expression to allocate storage for individual objects.  \n  \n```\nvoid* operator new(std::size_t count) throw(bad_alloc);\n\nvoid* operator new(std::size_t count,\n    const std::nothrow_t&) throw();\n\nvoid* operator new(std::size_t count,\n    void* ptr) throw();\n```  \n  \n### Parameters  \n `count`  \n The number of bytes of storage to be allocated.  \n  \n `ptr`  \n The pointer to be returned.  \n  \n### Return Value  \n A pointer to the lowest byte address of the newly-allocated storage. Or `ptr.`  \n  \n### Remarks  \n The first function is called by a new expression to allocate `count` bytes of storage suitably aligned to represent any object of that size. The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.  \n  \n The required behavior is to return a nonnull pointer only if storage can be allocated as requested. Each such allocation yields a pointer to storage disjoint from any other allocated storage. The order and contiguity of storage allocated by successive calls is unspecified. The initial stored value is unspecified. The returned pointer points to the start (lowest byte address) of the allocated storage. If count is zero, the value returned does not compare equal to any other value returned by the function.  \n  \n The default behavior is to execute a loop. Within the loop, the function first attempts to allocate the requested storage. Whether the attempt involves a call to `malloc`( **size_t**) is unspecified. If the attempt is successful, the function returns a pointer to the allocated storage. Otherwise, the function calls the designated [new handler](../standard-library/new-typedefs.md#new_handler). If the called function returns, the loop repeats. The loop terminates when an attempt to allocate the requested storage is successful or when a called function does not return.  \n  \n The required behavior of a new handler is to perform one of the following operations:  \n  \n-   Make more storage available for allocation and then return.  \n  \n-   Call either **abort** or **exit**( `int`).  \n  \n-   Throw an object of type **bad_alloc.**  \n  \n The default behavior of a [new handler](../standard-library/new-typedefs.md#new_handler) is to throw an object of type `bad_alloc`. A null pointer designates the default new handler.  \n  \n The order and contiguity of storage allocated by successive calls to `operator new`( **size_t**) is unspecified, as are the initial values stored there.  \n  \n The second function is called by a placement new expression to allocate `count` bytes of storage suitably aligned to represent any object of that size. The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.  \n  \n The default behavior is to return `operator new`( `count`) if that function succeeds. Otherwise, it returns a null pointer.  \n  \n The third function is called by a placement **new** expression, of the form **new** ( *args*) T. Here, *args* consists of a single object pointer. This can be useful for constructing an object at a known address. The function returns *ptr*.  \n  \n To free storage allocated by `operator new`, call [operator delete](../standard-library/new-operators.md#operator_delete).  \n  \n For information on throwing or nonthrowing behavior of new, see [The new and delete Operators](../cpp/new-and-delete-operators.md).  \n  \n### Example  \n  \n```cpp  \n// new_op_new.cpp  \n// compile with: /EHsc  \n#include<new>  \n#include<iostream>  \n  \nusing namespace std;  \n  \nclass MyClass   \n{  \npublic:   \n   MyClass( )  \n   {  \n      cout << \"Construction MyClass.\" << this << endl;  \n   };  \n  \n   ~MyClass( )  \n   {  \n      imember = 0; cout << \"Destructing MyClass.\" << this << endl;  \n   };  \n   int imember;  \n};  \n  \nint main( )   \n{  \n   // The first form of new delete  \n   MyClass* fPtr = new MyClass;  \n   delete fPtr;  \n  \n   // The second form of new delete  \n   MyClass* fPtr2 = new( nothrow ) MyClass;  \n   delete fPtr2;  \n  \n   // The third form of new delete  \n   char x[sizeof( MyClass )];  \n   MyClass* fPtr3 = new( &x[0] ) MyClass;  \n   fPtr3 -> ~MyClass();  \n   cout << \"The address of x[0] is : \" << ( void* )&x[0] << endl;  \n}  \n```  \n  \n##  <a name=\"operator_new_arr\"></a>  operator new[]  \n The allocation function called by a new expression to allocate storage for an array of objects.  \n  \n```\nvoid* operator new[](std::size_t count) throw(std::bad_alloc);\n\nvoid* operator new[](std::size_t count,\n    const std::nothrow_t&) throw();\n\nvoid* operator new[](std::size_t count,\n    void* ptr) throw();\n```  \n  \n### Parameters  \n `count`  \n The number of bytes of storage to be allocated for the array object.  \n  \n `ptr`  \n The pointer to be returned.  \n  \n### Return Value  \n A pointer to the lowest byte address of the newly-allocated storage. Or `ptr.`  \n  \n### Remarks  \n The first function is called by a `new[]` expression to allocate `count` bytes of storage suitably aligned to represent any array object of that size or smaller. The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The required behavior is the same as for [operator new](../standard-library/new-operators.md#operator_new)( **size_t**). The default behavior is to return `operator new`( `count`).  \n  \n The second function is called by a placement `new[]` expression to allocate `count` bytes of storage suitably aligned to represent any array object of that size. The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library. The default behavior is to return **operatornew**( `count`) if that function succeeds. Otherwise, it returns a null pointer.  \n  \n The third function is called by a placement `new[]` expression, of the form **new** ( *args*) **T**[ **N**]. Here, *args* consists of a single object pointer. The function returns `ptr`.  \n  \n To free storage allocated by `operator new[]`, call [operator delete&#91;&#93;](../standard-library/new-operators.md#operator_delete_arr).  \n  \n For information on throwing or nonthrowing behavior of new, see [The new and delete Operators](../cpp/new-and-delete-operators.md).  \n  \n### Example  \n  \n```cpp  \n// new_op_alloc.cpp  \n// compile with: /EHsc  \n#include <new>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nclass MyClass {  \npublic:  \n   MyClass() {  \n      cout << \"Construction MyClass.\" << this << endl;  \n   };  \n  \n   ~MyClass() {  \n      imember = 0; cout << \"Destructing MyClass.\" << this << endl;  \n      };  \n   int imember;  \n};  \n  \nint main() {  \n   // The first form of new delete  \n   MyClass* fPtr = new MyClass[2];  \n   delete[ ] fPtr;  \n  \n   // The second form of new delete  \n   char x[2 * sizeof( MyClass ) + sizeof(int)];  \n  \n   MyClass* fPtr2 = new( &x[0] ) MyClass[2];  \n   fPtr2[1].~MyClass();  \n   fPtr2[0].~MyClass();  \n   cout << \"The address of x[0] is : \" << ( void* )&x[0] << endl;  \n  \n   // The third form of new delete  \n   MyClass* fPtr3 = new( nothrow ) MyClass[2];  \n   delete[ ] fPtr3;  \n}  \n```  \n  \n## See Also  \n [\\<new>](../standard-library/new.md)\n\n\n\n"}