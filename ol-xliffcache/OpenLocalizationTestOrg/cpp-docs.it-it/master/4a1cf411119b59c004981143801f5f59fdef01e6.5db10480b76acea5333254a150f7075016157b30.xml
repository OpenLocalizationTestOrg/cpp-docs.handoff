{"nodes":[{"pos":[12,51],"content":"Summary of Scope Rules | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Summary of Scope Rules | Microsoft Docs","pos":[0,39]}]},{"content":"Summary of Scope Rules","pos":[715,737]},{"content":"The use of a name must be unambiguous within its scope (up to the point where overloading is determined).","pos":[738,843]},{"content":"If the name denotes a function, the function must be unambiguous with respect to number and type of parameters.","pos":[844,955]},{"content":"If the name remains unambiguous, <bpt id=\"p1\">[</bpt>member-access<ept id=\"p1\">](../cpp/member-access-control-cpp.md)</ept> rules are applied.","pos":[956,1060],"source":" If the name remains unambiguous, [member-access](../cpp/member-access-control-cpp.md) rules are applied."},{"content":"Constructor initializers","pos":[1069,1093]},{"content":"Constructor initializers (described in <bpt id=\"p1\">[</bpt>Initializing Bases and Members<ept id=\"p1\">](http://msdn.microsoft.com/en-us/2f71377e-2b6b-49da-9a26-18e9b40226a1)</ept>) are evaluated in the scope of the outermost block of the constructor for which they are specified.","pos":[1097,1338],"source":"Constructor initializers (described in [Initializing Bases and Members](http://msdn.microsoft.com/en-us/2f71377e-2b6b-49da-9a26-18e9b40226a1)) are evaluated in the scope of the outermost block of the constructor for which they are specified."},{"content":"Therefore, they can use the constructor's parameter names.","pos":[1339,1397]},{"content":"Global names","pos":[1406,1418]},{"pos":[1422,1654],"content":"A name of an object, function, or enumerator is global if it is introduced outside any function or class or prefixed by the global unary scope operator (<ph id=\"ph1\">`::`</ph>), and if it is not used in conjunction with any of these binary operators:","source":"A name of an object, function, or enumerator is global if it is introduced outside any function or class or prefixed by the global unary scope operator (`::`), and if it is not used in conjunction with any of these binary operators:"},{"pos":[1664,1687],"content":"Scope-resolution (<ph id=\"ph1\">`::`</ph>)","source":"Scope-resolution (`::`)"},{"pos":[1697,1748],"content":"Member-selection for objects and references (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>)","source":"Member-selection for objects and references (**.**)"},{"pos":[1758,1796],"content":"Member-selection for pointers (<bpt id=\"p1\">**</bpt>–&gt;<ept id=\"p1\">**</ept>)","source":"Member-selection for pointers (**–>**)"},{"content":"Qualified names","pos":[1805,1820]},{"content":"Names used with the binary scope-resolution operator (<ph id=\"ph1\">`::`</ph>) are called \"qualified names.\"","pos":[1824,1913],"source":"Names used with the binary scope-resolution operator (`::`) are called \"qualified names.\""},{"content":"The name specified after the binary scope-resolution operator must be a member of the class specified on the left of the operator or a member of its base class(es).","pos":[1914,2078]},{"content":"Names specified after the member-selection operator (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>","pos":[2085,2143],"source":"Names specified after the member-selection operator (**.**"},{"content":"or <bpt id=\"p1\">**</bpt>–&gt;<ept id=\"p1\">**</ept>) must be members of the class type of the object specified on the left of the operator or members of its base class(es).","pos":[2144,2274],"source":" or **–>**) must be members of the class type of the object specified on the left of the operator or members of its base class(es)."},{"content":"Names specified on the right of the member-selection operator (<bpt id=\"p1\">**</bpt>–&gt;<ept id=\"p1\">**</ept>) can also be objects of another class type, provided that the left-hand side of <bpt id=\"p2\">**</bpt>–&gt;<ept id=\"p2\">**</ept> is a class object and that the class defines an overloaded member-selection operator (<bpt id=\"p3\">**</bpt>–&gt;<ept id=\"p3\">**</ept>) that evaluates to a pointer to some other class type.","pos":[2275,2579],"source":" Names specified on the right of the member-selection operator (**–>**) can also be objects of another class type, provided that the left-hand side of **–>** is a class object and that the class defines an overloaded member-selection operator (**–>**) that evaluates to a pointer to some other class type."},{"content":"(This provision is discussed in more detail in <bpt id=\"p1\">[</bpt>Class Member Access<ept id=\"p1\">](../cpp/member-access.md)</ept>.)","pos":[2580,2675],"source":" (This provision is discussed in more detail in [Class Member Access](../cpp/member-access.md).)"},{"content":"The compiler searches for names in the following order, stopping when the name is found:","pos":[2682,2770]},{"content":"Current block scope if name is used inside a function; otherwise, global scope.","pos":[2780,2859]},{"content":"Outward through each enclosing block scope, including the outermost function scope (which includes function parameters).","pos":[2869,2989]},{"content":"If the name is used inside a member function, the class's scope is searched for the name.","pos":[2999,3088]},{"content":"The class's base classes are searched for the name.","pos":[3098,3149]},{"content":"The enclosing nested class scope (if any) and its bases are searched.","pos":[3159,3228]},{"content":"The search continues until the outermost enclosing class scope is searched.","pos":[3229,3304]},{"content":"Global scope is searched.","pos":[3314,3339]},{"content":"However, you can make modifications to this search order as follows:","pos":[3346,3414]},{"pos":[3424,3489],"content":"Names preceded by <ph id=\"ph1\">`::`</ph> force the search to begin at global scope.","source":"Names preceded by `::` force the search to begin at global scope."},{"pos":[3499,3643],"content":"Names preceded by the <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`struct`</ph>, and <bpt id=\"p2\">**</bpt>union<ept id=\"p2\">**</ept> keywords force the compiler to search only for <bpt id=\"p3\">**</bpt>class<ept id=\"p3\">**</ept>, <ph id=\"ph2\">`struct`</ph>, or <bpt id=\"p4\">**</bpt>union<ept id=\"p4\">**</ept> names.","source":"Names preceded by the **class**, `struct`, and **union** keywords force the compiler to search only for **class**, `struct`, or **union** names."},{"pos":[3653,3783],"content":"Names on the left side of the scope-resolution operator (<ph id=\"ph1\">`::`</ph>) can be only <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`struct`</ph>, <bpt id=\"p2\">**</bpt>namespace<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>union<ept id=\"p3\">**</ept> names.","source":"Names on the left side of the scope-resolution operator (`::`) can be only **class**, `struct`, **namespace**, or **union** names."},{"content":"If the name refers to a nonstatic member but is used in a static member function, an error message is generated.","pos":[3790,3902]},{"content":"Similarly, if the name refers to any nonstatic member in an enclosing class, an error message is generated because enclosed classes do not have enclosing-class <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> pointers.","pos":[3903,4081],"source":" Similarly, if the name refers to any nonstatic member in an enclosing class, an error message is generated because enclosed classes do not have enclosing-class **this** pointers."},{"content":"Function parameter names","pos":[4090,4114]},{"content":"Function parameter names in function definitions are considered to be in the scope of the outermost block of the function.","pos":[4118,4240]},{"content":"Therefore, they are local names and go out of scope when the function is exited.","pos":[4241,4321]},{"content":"Function parameter names in function declarations (prototypes) are in local scope of the declaration and go out of scope at the end of the declaration.","pos":[4328,4479]},{"content":"Default parameters are in the scope of the parameter for which they are the default, as described in the preceding two paragraphs.","pos":[4486,4616]},{"content":"However, they cannot access local variables or nonstatic class members.","pos":[4617,4688]},{"content":"Default parameters are evaluated at the point of the function call, but they are evaluated in the function declaration's original scope.","pos":[4689,4825]},{"content":"Therefore, the default parameters for member functions are always evaluated in class scope.","pos":[4826,4917]},{"content":"See Also","pos":[4926,4934]},{"content":"Inheritance","pos":[4939,4950]}],"content":"---\ntitle: \"Summary of Scope Rules | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"class scope [C++], rules\"\n  - \"classes [C++], scope\"\n  - \"class names [C++], scope rules\"\n  - \"names [C++], class\"\n  - \"scope [C++], class names\"\nms.assetid: 47e26482-0111-466f-b857-598c15d05105\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Summary of Scope Rules\nThe use of a name must be unambiguous within its scope (up to the point where overloading is determined). If the name denotes a function, the function must be unambiguous with respect to number and type of parameters. If the name remains unambiguous, [member-access](../cpp/member-access-control-cpp.md) rules are applied.  \n  \n## Constructor initializers  \n Constructor initializers (described in [Initializing Bases and Members](http://msdn.microsoft.com/en-us/2f71377e-2b6b-49da-9a26-18e9b40226a1)) are evaluated in the scope of the outermost block of the constructor for which they are specified. Therefore, they can use the constructor's parameter names.  \n  \n## Global names  \n A name of an object, function, or enumerator is global if it is introduced outside any function or class or prefixed by the global unary scope operator (`::`), and if it is not used in conjunction with any of these binary operators:  \n  \n-   Scope-resolution (`::`)  \n  \n-   Member-selection for objects and references (**.**)  \n  \n-   Member-selection for pointers (**–>**)  \n  \n## Qualified names  \n Names used with the binary scope-resolution operator (`::`) are called \"qualified names.\" The name specified after the binary scope-resolution operator must be a member of the class specified on the left of the operator or a member of its base class(es).  \n  \n Names specified after the member-selection operator (**.** or **–>**) must be members of the class type of the object specified on the left of the operator or members of its base class(es). Names specified on the right of the member-selection operator (**–>**) can also be objects of another class type, provided that the left-hand side of **–>** is a class object and that the class defines an overloaded member-selection operator (**–>**) that evaluates to a pointer to some other class type. (This provision is discussed in more detail in [Class Member Access](../cpp/member-access.md).)  \n  \n The compiler searches for names in the following order, stopping when the name is found:  \n  \n1.  Current block scope if name is used inside a function; otherwise, global scope.  \n  \n2.  Outward through each enclosing block scope, including the outermost function scope (which includes function parameters).  \n  \n3.  If the name is used inside a member function, the class's scope is searched for the name.  \n  \n4.  The class's base classes are searched for the name.  \n  \n5.  The enclosing nested class scope (if any) and its bases are searched. The search continues until the outermost enclosing class scope is searched.  \n  \n6.  Global scope is searched.  \n  \n However, you can make modifications to this search order as follows:  \n  \n1.  Names preceded by `::` force the search to begin at global scope.  \n  \n2.  Names preceded by the **class**, `struct`, and **union** keywords force the compiler to search only for **class**, `struct`, or **union** names.  \n  \n3.  Names on the left side of the scope-resolution operator (`::`) can be only **class**, `struct`, **namespace**, or **union** names.  \n  \n If the name refers to a nonstatic member but is used in a static member function, an error message is generated. Similarly, if the name refers to any nonstatic member in an enclosing class, an error message is generated because enclosed classes do not have enclosing-class **this** pointers.  \n  \n## Function parameter names  \n Function parameter names in function definitions are considered to be in the scope of the outermost block of the function. Therefore, they are local names and go out of scope when the function is exited.  \n  \n Function parameter names in function declarations (prototypes) are in local scope of the declaration and go out of scope at the end of the declaration.  \n  \n Default parameters are in the scope of the parameter for which they are the default, as described in the preceding two paragraphs. However, they cannot access local variables or nonstatic class members. Default parameters are evaluated at the point of the function call, but they are evaluated in the function declaration's original scope. Therefore, the default parameters for member functions are always evaluated in class scope.  \n  \n## See Also  \n [Inheritance](../cpp/inheritance-cpp.md)"}