{"nodes":[{"pos":[12,66],"content":"Writing a Multithreaded Win32 Program | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Writing a Multithreaded Win32 Program | Microsoft Docs","pos":[0,54]}]},{"content":"Writing a Multithreaded Win32 Program","pos":[951,988]},{"content":"When you write a program with multiple threads, you must coordinate their behavior and <bpt id=\"p1\">[</bpt>use of the program's resources<ept id=\"p1\">](#_core_sharing_common_resources_between_threads)</ept>.","pos":[989,1158],"source":"When you write a program with multiple threads, you must coordinate their behavior and [use of the program's resources](#_core_sharing_common_resources_between_threads)."},{"content":"You must also make sure that each thread receives <bpt id=\"p1\">[</bpt>its own stack<ept id=\"p1\">](#_core_thread_stacks)</ept>.","pos":[1159,1247],"source":" You must also make sure that each thread receives [its own stack](#_core_thread_stacks)."},{"pos":[1319,1359],"content":"Sharing Common Resources Between Threads"},{"pos":[1367,1651],"content":"[!NOTE]\n For a similar discussion from the MFC point of view, see [Multithreading: Programming Tips](../parallel/multithreading-programming-tips.md) and [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md).","leadings":["","> "],"nodes":[{"content":"For a similar discussion from the MFC point of view, see <bpt id=\"p1\">[</bpt>Multithreading: Programming Tips<ept id=\"p1\">](../parallel/multithreading-programming-tips.md)</ept> and <bpt id=\"p2\">[</bpt>Multithreading: When to Use the Synchronization Classes<ept id=\"p2\">](../parallel/multithreading-when-to-use-the-synchronization-classes.md)</ept>.","pos":[9,282],"source":" For a similar discussion from the MFC point of view, see [Multithreading: Programming Tips](../parallel/multithreading-programming-tips.md) and [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md)."}]},{"content":"Each thread has its own stack and its own copy of the CPU registers.","pos":[1658,1726]},{"content":"Other resources, such as files, static data, and heap memory, are shared by all threads in the process.","pos":[1727,1830]},{"content":"Threads using these common resources must be synchronized.","pos":[1831,1889]},{"content":"Win32 provides several ways to synchronize resources, including semaphores, critical sections, events, and mutexes.","pos":[1890,2005]},{"content":"When multiple threads are accessing static data, your program must provide for possible resource conflicts.","pos":[2012,2119]},{"content":"Consider a program where one thread updates a static data structure containing <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>,<bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> coordinates for items to be displayed by another thread.","pos":[2120,2263],"source":" Consider a program where one thread updates a static data structure containing *x*,*y* coordinates for items to be displayed by another thread."},{"content":"If the update thread alters the <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> coordinate and is preempted before it can change the <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> coordinate, the display thread might be scheduled before the <bpt id=\"p3\">*</bpt>y<ept id=\"p3\">*</ept> coordinate is updated.","pos":[2264,2444],"source":" If the update thread alters the *x* coordinate and is preempted before it can change the *y* coordinate, the display thread might be scheduled before the *y* coordinate is updated."},{"content":"The item would be displayed at the wrong location.","pos":[2445,2495]},{"content":"You can avoid this problem by using semaphores to control access to the structure.","pos":[2496,2578]},{"content":"A mutex (short for <bpt id=\"p1\">*</bpt>mut<ept id=\"p1\">*</ept>ual <bpt id=\"p2\">*</bpt>ex<ept id=\"p2\">*</ept>clusion) is a way of communicating among threads or processes that are executing asynchronously of one another.","pos":[2585,2728],"source":"A mutex (short for *mut*ual *ex*clusion) is a way of communicating among threads or processes that are executing asynchronously of one another."},{"content":"This communication is usually used to coordinate the activities of multiple threads or processes, typically by controlling access to a shared resource by locking and unlocking the resource.","pos":[2729,2918]},{"content":"To solve this <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>,<bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> coordinate update problem, the update thread sets a mutex indicating that the data structure is in use before performing the update.","pos":[2919,3073],"source":" To solve this *x*,*y* coordinate update problem, the update thread sets a mutex indicating that the data structure is in use before performing the update."},{"content":"It would clear the mutex after both coordinates had been processed.","pos":[3074,3141]},{"content":"The display thread must wait for the mutex to be clear before updating the display.","pos":[3142,3225]},{"content":"This process of waiting for a mutex is often called blocking on a mutex because the process is blocked and cannot continue until the mutex clears.","pos":[3226,3372]},{"content":"The Bounce.c program shown in <bpt id=\"p1\">[</bpt>Sample Multithread C Program<ept id=\"p1\">](../parallel/sample-multithread-c-program.md)</ept> uses a mutex named <ph id=\"ph1\">`ScreenMutex`</ph> to coordinate screen updates.","pos":[3379,3547],"source":"The Bounce.c program shown in [Sample Multithread C Program](../parallel/sample-multithread-c-program.md) uses a mutex named `ScreenMutex` to coordinate screen updates."},{"content":"Each time one of the display threads is ready to write to the screen, it calls <bpt id=\"p1\">**</bpt>WaitForSingleObject<ept id=\"p1\">**</ept> with the handle to <ph id=\"ph1\">`ScreenMutex`</ph> and constant <bpt id=\"p2\">**</bpt>INFINITE<ept id=\"p2\">**</ept> to indicate that the <bpt id=\"p3\">**</bpt>WaitForSingleObject<ept id=\"p3\">**</ept> call should block on the mutex and not time out.","pos":[3548,3803],"source":" Each time one of the display threads is ready to write to the screen, it calls **WaitForSingleObject** with the handle to `ScreenMutex` and constant **INFINITE** to indicate that the **WaitForSingleObject** call should block on the mutex and not time out."},{"content":"If <ph id=\"ph1\">`ScreenMutex`</ph> is clear, the wait function sets the mutex so other threads cannot interfere with the display and continues executing the thread.","pos":[3804,3950],"source":" If `ScreenMutex` is clear, the wait function sets the mutex so other threads cannot interfere with the display and continues executing the thread."},{"content":"Otherwise, the thread blocks until the mutex clears.","pos":[3951,4003]},{"content":"When the thread completes the display update, it releases the mutex by calling <bpt id=\"p1\">**</bpt>ReleaseMutex<ept id=\"p1\">**</ept>.","pos":[4004,4100],"source":" When the thread completes the display update, it releases the mutex by calling **ReleaseMutex**."},{"content":"Screen displays and static data are only two of the resources requiring careful management.","pos":[4107,4198]},{"content":"For example, your program might have multiple threads accessing the same file.","pos":[4199,4277]},{"content":"Because another thread might have moved the file pointer, each thread must reset the file pointer before reading or writing.","pos":[4278,4402]},{"content":"In addition, each thread must make sure that it is not preempted between the time it positions the pointer and the time it accesses the file.","pos":[4403,4544]},{"content":"These threads should use a semaphore to coordinate access to the file by bracketing each file access with <bpt id=\"p1\">**</bpt>WaitForSingleObject<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ReleaseMutex<ept id=\"p2\">**</ept> calls.","pos":[4545,4702],"source":" These threads should use a semaphore to coordinate access to the file by bracketing each file access with **WaitForSingleObject** and **ReleaseMutex** calls."},{"content":"The following code example illustrates this technique:","pos":[4703,4757]},{"pos":[5025,5038],"content":"Thread Stacks"},{"content":"All of an application's default stack space is allocated to the first thread of execution, which is known as thread 1.","pos":[5042,5160]},{"content":"As a result, you must specify how much memory to allocate for a separate stack for each additional thread your program needs.","pos":[5161,5286]},{"content":"The operating system allocates additional stack space for the thread, if necessary, but you must specify a default value.","pos":[5287,5408]},{"content":"The first argument in the <ph id=\"ph1\">`_beginthread`</ph> call is a pointer to the <bpt id=\"p1\">**</bpt>BounceProc<ept id=\"p1\">**</ept> function, which executes the threads.","pos":[5415,5533],"source":"The first argument in the `_beginthread` call is a pointer to the **BounceProc** function, which executes the threads."},{"content":"The second argument specifies the default stack size for the thread.","pos":[5534,5602]},{"content":"The last argument is an ID number that is passed to <bpt id=\"p1\">**</bpt>BounceProc<ept id=\"p1\">**</ept>.","pos":[5603,5670],"source":" The last argument is an ID number that is passed to **BounceProc**."},{"content":"<bpt id=\"p1\">**</bpt>BounceProc<ept id=\"p1\">**</ept> uses the ID number to seed the random number generator and to select the thread's color attribute and display character.","pos":[5671,5806],"source":"**BounceProc** uses the ID number to seed the random number generator and to select the thread's color attribute and display character."},{"content":"Threads that make calls to the C run-time library or to the Win32 API must allow sufficient stack space for the library and API functions they call.","pos":[5813,5961]},{"content":"The C <ph id=\"ph1\">`printf`</ph> function requires more than 500 bytes of stack space, and you should have 2K of stack space available when calling Win32 API routines.","pos":[5962,6111],"source":" The C `printf` function requires more than 500 bytes of stack space, and you should have 2K of stack space available when calling Win32 API routines."},{"content":"Because each thread has its own stack, you can avoid potential collisions over data items by using as little static data as possible.","pos":[6118,6251]},{"content":"Design your program to use automatic stack variables for all data that can be private to a thread.","pos":[6252,6350]},{"content":"The only global variables in the Bounce.c program are either mutexes or variables that never change after they are initialized.","pos":[6351,6478]},{"content":"Win32 also provides Thread-Local Storage (TLS) to store per-thread data.","pos":[6485,6557]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Thread Local Storage (TLS)<ept id=\"p1\">](../parallel/thread-local-storage-tls.md)</ept>.","pos":[6558,6654],"source":" For more information, see [Thread Local Storage (TLS)](../parallel/thread-local-storage-tls.md)."},{"content":"See Also","pos":[6663,6671]},{"content":"Multithreading with C and Win32","pos":[6676,6707]}],"content":"---\ntitle: \"Writing a Multithreaded Win32 Program | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"thread stacks [C++]\"\n  - \"resources [C++], multithreading\"\n  - \"stacks [C++]\"\n  - \"shared resources [C++]\"\n  - \"threading [C++], sharing common resources\"\n  - \"multithreading [C++], thread stacks\"\n  - \"multithreading [C++], sharing common resources\"\n  - \"mutual exclusion [C++]\"\n  - \"communications [C++], between threads\"\n  - \"mutex [C++]\"\n  - \"threading [C++], thread stacks\"\nms.assetid: 1415f47d-417f-4f42-949b-946fb28aab0e\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Writing a Multithreaded Win32 Program\nWhen you write a program with multiple threads, you must coordinate their behavior and [use of the program's resources](#_core_sharing_common_resources_between_threads). You must also make sure that each thread receives [its own stack](#_core_thread_stacks).  \n  \n##  <a name=\"_core_sharing_common_resources_between_threads\"></a> Sharing Common Resources Between Threads  \n  \n> [!NOTE]\n>  For a similar discussion from the MFC point of view, see [Multithreading: Programming Tips](../parallel/multithreading-programming-tips.md) and [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md).  \n  \n Each thread has its own stack and its own copy of the CPU registers. Other resources, such as files, static data, and heap memory, are shared by all threads in the process. Threads using these common resources must be synchronized. Win32 provides several ways to synchronize resources, including semaphores, critical sections, events, and mutexes.  \n  \n When multiple threads are accessing static data, your program must provide for possible resource conflicts. Consider a program where one thread updates a static data structure containing *x*,*y* coordinates for items to be displayed by another thread. If the update thread alters the *x* coordinate and is preempted before it can change the *y* coordinate, the display thread might be scheduled before the *y* coordinate is updated. The item would be displayed at the wrong location. You can avoid this problem by using semaphores to control access to the structure.  \n  \n A mutex (short for *mut*ual *ex*clusion) is a way of communicating among threads or processes that are executing asynchronously of one another. This communication is usually used to coordinate the activities of multiple threads or processes, typically by controlling access to a shared resource by locking and unlocking the resource. To solve this *x*,*y* coordinate update problem, the update thread sets a mutex indicating that the data structure is in use before performing the update. It would clear the mutex after both coordinates had been processed. The display thread must wait for the mutex to be clear before updating the display. This process of waiting for a mutex is often called blocking on a mutex because the process is blocked and cannot continue until the mutex clears.  \n  \n The Bounce.c program shown in [Sample Multithread C Program](../parallel/sample-multithread-c-program.md) uses a mutex named `ScreenMutex` to coordinate screen updates. Each time one of the display threads is ready to write to the screen, it calls **WaitForSingleObject** with the handle to `ScreenMutex` and constant **INFINITE** to indicate that the **WaitForSingleObject** call should block on the mutex and not time out. If `ScreenMutex` is clear, the wait function sets the mutex so other threads cannot interfere with the display and continues executing the thread. Otherwise, the thread blocks until the mutex clears. When the thread completes the display update, it releases the mutex by calling **ReleaseMutex**.  \n  \n Screen displays and static data are only two of the resources requiring careful management. For example, your program might have multiple threads accessing the same file. Because another thread might have moved the file pointer, each thread must reset the file pointer before reading or writing. In addition, each thread must make sure that it is not preempted between the time it positions the pointer and the time it accesses the file. These threads should use a semaphore to coordinate access to the file by bracketing each file access with **WaitForSingleObject** and **ReleaseMutex** calls. The following code example illustrates this technique:  \n  \n```  \nHANDLE    hIOMutex= CreateMutex (NULL, FALSE, NULL);  \n  \nWaitForSingleObject( hIOMutex, INFINITE );  \nfseek( fp, desired_position, 0L );  \nfwrite( data, sizeof( data ), 1, fp );  \nReleaseMutex( hIOMutex);  \n```  \n  \n##  <a name=\"_core_thread_stacks\"></a> Thread Stacks  \n All of an application's default stack space is allocated to the first thread of execution, which is known as thread 1. As a result, you must specify how much memory to allocate for a separate stack for each additional thread your program needs. The operating system allocates additional stack space for the thread, if necessary, but you must specify a default value.  \n  \n The first argument in the `_beginthread` call is a pointer to the **BounceProc** function, which executes the threads. The second argument specifies the default stack size for the thread. The last argument is an ID number that is passed to **BounceProc**. **BounceProc** uses the ID number to seed the random number generator and to select the thread's color attribute and display character.  \n  \n Threads that make calls to the C run-time library or to the Win32 API must allow sufficient stack space for the library and API functions they call. The C `printf` function requires more than 500 bytes of stack space, and you should have 2K of stack space available when calling Win32 API routines.  \n  \n Because each thread has its own stack, you can avoid potential collisions over data items by using as little static data as possible. Design your program to use automatic stack variables for all data that can be private to a thread. The only global variables in the Bounce.c program are either mutexes or variables that never change after they are initialized.  \n  \n Win32 also provides Thread-Local Storage (TLS) to store per-thread data. For more information, see [Thread Local Storage (TLS)](../parallel/thread-local-storage-tls.md).  \n  \n## See Also  \n [Multithreading with C and Win32](../parallel/multithreading-with-c-and-win32.md)"}