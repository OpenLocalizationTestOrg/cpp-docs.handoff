{"nodes":[{"pos":[12,69],"content":"TN039: MFC-OLE Automation Implementation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN039: MFC-OLE Automation Implementation | Microsoft Docs","pos":[0,57]}]},{"content":"TN039: MFC/OLE Automation Implementation","pos":[734,774]},{"pos":[777,1092],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"Overview of OLE IDispatch Interface","pos":[1101,1136]},{"content":"The <ph id=\"ph1\">`IDispatch`</ph> interface is the means by which applications expose methods and properties such that other applications such as Visual BASIC, or other languages, can make use of the application's features.","pos":[1140,1345],"source":"The `IDispatch` interface is the means by which applications expose methods and properties such that other applications such as Visual BASIC, or other languages, can make use of the application's features."},{"content":"The most important part of this interface is the <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept> function.","pos":[1346,1426],"source":" The most important part of this interface is the **IDispatch::Invoke** function."},{"content":"MFC uses \"dispatch maps\" to implement <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept>.","pos":[1427,1487],"source":" MFC uses \"dispatch maps\" to implement **IDispatch::Invoke**."},{"content":"The dispatch map provides the MFC implementation information on the layout or \"shape\" of your <ph id=\"ph1\">`CCmdTarget`</ph>-derived classes, such that it can directly manipulate the properties of the object, or call member functions within your object to satisfy <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept> requests.","pos":[1488,1765],"source":" The dispatch map provides the MFC implementation information on the layout or \"shape\" of your `CCmdTarget`-derived classes, such that it can directly manipulate the properties of the object, or call member functions within your object to satisfy **IDispatch::Invoke** requests."},{"content":"For the most part, ClassWizard and MFC cooperate to hide most of the details of OLE automation from the application programmer.","pos":[1772,1899]},{"content":"The programmer concentrates on the actual functionality to expose in the application and doesn't have to worry about the underlying plumbing.","pos":[1900,2041]},{"content":"There are cases, however, where it is necessary to understand what MFC is doing behind the scenes.","pos":[2048,2146]},{"content":"This note will address how the framework assigns <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>s to member functions and properties.","pos":[2147,2243],"source":" This note will address how the framework assigns **DISPID**s to member functions and properties."},{"content":"Knowledge of the algorithm MFC uses for assigning <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>s is only necessary when you need to know the IDs, such as when you create a \"type library\" for your application's objects.","pos":[2244,2427],"source":" Knowledge of the algorithm MFC uses for assigning **DISPID**s is only necessary when you need to know the IDs, such as when you create a \"type library\" for your application's objects."},{"content":"MFC DISPID assignment","pos":[2436,2457]},{"content":"Although the end-user of automation (a Visual Basic user, for example), sees the actual names of the automation enabled properties and methods in their code (such as obj.ShowWindow), the implementation of <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept> does not receive the actual names.","pos":[2461,2722],"source":"Although the end-user of automation (a Visual Basic user, for example), sees the actual names of the automation enabled properties and methods in their code (such as obj.ShowWindow), the implementation of **IDispatch::Invoke** does not receive the actual names."},{"content":"For optimization reasons, it receives a <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>, which is a 32-bit \"magic cookie\" that describes the method or property that is to be accessed.","pos":[2723,2869],"source":" For optimization reasons, it receives a **DISPID**, which is a 32-bit \"magic cookie\" that describes the method or property that is to be accessed."},{"content":"These <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> values are returned from the <ph id=\"ph1\">`IDispatch`</ph> implementation through another method, called <bpt id=\"p2\">**</bpt>IDispatch::GetIDsOfNames<ept id=\"p2\">**</ept>.","pos":[2870,3003],"source":" These **DISPID** values are returned from the `IDispatch` implementation through another method, called **IDispatch::GetIDsOfNames**."},{"content":"An automation client application will call <ph id=\"ph1\">`GetIDsOfNames`</ph> once for each member or property it intends to access, and cache them for later calls to <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept>.","pos":[3004,3174],"source":" An automation client application will call `GetIDsOfNames` once for each member or property it intends to access, and cache them for later calls to **IDispatch::Invoke**."},{"content":"This way, the expensive string lookup is only done once per object use, instead of once per <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept> call.","pos":[3175,3294],"source":" This way, the expensive string lookup is only done once per object use, instead of once per **IDispatch::Invoke** call."},{"pos":[3301,3381],"content":"MFC determines the <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>s for each method and property based on two things:","source":"MFC determines the **DISPID**s for each method and property based on two things:"},{"content":"The distance from the top of the dispatch map (1 relative)","pos":[3391,3449]},{"content":"The distance of the dispatch map from the most derived class (0 relative)","pos":[3459,3532]},{"content":"The <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> is divided into two parts.","pos":[3539,3580],"source":"The **DISPID** is divided into two parts."},{"content":"The <bpt id=\"p1\">**</bpt>LOWORD<ept id=\"p1\">**</ept> of the <bpt id=\"p2\">**</bpt>DISPID<ept id=\"p2\">**</ept> contains the first component, the distance from the top of the dispatch map.","pos":[3581,3690],"source":" The **LOWORD** of the **DISPID** contains the first component, the distance from the top of the dispatch map."},{"content":"The <bpt id=\"p1\">**</bpt>HIWORD<ept id=\"p1\">**</ept> contains the distance from the most derived class.","pos":[3691,3756],"source":" The **HIWORD** contains the distance from the most derived class."},{"content":"For example:","pos":[3757,3769]},{"content":"As you can see, there are two classes, both of which expose OLE automation interfaces.","pos":[4357,4443]},{"content":"One of these classes is derived from the other and thus leverages the base class's functionality, including the OLE automation part (\"x\" and \"y\" properties in this case).","pos":[4444,4614]},{"pos":[4621,4683],"content":"MFC will generate <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>s for class CDispPoint as follows:","source":"MFC will generate **DISPID**s for class CDispPoint as follows:"},{"pos":[4775,4935],"content":"Since the properties are not in a base class, the <bpt id=\"p1\">**</bpt>HIWORD<ept id=\"p1\">**</ept> of the <bpt id=\"p2\">**</bpt>DISPID<ept id=\"p2\">**</ept> is always zero (the distance from the most derived class for CDispPoint is zero).","source":"Since the properties are not in a base class, the **HIWORD** of the **DISPID** is always zero (the distance from the most derived class for CDispPoint is zero)."},{"pos":[4942,5006],"content":"MFC will generate <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept>s for class CDisp3DPoint as follows:","source":"MFC will generate **DISPID**s for class CDisp3DPoint as follows:"},{"content":"The Z property is given a <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> with a zero <bpt id=\"p2\">**</bpt>HIWORD<ept id=\"p2\">**</ept> since it is defined in the class that is exposing the properties, CDisp3DPoint.","pos":[5133,5272],"source":"The Z property is given a **DISPID** with a zero **HIWORD** since it is defined in the class that is exposing the properties, CDisp3DPoint."},{"content":"Since the X and Y properties are defined in a base class, the <bpt id=\"p1\">**</bpt>HIWORD<ept id=\"p1\">**</ept> of the <bpt id=\"p2\">**</bpt>DISPID<ept id=\"p2\">**</ept> is 1, since the class in which these properties are defined is at a distance of one derivation from the most derived class.","pos":[5273,5487],"source":" Since the X and Y properties are defined in a base class, the **HIWORD** of the **DISPID** is 1, since the class in which these properties are defined is at a distance of one derivation from the most derived class."},{"pos":[5495,5743],"content":"[!NOTE]\n The **LOWORD** is always determined by the position in the map, even if there exist entries in the map with explicit **DISPID** (see next section for information on the **_ID** versions of the `DISP_PROPERTY` and `DISP_FUNCTION` macros).","leadings":["","> "],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>LOWORD<ept id=\"p1\">**</ept> is always determined by the position in the map, even if there exist entries in the map with explicit <bpt id=\"p2\">**</bpt>DISPID<ept id=\"p2\">**</ept> (see next section for information on the <bpt id=\"p3\">**</bpt>_ID<ept id=\"p3\">**</ept> versions of the <ph id=\"ph1\">`DISP_PROPERTY`</ph> and <ph id=\"ph2\">`DISP_FUNCTION`</ph> macros).","pos":[9,246],"source":" The **LOWORD** is always determined by the position in the map, even if there exist entries in the map with explicit **DISPID** (see next section for information on the **_ID** versions of the `DISP_PROPERTY` and `DISP_FUNCTION` macros)."}]},{"content":"Advanced MFC Dispatch Map Features","pos":[5752,5786]},{"content":"There are a number of additional features that ClassWizard does not support with this release of Visual C++.","pos":[5790,5898]},{"content":"ClassWizard supports <ph id=\"ph1\">`DISP_FUNCTION`</ph>, <ph id=\"ph2\">`DISP_PROPERTY`</ph>, and <ph id=\"ph3\">`DISP_PROPERTY_EX`</ph> which define a method, member variable property, and get/set member function property, respectively.","pos":[5899,6077],"source":" ClassWizard supports `DISP_FUNCTION`, `DISP_PROPERTY`, and `DISP_PROPERTY_EX` which define a method, member variable property, and get/set member function property, respectively."},{"content":"These capabilities are usually all that is needed to create most automation servers.","pos":[6078,6162]},{"pos":[6169,6319],"content":"The following additional macros can be used when the ClassWizard supported macros are not adequate: <ph id=\"ph1\">`DISP_PROPERTY_NOTIFY`</ph>, and <ph id=\"ph2\">`DISP_PROPERTY_PARAM`</ph>.","source":"The following additional macros can be used when the ClassWizard supported macros are not adequate: `DISP_PROPERTY_NOTIFY`, and `DISP_PROPERTY_PARAM`."},{"content":"DISP_PROPERTY_NOTIFY — Macro Description","pos":[6328,6368]},{"content":"Remarks","pos":[6500,6507]},{"content":"Parameters","pos":[6517,6527]},{"content":"Name of the class.","pos":[6545,6563]},{"content":"External name of the property.","pos":[6583,6613]},{"content":"Name of the member variable in which the property is stored.","pos":[6636,6696]},{"content":"Name of member function to call when property is changed.","pos":[6720,6777]},{"content":"A value specifying the property's type.","pos":[6800,6839]},{"content":"Remarks","pos":[6848,6855]},{"content":"This macro is much like <ph id=\"ph1\">`DISP_PROPERTY`</ph>, except that it accepts an additional argument.","pos":[6859,6946],"source":"This macro is much like `DISP_PROPERTY`, except that it accepts an additional argument."},{"content":"The additional argument, <bpt id=\"p1\">*</bpt>pfnAfterSet,<ept id=\"p1\">*</ept> should be a member function that returns nothing and takes no parameters, 'void OnPropertyNotify()'.","pos":[6947,7087],"source":" The additional argument, *pfnAfterSet,* should be a member function that returns nothing and takes no parameters, 'void OnPropertyNotify()'."},{"content":"It will be called <bpt id=\"p1\">**</bpt>after<ept id=\"p1\">**</ept> the member variable has been modified.","pos":[7088,7154],"source":" It will be called **after** the member variable has been modified."},{"content":"DISP_PROPERTY_PARAM — Macro Description","pos":[7163,7202]},{"content":"Remarks","pos":[7340,7347]},{"content":"Parameters","pos":[7357,7367]},{"content":"Name of the class.","pos":[7385,7403]},{"content":"External name of the property.","pos":[7423,7453]},{"content":"Name of the member function used to get the property.","pos":[7475,7528]},{"content":"Name of the member function used to set the property.","pos":[7550,7603]},{"content":"A value specifying the property's type.","pos":[7626,7665]},{"content":"A string of space separated VTS_ for each parameter.","pos":[7687,7739]},{"content":"Remarks","pos":[7748,7755]},{"content":"Much like the <ph id=\"ph1\">`DISP_PROPERTY_EX`</ph> macro, this macro defines a property accessed with separate Get and Set member functions.","pos":[7759,7881],"source":"Much like the `DISP_PROPERTY_EX` macro, this macro defines a property accessed with separate Get and Set member functions."},{"content":"This macro, however, allows you to specify a parameter list for the property.","pos":[7882,7959]},{"content":"This is useful for implementing properties that are indexed or parameterized in some other way.","pos":[7960,8055]},{"content":"The parameters will always be placed first, followed by the new value for the property.","pos":[8056,8143]},{"content":"For example:","pos":[8144,8156]},{"content":"would correspond to get and set member functions:","pos":[8281,8330]},{"content":"DISP_XXXX_ID — Macro Descriptions","pos":[8489,8522]},{"content":"Remarks","pos":[9090,9097]},{"content":"Parameters","pos":[9107,9117]},{"content":"Name of the class.","pos":[9135,9153]},{"content":"External name of the property.","pos":[9173,9203]},{"content":"The fixed DISPID for the property or method.","pos":[9222,9266]},{"content":"Name of the member function used to get the property.","pos":[9285,9338]},{"content":"Name of the member function used to set the property.","pos":[9357,9410]},{"content":"The name of the member variable to map to the property","pos":[9433,9487]},{"content":"A value specifying the property's type.","pos":[9510,9549]},{"content":"A string of space separated VTS_ for each parameter.","pos":[9571,9623]},{"content":"Remarks","pos":[9632,9639]},{"content":"These macros allow you to specify a <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> instead of letting MFC automatically assign one.","pos":[9643,9738],"source":"These macros allow you to specify a **DISPID** instead of letting MFC automatically assign one."},{"content":"These advanced macros have the same names except that ID is appended to the macro name (e.g. <bpt id=\"p1\">**</bpt>DISP_PROPERTY_ID<ept id=\"p1\">**</ept>) and the ID is determined by the parameter specified just after the <ph id=\"ph1\">`pszName`</ph> parameter.","pos":[9739,9941],"source":" These advanced macros have the same names except that ID is appended to the macro name (e.g. **DISP_PROPERTY_ID**) and the ID is determined by the parameter specified just after the `pszName` parameter."},{"content":"See AFXDISP.H for more information on these macros.","pos":[9942,9993]},{"content":"The <bpt id=\"p1\">**</bpt>_ID<ept id=\"p1\">**</ept> entries must be placed at the end of the dispatch map.","pos":[9994,10060],"source":" The **_ID** entries must be placed at the end of the dispatch map."},{"content":"They will affect the automatic <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> generation in the same way as a non-<bpt id=\"p2\">**</bpt>_ID<ept id=\"p2\">**</ept> version of the macro would (the <bpt id=\"p3\">**</bpt>DISPID<ept id=\"p3\">**</ept>s are determined by position).","pos":[10061,10219],"source":" They will affect the automatic **DISPID** generation in the same way as a non-**_ID** version of the macro would (the **DISPID**s are determined by position)."},{"content":"For example:","pos":[10220,10232]},{"content":"MFC will generate DISPIDs for class CDisp3DPoint as follows:","pos":[10522,10582]},{"pos":[10710,10979],"content":"Specifying a fixed <bpt id=\"p1\">**</bpt>DISPID<ept id=\"p1\">**</ept> is useful to maintain backward compatibility to a previously existing dispatch interface, or to implement certain system defined methods or properties (usually indicated by a negative <bpt id=\"p2\">**</bpt>DISPID<ept id=\"p2\">**</ept>, such as the <bpt id=\"p3\">**</bpt>DISPID_NEWENUM<ept id=\"p3\">**</ept> collection).","source":"Specifying a fixed **DISPID** is useful to maintain backward compatibility to a previously existing dispatch interface, or to implement certain system defined methods or properties (usually indicated by a negative **DISPID**, such as the **DISPID_NEWENUM** collection)."},{"content":"Retrieving the IDispatch Interface for a COleClientItem","pos":[10990,11045]},{"content":"Many servers will support automation within their document objects, along with the OLE server functionality.","pos":[11049,11157]},{"content":"In order to gain access to this automation interface, it is necessary to directly access the <bpt id=\"p1\">**</bpt>COleClientItem::m_lpObject<ept id=\"p1\">**</ept> member variable.","pos":[11158,11298],"source":" In order to gain access to this automation interface, it is necessary to directly access the **COleClientItem::m_lpObject** member variable."},{"content":"The code below will retrieve the <ph id=\"ph1\">`IDispatch`</ph> interface for an object derived from <ph id=\"ph2\">`COleClientItem`</ph>.","pos":[11299,11398],"source":" The code below will retrieve the `IDispatch` interface for an object derived from `COleClientItem`."},{"content":"You can include the code below in your application if you find this functionality necessary:","pos":[11399,11491]},{"content":"The dispatch interface returned from this function could then be used directly or attached to a <ph id=\"ph1\">`COleDispatchDriver`</ph> for type-safe access.","pos":[12325,12463],"source":"The dispatch interface returned from this function could then be used directly or attached to a `COleDispatchDriver` for type-safe access."},{"content":"If you use it directly, make sure that you call its <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> member when through with the pointer (the <ph id=\"ph1\">`COleDispatchDriver`</ph> destructor does this by default).","pos":[12464,12624],"source":" If you use it directly, make sure that you call its **Release** member when through with the pointer (the `COleDispatchDriver` destructor does this by default)."},{"content":"See Also","pos":[12633,12641]},{"content":"Technical Notes by Number","pos":[12646,12671]},{"content":"Technical Notes by Category","pos":[12715,12742]}],"content":"---\ntitle: \"TN039: MFC-OLE Automation Implementation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.ole\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC, COM support\"\n  - \"IDispatch interface\"\n  - \"MFC, OLE DB and\"\n  - \"TN039\"\n  - \"Automation, MFC COM interface entry points\"\nms.assetid: 765fa3e9-dd54-4f08-9ad2-26e0546ff8b6\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN039: MFC/OLE Automation Implementation\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n## Overview of OLE IDispatch Interface  \n The `IDispatch` interface is the means by which applications expose methods and properties such that other applications such as Visual BASIC, or other languages, can make use of the application's features. The most important part of this interface is the **IDispatch::Invoke** function. MFC uses \"dispatch maps\" to implement **IDispatch::Invoke**. The dispatch map provides the MFC implementation information on the layout or \"shape\" of your `CCmdTarget`-derived classes, such that it can directly manipulate the properties of the object, or call member functions within your object to satisfy **IDispatch::Invoke** requests.  \n  \n For the most part, ClassWizard and MFC cooperate to hide most of the details of OLE automation from the application programmer. The programmer concentrates on the actual functionality to expose in the application and doesn't have to worry about the underlying plumbing.  \n  \n There are cases, however, where it is necessary to understand what MFC is doing behind the scenes. This note will address how the framework assigns **DISPID**s to member functions and properties. Knowledge of the algorithm MFC uses for assigning **DISPID**s is only necessary when you need to know the IDs, such as when you create a \"type library\" for your application's objects.  \n  \n## MFC DISPID assignment  \n Although the end-user of automation (a Visual Basic user, for example), sees the actual names of the automation enabled properties and methods in their code (such as obj.ShowWindow), the implementation of **IDispatch::Invoke** does not receive the actual names. For optimization reasons, it receives a **DISPID**, which is a 32-bit \"magic cookie\" that describes the method or property that is to be accessed. These **DISPID** values are returned from the `IDispatch` implementation through another method, called **IDispatch::GetIDsOfNames**. An automation client application will call `GetIDsOfNames` once for each member or property it intends to access, and cache them for later calls to **IDispatch::Invoke**. This way, the expensive string lookup is only done once per object use, instead of once per **IDispatch::Invoke** call.  \n  \n MFC determines the **DISPID**s for each method and property based on two things:  \n  \n-   The distance from the top of the dispatch map (1 relative)  \n  \n-   The distance of the dispatch map from the most derived class (0 relative)  \n  \n The **DISPID** is divided into two parts. The **LOWORD** of the **DISPID** contains the first component, the distance from the top of the dispatch map. The **HIWORD** contains the distance from the most derived class. For example:  \n  \n```  \nclass CDispPoint : public CCmdTarget  \n{  \npublic:  \n    short m_x,\n    m_y;  \n ...  \n    DECLARE_DISPATCH_MAP() \n ...  \n};  \n \nclass CDisp3DPoint : public CDispPoint  \n{  \npublic:  \n    short m_z;  \n ...  \n    DECLARE_DISPATCH_MAP() \n ...  \n};  \n \nBEGIN_DISPATCH_MAP(CDispPoint,\n    CCmdTarget)  \n    DISP_PROPERTY(CDispPoint, \"x\",\n    m_x,\n    VT_I2)  \n    DISP_PROPERTY(CDispPoint, \"y\",\n    m_y,\n    VT_I2)  \nEND_DISPATCH_MAP()  \n \nBEGIN_DISPATCH_MAP(CDisp3DPoint,\n    CDispPoint)  \n    DISP_PROPERTY(CDisp3DPoint, \"z\",\n    m_z,\n    VT_I2)  \nEND_DISPATCH_MAP()  \n```  \n  \n As you can see, there are two classes, both of which expose OLE automation interfaces. One of these classes is derived from the other and thus leverages the base class's functionality, including the OLE automation part (\"x\" and \"y\" properties in this case).  \n  \n MFC will generate **DISPID**s for class CDispPoint as follows:  \n  \n```  \nproperty X    (DISPID)0x00000001  \nproperty Y    (DISPID)0x00000002  \n```  \n  \n Since the properties are not in a base class, the **HIWORD** of the **DISPID** is always zero (the distance from the most derived class for CDispPoint is zero).  \n  \n MFC will generate **DISPID**s for class CDisp3DPoint as follows:  \n  \n```  \nproperty Z    (DISPID)0x00000001  \nproperty X    (DISPID)0x00010001  \nproperty Y    (DISPID)0x00010002  \n```  \n  \n The Z property is given a **DISPID** with a zero **HIWORD** since it is defined in the class that is exposing the properties, CDisp3DPoint. Since the X and Y properties are defined in a base class, the **HIWORD** of the **DISPID** is 1, since the class in which these properties are defined is at a distance of one derivation from the most derived class.  \n  \n> [!NOTE]\n>  The **LOWORD** is always determined by the position in the map, even if there exist entries in the map with explicit **DISPID** (see next section for information on the **_ID** versions of the `DISP_PROPERTY` and `DISP_FUNCTION` macros).  \n  \n## Advanced MFC Dispatch Map Features  \n There are a number of additional features that ClassWizard does not support with this release of Visual C++. ClassWizard supports `DISP_FUNCTION`, `DISP_PROPERTY`, and `DISP_PROPERTY_EX` which define a method, member variable property, and get/set member function property, respectively. These capabilities are usually all that is needed to create most automation servers.  \n  \n The following additional macros can be used when the ClassWizard supported macros are not adequate: `DISP_PROPERTY_NOTIFY`, and `DISP_PROPERTY_PARAM`.  \n  \n## DISP_PROPERTY_NOTIFY — Macro Description  \n  \n```  \n \n    DISP_PROPERTY_NOTIFY(\n theClass,   \n    pszName, \n    memberName, \n    pfnAfterSet, \n    vtPropType) \n```  \n  \n## Remarks  \n  \n### Parameters  \n `theClass`  \n Name of the class.  \n  \n `pszName`  \n External name of the property.  \n  \n `memberName`  \n Name of the member variable in which the property is stored.  \n  \n `pfnAfterSet`  \n Name of member function to call when property is changed.  \n  \n `vtPropType`  \n A value specifying the property's type.  \n  \n## Remarks  \n This macro is much like `DISP_PROPERTY`, except that it accepts an additional argument. The additional argument, *pfnAfterSet,* should be a member function that returns nothing and takes no parameters, 'void OnPropertyNotify()'. It will be called **after** the member variable has been modified.  \n  \n## DISP_PROPERTY_PARAM — Macro Description  \n  \n```  \n \n    DISP_PROPERTY_PARAM(\n theClass,   \n    pszName, \n    pfnGet, \n    pfnSet, \n    vtPropType, \n    vtsParams) \n```  \n  \n## Remarks  \n  \n### Parameters  \n `theClass`  \n Name of the class.  \n  \n `pszName`  \n External name of the property.  \n  \n `memberGet`  \n Name of the member function used to get the property.  \n  \n `memberSet`  \n Name of the member function used to set the property.  \n  \n `vtPropType`  \n A value specifying the property's type.  \n  \n `vtsParams`  \n A string of space separated VTS_ for each parameter.  \n  \n## Remarks  \n Much like the `DISP_PROPERTY_EX` macro, this macro defines a property accessed with separate Get and Set member functions. This macro, however, allows you to specify a parameter list for the property. This is useful for implementing properties that are indexed or parameterized in some other way. The parameters will always be placed first, followed by the new value for the property. For example:  \n  \n```  \nDISP_PROPERTY_PARAM(CMyObject, \"item\",\n    GetItem,\n    SetItem,\n    VT_DISPATCH,\n    VTS_I2 VTS_I2)  \n```  \n  \n would correspond to get and set member functions:  \n  \n```  \nLPDISPATCH CMyObject::GetItem(short row,\n    short col)  \nvoid CMyObject::SetItem(short row,\n    short col,\n    LPDISPATCH newValue)  \n```  \n  \n## DISP_XXXX_ID — Macro Descriptions  \n  \n```  \n \n    DISP_FUNCTION_ID(\n theClass,   \n    pszName, \n    dispid, \n    pfnMember, \n    vtRetVal, \n    vtsParams)DISP_PROPERTY_ID(\n theClass,   \n    pszName, \n    dispid, \n    memberName, \n    vtPropType)DISP_PROPERTY_NOTIFY_ID(\n theClass,   \n    pszName, \n    dispid, \n    memberName, \n    pfnAfterSet, \n    vtPropType)DISP_PROPERTY_EX_ID(\n theClass,   \n    pszName, \n    dispid, \n    pfnGet, \n    pfnSet, \n    vtPropType)DISP_PROPERTY_PARAM_ID(\n theClass,   \n    pszName, \n    dispid, \n    pfnGet, \n    pfnSet, \n    vtPropType, \n    vtsParams) \n```  \n  \n## Remarks  \n  \n### Parameters  \n `theClass`  \n Name of the class.  \n  \n `pszName`  \n External name of the property.  \n  \n `dispid`  \n The fixed DISPID for the property or method.  \n  \n `pfnGet`  \n Name of the member function used to get the property.  \n  \n `pfnSet`  \n Name of the member function used to set the property.  \n  \n `memberName`  \n The name of the member variable to map to the property  \n  \n `vtPropType`  \n A value specifying the property's type.  \n  \n `vtsParams`  \n A string of space separated VTS_ for each parameter.  \n  \n## Remarks  \n These macros allow you to specify a **DISPID** instead of letting MFC automatically assign one. These advanced macros have the same names except that ID is appended to the macro name (e.g. **DISP_PROPERTY_ID**) and the ID is determined by the parameter specified just after the `pszName` parameter. See AFXDISP.H for more information on these macros. The **_ID** entries must be placed at the end of the dispatch map. They will affect the automatic **DISPID** generation in the same way as a non-**_ID** version of the macro would (the **DISPID**s are determined by position). For example:  \n  \n```  \nBEGIN_DISPATCH_MAP(CDisp3DPoint,\n    CCmdTarget)  \n    DISP_PROPERTY(CDisp3DPoint, \"y\",\n    m_y,\n    VT_I2)  \n    DISP_PROPERTY(CDisp3DPoint, \"z\",\n    m_z,\n    VT_I2)  \n    DISP_PROPERTY_ID(CDisp3DPoint, \"x\",\n    0x00020003,\n    m_x,\n    VT_I2)  \nEND_DISPATCH_MAP()  \n```  \n  \n MFC will generate DISPIDs for class CDisp3DPoint as follows:  \n  \n```  \nproperty X    (DISPID)0x00020003  \nproperty Y    (DISPID)0x00000002  \nproperty Z     (DISPID)0x00000001  \n```  \n  \n Specifying a fixed **DISPID** is useful to maintain backward compatibility to a previously existing dispatch interface, or to implement certain system defined methods or properties (usually indicated by a negative **DISPID**, such as the **DISPID_NEWENUM** collection).  \n  \n#### Retrieving the IDispatch Interface for a COleClientItem  \n Many servers will support automation within their document objects, along with the OLE server functionality. In order to gain access to this automation interface, it is necessary to directly access the **COleClientItem::m_lpObject** member variable. The code below will retrieve the `IDispatch` interface for an object derived from `COleClientItem`. You can include the code below in your application if you find this functionality necessary:  \n  \n```  \nLPDISPATCH CMyClientItem::GetIDispatch()  \n{  \n    ASSERT_VALID(this);\n\n ASSERT(m_lpObject != NULL);\n\n \n    LPUNKNOWN lpUnk = m_lpObject;  \n \n    Run();\n*// must be running  \n \n    LPOLELINK lpOleLink = NULL;  \n    if (m_lpObject->QueryInterface(IID_IOleLink,   \n (LPVOID FAR*)&lpOleLink) == NOERROR)  \n {  \n    ASSERT(lpOleLink != NULL);\n\n    lpUnk = NULL;  \n    if (lpOleLink->GetBoundSource(&lpUnk) != NOERROR)  \n {  \n    TRACE0(\"Warning: Link is not connected!\\n\");\n\n    lpOleLink->Release();\nreturn NULL;  \n }  \n    ASSERT(lpUnk != NULL);\n\n }  \n \n    LPDISPATCH lpDispatch = NULL;  \n    if (lpUnk->QueryInterface(IID_IDispatch, &lpDispatch)   \n != NOERROR)  \n {  \n    TRACE0(\"Warning: does not support IDispatch!\\n\");\n\n    return NULL;  \n }  \n \n    ASSERT(lpDispatch != NULL);\n\n    return lpDispatch;  \n}  \n```  \n  \n The dispatch interface returned from this function could then be used directly or attached to a `COleDispatchDriver` for type-safe access. If you use it directly, make sure that you call its **Release** member when through with the pointer (the `COleDispatchDriver` destructor does this by default).  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}