{"nodes":[{"pos":[12,76],"content":"TN059: Using MFC MBCS-Unicode Conversion Macros | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN059: Using MFC MBCS-Unicode Conversion Macros | Microsoft Docs","pos":[0,64]}]},{"content":"TN059: Using MFC MBCS/Unicode Conversion Macros","pos":[851,898]},{"pos":[901,1216],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"This note describes how to use the macros for MBCS/Unicode conversion, which are defined in AFXPRIV.H.","pos":[1223,1325]},{"content":"These macros are most useful if your application deals directly with the OLE API or for some reason, often needs to convert between Unicode and MBCS.","pos":[1326,1475]},{"content":"Overview","pos":[1484,1492]},{"content":"In MFC 3.x, a special DLL was used (MFCANS32.DLL) to automatically convert between Unicode and MBCS when OLE interfaces were called.","pos":[1496,1628]},{"content":"This DLL was an almost transparent layer that allowed OLE applications to be written as if the OLE APIs and interfaces were MBCS, even though they are always Unicode (except on the Macintosh).","pos":[1629,1821]},{"content":"While this layer was convenient and allowed applications to be quickly ported from Win16 to Win32 (MFC, Microsoft Word, Microsoft Excel, and VBA, are just some of the Microsoft applications that used this technology), it had a sometimes significant performance hit.","pos":[1822,2087]},{"content":"For this reason, MFC 4.x does not use this DLL and instead talks directly to the Unicode OLE interfaces.","pos":[2088,2192]},{"content":"To do this, MFC needs to convert to Unicode to MBCS when making a call to an OLE interface, and often needs to convert to MBCS from Unicode when implementing an OLE interface.","pos":[2193,2368]},{"content":"In order to handle this efficiently and easily, a number of macros were created to make this conversion easier.","pos":[2369,2480]},{"content":"One of the biggest hurdles of creating such a set of macros is memory allocation.","pos":[2487,2568]},{"content":"Because the strings cannot be converted in place, new memory to hold the converted results must be allocated.","pos":[2569,2678]},{"content":"This could have been done with code similar to the following:","pos":[2679,2740]},{"content":"This approach as a number of problems.","pos":[3113,3151]},{"content":"The main problem is that it is a lot of code to write, test, and debug.","pos":[3152,3223]},{"content":"Something that was a simple function call, is now much more complex.","pos":[3224,3292]},{"content":"In addition, there is a significant runtime overhead in doing so.","pos":[3293,3358]},{"content":"Memory has to be allocated on the heap and freed each time a conversion is done.","pos":[3359,3439]},{"content":"Finally, the code above would need to have appropriate <ph id=\"ph1\">`#ifdefs`</ph> added for Unicode and Macintosh builds (which don't require this conversion to take place).","pos":[3440,3596],"source":" Finally, the code above would need to have appropriate `#ifdefs` added for Unicode and Macintosh builds (which don't require this conversion to take place)."},{"content":"The solution we came up with is to create some macros which 1) mask the difference between the various platforms, and 2) use an efficient memory allocation scheme, and 3) are easy to insert into the existing source code.","pos":[3603,3823]},{"content":"Here is an example of one of the definitions:","pos":[3824,3869]},{"content":"Using this macro instead of the code above and things are much simpler:","pos":[4062,4133]},{"content":"There are extra calls where conversion is necessary, but using the macros is simple and effective.","pos":[4251,4349]},{"content":"The implementation of each macro uses the _alloca() function to allocate memory from the stack instead of the heap.","pos":[4356,4471]},{"content":"Allocating memory from the stack is much faster than allocating memory on the heap, and the memory is automatically freed when the function is exited.","pos":[4472,4622]},{"content":"In addition, the macros avoid calling <bpt id=\"p1\">**</bpt>MultiByteToWideChar<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>WideCharToMultiByte<ept id=\"p2\">**</ept>) more than one time.","pos":[4623,4733],"source":" In addition, the macros avoid calling **MultiByteToWideChar** (or **WideCharToMultiByte**) more than one time."},{"content":"This is done by allocating a little bit more memory than is necessary.","pos":[4734,4804]},{"content":"We know that an MBC will convert into at most one <bpt id=\"p1\">**</bpt>WCHAR<ept id=\"p1\">**</ept> and that for each <bpt id=\"p2\">**</bpt>WCHAR<ept id=\"p2\">**</ept> we will have a maximum of two MBC bytes.","pos":[4805,4933],"source":" We know that an MBC will convert into at most one **WCHAR** and that for each **WCHAR** we will have a maximum of two MBC bytes."},{"content":"By allocating a little more than necessary, but always enough to handle the conversion the second call second call to the conversion function is avoided.","pos":[4934,5087]},{"content":"The call to the helper function <bpt id=\"p1\">**</bpt>AfxA2Whelper<ept id=\"p1\">**</ept> reduces the number of argument pushes that must be done in order to perform the conversion (this results in smaller code, than if it called <bpt id=\"p2\">**</bpt>MultiByteToWideChar<ept id=\"p2\">**</ept> directly).","pos":[5088,5311],"source":" The call to the helper function **AfxA2Whelper** reduces the number of argument pushes that must be done in order to perform the conversion (this results in smaller code, than if it called **MultiByteToWideChar** directly)."},{"content":"In order to for the macros to have space to store the a temporary length, it is necessary to declare a local variable called _convert that does this in each function that uses the conversion macros.","pos":[5318,5516]},{"content":"This is done by invoking the <bpt id=\"p1\">**</bpt>USES_CONVERSION<ept id=\"p1\">**</ept> macro as seen above in the example.","pos":[5517,5601],"source":" This is done by invoking the **USES_CONVERSION** macro as seen above in the example."},{"content":"There are both generic conversion macros and OLE specific macros.","pos":[5608,5673]},{"content":"These two different macro sets are discussed below.","pos":[5674,5725]},{"content":"All of the macros reside in AFXPRIV.H.","pos":[5726,5764]},{"content":"Generic Conversion Macros","pos":[5773,5798]},{"content":"The generic conversion macros form the underlying mechanism.","pos":[5802,5862]},{"content":"The macro example and implementation shown in the previous section, A2W, is one such \"generic\" macro.","pos":[5863,5964]},{"content":"It is not related to OLE specifically.","pos":[5965,6003]},{"content":"The set of generic macros is listed below:","pos":[6004,6046]},{"content":"Besides doing text conversions, there are also macros and helper functions for converting <ph id=\"ph1\">`TEXTMETRIC`</ph>, <ph id=\"ph2\">`DEVMODE`</ph>, <ph id=\"ph3\">`BSTR`</ph>, and OLE allocated strings.","pos":[6200,6349],"source":"Besides doing text conversions, there are also macros and helper functions for converting `TEXTMETRIC`, `DEVMODE`, `BSTR`, and OLE allocated strings."},{"content":"These macros are beyond the scope of this discussion â€“ refer to AFXPRIV.H for more information on those macros.","pos":[6350,6461]},{"content":"OLE Conversion Macros","pos":[6470,6491]},{"content":"The OLE conversion macros are designed specifically for handling functions that expect <bpt id=\"p1\">**</bpt>OLESTR<ept id=\"p1\">**</ept> characters.","pos":[6495,6604],"source":"The OLE conversion macros are designed specifically for handling functions that expect **OLESTR** characters."},{"content":"If you examine the OLE headers, you will see many references to <bpt id=\"p1\">**</bpt>LPCOLESTR<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>OLECHAR<ept id=\"p2\">**</ept>.","pos":[6605,6699],"source":" If you examine the OLE headers, you will see many references to **LPCOLESTR** and **OLECHAR**."},{"content":"These types are used to refer to the type of characters used in OLE interfaces in a way that is not specific to the platform.","pos":[6700,6825]},{"content":"<bpt id=\"p1\">**</bpt>OLECHAR<ept id=\"p1\">**</ept> maps to <ph id=\"ph1\">`char`</ph> in Win16 and Macintosh platforms and <bpt id=\"p2\">**</bpt>WCHAR<ept id=\"p2\">**</ept> in Win32.","pos":[6826,6909],"source":"**OLECHAR** maps to `char` in Win16 and Macintosh platforms and **WCHAR** in Win32."},{"content":"In order to keep the number of <bpt id=\"p1\">**</bpt>#ifdef<ept id=\"p1\">**</ept> directives in the MFC code to a minimum we have a similar macro for each conversion that where OLE strings are involved.","pos":[6916,7078],"source":"In order to keep the number of **#ifdef** directives in the MFC code to a minimum we have a similar macro for each conversion that where OLE strings are involved."},{"content":"The following macros are the most commonly used:","pos":[7079,7127]},{"content":"Again, there are similar macros for doing <ph id=\"ph1\">`TEXTMETRIC`</ph>, <ph id=\"ph2\">`DEVMODE`</ph>, <ph id=\"ph3\">`BSTR`</ph>, and OLE allocated strings.","pos":[7289,7390],"source":"Again, there are similar macros for doing `TEXTMETRIC`, `DEVMODE`, `BSTR`, and OLE allocated strings."},{"content":"Refer to AFXPRIV.H for more information.","pos":[7391,7431]},{"content":"Other Considerations","pos":[7440,7460]},{"content":"Do not use the macros in a tight loop.","pos":[7464,7502]},{"content":"For example, you do not want to write the following kind of code:","pos":[7503,7568]},{"content":"The code above could result in allocating megabytes of memory on the stack depending on what the contents of the string <ph id=\"ph1\">`lpsz`</ph> is!","pos":[7735,7865],"source":"The code above could result in allocating megabytes of memory on the stack depending on what the contents of the string `lpsz` is!"},{"content":"It also takes time to convert the string for each iteration of the loop.","pos":[7866,7938]},{"content":"Instead, move such constant conversions out of the loop:","pos":[7939,7995]},{"content":"If the string is not constant, then encapsulate the method call into a function.","pos":[8199,8279]},{"content":"This will allow the conversion buffer to be freed each time.","pos":[8280,8340]},{"content":"For example:","pos":[8341,8353]},{"content":"Never return the result of one of the macros, unless the return value implies making a copy of the data before the return.","pos":[8628,8750]},{"content":"For example, this code is bad:","pos":[8751,8781]},{"content":"The code above could be fixed by changing the return value to something that copies the value:","pos":[9031,9125]},{"content":"The macros are easy to use and easy to insert into your code, but as you can tell from the caveats above, you need to be careful when using them.","pos":[9369,9514]},{"content":"See Also","pos":[9523,9531]},{"content":"Technical Notes by Number","pos":[9536,9561]},{"content":"Technical Notes by Category","pos":[9605,9632]}],"content":"---\ntitle: \"TN059: Using MFC MBCS-Unicode Conversion Macros | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.mbcs\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFCANS32.DLL\"\n  - \"Unicode [C++], conversion macros\"\n  - \"Unicode [C++], OLE interfaces\"\n  - \"conversion macros [C++]\"\n  - \"converting Unicode\"\n  - \"MBCS [C++], conversion macros\"\n  - \"macros [C++], MBCS conversion macros\"\n  - \"TN059\"\nms.assetid: a2aab748-94d0-4e2f-8447-3bd07112a705\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN059: Using MFC MBCS/Unicode Conversion Macros\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This note describes how to use the macros for MBCS/Unicode conversion, which are defined in AFXPRIV.H. These macros are most useful if your application deals directly with the OLE API or for some reason, often needs to convert between Unicode and MBCS.  \n  \n## Overview  \n In MFC 3.x, a special DLL was used (MFCANS32.DLL) to automatically convert between Unicode and MBCS when OLE interfaces were called. This DLL was an almost transparent layer that allowed OLE applications to be written as if the OLE APIs and interfaces were MBCS, even though they are always Unicode (except on the Macintosh). While this layer was convenient and allowed applications to be quickly ported from Win16 to Win32 (MFC, Microsoft Word, Microsoft Excel, and VBA, are just some of the Microsoft applications that used this technology), it had a sometimes significant performance hit. For this reason, MFC 4.x does not use this DLL and instead talks directly to the Unicode OLE interfaces. To do this, MFC needs to convert to Unicode to MBCS when making a call to an OLE interface, and often needs to convert to MBCS from Unicode when implementing an OLE interface. In order to handle this efficiently and easily, a number of macros were created to make this conversion easier.  \n  \n One of the biggest hurdles of creating such a set of macros is memory allocation. Because the strings cannot be converted in place, new memory to hold the converted results must be allocated. This could have been done with code similar to the following:  \n  \n```  \n// we want to convert an MBCS string in lpszA  \nint nLen = MultiByteToWideChar(CP_ACP,\n    0,\n    lpszA, -1,\n    NULL,\n    NULL);\n\nLPWSTR lpszW = new WCHAR[nLen];  \nMultiByteToWideChar(CP_ACP,\n    0,   \n    lpszA, -1,\n    lpszW,\n    nLen);\n\n// use it to call OLE here  \npI->SomeFunctionThatNeedsUnicode(lpszW);\n\n// free the string  \ndelete[] lpszW;  \n```  \n  \n This approach as a number of problems. The main problem is that it is a lot of code to write, test, and debug. Something that was a simple function call, is now much more complex. In addition, there is a significant runtime overhead in doing so. Memory has to be allocated on the heap and freed each time a conversion is done. Finally, the code above would need to have appropriate `#ifdefs` added for Unicode and Macintosh builds (which don't require this conversion to take place).  \n  \n The solution we came up with is to create some macros which 1) mask the difference between the various platforms, and 2) use an efficient memory allocation scheme, and 3) are easy to insert into the existing source code. Here is an example of one of the definitions:  \n  \n```  \n#define A2W(lpa) (\\  \n ((LPCSTR)lpa == NULL) NULL : (\\  \n    _convert = (strnlen(lpa)+1),\\  \n    AfxA2WHelper((LPWSTR) alloca(_convert*2),   \n    lpa,\n    _convert)\\)\\)  \n```  \n  \n Using this macro instead of the code above and things are much simpler:  \n  \n```  \n// use it to call OLE here  \nUSES_CONVERSION;  \npI->SomeFunctionThatNeedsUnicode(T2OLE(lpszA));\n```  \n  \n There are extra calls where conversion is necessary, but using the macros is simple and effective.  \n  \n The implementation of each macro uses the _alloca() function to allocate memory from the stack instead of the heap. Allocating memory from the stack is much faster than allocating memory on the heap, and the memory is automatically freed when the function is exited. In addition, the macros avoid calling **MultiByteToWideChar** (or **WideCharToMultiByte**) more than one time. This is done by allocating a little bit more memory than is necessary. We know that an MBC will convert into at most one **WCHAR** and that for each **WCHAR** we will have a maximum of two MBC bytes. By allocating a little more than necessary, but always enough to handle the conversion the second call second call to the conversion function is avoided. The call to the helper function **AfxA2Whelper** reduces the number of argument pushes that must be done in order to perform the conversion (this results in smaller code, than if it called **MultiByteToWideChar** directly).  \n  \n In order to for the macros to have space to store the a temporary length, it is necessary to declare a local variable called _convert that does this in each function that uses the conversion macros. This is done by invoking the **USES_CONVERSION** macro as seen above in the example.  \n  \n There are both generic conversion macros and OLE specific macros. These two different macro sets are discussed below. All of the macros reside in AFXPRIV.H.  \n  \n## Generic Conversion Macros  \n The generic conversion macros form the underlying mechanism. The macro example and implementation shown in the previous section, A2W, is one such \"generic\" macro. It is not related to OLE specifically. The set of generic macros is listed below:  \n  \n```  \nA2CW      (LPCSTR) -> (LPCWSTR)  \nA2W      (LPCSTR) -> (LPWSTR)  \nW2CA      (LPCWSTR) -> (LPCSTR)  \nW2A      (LPCWSTR) -> (LPSTR)  \n```  \n  \n Besides doing text conversions, there are also macros and helper functions for converting `TEXTMETRIC`, `DEVMODE`, `BSTR`, and OLE allocated strings. These macros are beyond the scope of this discussion â€“ refer to AFXPRIV.H for more information on those macros.  \n  \n## OLE Conversion Macros  \n The OLE conversion macros are designed specifically for handling functions that expect **OLESTR** characters. If you examine the OLE headers, you will see many references to **LPCOLESTR** and **OLECHAR**. These types are used to refer to the type of characters used in OLE interfaces in a way that is not specific to the platform. **OLECHAR** maps to `char` in Win16 and Macintosh platforms and **WCHAR** in Win32.  \n  \n In order to keep the number of **#ifdef** directives in the MFC code to a minimum we have a similar macro for each conversion that where OLE strings are involved. The following macros are the most commonly used:  \n  \n```  \nT2COLE   (LPCTSTR) -> (LPCOLESTR)  \nT2OLE   (LPCTSTR) -> (LPOLESTR)  \nOLE2CT   (LPCOLESTR) -> (LPCTSTR)  \nOLE2T   (LPCOLESTR) -> (LPCSTR)  \n```  \n  \n Again, there are similar macros for doing `TEXTMETRIC`, `DEVMODE`, `BSTR`, and OLE allocated strings. Refer to AFXPRIV.H for more information.  \n  \n## Other Considerations  \n Do not use the macros in a tight loop. For example, you do not want to write the following kind of code:  \n  \n```  \nvoid BadIterateCode(LPCTSTR lpsz)  \n{  \n    USES_CONVERSION; \n    for (int ii = 0; ii <10000; ii++)  \n    pI->SomeMethod(ii, T2COLE(lpsz));\n\n}  \n```  \n  \n The code above could result in allocating megabytes of memory on the stack depending on what the contents of the string `lpsz` is! It also takes time to convert the string for each iteration of the loop. Instead, move such constant conversions out of the loop:  \n  \n```  \nvoid MuchBetterIterateCode(LPCTSTR lpsz)  \n{  \n    USES_CONVERSION; \n    LPCOLESTR lpszT = T2COLE(lpsz);\n\n    for (int ii = 0; ii <10000; ii++)  \n    pI->SomeMethod(ii, lpszT);\n\n}  \n```  \n  \n If the string is not constant, then encapsulate the method call into a function. This will allow the conversion buffer to be freed each time. For example:  \n  \n```  \nvoid CallSomeMethod(int ii, LPCTSTR lpsz)  \n{  \n    USES_CONVERSION; \n    pI->SomeMethod(ii, T2COLE(lpsz));\n\n}  \n \nvoid MuchBetterIterateCode2(LPCTSTR* lpszArray)  \n{  \n    for (int ii = 0; ii <10000; ii++)  \n    CallSomeMethod(ii, lpszArray[ii]);\n\n}  \n```  \n  \n Never return the result of one of the macros, unless the return value implies making a copy of the data before the return. For example, this code is bad:  \n  \n```  \nLPTSTR BadConvert(ISomeInterface* pI)  \n{  \n    USES_CONVERSION; \n    LPOLESTR lpsz = NULL;  \n    pI->GetFileName(&lpsz);\n\n LPTSTR lpszT = OLE2T(lpsz);\n\n    CoMemFree(lpsz);\n\n return lpszT; // bad! returning alloca memory  \n}  \n```  \n  \n The code above could be fixed by changing the return value to something that copies the value:  \n  \n```  \nCString BetterConvert(ISomeInterface* pI)  \n{  \n    USES_CONVERSION; \n    LPOLESTR lpsz = NULL;  \n    pI->GetFileName(&lpsz);\n\n LPTSTR lpszT = OLE2T(lpsz);\n\n    CoMemFree(lpsz);\n\n return lpszT; // CString makes copy  \n}  \n```  \n  \n The macros are easy to use and easy to insert into your code, but as you can tell from the caveats above, you need to be careful when using them.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}