{"nodes":[{"pos":[12,78],"content":"How to: Marshal Unicode Strings Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Unicode Strings Using C++ Interop | Microsoft Docs","pos":[0,66]}]},{"content":"How to: Marshal Unicode Strings Using C++ Interop","pos":[752,801]},{"content":"This topic demonstrates one facet of Visual C++ interoperability.","pos":[802,867]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>.","pos":[868,982],"source":" For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)."},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[989,1247],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1248,1430],"source":" Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"This topic demonstrates how Unicode strings can be passed from a managed to an unmanaged function, and vice versa.","pos":[1437,1551]},{"content":"For interoperating with other strings types, see the following topics:","pos":[1552,1622]},{"content":"How to: Marshal ANSI Strings Using C++ Interop","pos":[1633,1679]},{"content":"How to: Marshal COM Strings Using C++ Interop","pos":[1751,1796]},{"content":"Example","pos":[1865,1872]},{"content":"To pass a Unicode string from a managed to an unmanaged function, the PtrToStringChars function (declared in Vcclr.h) can be used to access in the memory where the managed string is stored.","pos":[1876,2065]},{"content":"Because this address will be passed to a native function, it is important that the memory be pinned with <bpt id=\"p1\">[</bpt>pin_ptr (C++/CLI)<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept> to prevent the string data from being relocated, should a garbage collection cycle take place while the unmanaged function executes.","pos":[2066,2354],"source":" Because this address will be passed to a native function, it is important that the memory be pinned with [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to prevent the string data from being relocated, should a garbage collection cycle take place while the unmanaged function executes."},{"content":"Example","pos":[2970,2977]},{"content":"The following example demonstrates the data marshaling required to access a Unicode string in a managed function called by an unmanaged function.","pos":[2981,3126]},{"content":"The managed function, on receiving the native Unicode string, converts it to a managed string using the &lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt; method.","pos":[3127,3302],"source":" The managed function, on receiving the native Unicode string, converts it to a managed string using the <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> method."},{"content":"See Also","pos":[3909,3917]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[3922,3958]}],"content":"---\ntitle: \"How to: Marshal Unicode Strings Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interop [C++], strings\"\n  - \"marshaling [C++], strings\"\n  - \"C++ Interop, strings\"\n  - \"data marshaling [C++], strings\"\n  - \"Unicode, marshaling strings\"\nms.assetid: 96c2141d-6c5d-43ef-a1aa-5785afb9a9aa\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Unicode Strings Using C++ Interop\nThis topic demonstrates one facet of Visual C++ interoperability. For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n This topic demonstrates how Unicode strings can be passed from a managed to an unmanaged function, and vice versa. For interoperating with other strings types, see the following topics:  \n  \n-   [How to: Marshal ANSI Strings Using C++ Interop](../dotnet/how-to-marshal-ansi-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal COM Strings Using C++ Interop](../dotnet/how-to-marshal-com-strings-using-cpp-interop.md)  \n  \n## Example  \n To pass a Unicode string from a managed to an unmanaged function, the PtrToStringChars function (declared in Vcclr.h) can be used to access in the memory where the managed string is stored. Because this address will be passed to a native function, it is important that the memory be pinned with [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to prevent the string data from being relocated, should a garbage collection cycle take place while the unmanaged function executes.  \n  \n```  \n// MarshalUnicode1.cpp  \n// compile with: /clr  \n#include <iostream>  \n#include <stdio.h>  \n#include <vcclr.h>  \n  \nusing namespace std;  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \nvoid NativeTakesAString(const wchar_t* p) {  \n   printf_s(\"(native) received '%S'\\n\", p);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   String^ s = gcnew String(\"test string\");  \n   pin_ptr<const wchar_t> str = PtrToStringChars(s);  \n  \n   Console::WriteLine(\"(managed) passing string to native func...\");  \n   NativeTakesAString( str );  \n}  \n```  \n  \n## Example  \n The following example demonstrates the data marshaling required to access a Unicode string in a managed function called by an unmanaged function. The managed function, on receiving the native Unicode string, converts it to a managed string using the <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> method.  \n  \n```  \n// MarshalUnicode2.cpp  \n// compile with: /clr  \n#include <iostream>  \n  \nusing namespace std;  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma managed  \n  \nvoid ManagedStringFunc(wchar_t* s) {  \n   String^ ms = Marshal::PtrToStringUni((IntPtr)s);  \n   Console::WriteLine(\"(managed) received '{0}'\", ms);  \n}  \n  \n#pragma unmanaged  \n  \nvoid NativeProvidesAString() {  \n   cout << \"(unmanaged) calling managed func...\\n\";  \n   ManagedStringFunc(L\"test string\");  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   NativeProvidesAString();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}