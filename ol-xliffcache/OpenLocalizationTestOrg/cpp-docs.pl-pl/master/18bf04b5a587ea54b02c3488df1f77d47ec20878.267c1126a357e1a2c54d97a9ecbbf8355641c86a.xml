{"nodes":[{"pos":[12,62],"content":"Reference-Type Function Arguments | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Reference-Type Function Arguments | Microsoft Docs","pos":[0,50]}]},{"content":"Reference-Type Function Arguments","pos":[774,807]},{"content":"It is often more efficient to pass references, rather than large objects, to functions.","pos":[808,895]},{"content":"This allows the compiler to pass the address of the object while maintaining the syntax that would have been used to access the object.","pos":[896,1031]},{"content":"Consider the following example that uses the <ph id=\"ph1\">`Date`</ph> structure:","pos":[1032,1094],"source":" Consider the following example that uses the `Date` structure:"},{"pos":[1847,2035],"content":"The preceding code shows that members of a structure passed by reference are accessed using the member-selection operator (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>) instead of the pointer member-selection operator (<bpt id=\"p2\">**</bpt>–&gt;<ept id=\"p2\">**</ept>).","source":"The preceding code shows that members of a structure passed by reference are accessed using the member-selection operator (**.**) instead of the pointer member-selection operator (**–>**)."},{"content":"Although arguments passed as reference types observe the syntax of non-pointer types, they retain one important characteristic of pointer types: they are modifiable unless declared as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[2042,2236],"source":"Although arguments passed as reference types observe the syntax of non-pointer types, they retain one important characteristic of pointer types: they are modifiable unless declared as **const**."},{"content":"Because the intent of the preceding code is not to modify the object <ph id=\"ph1\">`GDate`</ph>, a more appropriate function prototype is:","pos":[2237,2356],"source":" Because the intent of the preceding code is not to modify the object `GDate`, a more appropriate function prototype is:"},{"pos":[2427,2522],"content":"This prototype guarantees that the function <ph id=\"ph1\">`JulianFromGregorian`</ph> will not change its argument.","source":"This prototype guarantees that the function `JulianFromGregorian` will not change its argument."},{"pos":[2529,2705],"content":"Any function prototyped as taking a reference type can accept an object of the same type in its place because there is a standard conversion from <bpt id=\"p1\">*</bpt>typename<ept id=\"p1\">*</ept> to <bpt id=\"p2\">*</bpt>typename<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p3\">**</ept>.","source":"Any function prototyped as taking a reference type can accept an object of the same type in its place because there is a standard conversion from *typename* to *typename***&**."},{"content":"See Also","pos":[2714,2722]},{"content":"References","pos":[2727,2737]}],"content":"---\ntitle: \"Reference-Type Function Arguments | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"arguments [C++], function\"\n  - \"functions [C++], paramters\"\n  - \"function parameters, reference-type\"\n  - \"function arguments, reference-type\"\n  - \"passing parameters, reference-type arguments\"\nms.assetid: 0a70e831-9e76-46c0-821d-aeba13d73cc0\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Reference-Type Function Arguments\nIt is often more efficient to pass references, rather than large objects, to functions. This allows the compiler to pass the address of the object while maintaining the syntax that would have been used to access the object. Consider the following example that uses the `Date` structure:  \n  \n```  \n// reference_type_function_arguments.cpp  \nstruct Date  \n{  \nshort DayOfWeek;  \nshort Month;  \nshort Day;  \nshort Year;  \n};  \n  \n// Create a Julian date of the form DDDYYYY  \n// from a Gregorian date.  \nlong JulianFromGregorian( Date& GDate )  \n{  \nstatic int cDaysInMonth[] = {  \n31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  \n   };  \nlong JDate = 0;  \n// Add in days for months already elapsed.  \nfor ( int i = 0; i < GDate.Month - 1; ++i )  \nJDate += cDaysInMonth[i];  \n// Add in days for this month.  \nJDate += GDate.Day;  \n  \n// Check for leap year.  \nif ( GDate.Year % 100 != 0 && GDate.Year % 4 == 0 )  \nJDate++;  \n// Add in year.  \nJDate *= 10000;  \nJDate += GDate.Year;  \n  \nreturn JDate;  \n}  \n  \nint main()  \n{  \n}  \n```  \n  \n The preceding code shows that members of a structure passed by reference are accessed using the member-selection operator (**.**) instead of the pointer member-selection operator (**–>**).  \n  \n Although arguments passed as reference types observe the syntax of non-pointer types, they retain one important characteristic of pointer types: they are modifiable unless declared as **const**. Because the intent of the preceding code is not to modify the object `GDate`, a more appropriate function prototype is:  \n  \n```  \nlong JulianFromGregorian( const Date& GDate );  \n```  \n  \n This prototype guarantees that the function `JulianFromGregorian` will not change its argument.  \n  \n Any function prototyped as taking a reference type can accept an object of the same type in its place because there is a standard conversion from *typename* to *typename***&**.  \n  \n## See Also  \n [References](../cpp/references-cpp.md)"}