{"nodes":[{"pos":[12,54],"content":"scanf Width Specification | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"scanf Width Specification | Microsoft Docs","pos":[0,42]}]},{"content":"scanf Width Specification","pos":[788,813]},{"content":"This information applies to the interpretation of format strings in the <ph id=\"ph1\">`scanf`</ph> family of functions, including the secure versions such as <ph id=\"ph2\">`scanf_s`</ph>.","pos":[814,963],"source":"This information applies to the interpretation of format strings in the `scanf` family of functions, including the secure versions such as `scanf_s`."},{"content":"These functions normally assume the input stream is divided into a sequence of tokens.","pos":[964,1050]},{"content":"Tokens are separated by whitespace (space, tab, or newline), or in the case of numerical types, by the natural end of a numerical data type as indicated by the first character that cannot be converted into numerical text.","pos":[1051,1272]},{"content":"However, the width specification may be used to cause parsing of the input to stop before the natural end of a token.","pos":[1273,1390]},{"content":"The <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> specification consists of characters between the <ph id=\"ph1\">`%`</ph> and the type field specifier, which may include a positive integer called the <bpt id=\"p2\">*</bpt>width<ept id=\"p2\">*</ept> field and one or more characters indicating the size of the field, which may also be considered as modifiers of the type of the field, such as an indication of whether the integer type is <bpt id=\"p3\">**</bpt>short<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>long<ept id=\"p4\">**</ept>.","pos":[1397,1758],"source":"The *width* specification consists of characters between the `%` and the type field specifier, which may include a positive integer called the *width* field and one or more characters indicating the size of the field, which may also be considered as modifiers of the type of the field, such as an indication of whether the integer type is **short** or **long**."},{"content":"Such characters are referred to as the size prefix.","pos":[1759,1810]},{"content":"The Width Field","pos":[1819,1834]},{"content":"<bpt id=\"p1\">*</bpt>The width<ept id=\"p1\">*</ept> field is a positive decimal integer controlling the maximum number of characters to be read for that field.","pos":[1838,1957],"source":"*The width* field is a positive decimal integer controlling the maximum number of characters to be read for that field."},{"content":"No more than <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> characters are converted and stored at the corresponding <ph id=\"ph1\">`argument`</ph>.","pos":[1958,2047],"source":" No more than *width* characters are converted and stored at the corresponding `argument`."},{"content":"Fewer than <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> characters may be read if a whitespace character (space, tab, or newline) or a character that cannot be converted according to the given format occurs before <bpt id=\"p2\">*</bpt>width<ept id=\"p2\">*</ept> is reached.","pos":[2048,2244],"source":" Fewer than *width* characters may be read if a whitespace character (space, tab, or newline) or a character that cannot be converted according to the given format occurs before *width* is reached."},{"content":"The width specification is separate and distinct from the buffer size argument required by the secure versions of these functions (i.e., <ph id=\"ph1\">`scanf_s`</ph>, <ph id=\"ph2\">`wscanf_s`</ph>, etc.).","pos":[2251,2417],"source":"The width specification is separate and distinct from the buffer size argument required by the secure versions of these functions (i.e., `scanf_s`, `wscanf_s`, etc.)."},{"content":"In the following example, the width specification is 20, indicating that up to 20 characters are to be read from the input stream.","pos":[2418,2548]},{"content":"The buffer length is 21, which includes room for the possible 20 characters plus the null terminator:","pos":[2549,2650]},{"content":"If the <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> field is not used, <ph id=\"ph1\">`scanf_s`</ph> will attempt to read the entire token into the string.","pos":[2716,2814],"source":"If the *width* field is not used, `scanf_s` will attempt to read the entire token into the string."},{"content":"If the size specified is not large enough to hold the entire token, nothing will be written to the destination string.","pos":[2815,2933]},{"content":"If the <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> field is specified, then the first <bpt id=\"p2\">*</bpt>width<ept id=\"p2\">*</ept> characters in the token will be written to the destination string along with the null terminator.","pos":[2934,3089],"source":" If the *width* field is specified, then the first *width* characters in the token will be written to the destination string along with the null terminator."},{"content":"The Size Prefix","pos":[3098,3113]},{"content":"The optional prefixes <bpt id=\"p1\">**</bpt>h<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>l<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>ll<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>I64<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>L<ept id=\"p5\">**</ept> indicate the size of the <ph id=\"ph1\">`argument`</ph> (long or short, single-byte character or wide character, depending upon the type character that they modify).","pos":[3117,3325],"source":"The optional prefixes **h**, **l**, **ll**, **I64**, and **L** indicate the size of the `argument` (long or short, single-byte character or wide character, depending upon the type character that they modify)."},{"content":"These format-specification characters are used with type characters in <ph id=\"ph1\">`scanf`</ph> or <ph id=\"ph2\">`wscanf`</ph> functions to specify interpretation of arguments as shown in the following table.","pos":[3326,3498],"source":" These format-specification characters are used with type characters in `scanf` or `wscanf` functions to specify interpretation of arguments as shown in the following table."},{"content":"The type prefix <bpt id=\"p1\">**</bpt>I64<ept id=\"p1\">**</ept> is a Microsoft extension and is not ANSI compatible.","pos":[3499,3575],"source":" The type prefix **I64** is a Microsoft extension and is not ANSI compatible."},{"content":"The type characters and their meanings are described in the \"Type Characters for scanf functions\" table in <bpt id=\"p1\">[</bpt>scanf Type Field Characters<ept id=\"p1\">](../c-runtime-library/scanf-type-field-characters.md)</ept>.","pos":[3576,3766],"source":" The type characters and their meanings are described in the \"Type Characters for scanf functions\" table in [scanf Type Field Characters](../c-runtime-library/scanf-type-field-characters.md)."},{"pos":[3774,3882],"content":"[!NOTE]\n The **h**, **l**, and **L** prefixes are Microsoft extensions when used with data of type `char`.","leadings":["","> "],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>h<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>l<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>L<ept id=\"p3\">**</ept> prefixes are Microsoft extensions when used with data of type <ph id=\"ph1\">`char`</ph>.","pos":[9,106],"source":" The **h**, **l**, and **L** prefixes are Microsoft extensions when used with data of type `char`."}]},{"content":"Size Prefixes for scanf and wscanf Format-Type Specifiers","pos":[3892,3949]},{"content":"To specify","pos":[3956,3966]},{"content":"Use prefix","pos":[3967,3977]},{"content":"With type specifier","pos":[3978,3997]},{"content":"double","pos":[4068,4074]},{"content":"l","pos":[4079,4080]},{"pos":[4083,4119],"content":"<bpt id=\"p1\">**</bpt>e<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>E<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>f<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>g<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>G<ept id=\"p5\">**</ept>","source":"**e**, **E**, **f**, **g**, or **G**"},{"pos":[4124,4156],"content":"<bpt id=\"p1\">**</bpt>long double<ept id=\"p1\">**</ept> (same as double)","source":"**long double** (same as double)"},{"content":"L","pos":[4159,4160]},{"pos":[4163,4199],"content":"<bpt id=\"p1\">**</bpt>e<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>E<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>f<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>g<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>G<ept id=\"p5\">**</ept>","source":"**e**, **E**, **f**, **g**, or **G**"},{"content":"long int","pos":[4206,4214]},{"content":"l","pos":[4219,4220]},{"pos":[4223,4259],"content":"<bpt id=\"p1\">**</bpt>d<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>i<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>o<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>x<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>X<ept id=\"p5\">**</ept>","source":"**d**, **i**, **o**, **x**, or **X**"},{"content":"long unsigned int","pos":[4266,4283]},{"content":"l","pos":[4288,4289]},{"content":"u","pos":[4294,4295]},{"content":"long long","pos":[4304,4313]},{"content":"ll","pos":[4318,4320]},{"pos":[4323,4359],"content":"<bpt id=\"p1\">**</bpt>d<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>i<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>o<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>x<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>X<ept id=\"p5\">**</ept>","source":"**d**, **i**, **o**, **x**, or **X**"},{"content":"h","pos":[4378,4379]},{"pos":[4382,4418],"content":"<bpt id=\"p1\">**</bpt>d<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>i<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>o<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>x<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>X<ept id=\"p5\">**</ept>","source":"**d**, **i**, **o**, **x**, or **X**"},{"content":"short unsigned int","pos":[4425,4443]},{"content":"h","pos":[4448,4449]},{"content":"u","pos":[4454,4455]},{"pos":[4462,4473],"content":"__<bpt id=\"p1\">**</bpt>int64<ept id=\"p1\">**</ept>","source":"__**int64**"},{"content":"I64","pos":[4476,4479]},{"pos":[4482,4525],"content":"<bpt id=\"p1\">**</bpt>d<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>i<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>o<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>u<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>x<ept id=\"p5\">**</ept>, or <bpt id=\"p6\">**</bpt>X<ept id=\"p6\">**</ept>","source":"**d**, **i**, **o**, **u**, **x**, or **X**"},{"pos":[4530,4556],"content":"Single-byte character with"},{"content":"h","pos":[4567,4568]},{"pos":[4571,4585],"content":"<bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>C<ept id=\"p2\">**</ept>","source":"**c** or **C**"},{"pos":[4590,4616],"content":"Single-byte character with"},{"content":"h","pos":[4628,4629]},{"pos":[4632,4646],"content":"<bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>C<ept id=\"p2\">**</ept>","source":"**c** or **C**"},{"pos":[4651,4670],"content":"Wide character with"},{"content":"l","pos":[4681,4682]},{"pos":[4685,4699],"content":"<bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>C<ept id=\"p2\">**</ept>","source":"**c** or **C**"},{"pos":[4704,4723],"content":"Wide character with"},{"content":"l","pos":[4735,4736]},{"pos":[4739,4754],"content":"<bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept>, or <bpt id=\"p2\">**</bpt>C<ept id=\"p2\">**</ept>","source":"**c**, or **C**"},{"pos":[4759,4794],"content":"Single-byte – character string with"},{"content":"h","pos":[4805,4806]},{"pos":[4809,4823],"content":"<bpt id=\"p1\">**</bpt>s<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>S<ept id=\"p2\">**</ept>","source":"**s** or **S**"},{"pos":[4828,4863],"content":"Single-byte – character string with"},{"content":"h","pos":[4875,4876]},{"pos":[4879,4893],"content":"<bpt id=\"p1\">**</bpt>s<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>S<ept id=\"p2\">**</ept>","source":"**s** or **S**"},{"pos":[4898,4924],"content":"Wide-character string with"},{"content":"l","pos":[4935,4936]},{"pos":[4939,4953],"content":"<bpt id=\"p1\">**</bpt>s<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>S<ept id=\"p2\">**</ept>","source":"**s** or **S**"},{"pos":[4958,4984],"content":"Wide-character string with"},{"content":"l","pos":[4996,4997]},{"pos":[5000,5014],"content":"<bpt id=\"p1\">**</bpt>s<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>S<ept id=\"p2\">**</ept>","source":"**s** or **S**"},{"pos":[5022,5115],"content":"The following examples use <bpt id=\"p1\">**</bpt>h<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>l<ept id=\"p2\">**</ept> with <ph id=\"ph1\">`scanf_s`</ph> functions and <ph id=\"ph2\">`wscanf_s`</ph> functions:","source":"The following examples use **h** and **l** with `scanf_s` functions and `wscanf_s` functions:"},{"pos":[5260,5392],"content":"If using an unsecure function in the <ph id=\"ph1\">`scanf`</ph> family, omit the size parameter indicating the buffer length of the preceding argument.","source":"If using an unsecure function in the `scanf` family, omit the size parameter indicating the buffer length of the preceding argument."},{"content":"Reading Undelimited strings","pos":[5401,5428]},{"content":"To read strings not delimited by whitespace characters, a set of characters in brackets (<bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept>) can be substituted for the <bpt id=\"p2\">**</bpt>s<ept id=\"p2\">**</ept> (string) type character.","pos":[5432,5587],"source":"To read strings not delimited by whitespace characters, a set of characters in brackets (**[ ]**) can be substituted for the **s** (string) type character."},{"content":"The set of characters in brackets is referred to as a control string.","pos":[5588,5657]},{"content":"The corresponding input field is read up to the first character that does not appear in the control string.","pos":[5658,5765]},{"content":"If the first character in the set is a caret (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">^</ph><ept id=\"p1\">**</ept>), the effect is reversed: The input field is read up to the first character that does appear in the rest of the character set.","pos":[5766,5944],"source":" If the first character in the set is a caret (**^**), the effect is reversed: The input field is read up to the first character that does appear in the rest of the character set."},{"content":"Note that <bpt id=\"p1\">**</bpt>%[a-z]<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>%[z-a]<ept id=\"p2\">**</ept> are interpreted as equivalent to <bpt id=\"p3\">**</bpt>%[abcde...z]<ept id=\"p3\">**</ept>.","pos":[5951,6037],"source":"Note that **%[a-z]** and **%[z-a]** are interpreted as equivalent to **%[abcde...z]**."},{"content":"This is a common <ph id=\"ph1\">`scanf`</ph> function extension, but note that the ANSI standard does not require it.","pos":[6038,6135],"source":" This is a common `scanf` function extension, but note that the ANSI standard does not require it."},{"content":"Reading Unterminated strings","pos":[6144,6172]},{"content":"To store a string without storing a terminating null character ('\\0'), use the specification <ph id=\"ph1\">`%`</ph><bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt>c<ept id=\"p2\">**</ept> where <bpt id=\"p3\">*</bpt>n<ept id=\"p3\">*</ept> is a decimal integer.","pos":[6176,6312],"source":"To store a string without storing a terminating null character ('\\0'), use the specification `%`*n***c** where *n* is a decimal integer."},{"content":"In this case, the <bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept> type character indicates that the argument is a pointer to a character array.","pos":[6313,6414],"source":" In this case, the **c** type character indicates that the argument is a pointer to a character array."},{"content":"The next <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> characters are read from the input stream into the specified location, and no null character ('\\0') is appended.","pos":[6415,6540],"source":" The next *n* characters are read from the input stream into the specified location, and no null character ('\\0') is appended."},{"content":"If <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> is not specified, its default value is 1.","pos":[6541,6589],"source":" If *n* is not specified, its default value is 1."},{"content":"When scanf stops reading a field","pos":[6598,6630]},{"content":"The <ph id=\"ph1\">`scanf`</ph> function scans each input field, character by character.","pos":[6634,6702],"source":"The `scanf` function scans each input field, character by character."},{"content":"It may stop reading a particular input field before it reaches a space character for a variety of reasons:","pos":[6703,6809]},{"content":"The specified width has been reached.","pos":[6819,6856]},{"content":"The next character cannot be converted as specified.","pos":[6866,6918]},{"content":"The next character conflicts with a character in the control string that it is supposed to match.","pos":[6928,7025]},{"content":"The next character fails to appear in a given character set.","pos":[7035,7095]},{"content":"For whatever reason, when the <ph id=\"ph1\">`scanf`</ph> function stops reading an input field, the next input field is considered to begin at the first unread character.","pos":[7102,7253],"source":"For whatever reason, when the `scanf` function stops reading an input field, the next input field is considered to begin at the first unread character."},{"content":"The conflicting character, if there is one, is considered unread and is the first character of the next input field or the first character in subsequent read operations on the input stream.","pos":[7254,7443]},{"content":"See Also","pos":[7452,7460]},{"content":"scanf, _scanf_l, wscanf, _wscanf_l","pos":[7465,7499]},{"content":"scanf_s, _scanf_s_l, wscanf_s, _wscanf_s_l","pos":[7571,7613]},{"content":"Format Specification Fields: scanf and wscanf Functions","pos":[7693,7748]},{"content":"scanf Type Field Characters","pos":[7835,7862]}],"content":"---\ntitle: \"scanf Width Specification | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napilocation: \n  - \"msvcr100.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr90.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"scanf\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"scanf function, width specification\"\nms.assetid: 94b4e8fe-c4a2-4799-8b6c-a2cf28ffb09c\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# scanf Width Specification\nThis information applies to the interpretation of format strings in the `scanf` family of functions, including the secure versions such as `scanf_s`. These functions normally assume the input stream is divided into a sequence of tokens. Tokens are separated by whitespace (space, tab, or newline), or in the case of numerical types, by the natural end of a numerical data type as indicated by the first character that cannot be converted into numerical text. However, the width specification may be used to cause parsing of the input to stop before the natural end of a token.  \n  \n The *width* specification consists of characters between the `%` and the type field specifier, which may include a positive integer called the *width* field and one or more characters indicating the size of the field, which may also be considered as modifiers of the type of the field, such as an indication of whether the integer type is **short** or **long**. Such characters are referred to as the size prefix.  \n  \n## The Width Field  \n *The width* field is a positive decimal integer controlling the maximum number of characters to be read for that field. No more than *width* characters are converted and stored at the corresponding `argument`. Fewer than *width* characters may be read if a whitespace character (space, tab, or newline) or a character that cannot be converted according to the given format occurs before *width* is reached.  \n  \n The width specification is separate and distinct from the buffer size argument required by the secure versions of these functions (i.e., `scanf_s`, `wscanf_s`, etc.). In the following example, the width specification is 20, indicating that up to 20 characters are to be read from the input stream. The buffer length is 21, which includes room for the possible 20 characters plus the null terminator:  \n  \n```  \nchar str[21];  \nscanf_s(\"%20s\", str, 21);  \n```  \n  \n If the *width* field is not used, `scanf_s` will attempt to read the entire token into the string. If the size specified is not large enough to hold the entire token, nothing will be written to the destination string. If the *width* field is specified, then the first *width* characters in the token will be written to the destination string along with the null terminator.  \n  \n## The Size Prefix  \n The optional prefixes **h**, **l**, **ll**, **I64**, and **L** indicate the size of the `argument` (long or short, single-byte character or wide character, depending upon the type character that they modify). These format-specification characters are used with type characters in `scanf` or `wscanf` functions to specify interpretation of arguments as shown in the following table. The type prefix **I64** is a Microsoft extension and is not ANSI compatible. The type characters and their meanings are described in the \"Type Characters for scanf functions\" table in [scanf Type Field Characters](../c-runtime-library/scanf-type-field-characters.md).  \n  \n> [!NOTE]\n>  The **h**, **l**, and **L** prefixes are Microsoft extensions when used with data of type `char`.  \n  \n### Size Prefixes for scanf and wscanf Format-Type Specifiers  \n  \n|To specify|Use prefix|With type specifier|  \n|----------------|----------------|-------------------------|  \n|**double**|**l**|**e**, **E**, **f**, **g**, or **G**|  \n|**long double** (same as double)|**L**|**e**, **E**, **f**, **g**, or **G**|  \n|**long int**|**l**|**d**, **i**, **o**, **x**, or **X**|  \n|**long unsigned int**|**l**|**u**|  \n|**long long**|**ll**|**d**, **i**, **o**, **x**, or **X**|  \n|`short int`|**h**|**d**, **i**, **o**, **x**, or **X**|  \n|**short unsigned int**|**h**|**u**|  \n|__**int64**|**I64**|**d**, **i**, **o**, **u**, **x**, or **X**|  \n|Single-byte character with `scanf`|**h**|**c** or **C**|  \n|Single-byte character with `wscanf`|**h**|**c** or **C**|  \n|Wide character with `scanf`|**l**|**c** or **C**|  \n|Wide character with `wscanf`|**l**|**c**, or **C**|  \n|Single-byte – character string with `scanf`|**h**|**s** or **S**|  \n|Single-byte – character string with `wscanf`|**h**|**s** or **S**|  \n|Wide-character string with `scanf`|**l**|**s** or **S**|  \n|Wide-character string with `wscanf`|**l**|**s** or **S**|  \n  \n The following examples use **h** and **l** with `scanf_s` functions and `wscanf_s` functions:  \n  \n```  \nscanf_s(\"%ls\", &x, 2);     // Read a wide-character string  \nwscanf_s(L\"%hC\", &x, 2);    // Read a single-byte character  \n```  \n  \n If using an unsecure function in the `scanf` family, omit the size parameter indicating the buffer length of the preceding argument.  \n  \n## Reading Undelimited strings  \n To read strings not delimited by whitespace characters, a set of characters in brackets (**[ ]**) can be substituted for the **s** (string) type character. The set of characters in brackets is referred to as a control string. The corresponding input field is read up to the first character that does not appear in the control string. If the first character in the set is a caret (**^**), the effect is reversed: The input field is read up to the first character that does appear in the rest of the character set.  \n  \n Note that **%[a-z]** and **%[z-a]** are interpreted as equivalent to **%[abcde...z]**. This is a common `scanf` function extension, but note that the ANSI standard does not require it.  \n  \n## Reading Unterminated strings  \n To store a string without storing a terminating null character ('\\0'), use the specification `%`*n***c** where *n* is a decimal integer. In this case, the **c** type character indicates that the argument is a pointer to a character array. The next *n* characters are read from the input stream into the specified location, and no null character ('\\0') is appended. If *n* is not specified, its default value is 1.  \n  \n## When scanf stops reading a field  \n The `scanf` function scans each input field, character by character. It may stop reading a particular input field before it reaches a space character for a variety of reasons:  \n  \n-   The specified width has been reached.  \n  \n-   The next character cannot be converted as specified.  \n  \n-   The next character conflicts with a character in the control string that it is supposed to match.  \n  \n-   The next character fails to appear in a given character set.  \n  \n For whatever reason, when the `scanf` function stops reading an input field, the next input field is considered to begin at the first unread character. The conflicting character, if there is one, is considered unread and is the first character of the next input field or the first character in subsequent read operations on the input stream.  \n  \n## See Also  \n [scanf, _scanf_l, wscanf, _wscanf_l](../c-runtime-library/reference/scanf-scanf-l-wscanf-wscanf-l.md)   \n [scanf_s, _scanf_s_l, wscanf_s, _wscanf_s_l](../c-runtime-library/reference/scanf-s-scanf-s-l-wscanf-s-wscanf-s-l.md)   \n [Format Specification Fields: scanf and wscanf Functions](../c-runtime-library/format-specification-fields-scanf-and-wscanf-functions.md)   \n [scanf Type Field Characters](../c-runtime-library/scanf-type-field-characters.md)"}