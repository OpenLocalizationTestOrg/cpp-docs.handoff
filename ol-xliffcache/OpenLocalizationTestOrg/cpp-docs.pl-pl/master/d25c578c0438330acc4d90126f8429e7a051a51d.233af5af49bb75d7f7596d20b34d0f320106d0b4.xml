{"nodes":[{"pos":[12,53],"content":"Stringizing Operator (#) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Stringizing Operator (#) | Microsoft Docs","pos":[0,41]}]},{"content":"Stringizing Operator (#)","pos":[844,868]},{"content":"The number-sign or \"stringizing\" operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">#</ph><ept id=\"p1\">**</ept>) converts macro parameters to string literals without expanding the parameter definition.","pos":[869,1007],"source":"The number-sign or \"stringizing\" operator (**#**) converts macro parameters to string literals without expanding the parameter definition."},{"content":"It is used only with macros that take arguments.","pos":[1008,1056]},{"content":"If it precedes a formal parameter in the macro definition, the actual argument passed by the macro invocation is enclosed in quotation marks and treated as a string literal.","pos":[1057,1230]},{"content":"The string literal then replaces each occurrence of a combination of the stringizing operator and formal parameter within the macro definition.","pos":[1231,1374]},{"pos":[1382,1692],"content":"[!NOTE]\n The Microsoft C (versions 6.0 and earlier) extension to the ANSI C standard that previously expanded macro formal arguments appearing inside string literals and character constants is no longer supported. Code that relied on this extension should be rewritten using the stringizing (**#**) operator.","leadings":["","> "],"nodes":[{"content":" The Microsoft C (versions 6.0 and earlier) extension to the ANSI C standard that previously expanded macro formal arguments appearing inside string literals and character constants is no longer supported. Code that relied on this extension should be rewritten using the stringizing (**#**) operator.","pos":[8,308],"nodes":[{"content":"The Microsoft C (versions 6.0 and earlier) extension to the ANSI C standard that previously expanded macro formal arguments appearing inside string literals and character constants is no longer supported.","pos":[1,205]},{"content":"Code that relied on this extension should be rewritten using the stringizing (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">#</ph><ept id=\"p1\">**</ept>) operator.","pos":[206,300],"source":" Code that relied on this extension should be rewritten using the stringizing (**#**) operator."}]}]},{"content":"White space preceding the first token of the actual argument and following the last token of the actual argument is ignored.","pos":[1698,1822]},{"content":"Any white space between the tokens in the actual argument is reduced to a single white space in the resulting string literal.","pos":[1823,1948]},{"content":"Thus, if a comment occurs between two tokens in the actual argument, it is reduced to a single white space.","pos":[1949,2056]},{"content":"The resulting string literal is automatically concatenated with any adjacent string literals from which it is separated only by white space.","pos":[2057,2197]},{"pos":[2203,2472],"content":"Further, if a character contained in the argument usually requires an escape sequence when used in a string literal (for example, the quotation mark (<bpt id=\"p1\">**</bpt>\"<ept id=\"p1\">**</ept>) or backslash (<bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\\\</ph><ept id=\"p2\">**</ept>) character), the necessary escape backslash is automatically inserted before the character.","source":"Further, if a character contained in the argument usually requires an escape sequence when used in a string literal (for example, the quotation mark (**\"**) or backslash (**\\\\**) character), the necessary escape backslash is automatically inserted before the character."},{"content":"The Visual C++ stringizing operator does not behave correctly when it is used with strings that include escape sequences.","pos":[2478,2599]},{"content":"In this situation, the compiler generates <bpt id=\"p1\">[</bpt>Compiler Error C2017<ept id=\"p1\">](../error-messages/compiler-errors-1/compiler-error-c2017.md)</ept>.","pos":[2600,2726],"source":" In this situation, the compiler generates [Compiler Error C2017](../error-messages/compiler-errors-1/compiler-error-c2017.md)."},{"content":"Example","pos":[2735,2742]},{"content":"The following example shows a macro definition that includes the stringizing operator and a main function that invokes the macro:","pos":[2745,2874]},{"content":"Such invocations would be expanded during preprocessing, producing the following code:","pos":[2880,2966]},{"content":"Example","pos":[3663,3670]},{"content":"The following sample shows how you can expand a macro parameter:","pos":[3673,3737]},{"content":"See Also","pos":[3911,3919]},{"content":"Preprocessor Operators","pos":[3924,3946]}],"content":"---\ntitle: \"Stringizing Operator (#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"#\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"preprocessor, operators\"\n  - \"arguments [C++], converting to strings\"\n  - \"stringizing operator\"\n  - \"preprocessor\"\n  - \"string literals, converting macro parameters to\"\n  - \"macros [C++], converting parameters to strings\"\n  - \"# preprocessor operator\"\nms.assetid: 1175dd19-4538-43b3-ad97-a008ab80e7b1\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Stringizing Operator (#)\nThe number-sign or \"stringizing\" operator (**#**) converts macro parameters to string literals without expanding the parameter definition. It is used only with macros that take arguments. If it precedes a formal parameter in the macro definition, the actual argument passed by the macro invocation is enclosed in quotation marks and treated as a string literal. The string literal then replaces each occurrence of a combination of the stringizing operator and formal parameter within the macro definition.  \n  \n> [!NOTE]\n>  The Microsoft C (versions 6.0 and earlier) extension to the ANSI C standard that previously expanded macro formal arguments appearing inside string literals and character constants is no longer supported. Code that relied on this extension should be rewritten using the stringizing (**#**) operator.  \n  \nWhite space preceding the first token of the actual argument and following the last token of the actual argument is ignored. Any white space between the tokens in the actual argument is reduced to a single white space in the resulting string literal. Thus, if a comment occurs between two tokens in the actual argument, it is reduced to a single white space. The resulting string literal is automatically concatenated with any adjacent string literals from which it is separated only by white space.  \n  \nFurther, if a character contained in the argument usually requires an escape sequence when used in a string literal (for example, the quotation mark (**\"**) or backslash (**\\\\**) character), the necessary escape backslash is automatically inserted before the character.  \n  \nThe Visual C++ stringizing operator does not behave correctly when it is used with strings that include escape sequences. In this situation, the compiler generates [Compiler Error C2017](../error-messages/compiler-errors-1/compiler-error-c2017.md).  \n  \n## Example  \nThe following example shows a macro definition that includes the stringizing operator and a main function that invokes the macro:  \n  \nSuch invocations would be expanded during preprocessing, producing the following code:  \n  \n```cpp  \nint main() {  \n   printf_s( \"In quotes in the printf function call\\n\" \"\\n\" );  \n   printf_s( \"\\\"In quotes when printed to the screen\\\"\\n\" \"\\n\" );  \n   printf_s( \"\\\"This: \\\\\\\" prints an escaped double quote\\\"\" \"\\n\" );  \n}  \n```  \n  \n```cpp  \n// stringizer.cpp  \n#include <stdio.h>  \n#define stringer( x ) printf_s( #x \"\\n\" )  \nint main() {  \n   stringer( In quotes in the printf function call );   \n   stringer( \"In quotes when printed to the screen\" );     \n   stringer( \"This: \\\"  prints an escaped double quote\" );  \n}  \n```  \n  \n```Output  \nIn quotes in the printf function call  \n\"In quotes when printed to the screen\"  \n\"This: \\\"  prints an escaped double quote\"  \n```  \n  \n## Example  \nThe following sample shows how you can expand a macro parameter:  \n  \n```cpp  \n// stringizer_2.cpp  \n// compile with: /E  \n#define F abc  \n#define B def  \n#define FB(arg) #arg  \n#define FB1(arg) FB(arg)  \nFB(F B)  \nFB1(F B)  \n```  \n  \n## See Also  \n [Preprocessor Operators](../preprocessor/preprocessor-operators.md)"}