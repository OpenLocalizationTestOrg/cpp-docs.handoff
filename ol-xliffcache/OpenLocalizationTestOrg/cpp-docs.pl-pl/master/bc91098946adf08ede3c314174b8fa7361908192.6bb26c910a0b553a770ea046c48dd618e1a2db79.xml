{"nodes":[{"pos":[12,46],"content":"Connection Points | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Connection Points | Microsoft Docs","pos":[0,34]}]},{"content":"Connection Points","pos":[921,938]},{"pos":[939,1096],"content":"This article explains how to implement connection points (formerly known as OLE connection points) using the MFC classes <ph id=\"ph1\">`CCmdTarget`</ph> and <ph id=\"ph2\">`CConnectionPoint`</ph>.","source":"This article explains how to implement connection points (formerly known as OLE connection points) using the MFC classes `CCmdTarget` and `CConnectionPoint`."},{"content":"In the past, the Component Object Model (COM) defined a general mechanism (<bpt id=\"p1\">**</bpt>IUnknown::QueryInterface<ept id=\"p1\">**</ept>) that allowed objects to implement and expose functionality in interfaces.","pos":[1103,1281],"source":"In the past, the Component Object Model (COM) defined a general mechanism (**IUnknown::QueryInterface**) that allowed objects to implement and expose functionality in interfaces."},{"content":"However, a corresponding mechanism that allowed objects to expose their capability to call specific interfaces was not defined.","pos":[1282,1409]},{"content":"That is, COM defined how incoming pointers to objects (pointers to that object's interfaces) were handled, but it did not have an explicit model for outgoing interfaces (pointers the object holds to other objects' interfaces).","pos":[1410,1636]},{"content":"COM now has a model, called connection points, that supports this functionality.","pos":[1637,1717]},{"content":"A connection has two parts: the object calling the interface, called the source, and the object implementing the interface, called the sink.","pos":[1724,1864]},{"content":"A connection point is the interface exposed by the source.","pos":[1865,1923]},{"content":"By exposing a connection point, a source allows sinks to establish connections to itself (the source).","pos":[1924,2026]},{"content":"Through the connection point mechanism (the <bpt id=\"p1\">**</bpt>IConnectionPoint<ept id=\"p1\">**</ept> interface), a pointer to the sink interface is passed to the source object.","pos":[2027,2167],"source":" Through the connection point mechanism (the **IConnectionPoint** interface), a pointer to the sink interface is passed to the source object."},{"content":"This pointer provides the source with access to the sink's implementation of a set of member functions.","pos":[2168,2271]},{"content":"For example, to fire an event implemented by the sink, the source can call the appropriate method of the sink's implementation.","pos":[2272,2399]},{"content":"The following figure demonstrates the connection point just described.","pos":[2400,2470]},{"content":"Implemented connection point","pos":[2479,2507]},{"content":"An Implemented Connection Point","pos":[2547,2578]},{"content":"MFC implements this model in the <bpt id=\"p1\">[</bpt>CConnectionPoint<ept id=\"p1\">](../mfc/reference/cconnectionpoint-class.md)</ept> and <bpt id=\"p2\">[</bpt>CCmdTarget<ept id=\"p2\">](../mfc/reference/ccmdtarget-class.md)</ept> classes.","pos":[2585,2744],"source":"MFC implements this model in the [CConnectionPoint](../mfc/reference/cconnectionpoint-class.md) and [CCmdTarget](../mfc/reference/ccmdtarget-class.md) classes."},{"content":"Classes derived from <bpt id=\"p1\">**</bpt>CConnectionPoint<ept id=\"p1\">**</ept> implement the <bpt id=\"p2\">**</bpt>IConnectionPoint<ept id=\"p2\">**</ept> interface, used to expose connection points to other objects.","pos":[2745,2883],"source":" Classes derived from **CConnectionPoint** implement the **IConnectionPoint** interface, used to expose connection points to other objects."},{"content":"Classes derived from <ph id=\"ph1\">`CCmdTarget`</ph> implement the <bpt id=\"p1\">**</bpt>IConnectionPointContainer<ept id=\"p1\">**</ept> interface, which can enumerate all of an object's available connection points or find a specific connection point.","pos":[2884,3076],"source":" Classes derived from `CCmdTarget` implement the **IConnectionPointContainer** interface, which can enumerate all of an object's available connection points or find a specific connection point."},{"content":"For each connection point implemented in your class, you must declare a connection part that implements the connection point.","pos":[3083,3208]},{"content":"If you implement one or more connection points, you must also declare a single connection map in your class.","pos":[3209,3317]},{"content":"A connection map is a table of connection points supported by the ActiveX control.","pos":[3318,3400]},{"content":"The following examples demonstrate a simple connection map and one connection point.","pos":[3407,3491]},{"content":"The first example declares the connection map and point; the second example implements the map and point.","pos":[3492,3597]},{"content":"Note that <ph id=\"ph1\">`CMyClass`</ph> must be a <ph id=\"ph2\">`CCmdTarget`</ph>-derived class.","pos":[3598,3656],"source":" Note that `CMyClass` must be a `CCmdTarget`-derived class."},{"content":"In the first example, code is inserted in the class declaration, under the <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> section:","pos":[3657,3754],"source":" In the first example, code is inserted in the class declaration, under the **protected** section:"},{"pos":[3772,3797],"content":"NVC_MFCConnectionPoints#1"},{"content":"The <ph id=\"ph1\">`BEGIN_CONNECTION_PART`</ph> and <bpt id=\"p1\">**</bpt>END_CONNECTION_PART<ept id=\"p1\">**</ept> macros declare an embedded class, <ph id=\"ph2\">`XSampleConnPt`</ph> (derived from <ph id=\"ph3\">`CConnectionPoint`</ph>), that implements this particular connection point.","pos":[3852,4042],"source":"The `BEGIN_CONNECTION_PART` and **END_CONNECTION_PART** macros declare an embedded class, `XSampleConnPt` (derived from `CConnectionPoint`), that implements this particular connection point."},{"content":"If you want to override any <ph id=\"ph1\">`CConnectionPoint`</ph> member functions or add member functions of your own, declare them between these two macros.","pos":[4043,4182],"source":" If you want to override any `CConnectionPoint` member functions or add member functions of your own, declare them between these two macros."},{"content":"For example, the <ph id=\"ph1\">`CONNECTION_IID`</ph> macro overrides the <ph id=\"ph2\">`CConnectionPoint::GetIID`</ph> member function when placed between these two macros.","pos":[4183,4317],"source":" For example, the `CONNECTION_IID` macro overrides the `CConnectionPoint::GetIID` member function when placed between these two macros."},{"content":"In the second example, code is inserted in the control's implementation file (.cpp file).","pos":[4324,4413]},{"content":"This code implements the connection map, which includes the connection point, <ph id=\"ph1\">`SampleConnPt`</ph>:","pos":[4414,4507],"source":" This code implements the connection map, which includes the connection point, `SampleConnPt`:"},{"pos":[4525,4550],"content":"NVC_MFCConnectionPoints#2"},{"pos":[4607,4767],"content":"If your class has more than one connection point, insert additional <ph id=\"ph1\">`CONNECTION_PART`</ph> macros between the <ph id=\"ph2\">`BEGIN_CONNECTION_MAP`</ph> and <ph id=\"ph3\">`END_CONNECTION_MAP`</ph> macros.","source":"If your class has more than one connection point, insert additional `CONNECTION_PART` macros between the `BEGIN_CONNECTION_MAP` and `END_CONNECTION_MAP` macros."},{"content":"Finally, add a call to <ph id=\"ph1\">`EnableConnections`</ph> in the class's constructor.","pos":[4774,4844],"source":"Finally, add a call to `EnableConnections` in the class's constructor."},{"content":"For example:","pos":[4845,4857]},{"pos":[4875,4900],"content":"NVC_MFCConnectionPoints#3"},{"content":"Once this code has been inserted, your <ph id=\"ph1\">`CCmdTarget`</ph>-derived class exposes a connection point for the <bpt id=\"p1\">**</bpt>ISampleSink<ept id=\"p1\">**</ept> interface.","pos":[4957,5084],"source":"Once this code has been inserted, your `CCmdTarget`-derived class exposes a connection point for the **ISampleSink** interface."},{"content":"The following figure illustrates this example.","pos":[5085,5131]},{"content":"Connection point implemented by using MFC","pos":[5140,5181]},{"content":"A Connection Point Implemented with MFC","pos":[5221,5260]},{"content":"Usually, connection points support \"multicasting\" — the ability to broadcast to multiple sinks connected to the same interface.","pos":[5267,5394]},{"content":"The following example fragment demonstrates how to multicast by iterating through each sink on a connection point:","pos":[5395,5509]},{"pos":[5527,5552],"content":"NVC_MFCConnectionPoints#4"},{"content":"This example retrieves the current set of connections on the <ph id=\"ph1\">`SampleConnPt`</ph> connection point with a call to <ph id=\"ph2\">`CConnectionPoint::GetConnections`</ph>.","pos":[5609,5752],"source":"This example retrieves the current set of connections on the `SampleConnPt` connection point with a call to `CConnectionPoint::GetConnections`."},{"content":"It then iterates through the connections and calls <bpt id=\"p1\">**</bpt>ISampleSink::SinkFunc<ept id=\"p1\">**</ept> on every active connection.","pos":[5753,5857],"source":" It then iterates through the connections and calls **ISampleSink::SinkFunc** on every active connection."},{"content":"See Also","pos":[5866,5874]},{"content":"MFC COM","pos":[5879,5886]}],"content":"---\ntitle: \"Connection Points | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"IConnectionPoint\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"IConnectionPoint interface\"\n  - \"connections, connection points\"\n  - \"OLE COM connection points\"\n  - \"MFC COM, connection points\"\n  - \"COM, connection points\"\n  - \"interfaces, IConnectionPoint\"\n  - \"MFC [C++], COM support\"\n  - \"connection points [C++]\"\n  - \"CCmdTarget class, and connection points\"\n  - \"sinks, connection points\"\nms.assetid: bc9fd7c7-8df6-4752-ac8c-0b177442c88d\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Connection Points\nThis article explains how to implement connection points (formerly known as OLE connection points) using the MFC classes `CCmdTarget` and `CConnectionPoint`.  \n  \n In the past, the Component Object Model (COM) defined a general mechanism (**IUnknown::QueryInterface**) that allowed objects to implement and expose functionality in interfaces. However, a corresponding mechanism that allowed objects to expose their capability to call specific interfaces was not defined. That is, COM defined how incoming pointers to objects (pointers to that object's interfaces) were handled, but it did not have an explicit model for outgoing interfaces (pointers the object holds to other objects' interfaces). COM now has a model, called connection points, that supports this functionality.  \n  \n A connection has two parts: the object calling the interface, called the source, and the object implementing the interface, called the sink. A connection point is the interface exposed by the source. By exposing a connection point, a source allows sinks to establish connections to itself (the source). Through the connection point mechanism (the **IConnectionPoint** interface), a pointer to the sink interface is passed to the source object. This pointer provides the source with access to the sink's implementation of a set of member functions. For example, to fire an event implemented by the sink, the source can call the appropriate method of the sink's implementation. The following figure demonstrates the connection point just described.  \n  \n ![Implemented connection point](../mfc/media/vc37lh1.gif \"vc37lh1\")  \nAn Implemented Connection Point  \n  \n MFC implements this model in the [CConnectionPoint](../mfc/reference/cconnectionpoint-class.md) and [CCmdTarget](../mfc/reference/ccmdtarget-class.md) classes. Classes derived from **CConnectionPoint** implement the **IConnectionPoint** interface, used to expose connection points to other objects. Classes derived from `CCmdTarget` implement the **IConnectionPointContainer** interface, which can enumerate all of an object's available connection points or find a specific connection point.  \n  \n For each connection point implemented in your class, you must declare a connection part that implements the connection point. If you implement one or more connection points, you must also declare a single connection map in your class. A connection map is a table of connection points supported by the ActiveX control.  \n  \n The following examples demonstrate a simple connection map and one connection point. The first example declares the connection map and point; the second example implements the map and point. Note that `CMyClass` must be a `CCmdTarget`-derived class. In the first example, code is inserted in the class declaration, under the **protected** section:  \n  \n [!code-cpp[NVC_MFCConnectionPoints#1](../mfc/codesnippet/cpp/connection-points_1.h)]  \n  \n The `BEGIN_CONNECTION_PART` and **END_CONNECTION_PART** macros declare an embedded class, `XSampleConnPt` (derived from `CConnectionPoint`), that implements this particular connection point. If you want to override any `CConnectionPoint` member functions or add member functions of your own, declare them between these two macros. For example, the `CONNECTION_IID` macro overrides the `CConnectionPoint::GetIID` member function when placed between these two macros.  \n  \n In the second example, code is inserted in the control's implementation file (.cpp file). This code implements the connection map, which includes the connection point, `SampleConnPt`:  \n  \n [!code-cpp[NVC_MFCConnectionPoints#2](../mfc/codesnippet/cpp/connection-points_2.cpp)]  \n  \n If your class has more than one connection point, insert additional `CONNECTION_PART` macros between the `BEGIN_CONNECTION_MAP` and `END_CONNECTION_MAP` macros.  \n  \n Finally, add a call to `EnableConnections` in the class's constructor. For example:  \n  \n [!code-cpp[NVC_MFCConnectionPoints#3](../mfc/codesnippet/cpp/connection-points_3.cpp)]  \n  \n Once this code has been inserted, your `CCmdTarget`-derived class exposes a connection point for the **ISampleSink** interface. The following figure illustrates this example.  \n  \n ![Connection point implemented by using MFC](../mfc/media/vc37lh2.gif \"vc37lh2\")  \nA Connection Point Implemented with MFC  \n  \n Usually, connection points support \"multicasting\" — the ability to broadcast to multiple sinks connected to the same interface. The following example fragment demonstrates how to multicast by iterating through each sink on a connection point:  \n  \n [!code-cpp[NVC_MFCConnectionPoints#4](../mfc/codesnippet/cpp/connection-points_4.cpp)]  \n  \n This example retrieves the current set of connections on the `SampleConnPt` connection point with a call to `CConnectionPoint::GetConnections`. It then iterates through the connections and calls **ISampleSink::SinkFunc** on every active connection.  \n  \n## See Also  \n [MFC COM](../mfc/mfc-com.md)\n\n"}