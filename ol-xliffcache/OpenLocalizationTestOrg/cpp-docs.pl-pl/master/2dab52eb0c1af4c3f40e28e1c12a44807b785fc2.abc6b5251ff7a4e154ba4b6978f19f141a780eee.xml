{"nodes":[{"pos":[12,44],"content":"memchr, wmemchr | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"memchr, wmemchr | Microsoft Docs","pos":[0,32]}]},{"pos":[923,938],"content":"memchr, wmemchr","linkify":"memchr, wmemchr","nodes":[{"content":"memchr, wmemchr","pos":[0,15]}]},{"content":"Find characters in a buffer.","pos":[939,967]},{"pos":[976,982],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1553,1563],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to buffer.","pos":[1576,1594]},{"content":"Character to look for.","pos":[1608,1630]},{"content":"Number of characters to check.","pos":[1648,1678]},{"pos":[1687,1699],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If successful, returns a pointer to the first location of <ph id=\"ph1\">`c`</ph> in <ph id=\"ph2\">`buf`</ph>.","pos":[1703,1774],"source":"If successful, returns a pointer to the first location of `c` in `buf`."},{"content":"Otherwise it returns <ph id=\"ph1\">`NULL`</ph>.","pos":[1775,1803],"source":" Otherwise it returns `NULL`."},{"pos":[1812,1819],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`memchr`</ph> and <ph id=\"ph2\">`wmemchr`</ph> look for the first occurrence of <ph id=\"ph3\">`c`</ph> in the first <ph id=\"ph4\">`count`</ph> bytes of <ph id=\"ph5\">`buf`</ph>.","pos":[1823,1919],"source":"`memchr` and `wmemchr` look for the first occurrence of `c` in the first `count` bytes of `buf`."},{"content":"It stops when it finds <ph id=\"ph1\">`c`</ph> or when it has checked the first <ph id=\"ph2\">`count`</ph> bytes.","pos":[1920,1994],"source":" It stops when it finds `c` or when it has checked the first `count` bytes."},{"content":"In C, these functions take a <ph id=\"ph1\">`const`</ph> pointer for the first argument.","pos":[2001,2069],"source":"In C, these functions take a `const` pointer for the first argument."},{"content":"In C++, two overloads are available.","pos":[2070,2106]},{"content":"The overload taking a pointer to <ph id=\"ph1\">`const`</ph> returns a pointer to <ph id=\"ph2\">`const`</ph>; the version that takes a pointer to non-<ph id=\"ph3\">`const`</ph> returns a pointer to non-<ph id=\"ph4\">`const`</ph>.","pos":[2107,2259],"source":" The overload taking a pointer to `const` returns a pointer to `const`; the version that takes a pointer to non-`const` returns a pointer to non-`const`."},{"content":"The macro _CONST_CORRECT_OVERLOADS is defined if both the <ph id=\"ph1\">`const`</ph> and non-<ph id=\"ph2\">`const`</ph> versions of these functions are available.","pos":[2260,2384],"source":" The macro _CONST_CORRECT_OVERLOADS is defined if both the `const` and non-`const` versions of these functions are available."},{"content":"If you require the non-<ph id=\"ph1\">`const`</ph> behavior for both C++ overloadsin C++, define the symbol _CONST_RETURN.","pos":[2385,2487],"source":" If you require the non-`const` behavior for both C++ overloadsin C++, define the symbol _CONST_RETURN."},{"pos":[2496,2508],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[2515,2522]},{"content":"Required header","pos":[2523,2538]},{"content":"<ph id=\"ph1\">\\&lt;</ph>memory.h&gt; or <ph id=\"ph2\">\\&lt;</ph>string.h&gt;","pos":[2592,2618],"source":"\\<memory.h> or \\<string.h>"},{"content":"<ph id=\"ph1\">\\&lt;</ph>wchar.h&gt;","pos":[2633,2643],"source":"\\<wchar.h>"},{"pos":[2651,2755],"content":"For more information about compatibility, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more information about compatibility, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"pos":[2764,2773],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[2777,2869],"content":"All versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md)."},{"pos":[2878,2885],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3722,3728],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[4026,4051],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[4055,4070]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[4071,4118],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[4119,4244],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[4253,4261],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Buffer Manipulation<ept id=\"p1\">](../../c-runtime-library/buffer-manipulation.md)</ept><ph id=\"ph1\"> </ph>","pos":[4265,4335],"source":"[Buffer Manipulation](../../c-runtime-library/buffer-manipulation.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_memccpy<ept id=\"p1\">](../../c-runtime-library/reference/memccpy.md)</ept><ph id=\"ph1\"> </ph>","pos":[4338,4396],"source":" [_memccpy](../../c-runtime-library/reference/memccpy.md) "},{"content":"<bpt id=\"p1\"> [</bpt>memcmp, wmemcmp<ept id=\"p1\">](../../c-runtime-library/reference/memcmp-wmemcmp.md)</ept><ph id=\"ph1\"> </ph>","pos":[4399,4471],"source":" [memcmp, wmemcmp](../../c-runtime-library/reference/memcmp-wmemcmp.md) "},{"content":"<bpt id=\"p1\"> [</bpt>memcpy, wmemcpy<ept id=\"p1\">](../../c-runtime-library/reference/memcpy-wmemcpy.md)</ept><ph id=\"ph1\"> </ph>","pos":[4474,4546],"source":" [memcpy, wmemcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md) "},{"content":"<bpt id=\"p1\"> [</bpt>memset, wmemset<ept id=\"p1\">](../../c-runtime-library/reference/memset-wmemset.md)</ept><ph id=\"ph1\"> </ph>","pos":[4549,4621],"source":" [memset, wmemset](../../c-runtime-library/reference/memset-wmemset.md) "},{"content":"<bpt id=\"p1\"> [</bpt>strchr, wcschr, _mbschr, _mbschr_l<ept id=\"p1\">](../../c-runtime-library/reference/strchr-wcschr-mbschr-mbschr-l.md)</ept>","pos":[4624,4729],"source":" [strchr, wcschr, _mbschr, _mbschr_l](../../c-runtime-library/reference/strchr-wcschr-mbschr-mbschr-l.md)"}],"content":"---\ntitle: \"memchr, wmemchr | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"wmemchr\"\n  - \"memchr\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"memchr\"\n  - \"wmemchr\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"memchr function\"\n  - \"wmemchr function\"\nms.assetid: 5a348581-28f1-4256-8434-687245f7fc9f\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# memchr, wmemchr\nFind characters in a buffer.  \n  \n## Syntax  \n  \n```  \nvoid *memchr(  \n   const void *buf,  \n   int c,  \n   size_t count  \n); // C only  \nvoid *memchr(  \n   void *buf,  \n   int c,  \n   size_t count  \n); // C++ only  \nconst void *memchr(  \n   const void *buf,  \n   int c,  \n   size_t count  \n); // C++ only  \nwchar_t *wmemchr(  \n   const wchar_t * buf,   \n   wchar_t c,  \n   size_t count  \n); // C only  \nwchar_t *wmemchr(  \n   wchar_t * buf,   \n   wchar_t c,  \n   size_t count  \n); // C++ only  \nconst wchar_t *wmemchr(  \n   const wchar_t * buf,   \n   wchar_t c,  \n   size_t count  \n); // C++ only  \n```  \n  \n#### Parameters  \n `buf`  \n Pointer to buffer.  \n  \n `c`  \n Character to look for.  \n  \n `count`  \n Number of characters to check.  \n  \n## Return Value  \n If successful, returns a pointer to the first location of `c` in `buf`. Otherwise it returns `NULL`.  \n  \n## Remarks  \n `memchr` and `wmemchr` look for the first occurrence of `c` in the first `count` bytes of `buf`. It stops when it finds `c` or when it has checked the first `count` bytes.  \n  \n In C, these functions take a `const` pointer for the first argument. In C++, two overloads are available. The overload taking a pointer to `const` returns a pointer to `const`; the version that takes a pointer to non-`const` returns a pointer to non-`const`. The macro _CONST_CORRECT_OVERLOADS is defined if both the `const` and non-`const` versions of these functions are available. If you require the non-`const` behavior for both C++ overloadsin C++, define the symbol _CONST_RETURN.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`memchr`|\\<memory.h> or \\<string.h>|  \n|`wmemchr`|\\<wchar.h>|  \n  \n For more information about compatibility, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Libraries  \n All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md).  \n  \n## Example  \n  \n```  \n// crt_memchr.c  \n  \n#include <memory.h>  \n#include <stdio.h>  \n  \nint  ch = 'r';  \nchar str[] =    \"lazy\";  \nchar string[] = \"The quick brown dog jumps over the lazy fox\";  \nchar fmt1[] =   \"         1         2         3         4         5\";  \nchar fmt2[] =   \"12345678901234567890123456789012345678901234567890\";  \n  \nint main( void )  \n{  \n   char *pdest;  \n   int result;  \n   printf( \"String to be searched:\\n             %s\\n\", string );  \n   printf( \"             %s\\n             %s\\n\\n\", fmt1, fmt2 );  \n  \n   printf( \"Search char: %c\\n\", ch );  \n   pdest = memchr( string, ch, sizeof( string ) );  \n   result = (int)(pdest - string + 1);  \n   if ( pdest != NULL )  \n      printf( \"Result:      %c found at position %d\\n\", ch, result );  \n   else  \n      printf( \"Result:      %c not found\\n\" );  \n}  \n```  \n  \n## Output  \n  \n```  \nString to be searched:  \n             The quick brown dog jumps over the lazy fox  \n                      1         2         3         4         5  \n             12345678901234567890123456789012345678901234567890  \n  \nSearch char: r  \nResult:      r found at position 12  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Buffer Manipulation](../../c-runtime-library/buffer-manipulation.md)   \n [_memccpy](../../c-runtime-library/reference/memccpy.md)   \n [memcmp, wmemcmp](../../c-runtime-library/reference/memcmp-wmemcmp.md)   \n [memcpy, wmemcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md)   \n [memset, wmemset](../../c-runtime-library/reference/memset-wmemset.md)   \n [strchr, wcschr, _mbschr, _mbschr_l](../../c-runtime-library/reference/strchr-wcschr-mbschr-mbschr-l.md)"}