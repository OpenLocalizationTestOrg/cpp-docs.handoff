{"nodes":[{"pos":[12,64],"content":"_mm_extract_si64, _mm_extracti_si64 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_mm_extract_si64, _mm_extracti_si64 | Microsoft Docs","pos":[0,52]}]},{"content":"_mm_extract_si64, _mm_extracti_si64","pos":[745,780]},{"content":"Microsoft Specific","pos":[783,801]},{"pos":[810,913],"content":"Generates the <ph id=\"ph1\">`extrq`</ph> instruction to extract specified bits from the low 64 bits of its first argument.","source":"Generates the `extrq` instruction to extract specified bits from the low 64 bits of its first argument."},{"content":"Syntax","pos":[922,928]},{"content":"Parameters","pos":[1119,1129]},{"content":"[in]","pos":[1133,1137]},{"content":"A 128-bit field with input data in its lower 64 bits.","pos":[1150,1203]},{"content":"[in]","pos":[1210,1214]},{"content":"A 128-bit field that describes the bit field to extract.","pos":[1232,1288]},{"content":"[in]","pos":[1295,1299]},{"content":"An integer that specifies the length of the field to extract.","pos":[1313,1374]},{"content":"[in]","pos":[1381,1385]},{"content":"An integer that specifies the index of the field to extract","pos":[1398,1457]},{"content":"Return Value","pos":[1466,1478]},{"content":"A 128-bit field with the extracted field in its least significant bits.","pos":[1482,1553]},{"content":"Requirements","pos":[1562,1574]},{"content":"Intrinsic","pos":[1581,1590]},{"content":"Architecture","pos":[1591,1603]},{"content":"SSE4a","pos":[1666,1671]},{"content":"SSE4a","pos":[1696,1701]},{"pos":[1709,1736],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1745,1752]},{"content":"This intrinsic generates the <ph id=\"ph1\">`extrq`</ph> instruction to extract bits from <ph id=\"ph2\">`Source`</ph>.There are two versions of this intrinsic: <ph id=\"ph3\">`_mm_extracti_si64`</ph> is the immediate version, and <ph id=\"ph4\">`_mm_extract_si64`</ph> is the non-immediate one.","pos":[1756,1971],"source":"This intrinsic generates the `extrq` instruction to extract bits from `Source`.There are two versions of this intrinsic: `_mm_extracti_si64` is the immediate version, and `_mm_extract_si64` is the non-immediate one."},{"content":"Each version extracts from <ph id=\"ph1\">`Source`</ph> a bit field defined by its length and the index of its least significant bit.","pos":[1973,2086],"source":"  Each version extracts from `Source` a bit field defined by its length and the index of its least significant bit."},{"content":"The values of the length and index are taken mod 64, thus both -1 and 127 are interpreted as 63.","pos":[2087,2183]},{"content":"If the sum of the (reduced) index and (reduced) field length is greater than 64, the results are undefined.","pos":[2184,2291]},{"content":"A value of zero for field length is interpreted as 64.","pos":[2292,2346]},{"content":"If the field length and bit index are both zero, bits 63:0 of <ph id=\"ph1\">`Source`</ph> are extracted.","pos":[2347,2432],"source":" If the field length and bit index are both zero, bits 63:0 of `Source` are extracted."},{"content":"If the field length is zero but the bit index is non-zero, the results are undefined.","pos":[2433,2518]},{"pos":[2525,2667],"content":"In a call to _mm_extract_si64, the <ph id=\"ph1\">`Descriptor`</ph> contains the index in bits 13:8 and the field length of the data to be extracted in bits 5:0..","source":"In a call to _mm_extract_si64, the `Descriptor` contains the index in bits 13:8 and the field length of the data to be extracted in bits 5:0.."},{"pos":[2674,2896],"content":"If you call <ph id=\"ph1\">`_mm_extracti_si64`</ph> with arguments that the compiler cannot determine to be integer constants the compiler generates code to pack those values into an XMM register (<ph id=\"ph2\">`Descriptor`</ph>) and to call <ph id=\"ph3\">`_mm_extract_si64`</ph>.","source":"If you call `_mm_extracti_si64` with arguments that the compiler cannot determine to be integer constants the compiler generates code to pack those values into an XMM register (`Descriptor`) and to call `_mm_extract_si64`."},{"content":"To determine hardware support for the <ph id=\"ph1\">`extrq`</ph> instruction, call the <ph id=\"ph2\">`__cpuid`</ph> intrinsic with <ph id=\"ph3\">`InfoType=0x80000001`</ph> and check bit 6 of <ph id=\"ph4\">`CPUInfo[2] (ECX)`</ph>.","pos":[2903,3056],"source":"To determine hardware support for the `extrq` instruction, call the `__cpuid` intrinsic with `InfoType=0x80000001` and check bit 6 of `CPUInfo[2] (ECX)`."},{"content":"This bit will be 1 if the instruction is supported, and 0 otherwise.","pos":[3057,3125]},{"content":"If you run code that uses this intrinsic hardware that does not support the <ph id=\"ph1\">`extrq`</ph> instruction, the results are unpredictable.","pos":[3126,3253],"source":" If you run code that uses this intrinsic hardware that does not support the `extrq` instruction, the results are unpredictable."},{"content":"Example","pos":[3262,3269]},{"content":"END Microsoft Specific","pos":[4081,4103]},{"content":"Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved.","pos":[4107,4174]},{"content":"Reproduced with permission from Advanced Micro Devices, Inc.","pos":[4175,4235]},{"content":"See Also","pos":[4244,4252]},{"content":"_mm_insert_si64, _mm_inserti_si64","pos":[4257,4290]},{"content":"Compiler Intrinsics","pos":[4346,4365]}],"content":"---\ntitle: \"_mm_extract_si64, _mm_extracti_si64 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_mm_extracti_si64\"\n  - \"_mm_extract_si64\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"extrq instruction\"\n  - \"_mm_extracti_si64 intrinsic\"\n  - \"_mm_extract_si64 intrinsic\"\nms.assetid: 459fdd72-cc54-4ee5-bbd5-d2c6067a88e7\ncaps.latest.revision: 13\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# _mm_extract_si64, _mm_extracti_si64\n**Microsoft Specific**  \n  \n Generates the `extrq` instruction to extract specified bits from the low 64 bits of its first argument.  \n  \n## Syntax  \n  \n```  \n__m128i _mm_extract_si64(  \n   __m128i Source,  \n   __m128i Descriptor  \n);  \n__m128i _mm_extracti_si64(  \n   __m128i Source,  \n   int Length,  \n   int Index  \n);  \n```  \n  \n#### Parameters  \n [in] `Source`  \n A 128-bit field with input data in its lower 64 bits.  \n  \n [in]  `Descriptor`  \n A 128-bit field that describes the bit field to extract.  \n  \n [in]  `Length`  \n An integer that specifies the length of the field to extract.  \n  \n [in]  `Index`  \n An integer that specifies the index of the field to extract  \n  \n## Return Value  \n A 128-bit field with the extracted field in its least significant bits.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`_mm_extract_si64`|SSE4a|  \n|`_mm_extracti_si64`|SSE4a|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n This intrinsic generates the `extrq` instruction to extract bits from `Source`.There are two versions of this intrinsic: `_mm_extracti_si64` is the immediate version, and `_mm_extract_si64` is the non-immediate one.  Each version extracts from `Source` a bit field defined by its length and the index of its least significant bit. The values of the length and index are taken mod 64, thus both -1 and 127 are interpreted as 63. If the sum of the (reduced) index and (reduced) field length is greater than 64, the results are undefined. A value of zero for field length is interpreted as 64. If the field length and bit index are both zero, bits 63:0 of `Source` are extracted. If the field length is zero but the bit index is non-zero, the results are undefined.  \n  \n In a call to _mm_extract_si64, the `Descriptor` contains the index in bits 13:8 and the field length of the data to be extracted in bits 5:0..  \n  \n If you call `_mm_extracti_si64` with arguments that the compiler cannot determine to be integer constants the compiler generates code to pack those values into an XMM register (`Descriptor`) and to call `_mm_extract_si64`.  \n  \n To determine hardware support for the `extrq` instruction, call the `__cpuid` intrinsic with `InfoType=0x80000001` and check bit 6 of `CPUInfo[2] (ECX)`. This bit will be 1 if the instruction is supported, and 0 otherwise. If you run code that uses this intrinsic hardware that does not support the `extrq` instruction, the results are unpredictable.  \n  \n## Example  \n  \n```  \n// Compile this sample with: /EHsc  \n#include <iostream>  \n#include <intrin.h>  \nusing namespace std;  \n  \nunion {  \n    __m128i m;  \n    unsigned __int64 ui64[2];  \n} source, descriptor, result1, result2, result3;  \n  \nint  \nmain()  \n{  \n    source.ui64[0] =     0xfedcba9876543210ll;  \n    descriptor.ui64[0] = 0x0000000000000b1bll;  \n  \n    result1.m = _mm_extract_si64 (source.m, descriptor.m);  \n    result2.m = _mm_extracti_si64(source.m, 27, 11);  \n    result3.ui64[0] = (source.ui64[0] >> 11) & 0x7ffffff;  \n  \n    cout << hex << \"result1 = 0x\" << result1.ui64[0] << endl;  \n    cout << \"result2 = 0x\" << result2.ui64[0] << endl;  \n    cout << \"result3 = 0x\" << result3.ui64[0] << endl;  \n}  \n```  \n  \n```Output  \nresult1 = 0x30eca86  \nresult2 = 0x30eca86  \nresult3 = 0x30eca86  \n```  \n  \n## END Microsoft Specific  \n Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved. Reproduced with permission from Advanced Micro Devices, Inc.  \n  \n## See Also  \n [_mm_insert_si64, _mm_inserti_si64](../intrinsics/mm-insert-si64-mm-inserti-si64.md)   \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}