{"nodes":[{"pos":[12,44],"content":"Type Qualifiers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Type Qualifiers | Microsoft Docs","pos":[0,32]}]},{"content":"Type Qualifiers","pos":[776,791]},{"content":"Type qualifiers give one of two properties to an identifier.","pos":[792,852]},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> type qualifier declares an object to be nonmodifiable.","pos":[853,921],"source":" The **const** type qualifier declares an object to be nonmodifiable."},{"content":"The <ph id=\"ph1\">`volatile`</ph> type qualifier declares an item whose value can legitimately be changed by something beyond the control of the program in which it appears, such as a concurrently executing thread.","pos":[922,1117],"source":" The `volatile` type qualifier declares an item whose value can legitimately be changed by something beyond the control of the program in which it appears, such as a concurrently executing thread."},{"content":"The two type qualifiers, <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph>, can appear only once in a declaration.","pos":[1124,1213],"source":"The two type qualifiers, **const** and `volatile`, can appear only once in a declaration."},{"content":"Type qualifiers can appear with any type specifier; however, they cannot appear after the first comma in a multiple item declaration.","pos":[1214,1347]},{"content":"For example, the following declarations are legal:","pos":[1348,1398]},{"content":"These declarations are not legal:","pos":[1463,1496]},{"content":"Type qualifiers are relevant only when accessing identifiers as l-values in expressions.","pos":[1574,1662]},{"content":"See <bpt id=\"p1\">[</bpt>L-Value and R-Value Expressions<ept id=\"p1\">](../c-language/l-value-and-r-value-expressions.md)</ept> for information about l-values and expressions.","pos":[1663,1798],"source":" See [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md) for information about l-values and expressions."},{"content":"Syntax","pos":[1807,1813]},{"content":"<bpt id=\"p1\">*</bpt>type-qualifier<ept id=\"p1\">*</ept>:","pos":[1817,1834],"source":"*type-qualifier*:"},{"content":"constvolatile","pos":[1840,1853]},{"pos":[1862,1924],"content":"The following are legal <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph> declarations:","source":"The following are legal **const** and `volatile` declarations:"},{"content":"If the specification of an array type includes type qualifiers, the element is qualified, not the array type.","pos":[2221,2330]},{"content":"If the specification of the function type includes qualifiers, the behavior is undefined.","pos":[2331,2420]},{"content":"Neither <ph id=\"ph1\">`volatile`</ph> nor <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> affects the range of values or arithmetic properties of the object.","pos":[2421,2521],"source":" Neither `volatile` nor **const** affects the range of values or arithmetic properties of the object."},{"pos":[2528,2584],"content":"This list describes how to use <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph>.","source":"This list describes how to use **const** and `volatile`."},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> keyword can be used to modify any fundamental or aggregate type, or a pointer to an object of any type, or a <ph id=\"ph1\">`typedef`</ph>.","pos":[2594,2727],"source":"The **const** keyword can be used to modify any fundamental or aggregate type, or a pointer to an object of any type, or a `typedef`."},{"content":"If an item is declared with only the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> type qualifier, its type is taken to be <bpt id=\"p2\">**</bpt>const int<ept id=\"p2\">**</ept>.","pos":[2728,2829],"source":" If an item is declared with only the **const** type qualifier, its type is taken to be **const int**."},{"content":"A <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> variable can be initialized or can be placed in a read-only region of storage.","pos":[2830,2920],"source":" A **const** variable can be initialized or can be placed in a read-only region of storage."},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> keyword is useful for declaring pointers to <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> since this requires the function not to change the pointer in any way.","pos":[2921,3059],"source":" The **const** keyword is useful for declaring pointers to **const** since this requires the function not to change the pointer in any way."},{"content":"The compiler assumes that, at any point in the program, a <ph id=\"ph1\">`volatile`</ph> variable can be accessed by an unknown process that uses or modifies its value.","pos":[3069,3217],"source":"The compiler assumes that, at any point in the program, a `volatile` variable can be accessed by an unknown process that uses or modifies its value."},{"content":"Therefore, regardless of the optimizations specified on the command line, the code for each assignment to or reference of a <ph id=\"ph1\">`volatile`</ph> variable must be generated even if it appears to have no effect.","pos":[3218,3417],"source":" Therefore, regardless of the optimizations specified on the command line, the code for each assignment to or reference of a `volatile` variable must be generated even if it appears to have no effect."},{"content":"If <ph id=\"ph1\">`volatile`</ph> is used alone, <ph id=\"ph2\">`int`</ph> is assumed.","pos":[3428,3474],"source":"If `volatile` is used alone, `int` is assumed."},{"content":"The <ph id=\"ph1\">`volatile`</ph> type specifier can be used to provide reliable access to special memory locations.","pos":[3475,3572],"source":" The `volatile` type specifier can be used to provide reliable access to special memory locations."},{"content":"Use <ph id=\"ph1\">`volatile`</ph> with data objects that may be accessed or altered by signal handlers, by concurrently executing programs, or by special hardware such as memory-mapped I/O control registers.","pos":[3573,3761],"source":" Use `volatile` with data objects that may be accessed or altered by signal handlers, by concurrently executing programs, or by special hardware such as memory-mapped I/O control registers."},{"content":"You can declare a variable as <ph id=\"ph1\">`volatile`</ph> for its lifetime, or you can cast a single reference to be <ph id=\"ph2\">`volatile`</ph>.","pos":[3762,3873],"source":" You can declare a variable as `volatile` for its lifetime, or you can cast a single reference to be `volatile`."},{"pos":[3883,4058],"content":"An item can be both <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph>, in which case the item could not be legitimately modified by its own program, but could be modified by some asynchronous process.","source":"An item can be both **const** and `volatile`, in which case the item could not be legitimately modified by its own program, but could be modified by some asynchronous process."},{"content":"See Also","pos":[4067,4075]},{"content":"Declarations and Types","pos":[4080,4102]}],"content":"---\ntitle: \"Type Qualifiers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"volatile keyword [C], type qualifier\"\n  - \"type qualifiers\"\n  - \"volatile keyword [C]\"\n  - \"qualifiers for types\"\n  - \"const keyword [C]\"\n  - \"memory, access using volatile\"\n  - \"volatile keyword [C], type specifier\"\nms.assetid: bb4c6744-1dd7-40a8-b4eb-f5585be30908\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Type Qualifiers\nType qualifiers give one of two properties to an identifier. The **const** type qualifier declares an object to be nonmodifiable. The `volatile` type qualifier declares an item whose value can legitimately be changed by something beyond the control of the program in which it appears, such as a concurrently executing thread.  \n  \n The two type qualifiers, **const** and `volatile`, can appear only once in a declaration. Type qualifiers can appear with any type specifier; however, they cannot appear after the first comma in a multiple item declaration. For example, the following declarations are legal:  \n  \n```  \ntypedef volatile int VI;  \nconst int ci;  \n```  \n  \n These declarations are not legal:  \n  \n```  \ntypedef int *i, volatile *vi;  \nfloat f, const cf;     \n```  \n  \n Type qualifiers are relevant only when accessing identifiers as l-values in expressions. See [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md) for information about l-values and expressions.  \n  \n## Syntax  \n *type-qualifier*:  \n **constvolatile**  \n  \n The following are legal **const** and `volatile` declarations:  \n  \n```  \nint const *p_ci;       /* Pointer to constant int */  \nint const (*p_ci);     /* Pointer to constant int */  \nint *const cp_i;       /* Constant pointer to int */  \nint (*const cp_i);     /* Constant pointer to int */  \nint volatile vint;     /* Volatile integer        */  \n```  \n  \n If the specification of an array type includes type qualifiers, the element is qualified, not the array type. If the specification of the function type includes qualifiers, the behavior is undefined. Neither `volatile` nor **const** affects the range of values or arithmetic properties of the object.  \n  \n This list describes how to use **const** and `volatile`.  \n  \n-   The **const** keyword can be used to modify any fundamental or aggregate type, or a pointer to an object of any type, or a `typedef`. If an item is declared with only the **const** type qualifier, its type is taken to be **const int**. A **const** variable can be initialized or can be placed in a read-only region of storage. The **const** keyword is useful for declaring pointers to **const** since this requires the function not to change the pointer in any way.  \n  \n-   The compiler assumes that, at any point in the program, a `volatile` variable can be accessed by an unknown process that uses or modifies its value. Therefore, regardless of the optimizations specified on the command line, the code for each assignment to or reference of a `volatile` variable must be generated even if it appears to have no effect.  \n  \n     If `volatile` is used alone, `int` is assumed. The `volatile` type specifier can be used to provide reliable access to special memory locations. Use `volatile` with data objects that may be accessed or altered by signal handlers, by concurrently executing programs, or by special hardware such as memory-mapped I/O control registers. You can declare a variable as `volatile` for its lifetime, or you can cast a single reference to be `volatile`.  \n  \n-   An item can be both **const** and `volatile`, in which case the item could not be legitimately modified by its own program, but could be modified by some asynchronous process.  \n  \n## See Also  \n [Declarations and Types](../c-language/declarations-and-types.md)"}