{"nodes":[{"pos":[12,33],"content":"once | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"once | Microsoft Docs","pos":[0,21]}]},{"content":"once","pos":[631,635]},{"content":"Specifies that the file will be included (opened) only once by the compiler when compiling a source code file.","pos":[636,746]},{"content":"Syntax","pos":[755,761]},{"content":"Remarks","pos":[806,813]},{"content":"The use of <ph id=\"ph1\">`#pragma once`</ph> can reduce build times as the compiler will not open and read the file after the first #include of the file in the translation unit.","pos":[817,975],"source":"The use of `#pragma once` can reduce build times as the compiler will not open and read the file after the first #include of the file in the translation unit."},{"content":"This is referred to as <bpt id=\"p1\">*</bpt>multiple-include optimization<ept id=\"p1\">*</ept>.","pos":[976,1031],"source":" This is referred to as *multiple-include optimization*."},{"content":"It has an effect similar to the <bpt id=\"p1\">*</bpt>#include guard<ept id=\"p1\">*</ept> idiom, which uses preprocessor macro definitions to prevent multiple inclusion of the contents of the file.","pos":[1032,1188],"source":" It has an effect similar to the *#include guard* idiom, which uses preprocessor macro definitions to prevent multiple inclusion of the contents of the file."},{"content":"This also helps to prevent violations of the <bpt id=\"p1\">*</bpt>one definition rule<ept id=\"p1\">*</ept>—the requirement that all templates, types, functions, and objects have no more than one definition in your code.","pos":[1189,1368],"source":" This also helps to prevent violations of the *one definition rule*—the requirement that all templates, types, functions, and objects have no more than one definition in your code."},{"content":"For example:","pos":[1375,1387]},{"content":"We recommend the <ph id=\"ph1\">`#pragma once`</ph> directive for new code because it doesn't pollute the global namespace with a preprocessor symbol.","pos":[1506,1636],"source":"We recommend the `#pragma once` directive for new code because it doesn't pollute the global namespace with a preprocessor symbol."},{"content":"It requires less typing, is less distracting, and can't cause symbol collisions—errors caused when different header files use the same preprocessor symbol as the guard value.","pos":[1637,1811]},{"content":"It is not part of the C++ Standard, but it is implemented portably by several common compilers.","pos":[1812,1907]},{"content":"There is no advantage to use of both the #include guard idiom and <ph id=\"ph1\">`#pragma once`</ph> in the same file.","pos":[1914,2012],"source":"There is no advantage to use of both the #include guard idiom and `#pragma once` in the same file."},{"content":"The compiler recognizes the #include guard idiom and implements the multiple include optimization the same way as the <ph id=\"ph1\">`#pragma once`</ph> directive if no non-comment code or preprocessor directive comes before or after the standard form of the idiom:","pos":[2013,2258],"source":" The compiler recognizes the #include guard idiom and implements the multiple include optimization the same way as the `#pragma once` directive if no non-comment code or preprocessor directive comes before or after the standard form of the idiom:"},{"content":"We recommend the #include guard idiom when code must be portable to compilers that do not implement the <ph id=\"ph1\">`#pragma once`</ph> directive, to maintain consistency with existing code, or when the multiple-include optimization is impossible.","pos":[2568,2798],"source":"We recommend the #include guard idiom when code must be portable to compilers that do not implement the `#pragma once` directive, to maintain consistency with existing code, or when the multiple-include optimization is impossible."},{"content":"This can occur in complex projects when file system aliasing or aliased include paths prevent the compiler from identifying identical include files by canonical path.","pos":[2799,2965]},{"content":"Be careful not to use <ph id=\"ph1\">`#pragma once`</ph> or the #include guard idiom in header files that are designed to be included multiple times, using preprocessor symbols to control their effects.","pos":[2972,3154],"source":"Be careful not to use `#pragma once` or the #include guard idiom in header files that are designed to be included multiple times, using preprocessor symbols to control their effects."},{"content":"For an example of this design, see the <ph id=\"ph1\">\\&lt;</ph>assert.h&gt; header file.","pos":[3155,3218],"source":" For an example of this design, see the \\<assert.h> header file."},{"content":"Also be careful to manage include paths to avoid creating multiple paths to included files, which can defeat the multiple-include optimization for both #include guards and <ph id=\"ph1\">`#pragma once`</ph>.","pos":[3219,3406],"source":" Also be careful to manage include paths to avoid creating multiple paths to included files, which can defeat the multiple-include optimization for both #include guards and `#pragma once`."},{"content":"See Also","pos":[3415,3423]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[3428,3470]}],"content":"---\ntitle: \"once | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-pragma.once\"\n  - \"once_CPP\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"once pragma\"\n  - \"pragmas, once\"\nms.assetid: c7517556-6403-4b16-8898-f2aa0a6f685f\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# once\nSpecifies that the file will be included (opened) only once by the compiler when compiling a source code file.  \n  \n## Syntax  \n  \n```  \n  \n#pragma once  \n  \n```  \n  \n## Remarks  \n The use of `#pragma once` can reduce build times as the compiler will not open and read the file after the first #include of the file in the translation unit. This is referred to as *multiple-include optimization*. It has an effect similar to the *#include guard* idiom, which uses preprocessor macro definitions to prevent multiple inclusion of the contents of the file. This also helps to prevent violations of the *one definition rule*—the requirement that all templates, types, functions, and objects have no more than one definition in your code.  \n  \n For example:  \n  \n```  \n// header.h  \n#pragma once  \n// Code placed here is included only once per translation unit  \n  \n```  \n  \n We recommend the `#pragma once` directive for new code because it doesn't pollute the global namespace with a preprocessor symbol. It requires less typing, is less distracting, and can't cause symbol collisions—errors caused when different header files use the same preprocessor symbol as the guard value. It is not part of the C++ Standard, but it is implemented portably by several common compilers.  \n  \n There is no advantage to use of both the #include guard idiom and `#pragma once` in the same file. The compiler recognizes the #include guard idiom and implements the multiple include optimization the same way as the `#pragma once` directive if no non-comment code or preprocessor directive comes before or after the standard form of the idiom:  \n  \n```  \n// header.h  \n// Demonstration of the #include guard idiom.  \n// Note that the defined symbol can be arbitrary.  \n#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_  \n#define HEADER_H_  \n// Code placed here is included only once per translation unit  \n#endif // HEADER_H_  \n  \n```  \n  \n We recommend the #include guard idiom when code must be portable to compilers that do not implement the `#pragma once` directive, to maintain consistency with existing code, or when the multiple-include optimization is impossible. This can occur in complex projects when file system aliasing or aliased include paths prevent the compiler from identifying identical include files by canonical path.  \n  \n Be careful not to use `#pragma once` or the #include guard idiom in header files that are designed to be included multiple times, using preprocessor symbols to control their effects. For an example of this design, see the \\<assert.h> header file. Also be careful to manage include paths to avoid creating multiple paths to included files, which can defeat the multiple-include optimization for both #include guards and `#pragma once`.  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}