{"nodes":[{"pos":[12,61],"content":"Logical AND Operator: &amp;&amp; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Logical AND Operator: <ph id=\"ph1\">&amp;amp;&amp;amp;</ph> | Microsoft Docs","pos":[0,49],"source":"Logical AND Operator: &amp;&amp; | Microsoft Docs"}]},{"content":"Logical AND Operator:","pos":[661,682]},{"content":"Syntax","pos":[697,703]},{"content":"Remarks","pos":[766,773]},{"content":"The logical AND operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p1\">**</ept>) returns the boolean value <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if both operands are <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept> and returns <bpt id=\"p4\">**</bpt>false<ept id=\"p4\">**</ept> otherwise.","pos":[777,908],"source":"The logical AND operator (**&&**) returns the boolean value **true** if both operands are **true** and returns **false** otherwise."},{"content":"The operands are implicitly converted to type <ph id=\"ph1\">`bool`</ph> prior to evaluation, and the result is of type <ph id=\"ph2\">`bool`</ph>.","pos":[909,1016],"source":" The operands are implicitly converted to type `bool` prior to evaluation, and the result is of type `bool`."},{"content":"Logical AND has left-to-right associativity.","pos":[1017,1061]},{"content":"The operands to the logical AND operator need not be of the same type, but they must be of integral or pointer type.","pos":[1068,1184]},{"content":"The operands are commonly relational or equality expressions.","pos":[1185,1246]},{"content":"The first operand is completely evaluated and all side effects are completed before continuing evaluation of the logical AND expression.","pos":[1253,1389]},{"content":"The second operand is evaluated only if the first operand evaluates to true (nonzero).","pos":[1396,1482]},{"content":"This evaluation eliminates needless evaluation of the second operand when the logical AND expression is false.","pos":[1483,1593]},{"content":"You can use this short-circuit evaluation to prevent null-pointer dereferencing, as shown in the following example:","pos":[1594,1709]},{"content":"If <ph id=\"ph1\">`pch`</ph> is null (0), the right side of the expression is never evaluated.","pos":[1779,1853],"source":"If `pch` is null (0), the right side of the expression is never evaluated."},{"content":"Therefore, the assignment through a null pointer is impossible.","pos":[1854,1917]},{"content":"Operator Keyword for &amp;&amp;","pos":[1926,1949],"source":"Operator Keyword for &&"},{"content":"The <bpt id=\"p1\">**</bpt>and<ept id=\"p1\">**</ept> operator is the text equivalent of <bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p2\">**</ept>.","pos":[1953,2007],"source":"The **and** operator is the text equivalent of **&&**."},{"content":"There are two ways to access the <bpt id=\"p1\">**</bpt>and<ept id=\"p1\">**</ept> operator in your programs: include the header file <ph id=\"ph1\">`iso646.h`</ph>, or compile with the <bpt id=\"p2\">[</bpt>/Za<ept id=\"p2\">](../build/reference/za-ze-disable-language-extensions.md)</ept> (Disable language extensions) compiler option.","pos":[2008,2241],"source":" There are two ways to access the **and** operator in your programs: include the header file `iso646.h`, or compile with the [/Za](../build/reference/za-ze-disable-language-extensions.md) (Disable language extensions) compiler option."},{"content":"Example","pos":[2250,2257]},{"content":"See Also","pos":[2729,2737]},{"content":"<bpt id=\"p1\">[</bpt>C++ Built-in Operators Precedence and Associativity<ept id=\"p1\">](cpp-built-in-operators-precedence-and-associativity.md)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\"> [</bpt>C++ Built-in Operators, Precedence and Associativity<ept id=\"p2\">](../cpp/cpp-built-in-operators-precedence-and-associativity.md)</ept>","pos":[2741,2969],"source":"[C++ Built-in Operators Precedence and Associativity](cpp-built-in-operators-precedence-and-associativity.md)\n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)"},{"content":"C Logical Operators","pos":[2975,2994]}],"content":"---\ntitle: \"Logical AND Operator: &amp;&amp; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"&&\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"logical AND operator\"\n  - \"AND operator\"\n  - \"&& operator\"\nms.assetid: 50cfa664-a8c4-4b31-9bab-2f80d7cd2d1f\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Logical AND Operator: &amp;&amp;\n## Syntax  \n  \n```  \n  \nexpression   \n&&  \n expression  \n  \n```  \n  \n## Remarks  \n The logical AND operator (**&&**) returns the boolean value **true** if both operands are **true** and returns **false** otherwise. The operands are implicitly converted to type `bool` prior to evaluation, and the result is of type `bool`. Logical AND has left-to-right associativity.  \n  \n The operands to the logical AND operator need not be of the same type, but they must be of integral or pointer type. The operands are commonly relational or equality expressions.  \n  \n The first operand is completely evaluated and all side effects are completed before continuing evaluation of the logical AND expression.  \n  \n The second operand is evaluated only if the first operand evaluates to true (nonzero). This evaluation eliminates needless evaluation of the second operand when the logical AND expression is false. You can use this short-circuit evaluation to prevent null-pointer dereferencing, as shown in the following example:  \n  \n```  \nchar *pch = 0;  \n...  \n(pch) && (*pch = 'a');  \n```  \n  \n If `pch` is null (0), the right side of the expression is never evaluated. Therefore, the assignment through a null pointer is impossible.  \n  \n## Operator Keyword for &&  \n The **and** operator is the text equivalent of **&&**. There are two ways to access the **and** operator in your programs: include the header file `iso646.h`, or compile with the [/Za](../build/reference/za-ze-disable-language-extensions.md) (Disable language extensions) compiler option.  \n  \n## Example  \n  \n```  \n// expre_Logical_AND_Operator.cpp  \n// compile with: /EHsc  \n// Demonstrate logical AND  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main() {  \n   int a = 5, b = 10, c = 15;  \n   cout  << boolalpha  \n         << \"The true expression \"  \n         << \"a < b && b < c yields \"  \n         << (a < b && b < c) << endl  \n         << \"The false expression \"  \n         << \"a > b && b < c yields \"  \n         << (a > b && b < c) << endl;  \n}  \n```  \n  \n## See Also  \n [C++ Built-in Operators Precedence and Associativity](cpp-built-in-operators-precedence-and-associativity.md)\n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [C Logical Operators](../c-language/c-logical-operators.md)"}