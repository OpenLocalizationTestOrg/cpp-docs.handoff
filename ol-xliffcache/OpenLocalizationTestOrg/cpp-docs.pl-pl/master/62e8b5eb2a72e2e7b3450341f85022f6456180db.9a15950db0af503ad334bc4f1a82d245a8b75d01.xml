{"nodes":[{"pos":[12,106],"content":"How to: Implement a Plug-In Component Architecture using Reflection (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Implement a Plug-In Component Architecture using Reflection (C++-CLI) | Microsoft Docs","pos":[0,94]}]},{"content":"How to: Implement a Plug-In Component Architecture using Reflection (C++/CLI)","pos":[663,740]},{"content":"The following code examples demonstrate the use of reflection to implement a simple \"plug-in\" architecture.","pos":[741,848]},{"content":"The first listing is the application, and the second is the plug-in.","pos":[849,917]},{"content":"The application is a multiple document form that populates itself using any form-based classes found in the plug-in DLL provided as a command-line argument.","pos":[918,1074]},{"content":"The application attempts to load the provided assembly using the &lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName&gt; method.","pos":[1081,1220],"source":"The application attempts to load the provided assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> method."},{"content":"If successful, the types inside the assembly are enumerated using the &lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName&gt; method.","pos":[1221,1369],"source":" If successful, the types inside the assembly are enumerated using the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName> method."},{"content":"Each type is then checked for compatibility using the &lt;xref:System.Type.IsAssignableFrom%2A?displayProperty=fullName&gt; method.","pos":[1370,1495],"source":" Each type is then checked for compatibility using the <xref:System.Type.IsAssignableFrom%2A?displayProperty=fullName> method."},{"content":"In this example, classes found in the provided assembly must be derived from the &lt;xref:System.Windows.Forms.Form&gt; class to qualify as a plug-in.","pos":[1496,1640],"source":" In this example, classes found in the provided assembly must be derived from the <xref:System.Windows.Forms.Form> class to qualify as a plug-in."},{"content":"Compatible classes are then instantiated with the &lt;xref:System.Activator.CreateInstance%2A?displayProperty=fullName&gt; method, which accepts a &lt;xref:System.Type&gt; as an argument and returns a pointer to a new instance.","pos":[1647,1862],"source":"Compatible classes are then instantiated with the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, which accepts a <xref:System.Type> as an argument and returns a pointer to a new instance."},{"content":"Each new instance is then attached to the form and displayed.","pos":[1863,1924]},{"content":"Note that the &lt;xref:System.Reflection.Assembly.Load%2A&gt; method does not accept assembly names that include the file extension.","pos":[1931,2057],"source":"Note that the <xref:System.Reflection.Assembly.Load%2A> method does not accept assembly names that include the file extension."},{"content":"The main function in the application trims any provided extensions, so the following code example works in either case.","pos":[2058,2177]},{"content":"Example","pos":[2186,2193]},{"content":"The following code defines the application that accepts plug-ins.","pos":[2197,2262]},{"content":"An assembly name must be provided as the first argument.","pos":[2263,2319]},{"content":"This assembly should contain at least one public &lt;xref:System.Windows.Forms.Form&gt; derived type.","pos":[2320,2415],"source":" This assembly should contain at least one public <xref:System.Windows.Forms.Form> derived type."},{"content":"Example","pos":[3600,3607]},{"content":"The following code defines three classes derived from &lt;xref:System.Windows.Forms.Form&gt;.","pos":[3611,3698],"source":"The following code defines three classes derived from <xref:System.Windows.Forms.Form>."},{"content":"When the name of the resulting assembly name is passed to the executable in the previous listing, each of these three classes will be discovered and instantiated, despite the fact that they were all unknown to the hosting application at compile time.","pos":[3699,3949]},{"content":"See Also","pos":[5171,5179]},{"content":"Reflection (C++/CLI)","pos":[5184,5204]}],"content":"---\ntitle: \"How to: Implement a Plug-In Component Architecture using Reflection (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"plug-ins [C++]\"\n  - \"reflection [C++}, plug-ins\"\nms.assetid: 4f31e42b-78d1-48b9-8fdc-f28c75e8e77e\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Implement a Plug-In Component Architecture using Reflection (C++/CLI)\nThe following code examples demonstrate the use of reflection to implement a simple \"plug-in\" architecture. The first listing is the application, and the second is the plug-in. The application is a multiple document form that populates itself using any form-based classes found in the plug-in DLL provided as a command-line argument.  \n  \n The application attempts to load the provided assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> method. If successful, the types inside the assembly are enumerated using the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName> method. Each type is then checked for compatibility using the <xref:System.Type.IsAssignableFrom%2A?displayProperty=fullName> method. In this example, classes found in the provided assembly must be derived from the <xref:System.Windows.Forms.Form> class to qualify as a plug-in.  \n  \n Compatible classes are then instantiated with the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, which accepts a <xref:System.Type> as an argument and returns a pointer to a new instance. Each new instance is then attached to the form and displayed.  \n  \n Note that the <xref:System.Reflection.Assembly.Load%2A> method does not accept assembly names that include the file extension. The main function in the application trims any provided extensions, so the following code example works in either case.  \n  \n## Example  \n The following code defines the application that accepts plug-ins. An assembly name must be provided as the first argument. This assembly should contain at least one public <xref:System.Windows.Forms.Form> derived type.  \n  \n```  \n// plugin_application.cpp  \n// compile with: /clr /c  \n#using <system.dll>  \n#using <system.drawing.dll>  \n#using <system.windows.forms.dll>  \n  \nusing namespace System;  \nusing namespace System::Windows::Forms;  \nusing namespace System::Reflection;  \n  \nref class PluggableForm : public Form  {  \npublic:  \n   PluggableForm() {}  \n   PluggableForm(Assembly^ plugAssembly) {  \n      Text = \"plug-in example\";  \n      Size = Drawing::Size(400, 400);  \n      IsMdiContainer = true;  \n  \n      array<Type^>^ types = plugAssembly->GetTypes( );  \n      Type^ formType = Form::typeid;  \n  \n      for (int i = 0 ; i < types->Length ; i++) {  \n         if (formType->IsAssignableFrom(types[i])) {  \n            // Create an instance given the type description.  \n            Form^ f = dynamic_cast<Form^> (Activator::CreateInstance(types[i]));  \n            if (f) {  \n               f->Text = types[i]->ToString();  \n               f->MdiParent = this;  \n               f->Show();  \n            }  \n         }  \n      }  \n   }  \n};  \n  \nint main() {  \n   Assembly^ a = Assembly::LoadFrom(\"plugin_application.exe\");  \n   Application::Run(gcnew PluggableForm(a));  \n}  \n```  \n  \n## Example  \n The following code defines three classes derived from <xref:System.Windows.Forms.Form>. When the name of the resulting assembly name is passed to the executable in the previous listing, each of these three classes will be discovered and instantiated, despite the fact that they were all unknown to the hosting application at compile time.  \n  \n```  \n// plugin_assembly.cpp  \n// compile with: /clr /LD  \n#using <system.dll>  \n#using <system.drawing.dll>  \n#using <system.windows.forms.dll>  \n  \nusing namespace System;  \nusing namespace System::Windows::Forms;  \nusing namespace System::Reflection;  \nusing namespace System::Drawing;  \n  \npublic ref class BlueForm : public Form {  \npublic:  \n   BlueForm() {  \n      BackColor = Color::Blue;  \n   }  \n};  \n  \npublic ref class CircleForm : public Form {  \nprotected:  \n   virtual void OnPaint(PaintEventArgs^ args) override {  \n      args->Graphics->FillEllipse(Brushes::Green, ClientRectangle);  \n   }  \n};  \n  \npublic ref class StarburstForm : public Form {  \npublic:  \n   StarburstForm(){  \n      BackColor = Color::Black;  \n   }  \nprotected:  \n   virtual void OnPaint(PaintEventArgs^ args) override {  \n      Pen^ p = gcnew Pen(Color::Red, 2);  \n      Random^ r = gcnew Random( );  \n      Int32 w = ClientSize.Width;  \n      Int32 h = ClientSize.Height;  \n      for (int i=0; i<100; i++) {  \n         float x1 = w / 2;  \n         float y1 = h / 2;  \n         float x2 = r->Next(w);  \n         float y2 = r->Next(h);  \n         args->Graphics->DrawLine(p, x1, y1, x2, y2);  \n      }  \n   }  \n};  \n```  \n  \n## See Also  \n [Reflection (C++/CLI)](../dotnet/reflection-cpp-cli.md)"}