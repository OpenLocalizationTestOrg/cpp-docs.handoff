{"nodes":[{"pos":[12,39],"content":"auto (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"auto (C++) | Microsoft Docs","pos":[0,27]}]},{"content":"auto (C++)","pos":[531,541]},{"content":"Deduces the type of a declared variable from its initialization expression.","pos":[542,617]},{"content":"Syntax","pos":[626,632]},{"content":"Remarks","pos":[737,744]},{"pos":[748,900],"content":"The <ph id=\"ph1\">`auto`</ph> keyword directs the compiler to use the initialization expression of a declared variable, or lambda expression parameter, to deduce its type.","source":"The `auto` keyword directs the compiler to use the initialization expression of a declared variable, or lambda expression parameter, to deduce its type."},{"pos":[907,1043],"content":"We recommend that you use the <ph id=\"ph1\">`auto`</ph> keyword for most situations—unless you really want a conversion—because it provides these benefits:","source":"We recommend that you use the `auto` keyword for most situations—unless you really want a conversion—because it provides these benefits:"},{"pos":[1053,1172],"content":"<bpt id=\"p1\">**</bpt>Robustness:<ept id=\"p1\">**</ept> If the expression’s type is changed—this includes when a function return type is changed—it just works.","source":"**Robustness:** If the expression’s type is changed—this includes when a function return type is changed—it just works."},{"pos":[1182,1250],"content":"<bpt id=\"p1\">**</bpt>Performance:<ept id=\"p1\">**</ept> You’re guaranteed that there will be no conversion.","source":"**Performance:** You’re guaranteed that there will be no conversion."},{"pos":[1260,1347],"content":"<bpt id=\"p1\">**</bpt>Usability:<ept id=\"p1\">**</ept> You don't have to worry about type name spelling difficulties and typos.","source":"**Usability:** You don't have to worry about type name spelling difficulties and typos."},{"pos":[1357,1407],"content":"<bpt id=\"p1\">**</bpt>Efficiency:<ept id=\"p1\">**</ept> Your coding can be more efficient.","source":"**Efficiency:** Your coding can be more efficient."},{"pos":[1414,1473],"content":"Conversion cases in which you might not want to use <ph id=\"ph1\">`auto`</ph>:","source":"Conversion cases in which you might not want to use `auto`:"},{"content":"When you want a specific type and nothing else will do.","pos":[1483,1538]},{"pos":[1548,1616],"content":"Expression template helper types—for example, <ph id=\"ph1\">`(valarray+valarray)`</ph>.","source":"Expression template helper types—for example, `(valarray+valarray)`."},{"content":"To use the <ph id=\"ph1\">`auto`</ph> keyword, use it instead of a type to declare a variable, and specify an initialization expression.","pos":[1623,1739],"source":"To use the `auto` keyword, use it instead of a type to declare a variable, and specify an initialization expression."},{"content":"In addition, you can modify the <ph id=\"ph1\">`auto`</ph> keyword by using specifiers and declarators such as <ph id=\"ph2\">`const`</ph>, <ph id=\"ph3\">`volatile`</ph>, pointer (<ph id=\"ph4\">`*`</ph>), reference (<ph id=\"ph5\">`&amp;`</ph>), and rvalue reference <ph id=\"ph6\">`(&amp;&amp;`</ph>).","pos":[1740,1912],"source":" In addition, you can modify the `auto` keyword by using specifiers and declarators such as `const`, `volatile`, pointer (`*`), reference (`&`), and rvalue reference `(&&`)."},{"content":"The compiler evaluates the initialization expression and then uses that information to deduce the type of the variable.","pos":[1913,2032]},{"content":"The initialization expression can be an assignment (equal-sign syntax), a direct initialization (function-style syntax), an <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](new-operator-cpp.md)</ept> expression, or the initialization expression can be the <bpt id=\"p2\">*</bpt>for-range-declaration<ept id=\"p2\">*</ept> parameter in a <bpt id=\"p3\">[</bpt>Range-based for Statement (C++)<ept id=\"p3\">](../cpp/range-based-for-statement-cpp.md)</ept> statement.","pos":[2039,2379],"source":"The initialization expression can be an assignment (equal-sign syntax), a direct initialization (function-style syntax), an [operator new](new-operator-cpp.md) expression, or the initialization expression can be the *for-range-declaration* parameter in a [Range-based for Statement (C++)](../cpp/range-based-for-statement-cpp.md) statement."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Initializers<ept id=\"p1\">](../cpp/initializers.md)</ept> and the code examples later in this document.","pos":[2380,2490],"source":" For more information, see [Initializers](../cpp/initializers.md) and the code examples later in this document."},{"content":"The <ph id=\"ph1\">`auto`</ph> keyword is a placeholder for a type, but it is not itself a type.","pos":[2497,2573],"source":"The `auto` keyword is a placeholder for a type, but it is not itself a type."},{"content":"Therefore, the <ph id=\"ph1\">`auto`</ph> keyword cannot be used in casts or operators such as <bpt id=\"p1\">[</bpt>sizeof<ept id=\"p1\">](../cpp/sizeof-operator.md)</ept> and <bpt id=\"p2\">[</bpt>typeid<ept id=\"p2\">](../windows/typeid-cpp-component-extensions.md)</ept>.","pos":[2574,2745],"source":" Therefore, the `auto` keyword cannot be used in casts or operators such as [sizeof](../cpp/sizeof-operator.md) and [typeid](../windows/typeid-cpp-component-extensions.md)."},{"content":"Usefulness","pos":[2754,2764]},{"content":"The <ph id=\"ph1\">`auto`</ph> keyword is a simple way to declare a variable that has a complicated type.","pos":[2768,2853],"source":"The `auto` keyword is a simple way to declare a variable that has a complicated type."},{"content":"For example, you can use <ph id=\"ph1\">`auto`</ph> to declare a variable where the initialization expression involves templates, pointers to functions, or pointers to members.","pos":[2854,3010],"source":" For example, you can use `auto` to declare a variable where the initialization expression involves templates, pointers to functions, or pointers to members."},{"content":"You can also use <ph id=\"ph1\">`auto`</ph> to declare and initialize a variable to a lambda expression.","pos":[3017,3101],"source":"You can also use `auto` to declare and initialize a variable to a lambda expression."},{"content":"You can't declare the type of the variable yourself because the type of a lambda expression is known only to the compiler.","pos":[3102,3224]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Examples of Lambda Expressions<ept id=\"p1\">](../cpp/examples-of-lambda-expressions.md)</ept>.","pos":[3225,3326],"source":" For more information, see [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md)."},{"content":"Trailing Return Types","pos":[3335,3356]},{"content":"You can use <ph id=\"ph1\">`auto`</ph>, together with the <ph id=\"ph2\">`decltype`</ph> type specifier, to help write template libraries.","pos":[3360,3458],"source":"You can use `auto`, together with the `decltype` type specifier, to help write template libraries."},{"content":"Use <ph id=\"ph1\">`auto`</ph> and <ph id=\"ph2\">`decltype`</ph> to declare a template function whose return type depends on the types of its template arguments.","pos":[3459,3581],"source":" Use `auto` and `decltype` to declare a template function whose return type depends on the types of its template arguments."},{"content":"Or, use <ph id=\"ph1\">`auto`</ph> and <ph id=\"ph2\">`decltype`</ph> to declare a template function that wraps a call to another function, and then returns whatever is the return type of that other function.","pos":[3582,3750],"source":" Or, use `auto` and `decltype` to declare a template function that wraps a call to another function, and then returns whatever is the return type of that other function."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>decltype<ept id=\"p1\">](../cpp/decltype-cpp.md)</ept>.","pos":[3751,3812],"source":" For more information, see [decltype](../cpp/decltype-cpp.md)."},{"content":"References and cv-qualifiers","pos":[3821,3849]},{"content":"Note that using <ph id=\"ph1\">`auto`</ph> drops references, const qualifiers, and volatile qualifiers.","pos":[3853,3936],"source":"Note that using `auto` drops references, const qualifiers, and volatile qualifiers."},{"content":"Consider the following example:","pos":[3937,3968]},{"pos":[4284,4466],"content":"In the previous example, myAuto is an int, not an int reference, so the output is <ph id=\"ph1\">`11 11`</ph>, not <ph id=\"ph2\">`11 12`</ph> as would be the case if the reference qualifier had not been dropped by <ph id=\"ph3\">`auto`</ph>.","source":"In the previous example, myAuto is an int, not an int reference, so the output is `11 11`, not `11 12` as would be the case if the reference qualifier had not been dropped by `auto`."},{"content":"Type deduction with braced initializers (C++14)","pos":[4475,4522]},{"content":"The following code exmample shows how to intialize an auto variable using braces.","pos":[4526,4607]},{"content":"Note the difference between B and C and between A and E.","pos":[4608,4664]},{"content":"Restrictions and Error Messages","pos":[5189,5220]},{"pos":[5224,5372],"content":"The following table lists the restrictions on the use of the <ph id=\"ph1\">`auto`</ph> keyword, and the corresponding diagnostic error message that the compiler emits.","source":"The following table lists the restrictions on the use of the `auto` keyword, and the corresponding diagnostic error message that the compiler emits."},{"content":"Error number","pos":[5379,5391]},{"content":"Description","pos":[5392,5403]},{"content":"C3530","pos":[5450,5455]},{"pos":[5518,5586],"content":"The <ph id=\"ph1\">`auto`</ph> keyword cannot be combined with any other type-specifier.","source":"The `auto` keyword cannot be combined with any other type-specifier."},{"content":"C3531","pos":[5592,5597]},{"pos":[5660,5735],"content":"A symbol that is declared with the <ph id=\"ph1\">`auto`</ph> keyword must have an initializer.","source":"A symbol that is declared with the `auto` keyword must have an initializer."},{"content":"C3532","pos":[5741,5746]},{"content":"You incorrectly used the <ph id=\"ph1\">`auto`</ph> keyword to declare a type.","pos":[5809,5867],"source":"You incorrectly used the `auto` keyword to declare a type."},{"content":"For example, you declared a method return type or an array.","pos":[5868,5927]},{"pos":[5932,6070],"content":"<bpt id=\"p1\">[</bpt>C3533<ept id=\"p1\">](../error-messages/compiler-errors-2/compiler-error-c3533.md)</ept>, <bpt id=\"p2\">[</bpt>C3539<ept id=\"p2\">](../error-messages/compiler-errors-2/compiler-error-c3539.md)</ept>","source":"[C3533](../error-messages/compiler-errors-2/compiler-error-c3533.md), [C3539](../error-messages/compiler-errors-2/compiler-error-c3539.md)"},{"pos":[6071,6147],"content":"A parameter or template argument cannot be declared with the <ph id=\"ph1\">`auto`</ph> keyword.","source":"A parameter or template argument cannot be declared with the `auto` keyword."},{"content":"C3534","pos":[6153,6158]},{"content":"A symbol that is declared with the <ph id=\"ph1\">`auto`</ph> keyword in a <ph id=\"ph2\">`new`</ph> expression must have an initializer.","pos":[6221,6318],"source":"A symbol that is declared with the `auto` keyword in a `new` expression must have an initializer."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](new-operator-cpp.md)</ept>.","pos":[6319,6381],"source":" For more information, see [operator new](new-operator-cpp.md)."},{"content":"C3535","pos":[6387,6392]},{"pos":[6455,6529],"content":"A method or template parameter cannot be declared with the <ph id=\"ph1\">`auto`</ph> keyword.","source":"A method or template parameter cannot be declared with the `auto` keyword."},{"content":"C3536","pos":[6535,6540]},{"content":"A symbol cannot be used before it is initialized.","pos":[6603,6652]},{"content":"In practice, this means that a variable cannot be used to initialize itself.","pos":[6653,6729]},{"content":"C3537","pos":[6735,6740]},{"pos":[6803,6870],"content":"You cannot cast to a type that is declared with the <ph id=\"ph1\">`auto`</ph> keyword.","source":"You cannot cast to a type that is declared with the `auto` keyword."},{"content":"C3538","pos":[6876,6881]},{"content":"All the symbols in a declarator list that is declared with the <ph id=\"ph1\">`auto`</ph> keyword must resolve to the same type.","pos":[6944,7052],"source":"All the symbols in a declarator list that is declared with the `auto` keyword must resolve to the same type."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Declarations and Definitions<ept id=\"p1\">](declarations-and-definitions-cpp.md)</ept>.","pos":[7053,7147],"source":" For more information, see [Declarations and Definitions](declarations-and-definitions-cpp.md)."},{"pos":[7152,7290],"content":"<bpt id=\"p1\">[</bpt>C3540<ept id=\"p1\">](../error-messages/compiler-errors-2/compiler-error-c3540.md)</ept>, <bpt id=\"p2\">[</bpt>C3541<ept id=\"p2\">](../error-messages/compiler-errors-2/compiler-error-c3541.md)</ept>","source":"[C3540](../error-messages/compiler-errors-2/compiler-error-c3540.md), [C3541](../error-messages/compiler-errors-2/compiler-error-c3541.md)"},{"pos":[7291,7472],"content":"The <bpt id=\"p1\">[</bpt>sizeof<ept id=\"p1\">](../cpp/sizeof-operator.md)</ept> and <bpt id=\"p2\">[</bpt>typeid<ept id=\"p2\">](../windows/typeid-cpp-component-extensions.md)</ept> operators cannot be applied to a symbol that is declared with the <ph id=\"ph1\">`auto`</ph> keyword.","source":"The [sizeof](../cpp/sizeof-operator.md) and [typeid](../windows/typeid-cpp-component-extensions.md) operators cannot be applied to a symbol that is declared with the `auto` keyword."},{"content":"Examples","pos":[7482,7490]},{"pos":[7494,7583],"content":"These code fragments illustrate some of the ways in which the <ph id=\"ph1\">`auto`</ph> keyword can be used.","source":"These code fragments illustrate some of the ways in which the `auto` keyword can be used."},{"content":"The following declarations are equivalent.","pos":[7590,7632]},{"content":"In the first statement, variable <ph id=\"ph1\">`j`</ph> is declared to be type <ph id=\"ph2\">`int`</ph>.","pos":[7633,7699],"source":" In the first statement, variable `j` is declared to be type `int`."},{"content":"In the second statement, variable <ph id=\"ph1\">`k`</ph> is deduced to be type <ph id=\"ph2\">`int`</ph> because the initialization expression (0) is an integer.","pos":[7700,7822],"source":" In the second statement, variable `k` is deduced to be type `int` because the initialization expression (0) is an integer."},{"content":"The following declarations are equivalent, but the second declaration is simpler than the first.","pos":[7978,8074]},{"content":"One of the most compelling reasons to use the <ph id=\"ph1\">`auto`</ph> keyword is simplicity.","pos":[8075,8150],"source":" One of the most compelling reasons to use the `auto` keyword is simplicity."},{"pos":[8251,8371],"content":"The following code fragment declares the type of variables <ph id=\"ph1\">`iter`</ph> and <ph id=\"ph2\">`elem`</ph> when the <ph id=\"ph3\">`for`</ph> and range <ph id=\"ph4\">`for`</ph> loops start.","source":"The following code fragment declares the type of variables `iter` and `elem` when the `for` and range `for` loops start."},{"pos":[9109,9205],"content":"The following code fragment uses the <ph id=\"ph1\">`new`</ph> operator and pointer declaration to declare pointers.","source":"The following code fragment uses the `new` operator and pointer declaration to declare pointers."},{"content":"The next code fragment declares multiple symbols in each declaration statement.","pos":[9298,9377]},{"content":"Notice that all of the symbols in each statement resolve to the same type.","pos":[9378,9452]},{"pos":[9696,9814],"content":"This code fragment uses the conditional operator (<ph id=\"ph1\">`?:`</ph>) to declare variable <ph id=\"ph2\">`x`</ph> as an integer that has a value of 200:","source":"This code fragment uses the conditional operator (`?:`) to declare variable `x` as an integer that has a value of 200:"},{"pos":[9898,10085],"content":"The following code fragment initializes variable <ph id=\"ph1\">`x`</ph> to type <ph id=\"ph2\">`int`</ph>, variable <ph id=\"ph3\">`y`</ph> to a reference to type <ph id=\"ph4\">`const``int`</ph>, and variable <ph id=\"ph5\">`fp`</ph> to a pointer to a function that returns type <ph id=\"ph6\">`int`</ph>.","source":"The following code fragment initializes variable `x` to type `int`, variable `y` to a reference to type `const``int`, and variable `fp` to a pointer to a function that returns type `int`."},{"content":"See Also","pos":[10285,10293]},{"content":"auto Keyword","pos":[10298,10310]},{"content":"Keywords","pos":[10341,10349]},{"content":"/Zc:auto (Deduce Variable Type)","pos":[10380,10411]},{"content":"sizeof Operator","pos":[10470,10485]},{"content":"typeid","pos":[10519,10525]},{"content":"operator new","pos":[10579,10591]},{"content":"Declarations and Definitions","pos":[10619,10647]},{"content":"Examples of Lambda Expressions","pos":[10691,10721]},{"content":"Initializers","pos":[10770,10782]},{"content":"decltype","pos":[10813,10821]}],"content":"---\ntitle: \"auto (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: e9d495d7-601c-4547-b897-998389a311f4\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# auto (C++)\nDeduces the type of a declared variable from its initialization expression.  \n  \n## Syntax  \n  \n```  \nauto declarator initializer;  \n```  \n  \n```  \n[](auto param1, auto param2) {};  \n```  \n  \n## Remarks  \n The `auto` keyword directs the compiler to use the initialization expression of a declared variable, or lambda expression parameter, to deduce its type.  \n  \n We recommend that you use the `auto` keyword for most situations—unless you really want a conversion—because it provides these benefits:  \n  \n-   **Robustness:** If the expression’s type is changed—this includes when a function return type is changed—it just works.  \n  \n-   **Performance:** You’re guaranteed that there will be no conversion.  \n  \n-   **Usability:** You don't have to worry about type name spelling difficulties and typos.  \n  \n-   **Efficiency:** Your coding can be more efficient.  \n  \n Conversion cases in which you might not want to use `auto`:  \n  \n-   When you want a specific type and nothing else will do.  \n  \n-   Expression template helper types—for example, `(valarray+valarray)`.  \n  \n To use the `auto` keyword, use it instead of a type to declare a variable, and specify an initialization expression. In addition, you can modify the `auto` keyword by using specifiers and declarators such as `const`, `volatile`, pointer (`*`), reference (`&`), and rvalue reference `(&&`). The compiler evaluates the initialization expression and then uses that information to deduce the type of the variable.  \n  \n The initialization expression can be an assignment (equal-sign syntax), a direct initialization (function-style syntax), an [operator new](new-operator-cpp.md) expression, or the initialization expression can be the *for-range-declaration* parameter in a [Range-based for Statement (C++)](../cpp/range-based-for-statement-cpp.md) statement. For more information, see [Initializers](../cpp/initializers.md) and the code examples later in this document.  \n  \n The `auto` keyword is a placeholder for a type, but it is not itself a type. Therefore, the `auto` keyword cannot be used in casts or operators such as [sizeof](../cpp/sizeof-operator.md) and [typeid](../windows/typeid-cpp-component-extensions.md).  \n  \n## Usefulness  \n The `auto` keyword is a simple way to declare a variable that has a complicated type. For example, you can use `auto` to declare a variable where the initialization expression involves templates, pointers to functions, or pointers to members.  \n  \n You can also use `auto` to declare and initialize a variable to a lambda expression. You can't declare the type of the variable yourself because the type of a lambda expression is known only to the compiler. For more information, see [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md).  \n  \n## Trailing Return Types  \n You can use `auto`, together with the `decltype` type specifier, to help write template libraries. Use `auto` and `decltype` to declare a template function whose return type depends on the types of its template arguments. Or, use `auto` and `decltype` to declare a template function that wraps a call to another function, and then returns whatever is the return type of that other function. For more information, see [decltype](../cpp/decltype-cpp.md).  \n  \n## References and cv-qualifiers  \n Note that using `auto` drops references, const qualifiers, and volatile qualifiers. Consider the following example:  \n  \n```cpp  \n// cl.exe /analyze /EHsc /W4  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n    int count = 10;  \n    int& countRef = count;  \n    auto myAuto = countRef;  \n  \n    countRef = 11;  \n    cout << count << \" \";  \n  \n    myAuto = 12;  \n    cout << count << endl;  \n}  \n  \n```  \n  \n In the previous example, myAuto is an int, not an int reference, so the output is `11 11`, not `11 12` as would be the case if the reference qualifier had not been dropped by `auto`.  \n  \n## Type deduction with braced initializers (C++14)  \n The following code exmample shows how to intialize an auto variable using braces. Note the difference between B and C and between A and E.  \n  \n```  \n  \n#include <initializer_list>  \n  \nint main()  \n{  \n    // std::initializer_list<int>  \n    auto A = { 1, 2 };  \n  \n    // std::initializer_list<int>  \n    auto B = { 3 };  \n  \n    // int  \n    auto C{ 4 };  \n  \n    // C3535: cannot deduce type for 'auto' from initializer list'  \n    auto D = { 5, 6.7 };  \n  \n    // C3518 in a direct-list-initialization context the type for 'auto'  \n    // can only be deduced from a single initializer expression  \n    auto E{ 8, 9 };  \n  \n    return 0;  \n}  \n  \n```  \n  \n## Restrictions and Error Messages  \n The following table lists the restrictions on the use of the `auto` keyword, and the corresponding diagnostic error message that the compiler emits.  \n  \n|Error number|Description|  \n|------------------|-----------------|  \n|[C3530](../error-messages/compiler-errors-2/compiler-error-c3530.md)|The `auto` keyword cannot be combined with any other type-specifier.|  \n|[C3531](../error-messages/compiler-errors-2/compiler-error-c3531.md)|A symbol that is declared with the `auto` keyword must have an initializer.|  \n|[C3532](../error-messages/compiler-errors-2/compiler-error-c3532.md)|You incorrectly used the `auto` keyword to declare a type. For example, you declared a method return type or an array.|  \n|[C3533](../error-messages/compiler-errors-2/compiler-error-c3533.md), [C3539](../error-messages/compiler-errors-2/compiler-error-c3539.md)|A parameter or template argument cannot be declared with the `auto` keyword.|  \n|[C3534](../error-messages/compiler-errors-2/compiler-error-c3534.md)|A symbol that is declared with the `auto` keyword in a `new` expression must have an initializer. For more information, see [operator new](new-operator-cpp.md).|  \n|[C3535](../error-messages/compiler-errors-2/compiler-error-c3535.md)|A method or template parameter cannot be declared with the `auto` keyword.|  \n|[C3536](../error-messages/compiler-errors-2/compiler-error-c3536.md)|A symbol cannot be used before it is initialized. In practice, this means that a variable cannot be used to initialize itself.|  \n|[C3537](../error-messages/compiler-errors-2/compiler-error-c3537.md)|You cannot cast to a type that is declared with the `auto` keyword.|  \n|[C3538](../error-messages/compiler-errors-2/compiler-error-c3538.md)|All the symbols in a declarator list that is declared with the `auto` keyword must resolve to the same type. For more information, see [Declarations and Definitions](declarations-and-definitions-cpp.md).|  \n|[C3540](../error-messages/compiler-errors-2/compiler-error-c3540.md), [C3541](../error-messages/compiler-errors-2/compiler-error-c3541.md)|The [sizeof](../cpp/sizeof-operator.md) and [typeid](../windows/typeid-cpp-component-extensions.md) operators cannot be applied to a symbol that is declared with the `auto` keyword.|  \n  \n## Examples  \n These code fragments illustrate some of the ways in which the `auto` keyword can be used.  \n  \n The following declarations are equivalent. In the first statement, variable `j` is declared to be type `int`. In the second statement, variable `k` is deduced to be type `int` because the initialization expression (0) is an integer.  \n  \n```cpp  \n  \nint j = 0;  // Variable j is explicitly type int.  \nauto k = 0; // Variable k is implicitly type int because 0 is an integer.  \n```  \n  \n The following declarations are equivalent, but the second declaration is simpler than the first. One of the most compelling reasons to use the `auto` keyword is simplicity.  \n  \n```cpp  \n  \nmap<int,list<string>>::iterator i = m.begin();   \nauto i = m.begin();   \n```  \n  \n The following code fragment declares the type of variables `iter` and `elem` when the `for` and range `for` loops start.  \n  \n```cpp  \n  \n// cl /EHsc /nologo /W4  \n#include <deque>  \nusing namespace std;  \n  \nint main()  \n{  \n    deque<double> dqDoubleData(10, 0.1);  \n  \n    for (auto iter = dqDoubleData.begin(); iter != dqDoubleData.end(); ++iter)  \n    { /* ... */ }  \n  \n    // prefer range-for loops with the following information in mind  \n    // (this applies to any range-for with auto, not just deque)  \n  \n    for (auto elem : dqDoubleData) // COPIES elements, not much better than the previous examples  \n    { /* ... */ }  \n  \n    for (auto& elem : dqDoubleData) // observes and/or modifies elements IN-PLACE  \n    { /* ... */ }  \n  \n    for (const auto& elem : dqDoubleData) // observes elements IN-PLACE  \n    { /* ... */ }  \n}  \n  \n```  \n  \n The following code fragment uses the `new` operator and pointer declaration to declare pointers.  \n  \n```cpp  \n  \ndouble x = 12.34;  \nauto *y = new auto(x), **z = new auto(&x);  \n```  \n  \n The next code fragment declares multiple symbols in each declaration statement. Notice that all of the symbols in each statement resolve to the same type.  \n  \n```cpp  \n  \nauto x = 1, *y = &x, **z = &y; // Resolves to int.  \nauto a(2.01), *b (&a);         // Resolves to double.  \nauto c = 'a', *d(&c);          // Resolves to char.  \nauto m = 1, &n = m;            // Resolves to int.  \n```  \n  \n This code fragment uses the conditional operator (`?:`) to declare variable `x` as an integer that has a value of 200:  \n  \n```cpp  \n  \nint v1 = 100, v2 = 200;  \nauto x = v1 > v2 ? v1 : v2;  \n```  \n  \n The following code fragment initializes variable `x` to type `int`, variable `y` to a reference to type `const``int`, and variable `fp` to a pointer to a function that returns type `int`.  \n  \n```cpp  \n  \nint f(int x) { return x; }  \nint main()  \n{  \n    auto x = f(0);  \n    const auto & y = f(1);  \n    int (*p)(int x);  \n    p = f;  \n    auto fp = p;  \n    //...  \n}  \n  \n```  \n  \n## See Also  \n [auto Keyword](../cpp/auto-keyword.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [/Zc:auto (Deduce Variable Type)](../build/reference/zc-auto-deduce-variable-type.md)   \n [sizeof Operator](../cpp/sizeof-operator.md)   \n [typeid](../windows/typeid-cpp-component-extensions.md)   \n [operator new](new-operator-cpp.md)   \n [Declarations and Definitions](declarations-and-definitions-cpp.md)   \n [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md)   \n [Initializers](../cpp/initializers.md)   \n [decltype](../cpp/decltype-cpp.md)"}