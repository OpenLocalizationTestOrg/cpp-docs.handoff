{"nodes":[{"pos":[12,47],"content":"fopen_s, _wfopen_s | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"fopen_s, _wfopen_s | Microsoft Docs","pos":[0,35]}]},{"pos":[1221,1239],"content":"fopen_s, _wfopen_s","linkify":"fopen_s, _wfopen_s","nodes":[{"content":"fopen_s, _wfopen_s","pos":[0,18]}]},{"content":"Opens a file.","pos":[1240,1253]},{"content":"These versions of <bpt id=\"p1\">[</bpt>fopen, _wfopen<ept id=\"p1\">](../../c-runtime-library/reference/fopen-wfopen.md)</ept> have security enhancements, as described in <bpt id=\"p2\">[</bpt>Security Features in the CRT<ept id=\"p2\">](../../c-runtime-library/security-features-in-the-crt.md)</ept>.","pos":[1254,1472],"source":" These versions of [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md) have security enhancements, as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md)."},{"pos":[1481,1487],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1708,1718],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[out] <ph id=\"ph1\">`pFile`</ph>","pos":[1722,1735],"source":"[out] `pFile`"},{"content":"A pointer to the file pointer that will receive the pointer to the opened file.","pos":[1739,1818]},{"content":"[in] <ph id=\"ph1\">`filename`</ph>","pos":[1825,1840],"source":"[in] `filename`"},{"content":"Filename.","pos":[1844,1853]},{"content":"[in] <ph id=\"ph1\">`mode`</ph>","pos":[1860,1871],"source":"[in] `mode`"},{"content":"Type of access permitted.","pos":[1875,1900]},{"pos":[1909,1921],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Zero if successful; an error code on failure.","pos":[1925,1970]},{"content":"See <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept> for more information about these error codes.","pos":[1971,2136],"source":" See [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md) for more information about these error codes."},{"pos":[2146,2162],"content":"Error Conditions","linkify":"Error Conditions","nodes":[{"content":"Error Conditions","pos":[0,16]}]},{"content":"Return Value","pos":[2195,2207]},{"pos":[2208,2226],"content":"Contents of<ph id=\"ph1\">`pFile`</ph>","source":"Contents of`pFile`"},{"content":"any","pos":[2330,2333]},{"content":"any","pos":[2334,2337]},{"content":"unchanged","pos":[2347,2356]},{"content":"any","pos":[2361,2364]},{"content":"any","pos":[2372,2375]},{"content":"unchanged","pos":[2385,2394]},{"content":"any","pos":[2399,2402]},{"content":"any","pos":[2403,2406]},{"content":"NULL","pos":[2407,2411]},{"content":"unchanged","pos":[2421,2430]},{"pos":[2440,2447],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Files that are opened by <ph id=\"ph1\">`fopen_s`</ph> and <ph id=\"ph2\">`_wfopen_s`</ph> are not sharable.","pos":[2451,2519],"source":"Files that are opened by `fopen_s` and `_wfopen_s` are not sharable."},{"content":"If you require that a file be sharable, use <bpt id=\"p1\">[</bpt>_fsopen, _wfsopen<ept id=\"p1\">](../../c-runtime-library/reference/fsopen-wfsopen.md)</ept> with the appropriate sharing mode constant—for example, <ph id=\"ph1\">`_SH_DENYNO`</ph> for read/write sharing.","pos":[2520,2729],"source":" If you require that a file be sharable, use [_fsopen, _wfsopen](../../c-runtime-library/reference/fsopen-wfsopen.md) with the appropriate sharing mode constant—for example, `_SH_DENYNO` for read/write sharing."},{"content":"The <ph id=\"ph1\">`fopen_s`</ph> function opens the file that's specified by <ph id=\"ph2\">`filename`</ph>.","pos":[2736,2805],"source":"The `fopen_s` function opens the file that's specified by `filename`."},{"content":"<ph id=\"ph1\">`_wfopen_s`</ph> is a wide-character version of <ph id=\"ph2\">`fopen_s`</ph>; the arguments to <ph id=\"ph3\">`_wfopen_s`</ph> are wide-character strings.","pos":[2806,2916],"source":"`_wfopen_s` is a wide-character version of `fopen_s`; the arguments to `_wfopen_s` are wide-character strings."},{"content":"<ph id=\"ph1\">`_wfopen_s`</ph> and <ph id=\"ph2\">`fopen_s`</ph> behave identically otherwise.","pos":[2917,2972],"source":"`_wfopen_s` and `fopen_s` behave identically otherwise."},{"content":"<ph id=\"ph1\">`fopen_s`</ph> accepts paths that are valid on the file system at the point of execution; UNC paths and paths that involve mapped network drives are accepted by <ph id=\"ph2\">`fopen_s`</ph> as long as the system that's executing the code has access to the share or mapped network drive at the time of execution.","pos":[2979,3266],"source":"`fopen_s` accepts paths that are valid on the file system at the point of execution; UNC paths and paths that involve mapped network drives are accepted by `fopen_s` as long as the system that's executing the code has access to the share or mapped network drive at the time of execution."},{"content":"When you construct paths for <ph id=\"ph1\">`fopen_s`</ph>, don't make assumptions about the availability of drives, paths, or network shares in the execution environment.","pos":[3267,3418],"source":" When you construct paths for `fopen_s`, don't make assumptions about the availability of drives, paths, or network shares in the execution environment."},{"content":"You can use either forward slashes (/) or backslashes (<ph id=\"ph1\">\\\\</ph>) as the directory separators in a path.","pos":[3419,3516],"source":" You can use either forward slashes (/) or backslashes (\\\\) as the directory separators in a path."},{"content":"These functions validate their parameters.","pos":[3523,3565]},{"content":"If <ph id=\"ph1\">`pFile`</ph>, <ph id=\"ph2\">`filename`</ph>, or <ph id=\"ph3\">`mode`</ph> is a null pointer, these functions generate an invalid parameter exception, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[3566,3764],"source":" If `pFile`, `filename`, or `mode` is a null pointer, these functions generate an invalid parameter exception, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"Always check the return value to see if the function succeeded before you perform any further operations on the file.","pos":[3771,3888]},{"content":"If an error occurs, the error code is returned and the global variable <ph id=\"ph1\">`errno`</ph> is set.","pos":[3889,3975],"source":" If an error occurs, the error code is returned and the global variable `errno` is set."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","pos":[3976,4118],"source":" For more information, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"pos":[4127,4142],"content":"Unicode support","linkify":"Unicode support","nodes":[{"content":"Unicode support","pos":[0,15]}]},{"content":"<ph id=\"ph1\">`fopen_s`</ph> supports Unicode file streams.","pos":[4146,4186],"source":"`fopen_s` supports Unicode file streams."},{"content":"To open a new or existing Unicode file, pass a <ph id=\"ph1\">`ccs`</ph> flag that specifies the desired encoding to <ph id=\"ph2\">`fopen_s`</ph>:","pos":[4187,4294],"source":" To open a new or existing Unicode file, pass a `ccs` flag that specifies the desired encoding to `fopen_s`:"},{"pos":[4301,4362],"content":"<ph id=\"ph1\">`fopen_s(&amp;fp, \"newfile.txt\", \"rw,`</ph>   <ph id=\"ph2\">`ccs=`</ph>  <ph id=\"ph3\">`encoding`</ph> <ph id=\"ph4\">`\");`</ph>","source":"`fopen_s(&fp, \"newfile.txt\", \"rw,`   `ccs=`  `encoding` `\");`"},{"content":"Allowed values of <ph id=\"ph1\">`encoding`</ph> are <ph id=\"ph2\">`UNICODE`</ph>, <ph id=\"ph3\">`UTF-8`</ph>, and <ph id=\"ph4\">`UTF-16LE`</ph>.","pos":[4369,4437],"source":"Allowed values of `encoding` are `UNICODE`, `UTF-8`, and `UTF-16LE`."},{"content":"If there no value is specified for <ph id=\"ph1\">`encoding`</ph>, <ph id=\"ph2\">`fopen_s`</ph> uses ANSI encoding.","pos":[4438,4514],"source":" If there no value is specified for `encoding`, `fopen_s` uses ANSI encoding."},{"content":"If the file already exists and is opened for reading or appending, the Byte Order Mark (BOM), if present in the file, determines the encoding.","pos":[4521,4663]},{"content":"The BOM encoding takes precedence over the encoding that's specified by the <ph id=\"ph1\">`ccs`</ph> flag.","pos":[4664,4751],"source":" The BOM encoding takes precedence over the encoding that's specified by the `ccs` flag."},{"content":"The <ph id=\"ph1\">`ccs`</ph> encoding is only used when no BOM is present or if the file is a new file.","pos":[4752,4836],"source":" The `ccs` encoding is only used when no BOM is present or if the file is a new file."},{"pos":[4844,4959],"content":"[!NOTE]\n BOM-detection only applies to files that are opened in Unicode mode; that is, by passing the `ccs` flag.","leadings":["","> "],"nodes":[{"content":"BOM-detection only applies to files that are opened in Unicode mode; that is, by passing the <ph id=\"ph1\">`ccs`</ph> flag.","pos":[9,113],"source":" BOM-detection only applies to files that are opened in Unicode mode; that is, by passing the `ccs` flag."}]},{"pos":[4966,5096],"content":"The following table summarizes the modes for various <ph id=\"ph1\">`ccs`</ph> flags that are given to <ph id=\"ph2\">`fopen_s`</ph> and for Byte Order Marks in the file.","source":"The following table summarizes the modes for various `ccs` flags that are given to `fopen_s` and for Byte Order Marks in the file."},{"pos":[5106,5146],"content":"Encodings Used Based on ccs Flag and BOM","linkify":"Encodings Used Based on ccs Flag and BOM","nodes":[{"content":"Encodings Used Based on ccs Flag and BOM","pos":[0,40]}]},{"pos":[5153,5163],"content":"<ph id=\"ph1\">`ccs`</ph> flag","source":"`ccs` flag"},{"content":"No BOM (or new file)","pos":[5164,5184]},{"content":"BOM: UTF-8","pos":[5185,5195]},{"content":"BOM: UTF-16","pos":[5196,5207]},{"content":"Files that are opened for writing in Unicode mode have a BOM written to them automatically.","pos":[5430,5521]},{"content":"If <ph id=\"ph1\">`mode`</ph> is \"<ph id=\"ph2\">`a, ccs=&lt;encoding&gt;`</ph>\", <ph id=\"ph3\">`fopen_s`</ph> first tries to open the file with both read access and write access.","pos":[5528,5642],"source":"If `mode` is \"`a, ccs=<encoding>`\", `fopen_s` first tries to open the file with both read access and write access."},{"content":"If successful, the function reads the BOM to determine the encoding for the file; if unsuccessful, the function uses the default encoding for the file.","pos":[5643,5794]},{"content":"In either case, <ph id=\"ph1\">`fopen_s`</ph> then re-opens the file with write-only access.","pos":[5795,5867],"source":" In either case, `fopen_s` then re-opens the file with write-only access."},{"content":"(This applies to <ph id=\"ph1\">`a`</ph> mode only, not <ph id=\"ph2\">`a+`</ph>.)","pos":[5868,5910],"source":" (This applies to `a` mode only, not `a+`.)"},{"pos":[5920,5949],"content":"Generic-Text Routine Mappings","linkify":"Generic-Text Routine Mappings","nodes":[{"content":"Generic-Text Routine Mappings","pos":[0,29]}]},{"content":"TCHAR.H routine","pos":[5956,5971]},{"content":"_UNICODE &amp; _MBCS not defined","pos":[5972,6000],"source":"_UNICODE & _MBCS not defined"},{"content":"_MBCS defined","pos":[6001,6014]},{"content":"_UNICODE defined","pos":[6015,6031]},{"pos":[6195,6294],"content":"The character string <ph id=\"ph1\">`mode`</ph> specifies the kind of access that's requested for the file, as follows.","source":"The character string `mode` specifies the kind of access that's requested for the file, as follows."},{"content":"Opens for reading.","pos":[6310,6328]},{"content":"If the file does not exist or cannot be found, the <ph id=\"ph1\">`fopen_s`</ph> call fails.","pos":[6329,6401],"source":" If the file does not exist or cannot be found, the `fopen_s` call fails."},{"content":"Opens an empty file for writing.","pos":[6417,6449]},{"content":"If the file exists, its contents are destroyed.","pos":[6450,6497]},{"content":"Opens for writing at the end of the file (appending) without removing the EOF marker before writing new data to the file.","pos":[6513,6634]},{"content":"Creates the file if it doesn't exist.","pos":[6635,6672]},{"content":"Opens for both reading and writing.","pos":[6689,6724]},{"content":"(The file must exist.)","pos":[6725,6747]},{"content":"Opens an empty file for both reading and writing.","pos":[6764,6813]},{"content":"If the file exists, its contents are destroyed.","pos":[6814,6861]},{"content":"Opens for reading and appending.","pos":[6878,6910]},{"content":"The appending operation includes the removal of the EOF marker before new data is written to the file and the EOF marker is restored after writing is complete.","pos":[6911,7070]},{"content":"Creates the file if it doesn't exist.","pos":[7071,7108]},{"content":"When a file is opened by using the <ph id=\"ph1\">`\"a\"`</ph> or <ph id=\"ph2\">`\"a+\"`</ph> access type, all write operations occur at the end of the file.","pos":[7115,7229],"source":"When a file is opened by using the `\"a\"` or `\"a+\"` access type, all write operations occur at the end of the file."},{"content":"The file pointer can be repositioned by using <ph id=\"ph1\">`fseek`</ph> or <ph id=\"ph2\">`rewind`</ph>, but it's always moved back to the end of the file before any write operation is carried out so that existing data cannot be overwritten.","pos":[7230,7433],"source":" The file pointer can be repositioned by using `fseek` or `rewind`, but it's always moved back to the end of the file before any write operation is carried out so that existing data cannot be overwritten."},{"content":"The <ph id=\"ph1\">`\"a\"`</ph> mode does not remove the EOF marker before appending to the file.","pos":[7440,7515],"source":"The `\"a\"` mode does not remove the EOF marker before appending to the file."},{"content":"After appending has occurred, the MS-DOS TYPE command only shows data up to the original EOF marker and not any data that's appended to the file.","pos":[7516,7661]},{"content":"The <ph id=\"ph1\">`\"a+\"`</ph> mode does remove the EOF marker before appending to the file.","pos":[7662,7734],"source":" The `\"a+\"` mode does remove the EOF marker before appending to the file."},{"content":"After appending, the MS-DOS TYPE command shows all data in the file.","pos":[7735,7803]},{"content":"The <ph id=\"ph1\">`\"a+\"`</ph> mode is required for appending to a stream file that is terminated by using the CTRL+Z EOF marker.","pos":[7804,7913],"source":" The `\"a+\"` mode is required for appending to a stream file that is terminated by using the CTRL+Z EOF marker."},{"content":"When the <ph id=\"ph1\">`\"r+\",``\"w+\",`</ph> or <ph id=\"ph2\">`\"a+\"`</ph> access type is specified, both reading and writing are allowed.","pos":[7920,8017],"source":"When the `\"r+\",``\"w+\",` or `\"a+\"` access type is specified, both reading and writing are allowed."},{"content":"(The file is said to be open for \"update\".) However, when you switch from reading to writing, the input operation must encounter an EOF marker.","pos":[8018,8161]},{"content":"If there is no EOF, you must use an intervening call to a file-positioning function.","pos":[8162,8246]},{"content":"The file-positioning functions are <ph id=\"ph1\">`fsetpos`</ph>, <ph id=\"ph2\">`fseek`</ph>, and <ph id=\"ph3\">`rewind`</ph>.","pos":[8247,8315],"source":" The file-positioning functions are `fsetpos`, `fseek`, and `rewind`."},{"content":"When you switch from writing to reading, you must use an intervening call to either <ph id=\"ph1\">`fflush`</ph> or to a file-positioning function.","pos":[8316,8443],"source":" When you switch from writing to reading, you must use an intervening call to either `fflush` or to a file-positioning function."},{"pos":[8450,8589],"content":"In addition to the above values, the following characters can be included in <ph id=\"ph1\">`mode`</ph> to specify the translation mode for newline characters:","source":"In addition to the above values, the following characters can be included in `mode` to specify the translation mode for newline characters:"},{"content":"Open in text (translated) mode.","pos":[8603,8634]},{"content":"In this mode, CTRL+Z is interpreted as an end-of-file character on input.","pos":[8635,8708]},{"content":"In files opened for reading/writing with <ph id=\"ph1\">`\"a+\"`</ph>, <ph id=\"ph2\">`fopen_s`</ph> checks for a CTRL+Z at the end of the file and removes it, if possible.","pos":[8709,8839],"source":" In files opened for reading/writing with `\"a+\"`, `fopen_s` checks for a CTRL+Z at the end of the file and removes it, if possible."},{"content":"This is done because using <ph id=\"ph1\">`fseek`</ph> and <ph id=\"ph2\">`ftell`</ph> to move within a file that ends with a CTRL+Z, may cause <ph id=\"ph3\">`fseek`</ph> to behave improperly near the end of the file.","pos":[8840,8998],"source":" This is done because using `fseek` and `ftell` to move within a file that ends with a CTRL+Z, may cause `fseek` to behave improperly near the end of the file."},{"content":"Also, in text mode, carriage return–linefeed combinations are translated into single linefeeds on input, and linefeed characters are translated to carriage return–linefeed combinations on output.","pos":[9005,9200]},{"content":"When a Unicode stream-I/O function operates in text mode (the default), the source or destination stream is assumed to be a sequence of multibyte characters.","pos":[9201,9358]},{"content":"Therefore, the Unicode stream-input functions convert multibyte characters to wide characters (as if by a call to the <ph id=\"ph1\">`mbtowc`</ph> function).","pos":[9359,9496],"source":" Therefore, the Unicode stream-input functions convert multibyte characters to wide characters (as if by a call to the `mbtowc` function)."},{"content":"For the same reason, the Unicode stream-output functions convert wide characters to multibyte characters (as if by a call to the <ph id=\"ph1\">`wctomb`</ph> function).","pos":[9497,9645],"source":" For the same reason, the Unicode stream-output functions convert wide characters to multibyte characters (as if by a call to the `wctomb` function)."},{"content":"Open in binary (untranslated) mode; translations involving carriage-return and linefeed characters are suppressed.","pos":[9659,9773]},{"content":"If <ph id=\"ph1\">`t`</ph> or <ph id=\"ph2\">`b`</ph> is not given in <ph id=\"ph3\">`mode`</ph>, the default translation mode is defined by the global variable <bpt id=\"p1\">[</bpt>_fmode<ept id=\"p1\">](../../c-runtime-library/fmode.md)</ept>.","pos":[9780,9924],"source":"If `t` or `b` is not given in `mode`, the default translation mode is defined by the global variable [_fmode](../../c-runtime-library/fmode.md)."},{"content":"If <ph id=\"ph1\">`t`</ph> or <ph id=\"ph2\">`b`</ph> is prefixed to the argument, the function fails and returns <ph id=\"ph3\">`NULL`</ph>.","pos":[9925,10006],"source":" If `t` or `b` is prefixed to the argument, the function fails and returns `NULL`."},{"pos":[10013,10321],"content":"For more information about using text and binary modes in Unicode and multibyte stream-I/O, see <bpt id=\"p1\">[</bpt>Text and Binary Mode File I/O<ept id=\"p1\">](../../c-runtime-library/text-and-binary-mode-file-i-o.md)</ept> and <bpt id=\"p2\">[</bpt>Unicode Stream I/O in Text and Binary Modes<ept id=\"p2\">](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md)</ept>.","source":"For more information about using text and binary modes in Unicode and multibyte stream-I/O, see [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md) and [Unicode Stream I/O in Text and Binary Modes](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md)."},{"content":"Enable the commit flag for the associated <ph id=\"ph1\">`filename`</ph> so that the contents of the file buffer are written directly to disk if either <ph id=\"ph2\">`fflush`</ph> or <ph id=\"ph3\">`_flushall`</ph> is called.","pos":[10335,10501],"source":" Enable the commit flag for the associated `filename` so that the contents of the file buffer are written directly to disk if either `fflush` or `_flushall` is called."},{"content":"Reset the commit flag for the associated <ph id=\"ph1\">`filename`</ph> to \"no-commit.\"","pos":[10515,10582],"source":" Reset the commit flag for the associated `filename` to \"no-commit.\""},{"content":"This is the default.","pos":[10583,10603]},{"content":"It also overrides the global commit flag if you link your program with COMMODE.OBJ.","pos":[10604,10687]},{"content":"The global commit flag default is \"no-commit\" unless you explicitly link your program with COMMODE.OBJ (see <bpt id=\"p1\">[</bpt>Link Options<ept id=\"p1\">](../../c-runtime-library/link-options.md)</ept>).","pos":[10688,10853],"source":" The global commit flag default is \"no-commit\" unless you explicitly link your program with COMMODE.OBJ (see [Link Options](../../c-runtime-library/link-options.md))."},{"content":"Specifies that the file is not inherited by child processes.","pos":[10867,10927]},{"content":"Specifies that caching is optimized for, but not restricted to, sequential access from disk.","pos":[10941,11033]},{"content":"Specifies that caching is optimized for, but not restricted to, random access from disk.","pos":[11047,11135]},{"content":"Specifies a file as temporary.","pos":[11149,11179]},{"content":"If possible, it is not flushed to disk.","pos":[11180,11219]},{"content":"Specifies a file as temporary.","pos":[11233,11263]},{"content":"It is deleted when the last file pointer is closed.","pos":[11264,11315]},{"content":"Specify the coded character set to use (UTF-8, UTF-16LE, and UNICODE) for this file.","pos":[11340,11424]},{"content":"Leave this unspecified if you want ANSI encoding.","pos":[11425,11474]},{"pos":[11481,11725],"content":"Valid characters for the <ph id=\"ph1\">`mode`</ph> string used in <ph id=\"ph2\">`fopen_s`</ph> and <ph id=\"ph3\">`_fdopen`</ph> correspond to <ph id=\"ph4\">`oflag`</ph> arguments used in <bpt id=\"p1\">[</bpt>_open<ept id=\"p1\">](../../c-runtime-library/reference/open-wopen.md)</ept> and <bpt id=\"p2\">[</bpt>_sopen<ept id=\"p2\">](../../c-runtime-library/reference/sopen-wsopen.md)</ept>, as follows.","source":"Valid characters for the `mode` string used in `fopen_s` and `_fdopen` correspond to `oflag` arguments used in [_open](../../c-runtime-library/reference/open-wopen.md) and [_sopen](../../c-runtime-library/reference/sopen-wsopen.md), as follows."},{"content":"Characters in mode string","pos":[11732,11757]},{"pos":[11758,11803],"content":"Equivalent <ph id=\"ph1\">`oflag`</ph> value for <ph id=\"ph2\">`_open`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`_sopen`</ph>","source":"Equivalent `oflag` value for `_open`/`_sopen`"},{"pos":[11901,11985],"content":"<ph id=\"ph1\">`_O_WRONLY &amp;#124; _O_APPEND`</ph> (usually <ph id=\"ph2\">`_O_WRONLY &amp;#124; _O_CREAT &amp;#124;``_O_APPEND`</ph>)","source":"`_O_WRONLY &#124; _O_APPEND` (usually `_O_WRONLY &#124; _O_CREAT &#124;``_O_APPEND`)"},{"pos":[11995,12075],"content":"<ph id=\"ph1\">`_O_RDWR &amp;#124; _O_APPEND`</ph> (usually <ph id=\"ph2\">`_O_RDWR &amp;#124; _O_APPEND &amp;#124; _O_CREAT`</ph> )","source":"`_O_RDWR &#124; _O_APPEND` (usually `_O_RDWR &#124; _O_APPEND &#124; _O_CREAT` )"},{"pos":[12123,12189],"content":"<ph id=\"ph1\">`_O_WRONLY`</ph> (usually <ph id=\"ph2\">`_O_WRONLY &amp;#124;``_O_CREAT &amp;#124; _O_TRUNC`</ph>)","source":"`_O_WRONLY` (usually `_O_WRONLY &#124;``_O_CREAT &#124; _O_TRUNC`)"},{"pos":[12199,12260],"content":"<ph id=\"ph1\">`_O_RDWR`</ph> (usually <ph id=\"ph2\">`_O_RDWR &amp;#124; _O_CREAT &amp;#124; _O_TRUNC`</ph>)","source":"`_O_RDWR` (usually `_O_RDWR &#124; _O_CREAT &#124; _O_TRUNC`)"},{"content":"None","pos":[12307,12311]},{"content":"None","pos":[12320,12324]},{"pos":[12508,12698],"content":"If you are using <ph id=\"ph1\">`rb`</ph> mode, won't need to port your code, and expect to read a lot of the file and/or don't care about network performance, memory mapped Win32 files might also be an option.","source":"If you are using `rb` mode, won't need to port your code, and expect to read a lot of the file and/or don't care about network performance, memory mapped Win32 files might also be an option."},{"pos":[12707,12719],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Function","pos":[12726,12734]},{"content":"Required header","pos":[12735,12750]},{"content":"<ph id=\"ph1\">\\&lt;</ph>stdio.h&gt;","pos":[12806,12816],"source":"\\<stdio.h>"},{"content":"<ph id=\"ph1\">\\&lt;</ph>stdio.h&gt; or <ph id=\"ph2\">\\&lt;</ph>wchar.h&gt;","pos":[12833,12857],"source":"\\<stdio.h> or \\<wchar.h>"},{"pos":[12865,12989],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[12998,13007],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[13011,13103],"content":"All versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md)."},{"pos":[13110,13257],"content":"The <ph id=\"ph1\">`c`</ph>, <ph id=\"ph2\">`n`</ph>, and <ph id=\"ph3\">`t`</ph> <ph id=\"ph4\">`mode`</ph> options are Microsoft extensions for <ph id=\"ph5\">`fopen_s`</ph> and <ph id=\"ph6\">`_fdopen`</ph> and should not be used where ANSI portability is desired.","source":"The `c`, `n`, and `t` `mode` options are Microsoft extensions for `fopen_s` and `_fdopen` and should not be used where ANSI portability is desired."},{"pos":[13266,13273],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14693,14718],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"pos":[14728,14819],"content":"<bpt id=\"p1\">[</bpt>System::IO::File::Open<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.io.file.open.aspx)</ept>","source":"[System::IO::File::Open](https://msdn.microsoft.com/en-us/library/system.io.file.open.aspx)"},{"content":"&lt;xref:System.IO.FileStream.%23ctor%2A&gt;","pos":[14829,14867],"source":"<xref:System.IO.FileStream.%23ctor%2A>"},{"pos":[14876,14884],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Stream I/O<ept id=\"p1\">](../../c-runtime-library/stream-i-o.md)</ept><ph id=\"ph1\"> </ph>","pos":[14888,14940],"source":"[Stream I/O](../../c-runtime-library/stream-i-o.md) "},{"content":"<bpt id=\"p1\"> [</bpt>fclose, _fcloseall<ept id=\"p1\">](../../c-runtime-library/reference/fclose-fcloseall.md)</ept><ph id=\"ph1\"> </ph>","pos":[14943,15020],"source":" [fclose, _fcloseall](../../c-runtime-library/reference/fclose-fcloseall.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_fdopen, _wfdopen<ept id=\"p1\">](../../c-runtime-library/reference/fdopen-wfdopen.md)</ept><ph id=\"ph1\"> </ph>","pos":[15023,15097],"source":" [_fdopen, _wfdopen](../../c-runtime-library/reference/fdopen-wfdopen.md) "},{"content":"<bpt id=\"p1\"> [</bpt>ferror<ept id=\"p1\">](../../c-runtime-library/reference/ferror.md)</ept><ph id=\"ph1\"> </ph>","pos":[15100,15155],"source":" [ferror](../../c-runtime-library/reference/ferror.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_fileno<ept id=\"p1\">](../../c-runtime-library/reference/fileno.md)</ept><ph id=\"ph1\"> </ph>","pos":[15158,15214],"source":" [_fileno](../../c-runtime-library/reference/fileno.md) "},{"content":"<bpt id=\"p1\"> [</bpt>freopen, _wfreopen<ept id=\"p1\">](../../c-runtime-library/reference/freopen-wfreopen.md)</ept><ph id=\"ph1\"> </ph>","pos":[15217,15294],"source":" [freopen, _wfreopen](../../c-runtime-library/reference/freopen-wfreopen.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_open, _wopen<ept id=\"p1\">](../../c-runtime-library/reference/open-wopen.md)</ept><ph id=\"ph1\"> </ph>","pos":[15297,15363],"source":" [_open, _wopen](../../c-runtime-library/reference/open-wopen.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_setmode<ept id=\"p1\">](../../c-runtime-library/reference/setmode.md)</ept>","pos":[15366,15423],"source":" [_setmode](../../c-runtime-library/reference/setmode.md)"}],"content":"---\ntitle: \"fopen_s, _wfopen_s | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_wfopen_s\"\n  - \"fopen_s\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-stdio-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"fopen_s\"\n  - \"_tfopen_s\"\n  - \"_wfopen_s\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"_wfopen_s function\"\n  - \"opening files, for file I/O\"\n  - \"_tfopen_s function\"\n  - \"tfopen_s function\"\n  - \"wfopen_s function\"\n  - \"fopen_s function\"\n  - \"Unicode [C++], creating files\"\n  - \"Unicode [C++], writing files\"\n  - \"files [C++], opening\"\n  - \"Unicode [C++], files\"\nms.assetid: c534857e-39ee-4a3f-bd26-dfe551ac96c3\ncaps.latest.revision: 41\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# fopen_s, _wfopen_s\nOpens a file. These versions of [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md) have security enhancements, as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md).  \n  \n## Syntax  \n  \n```  \nerrno_t fopen_s(   \n   FILE** pFile,  \n   const char *filename,  \n   const char *mode   \n);  \nerrno_t _wfopen_s(  \n   FILE** pFile,  \n   const wchar_t *filename,  \n   const wchar_t *mode   \n);  \n```  \n  \n#### Parameters  \n [out] `pFile`  \n A pointer to the file pointer that will receive the pointer to the opened file.  \n  \n [in] `filename`  \n Filename.  \n  \n [in] `mode`  \n Type of access permitted.  \n  \n## Return Value  \n Zero if successful; an error code on failure. See [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md) for more information about these error codes.  \n  \n### Error Conditions  \n  \n|`pFile`|`filename`|`mode`|Return Value|Contents of`pFile`|  \n|-------------|----------------|------------|------------------|------------------------|  \n|`NULL`|any|any|`EINVAL`|unchanged|  \n|any|`NULL`|any|`EINVAL`|unchanged|  \n|any|any|NULL|`EINVAL`|unchanged|  \n  \n## Remarks  \n Files that are opened by `fopen_s` and `_wfopen_s` are not sharable. If you require that a file be sharable, use [_fsopen, _wfsopen](../../c-runtime-library/reference/fsopen-wfsopen.md) with the appropriate sharing mode constant—for example, `_SH_DENYNO` for read/write sharing.  \n  \n The `fopen_s` function opens the file that's specified by `filename`. `_wfopen_s` is a wide-character version of `fopen_s`; the arguments to `_wfopen_s` are wide-character strings. `_wfopen_s` and `fopen_s` behave identically otherwise.  \n  \n `fopen_s` accepts paths that are valid on the file system at the point of execution; UNC paths and paths that involve mapped network drives are accepted by `fopen_s` as long as the system that's executing the code has access to the share or mapped network drive at the time of execution. When you construct paths for `fopen_s`, don't make assumptions about the availability of drives, paths, or network shares in the execution environment. You can use either forward slashes (/) or backslashes (\\\\) as the directory separators in a path.  \n  \n These functions validate their parameters. If `pFile`, `filename`, or `mode` is a null pointer, these functions generate an invalid parameter exception, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md).  \n  \n Always check the return value to see if the function succeeded before you perform any further operations on the file. If an error occurs, the error code is returned and the global variable `errno` is set. For more information, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n## Unicode support  \n `fopen_s` supports Unicode file streams. To open a new or existing Unicode file, pass a `ccs` flag that specifies the desired encoding to `fopen_s`:  \n  \n `fopen_s(&fp, \"newfile.txt\", \"rw,`   `ccs=`  `encoding` `\");`  \n  \n Allowed values of `encoding` are `UNICODE`, `UTF-8`, and `UTF-16LE`. If there no value is specified for `encoding`, `fopen_s` uses ANSI encoding.  \n  \n If the file already exists and is opened for reading or appending, the Byte Order Mark (BOM), if present in the file, determines the encoding. The BOM encoding takes precedence over the encoding that's specified by the `ccs` flag. The `ccs` encoding is only used when no BOM is present or if the file is a new file.  \n  \n> [!NOTE]\n>  BOM-detection only applies to files that are opened in Unicode mode; that is, by passing the `ccs` flag.  \n  \n The following table summarizes the modes for various `ccs` flags that are given to `fopen_s` and for Byte Order Marks in the file.  \n  \n### Encodings Used Based on ccs Flag and BOM  \n  \n|`ccs` flag|No BOM (or new file)|BOM: UTF-8|BOM: UTF-16|  \n|----------------|----------------------------|-----------------|------------------|  \n|`UNICODE`|`UTF-16LE`|`UTF-8`|`UTF-16LE`|  \n|`UTF-8`|`UTF-8`|`UTF-8`|`UTF-16LE`|  \n|`UTF-16LE`|`UTF-16LE`|`UTF-8`|`UTF-16LE`|  \n  \n Files that are opened for writing in Unicode mode have a BOM written to them automatically.  \n  \n If `mode` is \"`a, ccs=<encoding>`\", `fopen_s` first tries to open the file with both read access and write access. If successful, the function reads the BOM to determine the encoding for the file; if unsuccessful, the function uses the default encoding for the file. In either case, `fopen_s` then re-opens the file with write-only access. (This applies to `a` mode only, not `a+`.)  \n  \n### Generic-Text Routine Mappings  \n  \n|TCHAR.H routine|_UNICODE & _MBCS not defined|_MBCS defined|_UNICODE defined|  \n|---------------------|------------------------------------|--------------------|-----------------------|  \n|`_tfopen_s`|`fopen_s`|`fopen_s`|`_wfopen_s`|  \n  \n The character string `mode` specifies the kind of access that's requested for the file, as follows.  \n  \n `\"r\"`  \n Opens for reading. If the file does not exist or cannot be found, the `fopen_s` call fails.  \n  \n `\"w\"`  \n Opens an empty file for writing. If the file exists, its contents are destroyed.  \n  \n `\"a\"`  \n Opens for writing at the end of the file (appending) without removing the EOF marker before writing new data to the file. Creates the file if it doesn't exist.  \n  \n `\"r+\"`  \n Opens for both reading and writing. (The file must exist.)  \n  \n `\"w+\"`  \n Opens an empty file for both reading and writing. If the file exists, its contents are destroyed.  \n  \n `\"a+\"`  \n Opens for reading and appending. The appending operation includes the removal of the EOF marker before new data is written to the file and the EOF marker is restored after writing is complete. Creates the file if it doesn't exist.  \n  \n When a file is opened by using the `\"a\"` or `\"a+\"` access type, all write operations occur at the end of the file. The file pointer can be repositioned by using `fseek` or `rewind`, but it's always moved back to the end of the file before any write operation is carried out so that existing data cannot be overwritten.  \n  \n The `\"a\"` mode does not remove the EOF marker before appending to the file. After appending has occurred, the MS-DOS TYPE command only shows data up to the original EOF marker and not any data that's appended to the file. The `\"a+\"` mode does remove the EOF marker before appending to the file. After appending, the MS-DOS TYPE command shows all data in the file. The `\"a+\"` mode is required for appending to a stream file that is terminated by using the CTRL+Z EOF marker.  \n  \n When the `\"r+\",``\"w+\",` or `\"a+\"` access type is specified, both reading and writing are allowed. (The file is said to be open for \"update\".) However, when you switch from reading to writing, the input operation must encounter an EOF marker. If there is no EOF, you must use an intervening call to a file-positioning function. The file-positioning functions are `fsetpos`, `fseek`, and `rewind`. When you switch from writing to reading, you must use an intervening call to either `fflush` or to a file-positioning function.  \n  \n In addition to the above values, the following characters can be included in `mode` to specify the translation mode for newline characters:  \n  \n `t`  \n Open in text (translated) mode. In this mode, CTRL+Z is interpreted as an end-of-file character on input. In files opened for reading/writing with `\"a+\"`, `fopen_s` checks for a CTRL+Z at the end of the file and removes it, if possible. This is done because using `fseek` and `ftell` to move within a file that ends with a CTRL+Z, may cause `fseek` to behave improperly near the end of the file.  \n  \n Also, in text mode, carriage return–linefeed combinations are translated into single linefeeds on input, and linefeed characters are translated to carriage return–linefeed combinations on output. When a Unicode stream-I/O function operates in text mode (the default), the source or destination stream is assumed to be a sequence of multibyte characters. Therefore, the Unicode stream-input functions convert multibyte characters to wide characters (as if by a call to the `mbtowc` function). For the same reason, the Unicode stream-output functions convert wide characters to multibyte characters (as if by a call to the `wctomb` function).  \n  \n `b`  \n Open in binary (untranslated) mode; translations involving carriage-return and linefeed characters are suppressed.  \n  \n If `t` or `b` is not given in `mode`, the default translation mode is defined by the global variable [_fmode](../../c-runtime-library/fmode.md). If `t` or `b` is prefixed to the argument, the function fails and returns `NULL`.  \n  \n For more information about using text and binary modes in Unicode and multibyte stream-I/O, see [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md) and [Unicode Stream I/O in Text and Binary Modes](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).  \n  \n `c`  \n Enable the commit flag for the associated `filename` so that the contents of the file buffer are written directly to disk if either `fflush` or `_flushall` is called.  \n  \n `n`  \n Reset the commit flag for the associated `filename` to \"no-commit.\" This is the default. It also overrides the global commit flag if you link your program with COMMODE.OBJ. The global commit flag default is \"no-commit\" unless you explicitly link your program with COMMODE.OBJ (see [Link Options](../../c-runtime-library/link-options.md)).  \n  \n `N`  \n Specifies that the file is not inherited by child processes.  \n  \n `S`  \n Specifies that caching is optimized for, but not restricted to, sequential access from disk.  \n  \n `R`  \n Specifies that caching is optimized for, but not restricted to, random access from disk.  \n  \n `T`  \n Specifies a file as temporary. If possible, it is not flushed to disk.  \n  \n `D`  \n Specifies a file as temporary. It is deleted when the last file pointer is closed.  \n  \n `ccs=ENCODING`  \n Specify the coded character set to use (UTF-8, UTF-16LE, and UNICODE) for this file. Leave this unspecified if you want ANSI encoding.  \n  \n Valid characters for the `mode` string used in `fopen_s` and `_fdopen` correspond to `oflag` arguments used in [_open](../../c-runtime-library/reference/open-wopen.md) and [_sopen](../../c-runtime-library/reference/sopen-wsopen.md), as follows.  \n  \n|Characters in mode string|Equivalent `oflag` value for `_open`/`_sopen`|  \n|-------------------------------|----------------------------------------------------|  \n|`a`|`_O_WRONLY &#124; _O_APPEND` (usually `_O_WRONLY &#124; _O_CREAT &#124;``_O_APPEND`)|  \n|`a+`|`_O_RDWR &#124; _O_APPEND` (usually `_O_RDWR &#124; _O_APPEND &#124; _O_CREAT` )|  \n|`r`|`_O_RDONLY`|  \n|`r+`|`_O_RDWR`|  \n|`w`|`_O_WRONLY` (usually `_O_WRONLY &#124;``_O_CREAT &#124; _O_TRUNC`)|  \n|`w+`|`_O_RDWR` (usually `_O_RDWR &#124; _O_CREAT &#124; _O_TRUNC`)|  \n|`b`|`_O_BINARY`|  \n|`t`|`_O_TEXT`|  \n|`c`|None|  \n|`n`|None|  \n|`S`|`_O_SEQUENTIAL`|  \n|`R`|`_O_RANDOM`|  \n|`T`|`_O_SHORTLIVED`|  \n|`D`|`_O_TEMPORARY`|  \n|`ccs=UNICODE`|`_O_WTEXT`|  \n|`ccs=UTF-8`|`_O_UTF8`|  \n|`ccs=UTF-16LE`|`_O_UTF16`|  \n  \n If you are using `rb` mode, won't need to port your code, and expect to read a lot of the file and/or don't care about network performance, memory mapped Win32 files might also be an option.  \n  \n## Requirements  \n  \n|Function|Required header|  \n|--------------|---------------------|  \n|`fopen_s`|\\<stdio.h>|  \n|`_wfopen_s`|\\<stdio.h> or \\<wchar.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Libraries  \n All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md).  \n  \n The `c`, `n`, and `t` `mode` options are Microsoft extensions for `fopen_s` and `_fdopen` and should not be used where ANSI portability is desired.  \n  \n## Example  \n  \n```  \n  \n      // crt_fopen_s.c  \n// This program opens two files. It uses  \n// fclose to close the first file and  \n// _fcloseall to close all remaining files.  \n  \n#include <stdio.h>  \n  \nFILE *stream, *stream2;  \n  \nint main( void )  \n{  \n   errno_t err;  \n  \n   // Open for read (will fail if file \"crt_fopen_s.c\" does not exist)  \n   err  = fopen_s( &stream, \"crt_fopen_s.c\", \"r\" );  \n   if( err == 0 )  \n   {  \n      printf( \"The file 'crt_fopen_s.c' was opened\\n\" );  \n   }  \n   else  \n   {  \n      printf( \"The file 'crt_fopen_s.c' was not opened\\n\" );  \n   }  \n  \n   // Open for write   \n   err = fopen_s( &stream2, \"data2\", \"w+\" );  \n   if( err == 0 )  \n   {  \n      printf( \"The file 'data2' was opened\\n\" );  \n   }  \n   else  \n   {  \n      printf( \"The file 'data2' was not opened\\n\" );  \n   }  \n  \n   // Close stream if it is not NULL   \n   if( stream )  \n   {  \n      err = fclose( stream );  \n      if ( err == 0 )  \n      {  \n         printf( \"The file 'crt_fopen_s.c' was closed\\n\" );  \n      }  \n      else  \n      {  \n         printf( \"The file 'crt_fopen_s.c' was not closed\\n\" );  \n      }  \n   }  \n  \n   // All other files are closed:  \n   int numclosed = _fcloseall( );  \n   printf( \"Number of files closed by _fcloseall: %u\\n\", numclosed );  \n}  \n```  \n  \n```Output  \nThe file 'crt_fopen_s.c' was opened  \nThe file 'data2' was opened  \nNumber of files closed by _fcloseall: 1  \n```  \n  \n## .NET Framework Equivalent  \n  \n-   [System::IO::File::Open](https://msdn.microsoft.com/en-us/library/system.io.file.open.aspx)  \n  \n-   <xref:System.IO.FileStream.%23ctor%2A>  \n  \n## See Also  \n [Stream I/O](../../c-runtime-library/stream-i-o.md)   \n [fclose, _fcloseall](../../c-runtime-library/reference/fclose-fcloseall.md)   \n [_fdopen, _wfdopen](../../c-runtime-library/reference/fdopen-wfdopen.md)   \n [ferror](../../c-runtime-library/reference/ferror.md)   \n [_fileno](../../c-runtime-library/reference/fileno.md)   \n [freopen, _wfreopen](../../c-runtime-library/reference/freopen-wfreopen.md)   \n [_open, _wopen](../../c-runtime-library/reference/open-wopen.md)   \n [_setmode](../../c-runtime-library/reference/setmode.md)"}