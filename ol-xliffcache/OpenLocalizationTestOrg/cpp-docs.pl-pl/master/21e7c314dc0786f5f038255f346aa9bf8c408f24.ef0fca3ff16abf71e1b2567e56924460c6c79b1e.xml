{"nodes":[{"pos":[12,71],"content":"How to: Use Tracking References in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Tracking References in C++-CLI | Microsoft Docs","pos":[0,59]}]},{"content":"How to: Use Tracking References in C++/CLI","pos":[612,654]},{"pos":[655,831],"content":"This article shows how to use a tracking reference (%) in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph> to pass common language runtime (CLR) types by reference.","source":"This article shows how to use a tracking reference (%) in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)] to pass common language runtime (CLR) types by reference."},{"content":"To pass CLR types by reference","pos":[840,870]},{"content":"The following sample shows how to use a tracking reference to pass CLR types by reference.","pos":[874,964]},{"content":"Output","pos":[1840,1846]},{"pos":[1891,2103],"content":"The next sample shows that taking the address of a tracking reference returns an <bpt id=\"p1\">[</bpt>interior_ptr (C++/CLI)<ept id=\"p1\">](../windows/interior-ptr-cpp-cli.md)</ept>, and shows how to modify and access data through a tracking reference.","source":"The next sample shows that taking the address of a tracking reference returns an [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md), and shows how to modify and access data through a tracking reference."},{"content":"Output","pos":[2987,2993]},{"content":"Tracking references and interior pointers","pos":[3057,3098]},{"content":"The following code sample shows that you can convert between tracking references and interior pointers.","pos":[3102,3205]},{"content":"Output","pos":[4094,4100]},{"content":"Tracking references and value types","pos":[4164,4199]},{"content":"This sample shows simple boxing through a tracking reference to a value type:","pos":[4203,4280]},{"content":"The next sample shows that you can have both tracking references and native references to value types.","pos":[4492,4594]},{"content":"Output","pos":[4919,4925]},{"content":"The following sample shows that you can use tracking references together with value types and native types.","pos":[4970,5077]},{"content":"Output","pos":[5492,5498]},{"content":"This sample shows that you can bind a tracking reference to a value type on the garbage-collected heap:","pos":[5544,5647]},{"content":"Output","pos":[6604,6610]},{"content":"Template functions that take native, value, or reference parameters","pos":[6811,6878]},{"content":"By using a tracking reference in the signature of a template function, you ensure that the function can be called by a parameter whose type is native, CLR value, or CLR reference.","pos":[6882,7061]},{"content":"Output","pos":[7838,7844]},{"content":"See Also","pos":[7894,7902]},{"content":"Tracking Reference Operator","pos":[7907,7934]}],"content":"---\ntitle: \"How to: Use Tracking References in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CLR types, passing by reference\"\nms.assetid: d91e471c-34ff-4786-9e0d-c6db0494b946\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Use Tracking References in C++/CLI\nThis article shows how to use a tracking reference (%) in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)] to pass common language runtime (CLR) types by reference.  \n  \n## To pass CLR types by reference  \n The following sample shows how to use a tracking reference to pass CLR types by reference.  \n  \n```  \n  \n      // tracking_reference_handles.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref struct City {  \nprivate:  \n   Int16 zip_;  \n  \npublic:  \n   City (int zip) : zip_(zip) {};  \n   property Int16 zip {  \n      Int16 get(void) {  \n         return zip_;  \n      }   // get  \n   }   // property  \n};  \n  \nvoid passByRef (City ^% myCity) {  \n   // cast required so this pointer in City struct is \"const City\"  \n   if (myCity->zip == 20100)  \n      Console::WriteLine(\"zip == 20100\");  \n   else  \n      Console::WriteLine(\"zip != 20100\");  \n}  \n  \nref class G {  \npublic:  \n   int i;  \n};  \n  \nvoid Test(int % i) {  \n   i++;  \n}  \n  \nint main() {  \n   G ^ g1 = gcnew G;  \n   G ^% g2 = g1;  \n   g1 -> i = 12;  \n  \n   Test(g2->i);   // g2->i will be changed in Test2()  \n  \n   City ^ Milano = gcnew City(20100);  \n   passByRef(Milano);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nzip == 20100  \n```  \n  \n The next sample shows that taking the address of a tracking reference returns an [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md), and shows how to modify and access data through a tracking reference.  \n  \n```  \n// tracking_reference_data.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic ref class R {  \npublic:  \n   R(int i) : m_i(i) {  \n      Console::WriteLine(\"ctor: R(int)\");  \n   }  \n  \n   int m_i;  \n};  \n  \nclass N {  \npublic:  \n   N(int i) : m_i (i) {  \n      Console::WriteLine(\"ctor: N(int i)\");  \n   }  \n  \n   int m_i;  \n};  \n  \nint main() {  \n   R ^hr = gcnew R('r');  \n   R ^%thr = hr;  \n   N n('n');  \n   N %tn = n;  \n  \n   // Declare interior pointers  \n   interior_ptr<R^> iphr = &thr;  \n   interior_ptr<N> ipn = &tn;  \n  \n   // Modify data through interior pointer  \n   (*iphr)->m_i = 1;   // (*iphr)->m_i == thr->m_i  \n   ipn->m_i = 4;   // ipn->m_i == tn.m_i  \n  \n   ++thr-> m_i;   // hr->m_i == thr->m_i  \n   ++tn. m_i;   // n.m_i == tn.m_i  \n  \n   ++hr-> m_i;   // (*iphr)->m_i == hr->m_i  \n   ++n. m_i;   // ipn->m_i == n.m_i  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nctor: R(int)  \nctor: N(int i)  \n```  \n  \n## Tracking references and interior pointers  \n The following code sample shows that you can convert between tracking references and interior pointers.  \n  \n```  \n// tracking_reference_interior_ptr.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic ref class R {  \npublic:  \n   R(int i) : m_i(i) {  \n      Console::WriteLine(\"ctor: R(int)\");  \n   }  \n  \n   int m_i;  \n};  \n  \nclass N {  \npublic:  \n   N(int i) : m_i(i) {  \n      Console::WriteLine(\"ctor: N(int i)\");  \n   }  \n  \n   int m_i;  \n};  \n  \nint main() {  \n   R ^hr = gcnew R('r');  \n   N n('n');  \n  \n   R ^%thr = hr;  \n   N %tn = n;  \n  \n   // Declare interior pointers  \n   interior_ptr<R^> iphr = &hr;  \n   interior_ptr<N> ipn = &n;  \n  \n   // Modify data through interior pointer  \n   (*iphr)->m_i = 1;   // (*iphr)-> m_i == thr->m_i  \n   ipn->m_i = 4;   // ipn->m_i == tn.m_i  \n  \n   ++thr->m_i;   // hr->m_i == thr->m_i  \n   ++tn.m_i;   // n.m_i == tn.m_i  \n  \n   ++hr->m_i;   // (*iphr)->m_i == hr->m_i  \n   ++n.m_i;   // ipn->m_i == n.m_i  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nctor: R(int)  \nctor: N(int i)  \n```  \n  \n## Tracking references and value types  \n This sample shows simple boxing through a tracking reference to a value type:  \n  \n```  \n// tracking_reference_valuetypes_1.cpp// compile with: /clrusing namespace System;int main() {   int i = 10;   int % j = i;   Object ^ o = j;   // j is implicitly boxed and assigned to o}  \n```  \n  \n The next sample shows that you can have both tracking references and native references to value types.  \n  \n```  \n// tracking_reference_valuetypes_2.cpp  \n// compile with: /clr  \nusing namespace System;  \nint main() {  \n   int i = 10;  \n   int & j = i;  \n   int % k = j;  \n   i++;   // 11  \n   j++;   // 12  \n   k++;   // 13  \n   Console::WriteLine(i);  \n   Console::WriteLine(j);  \n   Console::WriteLine(k);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n13  \n13  \n13  \n```  \n  \n The following sample shows that you can use tracking references together with value types and native types.  \n  \n```  \n// tracking_reference_valuetypes_3.cpp  \n// compile with: /clr  \nvalue struct G {  \n   int i;  \n};  \n  \nstruct H {  \n   int i;  \n};  \n  \nint main() {  \n   G g;  \n   G % v = g;  \n   v.i = 4;  \n   System::Console::WriteLine(v.i);  \n   System::Console::WriteLine(g.i);  \n  \n   H h;  \n   H % w = h;  \n   w.i = 5;  \n   System::Console::WriteLine(w.i);  \n   System::Console::WriteLine(h.i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n4  \n4  \n5  \n5  \n```  \n  \n This sample shows that you can bind a tracking reference to a value type on the garbage-collected heap:  \n  \n```  \n// tracking_reference_valuetypes_4.cpp  \n// compile with: /clr  \nusing namespace System;  \nvalue struct V {  \n   int i;  \n};  \n  \nvoid Test(V^ hV) {   // hv boxes another copy of original V on GC heap  \n   Console::WriteLine(\"Boxed new copy V: {0}\", hV->i);  \n}  \n  \nint main() {  \n   V v;   // V on the stack  \n   v.i = 1;  \n   V ^hV1 = v;   // v is boxed and assigned to hV1  \n   v.i = 2;  \n   V % trV = *hV1;   // trV is bound to boxed v, the v on the gc heap.  \n   Console::WriteLine(\"Original V: {0}, Tracking reference to boxed V: {1}\", v.i, trV.i);  \n   V ^hV2 = trV;   // hv2 boxes another copy of boxed v on the GC heap  \n   hV2->i = 3;  \n   Console::WriteLine(\"Tracking reference to boxed V: {0}\", hV2->i);  \n   Test(trV);  \n   v.i = 4;  \n   V ^% trhV = hV1;  // creates tracking reference to boxed type handle  \n   Console::WriteLine(\"Original V: {0}, Reference to handle of originally boxed V: {1}\", v.i, trhV->i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nOriginal V: 2, Tracking reference to boxed V: 1  \nTracking reference to boxed V: 3  \nBoxed new copy V: 1  \nOriginal V: 4, Reference to handle of originally boxed V: 1  \n```  \n  \n## Template functions that take native, value, or reference parameters  \n By using a tracking reference in the signature of a template function, you ensure that the function can be called by a parameter whose type is native, CLR value, or CLR reference.  \n  \n```  \n// tracking_reference_template.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nclass Temp {  \npublic:  \n   // template functions  \n   template<typename T>  \n   static int f1(T% tt) {   // works for object in any location  \n      Console::WriteLine(\"T %\");  \n      return 0;  \n   }  \n  \n   template<typename T>  \n   static int f2(T& rt) {   // won't work for object on the gc heap  \n      Console::WriteLine(\"T &\");  \n      return 1;  \n   }  \n};  \n  \n// Class Defintions  \nref struct R {  \n   int i;  \n};  \n  \nint main() {  \n   R ^hr = gcnew R;  \n   int i = 1;  \n  \n   Temp::f1(i); // ok  \n   Temp::f1(hr->i); // ok  \n   Temp::f2(i); // ok  \n  \n   // error can't track object on gc heap with a native reference  \n   // Temp::f2(hr->i);   \n}  \n```  \n  \n **Output**  \n  \n```Output  \nT %  \nT %  \nT &  \n```  \n  \n## See Also  \n [Tracking Reference Operator](../windows/tracking-reference-operator-cpp-component-extensions.md)"}