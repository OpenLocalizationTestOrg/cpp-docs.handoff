{"nodes":[{"pos":[12,68],"content":"B. Stubs for Run-time Library Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"B. Stubs for Run-time Library Functions | Microsoft Docs","pos":[0,56],"nodes":[{"content":"B.","pos":[0,2]},{"content":"Stubs for Run-time Library Functions | Microsoft Docs","pos":[3,56]}]}]},{"content":"B.","pos":[548,550]},{"content":"Stubs for Run-time Library Functions","pos":[551,587]},{"content":"This section provides stubs for the run-time library functions defined in the OpenMP C and C++ API.","pos":[588,687]},{"content":"The stubs are provided to enable portability to platforms that do not support the OpenMP C and C++ API.","pos":[688,791]},{"content":"On these platforms, OpenMP programs must be linked with a library containing these stub functions.","pos":[792,890]},{"content":"The stub functions assume that the directives in the OpenMP program are ignored.","pos":[891,971]},{"content":"As such, they emulate serial semantics.","pos":[972,1011]},{"pos":[1019,1367],"content":"[!NOTE]\n The lock variable that appears in the lock functions must be accessed exclusively through these functions. It should not be initialized or otherwise modified in the user program. Users should not make assumptions about mechanisms used by OpenMP C and C++ implementations to implement locks based on the scheme used by the stub functions.","leadings":["","> "],"nodes":[{"content":" The lock variable that appears in the lock functions must be accessed exclusively through these functions. It should not be initialized or otherwise modified in the user program. Users should not make assumptions about mechanisms used by OpenMP C and C++ implementations to implement locks based on the scheme used by the stub functions.","pos":[8,346],"nodes":[{"content":"The lock variable that appears in the lock functions must be accessed exclusively through these functions.","pos":[1,107]},{"content":"It should not be initialized or otherwise modified in the user program.","pos":[108,179]},{"content":"Users should not make assumptions about mechanisms used by OpenMP C and C++ implementations to implement locks based on the scheme used by the stub functions.","pos":[180,338]}]}]},{"content":"Code","pos":[1377,1381]}],"content":"---\ntitle: \"B. Stubs for Run-time Library Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: fdfdabe0-f678-4551-80d5-827b62354427\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# B. Stubs for Run-time Library Functions\nThis section provides stubs for the run-time library functions defined in the OpenMP C and C++ API. The stubs are provided to enable portability to platforms that do not support the OpenMP C and C++ API. On these platforms, OpenMP programs must be linked with a library containing these stub functions. The stub functions assume that the directives in the OpenMP program are ignored. As such, they emulate serial semantics.  \n  \n> [!NOTE]\n>  The lock variable that appears in the lock functions must be accessed exclusively through these functions. It should not be initialized or otherwise modified in the user program. Users should not make assumptions about mechanisms used by OpenMP C and C++ implementations to implement locks based on the scheme used by the stub functions.  \n  \n### Code  \n  \n```  \n#include <stdio.h>  \n#include <stdlib.h>  \n#include \"omp.h\"  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  \n  \nvoid omp_set_num_threads(int num_threads)  \n{  \n}  \nint omp_get_num_threads(void)  \n{  \n    return 1;  \n}  \nint omp_get_max_threads(void)  \n{  \n    return 1;  \n}  \nint omp_get_thread_num(void)  \n{  \n    return 0;  \n}  \nint omp_get_num_procs(void)  \n{  \n    return 1;  \n}  \nvoid omp_set_dynamic(int dynamic_threads)  \n{  \n}  \nint omp_get_dynamic(void)  \n{  \n    return 0;  \n}  \nint omp_in_parallel(void)  \n{  \n    return 0;  \n}  \nvoid omp_set_nested(int nested)  \n{  \n}  \nint omp_get_nested(void)  \n{  \n    return 0;  \n}  \nenum {UNLOCKED = -1, INIT, LOCKED};  \nvoid omp_init_lock(omp_lock_t *lock)  \n{  \n    *lock = UNLOCKED;  \n}  \nvoid omp_destroy_lock(omp_lock_t *lock)  \n{  \n    *lock = INIT;  \n}  \nvoid omp_set_lock(omp_lock_t *lock)  \n{  \n    if (*lock == UNLOCKED)   \n    {  \n        *lock = LOCKED;  \n    }   \n    else   \n        if (*lock == LOCKED)   \n        {  \n         fprintf_s(stderr, \"error: deadlock in using lock variable\\n\");  \n         exit(1);  \n        } else {  \n         fprintf_s(stderr, \"error: lock not initialized\\n\");  \n         exit(1);  \n        }  \n}  \n  \nvoid omp_unset_lock(omp_lock_t *lock)  \n{  \n    if (*lock == LOCKED)   \n    {  \n        *lock = UNLOCKED;  \n    }   \n    else   \n        if (*lock == UNLOCKED)   \n        {  \n            fprintf_s(stderr, \"error: lock not set\\n\");  \n            exit(1);  \n        } else {  \n            fprintf_s(stderr, \"error: lock not initialized\\n\");  \n            exit(1);  \n        }  \n}  \n  \nint omp_test_lock(omp_lock_t *lock)  \n{  \n    if (*lock == UNLOCKED)   \n    {  \n        *lock = LOCKED;  \n        return 1;  \n    } else if (*lock == LOCKED) {  \n        return 0;  \n    } else {  \n        fprintf_s(stderr, \"error: lock not initialized\\n\");  \n        exit(1);  \n    }  \n}  \n  \n#ifndef OMP_NEST_LOCK_T  \ntypedef struct {  // This really belongs in omp.h   \n    int owner;  \n    int count;  \n} omp_nest_lock_t;  \n#endif  \nenum {MASTER = 0};  \nvoid omp_init_nest_lock(omp_nest_lock_t *lock)  \n{  \n    lock->owner = UNLOCKED;  \n    lock->count = 0;  \n}  \nvoid omp_destroy_nest_lock(omp_nest_lock_t *lock)  \n{  \n    lock->owner = UNLOCKED;  \n    lock->count = UNLOCKED;  \n}  \n  \nvoid omp_set_nest_lock(omp_nest_lock_t *lock)  \n{  \n    if (lock->owner == MASTER && lock->count >= 1)   \n    {  \n        lock->count++;  \n    } else   \n        if (lock->owner == UNLOCKED && lock->count == 0)   \n        {  \n            lock->owner = MASTER;  \n            lock->count = 1;  \n        } else   \n        {  \n       fprintf_s(stderr, \"error: lock corrupted or not initialized\\n\");  \n         exit(1);  \n    }  \n}  \n  \nvoid omp_unset_nest_lock(omp_nest_lock_t *lock)  \n{  \n    if (lock->owner == MASTER && lock->count >= 1)   \n    {  \n        lock->count--;  \n        if (lock->count == 0)   \n        {  \n            lock->owner = UNLOCKED;  \n        }  \n    } else   \n        if (lock->owner == UNLOCKED && lock->count == 0)   \n        {  \n            fprintf_s(stderr, \"error: lock not set\\n\");  \n            exit(1);  \n        } else   \n        {  \n       fprintf_s(stderr, \"error: lock corrupted or not initialized\\n\");  \n       exit(1);  \n    }  \n}  \n  \nint omp_test_nest_lock(omp_nest_lock_t *lock)  \n{  \n    omp_set_nest_lock(lock);  \n    return lock->count;  \n}  \n  \ndouble omp_get_wtime(void)  \n{  \n    // This function does not provide a working  \n    // wallclock timer. Replace it with a version  \n    // customized for the target machine.  \n    return 0.0;  \n}  \n  \ndouble omp_get_wtick(void)  \n{  \n    // This function does not provide a working  \n    // clock tick function. Replace it with  \n    // a version customized for the target machine.  \n    return 365. * 86400.;  \n}  \n  \n#ifdef __cplusplus  \n}  \n#endif  \n```"}