{"nodes":[{"pos":[12,41],"content":"Arrays (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Arrays (C++) | Microsoft Docs","pos":[0,29]}]},{"content":"Arrays (C++)","pos":[651,663]},{"content":"An array is a collection of like objects.","pos":[664,705]},{"content":"The simplest case of an array is a vector, which may be declared by the following sequence:","pos":[706,797]},{"content":"The declaration specifier:","pos":[1056,1082]},{"content":"An optional storage class specifier.","pos":[1092,1128]},{"pos":[1138,1186],"content":"Optional <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and/or <ph id=\"ph1\">`volatile`</ph> specifiers.","source":"Optional **const** and/or `volatile` specifiers."},{"content":"The type name of the elements of the array.","pos":[1196,1239]},{"content":"The declarator:","pos":[1249,1264]},{"content":"The identifier.","pos":[1274,1289]},{"content":"A constant expression of integral type enclosed in brackets, <bpt id=\"p1\">**</bpt>[].<ept id=\"p1\">**</ept>","pos":[1299,1367],"source":"A constant expression of integral type enclosed in brackets, **[].**"},{"content":"If multiple dimensions are declared using additional brackets, the constant expression may be omitted on the first set of brackets.","pos":[1368,1499]},{"content":"Optional additional brackets enclosing constant expressions.","pos":[1509,1569]},{"content":"An optional initializer.","pos":[1579,1603]},{"content":"See <bpt id=\"p1\">[</bpt>Initializers<ept id=\"p1\">](../cpp/initializers.md)</ept>.","pos":[1605,1648],"source":"  See [Initializers](../cpp/initializers.md)."},{"content":"The number of elements in the array is given by the constant expression.","pos":[1655,1727]},{"content":"The first element in the array is the 0th element, and the last element is the (<bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept>-1) element, where <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> is the number of elements the array can contain.","pos":[1728,1882],"source":" The first element in the array is the 0th element, and the last element is the (*n*-1) element, where *n* is the number of elements the array can contain."},{"content":"The <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> must be of an integral type and must be greater than 0.","pos":[1883,1964],"source":" The *constant-expression* must be of an integral type and must be greater than 0."},{"content":"A zero-sized array is legal only when the array is the last field in a <ph id=\"ph1\">`struct`</ph> or <bpt id=\"p1\">**</bpt>union<ept id=\"p1\">**</ept> and when the Microsoft extensions (/Ze) are enabled.","pos":[1965,2110],"source":" A zero-sized array is legal only when the array is the last field in a `struct` or **union** and when the Microsoft extensions (/Ze) are enabled."},{"content":"The following example shows how to define an array at run time:","pos":[2117,2180]},{"pos":[2548,2690],"content":"Arrays are derived types and can therefore be constructed from any other derived or fundamental type except functions, references, and <ph id=\"ph1\">`void`</ph>.","source":"Arrays are derived types and can therefore be constructed from any other derived or fundamental type except functions, references, and `void`."},{"content":"Arrays constructed from other arrays are multidimensional arrays.","pos":[2697,2762]},{"content":"These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence.","pos":[2763,2870]},{"content":"For example, consider this declaration:","pos":[2871,2910]},{"pos":[2948,3100],"content":"It specifies an array of type <ph id=\"ph1\">`int`</ph>, conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:","source":"It specifies an array of type `int`, conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:"},{"content":"Conceptual layout of a multi&amp;#45;dimensional array","pos":[3109,3159],"source":"Conceptual layout of a multi&#45;dimensional array"},{"content":"Conceptual Layout of Multidimensional Array","pos":[3199,3242]},{"content":"In declarations of multidimensioned arrays that have an initializer list (as described in <bpt id=\"p1\">[</bpt>Initializers<ept id=\"p1\">](../cpp/initializers.md)</ept>), the constant expression that specifies the bounds for the first dimension can be omitted.","pos":[3249,3469],"source":"In declarations of multidimensioned arrays that have an initializer list (as described in [Initializers](../cpp/initializers.md)), the constant expression that specifies the bounds for the first dimension can be omitted."},{"content":"For example:","pos":[3470,3482]},{"content":"The preceding declaration defines an array that is three rows by four columns.","pos":[3788,3866]},{"content":"The rows represent factories and the columns represent markets to which the factories ship.","pos":[3867,3958]},{"content":"The values are the transportation costs from the factories to the markets.","pos":[3959,4033]},{"content":"The first dimension of the array is left out, but the compiler fills it in by examining the initializer.","pos":[4034,4138]},{"content":"Topics in this section:","pos":[4145,4168]},{"content":"Using Arrays","pos":[4179,4191]},{"content":"Arrays in Expressions","pos":[4231,4252]},{"content":"Interpretation of Subscript Operator","pos":[4297,4333]},{"content":"Indirection on Array Types","pos":[4393,4419]},{"content":"Ordering of C++ Arrays","pos":[4469,4491]},{"content":"Example","pos":[4535,4542]},{"content":"The technique of omitting the bounds specification for the first dimension of a multidimensional array can also be used in function declarations as follows:","pos":[4546,4702]},{"content":"Comments","pos":[6073,6081]},{"pos":[6085,6211],"content":"The function <ph id=\"ph1\">`FindMinToMkt`</ph> is written such that adding new factories does not require any code changes, just a recompilation.","source":"The function `FindMinToMkt` is written such that adding new factories does not require any code changes, just a recompilation."},{"content":"See Also","pos":[6220,6228]},{"content":"C++ Abstract Declarators","pos":[6233,6257]}],"content":"---\ntitle: \"Arrays (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"declaring arrays, about declaring arrays\"\n  - \"multidimensional arrays\"\n  - \"arrays [C++]\"\nms.assetid: 3f5986aa-485c-4ba4-9502-67e2ef924238\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Arrays (C++)\nAn array is a collection of like objects. The simplest case of an array is a vector, which may be declared by the following sequence:  \n  \n```  \n  \n      decl-specifier identifier [ constant-expression ]  \ndecl-specifier identifier []  \ndecl-specifier identifer [][ constant-expression] . . .  \ndecl-specifier identifier [ constant-expression ]  \n[ constant-expression ] . . .  \n```  \n  \n 1. The declaration specifier:  \n  \n-   An optional storage class specifier.  \n  \n-   Optional **const** and/or `volatile` specifiers.  \n  \n-   The type name of the elements of the array.  \n  \n 2. The declarator:  \n  \n-   The identifier.  \n  \n-   A constant expression of integral type enclosed in brackets, **[].** If multiple dimensions are declared using additional brackets, the constant expression may be omitted on the first set of brackets.  \n  \n-   Optional additional brackets enclosing constant expressions.  \n  \n 3. An optional initializer.  See [Initializers](../cpp/initializers.md).  \n  \n The number of elements in the array is given by the constant expression. The first element in the array is the 0th element, and the last element is the (*n*-1) element, where *n* is the number of elements the array can contain. The *constant-expression* must be of an integral type and must be greater than 0. A zero-sized array is legal only when the array is the last field in a `struct` or **union** and when the Microsoft extensions (/Ze) are enabled.  \n  \n The following example shows how to define an array at run time:  \n  \n```  \n// arrays.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   int size = 3, i = 0;  \n  \n   int* myarr = new int[size];  \n  \n   for (i = 0 ; i < size ; i++)  \n      myarr[i] = 10;  \n  \n   for (i = 0 ; i < size ; i++)  \n      printf_s(\"myarr[%d] = %d\\n\", i, myarr[i]);  \n  \n   delete [] myarr;  \n}  \n```  \n  \n Arrays are derived types and can therefore be constructed from any other derived or fundamental type except functions, references, and `void`.  \n  \n Arrays constructed from other arrays are multidimensional arrays. These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence. For example, consider this declaration:  \n  \n```  \nint i2[5][7];  \n```  \n  \n It specifies an array of type `int`, conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:  \n  \n ![Conceptual layout of a multi&#45;dimensional array](../cpp/media/vc38rc1.gif \"vc38RC1\")  \nConceptual Layout of Multidimensional Array  \n  \n In declarations of multidimensioned arrays that have an initializer list (as described in [Initializers](../cpp/initializers.md)), the constant expression that specifies the bounds for the first dimension can be omitted. For example:  \n  \n```  \n// arrays2.cpp  \n// compile with: /c  \nconst int cMarkets = 4;  \n// Declare a float that represents the transportation costs.  \ndouble TransportCosts[][cMarkets] = {   \n   { 32.19, 47.29, 31.99, 19.11 },  \n   { 11.29, 22.49, 33.47, 17.29 },  \n   { 41.97, 22.09,  9.76, 22.55 }  \n};  \n```  \n  \n The preceding declaration defines an array that is three rows by four columns. The rows represent factories and the columns represent markets to which the factories ship. The values are the transportation costs from the factories to the markets. The first dimension of the array is left out, but the compiler fills it in by examining the initializer.  \n  \n Topics in this section:  \n  \n-   [Using Arrays](../cpp/using-arrays-cpp.md)  \n  \n-   [Arrays in Expressions](../cpp/arrays-in-expressions.md)  \n  \n-   [Interpretation of Subscript Operator](../cpp/interpretation-of-subscript-operator.md)  \n  \n-   [Indirection on Array Types](../cpp/indirection-on-array-types.md)  \n  \n-   [Ordering of C++ Arrays](../cpp/ordering-of-cpp-arrays.md)  \n  \n## Example  \n The technique of omitting the bounds specification for the first dimension of a multidimensional array can also be used in function declarations as follows:  \n  \n```  \n// multidimensional_arrays.cpp  \n// compile with: /EHsc  \n// arguments: 3  \n#include <limits>   // Includes DBL_MAX  \n#include <iostream>  \n  \nconst int cMkts = 4, cFacts = 2;  \n  \n// Declare a float that represents the transportation costs  \ndouble TransportCosts[][cMkts] = {   \n   { 32.19, 47.29, 31.99, 19.11 },  \n   { 11.29, 22.49, 33.47, 17.29 },  \n   { 41.97, 22.09,  9.76, 22.55 }    \n};  \n  \n// Calculate size of unspecified dimension  \nconst int cFactories = sizeof TransportCosts /  \n                  sizeof( double[cMkts] );  \n  \ndouble FindMinToMkt( int Mkt, double myTransportCosts[][cMkts], int mycFacts);  \n  \nusing namespace std;  \n  \nint main( int argc, char *argv[] ) {  \n   double MinCost;  \n  \n   if (argv[1] == 0) {  \n      cout << \"You must specify the number of markets.\" << endl;  \n      exit(0);  \n   }  \n   MinCost = FindMinToMkt( *argv[1] - '0', TransportCosts, cFacts);  \n   cout << \"The minimum cost to Market \" << argv[1] << \" is: \"  \n       << MinCost << \"\\n\";  \n}  \n  \ndouble FindMinToMkt(int Mkt, double myTransportCosts[][cMkts], int mycFacts) {  \n   double MinCost = DBL_MAX;  \n  \n   for( int i = 0; i < cFacts; ++i )  \n      MinCost = (MinCost < TransportCosts[i][Mkt]) ?  \n         MinCost : TransportCosts[i][Mkt];  \n  \n   return MinCost;  \n}  \n```  \n  \n```Output  \nThe minimum cost to Market 3 is: 17.29  \n```  \n  \n## Comments  \n The function `FindMinToMkt` is written such that adding new factories does not require any code changes, just a recompilation.  \n  \n## See Also  \n [C++ Abstract Declarators](http://msdn.microsoft.com/en-us/e7e18c18-0cad-4450-942b-d27e1d4dd088)"}