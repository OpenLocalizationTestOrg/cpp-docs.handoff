{"nodes":[{"pos":[12,45],"content":"CUIntArray Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CUIntArray Class | Microsoft Docs","pos":[0,33]}]},{"content":"CUIntArray Class","pos":[695,711]},{"content":"Supports arrays of unsigned integers.","pos":[712,749]},{"content":"Syntax","pos":[758,764]},{"content":"Members","pos":[824,831]},{"content":"The member functions of <ph id=\"ph1\">`CUIntArray`</ph> are similar to the member functions of class <bpt id=\"p1\">[</bpt>CObArray<ept id=\"p1\">](../../mfc/reference/cobarray-class.md)</ept>.","pos":[835,967],"source":"The member functions of `CUIntArray` are similar to the member functions of class [CObArray](../../mfc/reference/cobarray-class.md)."},{"content":"Because of this similarity, you can use the <ph id=\"ph1\">`CObArray`</ph> reference documentation for member function specifics.","pos":[968,1077],"source":" Because of this similarity, you can use the `CObArray` reference documentation for member function specifics."},{"content":"Wherever you see a <ph id=\"ph1\">`CObject`</ph> pointer as a function parameter or return value, substitute a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept>.","pos":[1078,1178],"source":" Wherever you see a `CObject` pointer as a function parameter or return value, substitute a **UINT**."},{"content":"for example, translates to","pos":[1241,1267]},{"content":"Public Constructors","pos":[1331,1350]},{"content":"Name","pos":[1357,1361]},{"content":"Description","pos":[1362,1373]},{"content":"CObArray::CObArray","pos":[1412,1430]},{"content":"Constructs an empty array.","pos":[1490,1516]},{"content":"Public Methods","pos":[1527,1541]},{"content":"Name","pos":[1548,1552]},{"content":"Description","pos":[1553,1564]},{"content":"CObArray::Add","pos":[1603,1616]},{"content":"Adds an element to the end of the array; grows the array if necessary.","pos":[1671,1741]},{"content":"CObArray::Append","pos":[1747,1763]},{"content":"Appends another array to the array; grows the array if necessary.","pos":[1821,1886]},{"content":"CObArray::Copy","pos":[1892,1906]},{"content":"Copies another array to the array; grows the array if necessary.","pos":[1962,2026]},{"content":"CObArray::ElementAt","pos":[2032,2051]},{"content":"Returns a temporary reference to the element pointer within the array.","pos":[2112,2182]},{"content":"CObArray::FreeExtra","pos":[2188,2207]},{"content":"Frees all unused memory above the current upper bound.","pos":[2268,2322]},{"content":"CObArray::GetAt","pos":[2328,2343]},{"content":"Returns the value at a given index.","pos":[2400,2435]},{"content":"CObArray::GetCount","pos":[2441,2459]},{"content":"Gets the number of elements in this array.","pos":[2519,2561]},{"content":"CObArray::GetData","pos":[2567,2584]},{"content":"Allows access to elements in the array.","pos":[2643,2682]},{"content":"Can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[2683,2699],"source":" Can be **NULL**."},{"content":"CObArray::GetSize","pos":[2705,2722]},{"content":"Gets the number of elements in this array.","pos":[2781,2823]},{"content":"CObArray::GetUpperBound","pos":[2829,2852]},{"content":"Returns the largest valid index.","pos":[2917,2949]},{"content":"CObArray::InsertAt","pos":[2955,2973]},{"content":"Inserts an element (or all the elements in another array) at a specified index.","pos":[3033,3112]},{"content":"CObArray::IsEmpty","pos":[3118,3135]},{"content":"Determines if the array is empty.","pos":[3194,3227]},{"content":"CObArray::RemoveAll","pos":[3233,3252]},{"content":"Removes all the elements from this array.","pos":[3313,3354]},{"content":"CObArray::RemoveAt","pos":[3360,3378]},{"content":"Removes an element at a specific index.","pos":[3438,3477]},{"content":"CObArray::SetAt","pos":[3483,3498]},{"content":"Sets the value for a given index; array not allowed to grow.","pos":[3555,3615]},{"content":"CObArray::SetAtGrow","pos":[3621,3640]},{"content":"Sets the value for a given index; grows the array if necessary.","pos":[3701,3764]},{"content":"CObArray::SetSize","pos":[3770,3787]},{"content":"Sets the number of elements to be contained in this array.","pos":[3846,3904]},{"content":"Public Operators","pos":[3915,3931]},{"content":"Name","pos":[3938,3942]},{"content":"Description","pos":[3943,3954]},{"content":"CObArray::operator [ ]","pos":[3993,4015]},{"content":"Sets or gets the element at the specified index.","pos":[4078,4126]},{"content":"Remarks","pos":[4136,4143]},{"content":"An unsigned integer, or <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept>, differs from words and doublewords in that the physical size of a <bpt id=\"p2\">**</bpt>UINT<ept id=\"p2\">**</ept> can change depending on the target operating environment.","pos":[4147,4313],"source":"An unsigned integer, or **UINT**, differs from words and doublewords in that the physical size of a **UINT** can change depending on the target operating environment."},{"content":"A <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> is the same size as a doubleword.","pos":[4314,4358],"source":" A **UINT** is the same size as a doubleword."},{"content":"incorporates the <bpt id=\"p1\">[</bpt>IMPLEMENT_DYNAMIC<ept id=\"p1\">](run-time-object-model-services.md#implement_dynamic)</ept> macro to support run-time type access and dumping to a <bpt id=\"p2\">[</bpt>CDumpContext<ept id=\"p2\">](../../mfc/reference/cdumpcontext-class.md)</ept> object.","pos":[4378,4588],"source":" incorporates the [IMPLEMENT_DYNAMIC](run-time-object-model-services.md#implement_dynamic) macro to support run-time type access and dumping to a [CDumpContext](../../mfc/reference/cdumpcontext-class.md) object."},{"content":"If you need a dump of individual unsigned integer elements, you must set the depth of the dump context to 1 or greater.","pos":[4589,4708]},{"content":"Unsigned integer arrays cannot be serialized.","pos":[4709,4754]},{"pos":[4762,5044],"content":"[!NOTE]\n Before using an array, use `SetSize` to establish its size and allocate memory for it. If you do not use `SetSize`, adding elements to your array causes it to be frequently reallocated and copied. Frequent reallocation and copying are inefficient and can fragment memory.","leadings":["","> "],"nodes":[{"content":" Before using an array, use `SetSize` to establish its size and allocate memory for it. If you do not use `SetSize`, adding elements to your array causes it to be frequently reallocated and copied. Frequent reallocation and copying are inefficient and can fragment memory.","pos":[8,280],"nodes":[{"content":"Before using an array, use <ph id=\"ph1\">`SetSize`</ph> to establish its size and allocate memory for it.","pos":[1,87],"source":" Before using an array, use `SetSize` to establish its size and allocate memory for it."},{"content":"If you do not use <ph id=\"ph1\">`SetSize`</ph>, adding elements to your array causes it to be frequently reallocated and copied.","pos":[88,197],"source":" If you do not use `SetSize`, adding elements to your array causes it to be frequently reallocated and copied."},{"content":"Frequent reallocation and copying are inefficient and can fragment memory.","pos":[198,272]}]}]},{"pos":[5051,5151],"content":"For more information on using <ph id=\"ph1\">`CUIntArray`</ph>, see the article <bpt id=\"p1\">[</bpt>Collections<ept id=\"p1\">](../../mfc/collections.md)</ept>.","source":"For more information on using `CUIntArray`, see the article [Collections](../../mfc/collections.md)."},{"content":"Inheritance Hierarchy","pos":[5160,5181]},{"content":"CObject","pos":[5186,5193]},{"content":"Requirements","pos":[5260,5272]},{"pos":[5276,5297],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxcoll.h","source":"**Header:** afxcoll.h"},{"content":"See Also","pos":[5306,5314]},{"content":"CObject Class","pos":[5319,5332]},{"content":"Hierarchy Chart","pos":[5377,5392]}],"content":"---\ntitle: \"CUIntArray Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CUIntArray\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"INT\"\n  - \"UINT\"\n  - \"indexed arrays\"\n  - \"arrays [C++], indexed\"\n  - \"WORD data type\"\n  - \"CUIntArray class\"\nms.assetid: d71f3d8f-ef9f-4e48-9b69-7782c0e2ddf7\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CUIntArray Class\nSupports arrays of unsigned integers.  \n  \n## Syntax  \n  \n```  \nclass CUIntArray : public CObject  \n```  \n  \n## Members  \n The member functions of `CUIntArray` are similar to the member functions of class [CObArray](../../mfc/reference/cobarray-class.md). Because of this similarity, you can use the `CObArray` reference documentation for member function specifics. Wherever you see a `CObject` pointer as a function parameter or return value, substitute a **UINT**.  \n  \n `CObject* CObArray::GetAt( int <nIndex> ) const;`  \n  \n for example, translates to  \n  \n `UINT CUIntArray::GetAt( int <nIndex> ) const;`  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CObArray::CObArray](../../mfc/reference/cobarray-class.md#cobarray__cobarray)|Constructs an empty array.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CObArray::Add](../../mfc/reference/cobarray-class.md#cobarray__add)|Adds an element to the end of the array; grows the array if necessary.|  \n|[CObArray::Append](../../mfc/reference/cobarray-class.md#cobarray__append)|Appends another array to the array; grows the array if necessary.|  \n|[CObArray::Copy](../../mfc/reference/cobarray-class.md#cobarray__copy)|Copies another array to the array; grows the array if necessary.|  \n|[CObArray::ElementAt](../../mfc/reference/cobarray-class.md#cobarray__elementat)|Returns a temporary reference to the element pointer within the array.|  \n|[CObArray::FreeExtra](../../mfc/reference/cobarray-class.md#cobarray__freeextra)|Frees all unused memory above the current upper bound.|  \n|[CObArray::GetAt](../../mfc/reference/cobarray-class.md#cobarray__getat)|Returns the value at a given index.|  \n|[CObArray::GetCount](../../mfc/reference/cobarray-class.md#cobarray__getcount)|Gets the number of elements in this array.|  \n|[CObArray::GetData](../../mfc/reference/cobarray-class.md#cobarray__getdata)|Allows access to elements in the array. Can be **NULL**.|  \n|[CObArray::GetSize](../../mfc/reference/cobarray-class.md#cobarray__getsize)|Gets the number of elements in this array.|  \n|[CObArray::GetUpperBound](../../mfc/reference/cobarray-class.md#cobarray__getupperbound)|Returns the largest valid index.|  \n|[CObArray::InsertAt](../../mfc/reference/cobarray-class.md#cobarray__insertat)|Inserts an element (or all the elements in another array) at a specified index.|  \n|[CObArray::IsEmpty](../../mfc/reference/cobarray-class.md#cobarray__isempty)|Determines if the array is empty.|  \n|[CObArray::RemoveAll](../../mfc/reference/cobarray-class.md#cobarray__removeall)|Removes all the elements from this array.|  \n|[CObArray::RemoveAt](../../mfc/reference/cobarray-class.md#cobarray__removeat)|Removes an element at a specific index.|  \n|[CObArray::SetAt](../../mfc/reference/cobarray-class.md#cobarray__setat)|Sets the value for a given index; array not allowed to grow.|  \n|[CObArray::SetAtGrow](../../mfc/reference/cobarray-class.md#cobarray__setatgrow)|Sets the value for a given index; grows the array if necessary.|  \n|[CObArray::SetSize](../../mfc/reference/cobarray-class.md#cobarray__setsize)|Sets the number of elements to be contained in this array.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CObArray::operator [ ]](../../mfc/reference/cobarray-class.md#cobarray__operator_at)|Sets or gets the element at the specified index.|  \n  \n## Remarks  \n An unsigned integer, or **UINT**, differs from words and doublewords in that the physical size of a **UINT** can change depending on the target operating environment. A **UINT** is the same size as a doubleword.  \n  \n `CUIntArray` incorporates the [IMPLEMENT_DYNAMIC](run-time-object-model-services.md#implement_dynamic) macro to support run-time type access and dumping to a [CDumpContext](../../mfc/reference/cdumpcontext-class.md) object. If you need a dump of individual unsigned integer elements, you must set the depth of the dump context to 1 or greater. Unsigned integer arrays cannot be serialized.  \n  \n> [!NOTE]\n>  Before using an array, use `SetSize` to establish its size and allocate memory for it. If you do not use `SetSize`, adding elements to your array causes it to be frequently reallocated and copied. Frequent reallocation and copying are inefficient and can fragment memory.  \n  \n For more information on using `CUIntArray`, see the article [Collections](../../mfc/collections.md).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n `CUIntArray`  \n  \n## Requirements  \n **Header:** afxcoll.h  \n  \n## See Also  \n [CObject Class](../../mfc/reference/cobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n\n\n"}