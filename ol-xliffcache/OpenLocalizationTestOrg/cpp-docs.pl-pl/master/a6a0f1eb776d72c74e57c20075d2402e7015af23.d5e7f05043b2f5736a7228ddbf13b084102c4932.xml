{"nodes":[{"pos":[12,54],"content":"Understanding Parse Trees | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Understanding Parse Trees | Microsoft Docs","pos":[0,42]}]},{"content":"Understanding Parse Trees","pos":[575,600]},{"content":"You can define one or more parse trees in your registrar script, where each parse tree has the following form:","pos":[601,711]},{"content":"where:","pos":[770,776]},{"pos":[1389,1503],"content":"[!NOTE]\n`HKEY_CLASSES_ROOT` and `HKCR` are equivalent; `HKEY_CURRENT_USER` and `HKCU` are equivalent; and so on.","leadings":["","> "],"nodes":[{"content":"and <ph id=\"ph1\">`HKCR`</ph> are equivalent; <ph id=\"ph2\">`HKEY_CURRENT_USER`</ph> and <ph id=\"ph3\">`HKCU`</ph> are equivalent; and so on.","pos":[28,112],"source":" and `HKCR` are equivalent; `HKEY_CURRENT_USER` and `HKCU` are equivalent; and so on."}]},{"content":"A parse tree can add multiple keys and subkeys to the <ph id=\"ph1\">\\&lt;</ph>root key&gt;.","pos":[1510,1576],"source":"A parse tree can add multiple keys and subkeys to the \\<root key>."},{"content":"In doing so, it keeps a subkey's handle open until the parser has completed parsing all of its subkeys.","pos":[1577,1680]},{"content":"This approach is more efficient than operating on a single key at a time, as seen in the following example:","pos":[1681,1788]},{"content":"Here, the Registrar initially opens (creates) <ph id=\"ph1\">`HKEY_CLASSES_ROOT\\MyVeryOwnKey`</ph>.","pos":[1908,1987],"source":"Here, the Registrar initially opens (creates) `HKEY_CLASSES_ROOT\\MyVeryOwnKey`."},{"content":"It then sees that <ph id=\"ph1\">`MyVeryOwnKey`</ph> has a subkey.","pos":[1988,2034],"source":" It then sees that `MyVeryOwnKey` has a subkey."},{"content":"Rather than close the key to <ph id=\"ph1\">`MyVeryOwnKey`</ph>, the Registrar retains the handle and opens (creates) <ph id=\"ph2\">`HasASubKey`</ph> using this parent handle.","pos":[2035,2171],"source":" Rather than close the key to `MyVeryOwnKey`, the Registrar retains the handle and opens (creates) `HasASubKey` using this parent handle."},{"content":"(The system registry can be slower when no parent handle is open.) Thus, opening <ph id=\"ph1\">`HKEY_CLASSES_ROOT\\MyVeryOwnKey`</ph> and then opening <ph id=\"ph2\">`HasASubKey`</ph> with <ph id=\"ph3\">`MyVeryOwnKey`</ph> as the parent is faster than opening <ph id=\"ph4\">`MyVeryOwnKey`</ph>, closing <ph id=\"ph5\">`MyVeryOwnKey`</ph>, and then opening <ph id=\"ph6\">`MyVeryOwnKey\\HasASubKey`</ph>.","pos":[2172,2456],"source":" (The system registry can be slower when no parent handle is open.) Thus, opening `HKEY_CLASSES_ROOT\\MyVeryOwnKey` and then opening `HasASubKey` with `MyVeryOwnKey` as the parent is faster than opening `MyVeryOwnKey`, closing `MyVeryOwnKey`, and then opening `MyVeryOwnKey\\HasASubKey`."},{"content":"See Also","pos":[2465,2473]},{"content":"Creating Registrar Scripts","pos":[2478,2504]}],"content":"---\ntitle: \"Understanding Parse Trees | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"parse trees\"\nms.assetid: 668ce2dd-a1c3-4ca0-8135-b25267cb6a85\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Understanding Parse Trees\nYou can define one or more parse trees in your registrar script, where each parse tree has the following form:  \n  \n```  \n<root key>{<registry expression>}+  \n```  \n  \n where:  \n  \n```  \n<root key> ::= HKEY_CLASSES_ROOT | HKEY_CURRENT_USER |  \n    HKEY_LOCAL_MACHINE | HKEY_USERS |  \n    HKEY_PERFORMANCE_DATA | HKEY_DYN_DATA |  \n    HKEY_CURRENT_CONFIG | HKCR | HKCU |  \n    HKLM | HKU | HKPD | HKDD | HKCC  \n<registry expression> ::= <Add Key> | <Delete Key>  \n<Add Key> ::= [ForceRemove | NoRemove | val]<Key Name>  \n [<Key Value>][{<Add Key>}]  \n<Delete Key> ::= Delete<Key Name>  \n<Key Name> ::= '<AlphaNumeric>+'  \n<AlphaNumeric> ::= any character not NULL, i.e. ASCII 0  \n<Key Value> ::== <Key Type><Key Name>  \n<Key Type> ::= s | d  \n<Key Value> ::= '<AlphaNumeric>'  \n```  \n  \n> [!NOTE]\n> `HKEY_CLASSES_ROOT` and `HKCR` are equivalent; `HKEY_CURRENT_USER` and `HKCU` are equivalent; and so on.  \n  \n A parse tree can add multiple keys and subkeys to the \\<root key>. In doing so, it keeps a subkey's handle open until the parser has completed parsing all of its subkeys. This approach is more efficient than operating on a single key at a time, as seen in the following example:  \n  \n```  \nHKEY_CLASSES_ROOT  \n{  \n 'MyVeryOwnKey'  \n {  \n 'HasASubKey'  \n {  \n 'PrettyCool'  \n }  \n }  \n}  \n```  \n  \n Here, the Registrar initially opens (creates) `HKEY_CLASSES_ROOT\\MyVeryOwnKey`. It then sees that `MyVeryOwnKey` has a subkey. Rather than close the key to `MyVeryOwnKey`, the Registrar retains the handle and opens (creates) `HasASubKey` using this parent handle. (The system registry can be slower when no parent handle is open.) Thus, opening `HKEY_CLASSES_ROOT\\MyVeryOwnKey` and then opening `HasASubKey` with `MyVeryOwnKey` as the parent is faster than opening `MyVeryOwnKey`, closing `MyVeryOwnKey`, and then opening `MyVeryOwnKey\\HasASubKey`.  \n  \n## See Also  \n [Creating Registrar Scripts](../atl/creating-registrar-scripts.md)\n\n"}