{"nodes":[{"pos":[12,37],"content":"Type int | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Type int | Microsoft Docs","pos":[0,25]}]},{"content":"Type int","pos":[639,647]},{"content":"The size of a signed or unsigned <ph id=\"ph1\">`int`</ph> item is the standard size of an integer on a particular machine.","pos":[648,751],"source":"The size of a signed or unsigned `int` item is the standard size of an integer on a particular machine."},{"content":"For example, in 16-bit operating systems, the <ph id=\"ph1\">`int`</ph> type is usually 16 bits, or 2 bytes.","pos":[752,840],"source":" For example, in 16-bit operating systems, the `int` type is usually 16 bits, or 2 bytes."},{"content":"In 32-bit operating systems, the <ph id=\"ph1\">`int`</ph> type is usually 32 bits, or 4 bytes.","pos":[841,916],"source":" In 32-bit operating systems, the `int` type is usually 32 bits, or 4 bytes."},{"content":"Thus, the <ph id=\"ph1\">`int`</ph> type is equivalent to either the <ph id=\"ph2\">`short int`</ph> or the <bpt id=\"p1\">**</bpt>long int<ept id=\"p1\">**</ept> type, and the <ph id=\"ph3\">`unsigned int`</ph> type is equivalent to either the <bpt id=\"p2\">**</bpt>unsigned short<ept id=\"p2\">**</ept> or the <ph id=\"ph4\">`unsigned long`</ph> type, depending on the target environment.","pos":[917,1144],"source":" Thus, the `int` type is equivalent to either the `short int` or the **long int** type, and the `unsigned int` type is equivalent to either the **unsigned short** or the `unsigned long` type, depending on the target environment."},{"content":"The <ph id=\"ph1\">`int`</ph> types all represent signed values unless specified otherwise.","pos":[1145,1216],"source":" The `int` types all represent signed values unless specified otherwise."},{"content":"The type specifiers <ph id=\"ph1\">`int`</ph> and <ph id=\"ph2\">`unsigned int`</ph> (or simply <ph id=\"ph3\">`unsigned`</ph>) define certain features of the C language (for instance, the <ph id=\"ph4\">`enum`</ph> type).","pos":[1223,1365],"source":"The type specifiers `int` and `unsigned int` (or simply `unsigned`) define certain features of the C language (for instance, the `enum` type)."},{"content":"In these cases, the definitions of <ph id=\"ph1\">`int`</ph> and unsigned int for a particular implementation determine the actual storage.","pos":[1366,1485],"source":" In these cases, the definitions of `int` and unsigned int for a particular implementation determine the actual storage."},{"content":"Microsoft Specific","pos":[1494,1512]},{"content":"Signed integers are represented in two's-complement form.","pos":[1521,1578]},{"content":"The most-significant bit holds the sign: 1 for negative, 0 for positive and zero.","pos":[1579,1660]},{"content":"The range of values is given in <bpt id=\"p1\">[</bpt>C++ Integer Limits<ept id=\"p1\">](../c-language/cpp-integer-limits.md)</ept>, which is taken from the LIMITS.H header file.","pos":[1661,1797],"source":" The range of values is given in [C++ Integer Limits](../c-language/cpp-integer-limits.md), which is taken from the LIMITS.H header file."},{"content":"END Microsoft Specific","pos":[1806,1828]},{"pos":[1838,2367],"content":"[!NOTE]\n The int and unsigned int type specifiers are widely used in C programs because they allow a particular machine to handle integer values in the most efficient way for that machine. However, since the sizes of the int and unsigned int types vary, programs that depend on a specific int size may not be portable to other machines. To make programs more portable, you can use expressions with the sizeof operator (as discussed in [The sizeof Operator](../c-language/sizeof-operator-c.md)) instead of hard-coded data sizes.","leadings":["","> "],"nodes":[{"content":" The int and unsigned int type specifiers are widely used in C programs because they allow a particular machine to handle integer values in the most efficient way for that machine. However, since the sizes of the int and unsigned int types vary, programs that depend on a specific int size may not be portable to other machines. To make programs more portable, you can use expressions with the sizeof operator (as discussed in [The sizeof Operator](../c-language/sizeof-operator-c.md)) instead of hard-coded data sizes.","pos":[8,527],"nodes":[{"content":"The int and unsigned int type specifiers are widely used in C programs because they allow a particular machine to handle integer values in the most efficient way for that machine.","pos":[1,180]},{"content":"However, since the sizes of the int and unsigned int types vary, programs that depend on a specific int size may not be portable to other machines.","pos":[181,328]},{"content":"To make programs more portable, you can use expressions with the sizeof operator (as discussed in <bpt id=\"p1\">[</bpt>The sizeof Operator<ept id=\"p1\">](../c-language/sizeof-operator-c.md)</ept>) instead of hard-coded data sizes.","pos":[329,519],"source":" To make programs more portable, you can use expressions with the sizeof operator (as discussed in [The sizeof Operator](../c-language/sizeof-operator-c.md)) instead of hard-coded data sizes."}]}]},{"content":"See Also","pos":[2376,2384]},{"content":"Storage of Basic Types","pos":[2389,2411]}],"content":"---\ntitle: \"Type int | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"int data type\"\n  - \"type int\"\n  - \"portability [C++], type int\"\n  - \"signed integers\"\nms.assetid: 0067ce9a-281e-491a-ae63-632952981e13\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Type int\nThe size of a signed or unsigned `int` item is the standard size of an integer on a particular machine. For example, in 16-bit operating systems, the `int` type is usually 16 bits, or 2 bytes. In 32-bit operating systems, the `int` type is usually 32 bits, or 4 bytes. Thus, the `int` type is equivalent to either the `short int` or the **long int** type, and the `unsigned int` type is equivalent to either the **unsigned short** or the `unsigned long` type, depending on the target environment. The `int` types all represent signed values unless specified otherwise.  \n  \n The type specifiers `int` and `unsigned int` (or simply `unsigned`) define certain features of the C language (for instance, the `enum` type). In these cases, the definitions of `int` and unsigned int for a particular implementation determine the actual storage.  \n  \n **Microsoft Specific**  \n  \n Signed integers are represented in two's-complement form. The most-significant bit holds the sign: 1 for negative, 0 for positive and zero. The range of values is given in [C++ Integer Limits](../c-language/cpp-integer-limits.md), which is taken from the LIMITS.H header file.  \n  \n **END Microsoft Specific**  \n  \n> [!NOTE]\n>  The int and unsigned int type specifiers are widely used in C programs because they allow a particular machine to handle integer values in the most efficient way for that machine. However, since the sizes of the int and unsigned int types vary, programs that depend on a specific int size may not be portable to other machines. To make programs more portable, you can use expressions with the sizeof operator (as discussed in [The sizeof Operator](../c-language/sizeof-operator-c.md)) instead of hard-coded data sizes.  \n  \n## See Also  \n [Storage of Basic Types](../c-language/storage-of-basic-types.md)"}