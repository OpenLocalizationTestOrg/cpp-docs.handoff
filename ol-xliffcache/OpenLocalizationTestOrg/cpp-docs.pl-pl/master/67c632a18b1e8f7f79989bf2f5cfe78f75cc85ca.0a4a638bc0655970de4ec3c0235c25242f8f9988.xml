{"nodes":[{"pos":[12,40],"content":"__interface | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__interface | Microsoft Docs","pos":[0,28]}]},{"content":"__interface","pos":[640,651]},{"content":"Microsoft Specific","pos":[654,672]},{"content":"A Visual C++ interface can be defined as follows:","pos":[681,730]},{"content":"Can inherit from zero or more base interfaces.","pos":[740,786]},{"content":"Cannot inherit from a base class.","pos":[796,829]},{"content":"Can only contain public, pure virtual methods.","pos":[839,885]},{"content":"Cannot contain constructors, destructors, or operators.","pos":[895,950]},{"content":"Cannot contain static methods.","pos":[960,990]},{"content":"Cannot contain data members; properties are allowed.","pos":[1000,1052]},{"content":"Syntax","pos":[1061,1067]},{"content":"Remarks","pos":[1159,1166]},{"pos":[1170,1310],"content":"A C++ <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../cpp/class-cpp.md)</ept> or <bpt id=\"p2\">[</bpt>struct<ept id=\"p2\">](../cpp/struct-cpp.md)</ept> could be implemented with these rules, but <ph id=\"ph1\">`__interface`</ph> enforces them.","source":"A C++ [class](../cpp/class-cpp.md) or [struct](../cpp/struct-cpp.md) could be implemented with these rules, but `__interface` enforces them."},{"content":"For example, the following is a sample interface definition:","pos":[1317,1377]},{"pos":[1494,1611],"content":"For information on managed interfaces, see <bpt id=\"p1\">[</bpt>interface class<ept id=\"p1\">](../windows/interface-class-cpp-component-extensions.md)</ept>.","source":"For information on managed interfaces, see [interface class](../windows/interface-class-cpp-component-extensions.md)."},{"content":"Notice that you do not have to explicitly indicate that the <ph id=\"ph1\">`CommitX`</ph> and <ph id=\"ph2\">`get_X`</ph> functions are pure virtual.","pos":[1618,1727],"source":"Notice that you do not have to explicitly indicate that the `CommitX` and `get_X` functions are pure virtual."},{"content":"An equivalent declaration for the first function would be:","pos":[1728,1786]},{"pos":[1855,1920],"content":"implies the <bpt id=\"p1\">[</bpt>novtable<ept id=\"p1\">](../cpp/novtable.md)</ept> <ph id=\"ph1\">`__declspec`</ph> modifier.","source":" implies the [novtable](../cpp/novtable.md) `__declspec` modifier."},{"content":"Example","pos":[1929,1936]},{"content":"The following sample shows how to use properties declared in an interface.","pos":[1940,2014]},{"content":"END Microsoft Specific","pos":[3531,3553]},{"content":"See Also","pos":[3562,3570]},{"content":"Keywords","pos":[3575,3583]},{"content":"Interface Attributes","pos":[3614,3634]}],"content":"---\ntitle: \"__interface | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__interface\"\n  - \"__interface_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__interface keyword [C++]\"\nms.assetid: ca5d400b-d6d8-4ba2-89af-73f67e5ec056\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# __interface\n**Microsoft Specific**  \n  \n A Visual C++ interface can be defined as follows:  \n  \n-   Can inherit from zero or more base interfaces.  \n  \n-   Cannot inherit from a base class.  \n  \n-   Can only contain public, pure virtual methods.  \n  \n-   Cannot contain constructors, destructors, or operators.  \n  \n-   Cannot contain static methods.  \n  \n-   Cannot contain data members; properties are allowed.  \n  \n## Syntax  \n  \n```  \n  \nmodifier  \n __interface interface-name {interface-definition};  \n```  \n  \n## Remarks  \n A C++ [class](../cpp/class-cpp.md) or [struct](../cpp/struct-cpp.md) could be implemented with these rules, but `__interface` enforces them.  \n  \n For example, the following is a sample interface definition:  \n  \n```  \n__interface IMyInterface {  \n   HRESULT CommitX();  \n   HRESULT get_X(BSTR* pbstrName);  \n};  \n```  \n  \n For information on managed interfaces, see [interface class](../windows/interface-class-cpp-component-extensions.md).  \n  \n Notice that you do not have to explicitly indicate that the `CommitX` and `get_X` functions are pure virtual. An equivalent declaration for the first function would be:  \n  \n```  \nvirtual HRESULT CommitX() = 0;  \n```  \n  \n `__interface` implies the [novtable](../cpp/novtable.md) `__declspec` modifier.  \n  \n## Example  \n The following sample shows how to use properties declared in an interface.  \n  \n```  \n// deriv_interface.cpp  \n#define _ATL_ATTRIBUTES 1  \n#include <atlbase.h>  \n#include <atlcom.h>  \n#include <string.h>  \n#include <comdef.h>  \n#include <stdio.h>  \n  \n[module(name=\"test\")];  \n  \n[ object, uuid(\"00000000-0000-0000-0000-000000000001\"), library_block ]  \n__interface IFace {  \n   [ id(0) ] int int_data;  \n   [ id(5) ] BSTR bstr_data;  \n};  \n  \n[ coclass, uuid(\"00000000-0000-0000-0000-000000000002\") ]  \nclass MyClass : public IFace {  \nprivate:  \n    int m_i;  \n    BSTR m_bstr;   \n  \npublic:  \n    MyClass()  \n    {  \n        m_i = 0;  \n        m_bstr = 0;  \n    }  \n  \n    ~MyClass()  \n    {  \n        if (m_bstr)   \n            ::SysFreeString(m_bstr);  \n    }  \n  \n    int get_int_data()  \n    {  \n        return m_i;  \n    }  \n  \n    void put_int_data(int _i)   \n    {  \n        m_i = _i;  \n    }  \n  \n    BSTR get_bstr_data()  \n    {   \n        BSTR bstr = ::SysAllocString(m_bstr);  \n        return bstr;   \n    }  \n  \n    void put_bstr_data(BSTR bstr)   \n    {   \n        if (m_bstr)   \n            ::SysFreeString(m_bstr);  \n        m_bstr = ::SysAllocString(bstr);  \n    }  \n};  \n  \nint main()  \n{  \n    _bstr_t bstr(\"Testing\");  \n    CoInitialize(NULL);  \n    CComObject<MyClass>* p;  \n    CComObject<MyClass>::CreateInstance(&p);  \n    p->int_data = 100;  \n    printf_s(\"p->int_data = %d\\n\", p->int_data);                \n    p->bstr_data = bstr;  \n    printf_s(\"bstr_data = %S\\n\", p->bstr_data);  \n}  \n```  \n  \n```Output  \np->int_data = 100  \nbstr_data = Testing  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Keywords](../cpp/keywords-cpp.md)   \n [Interface Attributes](../windows/interface-attributes.md)"}