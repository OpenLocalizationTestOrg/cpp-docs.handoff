{"nodes":[{"pos":[12,72],"content":"Declaration of a CLR Reference Class Object | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Declaration of a CLR Reference Class Object | Microsoft Docs","pos":[0,60]}]},{"content":"Declaration of a CLR Reference Class Object","pos":[637,680]},{"pos":[681,874],"content":"The syntax to declare and instantiate an object of a reference class type has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The syntax to declare and instantiate an object of a reference class type has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"In Managed Extensions, a reference class type object is declared by using the ISO-C++ pointer syntax, with an optional use of the <ph id=\"ph1\">`__gc`</ph> keyword to the left of the star (<ph id=\"ph2\">`*`</ph>).","pos":[881,1056],"source":"In Managed Extensions, a reference class type object is declared by using the ISO-C++ pointer syntax, with an optional use of the `__gc` keyword to the left of the star (`*`)."},{"content":"For example, here are a variety of reference class type object declarations under the Managed Extensions syntax:","pos":[1057,1169]},{"content":"Under the new syntax, you declare a reference class type object by using a new declarative token (<ph id=\"ph1\">`^`</ph>) referred to formally as a <bpt id=\"p1\">*</bpt>tracking handle<ept id=\"p1\">*</ept> and more informally as a <bpt id=\"p2\">*</bpt>hat<ept id=\"p2\">*</ept>.","pos":[1650,1828],"source":"Under the new syntax, you declare a reference class type object by using a new declarative token (`^`) referred to formally as a *tracking handle* and more informally as a *hat*."},{"content":"(The tracking adjective means that a reference type sits in the CLR heap, and can therefore transparently move locations during garbage collection heap compaction.","pos":[1829,1992]},{"content":"A tracking handle is transparently updated during runtime.","pos":[1993,2051]},{"content":"Two similar concepts are the <bpt id=\"p1\">*</bpt>tracking reference<ept id=\"p1\">*</ept> (<ph id=\"ph1\">`%`</ph>), and the <bpt id=\"p2\">*</bpt>interior pointer<ept id=\"p2\">*</ept> (<ph id=\"ph2\">`interior_ptr&lt;&gt;`</ph>), discussed in <bpt id=\"p3\">[</bpt>Value Type Semantics<ept id=\"p3\">](../dotnet/value-type-semantics.md)</ept>.","pos":[2052,2227],"source":" Two similar concepts are the *tracking reference* (`%`), and the *interior pointer* (`interior_ptr<>`), discussed in [Value Type Semantics](../dotnet/value-type-semantics.md)."},{"content":"The primary reasons to move the declarative syntax away from a reuse of the ISO-C++ pointer syntax are as follows:","pos":[2234,2348]},{"content":"The use of the pointer syntax did not permit overloaded operators to be directly applied to a reference object.","pos":[2358,2469]},{"content":"Rather, one had to call the operator by using its internal name, such as <ph id=\"ph1\">`rV1-&gt;op_Addition(rV2)`</ph> instead of  the more intuitive <ph id=\"ph2\">`rV1+rV2`</ph>.","pos":[2470,2608],"source":" Rather, one had to call the operator by using its internal name, such as `rV1->op_Addition(rV2)` instead of  the more intuitive `rV1+rV2`."},{"content":"A number of pointer operations, such as casting and pointer arithmetic, not permitted for objects stored on a garbage collected heap.","pos":[2618,2751]},{"content":"The notion of a tracking handle better captures the nature of a CLR reference type.","pos":[2752,2835]},{"content":"The <ph id=\"ph1\">`__gc`</ph> modifier on a tracking handle is unnecessary and is not supported.","pos":[2842,2919],"source":"The `__gc` modifier on a tracking handle is unnecessary and is not supported."},{"content":"The use of the object itself is not changed; it still accesses members through the pointer member selection operator (<ph id=\"ph1\">`-&gt;`</ph>).","pos":[2920,3044],"source":" The use of the object itself is not changed; it still accesses members through the pointer member selection operator (`->`)."},{"content":"For example, here is the previous Managed Extensions code sample translated into the new syntax:","pos":[3045,3141]},{"content":"Dynamic Allocation of an Object on the CLR Heap","pos":[3595,3642]},{"content":"In Managed Extensions, the existence of two <ph id=\"ph1\">`new`</ph> expressions to allocate between the native and managed heap was largely transparent.","pos":[3646,3780],"source":"In Managed Extensions, the existence of two `new` expressions to allocate between the native and managed heap was largely transparent."},{"content":"In almost all instances, the compiler is able to use the context to determine whether to allocate memory from the native or managed heap.","pos":[3781,3918]},{"content":"For example,","pos":[3919,3931]},{"content":"When you do not want the contextual heap allocation, you could direct the compiler with either the <ph id=\"ph1\">`__gc`</ph> or <ph id=\"ph2\">`__nogc`</ph> keyword.","pos":[4108,4234],"source":"When you do not want the contextual heap allocation, you could direct the compiler with either the `__gc` or `__nogc` keyword."},{"content":"In the new syntax, the separate nature of the two new expressions is made explicit with the introduction of the <ph id=\"ph1\">`gcnew`</ph> keyword.","pos":[4235,4363],"source":" In the new syntax, the separate nature of the two new expressions is made explicit with the introduction of the `gcnew` keyword."},{"content":"For example, the previous three declarations look as follows in the new syntax:","pos":[4364,4443]},{"pos":[4634,4736],"content":"Here is the Managed Extensions initialization of the <ph id=\"ph1\">`Form1`</ph> members declared in the previous section:","source":"Here is the Managed Extensions initialization of the `Form1` members declared in the previous section:"},{"content":"Here is the same initialization recast to the new syntax.","pos":[5029,5086]},{"content":"Note that the hat is not required for the reference type when it is the target of a <ph id=\"ph1\">`gcnew`</ph> expression.","pos":[5087,5190],"source":" Note that the hat is not required for the reference type when it is the target of a `gcnew` expression."},{"content":"A Tracking Reference to No Object","pos":[5489,5522]},{"content":"In the new syntax, <ph id=\"ph1\">`0`</ph> no longer represents a null address but is treated as an integer, the same as <ph id=\"ph2\">`1`</ph>, <ph id=\"ph3\">`10`</ph>, or <ph id=\"ph4\">`100`</ph>.","pos":[5526,5647],"source":"In the new syntax, `0` no longer represents a null address but is treated as an integer, the same as `1`, `10`, or `100`."},{"content":"A new special token represents a null value for a tracking reference.","pos":[5648,5717]},{"content":"For example, in Managed Extensions, we initialize a reference type to address no object as follows:","pos":[5718,5817]},{"content":"In the new syntax, any initialization or assignment of a value type to an <ph id=\"ph1\">`Object`</ph> causes an implicit boxing of that value type.","pos":[5956,6084],"source":"In the new syntax, any initialization or assignment of a value type to an `Object` causes an implicit boxing of that value type."},{"content":"In the new syntax, both <ph id=\"ph1\">`obj`</ph> and <ph id=\"ph2\">`obj2`</ph> are initialized to addressed boxed Int32 objects holding the values 0 and 1, respectively.","pos":[6085,6216],"source":" In the new syntax, both `obj` and `obj2` are initialized to addressed boxed Int32 objects holding the values 0 and 1, respectively."},{"content":"For example:","pos":[6217,6229]},{"content":"Therefore, in order to perform the explicit initialization, assignment, and comparison of a tracking handle to null, use a new keyword, <ph id=\"ph1\">`nullptr`</ph>.","pos":[6340,6486],"source":"Therefore, in order to perform the explicit initialization, assignment, and comparison of a tracking handle to null, use a new keyword, `nullptr`."},{"content":"The correct revision of the original example looks as follows:","pos":[6488,6550]},{"content":"This complicates somewhat the porting of existing code into the new syntax.","pos":[6704,6779]},{"content":"For example, consider the following value class declaration:","pos":[6780,6840]},{"content":"Here, both <ph id=\"ph1\">`args`</ph> and <ph id=\"ph2\">`env`</ph> are CLR reference types.","pos":[7124,7176],"source":"Here, both `args` and `env` are CLR reference types."},{"content":"The initialization of these two members to <ph id=\"ph1\">`0`</ph> in the constructor cannot remain unchanged in the transition to the new syntax.","pos":[7177,7303],"source":" The initialization of these two members to `0` in the constructor cannot remain unchanged in the transition to the new syntax."},{"content":"Rather, they must be changed to <ph id=\"ph1\">`nullptr`</ph>:","pos":[7304,7346],"source":" Rather, they must be changed to `nullptr`:"},{"content":"Similarly, tests against those members comparing them to <ph id=\"ph1\">`0`</ph> must also be changed to compare the members to <ph id=\"ph2\">`nullptr`</ph>.","pos":[7643,7761],"source":"Similarly, tests against those members comparing them to `0` must also be changed to compare the members to `nullptr`."},{"content":"Here is the Managed Extensions syntax:","pos":[7762,7800]},{"content":"Here is the revision, replacing each <ph id=\"ph1\">`0`</ph> instance with a <ph id=\"ph2\">`nullptr`</ph>.","pos":[8243,8310],"source":"Here is the revision, replacing each `0` instance with a `nullptr`."},{"content":"The translation tool helps in this transformation by automating many if not all occurrences, including use of the <ph id=\"ph1\">`NULL`</ph> macro.","pos":[8311,8438],"source":" The translation tool helps in this transformation by automating many if not all occurrences, including use of the `NULL` macro."},{"content":"The <ph id=\"ph1\">`nullptr`</ph> is converted into any pointer or tracking handle type but is not promoted to an integral type.","pos":[8910,9018],"source":"The `nullptr` is converted into any pointer or tracking handle type but is not promoted to an integral type."},{"content":"For example, in the following set of initializations, the <ph id=\"ph1\">`nullptr`</ph> is valid only as an initial value to the first two.","pos":[9019,9138],"source":" For example, in the following set of initializations, the `nullptr` is valid only as an initial value to the first two."},{"content":"Similarly, given an overloaded set of methods such as the following:","pos":[9357,9425]},{"pos":[9531,9591],"content":"An invocation with <ph id=\"ph1\">`nullptr`</ph> literal, such as the following,","source":"An invocation with `nullptr` literal, such as the following,"},{"content":"is ambiguous because the <ph id=\"ph1\">`nullptr`</ph> matches both a tracking handle and a pointer, and there is no preference given to one type over the other.","pos":[9673,9814],"source":"is ambiguous because the `nullptr` matches both a tracking handle and a pointer, and there is no preference given to one type over the other."},{"content":"(This situation requires an explicit cast in order to disambiguate.)","pos":[9815,9883]},{"pos":[9890,9942],"content":"An invocation with <ph id=\"ph1\">`0`</ph> exactly matches instance (3):","source":"An invocation with `0` exactly matches instance (3):"},{"content":"because <ph id=\"ph1\">`0`</ph> is of type integer.","pos":[9995,10026],"source":"because `0` is of type integer."},{"content":"Were <ph id=\"ph1\">`f(int)`</ph> not present, the call would unambiguously match <ph id=\"ph2\">`f(char*)`</ph> through a standard conversion.","pos":[10027,10130],"source":" Were `f(int)` not present, the call would unambiguously match `f(char*)` through a standard conversion."},{"content":"The matching rules give precedence of an exact match over a standard conversion.","pos":[10131,10211]},{"content":"In the absence of an exact match, a standard conversion is given precedence over an implicit boxing of a value type.","pos":[10212,10328]},{"content":"That is why there is no ambiguity.","pos":[10329,10363]},{"content":"See Also","pos":[10372,10380]},{"content":"Managed Types (C++/CL)","pos":[10385,10407]},{"content":"Classes and Structs","pos":[10449,10468]},{"content":"Handle to Object Operator (^)","pos":[10535,10564]},{"content":"nullptr","pos":[10641,10648]}],"content":"---\ntitle: \"Declaration of a CLR Reference Class Object | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"types [C++], reference types\"\n  - \"reference types, CLR\"\nms.assetid: 6d64f746-3715-4948-ada3-88859f4150e4\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Declaration of a CLR Reference Class Object\nThe syntax to declare and instantiate an object of a reference class type has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n In Managed Extensions, a reference class type object is declared by using the ISO-C++ pointer syntax, with an optional use of the `__gc` keyword to the left of the star (`*`). For example, here are a variety of reference class type object declarations under the Managed Extensions syntax:  \n  \n```  \npublic __gc class Form1 : public System::Windows::Forms::Form {  \nprivate:  \n   System::ComponentModel::Container __gc *components;  \n   Button __gc *button1;  \n   DataGrid __gc *myDataGrid;     \n   DataSet __gc *myDataSet;  \n  \n   void PrintValues( Array* myArr ) {  \n      System::Collections::IEnumerator* myEnumerator =   \n         myArr->GetEnumerator();  \n  \n      Array *localArray;  \n      myArr->Copy(myArr, localArray, myArr->Length);  \n   }  \n};  \n```  \n  \n Under the new syntax, you declare a reference class type object by using a new declarative token (`^`) referred to formally as a *tracking handle* and more informally as a *hat*. (The tracking adjective means that a reference type sits in the CLR heap, and can therefore transparently move locations during garbage collection heap compaction. A tracking handle is transparently updated during runtime. Two similar concepts are the *tracking reference* (`%`), and the *interior pointer* (`interior_ptr<>`), discussed in [Value Type Semantics](../dotnet/value-type-semantics.md).  \n  \n The primary reasons to move the declarative syntax away from a reuse of the ISO-C++ pointer syntax are as follows:  \n  \n-   The use of the pointer syntax did not permit overloaded operators to be directly applied to a reference object. Rather, one had to call the operator by using its internal name, such as `rV1->op_Addition(rV2)` instead of  the more intuitive `rV1+rV2`.  \n  \n-   A number of pointer operations, such as casting and pointer arithmetic, not permitted for objects stored on a garbage collected heap. The notion of a tracking handle better captures the nature of a CLR reference type.  \n  \n The `__gc` modifier on a tracking handle is unnecessary and is not supported. The use of the object itself is not changed; it still accesses members through the pointer member selection operator (`->`). For example, here is the previous Managed Extensions code sample translated into the new syntax:  \n  \n```  \npublic ref class Form1: public System::Windows::Forms::Form {  \nprivate:  \n   System::ComponentModel::Container^ components;  \n   Button^ button1;  \n   DataGrid^ myDataGrid;  \n   DataSet^ myDataSet;  \n  \n   void PrintValues( Array^ myArr ) {  \n      System::Collections::IEnumerator^ myEnumerator =  \n         myArr->GetEnumerator();  \n  \n      Array ^localArray;  \n      myArr->Copy(myArr, localArray, myArr->Length);   }  \n};  \n```  \n  \n## Dynamic Allocation of an Object on the CLR Heap  \n In Managed Extensions, the existence of two `new` expressions to allocate between the native and managed heap was largely transparent. In almost all instances, the compiler is able to use the context to determine whether to allocate memory from the native or managed heap. For example,  \n  \n```  \nButton *button1 = new Button; // OK: managed heap  \nint *pi1 = new int;           // OK: native heap  \nInt32 *pi2 = new Int32;       // OK: managed heap  \n```  \n  \n When you do not want the contextual heap allocation, you could direct the compiler with either the `__gc` or `__nogc` keyword. In the new syntax, the separate nature of the two new expressions is made explicit with the introduction of the `gcnew` keyword. For example, the previous three declarations look as follows in the new syntax:  \n  \n```  \nButton^ button1 = gcnew Button;        // OK: managed heap  \nint * pi1 = new int;                   // OK: native heap  \nInt32^ pi2 = gcnew Int32; // OK: managed heap  \n```  \n  \n Here is the Managed Extensions initialization of the `Form1` members declared in the previous section:  \n  \n```  \nvoid InitializeComponent() {  \n   components = new System::ComponentModel::Container();  \n   button1 = new System::Windows::Forms::Button();  \n   myDataGrid = new DataGrid();  \n  \n   button1->Click +=   \n      new System::EventHandler(this, &Form1::button1_Click);  \n}  \n```  \n  \n Here is the same initialization recast to the new syntax. Note that the hat is not required for the reference type when it is the target of a `gcnew` expression.  \n  \n```  \nvoid InitializeComponent() {  \n   components = gcnew System::ComponentModel::Container;  \n   button1 = gcnew System::Windows::Forms::Button;  \n   myDataGrid = gcnew DataGrid;  \n  \n   button1->Click +=   \n      gcnew System::EventHandler( this, &Form1::button1_Click );  \n}  \n```  \n  \n## A Tracking Reference to No Object  \n In the new syntax, `0` no longer represents a null address but is treated as an integer, the same as `1`, `10`, or `100`. A new special token represents a null value for a tracking reference. For example, in Managed Extensions, we initialize a reference type to address no object as follows:  \n  \n```  \n// OK: we set obj to refer to no object  \nObject * obj = 0;  \n  \n// Error: no implicit boxing  \nObject * obj2 = 1;  \n```  \n  \n In the new syntax, any initialization or assignment of a value type to an `Object` causes an implicit boxing of that value type. In the new syntax, both `obj` and `obj2` are initialized to addressed boxed Int32 objects holding the values 0 and 1, respectively. For example:  \n  \n```  \n// causes the implicit boxing of both 0 and 1  \nObject ^ obj = 0;  \nObject ^ obj2 = 1;  \n```  \n  \n Therefore, in order to perform the explicit initialization, assignment, and comparison of a tracking handle to null, use a new keyword, `nullptr`.  The correct revision of the original example looks as follows:  \n  \n```  \n// OK: we set obj to refer to no object  \nObject ^ obj = nullptr;  \n  \n// OK: we initialize obj2 to a Int32^  \nObject ^ obj2 = 1;  \n```  \n  \n This complicates somewhat the porting of existing code into the new syntax. For example, consider the following value class declaration:  \n  \n```  \n__value struct Holder {  \n   Holder( Continuation* c, Sexpr* v ) {  \n      cont = c;  \n      value = v;  \n      args = 0;  \n      env = 0;  \n   }  \n  \nprivate:  \n   Continuation* cont;  \n   Sexpr * value;  \n   Environment* env;  \n   Sexpr * args __gc [];  \n};  \n```  \n  \n Here, both `args` and `env` are CLR reference types. The initialization of these two members to `0` in the constructor cannot remain unchanged in the transition to the new syntax. Rather, they must be changed to `nullptr`:  \n  \n```  \nvalue struct Holder {  \n   Holder( Continuation^ c, Sexpr^ v )  \n   {  \n      cont = c;  \n      value = v;  \n      args = nullptr;  \n      env = nullptr;  \n   }  \n  \nprivate:  \n   Continuation^ cont;  \n   Sexpr^ value;  \n   Environment^ env;  \n   array<Sexpr^>^ args;  \n};  \n```  \n  \n Similarly, tests against those members comparing them to `0` must also be changed to compare the members to `nullptr`. Here is the Managed Extensions syntax:  \n  \n```  \nSexpr * Loop (Sexpr* input) {  \n   value = 0;  \n   Holder holder = Interpret(this, input, env);  \n  \n   while (holder.cont != 0) {  \n      if (holder.env != 0) {  \n         holder=Interpret(holder.cont,holder.value,holder.env);  \n      }  \n      else if (holder.args != 0) {  \n         holder =   \n         holder.value->closure()->  \n         apply(holder.cont,holder.args);  \n      }  \n   }  \n  \n   return value;  \n}  \n```  \n  \n Here is the revision, replacing each `0` instance with a `nullptr`. The translation tool helps in this transformation by automating many if not all occurrences, including use of the `NULL` macro.  \n  \n```  \nSexpr ^ Loop (Sexpr^ input) {  \n   value = nullptr;  \n   Holder holder = Interpret(this, input, env);  \n  \n   while ( holder.cont != nullptr ) {  \n      if ( holder.env != nullptr ) {  \n         holder=Interpret(holder.cont,holder.value,holder.env);  \n      }  \n      else if (holder.args != nullptr ) {  \n         holder =   \n         holder.value->closure()->  \n         apply(holder.cont,holder.args);  \n      }  \n   }  \n  \n   return value;  \n}  \n```  \n  \n The `nullptr` is converted into any pointer or tracking handle type but is not promoted to an integral type. For example, in the following set of initializations, the `nullptr` is valid only as an initial value to the first two.  \n  \n```  \n// OK: we set obj and pstr to refer to no object  \nObject^ obj = nullptr;  \nchar*   pstr = nullptr; // 0 would also work here  \n  \n// Error: no conversion of nullptr to 0 â€¦  \nint ival = nullptr;  \n```  \n  \n Similarly, given an overloaded set of methods such as the following:  \n  \n```  \nvoid f( Object^ ); // (1)  \nvoid f( char* );   // (2)  \nvoid f( int );     // (3)  \n```  \n  \n An invocation with `nullptr` literal, such as the following,  \n  \n```  \n// Error: ambiguous: matches (1) and (2)  \nf(  nullptr );  \n```  \n  \n is ambiguous because the `nullptr` matches both a tracking handle and a pointer, and there is no preference given to one type over the other. (This situation requires an explicit cast in order to disambiguate.)  \n  \n An invocation with `0` exactly matches instance (3):  \n  \n```  \n// OK: matches (3)  \nf( 0 );  \n```  \n  \n because `0` is of type integer. Were `f(int)` not present, the call would unambiguously match `f(char*)` through a standard conversion. The matching rules give precedence of an exact match over a standard conversion. In the absence of an exact match, a standard conversion is given precedence over an implicit boxing of a value type. That is why there is no ambiguity.  \n  \n## See Also  \n [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md)   \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)   \n [Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)   \n [nullptr](../windows/nullptr-cpp-component-extensions.md)"}