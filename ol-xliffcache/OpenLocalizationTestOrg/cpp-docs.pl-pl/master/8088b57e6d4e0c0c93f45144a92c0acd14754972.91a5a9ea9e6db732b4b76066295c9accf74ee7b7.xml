{"nodes":[{"pos":[12,60],"content":"Parallel Patterns Library (PPL) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Parallel Patterns Library (PPL) | Microsoft Docs","pos":[0,48]}]},{"content":"Parallel Patterns Library (PPL)","pos":[601,632]},{"content":"The Parallel Patterns Library (PPL) provides an imperative programming model that promotes scalability and ease-of-use for developing concurrent applications.","pos":[633,791]},{"content":"The PPL builds on the scheduling and resource management components of the Concurrency Runtime.","pos":[792,887]},{"content":"It raises the level of abstraction between your application code and the underlying threading mechanism by providing generic, type-safe algorithms and containers that act on data in parallel.","pos":[888,1079]},{"content":"The PPL also lets you develop applications that scale by providing alternatives to shared state.","pos":[1080,1176]},{"content":"The PPL provides the following features:","pos":[1183,1223]},{"pos":[1231,1356],"content":"<bpt id=\"p1\">*</bpt>Task Parallelism<ept id=\"p1\">*</ept>: a mechanism that works on top of the Windows ThreadPool to execute several work items (tasks) in parallel","source":"*Task Parallelism*: a mechanism that works on top of the Windows ThreadPool to execute several work items (tasks) in parallel"},{"pos":[1364,1492],"content":"<bpt id=\"p1\">*</bpt>Parallel algorithms<ept id=\"p1\">*</ept>: generic algorithms that works on top of the Concurrency Runtime to act on collections of data in parallel","source":"*Parallel algorithms*: generic algorithms that works on top of the Concurrency Runtime to act on collections of data in parallel"},{"pos":[1500,1612],"content":"<bpt id=\"p1\">*</bpt>Parallel containers and objects<ept id=\"p1\">*</ept>: generic container types that provide safe concurrent access to their elements","source":"*Parallel containers and objects*: generic container types that provide safe concurrent access to their elements"},{"content":"Example","pos":[1621,1628]},{"content":"The PPL provides a programming model that resembles the Standard Template Library (STL).","pos":[1632,1720]},{"content":"The following example demonstrates many features of the PPL.","pos":[1721,1781]},{"content":"It computes several Fibonacci numbers serially and in parallel.","pos":[1782,1845]},{"content":"Both computations act on a <bpt id=\"p1\">[</bpt>std::array<ept id=\"p1\">](../../standard-library/array-class-stl.md)</ept> object.","pos":[1846,1936],"source":" Both computations act on a [std::array](../../standard-library/array-class-stl.md) object."},{"content":"The example also prints to the console the time that is required to perform both computations.","pos":[1937,2031]},{"content":"The serial version uses the STL <bpt id=\"p1\">[</bpt>std::for_each<ept id=\"p1\">](http://msdn.microsoft.com/Library/8cb2ae72-bef6-488b-b011-0475c0787e33)</ept> algorithm to traverse the array and stores the results in a <bpt id=\"p2\">[</bpt>std::vector<ept id=\"p2\">](../../standard-library/vector-class.md)</ept> object.","pos":[2038,2279],"source":"The serial version uses the STL [std::for_each](http://msdn.microsoft.com/Library/8cb2ae72-bef6-488b-b011-0475c0787e33) algorithm to traverse the array and stores the results in a [std::vector](../../standard-library/vector-class.md) object."},{"content":"The parallel version performs the same task, but uses the PPL <bpt id=\"p1\">[</bpt>concurrency::parallel_for_each<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for_each)</ept> algorithm and stores the results in a <bpt id=\"p2\">[</bpt>concurrency::concurrent_vector<ept id=\"p2\">](../../parallel/concrt/reference/concurrent-vector-class.md)</ept> object.","pos":[2280,2577],"source":" The parallel version performs the same task, but uses the PPL [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) algorithm and stores the results in a [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) object."},{"content":"The <ph id=\"ph1\">`concurrent_vector`</ph> class enables each loop iteration to concurrently add elements without the requirement to synchronize write access to the container.","pos":[2578,2734],"source":" The `concurrent_vector` class enables each loop iteration to concurrently add elements without the requirement to synchronize write access to the container."},{"pos":[2741,2916],"content":"Because <ph id=\"ph1\">`parallel_for_each`</ph> acts concurrently, the parallel version of this example must sort the <ph id=\"ph2\">`concurrent_vector`</ph> object to produce the same results as the serial version.","source":"Because `parallel_for_each` acts concurrently, the parallel version of this example must sort the `concurrent_vector` object to produce the same results as the serial version."},{"content":"Note that the example uses a naïve method to compute the Fibonacci numbers; however, this method illustrates how the Concurrency Runtime can improve the performance of long computations.","pos":[2923,3109]},{"pos":[3127,3154],"content":"concrt-parallel-fibonacci#1"},{"content":"The following sample output is for a computer that has four processors.","pos":[3238,3309]},{"content":"Each iteration of the loop requires a different amount of time to finish.","pos":[3464,3537]},{"content":"The performance of <ph id=\"ph1\">`parallel_for_each`</ph> is bounded by the operation that finishes last.","pos":[3538,3624],"source":" The performance of `parallel_for_each` is bounded by the operation that finishes last."},{"content":"Therefore, you should not expect linear performance improvements between the serial and parallel versions of this example.","pos":[3625,3747]},{"content":"Related Topics","pos":[3756,3770]},{"content":"Title","pos":[3777,3782]},{"content":"Description","pos":[3783,3794]},{"content":"Task Parallelism","pos":[3834,3850]},{"content":"Describes the role of tasks and task groups in the PPL.","pos":[3915,3970]},{"content":"Parallel Algorithms","pos":[3976,3995]},{"pos":[4043,4131],"content":"Describes how to use parallel algorithms such as <ph id=\"ph1\">`parallel_for`</ph> and <ph id=\"ph2\">`parallel_for_each`</ph>.","source":"Describes how to use parallel algorithms such as `parallel_for` and `parallel_for_each`."},{"content":"Parallel Containers and Objects","pos":[4137,4168]},{"content":"Describes the various parallel containers and objects that are provided by the PPL.","pos":[4228,4311]},{"content":"Cancellation in the PPL","pos":[4317,4340]},{"content":"Explains how to cancel the work that is being performed by a parallel algorithm.","pos":[4370,4450]},{"content":"Concurrency Runtime","pos":[4456,4475]},{"content":"Describes the Concurrency Runtime, which simplifies parallel programming, and contains links to related topics.","pos":[4523,4634]}],"content":"---\ntitle: \"Parallel Patterns Library (PPL) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Parallel Patterns Library (PPL)\"\nms.assetid: 40fd86b2-69fa-45e5-93d8-98a75636c242\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Parallel Patterns Library (PPL)\nThe Parallel Patterns Library (PPL) provides an imperative programming model that promotes scalability and ease-of-use for developing concurrent applications. The PPL builds on the scheduling and resource management components of the Concurrency Runtime. It raises the level of abstraction between your application code and the underlying threading mechanism by providing generic, type-safe algorithms and containers that act on data in parallel. The PPL also lets you develop applications that scale by providing alternatives to shared state.  \n  \n The PPL provides the following features:  \n  \n- *Task Parallelism*: a mechanism that works on top of the Windows ThreadPool to execute several work items (tasks) in parallel  \n  \n- *Parallel algorithms*: generic algorithms that works on top of the Concurrency Runtime to act on collections of data in parallel  \n  \n- *Parallel containers and objects*: generic container types that provide safe concurrent access to their elements  \n  \n## Example  \n The PPL provides a programming model that resembles the Standard Template Library (STL). The following example demonstrates many features of the PPL. It computes several Fibonacci numbers serially and in parallel. Both computations act on a [std::array](../../standard-library/array-class-stl.md) object. The example also prints to the console the time that is required to perform both computations.  \n  \n The serial version uses the STL [std::for_each](http://msdn.microsoft.com/Library/8cb2ae72-bef6-488b-b011-0475c0787e33) algorithm to traverse the array and stores the results in a [std::vector](../../standard-library/vector-class.md) object. The parallel version performs the same task, but uses the PPL [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) algorithm and stores the results in a [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) object. The `concurrent_vector` class enables each loop iteration to concurrently add elements without the requirement to synchronize write access to the container.  \n  \n Because `parallel_for_each` acts concurrently, the parallel version of this example must sort the `concurrent_vector` object to produce the same results as the serial version.  \n  \n Note that the example uses a naïve method to compute the Fibonacci numbers; however, this method illustrates how the Concurrency Runtime can improve the performance of long computations.  \n  \n [!code-cpp[concrt-parallel-fibonacci#1](../../parallel/concrt/codesnippet/cpp/parallel-patterns-library-ppl_1.cpp)]  \n  \n The following sample output is for a computer that has four processors.  \n  \n```Output  \nserial time: 9250 ms  \nparallel time: 5726 ms  \n \nfib(24): 46368  \nfib(26): 121393  \nfib(41): 165580141  \nfib(42): 267914296  \n```  \n  \n Each iteration of the loop requires a different amount of time to finish. The performance of `parallel_for_each` is bounded by the operation that finishes last. Therefore, you should not expect linear performance improvements between the serial and parallel versions of this example.  \n  \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|Describes the role of tasks and task groups in the PPL.|  \n|[Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)|Describes how to use parallel algorithms such as `parallel_for` and `parallel_for_each`.|  \n|[Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md)|Describes the various parallel containers and objects that are provided by the PPL.|  \n|[Cancellation in the PPL](cancellation-in-the-ppl.md)|Explains how to cancel the work that is being performed by a parallel algorithm.|  \n|[Concurrency Runtime](../../parallel/concrt/concurrency-runtime.md)|Describes the Concurrency Runtime, which simplifies parallel programming, and contains links to related topics.|\n\n"}