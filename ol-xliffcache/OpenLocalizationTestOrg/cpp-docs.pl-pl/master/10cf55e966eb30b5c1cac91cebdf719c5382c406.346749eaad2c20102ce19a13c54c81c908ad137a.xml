{"nodes":[{"pos":[12,80],"content":"How to: Marshal Embedded Pointers Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Embedded Pointers Using C++ Interop | Microsoft Docs","pos":[0,68]}]},{"content":"How to: Marshal Embedded Pointers Using C++ Interop","pos":[846,897]},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[898,1156],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1157,1339],"source":" Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Example","pos":[1348,1355]},{"content":"The following example demonstrates how an unmanaged function that takes a structure containing pointers can be called from a managed function.","pos":[1359,1501]},{"content":"The managed function creates an instance of the structure and initializes the embedded pointer with the new keyword (instead of the <bpt id=\"p1\">[</bpt>ref new, gcnew<ept id=\"p1\">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept> keyword).","pos":[1502,1714],"source":" The managed function creates an instance of the structure and initializes the embedded pointer with the new keyword (instead of the [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) keyword)."},{"content":"Because this allocates the memory on the native heap, there is no need to pin the array to suppress garbage collection.","pos":[1715,1834]},{"content":"However, the memory must be explicitly deleted to avoid memory leakage.","pos":[1835,1906]},{"content":"See Also","pos":[3455,3463]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[3468,3504]}],"content":"---\ntitle: \"How to: Marshal Embedded Pointers Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"structures [C++], marshaling embedded pointers\"\n  - \"interop [C++], embedded pointers\"\n  - \"C++ Interop, embedded pointers\"\n  - \"marshaling [C++], embedded pointers\"\n  - \"pointers [C++], marshaling\"\n  - \"data marshaling [C++], embedded pointers\"\nms.assetid: 05fb8858-97f2-47aa-86b2-2c0ad713bdb2\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Embedded Pointers Using C++ Interop\nThe following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Example  \n The following example demonstrates how an unmanaged function that takes a structure containing pointers can be called from a managed function. The managed function creates an instance of the structure and initializes the embedded pointer with the new keyword (instead of the [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) keyword). Because this allocates the memory on the native heap, there is no need to pin the array to suppress garbage collection. However, the memory must be explicitly deleted to avoid memory leakage.  \n  \n```  \n// marshal_embedded_pointer.cpp  \n// compile with: /clr  \n#include <iostream>  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n// unmanaged struct  \nstruct ListStruct {  \n   int count;  \n   double* item;  \n};  \n  \n#pragma unmanaged  \n  \nvoid UnmanagedTakesListStruct(ListStruct list) {  \n   printf_s(\"[unmanaged] count = %d\\n\", list.count);  \n   for (int i=0; i<list.count; i++)  \n      printf_s(\"array[%d] = %f\\n\", i, list.item[i]);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   ListStruct list;  \n   list.count = 10;  \n   list.item = new double[list.count];  \n  \n   Console::WriteLine(\"[managed] count = {0}\", list.count);  \n   Random^ r = gcnew Random(0);  \n   for (int i=0; i<list.count; i++) {  \n      list.item[i] = r->NextDouble() * 100.0;  \n      Console::WriteLine(\"array[{0}] = {1}\", i, list.item[i]);  \n   }  \n  \n   UnmanagedTakesListStruct( list );  \n   delete list.item;  \n}  \n```  \n  \n```Output  \n[managed] count = 10  \narray[0] = 72.624326996796  \narray[1] = 81.7325359590969  \narray[2] = 76.8022689394663  \narray[3] = 55.8161191436537  \narray[4] = 20.6033154021033  \narray[5] = 55.8884794618415  \narray[6] = 90.6027066011926  \narray[7] = 44.2177873310716  \narray[8] = 97.754975314138  \narray[9] = 27.370445768987  \n[unmanaged] count = 10  \narray[0] = 72.624327  \narray[1] = 81.732536  \narray[2] = 76.802269  \narray[3] = 55.816119  \narray[4] = 20.603315  \narray[5] = 55.888479  \narray[6] = 90.602707  \narray[7] = 44.217787  \narray[8] = 97.754975  \narray[9] = 27.370446  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}