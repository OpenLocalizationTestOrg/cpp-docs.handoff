{"nodes":[{"pos":[12,54],"content":"IUMSThreadProxy Structure | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"IUMSThreadProxy Structure | Microsoft Docs","pos":[0,42]}]},{"pos":[647,672],"content":"IUMSThreadProxy Structure","linkify":"IUMSThreadProxy Structure","nodes":[{"content":"IUMSThreadProxy Structure","pos":[0,25]}]},{"content":"An abstraction for a thread of execution.","pos":[673,714]},{"content":"If you want your scheduler to be granted user-mode schedulable (UMS) threads, set the value for the scheduler policy element <ph id=\"ph1\">`SchedulerKind`</ph> to <ph id=\"ph2\">`UmsThreadDefault`</ph>, and implement the <ph id=\"ph3\">`IUMSScheduler`</ph> interface.","pos":[715,923],"source":" If you want your scheduler to be granted user-mode schedulable (UMS) threads, set the value for the scheduler policy element `SchedulerKind` to `UmsThreadDefault`, and implement the `IUMSScheduler` interface."},{"content":"UMS threads are only supported on 64-bit operating systems with version Windows 7 and higher.","pos":[924,1017]},{"pos":[1026,1032],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1100,1107],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[1117,1131],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1138,1142]},{"content":"Description","pos":[1143,1154]},{"pos":[1192,1259],"content":"<bpt id=\"p1\">[</bpt>IUMSThreadProxy::EnterCriticalRegion Method<ept id=\"p1\">](#entercriticalregion)</ept>","source":"[IUMSThreadProxy::EnterCriticalRegion Method](#entercriticalregion)"},{"content":"Called in order to enter a critical region.","pos":[1260,1303]},{"content":"When inside a critical region, the scheduler will not observe asynchronous blocking operations that happen during the region.","pos":[1304,1429]},{"content":"This means that the scheduler will not be reentered for page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.","pos":[1430,1594]},{"pos":[1599,1676],"content":"<bpt id=\"p1\">[</bpt>IUMSThreadProxy::EnterHyperCriticalRegion Method<ept id=\"p1\">](#enterhypercriticalregion)</ept>","source":"[IUMSThreadProxy::EnterHyperCriticalRegion Method](#enterhypercriticalregion)"},{"content":"Called in order to enter a hyper-critical region.","pos":[1677,1726]},{"content":"When inside a hyper-critical region, the scheduler will not observe any blocking operations that happen during the region.","pos":[1727,1849]},{"content":"This means the scheduler will not be reentered for blocking function calls, lock acquisition attempts which block, page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.","pos":[1850,2073]},{"pos":[2078,2143],"content":"<bpt id=\"p1\">[</bpt>IUMSThreadProxy::ExitCriticalRegion Method<ept id=\"p1\">](#exitcriticalregion)</ept>","source":"[IUMSThreadProxy::ExitCriticalRegion Method](#exitcriticalregion)"},{"content":"Called in order to exit a critical region.","pos":[2144,2186]},{"pos":[2191,2266],"content":"<bpt id=\"p1\">[</bpt>IUMSThreadProxy::ExitHyperCriticalRegion Method<ept id=\"p1\">](#exithypercriticalregion)</ept>","source":"[IUMSThreadProxy::ExitHyperCriticalRegion Method](#exithypercriticalregion)"},{"content":"Called in order to exit a hyper-critical region.","pos":[2267,2315]},{"pos":[2320,2391],"content":"<bpt id=\"p1\">[</bpt>IUMSThreadProxy::GetCriticalRegionType Method<ept id=\"p1\">](#getcriticalregiontype)</ept>","source":"[IUMSThreadProxy::GetCriticalRegionType Method](#getcriticalregiontype)"},{"content":"Returns what kind of critical region the thread proxy is within.","pos":[2392,2456]},{"content":"Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, <ph id=\"ph1\">`InsideHyperCriticalRegion`</ph> will be returned.","pos":[2457,2641],"source":" Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, `InsideHyperCriticalRegion` will be returned."},{"pos":[2651,2672],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[2676,2717],"content":"<bpt id=\"p1\">[</bpt>IThreadProxy<ept id=\"p1\">](ithreadproxy-structure.md)</ept>","source":"[IThreadProxy](ithreadproxy-structure.md)"},{"pos":[2750,2762],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2766,2788],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> concrtrm.h","source":"**Header:** concrtrm.h"},{"pos":[2795,2821],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> concurrency","source":"**Namespace:** concurrency"},{"pos":[2831,2910],"content":"<bpt id=\"p1\">&lt;a name=\"entercriticalregion\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  IUMSThreadProxy::EnterCriticalRegion Method","linkify":"<a name=\"entercriticalregion\"></a>  IUMSThreadProxy::EnterCriticalRegion Method","source":"<a name=\"entercriticalregion\"></a>  IUMSThreadProxy::EnterCriticalRegion Method"},{"content":"Called in order to enter a critical region.","pos":[2914,2957]},{"content":"When inside a critical region, the scheduler will not observe asynchronous blocking operations that happen during the region.","pos":[2958,3083]},{"content":"This means that the scheduler will not be reentered for page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.","pos":[3084,3248]},{"pos":[3310,3322],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The new depth of critical region.","pos":[3326,3359]},{"content":"Critical regions are reentrant.","pos":[3360,3391]},{"pos":[3401,3490],"content":"<bpt id=\"p1\">&lt;a name=\"enterhypercriticalregion\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  IUMSThreadProxy::EnterHyperCriticalRegion Method","linkify":"<a name=\"enterhypercriticalregion\"></a>  IUMSThreadProxy::EnterHyperCriticalRegion Method","source":"<a name=\"enterhypercriticalregion\"></a>  IUMSThreadProxy::EnterHyperCriticalRegion Method"},{"content":"Called in order to enter a hyper-critical region.","pos":[3494,3543]},{"content":"When inside a hyper-critical region, the scheduler will not observe any blocking operations that happen during the region.","pos":[3544,3666]},{"content":"This means the scheduler will not be reentered for blocking function calls, lock acquisition attempts which block, page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.","pos":[3667,3890]},{"pos":[3957,3969],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The new depth of hyper-critical region.","pos":[3973,4012]},{"content":"Hyper-critical regions are reentrant.","pos":[4013,4050]},{"pos":[4060,4067],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The scheduler must be extraordinarily careful about what methods it calls and what locks it acquires in such regions.","pos":[4071,4188]},{"content":"If code in such a region blocks on a lock that is held by something the scheduler is responsible for scheduling, deadlock may ensue.","pos":[4189,4321]},{"pos":[4331,4408],"content":"<bpt id=\"p1\">&lt;a name=\"exitcriticalregion\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  IUMSThreadProxy::ExitCriticalRegion Method","linkify":"<a name=\"exitcriticalregion\"></a>  IUMSThreadProxy::ExitCriticalRegion Method","source":"<a name=\"exitcriticalregion\"></a>  IUMSThreadProxy::ExitCriticalRegion Method"},{"content":"Called in order to exit a critical region.","pos":[4412,4454]},{"pos":[4515,4527],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The new depth of critical region.","pos":[4531,4564]},{"content":"Critical regions are reentrant.","pos":[4565,4596]},{"pos":[4606,4693],"content":"<bpt id=\"p1\">&lt;a name=\"exithypercriticalregion\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  IUMSThreadProxy::ExitHyperCriticalRegion Method","linkify":"<a name=\"exithypercriticalregion\"></a>  IUMSThreadProxy::ExitHyperCriticalRegion Method","source":"<a name=\"exithypercriticalregion\"></a>  IUMSThreadProxy::ExitHyperCriticalRegion Method"},{"content":"Called in order to exit a hyper-critical region.","pos":[4697,4745]},{"pos":[4811,4823],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The new depth of hyper-critical region.","pos":[4827,4866]},{"content":"Hyper-critical regions are reentrant.","pos":[4867,4904]},{"pos":[4914,4997],"content":"<bpt id=\"p1\">&lt;a name=\"getcriticalregiontype\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  IUMSThreadProxy::GetCriticalRegionType Method","linkify":"<a name=\"getcriticalregiontype\"></a>  IUMSThreadProxy::GetCriticalRegionType Method","source":"<a name=\"getcriticalregiontype\"></a>  IUMSThreadProxy::GetCriticalRegionType Method"},{"content":"Returns what kind of critical region the thread proxy is within.","pos":[5001,5065]},{"content":"Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, <ph id=\"ph1\">`InsideHyperCriticalRegion`</ph> will be returned.","pos":[5066,5250],"source":" Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, `InsideHyperCriticalRegion` will be returned."},{"pos":[5335,5347],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The type of critical region the thread proxy is within.","pos":[5351,5406]},{"pos":[5415,5423],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>concurrency Namespace<ept id=\"p1\">](concurrency-namespace.md)</ept><ph id=\"ph1\"> </ph>","pos":[5427,5477],"source":"[concurrency Namespace](concurrency-namespace.md) "},{"content":"<bpt id=\"p1\"> [</bpt>IUMSScheduler Structure<ept id=\"p1\">](iumsscheduler-structure.md)</ept>","pos":[5480,5534],"source":" [IUMSScheduler Structure](iumsscheduler-structure.md)"}],"content":"---\ntitle: \"IUMSThreadProxy Structure | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"concrtrm/concurrency::IUMSThreadProxy\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"IUMSThreadProxy structure\"\nms.assetid: 61c69b7e-5c37-4048-bcb4-e75c536afd86\ncaps.latest.revision: 19\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# IUMSThreadProxy Structure\nAn abstraction for a thread of execution. If you want your scheduler to be granted user-mode schedulable (UMS) threads, set the value for the scheduler policy element `SchedulerKind` to `UmsThreadDefault`, and implement the `IUMSScheduler` interface. UMS threads are only supported on 64-bit operating systems with version Windows 7 and higher.  \n  \n## Syntax  \n  \n```\nstruct IUMSThreadProxy : public IThreadProxy;\n```  \n  \n## Members  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[IUMSThreadProxy::EnterCriticalRegion Method](#entercriticalregion)|Called in order to enter a critical region. When inside a critical region, the scheduler will not observe asynchronous blocking operations that happen during the region. This means that the scheduler will not be reentered for page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.|  \n|[IUMSThreadProxy::EnterHyperCriticalRegion Method](#enterhypercriticalregion)|Called in order to enter a hyper-critical region. When inside a hyper-critical region, the scheduler will not observe any blocking operations that happen during the region. This means the scheduler will not be reentered for blocking function calls, lock acquisition attempts which block, page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.|  \n|[IUMSThreadProxy::ExitCriticalRegion Method](#exitcriticalregion)|Called in order to exit a critical region.|  \n|[IUMSThreadProxy::ExitHyperCriticalRegion Method](#exithypercriticalregion)|Called in order to exit a hyper-critical region.|  \n|[IUMSThreadProxy::GetCriticalRegionType Method](#getcriticalregiontype)|Returns what kind of critical region the thread proxy is within. Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, `InsideHyperCriticalRegion` will be returned.|  \n  \n## Inheritance Hierarchy  \n [IThreadProxy](ithreadproxy-structure.md)  \n  \n `IUMSThreadProxy`  \n  \n## Requirements  \n **Header:** concrtrm.h  \n  \n **Namespace:** concurrency  \n  \n##  <a name=\"entercriticalregion\"></a>  IUMSThreadProxy::EnterCriticalRegion Method  \n Called in order to enter a critical region. When inside a critical region, the scheduler will not observe asynchronous blocking operations that happen during the region. This means that the scheduler will not be reentered for page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.  \n  \n```\nvirtual int EnterCriticalRegion() = 0;\n```  \n  \n### Return Value  \n The new depth of critical region. Critical regions are reentrant.  \n  \n##  <a name=\"enterhypercriticalregion\"></a>  IUMSThreadProxy::EnterHyperCriticalRegion Method  \n Called in order to enter a hyper-critical region. When inside a hyper-critical region, the scheduler will not observe any blocking operations that happen during the region. This means the scheduler will not be reentered for blocking function calls, lock acquisition attempts which block, page faults, thread suspensions, kernel asynchronous procedure calls (APCs), and so forth, for a UMS thread.  \n  \n```\nvirtual int EnterHyperCriticalRegion() = 0;\n```  \n  \n### Return Value  \n The new depth of hyper-critical region. Hyper-critical regions are reentrant.  \n  \n### Remarks  \n The scheduler must be extraordinarily careful about what methods it calls and what locks it acquires in such regions. If code in such a region blocks on a lock that is held by something the scheduler is responsible for scheduling, deadlock may ensue.  \n  \n##  <a name=\"exitcriticalregion\"></a>  IUMSThreadProxy::ExitCriticalRegion Method  \n Called in order to exit a critical region.  \n  \n```\nvirtual int ExitCriticalRegion() = 0;\n```  \n  \n### Return Value  \n The new depth of critical region. Critical regions are reentrant.  \n  \n##  <a name=\"exithypercriticalregion\"></a>  IUMSThreadProxy::ExitHyperCriticalRegion Method  \n Called in order to exit a hyper-critical region.  \n  \n```\nvirtual int ExitHyperCriticalRegion() = 0;\n```  \n  \n### Return Value  \n The new depth of hyper-critical region. Hyper-critical regions are reentrant.  \n  \n##  <a name=\"getcriticalregiontype\"></a>  IUMSThreadProxy::GetCriticalRegionType Method  \n Returns what kind of critical region the thread proxy is within. Because hyper-critical regions are a superset of critical regions, if code has entered a critical region and then a hyper-critical region, `InsideHyperCriticalRegion` will be returned.  \n  \n```\nvirtual CriticalRegionType GetCriticalRegionType() const = 0;\n```  \n  \n### Return Value  \n The type of critical region the thread proxy is within.  \n  \n## See Also  \n [concurrency Namespace](concurrency-namespace.md)   \n [IUMSScheduler Structure](iumsscheduler-structure.md)\n"}