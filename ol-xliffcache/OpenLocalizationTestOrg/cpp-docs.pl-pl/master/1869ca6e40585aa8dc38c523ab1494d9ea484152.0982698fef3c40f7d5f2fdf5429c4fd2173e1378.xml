{"nodes":[{"pos":[12,54],"content":"Initializing Scalar Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Initializing Scalar Types | Microsoft Docs","pos":[0,42]}]},{"content":"Initializing Scalar Types","pos":[872,897]},{"content":"When initializing scalar types, the value of the <bpt id=\"p1\">*</bpt>assignment-expression<ept id=\"p1\">*</ept> is assigned to the variable.","pos":[898,999],"source":"When initializing scalar types, the value of the *assignment-expression* is assigned to the variable."},{"content":"The conversion rules for assignment apply.","pos":[1000,1042]},{"content":"(See <bpt id=\"p1\">[</bpt>Type Conversions<ept id=\"p1\">](../c-language/type-conversions-c.md)</ept> for information on conversion rules.)","pos":[1043,1141],"source":" (See [Type Conversions](../c-language/type-conversions-c.md) for information on conversion rules.)"},{"content":"Syntax","pos":[1150,1156]},{"content":":","pos":[1173,1174]},{"content":"<bpt id=\"p1\"> *</bpt>declaration-specifiers init-declarator-list<ept id=\"p1\">*</ept> opt<bpt id=\"p2\">**</bpt>;<ept id=\"p2\">**</ept>","pos":[1177,1232],"source":" *declaration-specifiers init-declarator-list* opt**;**"},{"content":"<bpt id=\"p1\">*</bpt>declaration-specifiers<ept id=\"p1\">*</ept>:","pos":[1239,1264],"source":"*declaration-specifiers*:"},{"content":"<bpt id=\"p1\"> *</bpt>storage-class-specifier declaration-specifiers<ept id=\"p1\">*</ept> opt","pos":[1267,1320],"source":" *storage-class-specifier declaration-specifiers* opt"},{"pos":[1327,1370],"content":"<bpt id=\"p1\">*</bpt>type-specifier declaration-specifiers<ept id=\"p1\">*</ept> opt","source":"*type-specifier declaration-specifiers* opt"},{"pos":[1377,1420],"content":"<bpt id=\"p1\">*</bpt>type-qualifier declaration-specifiers<ept id=\"p1\">*</ept> opt","source":"*type-qualifier declaration-specifiers* opt"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept>:","pos":[1427,1450],"source":"*init-declarator-list*:"},{"content":"init-declarator","pos":[1455,1470]},{"pos":[1478,1526],"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>init-declarator<ept id=\"p3\">*</ept>","source":"*init-declarator-list*  **,**  *init-declarator*"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator<ept id=\"p1\">*</ept>:","pos":[1533,1551],"source":"*init-declarator*:"},{"content":"declarator","pos":[1556,1566]},{"pos":[1574,1637],"content":"<bpt id=\"p1\">*</bpt>declarator<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt><ph id=\"ph1\">=</ph><ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>initializer<ept id=\"p3\">*</ept> /* For scalar initialization","source":"*declarator*  **=**  *initializer* /* For scalar initialization "},{"content":"<bpt id=\"p1\">*</bpt>initializer<ept id=\"p1\">*</ept>:","pos":[1648,1662],"source":"*initializer*:"},{"content":"assignment-expression","pos":[1667,1688]},{"content":"You can initialize variables of any type, provided that you obey the following rules:","pos":[1696,1781]},{"content":"Variables declared at the file-scope level can be initialized.","pos":[1791,1853]},{"content":"If you do not explicitly initialize a variable at the external level, it is initialized to 0 by default.","pos":[1854,1958]},{"content":"A constant expression can be used to initialize any global variable declared with the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>storage-class-specifier<ept id=\"p2\">*</ept>.","pos":[1968,2091],"source":"A constant expression can be used to initialize any global variable declared with the **static** *storage-class-specifier*."},{"content":"Variables declared to be <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> are initialized when program execution begins.","pos":[2092,2174],"source":" Variables declared to be **static** are initialized when program execution begins."},{"content":"If you do not explicitly initialize a global <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> variable, it is initialized to 0 by default, and every member that has pointer type is assigned a null pointer.","pos":[2175,2342],"source":" If you do not explicitly initialize a global **static** variable, it is initialized to 0 by default, and every member that has pointer type is assigned a null pointer."},{"content":"Variables declared with the <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept> storage-class specifier are initialized each time execution control passes to the block in which they are declared.","pos":[2352,2520],"source":"Variables declared with the **auto** or **register** storage-class specifier are initialized each time execution control passes to the block in which they are declared."},{"content":"If you omit an initializer from the declaration of an <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept> variable, the initial value of the variable is undefined.","pos":[2521,2657],"source":" If you omit an initializer from the declaration of an **auto** or **register** variable, the initial value of the variable is undefined."},{"content":"For automatic and register values, the initializer is not restricted to being a constant; it can be any expression involving previously defined values, even function calls.","pos":[2658,2830]},{"content":"The initial values for external variable declarations and for all <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> variables, whether external or internal, must be constant expressions.","pos":[2840,2987],"source":"The initial values for external variable declarations and for all **static** variables, whether external or internal, must be constant expressions."},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Constant Expressions<ept id=\"p1\">](../c-language/c-constant-expressions.md)</ept>.) Since the address of any externally declared or static variable is constant, it can be used to initialize an internally declared <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept> pointer variable.","pos":[2988,3238],"source":" (For more information, see [Constant Expressions](../c-language/c-constant-expressions.md).) Since the address of any externally declared or static variable is constant, it can be used to initialize an internally declared **static** pointer variable."},{"content":"However, the address of an <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> variable cannot be used as a static initializer because it may be different for each execution of the block.","pos":[3239,3383],"source":" However, the address of an **auto** variable cannot be used as a static initializer because it may be different for each execution of the block."},{"content":"You can use either constant or variable values to initialize <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept> variables.","pos":[3384,3481],"source":" You can use either constant or variable values to initialize **auto** and **register** variables."},{"content":"If the declaration of an identifier has block scope, and the identifier has external linkage, the declaration cannot have an initialization.","pos":[3491,3631]},{"content":"Examples","pos":[3640,3648]},{"content":"The following examples illustrate initializations:","pos":[3652,3702]},{"pos":[3739,3811],"content":"The integer variable <ph id=\"ph1\">`x`</ph> is initialized to the constant expression <ph id=\"ph2\">`10`</ph>.","source":"The integer variable `x` is initialized to the constant expression `10`."},{"pos":[3857,3922],"content":"The pointer <ph id=\"ph1\">`px`</ph> is initialized to 0, producing a \"null\" pointer.","source":"The pointer `px` is initialized to 0, producing a \"null\" pointer."},{"pos":[3972,4120],"content":"This example uses a constant expression <ph id=\"ph1\">`(3 * 1024)`</ph> to initialize <ph id=\"ph2\">`c`</ph> to a constant value that cannot be modified because of the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> keyword.","source":"This example uses a constant expression `(3 * 1024)` to initialize `c` to a constant value that cannot be modified because of the **const** keyword."},{"pos":[4157,4242],"content":"This statement initializes the pointer <ph id=\"ph1\">`b`</ph> with the address of another variable, <ph id=\"ph2\">`x`</ph>.","source":"This statement initializes the pointer `b` with the address of another variable, `x`."},{"content":"The pointer <ph id=\"ph1\">`a`</ph> is initialized with the address of a variable named <ph id=\"ph2\">`z`</ph>.","pos":[4285,4357],"source":"The pointer `a` is initialized with the address of a variable named `z`."},{"content":"However, since it is specified to be a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, the variable <ph id=\"ph1\">`a`</ph> can only be initialized, never modified.","pos":[4358,4465],"source":" However, since it is specified to be a **const**, the variable `a` can only be initialized, never modified."},{"content":"It always points to the same location.","pos":[4466,4504]},{"content":"The global variable <ph id=\"ph1\">`GLOBAL`</ph> is declared at the external level, so it has global lifetime.","pos":[4779,4869],"source":"The global variable `GLOBAL` is declared at the external level, so it has global lifetime."},{"content":"The local variable <ph id=\"ph1\">`LOCAL`</ph> has <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> storage class and only has an address during the execution of the function in which it is declared.","pos":[4870,5009],"source":" The local variable `LOCAL` has **auto** storage class and only has an address during the execution of the function in which it is declared."},{"content":"Therefore, attempting to initialize the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> pointer variable <ph id=\"ph1\">`lp`</ph> with the address of <ph id=\"ph2\">`LOCAL`</ph> is not permitted.","pos":[5010,5128],"source":" Therefore, attempting to initialize the **static** pointer variable `lp` with the address of `LOCAL` is not permitted."},{"content":"The <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> pointer variable <ph id=\"ph1\">`gp`</ph> can be initialized to the address of <ph id=\"ph2\">`GLOBAL`</ph> because that address is always the same.","pos":[5129,5252],"source":" The **static** pointer variable `gp` can be initialized to the address of `GLOBAL` because that address is always the same."},{"content":"Similarly, <ph id=\"ph1\">`*rp`</ph> can be initialized because <ph id=\"ph2\">`rp`</ph> is a local variable and can have a nonconstant initializer.","pos":[5253,5361],"source":" Similarly, `*rp` can be initialized because `rp` is a local variable and can have a nonconstant initializer."},{"content":"Each time the block is entered, <ph id=\"ph1\">`LOCAL`</ph> has a new address, which is then assigned to <ph id=\"ph2\">`rp`</ph>.","pos":[5362,5452],"source":" Each time the block is entered, `LOCAL` has a new address, which is then assigned to `rp`."},{"content":"See Also","pos":[5461,5469]},{"content":"Initialization","pos":[5474,5488]}],"content":"---\ntitle: \"Initializing Scalar Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"initializing scalar types\"\n  - \"register variables\"\n  - \"initialization, scalar types\"\n  - \"initializing variables, scalar types\"\n  - \"scalar types\"\n  - \"static variables, initializing\"\n  - \"automatic storage class, initializing scalar types\"\n  - \"automatic storage class\"\n  - \"types [C], initializing\"\nms.assetid: 73c516f5-c3ad-4d56-ab3b-f2a82b621104\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Initializing Scalar Types\nWhen initializing scalar types, the value of the *assignment-expression* is assigned to the variable. The conversion rules for assignment apply. (See [Type Conversions](../c-language/type-conversions-c.md) for information on conversion rules.)  \n  \n## Syntax  \n `declaration`:  \n *declaration-specifiers init-declarator-list* opt**;**  \n  \n *declaration-specifiers*:  \n *storage-class-specifier declaration-specifiers* opt  \n  \n *type-specifier declaration-specifiers* opt  \n  \n *type-qualifier declaration-specifiers* opt  \n  \n *init-declarator-list*:  \n *init-declarator*  \n  \n *init-declarator-list*  **,**  *init-declarator*  \n  \n *init-declarator*:  \n *declarator*  \n  \n *declarator*  **=**  *initializer* /* For scalar initialization \\*/  \n  \n *initializer*:  \n *assignment-expression*  \n  \n You can initialize variables of any type, provided that you obey the following rules:  \n  \n-   Variables declared at the file-scope level can be initialized. If you do not explicitly initialize a variable at the external level, it is initialized to 0 by default.  \n  \n-   A constant expression can be used to initialize any global variable declared with the **static** *storage-class-specifier*. Variables declared to be **static** are initialized when program execution begins. If you do not explicitly initialize a global **static** variable, it is initialized to 0 by default, and every member that has pointer type is assigned a null pointer.  \n  \n-   Variables declared with the **auto** or **register** storage-class specifier are initialized each time execution control passes to the block in which they are declared. If you omit an initializer from the declaration of an **auto** or **register** variable, the initial value of the variable is undefined. For automatic and register values, the initializer is not restricted to being a constant; it can be any expression involving previously defined values, even function calls.  \n  \n-   The initial values for external variable declarations and for all **static** variables, whether external or internal, must be constant expressions. (For more information, see [Constant Expressions](../c-language/c-constant-expressions.md).) Since the address of any externally declared or static variable is constant, it can be used to initialize an internally declared **static** pointer variable. However, the address of an **auto** variable cannot be used as a static initializer because it may be different for each execution of the block. You can use either constant or variable values to initialize **auto** and **register** variables.  \n  \n-   If the declaration of an identifier has block scope, and the identifier has external linkage, the declaration cannot have an initialization.  \n  \n## Examples  \n The following examples illustrate initializations:  \n  \n```  \nint x = 10;   \n```  \n  \n The integer variable `x` is initialized to the constant expression `10`.  \n  \n```  \nregister int *px = 0;  \n```  \n  \n The pointer `px` is initialized to 0, producing a \"null\" pointer.  \n  \n```  \nconst int c = (3 * 1024);  \n```  \n  \n This example uses a constant expression `(3 * 1024)` to initialize `c` to a constant value that cannot be modified because of the **const** keyword.  \n  \n```  \nint *b = &x;  \n```  \n  \n This statement initializes the pointer `b` with the address of another variable, `x`.  \n  \n```  \nint *const a = &z;  \n```  \n  \n The pointer `a` is initialized with the address of a variable named `z`. However, since it is specified to be a **const**, the variable `a` can only be initialized, never modified. It always points to the same location.  \n  \n```  \nint GLOBAL ;  \n  \nint function( void )  \n{  \n    int LOCAL ;  \n    static int *lp = &LOCAL;   /* Illegal initialization */  \n    static int *gp = &GLOBAL;  /* Legal initialization   */  \n    register int *rp = &LOCAL; /* Legal initialization   */  \n}  \n```  \n  \n The global variable `GLOBAL` is declared at the external level, so it has global lifetime. The local variable `LOCAL` has **auto** storage class and only has an address during the execution of the function in which it is declared. Therefore, attempting to initialize the **static** pointer variable `lp` with the address of `LOCAL` is not permitted. The **static** pointer variable `gp` can be initialized to the address of `GLOBAL` because that address is always the same. Similarly, `*rp` can be initialized because `rp` is a local variable and can have a nonconstant initializer. Each time the block is entered, `LOCAL` has a new address, which is then assigned to `rp`.  \n  \n## See Also  \n [Initialization](../c-language/initialization.md)"}