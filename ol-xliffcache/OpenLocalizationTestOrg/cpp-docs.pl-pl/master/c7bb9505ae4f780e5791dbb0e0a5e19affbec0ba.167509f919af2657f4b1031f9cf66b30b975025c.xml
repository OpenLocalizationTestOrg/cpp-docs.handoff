{"nodes":[{"pos":[12,87],"content":"Design Principles for Collection and Enumerator Interfaces | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Design Principles for Collection and Enumerator Interfaces | Microsoft Docs","pos":[0,75]}]},{"content":"Design Principles for Collection and Enumerator Interfaces","pos":[646,704]},{"content":"There are different design principles behind each type of interface:","pos":[705,773]},{"pos":[783,1032],"content":"A collection interface provides <bpt id=\"p1\">*</bpt>random<ept id=\"p1\">*</ept> access to a <bpt id=\"p2\">*</bpt>single<ept id=\"p2\">*</ept> item in the collection via the <bpt id=\"p3\">**</bpt>Item<ept id=\"p3\">**</ept> method, it lets clients discover how many items are in the collection via the <bpt id=\"p4\">**</bpt>Count<ept id=\"p4\">**</ept> property, and often allows clients to add and remove items.","source":"A collection interface provides *random* access to a *single* item in the collection via the **Item** method, it lets clients discover how many items are in the collection via the **Count** property, and often allows clients to add and remove items."},{"pos":[1042,1310],"content":"An enumerator interface provides <bpt id=\"p1\">*</bpt>serial<ept id=\"p1\">*</ept> access to <bpt id=\"p2\">*</bpt>multiple<ept id=\"p2\">*</ept> items in a collection, it doesn't allow the client to discover how many items are in the collection (until the enumerator stops returning items), and it doesn't provide any way of adding or removing items.","source":"An enumerator interface provides *serial* access to *multiple* items in a collection, it doesn't allow the client to discover how many items are in the collection (until the enumerator stops returning items), and it doesn't provide any way of adding or removing items."},{"content":"Each type of interface plays a different role in providing access to the elements in a collection.","pos":[1317,1415]},{"content":"See Also","pos":[1424,1432]},{"content":"Collections and Enumerators","pos":[1437,1464]}],"content":"---\ntitle: \"Design Principles for Collection and Enumerator Interfaces | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"enumerator interfaces\"\n  - \"collection interfaces\"\nms.assetid: ea19a39e-6333-41a1-be62-5435c236640e\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Design Principles for Collection and Enumerator Interfaces\nThere are different design principles behind each type of interface:  \n  \n-   A collection interface provides *random* access to a *single* item in the collection via the **Item** method, it lets clients discover how many items are in the collection via the **Count** property, and often allows clients to add and remove items.  \n  \n-   An enumerator interface provides *serial* access to *multiple* items in a collection, it doesn't allow the client to discover how many items are in the collection (until the enumerator stops returning items), and it doesn't provide any way of adding or removing items.  \n  \n Each type of interface plays a different role in providing access to the elements in a collection.  \n  \n## See Also  \n [Collections and Enumerators](../atl/atl-collections-and-enumerators.md)\n\n"}