{"nodes":[{"pos":[12,45],"content":"CMultiLock Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CMultiLock Class | Microsoft Docs","pos":[0,33]}]},{"pos":[650,666],"content":"CMultiLock Class","linkify":"CMultiLock Class","nodes":[{"content":"CMultiLock Class","pos":[0,16]}]},{"content":"Represents the access-control mechanism used in controlling access to resources in a multithreaded program.","pos":[667,774]},{"pos":[783,789],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[832,839],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[849,868],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[875,879]},{"content":"Description","pos":[880,891]},{"pos":[929,978],"content":"<bpt id=\"p1\">[</bpt>CMultiLock::CMultiLock<ept id=\"p1\">](#cmultilock__cmultilock)</ept>","source":"[CMultiLock::CMultiLock](#cmultilock__cmultilock)"},{"pos":[979,1012],"content":"Constructs a <ph id=\"ph1\">`CMultiLock`</ph> object.","source":"Constructs a `CMultiLock` object."},{"pos":[1023,1037],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1044,1048]},{"content":"Description","pos":[1049,1060]},{"pos":[1098,1143],"content":"<bpt id=\"p1\">[</bpt>CMultiLock::IsLocked<ept id=\"p1\">](#cmultilock__islocked)</ept>","source":"[CMultiLock::IsLocked](#cmultilock__islocked)"},{"content":"Determines if a specific synchronization object in the array is locked.","pos":[1144,1215]},{"pos":[1220,1257],"content":"<bpt id=\"p1\">[</bpt>CMultiLock::Lock<ept id=\"p1\">](#cmultilock__lock)</ept>","source":"[CMultiLock::Lock](#cmultilock__lock)"},{"content":"Waits on the array of synchronization objects.","pos":[1258,1304]},{"pos":[1309,1350],"content":"<bpt id=\"p1\">[</bpt>CMultiLock::Unlock<ept id=\"p1\">](#cmultilock__unlock)</ept>","source":"[CMultiLock::Unlock](#cmultilock__unlock)"},{"content":"Releases any owned synchronization objects.","pos":[1351,1394]},{"pos":[1404,1411],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1415,1455],"content":"<ph id=\"ph1\">`CMultiLock`</ph> does not have a base class.","source":"`CMultiLock` does not have a base class."},{"content":"To use the synchronization classes <bpt id=\"p1\">[</bpt>CSemaphore<ept id=\"p1\">](../../mfc/reference/csemaphore-class.md)</ept>, <bpt id=\"p2\">[</bpt>CMutex<ept id=\"p2\">](../../mfc/reference/cmutex-class.md)</ept>, and <bpt id=\"p3\">[</bpt>CEvent<ept id=\"p3\">](../../mfc/reference/cevent-class.md)</ept>, you can create either a <bpt id=\"p4\">**</bpt>CMultiLock<ept id=\"p4\">**</ept> or <bpt id=\"p5\">[</bpt>CSingleLock<ept id=\"p5\">](../../mfc/reference/csinglelock-class.md)</ept> object to wait on and release the synchronization object.","pos":[1462,1805],"source":"To use the synchronization classes [CSemaphore](../../mfc/reference/csemaphore-class.md), [CMutex](../../mfc/reference/cmutex-class.md), and [CEvent](../../mfc/reference/cevent-class.md), you can create either a **CMultiLock** or [CSingleLock](../../mfc/reference/csinglelock-class.md) object to wait on and release the synchronization object."},{"content":"Use <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> when there are multiple objects that you could use at a particular time.","pos":[1806,1897],"source":" Use **CMultiLock** when there are multiple objects that you could use at a particular time."},{"content":"Use <ph id=\"ph1\">`CSingleLock`</ph> when you only need to wait on one object at a time.","pos":[1898,1967],"source":" Use `CSingleLock` when you only need to wait on one object at a time."},{"content":"To use a <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> object, first create an array of the synchronization objects that you wish to wait on.","pos":[1974,2084],"source":"To use a **CMultiLock** object, first create an array of the synchronization objects that you wish to wait on."},{"content":"Next, call the <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> object's constructor inside a member function in the controlled resource's class.","pos":[2085,2196],"source":" Next, call the **CMultiLock** object's constructor inside a member function in the controlled resource's class."},{"content":"Then call the <bpt id=\"p1\">[</bpt>Lock<ept id=\"p1\">](#cmultilock__lock)</ept> member function to determine if a resource is available (signaled).","pos":[2197,2304],"source":" Then call the [Lock](#cmultilock__lock) member function to determine if a resource is available (signaled)."},{"content":"If one is, continue with the remainder of the member function.","pos":[2305,2367]},{"content":"If no resource is available, either wait for a specified amount of time for a resource to be released, or return failure.","pos":[2368,2489]},{"content":"After use of a resource is complete, either call the <bpt id=\"p1\">[</bpt>Unlock<ept id=\"p1\">](#cmultilock__unlock)</ept> function if the <bpt id=\"p2\">**</bpt>CMultiLock<ept id=\"p2\">**</ept> object is to be used again, or allow the <bpt id=\"p3\">**</bpt>CMultiLock<ept id=\"p3\">**</ept> object to be destroyed.","pos":[2490,2683],"source":" After use of a resource is complete, either call the [Unlock](#cmultilock__unlock) function if the **CMultiLock** object is to be used again, or allow the **CMultiLock** object to be destroyed."},{"content":"<bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> objects are most useful when a thread has a large number of <ph id=\"ph1\">`CEvent`</ph> objects it can respond to.","pos":[2690,2800],"source":"**CMultiLock** objects are most useful when a thread has a large number of `CEvent` objects it can respond to."},{"content":"Create an array containing all the <ph id=\"ph1\">`CEvent`</ph> pointers, and call <ph id=\"ph2\">`Lock`</ph>.","pos":[2801,2871],"source":" Create an array containing all the `CEvent` pointers, and call `Lock`."},{"content":"This will cause the thread to wait until one of the events is signaled.","pos":[2872,2943]},{"pos":[2950,3155],"content":"For more information on how to use <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> objects, see the article <bpt id=\"p2\">[</bpt>Multithreading: How to Use the Synchronization Classes<ept id=\"p2\">](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)</ept>.","source":"For more information on how to use **CMultiLock** objects, see the article [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)."},{"pos":[3164,3185],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[3210,3222],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[3226,3245],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxmt.h","source":"**Header:** afxmt.h"},{"pos":[3255,3316],"content":"<bpt id=\"p1\">&lt;a name=\"cmultilock__cmultilock\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMultiLock::CMultiLock","linkify":"<a name=\"cmultilock__cmultilock\"></a>  CMultiLock::CMultiLock","source":"<a name=\"cmultilock__cmultilock\"></a>  CMultiLock::CMultiLock"},{"pos":[3320,3355],"content":"Constructs a <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> object.","source":"Constructs a **CMultiLock** object."},{"pos":[3479,3489],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Array of pointers to the synchronization objects to be waited on.","pos":[3508,3573]},{"content":"Cannot be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[3574,3593],"source":" Cannot be **NULL**."},{"content":"Number of objects in <ph id=\"ph1\">`ppObjects`</ph>.","pos":[3613,3646],"source":" Number of objects in `ppObjects`."},{"content":"Must be greater than 0.","pos":[3647,3670]},{"content":"Specifies whether to initially attempt to access any of the supplied objects.","pos":[3695,3772]},{"pos":[3782,3789],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This function is called after creating the array of synchronization objects to be waited on.","pos":[3793,3885]},{"content":"It is usually called from within the thread that must wait for one of the synchronization objects to become available.","pos":[3886,4004]},{"pos":[4014,4071],"content":"<bpt id=\"p1\">&lt;a name=\"cmultilock__islocked\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMultiLock::IsLocked","linkify":"<a name=\"cmultilock__islocked\"></a>  CMultiLock::IsLocked","source":"<a name=\"cmultilock__islocked\"></a>  CMultiLock::IsLocked"},{"content":"Determines if the specified object is nonsignaled (unavailable).","pos":[4075,4139]},{"pos":[4193,4203],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>dwItem<ept id=\"p1\">*</ept>","pos":[4207,4215],"source":"*dwItem*"},{"content":"The index in the array of objects corresponding to the object whose state is being queried.","pos":[4219,4310]},{"pos":[4320,4332],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the specified object is locked; otherwise 0.","pos":[4336,4391]},{"pos":[4401,4450],"content":"<bpt id=\"p1\">&lt;a name=\"cmultilock__lock\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMultiLock::Lock","linkify":"<a name=\"cmultilock__lock\"></a>  CMultiLock::Lock","source":"<a name=\"cmultilock__lock\"></a>  CMultiLock::Lock"},{"pos":[4454,4605],"content":"Call this function to gain access to one or more of the resources controlled by the synchronization objects supplied to the <bpt id=\"p1\">**</bpt>CMultiLock<ept id=\"p1\">**</ept> constructor.","source":"Call this function to gain access to one or more of the resources controlled by the synchronization objects supplied to the **CMultiLock** constructor."},{"pos":[4734,4744],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>dwTimeOut<ept id=\"p1\">*</ept>","pos":[4748,4759],"source":"*dwTimeOut*"},{"content":"Specifies the amount of time to wait for the synchronization object to be available (signaled).","pos":[4763,4858]},{"content":"If <bpt id=\"p1\">**</bpt>INFINITE<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`Lock`</ph> will wait until the object is signaled before returning.","pos":[4859,4939],"source":" If **INFINITE**, `Lock` will wait until the object is signaled before returning."},{"content":"Specifies whether all objects waited on must become signaled at the same time before returning.","pos":[4963,5058]},{"content":"If <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`Lock`</ph> will return when any one of the objects waited on is signaled.","pos":[5059,5142],"source":" If **FALSE**, `Lock` will return when any one of the objects waited on is signaled."},{"content":"Specifies other conditions that are allowed to abort the wait.","pos":[5165,5227]},{"content":"For a full list of the available options for this parameter, see <bpt id=\"p1\">[</bpt>MsgWaitForMultipleObjects<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms684242)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[5228,5440],"source":" For a full list of the available options for this parameter, see [MsgWaitForMultipleObjects](http://msdn.microsoft.com/library/windows/desktop/ms684242) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[5450,5462],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If <ph id=\"ph1\">`Lock`</ph> fails, it returns – 1.","pos":[5466,5498],"source":"If `Lock` fails, it returns – 1."},{"content":"If successful, it returns one of the following values:","pos":[5499,5553]},{"pos":[5563,5636],"content":"Between <bpt id=\"p1\">**</bpt>WAIT_OBJECT_0<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WAIT_OBJECT_0<ept id=\"p2\">**</ept> + (number of objects – 1)","source":"Between **WAIT_OBJECT_0** and **WAIT_OBJECT_0** + (number of objects – 1)"},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>, all objects are signaled (available).","pos":[5647,5714],"source":"If `bWaitForAll` is **TRUE**, all objects are signaled (available)."},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, the return value – <bpt id=\"p2\">**</bpt>WAIT_OBJECT_0<ept id=\"p2\">**</ept> is the index in the array of objects of the object that is signaled (available).","pos":[5715,5863],"source":" If `bWaitForAll` is **FALSE**, the return value – **WAIT_OBJECT_0** is the index in the array of objects of the object that is signaled (available)."},{"pos":[5871,5910],"content":"<bpt id=\"p1\">**</bpt>WAIT_OBJECT_0<ept id=\"p1\">**</ept> + (number of objects)","source":"**WAIT_OBJECT_0** + (number of objects)"},{"pos":[5921,5997],"content":"An event specified in <ph id=\"ph1\">`dwWakeMask`</ph> is available in the thread's input queue.","source":"An event specified in `dwWakeMask` is available in the thread's input queue."},{"pos":[6007,6086],"content":"Between <bpt id=\"p1\">**</bpt>WAIT_ABANDONED_0<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WAIT_ABANDONED_0<ept id=\"p2\">**</ept> + (number of objects – 1)","source":"Between **WAIT_ABANDONED_0** and **WAIT_ABANDONED_0** + (number of objects – 1)"},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>, all objects are signaled, and at least one of the objects is an abandoned mutex object.","pos":[6097,6214],"source":"If `bWaitForAll` is **TRUE**, all objects are signaled, and at least one of the objects is an abandoned mutex object."},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, the return value – <bpt id=\"p2\">**</bpt>WAIT_ABANDONED_0<ept id=\"p2\">**</ept> is the index in the array of objects of the abandoned mutex object that satisfied the wait.","pos":[6215,6377],"source":" If `bWaitForAll` is **FALSE**, the return value – **WAIT_ABANDONED_0** is the index in the array of objects of the abandoned mutex object that satisfied the wait."},{"pos":[6385,6401],"content":"<bpt id=\"p1\">**</bpt>WAIT_TIMEOUT<ept id=\"p1\">**</ept>","source":"**WAIT_TIMEOUT**"},{"pos":[6412,6494],"content":"The timeout interval specified in <bpt id=\"p1\">*</bpt>dwTimeOut<ept id=\"p1\">*</ept> expired without the wait succeeding.","source":"The timeout interval specified in *dwTimeOut* expired without the wait succeeding."},{"pos":[6504,6511],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`Lock`</ph> will return successfully as soon as all the synchronization objects become signaled simultaneously.","pos":[6515,6651],"source":"If `bWaitForAll` is **TRUE**, `Lock` will return successfully as soon as all the synchronization objects become signaled simultaneously."},{"content":"If <ph id=\"ph1\">`bWaitForAll`</ph> is <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`Lock`</ph> will return as soon as one or more of the synchronization objects becomes signaled.","pos":[6652,6773],"source":" If `bWaitForAll` is **FALSE**, `Lock` will return as soon as one or more of the synchronization objects becomes signaled."},{"content":"If <ph id=\"ph1\">`Lock`</ph> is not able to return immediately, it will wait for no more than the number of milliseconds specified in the <bpt id=\"p1\">*</bpt>dwTimeOut<ept id=\"p1\">*</ept> parameter before returning.","pos":[6780,6938],"source":"If `Lock` is not able to return immediately, it will wait for no more than the number of milliseconds specified in the *dwTimeOut* parameter before returning."},{"content":"If <bpt id=\"p1\">*</bpt>dwTimeOut<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>INFINITE<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`Lock`</ph> will not return until access to an object is gained or a condition specified in <ph id=\"ph2\">`dwWakeMask`</ph> was met.","pos":[6939,7079],"source":" If *dwTimeOut* is **INFINITE**, `Lock` will not return until access to an object is gained or a condition specified in `dwWakeMask` was met."},{"content":"Otherwise, if <ph id=\"ph1\">`Lock`</ph> was able to acquire a synchronization object, it will return successfully; if not, it will return failure.","pos":[7080,7207],"source":" Otherwise, if `Lock` was able to acquire a synchronization object, it will return successfully; if not, it will return failure."},{"pos":[7217,7270],"content":"<bpt id=\"p1\">&lt;a name=\"cmultilock__unlock\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMultiLock::Unlock","linkify":"<a name=\"cmultilock__unlock\"></a>  CMultiLock::Unlock","source":"<a name=\"cmultilock__unlock\"></a>  CMultiLock::Unlock"},{"pos":[7274,7332],"content":"Releases the synchronization object owned by <ph id=\"ph1\">`CMultiLock`</ph>.","source":"Releases the synchronization object owned by `CMultiLock`."},{"pos":[7438,7448],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Number of reference counts to release.","pos":[7464,7502]},{"content":"Must be greater than 0.","pos":[7503,7526]},{"content":"If the specified amount would cause the object's count to exceed its maximum, the count is not changed and the function returns <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>.","pos":[7527,7665],"source":" If the specified amount would cause the object's count to exceed its maximum, the count is not changed and the function returns **FALSE**."},{"content":"Points to a variable to receive the previous count for the synchronization object.","pos":[7688,7770]},{"content":"If <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the previous count is not returned.","pos":[7771,7819],"source":" If **NULL**, the previous count is not returned."},{"pos":[7829,7841],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function was successful; otherwise 0.","pos":[7845,7897]},{"pos":[7907,7914],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7918,7971],"content":"This function is called by <ph id=\"ph1\">`CMultiLock`</ph>'s destructor.","source":"This function is called by `CMultiLock`'s destructor."},{"content":"The first form of <ph id=\"ph1\">`Unlock`</ph> tries to unlock the synchronization object managed by <ph id=\"ph2\">`CMultiLock`</ph>.","pos":[7978,8072],"source":"The first form of `Unlock` tries to unlock the synchronization object managed by `CMultiLock`."},{"content":"The second form of <ph id=\"ph1\">`Unlock`</ph> tries to unlock the <ph id=\"ph2\">`CSemaphore`</ph> objects owned by <ph id=\"ph3\">`CMultiLock`</ph>.","pos":[8073,8164],"source":" The second form of `Unlock` tries to unlock the `CSemaphore` objects owned by `CMultiLock`."},{"content":"If <ph id=\"ph1\">`CMultiLock`</ph> does not own any locked <ph id=\"ph2\">`CSemaphore`</ph> object, the function returns <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>; otherwise, it returns <bpt id=\"p2\">**</bpt>TRUE<ept id=\"p2\">**</ept>.","pos":[8165,8289],"source":" If `CMultiLock` does not own any locked `CSemaphore` object, the function returns **FALSE**; otherwise, it returns **TRUE**."},{"content":"<ph id=\"ph1\">`lCount`</ph> and <ph id=\"ph2\">`lpPrevCount`</ph> are exactly the same as the parameters of <bpt id=\"p1\">[</bpt>CSingleLock::Unlock<ept id=\"p1\">](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)</ept>.","pos":[8290,8443],"source":"`lCount` and `lpPrevCount` are exactly the same as the parameters of [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)."},{"content":"The second form of <ph id=\"ph1\">`Unlock`</ph> is rarely applicable to multilock situations.","pos":[8444,8517],"source":" The second form of `Unlock` is rarely applicable to multilock situations."},{"pos":[8526,8534],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[8538,8585],"content":"<bpt id=\"p1\">[</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept>","source":"[Hierarchy Chart](../../mfc/hierarchy-chart.md)"}],"content":"---\ntitle: \"CMultiLock Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CMultiLock\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CMultiLock class\"\n  - \"synchronization objects, access control\"\nms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CMultiLock Class\nRepresents the access-control mechanism used in controlling access to resources in a multithreaded program.  \n  \n## Syntax  \n  \n```  \nclass CMultiLock  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMultiLock::CMultiLock](#cmultilock__cmultilock)|Constructs a `CMultiLock` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMultiLock::IsLocked](#cmultilock__islocked)|Determines if a specific synchronization object in the array is locked.|  \n|[CMultiLock::Lock](#cmultilock__lock)|Waits on the array of synchronization objects.|  \n|[CMultiLock::Unlock](#cmultilock__unlock)|Releases any owned synchronization objects.|  \n  \n## Remarks  \n `CMultiLock` does not have a base class.  \n  \n To use the synchronization classes [CSemaphore](../../mfc/reference/csemaphore-class.md), [CMutex](../../mfc/reference/cmutex-class.md), and [CEvent](../../mfc/reference/cevent-class.md), you can create either a **CMultiLock** or [CSingleLock](../../mfc/reference/csinglelock-class.md) object to wait on and release the synchronization object. Use **CMultiLock** when there are multiple objects that you could use at a particular time. Use `CSingleLock` when you only need to wait on one object at a time.  \n  \n To use a **CMultiLock** object, first create an array of the synchronization objects that you wish to wait on. Next, call the **CMultiLock** object's constructor inside a member function in the controlled resource's class. Then call the [Lock](#cmultilock__lock) member function to determine if a resource is available (signaled). If one is, continue with the remainder of the member function. If no resource is available, either wait for a specified amount of time for a resource to be released, or return failure. After use of a resource is complete, either call the [Unlock](#cmultilock__unlock) function if the **CMultiLock** object is to be used again, or allow the **CMultiLock** object to be destroyed.  \n  \n **CMultiLock** objects are most useful when a thread has a large number of `CEvent` objects it can respond to. Create an array containing all the `CEvent` pointers, and call `Lock`. This will cause the thread to wait until one of the events is signaled.  \n  \n For more information on how to use **CMultiLock** objects, see the article [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).  \n  \n## Inheritance Hierarchy  \n `CMultiLock`  \n  \n## Requirements  \n **Header:** afxmt.h  \n  \n##  <a name=\"cmultilock__cmultilock\"></a>  CMultiLock::CMultiLock  \n Constructs a **CMultiLock** object.  \n  \n```  \nCMultiLock(\n    CSyncObject* ppObjects [ ],  \n    DWORD dwCount,  \n    BOOL bInitialLock = FALSE);\n```  \n  \n### Parameters  \n `ppObjects`  \n Array of pointers to the synchronization objects to be waited on. Cannot be **NULL**.  \n  \n `dwCount`  \n Number of objects in `ppObjects`. Must be greater than 0.  \n  \n `bInitialLock`  \n Specifies whether to initially attempt to access any of the supplied objects.  \n  \n### Remarks  \n This function is called after creating the array of synchronization objects to be waited on. It is usually called from within the thread that must wait for one of the synchronization objects to become available.  \n  \n##  <a name=\"cmultilock__islocked\"></a>  CMultiLock::IsLocked  \n Determines if the specified object is nonsignaled (unavailable).  \n  \n```  \nBOOL IsLocked(DWORD dwItem);\n```  \n  \n### Parameters  \n *dwItem*  \n The index in the array of objects corresponding to the object whose state is being queried.  \n  \n### Return Value  \n Nonzero if the specified object is locked; otherwise 0.  \n  \n##  <a name=\"cmultilock__lock\"></a>  CMultiLock::Lock  \n Call this function to gain access to one or more of the resources controlled by the synchronization objects supplied to the **CMultiLock** constructor.  \n  \n```  \nDWORD Lock(\n    DWORD dwTimeOut = INFINITE,  \n    BOOL bWaitForAll = TRUE,  \n    DWORD dwWakeMask = 0);\n```  \n  \n### Parameters  \n *dwTimeOut*  \n Specifies the amount of time to wait for the synchronization object to be available (signaled). If **INFINITE**, `Lock` will wait until the object is signaled before returning.  \n  \n `bWaitForAll`  \n Specifies whether all objects waited on must become signaled at the same time before returning. If **FALSE**, `Lock` will return when any one of the objects waited on is signaled.  \n  \n `dwWakeMask`  \n Specifies other conditions that are allowed to abort the wait. For a full list of the available options for this parameter, see [MsgWaitForMultipleObjects](http://msdn.microsoft.com/library/windows/desktop/ms684242) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Return Value  \n If `Lock` fails, it returns – 1. If successful, it returns one of the following values:  \n  \n-   Between **WAIT_OBJECT_0** and **WAIT_OBJECT_0** + (number of objects – 1)  \n  \n     If `bWaitForAll` is **TRUE**, all objects are signaled (available). If `bWaitForAll` is **FALSE**, the return value – **WAIT_OBJECT_0** is the index in the array of objects of the object that is signaled (available).  \n  \n- **WAIT_OBJECT_0** + (number of objects)  \n  \n     An event specified in `dwWakeMask` is available in the thread's input queue.  \n  \n-   Between **WAIT_ABANDONED_0** and **WAIT_ABANDONED_0** + (number of objects – 1)  \n  \n     If `bWaitForAll` is **TRUE**, all objects are signaled, and at least one of the objects is an abandoned mutex object. If `bWaitForAll` is **FALSE**, the return value – **WAIT_ABANDONED_0** is the index in the array of objects of the abandoned mutex object that satisfied the wait.  \n  \n- **WAIT_TIMEOUT**  \n  \n     The timeout interval specified in *dwTimeOut* expired without the wait succeeding.  \n  \n### Remarks  \n If `bWaitForAll` is **TRUE**, `Lock` will return successfully as soon as all the synchronization objects become signaled simultaneously. If `bWaitForAll` is **FALSE**, `Lock` will return as soon as one or more of the synchronization objects becomes signaled.  \n  \n If `Lock` is not able to return immediately, it will wait for no more than the number of milliseconds specified in the *dwTimeOut* parameter before returning. If *dwTimeOut* is **INFINITE**, `Lock` will not return until access to an object is gained or a condition specified in `dwWakeMask` was met. Otherwise, if `Lock` was able to acquire a synchronization object, it will return successfully; if not, it will return failure.  \n  \n##  <a name=\"cmultilock__unlock\"></a>  CMultiLock::Unlock  \n Releases the synchronization object owned by `CMultiLock`.  \n  \n```  \nBOOL Unlock();\n\n \nBOOL Unlock(\n    LONG lCount,  \n    LPLONG lPrevCount = NULL);\n```  \n  \n### Parameters  \n `lCount`  \n Number of reference counts to release. Must be greater than 0. If the specified amount would cause the object's count to exceed its maximum, the count is not changed and the function returns **FALSE**.  \n  \n `lPrevCount`  \n Points to a variable to receive the previous count for the synchronization object. If **NULL**, the previous count is not returned.  \n  \n### Return Value  \n Nonzero if the function was successful; otherwise 0.  \n  \n### Remarks  \n This function is called by `CMultiLock`'s destructor.  \n  \n The first form of `Unlock` tries to unlock the synchronization object managed by `CMultiLock`. The second form of `Unlock` tries to unlock the `CSemaphore` objects owned by `CMultiLock`. If `CMultiLock` does not own any locked `CSemaphore` object, the function returns **FALSE**; otherwise, it returns **TRUE**. `lCount` and `lpPrevCount` are exactly the same as the parameters of [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock). The second form of `Unlock` is rarely applicable to multilock situations.  \n  \n## See Also  \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n\n\n"}