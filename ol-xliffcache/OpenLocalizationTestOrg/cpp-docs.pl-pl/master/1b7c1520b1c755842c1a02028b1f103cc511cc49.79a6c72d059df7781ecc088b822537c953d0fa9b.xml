{"nodes":[{"pos":[12,50],"content":"Raw Pseudo Operations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Raw Pseudo Operations | Microsoft Docs","pos":[0,38]}]},{"content":"Raw Pseudo Operations","pos":[530,551]},{"content":"This topic lists the pseudo operations.","pos":[552,591]},{"content":"Remarks","pos":[600,607]},{"content":"Pseudo operation","pos":[614,630]},{"content":"Description","pos":[631,642]},{"content":"PROC FRAME [:ehandler]","pos":[692,714]},{"content":"Causes MASM to generate a function table entry in .pdata and unwind information in .xdata for a function's structured exception handling unwind behavior.","pos":[715,868]},{"content":"If ehandler is present, this proc is entered in the .xdata as the language specific handler.","pos":[870,962]},{"content":"When the FRAME attribute is used, it must be followed by an .ENDPROLOG directive.","pos":[975,1056]},{"content":"If the function is a leaf function (as defined in <bpt id=\"p1\">[</bpt>Function Types<ept id=\"p1\">](../build/function-types.md)</ept>) the FRAME attribute is unnecessary, as are the remainder of these pseudo-operations.","pos":[1058,1238],"source":"  If the function is a leaf function (as defined in [Function Types](../build/function-types.md)) the FRAME attribute is unnecessary, as are the remainder of these pseudo-operations."},{"content":".PUSHREG reg","pos":[1243,1255]},{"content":"Generates a UWOP_PUSH_NONVOL unwind code entry for the specified register number using the current offset in the prologue.","pos":[1256,1378]},{"content":"This should only be used with nonvolatile integer registers.","pos":[1391,1451]},{"content":"For pushes of volatile registers, use an .ALLOCSTACK 8, instead","pos":[1453,1516]},{"content":".SETFRAME reg, offset","pos":[1521,1542]},{"content":"Fills in the frame register field and offset in the unwind information using the specified register and offset.","pos":[1543,1654]},{"content":"The offset must be a multiple of 16 and less than or equal to 240.","pos":[1655,1721]},{"content":"This directive also generates a UWOP_SET_FPREG unwind code entry for the specified register using the current prologue offset.","pos":[1722,1848]},{"content":".ALLOCSTACK size","pos":[1853,1869]},{"content":"Generates a UWOP_ALLOC_SMALL or a UWOP_ALLOC_LARGE with the specified size for the current offset in the prologue.","pos":[1870,1984]},{"content":"The size operand must be a multiple of 8.","pos":[1997,2038]},{"content":".SAVEREG reg, offset","pos":[2043,2063]},{"content":"Generates either a UWOP_SAVE_NONVOL or a UWOP_SAVE_NONVOL_FAR unwind code entry for the specified register and offset using the current prologue offset.","pos":[2064,2216]},{"content":"MASM will choose the most efficient encoding.","pos":[2217,2262]},{"content":"Offset must be positive, and a multiple of 8.","pos":[2275,2320]},{"content":"Offset is relative to the base of the procedure’s frame, which is generally in RSP, or, if using a frame pointer, the unscaled frame pointer.","pos":[2322,2463]},{"content":".SAVEXMM128 reg, offset","pos":[2468,2491]},{"content":"Generates either a UWOP_SAVE_XMM128 or a UWOP_SAVE_XMM128_FAR unwind code entry for the specified XMM register and offset using the current prologue offset.","pos":[2492,2648]},{"content":"MASM will choose the most efficient encoding.","pos":[2649,2694]},{"content":"Offset must be positive, and a multiple of 16.","pos":[2707,2753]},{"content":"Offset is relative to the base of the procedure’s frame, which is generally in RSP, or, if using a frame pointer, the unscaled frame pointer.","pos":[2755,2896]},{"content":".PUSHFRAME [code]","pos":[2901,2918]},{"content":"Generates a UWOP_PUSH_MACHFRAME unwind code entry.","pos":[2919,2969]},{"content":"If the optional code is specified, the unwind code entry is given a modifier of 1.","pos":[2970,3052]},{"content":"Otherwise the modifier is 0.","pos":[3053,3081]},{"content":".ENDPROLOG","pos":[3086,3096]},{"content":"Signals the end of the prologue declarations.","pos":[3097,3142]},{"content":"Must occur in the first 255 bytes of the function.","pos":[3144,3194]},{"content":"Here is a sample function prolog with proper usage of most of the opcodes:","pos":[3202,3276]},{"content":"See Also","pos":[4490,4498]},{"content":"Unwind Helpers for MASM","pos":[4503,4526]}],"content":"---\ntitle: \"Raw Pseudo Operations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 4def1a0e-ec28-4736-91fb-fac95fba1f36\ncaps.latest.revision: 4\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Raw Pseudo Operations\nThis topic lists the pseudo operations.  \n  \n## Remarks  \n  \n|Pseudo operation|Description|  \n|----------------------|-----------------|  \n|PROC FRAME [:ehandler]|Causes MASM to generate a function table entry in .pdata and unwind information in .xdata for a function's structured exception handling unwind behavior.  If ehandler is present, this proc is entered in the .xdata as the language specific handler.<br /><br /> When the FRAME attribute is used, it must be followed by an .ENDPROLOG directive.  If the function is a leaf function (as defined in [Function Types](../build/function-types.md)) the FRAME attribute is unnecessary, as are the remainder of these pseudo-operations.|  \n|.PUSHREG reg|Generates a UWOP_PUSH_NONVOL unwind code entry for the specified register number using the current offset in the prologue.<br /><br /> This should only be used with nonvolatile integer registers.  For pushes of volatile registers, use an .ALLOCSTACK 8, instead|  \n|.SETFRAME reg, offset|Fills in the frame register field and offset in the unwind information using the specified register and offset. The offset must be a multiple of 16 and less than or equal to 240. This directive also generates a UWOP_SET_FPREG unwind code entry for the specified register using the current prologue offset.|  \n|.ALLOCSTACK size|Generates a UWOP_ALLOC_SMALL or a UWOP_ALLOC_LARGE with the specified size for the current offset in the prologue.<br /><br /> The size operand must be a multiple of 8.|  \n|.SAVEREG reg, offset|Generates either a UWOP_SAVE_NONVOL or a UWOP_SAVE_NONVOL_FAR unwind code entry for the specified register and offset using the current prologue offset. MASM will choose the most efficient encoding.<br /><br /> Offset must be positive, and a multiple of 8.  Offset is relative to the base of the procedure’s frame, which is generally in RSP, or, if using a frame pointer, the unscaled frame pointer.|  \n|.SAVEXMM128 reg, offset|Generates either a UWOP_SAVE_XMM128 or a UWOP_SAVE_XMM128_FAR unwind code entry for the specified XMM register and offset using the current prologue offset. MASM will choose the most efficient encoding.<br /><br /> Offset must be positive, and a multiple of 16.  Offset is relative to the base of the procedure’s frame, which is generally in RSP, or, if using a frame pointer, the unscaled frame pointer.|  \n|.PUSHFRAME [code]|Generates a UWOP_PUSH_MACHFRAME unwind code entry. If the optional code is specified, the unwind code entry is given a modifier of 1. Otherwise the modifier is 0.|  \n|.ENDPROLOG|Signals the end of the prologue declarations.  Must occur in the first 255 bytes of the function.|  \n  \n Here is a sample function prolog with proper usage of most of the opcodes:  \n  \n```  \nsample PROC FRAME     \n   db      048h; emit a REX prefix, to enable hot-patching  \npush rbp  \n.pushreg rbp  \nsub rsp, 040h  \n.allocstack 040h     \nlea rbp, [rsp+020h]  \n.setframe rbp, 020h  \nmovdqa [rbp], xmm7  \n.savexmm128 xmm7, 020h;the offset is from the base of the frame  \n;not the scaled offset of the frame  \nmov [rbp+018h], rsi  \n.savereg rsi, 038h  \nmov [rsp+010h], rdi  \n.savereg rdi, 010h; you can still use RSP as the base of the frame  \n; or any other register you choose  \n.endprolog  \n  \n; you can modify the stack pointer outside of the prologue (similar to alloca)  \n; because we have a frame pointer.  \n; if we didn’t have a frame pointer, this would be illegal  \n; if we didn’t make this modification,  \n; there would be no need for a frame pointer  \n  \nsub rsp, 060h  \n  \n; we can unwind from the following AV because of the frame pointer  \n  \nmov rax, 0  \nmov rax, [rax] ; AV!  \n  \n; restore the registers that weren’t saved with a push  \n; this isn’t part of the official epilog, as described in section 2.5  \n  \nmovdqa xmm7, [rbp]  \nmov rsi, [rbp+018h]  \nmov rdi, [rbp-010h]  \n  \n; Here’s the official epilog  \n  \nlea rsp, [rbp-020h]  \npop rbp  \nret  \nsample ENDP  \n```  \n  \n## See Also  \n [Unwind Helpers for MASM](../build/unwind-helpers-for-masm.md)"}