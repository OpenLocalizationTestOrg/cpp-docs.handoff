{"nodes":[{"pos":[12,73],"content":"TN003: Mapping of Windows Handles to Objects | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN003: Mapping of Windows Handles to Objects | Microsoft Docs","pos":[0,61]}]},{"content":"TN003: Mapping of Windows Handles to Objects","pos":[719,763]},{"content":"This note describes the MFC routines that support mapping Windows object handles to C++ objects.","pos":[764,860]},{"content":"The Problem","pos":[869,880]},{"content":"Windows objects are typically represented by various <bpt id=\"p1\">[</bpt>HANDLE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa383751)</ept> objects The MFC classes wrap Windows object handles with C++ objects.","pos":[884,1075],"source":"Windows objects are typically represented by various [HANDLE](http://msdn.microsoft.com/library/windows/desktop/aa383751) objects The MFC classes wrap Windows object handles with C++ objects."},{"content":"The handle wrapping functions of the MFC class library let you find the C++ object that is wrapping the Windows object that has a particular handle.","pos":[1076,1224]},{"content":"However, sometimes an object does not have a C++ wrapper object and at these times the system creates a temporary object to act as the C++ wrapper.","pos":[1225,1372]},{"content":"The Windows objects that use handle maps are as follows:","pos":[1379,1435]},{"pos":[1445,1517],"content":"HWND (<bpt id=\"p1\">[</bpt>CWnd<ept id=\"p1\">](../mfc/reference/cwnd-class.md)</ept> and <ph id=\"ph1\">`CWnd`</ph>-derived classes)","source":"HWND ([CWnd](../mfc/reference/cwnd-class.md) and `CWnd`-derived classes)"},{"pos":[1527,1595],"content":"HDC (<bpt id=\"p1\">[</bpt>CDC<ept id=\"p1\">](../mfc/reference/cdc-class.md)</ept> and <ph id=\"ph1\">`CDC`</ph>-derived classes)","source":"HDC ([CDC](../mfc/reference/cdc-class.md) and `CDC`-derived classes)"},{"pos":[1605,1653],"content":"HMENU (<bpt id=\"p1\">[</bpt>CMenu<ept id=\"p1\">](../mfc/reference/cmenu-class.md)</ept>)","source":"HMENU ([CMenu](../mfc/reference/cmenu-class.md))"},{"pos":[1663,1720],"content":"HPEN (<bpt id=\"p1\">[</bpt>CGdiObject<ept id=\"p1\">](../mfc/reference/cgdiobject-class.md)</ept>)","source":"HPEN ([CGdiObject](../mfc/reference/cgdiobject-class.md))"},{"pos":[1730,1751],"content":"HBRUSH (<ph id=\"ph1\">`CGdiObject`</ph>)","source":"HBRUSH (`CGdiObject`)"},{"pos":[1761,1781],"content":"HFONT (<ph id=\"ph1\">`CGdiObject`</ph>)","source":"HFONT (`CGdiObject`)"},{"pos":[1791,1813],"content":"HBITMAP (<ph id=\"ph1\">`CGdiObject`</ph>)","source":"HBITMAP (`CGdiObject`)"},{"pos":[1823,1846],"content":"HPALETTE (<ph id=\"ph1\">`CGdiObject`</ph>)","source":"HPALETTE (`CGdiObject`)"},{"pos":[1856,1875],"content":"HRGN (<ph id=\"ph1\">`CGdiObject`</ph>)","source":"HRGN (`CGdiObject`)"},{"pos":[1885,1948],"content":"HIMAGELIST (<bpt id=\"p1\">[</bpt>CImageList<ept id=\"p1\">](../mfc/reference/cimagelist-class.md)</ept>)","source":"HIMAGELIST ([CImageList](../mfc/reference/cimagelist-class.md))"},{"pos":[1958,2011],"content":"SOCKET (<bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept>)","source":"SOCKET ([CSocket](../mfc/reference/csocket-class.md))"},{"content":"Given a handle to any one of these objects, you can find the MFC object that wraps the handle by calling the static method <ph id=\"ph1\">`FromHandle`</ph>.","pos":[2018,2154],"source":"Given a handle to any one of these objects, you can find the MFC object that wraps the handle by calling the static method `FromHandle`."},{"content":"For example, given an HWND called <ph id=\"ph1\">`hWnd`</ph>, the following line will return a pointer to the <ph id=\"ph2\">`CWnd`</ph> that wraps <ph id=\"ph3\">`hWnd`</ph>:","pos":[2155,2270],"source":" For example, given an HWND called `hWnd`, the following line will return a pointer to the `CWnd` that wraps `hWnd`:"},{"content":"If <ph id=\"ph1\">`hWnd`</ph> does not have a specific wrapper object, a temporary <ph id=\"ph2\">`CWnd`</ph> is created to wrap <ph id=\"ph3\">`hWnd`</ph>.","pos":[2317,2413],"source":"If `hWnd` does not have a specific wrapper object, a temporary `CWnd` is created to wrap `hWnd`."},{"content":"This makes it possible to obtain a valid C++ object from any handle.","pos":[2414,2482]},{"content":"After you have a wrapper object, you can retrieve its handle from a public member variable of the wrapper class.","pos":[2489,2601]},{"content":"In the case of a <ph id=\"ph1\">`CWnd`</ph>, <ph id=\"ph2\">`m_hWnd`</ph> contains the HWND for that object.","pos":[2602,2670],"source":" In the case of a `CWnd`, `m_hWnd` contains the HWND for that object."},{"content":"Attaching Handles to MFC Objects","pos":[2679,2711]},{"pos":[2715,2871],"content":"Given a newly created handle-wrapper object and a handle to a Windows object, you can associate the two by calling the <ph id=\"ph1\">`Attach`</ph> function as in this example:","source":"Given a newly created handle-wrapper object and a handle to a Windows object, you can associate the two by calling the `Attach` function as in this example:"},{"content":"This makes an entry in the permanent map associating <ph id=\"ph1\">`myWnd`</ph> and <ph id=\"ph2\">`hWnd`</ph>.","pos":[2927,2999],"source":"This makes an entry in the permanent map associating `myWnd` and `hWnd`."},{"content":"Calling <ph id=\"ph1\">`CWnd::FromHandle(hWnd)`</ph> will now return a pointer to <ph id=\"ph2\">`myWnd`</ph>.","pos":[3000,3070],"source":" Calling `CWnd::FromHandle(hWnd)` will now return a pointer to `myWnd`."},{"content":"When <ph id=\"ph1\">`myWnd`</ph> is deleted, the destructor will automatically destroy <ph id=\"ph2\">`hWnd`</ph> by calling the Windows <bpt id=\"p1\">[</bpt>DestroyWindow<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms632682)</ept> function.","pos":[3071,3253],"source":" When `myWnd` is deleted, the destructor will automatically destroy `hWnd` by calling the Windows [DestroyWindow](http://msdn.microsoft.com/library/windows/desktop/ms632682) function."},{"content":"If this is not desired, <ph id=\"ph1\">`hWnd`</ph> must be detached from <ph id=\"ph2\">`myWnd`</ph> before <ph id=\"ph3\">`myWnd`</ph> is destroyed (normally when leaving the scope at which <ph id=\"ph4\">`myWnd`</ph> was defined).","pos":[3254,3406],"source":" If this is not desired, `hWnd` must be detached from `myWnd` before `myWnd` is destroyed (normally when leaving the scope at which `myWnd` was defined)."},{"content":"The <ph id=\"ph1\">`Detach`</ph> method does this.","pos":[3407,3437],"source":" The `Detach` method does this."},{"content":"More About Temporary Objects","pos":[3477,3505]},{"content":"Temporary objects are created whenever <ph id=\"ph1\">`FromHandle`</ph> is given a handle that does not already have a wrapper object.","pos":[3509,3623],"source":"Temporary objects are created whenever `FromHandle` is given a handle that does not already have a wrapper object."},{"content":"These temporary objects are detached from their handle and deleted by the <ph id=\"ph1\">`DeleteTempMap`</ph> functions.","pos":[3624,3724],"source":" These temporary objects are detached from their handle and deleted by the `DeleteTempMap` functions."},{"content":"By default <bpt id=\"p1\">[</bpt>CWinThread::OnIdle<ept id=\"p1\">](../mfc/reference/cwinthread-class.md#cwinthread__onidle)</ept> automatically calls <ph id=\"ph1\">`DeleteTempMap`</ph> for each class that supports temporary handle maps.","pos":[3725,3901],"source":" By default [CWinThread::OnIdle](../mfc/reference/cwinthread-class.md#cwinthread__onidle) automatically calls `DeleteTempMap` for each class that supports temporary handle maps."},{"content":"This means that you cannot assume a pointer to a temporary object will be valid past the point of exit from the function where the pointer was obtained.","pos":[3902,4054]},{"content":"Wrapper Objects and Multiple Threads","pos":[4063,4099]},{"content":"Both temporary and permanent objects are maintained on a per-thread basis.","pos":[4103,4177]},{"content":"That is, one thread cannot access another thread's C++ wrapper objects, regardless of whether it is temporary or permanent.","pos":[4178,4301]},{"content":"To pass these objects from one thread to another, always send them as their native <ph id=\"ph1\">`HANDLE`</ph> type.","pos":[4308,4405],"source":"To pass these objects from one thread to another, always send them as their native `HANDLE` type."},{"content":"Passing a C++ wrapper object from one thread to another will often cause unexpected results.","pos":[4406,4498]},{"content":"See Also","pos":[4507,4515]},{"content":"Technical Notes by Number","pos":[4520,4545]},{"content":"Technical Notes by Category","pos":[4589,4616]}],"content":"---\ntitle: \"TN003: Mapping of Windows Handles to Objects | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mapping\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"TN003\"\n  - \"handle maps\"\n  - \"Windows handles to objects [C++]\"\n  - \"mappings, Windows handles to objects\"\nms.assetid: fbea9f38-992c-4091-8dbc-f29e288617d6\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN003: Mapping of Windows Handles to Objects\nThis note describes the MFC routines that support mapping Windows object handles to C++ objects.  \n  \n## The Problem  \n Windows objects are typically represented by various [HANDLE](http://msdn.microsoft.com/library/windows/desktop/aa383751) objects The MFC classes wrap Windows object handles with C++ objects. The handle wrapping functions of the MFC class library let you find the C++ object that is wrapping the Windows object that has a particular handle. However, sometimes an object does not have a C++ wrapper object and at these times the system creates a temporary object to act as the C++ wrapper.  \n  \n The Windows objects that use handle maps are as follows:  \n  \n-   HWND ([CWnd](../mfc/reference/cwnd-class.md) and `CWnd`-derived classes)  \n  \n-   HDC ([CDC](../mfc/reference/cdc-class.md) and `CDC`-derived classes)  \n  \n-   HMENU ([CMenu](../mfc/reference/cmenu-class.md))  \n  \n-   HPEN ([CGdiObject](../mfc/reference/cgdiobject-class.md))  \n  \n-   HBRUSH (`CGdiObject`)  \n  \n-   HFONT (`CGdiObject`)  \n  \n-   HBITMAP (`CGdiObject`)  \n  \n-   HPALETTE (`CGdiObject`)  \n  \n-   HRGN (`CGdiObject`)  \n  \n-   HIMAGELIST ([CImageList](../mfc/reference/cimagelist-class.md))  \n  \n-   SOCKET ([CSocket](../mfc/reference/csocket-class.md))  \n  \n Given a handle to any one of these objects, you can find the MFC object that wraps the handle by calling the static method `FromHandle`. For example, given an HWND called `hWnd`, the following line will return a pointer to the `CWnd` that wraps `hWnd`:  \n  \n```  \nCWnd::FromHandle(hWnd)  \n```  \n  \n If `hWnd` does not have a specific wrapper object, a temporary `CWnd` is created to wrap `hWnd`. This makes it possible to obtain a valid C++ object from any handle.  \n  \n After you have a wrapper object, you can retrieve its handle from a public member variable of the wrapper class. In the case of a `CWnd`, `m_hWnd` contains the HWND for that object.  \n  \n## Attaching Handles to MFC Objects  \n Given a newly created handle-wrapper object and a handle to a Windows object, you can associate the two by calling the `Attach` function as in this example:  \n  \n```  \nCWnd myWnd;  \nmyWnd.Attach(hWnd);\n```  \n  \n This makes an entry in the permanent map associating `myWnd` and `hWnd`. Calling `CWnd::FromHandle(hWnd)` will now return a pointer to `myWnd`. When `myWnd` is deleted, the destructor will automatically destroy `hWnd` by calling the Windows [DestroyWindow](http://msdn.microsoft.com/library/windows/desktop/ms632682) function. If this is not desired, `hWnd` must be detached from `myWnd` before `myWnd` is destroyed (normally when leaving the scope at which `myWnd` was defined). The `Detach` method does this.  \n  \n```  \nmyWnd.Detach();\n```  \n  \n## More About Temporary Objects  \n Temporary objects are created whenever `FromHandle` is given a handle that does not already have a wrapper object. These temporary objects are detached from their handle and deleted by the `DeleteTempMap` functions. By default [CWinThread::OnIdle](../mfc/reference/cwinthread-class.md#cwinthread__onidle) automatically calls `DeleteTempMap` for each class that supports temporary handle maps. This means that you cannot assume a pointer to a temporary object will be valid past the point of exit from the function where the pointer was obtained.  \n  \n## Wrapper Objects and Multiple Threads  \n Both temporary and permanent objects are maintained on a per-thread basis. That is, one thread cannot access another thread's C++ wrapper objects, regardless of whether it is temporary or permanent.  \n  \n To pass these objects from one thread to another, always send them as their native `HANDLE` type. Passing a C++ wrapper object from one thread to another will often cause unexpected results.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}