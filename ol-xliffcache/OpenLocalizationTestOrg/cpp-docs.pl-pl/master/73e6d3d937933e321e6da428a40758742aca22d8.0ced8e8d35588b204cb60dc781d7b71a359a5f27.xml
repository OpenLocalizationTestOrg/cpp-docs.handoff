{"nodes":[{"pos":[12,43],"content":"__sptr, __uptr | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__sptr, __uptr | Microsoft Docs","pos":[0,31]}]},{"content":"__sptr, __uptr","pos":[674,688]},{"content":"Microsoft Specific","pos":[692,710]},{"content":"Use the <ph id=\"ph1\">`__sptr`</ph> or <ph id=\"ph2\">`__uptr`</ph> modifier on a 32-bit pointer declaration to specify how the compiler converts a 32-bit pointer to a 64-bit pointer.","pos":[714,858],"source":"Use the `__sptr` or `__uptr` modifier on a 32-bit pointer declaration to specify how the compiler converts a 32-bit pointer to a 64-bit pointer."},{"content":"A 32-bit pointer is converted, for example, when it is assigned to a 64-bit pointer variable or is dereferenced on a 64-bit platform.","pos":[859,992]},{"content":"Microsoft documentation for support of 64-bit platforms sometimes refers to the most significant bit of a 32-bit pointer as the sign bit.","pos":[999,1136]},{"content":"By default, the compiler uses sign extension to convert a 32-bit pointer to a 64-bit pointer.","pos":[1137,1230]},{"content":"That is, the least significant 32 bits of the 64-bit pointer are set to the value of the 32-bit pointer and the most significant 32 bits are set to the value of the sign bit of the 32-bit pointer.","pos":[1231,1427]},{"content":"This conversion yields correct results if the sign bit is 0, but not if the sign bit is 1.","pos":[1428,1518]},{"content":"For example, the 32-bit address 0x7FFFFFFF yields the equivalent 64-bit address 0x000000007FFFFFFF, but the 32-bit address 0x80000000 is incorrectly changed to 0xFFFFFFFF80000000.","pos":[1519,1698]},{"content":"The <ph id=\"ph1\">`__sptr`</ph>, or signed pointer, modifier specifies that a pointer conversion set the most significant bits of a 64-bit pointer to the sign bit of the 32-bit pointer.","pos":[1705,1871],"source":"The `__sptr`, or signed pointer, modifier specifies that a pointer conversion set the most significant bits of a 64-bit pointer to the sign bit of the 32-bit pointer."},{"content":"The <ph id=\"ph1\">`__uptr`</ph>, or unsigned pointer, modifier specifies that a conversion set the most significant bits to zero.","pos":[1872,1982],"source":" The `__uptr`, or unsigned pointer, modifier specifies that a conversion set the most significant bits to zero."},{"content":"The following declarations show the <ph id=\"ph1\">`__sptr`</ph> and <ph id=\"ph2\">`__uptr`</ph> modifiers used with two unqualified pointers, two pointers qualified with the <bpt id=\"p1\">[</bpt>__ptr32<ept id=\"p1\">](../cpp/ptr32-ptr64.md)</ept> type, and a function parameter.","pos":[1983,2183],"source":" The following declarations show the `__sptr` and `__uptr` modifiers used with two unqualified pointers, two pointers qualified with the [__ptr32](../cpp/ptr32-ptr64.md) type, and a function parameter."},{"content":"Use the <ph id=\"ph1\">`__sptr`</ph> and <ph id=\"ph2\">`__uptr`</ph> modifiers with pointer declarations.","pos":[2355,2421],"source":"Use the `__sptr` and `__uptr` modifiers with pointer declarations."},{"content":"Use the modifiers in the position of a <bpt id=\"p1\">[</bpt>pointer type qualifier<ept id=\"p1\">](../c-language/pointer-declarations.md)</ept>, which means the modifier must follow the asterisk.","pos":[2422,2576],"source":" Use the modifiers in the position of a [pointer type qualifier](../c-language/pointer-declarations.md), which means the modifier must follow the asterisk."},{"content":"You cannot use the modifiers with <bpt id=\"p1\">[</bpt>pointers to members<ept id=\"p1\">](../cpp/pointers-to-members.md)</ept>.","pos":[2577,2664],"source":" You cannot use the modifiers with [pointers to members](../cpp/pointers-to-members.md)."},{"content":"The modifiers do not affect non-pointer declarations.","pos":[2665,2718]},{"content":"Example","pos":[2727,2734]},{"content":"The following example declares 32-bit pointers that use the <ph id=\"ph1\">`__sptr`</ph> and <ph id=\"ph2\">`__uptr`</ph> modifiers, assigns each 32-bit pointer to a 64-bit pointer variable, and then displays the hexadecimal value of each 64-bit pointer.","pos":[2738,2952],"source":"The following example declares 32-bit pointers that use the `__sptr` and `__uptr` modifiers, assigns each 32-bit pointer to a 64-bit pointer variable, and then displays the hexadecimal value of each 64-bit pointer."},{"content":"The example is compiled with the native 64-bit compiler and is executed on a 64-bit platform.","pos":[2953,3046]},{"content":"END Microsoft Specific","pos":[4491,4513]},{"content":"See Also","pos":[4522,4530]},{"content":"Microsoft-Specific Modifiers","pos":[4535,4563]}],"content":"---\ntitle: \"__sptr, __uptr | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__uptr_cpp\"\n  - \"__sptr\"\n  - \"__uptr\"\n  - \"__sptr_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__sptr modifier\"\n  - \"__uptr modifier\"\nms.assetid: c7f5f3b2-9106-4a0b-a6de-d1588ab153ed\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# __sptr, __uptr\n## Microsoft Specific  \n Use the `__sptr` or `__uptr` modifier on a 32-bit pointer declaration to specify how the compiler converts a 32-bit pointer to a 64-bit pointer. A 32-bit pointer is converted, for example, when it is assigned to a 64-bit pointer variable or is dereferenced on a 64-bit platform.  \n  \n Microsoft documentation for support of 64-bit platforms sometimes refers to the most significant bit of a 32-bit pointer as the sign bit. By default, the compiler uses sign extension to convert a 32-bit pointer to a 64-bit pointer. That is, the least significant 32 bits of the 64-bit pointer are set to the value of the 32-bit pointer and the most significant 32 bits are set to the value of the sign bit of the 32-bit pointer. This conversion yields correct results if the sign bit is 0, but not if the sign bit is 1. For example, the 32-bit address 0x7FFFFFFF yields the equivalent 64-bit address 0x000000007FFFFFFF, but the 32-bit address 0x80000000 is incorrectly changed to 0xFFFFFFFF80000000.  \n  \n The `__sptr`, or signed pointer, modifier specifies that a pointer conversion set the most significant bits of a 64-bit pointer to the sign bit of the 32-bit pointer. The `__uptr`, or unsigned pointer, modifier specifies that a conversion set the most significant bits to zero. The following declarations show the `__sptr` and `__uptr` modifiers used with two unqualified pointers, two pointers qualified with the [__ptr32](../cpp/ptr32-ptr64.md) type, and a function parameter.  \n  \n```  \nint * __sptr psp;  \nint * __uptr pup;  \nint * __ptr32 __sptr psp32;  \nint * __ptr32 __uptr pup32;  \nvoid MyFunction(char * __uptr __ptr32 myValue);  \n```  \n  \n Use the `__sptr` and `__uptr` modifiers with pointer declarations. Use the modifiers in the position of a [pointer type qualifier](../c-language/pointer-declarations.md), which means the modifier must follow the asterisk. You cannot use the modifiers with [pointers to members](../cpp/pointers-to-members.md). The modifiers do not affect non-pointer declarations.  \n  \n## Example  \n The following example declares 32-bit pointers that use the `__sptr` and `__uptr` modifiers, assigns each 32-bit pointer to a 64-bit pointer variable, and then displays the hexadecimal value of each 64-bit pointer. The example is compiled with the native 64-bit compiler and is executed on a 64-bit platform.  \n  \n```cpp  \n// sptr_uptr.cpp  \n// processor: x64  \n#include \"stdio.h\"  \n  \nint main()  \n{  \n    void *        __ptr64 p64;  \n    void *        __ptr32 p32d; //default signed pointer  \n    void * __sptr __ptr32 p32s; //explicit signed pointer  \n    void * __uptr __ptr32 p32u; //explicit unsigned pointer  \n  \n// Set the 32-bit pointers to a value whose sign bit is 1.  \n    p32d = reinterpret_cast<void *>(0x87654321);  \n    p32s = p32d;  \n    p32u = p32d;  \n  \n// The printf() function automatically displays leading zeroes with each 32-bit pointer. These are unrelated   \n// to the __sptr and __uptr modifiers.   \n    printf(\"Display each 32-bit pointer (as an unsigned 64-bit pointer):\\n\");  \n    printf(\"p32d:       %p\\n\", p32d);   \n    printf(\"p32s:       %p\\n\", p32s);  \n    printf(\"p32u:       %p\\n\", p32u);  \n  \n    printf(\"\\nDisplay the 64-bit pointer created from each 32-bit pointer:\\n\");  \n    p64 = p32d;   \n    printf(\"p32d: p64 = %p\\n\", p64);  \n    p64 = p32s;  \n    printf(\"p32s: p64 = %p\\n\", p64);  \n    p64 = p32u;  \n    printf(\"p32u: p64 = %p\\n\", p64);  \n    return 0;  \n}  \n```  \n  \n```Output  \nDisplay each 32-bit pointer (as an unsigned 64-bit pointer):  \np32d:       0000000087654321  \np32s:       0000000087654321  \np32u:       0000000087654321  \n  \nDisplay the 64-bit pointer created from each 32-bit pointer:  \np32d: p64 = FFFFFFFF87654321  \np32s: p64 = FFFFFFFF87654321  \np32u: p64 = 0000000087654321  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md)"}