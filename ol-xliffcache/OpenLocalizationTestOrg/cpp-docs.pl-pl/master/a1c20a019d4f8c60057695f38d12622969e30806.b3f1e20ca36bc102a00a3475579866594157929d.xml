{"nodes":[{"pos":[12,36],"content":"EXPORTS | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"EXPORTS | Microsoft Docs","pos":[0,24]}]},{"content":"EXPORTS","pos":[601,608]},{"content":"Introduces a section of one or more export definitions that specify the exported names or ordinals of functions or data.","pos":[609,729]},{"content":"Each definition must be on a separate line.","pos":[730,773]},{"content":"Remarks","pos":[823,830]},{"content":"The first <ph id=\"ph1\">`definition`</ph> can be on the same line as the <ph id=\"ph2\">`EXPORTS`</ph> keyword or on a subsequent line.","pos":[834,930],"source":"The first `definition` can be on the same line as the `EXPORTS` keyword or on a subsequent line."},{"content":"The .DEF file can contain one or more <ph id=\"ph1\">`EXPORTS`</ph> statements.","pos":[931,990],"source":" The .DEF file can contain one or more `EXPORTS` statements."},{"pos":[997,1038],"content":"The syntax for an export <ph id=\"ph1\">`definition`</ph> is:","source":"The syntax for an export `definition` is:"},{"content":"is the function or variable name that you want to export.","pos":[1143,1200]},{"content":"This is required.","pos":[1201,1218]},{"content":"If the name that you export differs from the name in the DLL, specify the export's name in the DLL by using <ph id=\"ph1\">`internalname`</ph>.","pos":[1219,1342],"source":" If the name that you export differs from the name in the DLL, specify the export's name in the DLL by using `internalname`."},{"content":"For example, if your DLL exports a function <ph id=\"ph1\">`func1`</ph> and you want callers to use it as <ph id=\"ph2\">`func2`</ph>, you would specify:","pos":[1343,1456],"source":" For example, if your DLL exports a function `func1` and you want callers to use it as `func2`, you would specify:"},{"content":"Because the Visual C++ compiler uses name decoration for C++ functions, you must either use the decorated name as the <ph id=\"ph1\">`entryname`</ph> or <ph id=\"ph2\">`internalname`</ph>, or define the exported functions by using <ph id=\"ph3\">`extern \"C\"`</ph> in the source code.","pos":[1505,1728],"source":"Because the Visual C++ compiler uses name decoration for C++ functions, you must either use the decorated name as the `entryname` or `internalname`, or define the exported functions by using `extern \"C\"` in the source code."},{"content":"The compiler also decorates C functions that use the <bpt id=\"p1\">[</bpt>__stdcall<ept id=\"p1\">](../../cpp/stdcall.md)</ept> calling convention with an underscore (_) prefix and a suffix composed of the at sign (@) followed by the number of bytes (in decimal) in the argument list.","pos":[1729,1972],"source":" The compiler also decorates C functions that use the [__stdcall](../../cpp/stdcall.md) calling convention with an underscore (_) prefix and a suffix composed of the at sign (@) followed by the number of bytes (in decimal) in the argument list."},{"content":"To find the decorated names produced by the compiler, use the <bpt id=\"p1\">[</bpt>DUMPBIN<ept id=\"p1\">](../../build/reference/dumpbin-reference.md)</ept> tool or the linker <bpt id=\"p2\">[</bpt>/MAP<ept id=\"p2\">](../../build/reference/map-generate-mapfile.md)</ept> option.","pos":[1979,2175],"source":"To find the decorated names produced by the compiler, use the [DUMPBIN](../../build/reference/dumpbin-reference.md) tool or the linker [/MAP](../../build/reference/map-generate-mapfile.md) option."},{"content":"The decorated names are compiler-specific.","pos":[2176,2218]},{"content":"If you export the decorated names in the .DEF file, executables that link to the DLL must also be built by using the same version of the compiler.","pos":[2219,2365]},{"content":"This ensures that the decorated names in the caller match the exported names in the .DEF file.","pos":[2366,2460]},{"content":"You can use @<ph id=\"ph1\">`ordinal`</ph> to specify that a number, and not the function name, will go into the DLL's export table.","pos":[2467,2579],"source":"You can use @`ordinal` to specify that a number, and not the function name, will go into the DLL's export table."},{"content":"Many Windows DLLs export ordinals to support legacy code.","pos":[2580,2637]},{"content":"It was common to use ordinals in 16-bit Windows code, because it can help minimize the size of a DLL.","pos":[2638,2739]},{"content":"We don’t recommend exporting functions by ordinal unless your DLL’s clients need it for legacy support.","pos":[2740,2843]},{"content":"Because the .LIB file will contain the mapping between the ordinal and the function, you can use the function name as you normally would in projects that use the DLL.","pos":[2844,3010]},{"content":"By using the optional <ph id=\"ph1\">`NONAME`</ph> keyword, you can export by ordinal only and reduce the size of the export table in the resulting DLL.","pos":[3017,3149],"source":"By using the optional `NONAME` keyword, you can export by ordinal only and reduce the size of the export table in the resulting DLL."},{"content":"However, if you want to use <bpt id=\"p1\">[</bpt>GetProcAddress<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms683212.aspx)</ept> on the DLL, you must know the ordinal because the name will not be valid.","pos":[3150,3333],"source":" However, if you want to use [GetProcAddress](http://msdn.microsoft.com/library/windows/desktop/ms683212.aspx) on the DLL, you must know the ordinal because the name will not be valid."},{"content":"The optional keyword <ph id=\"ph1\">`PRIVATE`</ph> prevents <ph id=\"ph2\">`entryname`</ph> from being included in the import library generated by LINK.","pos":[3340,3452],"source":"The optional keyword `PRIVATE` prevents `entryname` from being included in the import library generated by LINK."},{"content":"It does not affect the export in the image also generated by LINK.","pos":[3453,3519]},{"content":"The optional keyword <ph id=\"ph1\">`DATA`</ph> specifies that an export is data, not code.","pos":[3526,3597],"source":"The optional keyword `DATA` specifies that an export is data, not code."},{"content":"This example shows how you could export a data variable named <ph id=\"ph1\">`exported_global`</ph>:","pos":[3598,3678],"source":" This example shows how you could export a data variable named `exported_global`:"},{"content":"There are four ways to export a definition, listed in recommended order:","pos":[3736,3808]},{"pos":[3818,3906],"content":"The <bpt id=\"p1\">[</bpt>__declspec(dllexport)<ept id=\"p1\">](../../cpp/dllexport-dllimport.md)</ept> keyword in the source code","source":"The [__declspec(dllexport)](../../cpp/dllexport-dllimport.md) keyword in the source code"},{"pos":[3916,3953],"content":"An <ph id=\"ph1\">`EXPORTS`</ph> statement in a .DEF file","source":"An `EXPORTS` statement in a .DEF file"},{"pos":[3963,4059],"content":"An <bpt id=\"p1\">[</bpt>/EXPORT<ept id=\"p1\">](../../build/reference/export-exports-a-function.md)</ept> specification in a LINK command","source":"An [/EXPORT](../../build/reference/export-exports-a-function.md) specification in a LINK command"},{"pos":[4069,4159],"content":"A <bpt id=\"p1\">[</bpt>comment<ept id=\"p1\">](../../preprocessor/comment-c-cpp.md)</ept> directive in the source code, of the form","source":"A [comment](../../preprocessor/comment-c-cpp.md) directive in the source code, of the form "},{"content":"All four methods can be used in the same program.","pos":[4218,4267]},{"content":"When LINK builds a program that contains exports, it also creates an import library, unless an .EXP file is used in the build.","pos":[4268,4394]},{"content":"Here's an example of an EXPORTS section:","pos":[4401,4441]},{"content":"When you export a variable from a DLL by using a .DEF file, you do not have to specify <ph id=\"ph1\">`__declspec(dllexport)`</ph> on the variable.","pos":[4662,4789],"source":"When you export a variable from a DLL by using a .DEF file, you do not have to specify `__declspec(dllexport)` on the variable."},{"content":"However, in any file that uses the DLL, you must still use <ph id=\"ph1\">`__declspec(dllimport)`</ph> on the declaration of data.","pos":[4790,4900],"source":" However, in any file that uses the DLL, you must still use `__declspec(dllimport)` on the declaration of data."},{"content":"See Also","pos":[4909,4917]},{"content":"Rules for Module-Definition Statements","pos":[4922,4960]}],"content":"---\ntitle: \"EXPORTS | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"EXPORTS\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"EXPORTS .def file statement\"\nms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# EXPORTS\nIntroduces a section of one or more export definitions that specify the exported names or ordinals of functions or data. Each definition must be on a separate line.  \n  \n```  \nEXPORTS  \n   definition  \n```  \n  \n## Remarks  \n The first `definition` can be on the same line as the `EXPORTS` keyword or on a subsequent line. The .DEF file can contain one or more `EXPORTS` statements.  \n  \n The syntax for an export `definition` is:  \n  \n```  \n  \nentryname[=internalname] [@ordinal [NONAME]] [[PRIVATE] | [DATA]]  \n```  \n  \n `entryname` is the function or variable name that you want to export. This is required. If the name that you export differs from the name in the DLL, specify the export's name in the DLL by using `internalname`. For example, if your DLL exports a function `func1` and you want callers to use it as `func2`, you would specify:  \n  \n```  \nEXPORTS  \n   func2=func1  \n```  \n  \n Because the Visual C++ compiler uses name decoration for C++ functions, you must either use the decorated name as the `entryname` or `internalname`, or define the exported functions by using `extern \"C\"` in the source code. The compiler also decorates C functions that use the [__stdcall](../../cpp/stdcall.md) calling convention with an underscore (_) prefix and a suffix composed of the at sign (@) followed by the number of bytes (in decimal) in the argument list.  \n  \n To find the decorated names produced by the compiler, use the [DUMPBIN](../../build/reference/dumpbin-reference.md) tool or the linker [/MAP](../../build/reference/map-generate-mapfile.md) option. The decorated names are compiler-specific. If you export the decorated names in the .DEF file, executables that link to the DLL must also be built by using the same version of the compiler. This ensures that the decorated names in the caller match the exported names in the .DEF file.  \n  \n You can use @`ordinal` to specify that a number, and not the function name, will go into the DLL's export table. Many Windows DLLs export ordinals to support legacy code. It was common to use ordinals in 16-bit Windows code, because it can help minimize the size of a DLL. We don’t recommend exporting functions by ordinal unless your DLL’s clients need it for legacy support. Because the .LIB file will contain the mapping between the ordinal and the function, you can use the function name as you normally would in projects that use the DLL.  \n  \n By using the optional `NONAME` keyword, you can export by ordinal only and reduce the size of the export table in the resulting DLL. However, if you want to use [GetProcAddress](http://msdn.microsoft.com/library/windows/desktop/ms683212.aspx) on the DLL, you must know the ordinal because the name will not be valid.  \n  \n The optional keyword `PRIVATE` prevents `entryname` from being included in the import library generated by LINK. It does not affect the export in the image also generated by LINK.  \n  \n The optional keyword `DATA` specifies that an export is data, not code. This example shows how you could export a data variable named `exported_global`:  \n  \n```  \nEXPORTS  \n   exported_global DATA  \n```  \n  \n There are four ways to export a definition, listed in recommended order:  \n  \n1.  The [__declspec(dllexport)](../../cpp/dllexport-dllimport.md) keyword in the source code  \n  \n2.  An `EXPORTS` statement in a .DEF file  \n  \n3.  An [/EXPORT](../../build/reference/export-exports-a-function.md) specification in a LINK command  \n  \n4.  A [comment](../../preprocessor/comment-c-cpp.md) directive in the source code, of the form `#pragma comment(linker, \"/export:``definition``\")`  \n  \n All four methods can be used in the same program. When LINK builds a program that contains exports, it also creates an import library, unless an .EXP file is used in the build.  \n  \n Here's an example of an EXPORTS section:  \n  \n```  \nEXPORTS  \n   DllCanUnloadNow      @1          PRIVATE  \n   DllWindowName = WindowName       DATA  \n   DllGetClassObject    @4 NONAME   PRIVATE  \n   DllRegisterServer    @7  \n   DllUnregisterServer  \n```  \n  \n When you export a variable from a DLL by using a .DEF file, you do not have to specify `__declspec(dllexport)` on the variable. However, in any file that uses the DLL, you must still use `__declspec(dllimport)` on the declaration of data.  \n  \n## See Also  \n [Rules for Module-Definition Statements](../../build/reference/rules-for-module-definition-statements.md)"}