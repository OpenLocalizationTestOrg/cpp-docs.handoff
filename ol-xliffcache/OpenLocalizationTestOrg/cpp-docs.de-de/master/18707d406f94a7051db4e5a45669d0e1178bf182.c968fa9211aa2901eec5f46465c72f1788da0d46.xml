{"nodes":[{"pos":[12,55],"content":"Thread Local Storage (TLS) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Thread Local Storage (TLS) | Microsoft Docs","pos":[0,43]}]},{"content":"Thread Local Storage (TLS)","pos":[757,783]},{"content":"Thread Local Storage (TLS) is the method by which each thread in a given multithreaded process can allocate locations in which to store thread-specific data.","pos":[784,941]},{"content":"Dynamically bound (run-time) thread-specific data is supported by way of the TLS API (<bpt id=\"p1\">[</bpt>TlsAlloc<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686801)</ept>,  <bpt id=\"p2\">[</bpt>TlsGetValue<ept id=\"p2\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686812)</ept>,  <bpt id=\"p3\">[</bpt>TlsSetValue<ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686818)</ept>, and <bpt id=\"p4\">[</bpt>TlsFree<ept id=\"p4\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686804)</ept>).","pos":[942,1355],"source":" Dynamically bound (run-time) thread-specific data is supported by way of the TLS API ([TlsAlloc](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686801),  [TlsGetValue](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686812),  [TlsSetValue](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686818), and [TlsFree](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686804))."},{"content":"For more information about how thread local storage is implemented on Windows, see <bpt id=\"p1\">[</bpt>Thread Local Storage (Windows)<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686749\\(v=vs.85\\).aspx)</ept>.","pos":[1356,1555],"source":" For more information about how thread local storage is implemented on Windows, see [Thread Local Storage (Windows)](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686749\\(v=vs.85\\).aspx)."},{"content":"Win32 and the Visual C++ compiler now support statically bound (load-time) per-thread data in addition to the existing API implementation.","pos":[1557,1695]},{"pos":[1758,1789],"content":"Compiler Implementation for TLS"},{"content":"<bpt id=\"p1\">**</bpt>C++11:<ept id=\"p1\">**</ept>  The <ph id=\"ph1\">`thread_local`</ph> storage class specifier is the recommended way to specify thread-local storage for objects and class members.","pos":[1793,1933],"source":"**C++11:**  The `thread_local` storage class specifier is the recommended way to specify thread-local storage for objects and class members."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Storage classes (C++)<ept id=\"p1\">](../cpp/storage-classes-cpp.md)</ept>.","pos":[1934,2015],"source":" For more information, see [Storage classes (C++)](../cpp/storage-classes-cpp.md)."},{"content":"Visual C++ also provides a Microsoft-specific attribute,  <bpt id=\"p1\">[</bpt>thread<ept id=\"p1\">](../cpp/thread.md)</ept>, as extended storage class modifier.","pos":[2022,2143],"source":"Visual C++ also provides a Microsoft-specific attribute,  [thread](../cpp/thread.md), as extended storage class modifier."},{"content":"Use the <ph id=\"ph1\">`__declspec`</ph> keyword to declare a <bpt id=\"p1\">**</bpt>thread<ept id=\"p1\">**</ept> variable.","pos":[2144,2206],"source":" Use the `__declspec` keyword to declare a **thread** variable."},{"content":"For example, the following code declares an integer thread local variable and initializes it with a value:","pos":[2207,2313]},{"content":"Rules and limitations","pos":[2375,2396]},{"content":"The following guidelines must be observed when declaring statically bound thread local objects and variables.","pos":[2400,2509]},{"content":"These guidelines apply both to <bpt id=\"p1\">[</bpt>thread<ept id=\"p1\">](../cpp/thread.md)</ept>and for the most part also to <bpt id=\"p2\">[</bpt>thread_local<ept id=\"p2\">](../cpp/storage-classes-cpp.md)</ept>:","pos":[2510,2643],"source":" These guidelines apply both to [thread](../cpp/thread.md)and for the most part also to [thread_local](../cpp/storage-classes-cpp.md):"},{"content":"The <ph id=\"ph1\">`thread`</ph> attribute can be applied only to class and data declarations and definitions.","pos":[2653,2743],"source":"The `thread` attribute can be applied only to class and data declarations and definitions."},{"content":"It cannot be used on function declarations or definitions.","pos":[2744,2802]},{"content":"For example, the following code generates a compiler error:","pos":[2803,2862]},{"content":"The <ph id=\"ph1\">`thread`</ph> modifier might be specified only on data items with <ph id=\"ph2\">`static`</ph> extent.","pos":[2973,3054],"source":"The `thread` modifier might be specified only on data items with `static` extent."},{"content":"This includes global data objects (both <ph id=\"ph1\">`static`</ph> and <ph id=\"ph2\">`extern`</ph>), local static objects, and static data members of C++ classes.","pos":[3055,3180],"source":" This includes global data objects (both `static` and `extern`), local static objects, and static data members of C++ classes."},{"content":"Automatic data objects cannot be declared with the <ph id=\"ph1\">`thread`</ph> attribute.","pos":[3181,3251],"source":" Automatic data objects cannot be declared with the `thread` attribute."},{"content":"The following code generates compiler errors:","pos":[3252,3297]},{"content":"The declarations and the definition of a thread local object must all specify the <ph id=\"ph1\">`thread`</ph> attribute.","pos":[3578,3679],"source":"The declarations and the definition of a thread local object must all specify the `thread` attribute."},{"content":"For example, the following code generates an error:","pos":[3680,3731]},{"content":"The <ph id=\"ph1\">`thread`</ph> attribute cannot be used as a type modifier.","pos":[3962,4019],"source":"The `thread` attribute cannot be used as a type modifier."},{"content":"For example, the following code generates a compiler error:","pos":[4020,4079]},{"pos":[4165,4305],"content":"Because the declaration of C++ objects that use the <ph id=\"ph1\">`thread`</ph> attribute is permitted, the following two examples are semantically equivalent:","source":"Because the declaration of C++ objects that use the `thread` attribute is permitted, the following two examples are semantically equivalent:"},{"content":"The address of a thread local object is not considered constant, and any expression involving such an address is not considered a constant expression.","pos":[4585,4735]},{"content":"In standard C, the effect of this is to forbid the use of the address of a thread local variable as an initializer for an object or pointer.","pos":[4736,4876]},{"content":"For example, the following code is flagged as an error by the C compiler:","pos":[4877,4950]},{"content":"This restriction does not apply in C++.","pos":[5089,5128]},{"content":"Because C++ allows for dynamic initialization of all objects, you can initialize an object by using an expression that uses the address of a thread local variable.","pos":[5129,5292]},{"content":"This is accomplished just like the construction of thread local objects.","pos":[5293,5365]},{"content":"For example, the code shown earlier does not generate an error when it is compiled as a C++ source file.","pos":[5366,5470]},{"content":"Note that the address of a thread local variable is valid only as long as the thread in which the address was taken still exists.","pos":[5471,5600]},{"content":"Standard C allows for the initialization of an object or variable with an expression involving a reference to itself, but only for objects of nonstatic extent.","pos":[5610,5769]},{"content":"Although C++ generally allows for such dynamic initialization of objects with an expression involving a reference to itself, this kind of initialization is not permitted with thread local objects.","pos":[5770,5966]},{"content":"For example:","pos":[5967,5979]},{"pos":[6250,6399],"content":"Note that a <ph id=\"ph1\">`sizeof`</ph> expression that includes the object being initialized does not represent a reference to itself and is enabled in both C and C++.","source":"Note that a `sizeof` expression that includes the object being initialized does not represent a reference to itself and is enabled in both C and C++."},{"content":"C++ does not allow such dynamic initialization of thread data because of possible future enhancements to the thread local storage facility.","pos":[6410,6549]},{"content":"On Windows operating systems before <ph id=\"ph1\">[!INCLUDE[wiprlhext](../c-runtime-library/reference/includes/wiprlhext_md.md)]</ph>, <ph id=\"ph2\">`__declspec`</ph>( thread ) has some limitations.","pos":[6559,6719],"source":"On Windows operating systems before [!INCLUDE[wiprlhext](../c-runtime-library/reference/includes/wiprlhext_md.md)], `__declspec`( thread ) has some limitations."},{"content":"If a DLL declares any data or object as <ph id=\"ph1\">`__declspec`</ph>( thread ), it can cause a protection fault if dynamically loaded.","pos":[6720,6838],"source":" If a DLL declares any data or object as `__declspec`( thread ), it can cause a protection fault if dynamically loaded."},{"content":"After the DLL is loaded with <bpt id=\"p1\">[</bpt>LoadLibrary<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms684175)</ept>, it causes system failure whenever the code references the <ph id=\"ph1\">`__declspec`</ph>( thread ) data.","pos":[6839,7029],"source":" After the DLL is loaded with [LoadLibrary](http://msdn.microsoft.com/library/windows/desktop/ms684175), it causes system failure whenever the code references the `__declspec`( thread ) data."},{"content":"Because the global variable space for a thread is allocated at run time, the size of this space is based on a calculation of the requirements of the application plus the requirements of all the DLLs that are statically linked.","pos":[7030,7256]},{"content":"When you use <ph id=\"ph1\">`LoadLibrary`</ph>, you cannot extend this space to allow for the thread local variables declared with <ph id=\"ph2\">`__declspec`</ph>( thread ).","pos":[7257,7391],"source":" When you use `LoadLibrary`, you cannot extend this space to allow for the thread local variables declared with `__declspec`( thread )."},{"content":"Use the TLS APIs, such as <bpt id=\"p1\">[</bpt>TlsAlloc<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686801)</ept>, in your DLL to allocate TLS if the DLL might be loaded with <ph id=\"ph1\">`LoadLibrary`</ph>.","pos":[7392,7564],"source":" Use the TLS APIs, such as [TlsAlloc](http://msdn.microsoft.com/library/windows/desktop/ms686801), in your DLL to allocate TLS if the DLL might be loaded with `LoadLibrary`."},{"content":"See Also","pos":[7573,7581]},{"content":"Multithreading with C and Win32","pos":[7586,7617]}],"content":"---\ntitle: \"Thread Local Storage (TLS) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"multithreading [C++], Thread Local Storage\"\n  - \"TLS [C++]\"\n  - \"threading [C++], Thread Local Storage\"\n  - \"storing thread-specific data\"\n  - \"thread attribute\"\n  - \"Thread Local Storage [C++]\"\nms.assetid: 80801907-d792-45ca-b776-df0cf2e9f197\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Thread Local Storage (TLS)\nThread Local Storage (TLS) is the method by which each thread in a given multithreaded process can allocate locations in which to store thread-specific data. Dynamically bound (run-time) thread-specific data is supported by way of the TLS API ([TlsAlloc](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686801),  [TlsGetValue](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686812),  [TlsSetValue](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686818), and [TlsFree](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686804)). For more information about how thread local storage is implemented on Windows, see [Thread Local Storage (Windows)](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686749\\(v=vs.85\\).aspx).  Win32 and the Visual C++ compiler now support statically bound (load-time) per-thread data in addition to the existing API implementation.  \n  \n##  <a name=\"_core_compiler_implementation_for_tls\"></a> Compiler Implementation for TLS  \n **C++11:**  The `thread_local` storage class specifier is the recommended way to specify thread-local storage for objects and class members. For more information, see [Storage classes (C++)](../cpp/storage-classes-cpp.md).  \n  \n Visual C++ also provides a Microsoft-specific attribute,  [thread](../cpp/thread.md), as extended storage class modifier. Use the `__declspec` keyword to declare a **thread** variable. For example, the following code declares an integer thread local variable and initializes it with a value:  \n  \n```  \n__declspec( thread ) int tls_i = 1;  \n```  \n  \n## Rules and limitations  \n The following guidelines must be observed when declaring statically bound thread local objects and variables. These guidelines apply both to [thread](../cpp/thread.md)and for the most part also to [thread_local](../cpp/storage-classes-cpp.md):  \n  \n-   The `thread` attribute can be applied only to class and data declarations and definitions. It cannot be used on function declarations or definitions. For example, the following code generates a compiler error:  \n  \n    ```  \n  \n    __declspec( thread )void func();     // This will generate an error.  \n    ```  \n  \n-   The `thread` modifier might be specified only on data items with `static` extent. This includes global data objects (both `static` and `extern`), local static objects, and static data members of C++ classes. Automatic data objects cannot be declared with the `thread` attribute. The following code generates compiler errors:  \n  \n    ```  \n  \n    void func1()  \n    {  \n        __declspec( thread )int tls_i;            // This will generate an error.  \n    }  \n  \n    int func2(__declspec( thread )int tls_i )    // This will generate an error.  \n    {  \n        return tls_i;  \n    }  \n    ```  \n  \n-   The declarations and the definition of a thread local object must all specify the `thread` attribute. For example, the following code generates an error:  \n  \n    ```  \n    #define Thread  __declspec( thread )  \n    extern int tls_i;        // This will generate an error, since the  \n    int __declspec( thread )tls_i;        // declaration and definition differ.  \n    ```  \n  \n-   The `thread` attribute cannot be used as a type modifier. For example, the following code generates a compiler error:  \n  \n    ```  \n    char __declspec( thread ) *ch;        // Error  \n    ```  \n  \n-   Because the declaration of C++ objects that use the `thread` attribute is permitted, the following two examples are semantically equivalent:  \n  \n    ```  \n  \n    __declspec( thread ) class B  \n    {  \n    // Code  \n    } BObject;  // OK--BObject is declared thread local.  \n  \n    class B  \n    {  \n    // Code  \n    };  \n    __declspec( thread ) B BObject;  // OK--BObject is declared thread local.  \n    ```  \n  \n-   The address of a thread local object is not considered constant, and any expression involving such an address is not considered a constant expression. In standard C, the effect of this is to forbid the use of the address of a thread local variable as an initializer for an object or pointer. For example, the following code is flagged as an error by the C compiler:  \n  \n    ```  \n  \n    __declspec( thread )int tls_i;  \n    int *p = &tls_i;       //This will generate an error in C.  \n    ```  \n  \n     This restriction does not apply in C++. Because C++ allows for dynamic initialization of all objects, you can initialize an object by using an expression that uses the address of a thread local variable. This is accomplished just like the construction of thread local objects. For example, the code shown earlier does not generate an error when it is compiled as a C++ source file. Note that the address of a thread local variable is valid only as long as the thread in which the address was taken still exists.  \n  \n-   Standard C allows for the initialization of an object or variable with an expression involving a reference to itself, but only for objects of nonstatic extent. Although C++ generally allows for such dynamic initialization of objects with an expression involving a reference to itself, this kind of initialization is not permitted with thread local objects. For example:  \n  \n    ```  \n    __declspec( thread )int tls_i = tls_i;                // Error in C and C++   \n    int j = j;                               // OK in C++, error in C  \n    __declspec( thread )int tls_i = sizeof( tls_i )       // Legal in C and C++  \n    ```  \n  \n     Note that a `sizeof` expression that includes the object being initialized does not represent a reference to itself and is enabled in both C and C++.  \n  \n     C++ does not allow such dynamic initialization of thread data because of possible future enhancements to the thread local storage facility.  \n  \n-   On Windows operating systems before [!INCLUDE[wiprlhext](../c-runtime-library/reference/includes/wiprlhext_md.md)], `__declspec`( thread ) has some limitations. If a DLL declares any data or object as `__declspec`( thread ), it can cause a protection fault if dynamically loaded. After the DLL is loaded with [LoadLibrary](http://msdn.microsoft.com/library/windows/desktop/ms684175), it causes system failure whenever the code references the `__declspec`( thread ) data. Because the global variable space for a thread is allocated at run time, the size of this space is based on a calculation of the requirements of the application plus the requirements of all the DLLs that are statically linked. When you use `LoadLibrary`, you cannot extend this space to allow for the thread local variables declared with `__declspec`( thread ). Use the TLS APIs, such as [TlsAlloc](http://msdn.microsoft.com/library/windows/desktop/ms686801), in your DLL to allocate TLS if the DLL might be loaded with `LoadLibrary`.  \n  \n## See Also  \n [Multithreading with C and Win32](../parallel/multithreading-with-c-and-win32.md)   \n"}