{"nodes":[{"pos":[12,82],"content":"Copy Constructors and Copy Assignment Operators (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Copy Constructors and Copy Assignment Operators (C++) | Microsoft Docs","pos":[0,70]}]},{"content":"Copy Constructors and Copy Assignment Operators (C++)","pos":[860,913]},{"pos":[916,1298],"content":"[!NOTE]\n Starting in C++11, two kinds of assignment are supported in the language: *copy assignment* and *move assignment*. In this article \"assignment\" means copy assignment unless explicitly stated otherwise. For information about move assignment, see [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db).","leadings":["","> "],"nodes":[{"content":" Starting in C++11, two kinds of assignment are supported in the language: *copy assignment* and *move assignment*. In this article \"assignment\" means copy assignment unless explicitly stated otherwise. For information about move assignment, see [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db).","pos":[8,380],"nodes":[{"content":"Starting in C++11, two kinds of assignment are supported in the language: <bpt id=\"p1\">*</bpt>copy assignment<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>move assignment<ept id=\"p2\">*</ept>.","pos":[1,115],"source":" Starting in C++11, two kinds of assignment are supported in the language: *copy assignment* and *move assignment*."},{"content":"In this article \"assignment\" means copy assignment unless explicitly stated otherwise.","pos":[116,202]},{"content":"For information about move assignment, see <bpt id=\"p1\">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id=\"p1\">](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db)</ept>.","pos":[203,372],"source":" For information about move assignment, see [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db)."}]}]},{"content":"Both the assignment operation and the initialization operation cause objects to be copied.","pos":[1309,1399]},{"content":"<bpt id=\"p1\">**</bpt>Assignment<ept id=\"p1\">**</ept>: When one object's value is assigned to another object, the first object is copied to the second object.","pos":[1409,1528],"source":"**Assignment**: When one object's value is assigned to another object, the first object is copied to the second object."},{"content":"Therefore,","pos":[1529,1539]},{"pos":[1617,1661],"content":"causes the value of <ph id=\"ph1\">`b`</ph> to be copied to <ph id=\"ph2\">`a`</ph>.","source":"causes the value of `b` to be copied to `a`."},{"pos":[1671,1845],"content":"<bpt id=\"p1\">**</bpt>Initialization<ept id=\"p1\">**</ept>: Initialization occurs when a new object is declared, when arguments are passed to functions by value, or when values are returned from functions by value.","source":"**Initialization**: Initialization occurs when a new object is declared, when arguments are passed to functions by value, or when values are returned from functions by value."},{"content":"You can define the semantics of \"copy\" for objects of class type.","pos":[1852,1917]},{"content":"For example, consider this code:","pos":[1918,1950]},{"content":"The preceding code could mean \"copy the contents of FILE1.DAT to FILE2.DAT\" or it could mean \"ignore FILE2.DAT and make <ph id=\"ph1\">`b`</ph> a second handle to FILE1.DAT.\"","pos":[2051,2205],"source":"The preceding code could mean \"copy the contents of FILE1.DAT to FILE2.DAT\" or it could mean \"ignore FILE2.DAT and make `b` a second handle to FILE1.DAT.\""},{"content":"You must attach appropriate copying semantics to each class, as follows.","pos":[2206,2278]},{"pos":[2288,2506],"content":"By using the assignment operator <ph id=\"ph1\">`operator=`</ph> together with a reference to the class type as the return type and the parameter that is passed by <ph id=\"ph2\">`const`</ph> reference—for example <ph id=\"ph3\">`ClassName&amp; operator=(const ClassName&amp; x);`</ph>.","source":"By using the assignment operator `operator=` together with a reference to the class type as the return type and the parameter that is passed by `const` reference—for example `ClassName& operator=(const ClassName& x);`."},{"content":"By using the copy constructor.","pos":[2516,2546]},{"content":"If you do not declare a copy constructor, the compiler generates a member-wise copy constructor for you.","pos":[2554,2658]},{"content":"If you do not declare a copy assignment operator, the compiler generates a member-wise copy assignment operator for you.","pos":[2660,2780]},{"content":"Declaring a copy constructor does not suppress the compiler-generated copy assignment operator, nor vice versa.","pos":[2781,2892]},{"content":"If you implement either one, we recommend that you also implement the other one so that the meaning of the code is clear.","pos":[2893,3014]},{"content":"The copy constructor takes an argument of type <bpt id=\"p1\">*</bpt>class-name<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p2\">**</ept>, where <bpt id=\"p3\">*</bpt>class-name<ept id=\"p3\">*</ept> is the name of the class for which the constructor is defined.","pos":[3022,3169],"source":"The copy constructor takes an argument of type *class-name***&**, where *class-name* is the name of the class for which the constructor is defined."},{"content":"For example:","pos":[3170,3182]},{"pos":[3376,3625],"content":"[!NOTE]\n Make the type of the copy constructor's argument *const class-name***&** whenever possible. This prevents the copy constructor from accidentally changing the object from which it is copying. It also enables copying from **const** objects.","leadings":["","> "],"nodes":[{"content":" Make the type of the copy constructor's argument *const class-name***&** whenever possible. This prevents the copy constructor from accidentally changing the object from which it is copying. It also enables copying from **const** objects.","pos":[8,247],"nodes":[{"content":"Make the type of the copy constructor's argument <bpt id=\"p1\">*</bpt>const class-name<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p2\">**</ept> whenever possible.","pos":[1,92],"source":" Make the type of the copy constructor's argument *const class-name***&** whenever possible."},{"content":"This prevents the copy constructor from accidentally changing the object from which it is copying.","pos":[93,191]},{"content":"It also enables copying from <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> objects.","pos":[192,239],"source":" It also enables copying from **const** objects."}]}]},{"content":"Compiler generated copy constructors","pos":[3634,3670]},{"content":"Compiler-generated copy constructors, like user-defined copy constructors, have a single argument of type \"reference to <bpt id=\"p1\">*</bpt>class-name<ept id=\"p1\">*</ept>.\"","pos":[3674,3808],"source":"Compiler-generated copy constructors, like user-defined copy constructors, have a single argument of type \"reference to *class-name*.\""},{"content":"An exception is when all base classes and member classes have copy constructors declared as taking a single argument of type <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>class-name<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p3\">**</ept>.","pos":[3809,3962],"source":" An exception is when all base classes and member classes have copy constructors declared as taking a single argument of type **const** *class-name***&**."},{"content":"In such a case, the compiler-generated copy constructor's argument is also <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[3963,4048],"source":" In such a case, the compiler-generated copy constructor's argument is also **const**."},{"content":"When the argument type to the copy constructor is not <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, initialization by copying a <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> object generates an error.","pos":[4055,4184],"source":"When the argument type to the copy constructor is not **const**, initialization by copying a **const** object generates an error."},{"content":"The reverse is not true: If the argument is <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, you can initialize by copying an object that is not <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept>.","pos":[4185,4302],"source":" The reverse is not true: If the argument is **const**, you can initialize by copying an object that is not **const**."},{"content":"Compiler-generated assignment operators follow the same pattern with regard to <bpt id=\"p1\">**</bpt>const.<ept id=\"p1\">**</ept>","pos":[4309,4398],"source":"Compiler-generated assignment operators follow the same pattern with regard to **const.**"},{"content":"They take a single argument of type <bpt id=\"p1\">*</bpt>class-name<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p2\">**</ept> unless the assignment operators in all base and member classes take arguments of type <bpt id=\"p3\">**</bpt>const<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>class-name&amp;.<ept id=\"p4\">*</ept>","pos":[4399,4563],"source":" They take a single argument of type *class-name***&** unless the assignment operators in all base and member classes take arguments of type **const** *class-name&.*"},{"content":"In this case, the class's generated assignment operator takes a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> argument.","pos":[4564,4647],"source":" In this case, the class's generated assignment operator takes a **const** argument."},{"pos":[4655,4837],"content":"[!NOTE]\n When virtual base classes are initialized by copy constructors, compiler-generated or user-defined, they are initialized only once: at the point when they are constructed.","leadings":["","> "],"nodes":[{"content":"When virtual base classes are initialized by copy constructors, compiler-generated or user-defined, they are initialized only once: at the point when they are constructed.","pos":[9,180]}]},{"content":"The implications are similar to those of the copy constructor.","pos":[4844,4906]},{"content":"When the argument type is not <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, assignment from a <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> object generates an error.","pos":[4907,5002],"source":" When the argument type is not **const**, assignment from a **const** object generates an error."},{"content":"The reverse is not true: If a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> value is assigned to a value that is not <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept>, the assignment succeeds.","pos":[5003,5119],"source":" The reverse is not true: If a **const** value is assigned to a value that is not **const**, the assignment succeeds."},{"pos":[5126,5225],"content":"For more information about overloaded assignment operators, see <bpt id=\"p1\">[</bpt>Assignment<ept id=\"p1\">](../cpp/assignment.md)</ept>.","source":"For more information about overloaded assignment operators, see [Assignment](../cpp/assignment.md)."}],"content":"---\ntitle: \"Copy Constructors and Copy Assignment Operators (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"= operator, copying objects\"\n  - \"assignment statements, copying objects\"\n  - \"assignment operators, for copying objects\"\n  - \"objects [C++], copying\"\n  - \"initializing objects, by copying objects\"\n  - \"copying objects\"\n  - \"assigning values to copy objects\"\nms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Copy Constructors and Copy Assignment Operators (C++)\n> [!NOTE]\n>  Starting in C++11, two kinds of assignment are supported in the language: *copy assignment* and *move assignment*. In this article \"assignment\" means copy assignment unless explicitly stated otherwise. For information about move assignment, see [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db).  \n>   \n>  Both the assignment operation and the initialization operation cause objects to be copied.  \n  \n-   **Assignment**: When one object's value is assigned to another object, the first object is copied to the second object. Therefore,  \n  \n    ```cpp  \n    Point a, b;  \n    ...  \n    a = b;  \n    ```  \n  \n     causes the value of `b` to be copied to `a`.  \n  \n-   **Initialization**: Initialization occurs when a new object is declared, when arguments are passed to functions by value, or when values are returned from functions by value.  \n  \n You can define the semantics of \"copy\" for objects of class type. For example, consider this code:  \n  \n```cpp  \nTextFile a, b;  \na.Open( \"FILE1.DAT\" );  \nb.Open( \"FILE2.DAT\" );  \nb = a;  \n```  \n  \n The preceding code could mean \"copy the contents of FILE1.DAT to FILE2.DAT\" or it could mean \"ignore FILE2.DAT and make `b` a second handle to FILE1.DAT.\" You must attach appropriate copying semantics to each class, as follows.  \n  \n-   By using the assignment operator `operator=` together with a reference to the class type as the return type and the parameter that is passed by `const` reference—for example `ClassName& operator=(const ClassName& x);`.  \n  \n-   By using the copy constructor.   \n  \n If you do not declare a copy constructor, the compiler generates a member-wise copy constructor for you.  If you do not declare a copy assignment operator, the compiler generates a member-wise copy assignment operator for you. Declaring a copy constructor does not suppress the compiler-generated copy assignment operator, nor vice versa. If you implement either one, we recommend that you also implement the other one so that the meaning of the code is clear.  \n   \n The copy constructor takes an argument of type *class-name***&**, where *class-name* is the name of the class for which the constructor is defined. For example:  \n  \n```cpp  \n// spec1_copying_class_objects.cpp  \nclass Window  \n{  \npublic:  \n    Window( const Window& ); // Declare copy constructor.  \n    // ...  \n};  \n  \nint main()  \n{  \n}  \n```  \n  \n> [!NOTE]\n>  Make the type of the copy constructor's argument *const class-name***&** whenever possible. This prevents the copy constructor from accidentally changing the object from which it is copying. It also enables copying from **const** objects.  \n  \n## Compiler generated copy constructors  \n Compiler-generated copy constructors, like user-defined copy constructors, have a single argument of type \"reference to *class-name*.\" An exception is when all base classes and member classes have copy constructors declared as taking a single argument of type **const** *class-name***&**. In such a case, the compiler-generated copy constructor's argument is also **const**.  \n  \n When the argument type to the copy constructor is not **const**, initialization by copying a **const** object generates an error. The reverse is not true: If the argument is **const**, you can initialize by copying an object that is not **const**.  \n  \n Compiler-generated assignment operators follow the same pattern with regard to **const.** They take a single argument of type *class-name***&** unless the assignment operators in all base and member classes take arguments of type **const** *class-name&.* In this case, the class's generated assignment operator takes a **const** argument.  \n  \n> [!NOTE]\n>  When virtual base classes are initialized by copy constructors, compiler-generated or user-defined, they are initialized only once: at the point when they are constructed.  \n  \n The implications are similar to those of the copy constructor. When the argument type is not **const**, assignment from a **const** object generates an error. The reverse is not true: If a **const** value is assigned to a value that is not **const**, the assignment succeeds.  \n  \n For more information about overloaded assignment operators, see [Assignment](../cpp/assignment.md).  \n  \n"}