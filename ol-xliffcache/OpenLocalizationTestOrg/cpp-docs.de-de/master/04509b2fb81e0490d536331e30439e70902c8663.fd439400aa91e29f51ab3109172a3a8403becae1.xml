{"nodes":[{"pos":[12,47],"content":"char_traits Struct | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"char_traits Struct | Microsoft Docs","pos":[0,35]}]},{"pos":[706,724],"content":"char_traits Struct","linkify":"char_traits Struct","nodes":[{"content":"char_traits Struct","pos":[0,18]}]},{"content":"The char_traits struct describes attributes associated with a character.","pos":[725,797]},{"pos":[806,812],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[888,898],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element data type.","pos":[916,938]},{"pos":[947,954],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template struct describes various character traits for type <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>.","pos":[958,1035],"source":"The template struct describes various character traits for type **CharType**."},{"content":"The template class <bpt id=\"p1\">[</bpt>basic_string<ept id=\"p1\">](../standard-library/basic-string-class.md)</ept> as well as several iostream template classes, including <bpt id=\"p2\">[</bpt>basic_ios<ept id=\"p2\">](../standard-library/basic-ios-class.md)</ept>, use this information to manipulate elements of type <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>.","pos":[1036,1287],"source":" The template class [basic_string](../standard-library/basic-string-class.md) as well as several iostream template classes, including [basic_ios](../standard-library/basic-ios-class.md), use this information to manipulate elements of type **CharType**."},{"content":"Such an element type must not require explicit construction or destruction.","pos":[1288,1363]},{"content":"It must supply a default constructor, a copy constructor, and an assignment operator, with the expected semantics.","pos":[1364,1478]},{"content":"A bitwise copy must have the same effect as an assignment.","pos":[1479,1537]},{"content":"None of the member functions of struct char_traits can throw exceptions.","pos":[1538,1610]},{"pos":[1620,1628],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[1649,1685],"content":"<bpt id=\"p1\">[</bpt>char_type<ept id=\"p1\">](#char_traits__char_type)</ept>","source":"[char_type](#char_traits__char_type)"},{"content":"A type of character.","pos":[1686,1706]},{"pos":[1711,1745],"content":"<bpt id=\"p1\">[</bpt>int_type<ept id=\"p1\">](#char_traits__int_type)</ept>","source":"[int_type](#char_traits__int_type)"},{"pos":[1746,1847],"content":"An integer type that can represent a character of type <ph id=\"ph1\">`char_type`</ph> or an end-of-file (EOF) character.","source":"An integer type that can represent a character of type `char_type` or an end-of-file (EOF) character."},{"pos":[1852,1886],"content":"<bpt id=\"p1\">[</bpt>off_type<ept id=\"p1\">](#char_traits__off_type)</ept>","source":"[off_type](#char_traits__off_type)"},{"content":"An integer type that can represent offsets between positions in a stream.","pos":[1887,1960]},{"pos":[1965,1999],"content":"<bpt id=\"p1\">[</bpt>pos_type<ept id=\"p1\">](#char_traits__pos_type)</ept>","source":"[pos_type](#char_traits__pos_type)"},{"content":"An integer type that can represent positions in a stream.","pos":[2000,2057]},{"pos":[2062,2100],"content":"<bpt id=\"p1\">[</bpt>state_type<ept id=\"p1\">](#char_traits__state_type)</ept>","source":"[state_type](#char_traits__state_type)"},{"content":"A type that represents the conversion state in for multibyte characters in a stream.","pos":[2101,2185]},{"pos":[2196,2212],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[2233,2263],"content":"<bpt id=\"p1\">[</bpt>assign<ept id=\"p1\">](#char_traits__assign)</ept>","source":"[assign](#char_traits__assign)"},{"content":"Assigns one character value to another.","pos":[2264,2303]},{"pos":[2308,2340],"content":"<bpt id=\"p1\">[</bpt>compare<ept id=\"p1\">](#char_traits__compare)</ept>","source":"[compare](#char_traits__compare)"},{"content":"Compares up to a specified number of characters in two strings.","pos":[2341,2404]},{"pos":[2409,2435],"content":"<bpt id=\"p1\">[</bpt>copy<ept id=\"p1\">](#char_traits__copy)</ept>","source":"[copy](#char_traits__copy)"},{"content":"Copies a specified number of characters from one string to another.","pos":[2436,2503]},{"content":"Deprecated.","pos":[2504,2515]},{"content":"Use <bpt id=\"p1\">[</bpt>char_traits::_Copy_s<ept id=\"p1\">](#char_traits___copy_s)</ept> instead.","pos":[2516,2574],"source":" Use [char_traits::_Copy_s](#char_traits___copy_s) instead."},{"pos":[2579,2611],"content":"<bpt id=\"p1\">[</bpt>_Copy_s<ept id=\"p1\">](#char_traits___copy_s)</ept>","source":"[_Copy_s](#char_traits___copy_s)"},{"content":"Copies a specified number of characters from one string to another.","pos":[2612,2679]},{"pos":[2684,2708],"content":"<bpt id=\"p1\">[</bpt>eof<ept id=\"p1\">](#char_traits__eof)</ept>","source":"[eof](#char_traits__eof)"},{"content":"Returns the end-of-file (EOF) character.","pos":[2709,2749]},{"pos":[2754,2776],"content":"<bpt id=\"p1\">[</bpt>eq<ept id=\"p1\">](#char_traits__eq)</ept>","source":"[eq](#char_traits__eq)"},{"pos":[2777,2828],"content":"Tests whether two <ph id=\"ph1\">`char_type`</ph> characters are equal.","source":"Tests whether two `char_type` characters are equal."},{"pos":[2833,2873],"content":"<bpt id=\"p1\">[</bpt>eq_int_type<ept id=\"p1\">](#char_traits__eq_int_type)</ept>","source":"[eq_int_type](#char_traits__eq_int_type)"},{"pos":[2874,2940],"content":"Tests whether two characters represented as <ph id=\"ph1\">`int_type`</ph>s are equal.","source":"Tests whether two characters represented as `int_type`s are equal."},{"pos":[2945,2971],"content":"<bpt id=\"p1\">[</bpt>find<ept id=\"p1\">](#char_traits__find)</ept>","source":"[find](#char_traits__find)"},{"content":"Searches for the first occurrence of a specified character in a range of characters.","pos":[2972,3056]},{"pos":[3061,3091],"content":"<bpt id=\"p1\">[</bpt>length<ept id=\"p1\">](#char_traits__length)</ept>","source":"[length](#char_traits__length)"},{"content":"Returns the length of a string.","pos":[3092,3123]},{"pos":[3128,3150],"content":"<bpt id=\"p1\">[</bpt>lt<ept id=\"p1\">](#char_traits__lt)</ept>","source":"[lt](#char_traits__lt)"},{"content":"Tests whether one character is less than another.","pos":[3151,3200]},{"pos":[3205,3231],"content":"<bpt id=\"p1\">[</bpt>move<ept id=\"p1\">](#char_traits__move)</ept>","source":"[move](#char_traits__move)"},{"content":"Copies a specified number of characters in a sequence to another, possible overlapping, sequence.","pos":[3232,3329]},{"content":"Deprecated.","pos":[3330,3341]},{"content":"Use <bpt id=\"p1\">[</bpt>char_traits::_Move_s<ept id=\"p1\">](#char_traits___move_s)</ept> instead.","pos":[3342,3400],"source":" Use [char_traits::_Move_s](#char_traits___move_s) instead."},{"pos":[3405,3437],"content":"<bpt id=\"p1\">[</bpt>_Move_s<ept id=\"p1\">](#char_traits___move_s)</ept>","source":"[_Move_s](#char_traits___move_s)"},{"content":"Copies a specified number of characters in a sequence to another, possible overlapping, sequence.","pos":[3438,3535]},{"pos":[3540,3572],"content":"<bpt id=\"p1\">[</bpt>not_eof<ept id=\"p1\">](#char_traits__not_eof)</ept>","source":"[not_eof](#char_traits__not_eof)"},{"content":"Tests whether a character is the end-of-file (EOF) character.","pos":[3573,3634]},{"pos":[3639,3681],"content":"<bpt id=\"p1\">[</bpt>to_char_type<ept id=\"p1\">](#char_traits__to_char_type)</ept>","source":"[to_char_type](#char_traits__to_char_type)"},{"pos":[3682,3781],"content":"Converts an <ph id=\"ph1\">`int_type`</ph> character to the corresponding <ph id=\"ph2\">`char_type`</ph> character and returns the result.","source":"Converts an `int_type` character to the corresponding `char_type` character and returns the result."},{"pos":[3786,3826],"content":"<bpt id=\"p1\">[</bpt>to_int_type<ept id=\"p1\">](#char_traits__to_int_type)</ept>","source":"[to_int_type](#char_traits__to_int_type)"},{"pos":[3827,3925],"content":"Converts a <ph id=\"ph1\">`char_type`</ph> character to the corresponding <ph id=\"ph2\">`int_type`</ph> character and returns the result.","source":"Converts a `char_type` character to the corresponding `int_type` character and returns the result."},{"pos":[3935,3947],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[3951,3972],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>string&gt;","source":"**Header:** \\<string>"},{"pos":[3979,3997],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[4007,4062],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__assign\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::assign","linkify":"<a name=\"char_traits__assign\"></a>  char_traits::assign","source":"<a name=\"char_traits__assign\"></a>  char_traits::assign"},{"content":"Assigns one character value to another or to a range of elements in a string.","pos":[4066,4143]},{"pos":[4327,4337],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>CharFrom<ept id=\"p2\">*</ept>","pos":[4341,4357],"source":"**_** *CharFrom*"},{"content":"The character whose value is to be assigned.","pos":[4361,4405]},{"content":"<bpt id=\"p1\">*</bpt>_CharTo<ept id=\"p1\">*</ept>","pos":[4412,4421],"source":"*_CharTo*"},{"content":"The element that is to be assigned the character value.","pos":[4425,4480]},{"pos":[4489,4588],"content":"strTo*  \nThe string or character array whose initial elements are to be assigned character values.","leadings":[""," "],"nodes":[{"content":"strTo*","pos":[0,6]},{"content":"The string or character array whose initial elements are to be assigned character values.","pos":[9,98]}]},{"pos":[4595,4665],"content":"`_Num`  \nThe number of elements that are going to be assigned values.","leadings":[""," "],"nodes":[{"content":"The number of elements that are going to be assigned values.","pos":[9,69]}]},{"pos":[4675,4687],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[4691,4819],"content":"The second member function returns a pointer to the string whose first <ph id=\"ph1\">`_Num`</ph> elements have been assigned values of <bpt id=\"p1\">*</bpt>_CharFrom<ept id=\"p1\">*</ept>.","source":"The second member function returns a pointer to the string whose first `_Num` elements have been assigned values of *_CharFrom*."},{"pos":[4829,4836],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6125,6186],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::char_type","linkify":"<a name=\"char_traits__char_type\"></a>  char_traits::char_type","source":"<a name=\"char_traits__char_type\"></a>  char_traits::char_type"},{"content":"A type of character.","pos":[6190,6210]},{"pos":[6265,6272],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6276,6338],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **CharType**."},{"pos":[6348,6355],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6360,6460],"content":"See the example for <bpt id=\"p1\">[</bpt>copy<ept id=\"p1\">](#char_traits__copy)</ept> for an example of how to declare and use <ph id=\"ph1\">`char_type`</ph>.","source":"See the example for [copy](#char_traits__copy) for an example of how to declare and use `char_type`."},{"pos":[6470,6527],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__compare\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::compare","linkify":"<a name=\"char_traits__compare\"></a>  char_traits::compare","source":"<a name=\"char_traits__compare\"></a>  char_traits::compare"},{"content":"Compares up to a specified number of characters in two strings.","pos":[6531,6594]},{"pos":[6706,6716],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"pos":[6722,6785],"content":"str1*  \nThe first of two strings to be compared to each other.","leadings":[""," "],"nodes":[{"content":"str1*","pos":[0,5]},{"content":"The first of two strings to be compared to each other.","pos":[8,62]}]},{"pos":[6794,6858],"content":"str2*  \nThe second of two strings to be compared to each other.","leadings":[""," "],"nodes":[{"content":"str2*","pos":[0,5]},{"content":"The second of two strings to be compared to each other.","pos":[8,63]}]},{"pos":[6865,6928],"content":"`_Num`  \nThe number of elements in the strings to be compared.","leadings":[""," "],"nodes":[{"content":"The number of elements in the strings to be compared.","pos":[9,62]}]},{"pos":[6938,6950],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A negative value if the first string is less than the second string, 0 if the two strings are equal, or a positive value if the first string is greater than the second string.","pos":[6954,7129]},{"pos":[7139,7146],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison between the strings is made element by element, first testing for equality and then, if a pair of elements in the sequence tests not equal, they are tested for less than.","pos":[7150,7335]},{"content":"If two strings compare equal over a range but one is longer than the other, then the shorter of the two is less than the longer one.","pos":[7342,7474]},{"pos":[7484,7491],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8562,8613],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__copy\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::copy","linkify":"<a name=\"char_traits__copy\"></a>  char_traits::copy","source":"<a name=\"char_traits__copy\"></a>  char_traits::copy"},{"content":"Copies a specified number of characters from one string to another.","pos":[8617,8684]},{"content":"This method is potentially unsafe, as it relies on the caller to check that the passed values are correct.","pos":[8691,8797]},{"content":"Consider using <bpt id=\"p1\">[</bpt>char_traits::_Copy_s<ept id=\"p1\">](#char_traits___copy_s)</ept> instead.","pos":[8798,8867],"source":" Consider using [char_traits::_Copy_s](#char_traits___copy_s) instead."},{"pos":[8977,8987],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element at the beginning of the string or character array targeted to receive the copied sequence of characters.","pos":[9000,9116]},{"content":"The element at the beginning of the source string or character array to be copied.","pos":[9134,9216]},{"content":"The number of elements to be copied.","pos":[9233,9269]},{"pos":[9279,9291],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The first element copied into the string or character array targeted to receive the copied sequence of characters.","pos":[9295,9409]},{"pos":[9419,9426],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The source and destination character sequences must not overlap.","pos":[9430,9494]},{"pos":[9504,9511],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10372,10429],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits___copy_s\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::_Copy_s","linkify":"<a name=\"char_traits___copy_s\"></a>  char_traits::_Copy_s","source":"<a name=\"char_traits___copy_s\"></a>  char_traits::_Copy_s"},{"content":"Copies a specified number of characters from one string to another.","pos":[10433,10500]},{"pos":[10648,10658],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The string or character array targeted to receive the copied sequence of characters.","pos":[10673,10757]},{"content":"The size of <ph id=\"ph1\">` dest`</ph>.","pos":[10780,10800],"source":" The size of ` dest`."},{"content":"If <ph id=\"ph1\">`char_type`</ph> is <ph id=\"ph2\">`char`</ph>, then this size is in bytes.","pos":[10801,10854],"source":" If `char_type` is `char`, then this size is in bytes."},{"content":"If <ph id=\"ph1\">`char_type`</ph> is <ph id=\"ph2\">`wchar_t`</ph>, then this size is in words.","pos":[10855,10911],"source":" If `char_type` is `wchar_t`, then this size is in words."},{"content":"The source string or character array to be copied.","pos":[10929,10979]},{"content":"The number of elements to be copied.","pos":[10998,11034]},{"pos":[11044,11056],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The string or character array targeted to receive the copied sequence of characters.","pos":[11060,11144]},{"pos":[11154,11161],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The source and destination character sequences must not overlap.","pos":[11165,11229]},{"pos":[11239,11246],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12111,12160],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__eof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::eof","linkify":"<a name=\"char_traits__eof\"></a>  char_traits::eof","source":"<a name=\"char_traits__eof\"></a>  char_traits::eof"},{"content":"Returns the end-of-file (EOF) character.","pos":[12164,12204]},{"pos":[12252,12264],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The EOF character.","pos":[12268,12286]},{"pos":[12296,12303],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12307,12369],"content":"A value that represents end of file (such as <ph id=\"ph1\">`EOF`</ph> or <ph id=\"ph2\">`WEOF`</ph>).","source":"A value that represents end of file (such as `EOF` or `WEOF`)."},{"content":"The C++ standard states that this value must not correspond to a valid <ph id=\"ph1\">`char_type`</ph> value.","pos":[12376,12465],"source":"The C++ standard states that this value must not correspond to a valid `char_type` value."},{"content":"The Visual C++ compiler enforces this constraint for type <ph id=\"ph1\">`char`</ph>, but not for type <ph id=\"ph2\">`wchar_t`</ph>.","pos":[12466,12559],"source":" The Visual C++ compiler enforces this constraint for type `char`, but not for type `wchar_t`."},{"content":"The example below demonstrates this.","pos":[12560,12596]},{"pos":[12606,12613],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13521,13568],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::eq","linkify":"<a name=\"char_traits__eq\"></a>  char_traits::eq","source":"<a name=\"char_traits__eq\"></a>  char_traits::eq"},{"pos":[13572,13623],"content":"Tests whether two <ph id=\"ph1\">`char_type`</ph> characters are equal.","source":"Tests whether two `char_type` characters are equal."},{"pos":[13710,13720],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The first of two characters to be tested for equality.","pos":[13734,13788]},{"content":"The second of two characters to be tested for equality.","pos":[13805,13860]},{"pos":[13870,13882],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[13886,13972],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the first character is equal to the second character; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the first character is equal to the second character; otherwise **false**."},{"pos":[13982,13989],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15016,15081],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__eq_int_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::eq_int_type","linkify":"<a name=\"char_traits__eq_int_type\"></a>  char_traits::eq_int_type","source":"<a name=\"char_traits__eq_int_type\"></a>  char_traits::eq_int_type"},{"pos":[15085,15158],"content":"Tests whether two characters represented as <ph id=\"ph1\">`int_type`</ph>s are equal or not.","source":"Tests whether two characters represented as `int_type`s are equal or not."},{"pos":[15252,15262],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The first of the two characters to be tested for equality as <bpt id=\"p1\">**</bpt>int_type<ept id=\"p1\">**</ept>s.","pos":[15276,15351],"source":" The first of the two characters to be tested for equality as **int_type**s."},{"content":"The second of the two characters to be tested for equality as <ph id=\"ph1\">`int_type`</ph>s.","pos":[15368,15442],"source":" The second of the two characters to be tested for equality as `int_type`s."},{"pos":[15452,15464],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[15468,15554],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the first character is equal to the second character; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the first character is equal to the second character; otherwise **false**."},{"pos":[15564,15571],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17772,17823],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__find\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::find","linkify":"<a name=\"char_traits__find\"></a>  char_traits::find","source":"<a name=\"char_traits__find\"></a>  char_traits::find"},{"content":"Searches for the first occurrence of a specified character in a range of characters.","pos":[17827,17911]},{"pos":[18031,18041],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The first character in the string to be searched.","pos":[18055,18104]},{"content":"The number of positions, counting from the first, in the range to be searched.","pos":[18121,18199]},{"content":"The character to be searched for in the range.","pos":[18215,18261]},{"pos":[18271,18283],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A pointer to the first occurrence of the specified character in the range if a match is found; otherwise, a null pointer.","pos":[18287,18408]},{"pos":[18418,18425],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19622,19681],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__int_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::int_type","linkify":"<a name=\"char_traits__int_type\"></a>  char_traits::int_type","source":"<a name=\"char_traits__int_type\"></a>  char_traits::int_type"},{"pos":[19685,19786],"content":"An integer type that can represent a character of type <ph id=\"ph1\">`char_type`</ph> or an end-of-file (EOF) character.","source":"An integer type that can represent a character of type `char_type` or an end-of-file (EOF) character."},{"pos":[19836,19843],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[19847,19985],"content":"It must be possible to type cast a value of type <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> to <ph id=\"ph1\">`int_type`</ph> then back to <bpt id=\"p2\">**</bpt>CharType<ept id=\"p2\">**</ept> without altering the original value.","source":"It must be possible to type cast a value of type **CharType** to `int_type` then back to **CharType** without altering the original value."},{"pos":[19995,20002],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20007,20120],"content":"See the example for <bpt id=\"p1\">[</bpt>eq_int_type<ept id=\"p1\">](#char_traits__eq_int_type)</ept> for an example of how to declare and use <ph id=\"ph1\">`int_type`</ph>.","source":"See the example for [eq_int_type](#char_traits__eq_int_type) for an example of how to declare and use `int_type`."},{"pos":[20130,20185],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::length","linkify":"<a name=\"char_traits__length\"></a>  char_traits::length","source":"<a name=\"char_traits__length\"></a>  char_traits::length"},{"content":"Returns the length of a string.","pos":[20189,20220]},{"pos":[20289,20299],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The C-string whose length is to be measured.","pos":[20313,20357]},{"pos":[20367,20379],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of elements in the sequence being measured, not including the null terminator.","pos":[20383,20472]},{"pos":[20482,20489],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[21000,21047],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__lt\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::lt","linkify":"<a name=\"char_traits__lt\"></a>  char_traits::lt","source":"<a name=\"char_traits__lt\"></a>  char_traits::lt"},{"content":"Tests whether one character is less than another.","pos":[21051,21100]},{"pos":[21187,21197],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The first of two characters to be tested for less than.","pos":[21211,21266]},{"content":"The second of two characters to be tested for less than.","pos":[21283,21339]},{"pos":[21349,21361],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[21365,21452],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the first character is less than the second character; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the first character is less than the second character; otherwise **false**."},{"pos":[21462,21469],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22500,22551],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__move\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::move","linkify":"<a name=\"char_traits__move\"></a>  char_traits::move","source":"<a name=\"char_traits__move\"></a>  char_traits::move"},{"content":"Copies a specified number of characters in a sequence to another, possibly overlapping sequence.","pos":[22555,22651]},{"content":"This method is potentially unsafe, as it relies on the caller to check that the passed values are correct.","pos":[22658,22764]},{"content":"Consider using <bpt id=\"p1\">[</bpt>char_traits::_Move_s<ept id=\"p1\">](#char_traits___move_s)</ept> instead.","pos":[22765,22834],"source":" Consider using [char_traits::_Move_s](#char_traits___move_s) instead."},{"pos":[22944,22954],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element at the beginning of the string or character array targeted to receive the copied sequence of characters.","pos":[22967,23083]},{"content":"The element at the beginning of the source string or character array to be copied.","pos":[23101,23183]},{"content":"The number of elements to be copied from the source string.","pos":[23200,23259]},{"pos":[23269,23281],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[23285,23405],"content":"The first element <ph id=\"ph1\">`_To`</ph> copied into the string or character array targeted to receive the copied sequence of characters.","source":"The first element `_To` copied into the string or character array targeted to receive the copied sequence of characters."},{"pos":[23415,23422],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The source and destination may overlap.","pos":[23426,23465]},{"pos":[23475,23482],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25125,25182],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits___move_s\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::_Move_s","linkify":"<a name=\"char_traits___move_s\"></a>  char_traits::_Move_s","source":"<a name=\"char_traits___move_s\"></a>  char_traits::_Move_s"},{"content":"Copies a specified number of characters in a sequence to another, possibly overlapping sequence.","pos":[25186,25282]},{"pos":[25430,25440],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element at the beginning of the string or character array targeted to receive the copied sequence of characters.","pos":[25455,25571]},{"content":"The size of <ph id=\"ph1\">` dest`</ph>.","pos":[25594,25614],"source":" The size of ` dest`."},{"content":"If <ph id=\"ph1\">`char_type`</ph> is <ph id=\"ph2\">`char`</ph>, then this is in bytes.","pos":[25615,25663],"source":" If `char_type` is `char`, then this is in bytes."},{"content":"If <ph id=\"ph1\">`char_type`</ph> is <ph id=\"ph2\">`wchar_t`</ph>, then this is in words.","pos":[25664,25715],"source":" If `char_type` is `wchar_t`, then this is in words."},{"content":"The element at the beginning of the source string or character array to be copied.","pos":[25733,25815]},{"content":"The number of elements to be copied from the source string.","pos":[25834,25893]},{"pos":[25903,25915],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[25919,26041],"content":"The first element <ph id=\"ph1\">` dest`</ph> copied into the string or character array targeted to receive the copied sequence of characters.","source":"The first element ` dest` copied into the string or character array targeted to receive the copied sequence of characters."},{"pos":[26051,26058],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The source and destination may overlap.","pos":[26062,26101]},{"pos":[26111,26118],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27787,27844],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__not_eof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::not_eof","linkify":"<a name=\"char_traits__not_eof\"></a>  char_traits::not_eof","source":"<a name=\"char_traits__not_eof\"></a>  char_traits::not_eof"},{"content":"Tests whether a character is not the end-of-file (EOF) character or is the EOF.","pos":[27848,27927]},{"pos":[27998,28008],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The character represented as an <ph id=\"ph1\">`int_type`</ph> to be tested for whether it is the EOF character or not.","pos":[28021,28120],"source":" The character represented as an `int_type` to be tested for whether it is the EOF character or not."},{"pos":[28130,28142],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[28146,28280],"content":"The <ph id=\"ph1\">`int_type`</ph> representation of the character tested, if the <bpt id=\"p1\">**</bpt>int_type<ept id=\"p1\">**</ept> of the character is not equal to that of the EOF character.","source":"The `int_type` representation of the character tested, if the **int_type** of the character is not equal to that of the EOF character."},{"pos":[28287,28374],"content":"If the character <ph id=\"ph1\">`int_type`</ph> value is equal to the EOF <ph id=\"ph2\">`int_type`</ph> value, then <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept>.","source":"If the character `int_type` value is equal to the EOF `int_type` value, then **false**."},{"pos":[28384,28391],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[30026,30085],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__off_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::off_type","linkify":"<a name=\"char_traits__off_type\"></a>  char_traits::off_type","source":"<a name=\"char_traits__off_type\"></a>  char_traits::off_type"},{"content":"An integer type that can represent offsets between positions in a stream.","pos":[30089,30162]},{"pos":[30217,30224],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type is a signed integer that describes an object that can store a byte offset involved in various stream positioning operations.","pos":[30228,30361]},{"content":"It is typically a synonym for <bpt id=\"p1\">[</bpt>streamoff<ept id=\"p1\">](../standard-library/ios-typedefs.md#streamoff)</ept>, but it has essentially the same properties as that type.","pos":[30362,30508],"source":" It is typically a synonym for [streamoff](../standard-library/ios-typedefs.md#streamoff), but it has essentially the same properties as that type."},{"pos":[30518,30577],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__pos_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::pos_type","linkify":"<a name=\"char_traits__pos_type\"></a>  char_traits::pos_type","source":"<a name=\"char_traits__pos_type\"></a>  char_traits::pos_type"},{"content":"An integer type that can represent positions in a stream.","pos":[30581,30638]},{"pos":[30693,30700],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type describes an object that can store all the information needed to restore an arbitrary file-position indicator within a stream.","pos":[30704,30839]},{"content":"It is typically a synonym for <bpt id=\"p1\">[</bpt>streampos<ept id=\"p1\">](../standard-library/ios-typedefs.md#streampos)</ept>, but in any case it has essentially the same properties as that type.","pos":[30840,30998],"source":" It is typically a synonym for [streampos](../standard-library/ios-typedefs.md#streampos), but in any case it has essentially the same properties as that type."},{"pos":[31008,31071],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__state_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::state_type","linkify":"<a name=\"char_traits__state_type\"></a>  char_traits::state_type","source":"<a name=\"char_traits__state_type\"></a>  char_traits::state_type"},{"content":"A type that represents the conversion state for multibyte characters in a stream.","pos":[31075,31156]},{"pos":[31226,31233],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type describes an object that can represent a conversion state.","pos":[31237,31304]},{"content":"It is typically a synonym for <ph id=\"ph1\">`mbstate_t`</ph>, but in any case it has essentially the same properties as that type.","pos":[31305,31416],"source":" It is typically a synonym for `mbstate_t`, but in any case it has essentially the same properties as that type."},{"pos":[31426,31493],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__to_char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::to_char_type","linkify":"<a name=\"char_traits__to_char_type\"></a>  char_traits::to_char_type","source":"<a name=\"char_traits__to_char_type\"></a>  char_traits::to_char_type"},{"pos":[31497,31596],"content":"Converts an <ph id=\"ph1\">`int_type`</ph> character to the corresponding <ph id=\"ph2\">`char_type`</ph> character and returns the result.","source":"Converts an `int_type` character to the corresponding `char_type` character and returns the result."},{"pos":[31673,31683],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <ph id=\"ph1\">`int_type`</ph> character to be represented as a <ph id=\"ph2\">`char_type`</ph>.","pos":[31696,31756],"source":" The `int_type` character to be represented as a `char_type`."},{"pos":[31766,31778],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[31782,31850],"content":"The <ph id=\"ph1\">`char_type`</ph> character corresponding to the <ph id=\"ph2\">`int_type`</ph> character.","source":"The `char_type` character corresponding to the `int_type` character."},{"pos":[31857,31938],"content":"A value of <ph id=\"ph1\">`_Ch`</ph> that cannot be represented as such yields an unspecified result.","source":"A value of `_Ch` that cannot be represented as such yields an unspecified result."},{"pos":[31948,31955],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[31959,32080],"content":"The conversion operations <bpt id=\"p1\">[</bpt>to_int_type<ept id=\"p1\">](#char_traits__to_int_type)</ept> and <ph id=\"ph1\">`to_char_type`</ph> are inverse to each other, so that:","source":"The conversion operations [to_int_type](#char_traits__to_int_type) and `to_char_type` are inverse to each other, so that:"},{"pos":[32087,32134],"content":"<ph id=\"ph1\">`to_int_type`</ph> ( <ph id=\"ph2\">`to_char_type`</ph> ( <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> ) ) == <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>","source":"`to_int_type` ( `to_char_type` ( *x* ) ) == *x*"},{"pos":[32141,32167],"content":"for any <ph id=\"ph1\">`int_type`</ph> <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and","source":"for any `int_type` *x* and"},{"pos":[32174,32221],"content":"<ph id=\"ph1\">`to_char_type`</ph> ( <ph id=\"ph2\">`to_int_type`</ph> ( <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> ) ) == <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>","source":"`to_char_type` ( `to_int_type` ( *x* ) ) == *x*"},{"pos":[32228,32252],"content":"for any <ph id=\"ph1\">`char_type`</ph> <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>.","source":"for any `char_type` *x*."},{"pos":[32262,32269],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[34886,34951],"content":"<bpt id=\"p1\">&lt;a name=\"char_traits__to_int_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  char_traits::to_int_type","linkify":"<a name=\"char_traits__to_int_type\"></a>  char_traits::to_int_type","source":"<a name=\"char_traits__to_int_type\"></a>  char_traits::to_int_type"},{"pos":[34955,35053],"content":"Converts a <ph id=\"ph1\">`char_type`</ph> character to the corresponding <ph id=\"ph2\">`int_type`</ph> character and returns the result.","source":"Converts a `char_type` character to the corresponding `int_type` character and returns the result."},{"pos":[35129,35139],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <ph id=\"ph1\">`char_type`</ph> character to be represented as an <ph id=\"ph2\">`int_type`</ph>.","pos":[35152,35213],"source":" The `char_type` character to be represented as an `int_type`."},{"pos":[35223,35235],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[35239,35307],"content":"The <ph id=\"ph1\">`int_type`</ph> character corresponding to the <ph id=\"ph2\">`char_type`</ph> character.","source":"The `int_type` character corresponding to the `char_type` character."},{"pos":[35317,35324],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[35328,35450],"content":"The conversion operations <ph id=\"ph1\">`to_int_type`</ph> and <bpt id=\"p1\">[</bpt>to_char_type<ept id=\"p1\">](#char_traits__to_char_type)</ept> are inverse to each other, so that:","source":"The conversion operations `to_int_type` and [to_char_type](#char_traits__to_char_type) are inverse to each other, so that:"},{"pos":[35457,35504],"content":"<ph id=\"ph1\">`to_int_type`</ph> ( <ph id=\"ph2\">`to_char_type`</ph> ( <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> ) ) == <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>","source":"`to_int_type` ( `to_char_type` ( *x* ) ) == *x*"},{"pos":[35511,35538],"content":"for any <ph id=\"ph1\">`int_type`</ph> <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>, and","source":"for any `int_type` *x*, and"},{"pos":[35545,35592],"content":"<ph id=\"ph1\">`to_char_type`</ph> ( <ph id=\"ph2\">`to_int_type`</ph> ( <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> ) ) == <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>","source":"`to_char_type` ( `to_int_type` ( *x* ) ) == *x*"},{"pos":[35599,35623],"content":"for any <ph id=\"ph1\">`char_type`</ph> <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>.","source":"for any `char_type` *x*."},{"pos":[35633,35640],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[38249,38257],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[38261,38370],"content":"<bpt id=\"p1\">[</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept>","source":"[Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)"}],"content":"---\ntitle: \"char_traits Struct | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::char_traits\"\n  - \"std.char_traits\"\n  - \"iosfwd/std::char_traits\"\n  - \"char_traits\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"char_traits struct\"\n  - \"char_traits class\"\nms.assetid: 568e59f0-4521-4207-9223-9dcf6a16d620\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# char_traits Struct\nThe char_traits struct describes attributes associated with a character.  \n  \n## Syntax  \n  \n```  \ntemplate <class CharType>  \nstruct char_traits;  \n```  \n  \n#### Parameters  \n `CharType`  \n The element data type.  \n  \n## Remarks  \n The template struct describes various character traits for type **CharType**. The template class [basic_string](../standard-library/basic-string-class.md) as well as several iostream template classes, including [basic_ios](../standard-library/basic-ios-class.md), use this information to manipulate elements of type **CharType**. Such an element type must not require explicit construction or destruction. It must supply a default constructor, a copy constructor, and an assignment operator, with the expected semantics. A bitwise copy must have the same effect as an assignment. None of the member functions of struct char_traits can throw exceptions.  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[char_type](#char_traits__char_type)|A type of character.|  \n|[int_type](#char_traits__int_type)|An integer type that can represent a character of type `char_type` or an end-of-file (EOF) character.|  \n|[off_type](#char_traits__off_type)|An integer type that can represent offsets between positions in a stream.|  \n|[pos_type](#char_traits__pos_type)|An integer type that can represent positions in a stream.|  \n|[state_type](#char_traits__state_type)|A type that represents the conversion state in for multibyte characters in a stream.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[assign](#char_traits__assign)|Assigns one character value to another.|  \n|[compare](#char_traits__compare)|Compares up to a specified number of characters in two strings.|  \n|[copy](#char_traits__copy)|Copies a specified number of characters from one string to another. Deprecated. Use [char_traits::_Copy_s](#char_traits___copy_s) instead.|  \n|[_Copy_s](#char_traits___copy_s)|Copies a specified number of characters from one string to another.|  \n|[eof](#char_traits__eof)|Returns the end-of-file (EOF) character.|  \n|[eq](#char_traits__eq)|Tests whether two `char_type` characters are equal.|  \n|[eq_int_type](#char_traits__eq_int_type)|Tests whether two characters represented as `int_type`s are equal.|  \n|[find](#char_traits__find)|Searches for the first occurrence of a specified character in a range of characters.|  \n|[length](#char_traits__length)|Returns the length of a string.|  \n|[lt](#char_traits__lt)|Tests whether one character is less than another.|  \n|[move](#char_traits__move)|Copies a specified number of characters in a sequence to another, possible overlapping, sequence. Deprecated. Use [char_traits::_Move_s](#char_traits___move_s) instead.|  \n|[_Move_s](#char_traits___move_s)|Copies a specified number of characters in a sequence to another, possible overlapping, sequence.|  \n|[not_eof](#char_traits__not_eof)|Tests whether a character is the end-of-file (EOF) character.|  \n|[to_char_type](#char_traits__to_char_type)|Converts an `int_type` character to the corresponding `char_type` character and returns the result.|  \n|[to_int_type](#char_traits__to_int_type)|Converts a `char_type` character to the corresponding `int_type` character and returns the result.|  \n  \n## Requirements  \n **Header:** \\<string>  \n  \n **Namespace:** std  \n  \n##  <a name=\"char_traits__assign\"></a>  char_traits::assign  \n Assigns one character value to another or to a range of elements in a string.  \n  \n```  \nstatic void assign(char_type& _CharTo,\n    const char_type& _CharFrom);\n\nstatic char_type *assign(char_type* strTo,\n    size_t _Num,\n    char_type _CharFrom);\n```  \n  \n### Parameters  \n **_** *CharFrom*  \n The character whose value is to be assigned.  \n  \n *_CharTo*  \n The element that is to be assigned the character value.  \n  \n * strTo*  \n The string or character array whose initial elements are to be assigned character values.  \n  \n `_Num`  \n The number of elements that are going to be assigned values.  \n  \n### Return Value  \n The second member function returns a pointer to the string whose first `_Num` elements have been assigned values of *_CharFrom*.  \n  \n### Example  \n  \n```cpp  \n// char_traits_assign.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // The first member function assigning   \n   // one character value to another character  \n   char ChTo = 't';  \n   const char ChFrom = 'f';  \n   cout << \"The initial characters ( ChTo , ChFrom ) are: ( \"  \n        << ChTo << \" , \" << ChFrom << \" ).\" << endl;  \n   char_traits<char>::assign ( ChTo , ChFrom );  \n   cout << \"After assigning, the characters ( ChTo , ChFrom ) are: ( \"  \n        << ChTo << \" , \" << ChFrom << \" ).\" << endl << endl;  \n  \n   // The second member function assigning   \n   // character values to initial part of a string  \n   char_traits<char>::char_type s1[] = \"abcd-1234-abcd\";  \n   char_traits<char>::char_type* result1;  \n   cout << \"The target string s1 is: \" << s1 << endl;  \n   result1 = char_traits<char>::assign ( s1 , 4 , 'f' );  \n   cout << \"The result1 = assign ( s1 , 4 , 'f' ) is: \"  \n        << result1 << endl;  \n}  \n```  \n  \n```Output  \nThe initial characters ( ChTo , ChFrom ) are: ( t , f ).  \nAfter assigning, the characters ( ChTo , ChFrom ) are: ( f , f ).  \n  \nThe target string s1 is: abcd-1234-abcd  \nThe result1 = assign ( s1 , 4 , 'f' ) is: ffff-1234-abcd  \n```  \n  \n##  <a name=\"char_traits__char_type\"></a>  char_traits::char_type  \n A type of character.  \n  \n```  \ntypedef CharType char_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **CharType**.  \n  \n### Example  \n  See the example for [copy](#char_traits__copy) for an example of how to declare and use `char_type`.  \n  \n##  <a name=\"char_traits__compare\"></a>  char_traits::compare  \n Compares up to a specified number of characters in two strings.  \n  \n```  \nstatic int compare(const char_type* str1,\n    const char_type* str2,\n    size_t _Num);\n```  \n  \n### Parameters  \n * str1*  \n The first of two strings to be compared to each other.  \n  \n * str2*  \n The second of two strings to be compared to each other.  \n  \n `_Num`  \n The number of elements in the strings to be compared.  \n  \n### Return Value  \n A negative value if the first string is less than the second string, 0 if the two strings are equal, or a positive value if the first string is greater than the second string.  \n  \n### Remarks  \n The comparison between the strings is made element by element, first testing for equality and then, if a pair of elements in the sequence tests not equal, they are tested for less than.  \n  \n If two strings compare equal over a range but one is longer than the other, then the shorter of the two is less than the longer one.  \n  \n### Example  \n  \n```cpp  \n// char_traits_compare.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n  \n   char_traits<char>::char_type* s1 = \"CAB\";  \n   char_traits<char>::char_type* s2 = \"ABC\";  \n   char_traits<char>::char_type* s3 = \"ABC\";  \n   char_traits<char>::char_type* s4 = \"ABCD\";  \n  \n   cout << \"The string s1 is: \" << s1 << endl;  \n   cout << \"The string s2 is: \" << s2 << endl;  \n   cout << \"The string s3 is: \" << s3 << endl;  \n   cout << \"The string s4 is: \" << s4 << endl;  \n  \n   int comp1, comp2, comp3, comp4;  \n   comp1 = char_traits<char>::compare ( s1 , s2 , 2 );  \n   comp2 = char_traits<char>::compare ( s2 , s3 , 3 );  \n   comp3 = char_traits<char>::compare ( s3 , s4 , 4 );  \n   comp4 = char_traits<char>::compare ( s4 , s3 , 4 );  \n   cout << \"compare ( s1 , s2 , 2 ) = \" << comp1 << endl;  \n   cout << \"compare ( s2 , s3 , 3 ) = \" << comp2 << endl;  \n   cout << \"compare ( s3 , s4 , 4 ) = \" << comp3 << endl;  \n   cout << \"compare ( s4 , s3 , 4 ) = \" << comp4 << endl;  \n}  \n```  \n  \n##  <a name=\"char_traits__copy\"></a>  char_traits::copy  \n Copies a specified number of characters from one string to another.  \n  \n This method is potentially unsafe, as it relies on the caller to check that the passed values are correct. Consider using [char_traits::_Copy_s](#char_traits___copy_s) instead.  \n  \n```  \nstatic char_type *copy(char_type* _To,\n    const char_type* _From,\n    size_t _Num);\n```  \n  \n### Parameters  \n `_To`  \n The element at the beginning of the string or character array targeted to receive the copied sequence of characters.  \n  \n `_From`  \n The element at the beginning of the source string or character array to be copied.  \n  \n `_Num`  \n The number of elements to be copied.  \n  \n### Return Value  \n The first element copied into the string or character array targeted to receive the copied sequence of characters.  \n  \n### Remarks  \n The source and destination character sequences must not overlap.  \n  \n### Example  \n  \n```cpp  \n// char_traits_copy.cpp  \n// compile with: /EHsc /W3  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   char_traits<char>::char_type s1[] = \"abcd-1234-abcd\";  \n   char_traits<char>::char_type s2[] = \"ABCD-1234\";  \n   char_traits<char>::char_type* result1;  \n   cout << \"The source string is: \" << s1 << endl;  \n   cout << \"The destination string is: \" << s2 << endl;  \n   // Note: char_traits::copy is potentially unsafe, consider  \n   // using char_traits::_Copy_s instead.  \n   result1 = char_traits<char>::copy ( s1 , s2 , 4 );  // C4996  \n   cout << \"The result1 = copy ( s1 , s2 , 4 ) is: \"  \n        << result1 << endl;  \n}  \n```  \n  \n```Output  \nThe source string is: abcd-1234-abcd  \nThe destination string is: ABCD-1234  \nThe result1 = copy ( s1 , s2 , 4 ) is: ABCD-1234-abcd  \n```  \n  \n##  <a name=\"char_traits___copy_s\"></a>  char_traits::_Copy_s  \n Copies a specified number of characters from one string to another.  \n  \n```  \nstatic char_type *_Copy_s(\n    char_type* dest,  \n    size_t dest_size,  \n    const char_type* _From,  \n    size_t count);\n```  \n  \n### Parameters  \n ` dest`  \n The string or character array targeted to receive the copied sequence of characters.  \n  \n ` dest_size`  \n The size of ` dest`. If `char_type` is `char`, then this size is in bytes. If `char_type` is `wchar_t`, then this size is in words.  \n  \n `_From`  \n The source string or character array to be copied.  \n  \n ` count`  \n The number of elements to be copied.  \n  \n### Return Value  \n The string or character array targeted to receive the copied sequence of characters.  \n  \n### Remarks  \n The source and destination character sequences must not overlap.  \n  \n### Example  \n  \n```cpp  \n// char_traits__Copy_s.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n    using namespace std;  \n  \n    char_traits<char>::char_type s1[] = \"abcd-1234-abcd\";  \n    char_traits<char>::char_type s2[] = \"ABCD-1234\";  \n    char_traits<char>::char_type* result1;  \n    cout << \"The source string is: \" << s1 << endl;  \n    cout << \"The destination string is: \" << s2 << endl;  \n    result1 = char_traits<char>::_Copy_s(s1,  \n        char_traits<char>::length(s1), s2, 4);  \n    cout << \"The result1 = _Copy_s(s1, \"  \n         << \"char_traits<char>::length(s1), s2, 4) is: \"  \n         << result1 << endl;  \n}  \n```  \n  \n```Output  \nThe source string is: abcd-1234-abcd  \nThe destination string is: ABCD-1234  \nThe result1 = _Copy_s(s1, char_traits<char>::length(s1), s2, 4) is: ABCD-1234-abcd  \n```  \n  \n##  <a name=\"char_traits__eof\"></a>  char_traits::eof  \n Returns the end-of-file (EOF) character.  \n  \n```  \nstatic int_type eof();\n```  \n  \n### Return Value  \n The EOF character.  \n  \n### Remarks  \n A value that represents end of file (such as `EOF` or `WEOF`).  \n  \n The C++ standard states that this value must not correspond to a valid `char_type` value. The Visual C++ compiler enforces this constraint for type `char`, but not for type `wchar_t`. The example below demonstrates this.  \n  \n### Example  \n  \n```cpp  \n// char_traits_eof.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace std;  \n  \n    char_traits<char>::char_type ch1 = 'x';  \n    char_traits<char>::int_type int1;  \n    int1 = char_traits<char>::to_int_type(ch1);  \n    cout << \"char_type ch1 is '\" << ch1 << \"' and corresponds to int_type \"  \n         << int1 << \".\" << endl << endl;  \n  \n    char_traits<char>::int_type int2 = char_traits<char>::eof();  \n    cout << \"The eof marker for char_traits<char> is: \" << int2 << endl;  \n  \n    char_traits<wchar_t>::int_type int3 = char_traits<wchar_t>::eof();  \n    cout << \"The eof marker for char_traits<wchar_t> is: \" << int3 << endl;  \n}  \n```  \n  \n```Output  \nchar_type ch1 is 'x' and corresponds to int_type 120.  \n  \nThe eof marker for char_traits<char> is: -1  \nThe eof marker for char_traits<wchar_t> is: 65535  \n```  \n  \n##  <a name=\"char_traits__eq\"></a>  char_traits::eq  \n Tests whether two `char_type` characters are equal.  \n  \n```  \nstatic bool eq(const char_type& _Ch1, const char_type& _Ch2);\n```  \n  \n### Parameters  \n `_Ch1`  \n The first of two characters to be tested for equality.  \n  \n `_Ch2`  \n The second of two characters to be tested for equality.  \n  \n### Return Value  \n **true** if the first character is equal to the second character; otherwise **false**.  \n  \n### Example  \n  \n```cpp  \n// char_traits_eq.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   char_traits<char>::char_type ch1 =  'x';  \n   char_traits<char>::char_type ch2 =  'y';  \n   char_traits<char>::char_type ch3 =  'x';  \n  \n   // Testing for equality  \n   bool b1 = char_traits<char>::eq ( ch1 , ch2 );  \n   if ( b1 )  \n      cout << \"The character ch1 is equal \"  \n           << \"to the character ch2.\" << endl;  \n   else  \n      cout << \"The character ch1 is not equal \"  \n           << \"to the character ch2.\" << endl;  \n  \n   // An equivalent and alternatively test procedure  \n   if ( ch1 == ch3 )  \n      cout << \"The character ch1 is equal \"  \n           << \"to the character ch3.\" << endl;  \n   else  \n      cout << \"The character ch1 is not equal \"  \n           << \"to the character ch3.\" << endl;  \n}  \n```  \n  \n```Output  \nThe character ch1 is not equal to the character ch2.  \nThe character ch1 is equal to the character ch3.  \n```  \n  \n##  <a name=\"char_traits__eq_int_type\"></a>  char_traits::eq_int_type  \n Tests whether two characters represented as `int_type`s are equal or not.  \n  \n```  \nstatic bool eq_int_type(const int_type& _Ch1, const int_type& _Ch2);\n```  \n  \n### Parameters  \n `_Ch1`  \n The first of the two characters to be tested for equality as **int_type**s.  \n  \n `_Ch2`  \n The second of the two characters to be tested for equality as `int_type`s.  \n  \n### Return Value  \n **true** if the first character is equal to the second character; otherwise **false**.  \n  \n### Example  \n  \n```cpp  \n// char_traits_eq_int_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   char_traits<char>::char_type ch1 =  'x';  \n   char_traits<char>::char_type ch2 =  'y';  \n   char_traits<char>::char_type ch3 =  'x';  \n  \n   // Converting from char_type to int_type  \n   char_traits<char>::int_type int1, int2 , int3;  \n   int1 =char_traits<char>:: to_int_type ( ch1 );  \n   int2 =char_traits<char>:: to_int_type ( ch2 );  \n   int3 =char_traits<char>:: to_int_type ( ch3 );  \n  \n   cout << \"The char_types and corresponding int_types are:\"  \n        << \"\\n    ch1 = \" << ch1 << \" corresponding to int1 = \"  \n        << int1 << \".\"  \n        << \"\\n    ch2 = \" << ch2 << \" corresponding to int1 = \"  \n        << int2 << \".\"  \n        << \"\\n    ch3 = \" << ch3 << \" corresponding to int1 = \"  \n        << int3 << \".\" << endl << endl;  \n  \n   // Testing for equality of int_type representations  \n   bool b1 = char_traits<char>::eq_int_type ( int1 , int2 );  \n   if ( b1 )  \n      cout << \"The int_type representation of character ch1\\n \"  \n           << \"is equal to the int_type representation of ch2.\"  \n           << endl;  \n   else  \n      cout << \"The int_type representation of character ch1\\n is \"  \n           << \"not equal to the int_type representation of ch2.\"  \n           << endl;  \n  \n   // An equivalent and alternatively test procedure  \n   if ( int1 == int3 )  \n      cout << \"The int_type representation of character ch1\\n \"  \n           << \"is equal to the int_type representation of ch3.\"  \n           << endl;  \n   else  \n      cout << \"The int_type representation of character ch1\\n is \"  \n           << \"not equal to the int_type representation of ch3.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe char_types and corresponding int_types are:  \n    ch1 = x corresponding to int1 = 120.  \n    ch2 = y corresponding to int1 = 121.  \n    ch3 = x corresponding to int1 = 120.  \n  \nThe int_type representation of character ch1  \n is not equal to the int_type representation of ch2.  \nThe int_type representation of character ch1  \n is equal to the int_type representation of ch3.  \n```  \n  \n##  <a name=\"char_traits__find\"></a>  char_traits::find  \n Searches for the first occurrence of a specified character in a range of characters.  \n  \n```  \nstatic const char_type* find(const char_type* str,\n    size_t _Num,\n    const char_type& _Ch);\n```  \n  \n### Parameters  \n ` str`  \n The first character in the string to be searched.  \n  \n `_Num`  \n The number of positions, counting from the first, in the range to be searched.  \n  \n `_Ch`  \n The character to be searched for in the range.  \n  \n### Return Value  \n A pointer to the first occurrence of the specified character in the range if a match is found; otherwise, a null pointer.  \n  \n### Example  \n  \n```cpp  \n// char_traits_find.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   const char* s1 = \"f2d-1234-abcd\";  \n   const char* result1;  \n   cout << \"The string to be searched is: \" << s1 << endl;  \n  \n   // Searching for a 'd' in the first 6 positions of string s1  \n   result1 = char_traits<char>::find ( s1 , 6 , 'd');  \n   cout << \"The character searched for in s1 is: \"  \n        << *result1 << endl;  \n   cout << \"The string beginning with the first occurrence\\n \"  \n        << \"of the character 'd' is: \" << result1 << endl;  \n  \n   // When no match is found the NULL value is returned  \n   const char* result2;  \n   result2 = char_traits<char>::find ( s1 , 3 , 'a');  \n   if ( result2 == NULL )  \n      cout << \"The result2 of the search is NULL.\" << endl;  \n   else  \n      cout << \"The result2 of the search  is: \" << result1  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe string to be searched is: f2d-1234-abcd  \nThe character searched for in s1 is: d  \nThe string beginning with the first occurrence  \n of the character 'd' is: d-1234-abcd  \nThe result2 of the search is NULL.  \n```  \n  \n##  <a name=\"char_traits__int_type\"></a>  char_traits::int_type  \n An integer type that can represent a character of type `char_type` or an end-of-file (EOF) character.  \n  \n```  \ntypedef long int_type;  \n```  \n  \n### Remarks  \n It must be possible to type cast a value of type **CharType** to `int_type` then back to **CharType** without altering the original value.  \n  \n### Example  \n  See the example for [eq_int_type](#char_traits__eq_int_type) for an example of how to declare and use `int_type`.  \n  \n##  <a name=\"char_traits__length\"></a>  char_traits::length  \n Returns the length of a string.  \n  \n```  \nstatic size_t length(const char_type* str);\n```  \n  \n### Parameters  \n ` str`  \n The C-string whose length is to be measured.  \n  \n### Return Value  \n The number of elements in the sequence being measured, not including the null terminator.  \n  \n### Example  \n  \n```cpp  \n// char_traits_length.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   const char* str1= \"Hello\";  \n   cout << \"The C-string str1 is: \" << str1 << endl;  \n  \n   size_t lenStr1;  \n   lenStr1 = char_traits<char>::length ( str1 );  \n   cout << \"The length of C-string str1 is: \"   \n        << lenStr1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe C-string str1 is: Hello  \nThe length of C-string str1 is: 5.  \n```  \n  \n##  <a name=\"char_traits__lt\"></a>  char_traits::lt  \n Tests whether one character is less than another.  \n  \n```  \nstatic bool lt(const char_type& _Ch1, const char_type& _Ch2);\n```  \n  \n### Parameters  \n `_Ch1`  \n The first of two characters to be tested for less than.  \n  \n `_Ch2`  \n The second of two characters to be tested for less than.  \n  \n### Return Value  \n **true** if the first character is less than the second character; otherwise **false**.  \n  \n### Example  \n  \n```cpp  \n// char_traits_lt.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   char_traits<char>::char_type ch1 =  'x';  \n   char_traits<char>::char_type ch2 =  'y';  \n   char_traits<char>::char_type ch3 =  'z';  \n  \n   // Testing for less than  \n   bool b1 = char_traits<char>::lt ( ch1 , ch2 );  \n   if ( b1 )  \n      cout << \"The character ch1 is less than \"  \n           << \"the character ch2.\" << endl;  \n   else  \n      cout << \"The character ch1 is not less \"  \n           << \"than the character ch2.\" << endl;  \n  \n   // An equivalent and alternatively test procedure  \n   if ( ch3 <  ch2 )  \n      cout << \"The character ch3 is less than \"  \n           << \"the character ch2.\" << endl;  \n   else  \n      cout << \"The character ch3 is not less \"  \n           << \"than the character ch2.\" << endl;  \n}  \n```  \n  \n```Output  \nThe character ch1 is less than the character ch2.  \nThe character ch3 is not less than the character ch2.  \n```  \n  \n##  <a name=\"char_traits__move\"></a>  char_traits::move  \n Copies a specified number of characters in a sequence to another, possibly overlapping sequence.  \n  \n This method is potentially unsafe, as it relies on the caller to check that the passed values are correct. Consider using [char_traits::_Move_s](#char_traits___move_s) instead.  \n  \n```  \nstatic char_type *move(char_type* _To,\n    const char_type* _From,\n    size_t _Num);\n```  \n  \n### Parameters  \n `_To`  \n The element at the beginning of the string or character array targeted to receive the copied sequence of characters.  \n  \n `_From`  \n The element at the beginning of the source string or character array to be copied.  \n  \n `_Num`  \n The number of elements to be copied from the source string.  \n  \n### Return Value  \n The first element `_To` copied into the string or character array targeted to receive the copied sequence of characters.  \n  \n### Remarks  \n The source and destination may overlap.  \n  \n### Example  \n  \n```cpp  \n// char_traits_move.cpp  \n// compile with: /EHsc /W3  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   char_traits<char>::char_type sFrom1[] =  \"abcd-1234-abcd\";  \n   char_traits<char>::char_type sTo1[] =  \"ABCD-1234\";  \n   char_traits<char>::char_type* result1;  \n   cout << \"The source string sFrom1 is: \" << sFrom1 << endl;  \n   cout << \"The destination stringsTo1 is: \" << sTo1 << endl;  \n   // Note: char_traits::move is potentially unsafe, consider  \n   // using char_traits::_Move_s instead.  \n   result1 = char_traits<char>::move ( sTo1 ,  sFrom1 , 4 );  // C4996  \n   cout << \"The result1 = move ( sTo1 , sFrom1 , 4 ) is: \"  \n        << result1 << endl << endl;  \n  \n   // When source and destination overlap  \n   char_traits<char>::char_type sToFrom2[] = \"abcd-1234-ABCD\";  \n   char_traits<char>::char_type* result2;  \n   cout << \"The source/destination string sToFrom2 is: \"  \n        << sToFrom2 << endl;  \n   const char* findc = char_traits<char>::find ( sToFrom2 , 4 , 'c' );  \n   // Note: char_traits::move is potentially unsafe, consider  \n   // using char_traits::_Move_s instead.  \n   result2 = char_traits<char>::move ( sToFrom2 , findc , 8 );  // C4996  \n   cout << \"The result2 = move ( sToFrom2 , findc , 8 ) is: \"  \n        << result2 << endl;  \n}  \n```  \n  \n```Output  \nThe source string sFrom1 is: abcd-1234-abcd  \nThe destination stringsTo1 is: ABCD-1234  \nThe result1 = move ( sTo1 , sFrom1 , 4 ) is: abcd-1234  \n  \nThe source/destination string sToFrom2 is: abcd-1234-ABCD  \nThe result2 = move ( sToFrom2 , findc , 8 ) is: cd-1234-4-ABCD  \n```  \n  \n##  <a name=\"char_traits___move_s\"></a>  char_traits::_Move_s  \n Copies a specified number of characters in a sequence to another, possibly overlapping sequence.  \n  \n```  \nstatic char_type *_Move_s(\n    char_type* dest,  \n    size_t dest_size,  \n    const char_type* _From,  \n    size_t count);\n```  \n  \n### Parameters  \n ` dest`  \n The element at the beginning of the string or character array targeted to receive the copied sequence of characters.  \n  \n ` dest_size`  \n The size of ` dest`. If `char_type` is `char`, then this is in bytes. If `char_type` is `wchar_t`, then this is in words.  \n  \n `_From`  \n The element at the beginning of the source string or character array to be copied.  \n  \n ` count`  \n The number of elements to be copied from the source string.  \n  \n### Return Value  \n The first element ` dest` copied into the string or character array targeted to receive the copied sequence of characters.  \n  \n### Remarks  \n The source and destination may overlap.  \n  \n### Example  \n  \n```cpp  \n// char_traits__Move_s.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n    using namespace std;  \n  \n    char_traits<char>::char_type sFrom1[] =  \"abcd-1234-abcd\";  \n    char_traits<char>::char_type sTo1[] =  \"ABCD-1234\";  \n    char_traits<char>::char_type* result1;  \n    cout << \"The source string sFrom1 is: \" << sFrom1 << endl;  \n    cout << \"The destination stringsTo1 is: \" << sTo1 << endl;  \n    result1 = char_traits<char>::_Move_s(sTo1,  \n        char_traits<char>::length(sTo1), sFrom1, 4);  \n    cout << \"The result1 = _Move_s(sTo1, \"  \n         << \"char_traits<char>::length(sTo1), sFrom1, 4) is: \"  \n         << result1 << endl << endl;  \n  \n    // When source and destination overlap  \n    char_traits<char>::char_type sToFrom2[] = \"abcd-1234-ABCD\";  \n    char_traits<char>::char_type* result2;  \n    cout << \"The source/destination string sToFrom2 is: \"  \n         << sToFrom2 << endl;  \n    const char* findc = char_traits<char>::find(sToFrom2, 4, 'c');  \n    result2 = char_traits<char>::_Move_s(sToFrom2,  \n        char_traits<char>::length(sToFrom2), findc, 8);  \n    cout << \"The result2 = _Move_s(sToFrom2, \"  \n        << \"char_traits<char>::length(sToFrom2), findc, 8) is: \"  \n         << result2 << endl;  \n}  \n```  \n  \n```Output  \nThe source string sFrom1 is: abcd-1234-abcd  \nThe destination stringsTo1 is: ABCD-1234  \nThe result1 = _Move_s(sTo1, char_traits<char>::length(sTo1), sFrom1, 4) is: abcd-1234  \n  \nThe source/destination string sToFrom2 is: abcd-1234-ABCD  \nThe result2 = _Move_s(sToFrom2, char_traits<char>::length(sToFrom2), findc, 8) is: cd-1234-4-ABCD  \n```  \n  \n##  <a name=\"char_traits__not_eof\"></a>  char_traits::not_eof  \n Tests whether a character is not the end-of-file (EOF) character or is the EOF.  \n  \n```  \nstatic int_type not_eof(const int_type& _Ch);\n```  \n  \n### Parameters  \n `_Ch`  \n The character represented as an `int_type` to be tested for whether it is the EOF character or not.  \n  \n### Return Value  \n The `int_type` representation of the character tested, if the **int_type** of the character is not equal to that of the EOF character.  \n  \n If the character `int_type` value is equal to the EOF `int_type` value, then **false**.  \n  \n### Example  \n  \n```cpp  \n// char_traits_not_eof.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n  \n   char_traits<char>::char_type ch1 =  'x';  \n   char_traits<char>::int_type int1;  \n   int1 = char_traits<char>:: to_int_type ( ch1 );  \n   cout << \"The char_type ch1 is \" << ch1  \n        << \" corresponding to int_type: \"   \n        << int1 << \".\" << endl;  \n  \n   // EOF member function  \n   char_traits <char>::int_type int2 = char_traits<char>::eof ( );  \n   cout << \"The eofReturn is: \" << int2 << endl;  \n  \n   // Testing for EOF or another character  \n   char_traits <char>::int_type eofTest1, eofTest2;  \n   eofTest1 = char_traits<char>::not_eof ( int1 );  \n   if ( !eofTest1 )  \n      cout << \"The eofTest1 indicates ch1 is an EOF character.\"  \n              << endl;  \n   else  \n      cout << \"The eofTest1 returns: \" << eofTest1   \n           << \", which is the character: \"   \n           <<  char_traits<char>::to_char_type ( eofTest1 )  \n           << \".\" << endl;  \n  \n   eofTest2 = char_traits<char>::not_eof ( int2 );  \n   if ( !eofTest2 )  \n      cout << \"The eofTest2 indicates int2 is an EOF character.\"   \n           << endl;  \n   else  \n      cout << \"The eofTest1 returns: \" << eofTest2   \n           << \", which is the character: \"   \n           <<  char_traits<char>::to_char_type ( eofTest2 )   \n           << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe char_type ch1 is x corresponding to int_type: 120.  \nThe eofReturn is: -1  \nThe eofTest1 returns: 120, which is the character: x.  \nThe eofTest2 indicates int2 is an EOF character.  \n```  \n  \n##  <a name=\"char_traits__off_type\"></a>  char_traits::off_type  \n An integer type that can represent offsets between positions in a stream.  \n  \n```  \ntypedef streamoff off_type;  \n```  \n  \n### Remarks  \n The type is a signed integer that describes an object that can store a byte offset involved in various stream positioning operations. It is typically a synonym for [streamoff](../standard-library/ios-typedefs.md#streamoff), but it has essentially the same properties as that type.  \n  \n##  <a name=\"char_traits__pos_type\"></a>  char_traits::pos_type  \n An integer type that can represent positions in a stream.  \n  \n```  \ntypedef streampos pos_type;  \n```  \n  \n### Remarks  \n The type describes an object that can store all the information needed to restore an arbitrary file-position indicator within a stream. It is typically a synonym for [streampos](../standard-library/ios-typedefs.md#streampos), but in any case it has essentially the same properties as that type.  \n  \n##  <a name=\"char_traits__state_type\"></a>  char_traits::state_type  \n A type that represents the conversion state for multibyte characters in a stream.  \n  \n```  \ntypedef implementation-defined state_type;  \n```  \n  \n### Remarks  \n The type describes an object that can represent a conversion state. It is typically a synonym for `mbstate_t`, but in any case it has essentially the same properties as that type.  \n  \n##  <a name=\"char_traits__to_char_type\"></a>  char_traits::to_char_type  \n Converts an `int_type` character to the corresponding `char_type` character and returns the result.  \n  \n```  \nstatic char_type to_char_type(const int_type& _Ch);\n```  \n  \n### Parameters  \n `_Ch`  \n The `int_type` character to be represented as a `char_type`.  \n  \n### Return Value  \n The `char_type` character corresponding to the `int_type` character.  \n  \n A value of `_Ch` that cannot be represented as such yields an unspecified result.  \n  \n### Remarks  \n The conversion operations [to_int_type](#char_traits__to_int_type) and `to_char_type` are inverse to each other, so that:  \n  \n `to_int_type` ( `to_char_type` ( *x* ) ) == *x*  \n  \n for any `int_type` *x* and  \n  \n `to_char_type` ( `to_int_type` ( *x* ) ) == *x*  \n  \n for any `char_type` *x*.  \n  \n### Example  \n  \n```cpp  \n// char_traits_to_char_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   char_traits<char>::char_type ch1 =  'a';  \n   char_traits<char>::char_type ch2 =  'b';  \n   char_traits<char>::char_type ch3 =  'a';  \n  \n   // Converting from char_type to int_type  \n   char_traits<char>::int_type int1, int2 , int3;  \n   int1 =char_traits<char>:: to_int_type ( ch1 );  \n   int2 =char_traits<char>:: to_int_type ( ch2 );  \n   int3 =char_traits<char>:: to_int_type ( ch3 );  \n  \n   cout << \"The char_types and corresponding int_types are:\"  \n        << \"\\n    ch1 = \" << ch1 << \" corresponding to int1 = \"   \n        << int1 << \".\"  \n        << \"\\n    ch2 = \" << ch2 << \" corresponding to int1 = \"   \n        << int2 << \".\"  \n        << \"\\n    ch3 = \" << ch3 << \" corresponding to int1 = \"   \n        << int3 << \".\" << endl << endl;  \n  \n   // Converting from int_type back to char_type  \n   char_traits<char>::char_type rec_ch1;  \n   rec_ch1 = char_traits<char>:: to_char_type ( int1);  \n   char_traits<char>::char_type rec_ch2;  \n   rec_ch2 = char_traits<char>:: to_char_type ( int2);  \n  \n   cout << \"The recovered char_types and corresponding int_types are:\"  \n        << \"\\n    recovered ch1 = \" << rec_ch1 << \" from int1 = \"   \n        << int1 << \".\"  \n        << \"\\n    recovered ch2 = \" << rec_ch2 << \" from int2 = \"   \n        << int2 << \".\" << endl << endl;  \n  \n   // Testing that the conversions are inverse operations  \n   bool b1 = char_traits<char>::eq ( rec_ch1 , ch1 );  \n   if ( b1 )  \n      cout << \"The recovered char_type of ch1\"  \n           << \" is equal to the original ch1.\" << endl;  \n   else  \n      cout << \"The recovered char_type of ch1\"  \n           << \" is not equal to the original ch1.\" << endl;  \n  \n   // An equivalent and alternatively test procedure  \n   if ( rec_ch2 == ch2 )  \n      cout << \"The recovered char_type of ch2\"  \n           << \" is equal to the original ch2.\" << endl;  \n   else  \n      cout << \"The recovered char_type of ch2\"  \n           << \" is not equal to the original ch2.\" << endl;  \n}  \n```  \n  \n```Output  \nThe char_types and corresponding int_types are:  \n    ch1 = a corresponding to int1 = 97.  \n    ch2 = b corresponding to int1 = 98.  \n    ch3 = a corresponding to int1 = 97.  \n  \nThe recovered char_types and corresponding int_types are:  \n    recovered ch1 = a from int1 = 97.  \n    recovered ch2 = b from int2 = 98.  \n  \nThe recovered char_type of ch1 is equal to the original ch1.  \nThe recovered char_type of ch2 is equal to the original ch2.  \n```  \n  \n##  <a name=\"char_traits__to_int_type\"></a>  char_traits::to_int_type  \n Converts a `char_type` character to the corresponding `int_type` character and returns the result.  \n  \n```  \nstatic int_type to_int_type(const char_type& _Ch);\n```  \n  \n### Parameters  \n `_Ch`  \n The `char_type` character to be represented as an `int_type`.  \n  \n### Return Value  \n The `int_type` character corresponding to the `char_type` character.  \n  \n### Remarks  \n The conversion operations `to_int_type` and [to_char_type](#char_traits__to_char_type) are inverse to each other, so that:  \n  \n `to_int_type` ( `to_char_type` ( *x* ) ) == *x*  \n  \n for any `int_type` *x*, and  \n  \n `to_char_type` ( `to_int_type` ( *x* ) ) == *x*  \n  \n for any `char_type` *x*.  \n  \n### Example  \n  \n```cpp  \n// char_traits_to_int_type.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   char_traits<char>::char_type ch1 = 'a';  \n   char_traits<char>::char_type ch2 = 'b';  \n   char_traits<char>::char_type ch3 = 'a';  \n  \n   // Converting from char_type to int_type  \n   char_traits<char>::int_type int1, int2 , int3;  \n   int1 =char_traits<char>:: to_int_type ( ch1 );  \n   int2 =char_traits<char>:: to_int_type ( ch2 );  \n   int3 =char_traits<char>:: to_int_type ( ch3 );  \n  \n   cout << \"The char_types and corresponding int_types are:\"  \n        << \"\\n    ch1 = \" << ch1 << \" corresponding to int1 = \"   \n        << int1 << \".\"  \n        << \"\\n    ch2 = \" << ch2 << \" corresponding to int1 = \"   \n        << int2 << \".\"  \n        << \"\\n    ch3 = \" << ch3 << \" corresponding to int1 = \"   \n        << int3 << \".\" << endl << endl;  \n  \n   // Converting from int_type back to char_type  \n   char_traits<char>::char_type rec_ch1;  \n   rec_ch1 = char_traits<char>:: to_char_type ( int1);  \n   char_traits<char>::char_type rec_ch2;  \n   rec_ch2 = char_traits<char>:: to_char_type ( int2);  \n  \n   cout << \"The recovered char_types and corresponding int_types are:\"  \n        << \"\\n    recovered ch1 = \" << rec_ch1 << \" from int1 = \"   \n        << int1 << \".\"  \n        << \"\\n    recovered ch2 = \" << rec_ch2 << \" from int2 = \"   \n        << int2 << \".\" << endl << endl;  \n  \n   // Testing that the conversions are inverse operations  \n   bool b1 = char_traits<char>::eq ( rec_ch1 , ch1 );  \n   if ( b1 )  \n      cout << \"The recovered char_type of ch1\"  \n           << \" is equal to the original ch1.\" << endl;  \n   else  \n      cout << \"The recovered char_type of ch1\"  \n           << \" is not equal to the original ch1.\" << endl;  \n  \n   // An equivalent and alternatively test procedure  \n   if ( rec_ch2 == ch2 )  \n      cout << \"The recovered char_type of ch2\"  \n           << \" is equal to the original ch2.\" << endl;  \n   else  \n      cout << \"The recovered char_type of ch2\"  \n           << \" is not equal to the original ch2.\" << endl;  \n}  \n```  \n  \n```Output  \nThe char_types and corresponding int_types are:  \n    ch1 = a corresponding to int1 = 97.  \n    ch2 = b corresponding to int1 = 98.  \n    ch3 = a corresponding to int1 = 97.  \n  \nThe recovered char_types and corresponding int_types are:  \n    recovered ch1 = a from int1 = 97.  \n    recovered ch2 = b from int2 = 98.  \n  \nThe recovered char_type of ch1 is equal to the original ch1.  \nThe recovered char_type of ch2 is equal to the original ch2.  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}