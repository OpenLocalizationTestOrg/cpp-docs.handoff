{"nodes":[{"pos":[12,64],"content":"Overview of x64 Calling Conventions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overview of x64 Calling Conventions | Microsoft Docs","pos":[0,52]}]},{"content":"Overview of x64 Calling Conventions","pos":[545,580]},{"content":"Two important differences between x86 and <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph> are the 64-bit addressing capability and a flat set of 16 64-bit registers for general use.","pos":[581,778],"source":"Two important differences between x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] are the 64-bit addressing capability and a flat set of 16 64-bit registers for general use."},{"content":"Given the expanded register set, <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph> uses the <bpt id=\"p1\">[</bpt>__fastcall<ept id=\"p1\">](../cpp/fastcall.md)</ept> calling convention and a RISC-based exception-handling model.","pos":[779,979],"source":" Given the expanded register set, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] uses the [__fastcall](../cpp/fastcall.md) calling convention and a RISC-based exception-handling model."},{"content":"The <ph id=\"ph1\">`__fastcall`</ph> convention uses registers for the first four arguments and the stack frame to pass additional arguments.","pos":[980,1101],"source":" The `__fastcall` convention uses registers for the first four arguments and the stack frame to pass additional arguments."},{"pos":[1108,1242],"content":"The following compiler option helps you optimize your application for <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph>:","source":"The following compiler option helps you optimize your application for [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]:"},{"content":"/favor (Optimize for Architecture Specifics)","pos":[1253,1297]},{"content":"Calling convention","pos":[1372,1390]},{"content":"The <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph> Application Binary Interface (ABI) uses a four register fast-call calling convention by default.","pos":[1394,1558],"source":"The [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] Application Binary Interface (ABI) uses a four register fast-call calling convention by default."},{"content":"Space is allocated on the call stack as a shadow store for callees to save those registers.","pos":[1559,1650]},{"content":"There is a strict one-to-one correspondence between the arguments to a function call and the registers used for those arguments.","pos":[1651,1779]},{"content":"Any argument that doesn’t fit in 8 bytes, or is not 1, 2, 4, or 8 bytes, must be passed by reference.","pos":[1780,1881]},{"content":"There is no attempt to spread a single argument across multiple registers.","pos":[1882,1956]},{"content":"The x87 register stack is unused.","pos":[1957,1990]},{"content":"It may be used by the callee, but must be considered volatile across function calls.","pos":[1991,2075]},{"content":"All floating point operations are done using the 16 XMM registers.","pos":[2076,2142]},{"content":"Integer arguments are passed in registers RCX, RDX, R8, and R9.","pos":[2143,2206]},{"content":"Floating point arguments are passed in XMM0L, XMM1L, XMM2L, and XMM3L.","pos":[2207,2277]},{"content":"16-byte arguments are passed by reference.","pos":[2278,2320]},{"content":"Parameter passing is described in detail in <bpt id=\"p1\">[</bpt>Parameter Passing<ept id=\"p1\">](../build/parameter-passing.md)</ept>.","pos":[2321,2416],"source":" Parameter passing is described in detail in [Parameter Passing](../build/parameter-passing.md)."},{"content":"In addition to these registers, RAX, R10, R11, XMM4, and XMM5 are considered volatile.","pos":[2417,2503]},{"content":"All other registers are non-volatile.","pos":[2504,2541]},{"content":"Register usage is documented in detail in <bpt id=\"p1\">[</bpt>Register Usage<ept id=\"p1\">](../build/register-usage.md)</ept> and <bpt id=\"p2\">[</bpt>Caller/Callee Saved Registers<ept id=\"p2\">](../build/caller-callee-saved-registers.md)</ept>.","pos":[2542,2708],"source":" Register usage is documented in detail in [Register Usage](../build/register-usage.md) and [Caller/Callee Saved Registers](../build/caller-callee-saved-registers.md)."},{"content":"The caller is responsible for allocating space for parameters to the callee, and must always allocate sufficient space to store four register parameters, even if the callee doesn’t take that many parameters.","pos":[2715,2922]},{"content":"This simplifies support for unprototyped C-language functions, and vararg C/C++ functions.","pos":[2923,3013]},{"content":"For vararg or unprototyped functions, any floating point values must be duplicated in the corresponding general-purpose register.","pos":[3014,3143]},{"content":"Any parameters beyond the first four must be stored on the stack, above the shadow store for the first four, prior to the call.","pos":[3144,3271]},{"content":"Vararg function details can be found in <bpt id=\"p1\">[</bpt>Varargs<ept id=\"p1\">](../build/varargs.md)</ept>.","pos":[3272,3343],"source":" Vararg function details can be found in [Varargs](../build/varargs.md)."},{"content":"Unprototyped function information is detailed in <bpt id=\"p1\">[</bpt>Unprototyped Functions<ept id=\"p1\">](../build/unprototyped-functions.md)</ept>.","pos":[3344,3454],"source":" Unprototyped function information is detailed in [Unprototyped Functions](../build/unprototyped-functions.md)."},{"content":"Alignment","pos":[3463,3472]},{"content":"Most structures are aligned to their natural alignment.","pos":[3476,3531]},{"content":"The primary exceptions are the stack pointer and <ph id=\"ph1\">`malloc`</ph> or <ph id=\"ph2\">`alloca`</ph> memory, which are aligned to 16 bytes in order to aid performance.","pos":[3532,3668],"source":" The primary exceptions are the stack pointer and `malloc` or `alloca` memory, which are aligned to 16 bytes in order to aid performance."},{"content":"Alignment above 16 bytes must be done manually, but since 16 bytes is a common alignment size for XMM operations, this should work for most code.","pos":[3669,3814]},{"content":"For more information about structure layout and alignment see <bpt id=\"p1\">[</bpt>Types and Storage<ept id=\"p1\">](../build/types-and-storage.md)</ept>.","pos":[3815,3928],"source":" For more information about structure layout and alignment see [Types and Storage](../build/types-and-storage.md)."},{"content":"For information about the stack layout, see <bpt id=\"p1\">[</bpt>Stack Usage<ept id=\"p1\">](../build/stack-usage.md)</ept>.","pos":[3929,4012],"source":" For information about the stack layout, see [Stack Usage](../build/stack-usage.md)."},{"content":"Unwindability","pos":[4021,4034]},{"content":"Leaf functions are functions that do not change any non-volatile registers.","pos":[4038,4113]},{"content":"A non-leaf function may change non-volatile RSP, for example, by calling a function or allocating additional stack space for local variables.","pos":[4114,4255]},{"content":"In order to recover non-volatile registers when an exception is handled, non-leaf functions must be annotated with static data that describes how to properly unwind the function at an arbitrary instruction.","pos":[4256,4462]},{"content":"This data is stored as <bpt id=\"p1\">*</bpt>pdata<ept id=\"p1\">*</ept>, or procedure data, which in turn refers to <bpt id=\"p2\">*</bpt>xdata<ept id=\"p2\">*</ept>, the exception handling data.","pos":[4463,4575],"source":" This data is stored as *pdata*, or procedure data, which in turn refers to *xdata*, the exception handling data."},{"content":"The xdata contains the unwinding information, and can point to additional pdata or an exception handler function.","pos":[4576,4689]},{"content":"Prologs and epilogs are highly restricted so that they can be properly described in xdata.","pos":[4690,4780]},{"content":"The stack pointer must be aligned to 16 bytes in any region of code that isn’t part of an epilog or prolog, except within leaf functions.","pos":[4781,4918]},{"content":"Leaf functions can be unwound simply by simulating a return, so pdata and xdata are not required.","pos":[4919,5016]},{"content":"For details about the proper structure of function prologs and epilogs, see <bpt id=\"p1\">[</bpt>Prolog and Epilog<ept id=\"p1\">](../build/prolog-and-epilog.md)</ept>.","pos":[5017,5144],"source":" For details about the proper structure of function prologs and epilogs, see [Prolog and Epilog](../build/prolog-and-epilog.md)."},{"content":"For more information about exception handling, and the exception handling and unwinding of pdata and xdata, see <bpt id=\"p1\">[</bpt>Exception Handling (x64)<ept id=\"p1\">](../build/exception-handling-x64.md)</ept>.","pos":[5145,5320],"source":" For more information about exception handling, and the exception handling and unwinding of pdata and xdata, see [Exception Handling (x64)](../build/exception-handling-x64.md)."},{"content":"See Also","pos":[5329,5337]},{"content":"x64 Software Conventions","pos":[5342,5366]}],"content":"---\ntitle: \"Overview of x64 Calling Conventions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: a05db5eb-0844-4d9d-8b92-b1b2434be0ea\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overview of x64 Calling Conventions\nTwo important differences between x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] are the 64-bit addressing capability and a flat set of 16 64-bit registers for general use. Given the expanded register set, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] uses the [__fastcall](../cpp/fastcall.md) calling convention and a RISC-based exception-handling model. The `__fastcall` convention uses registers for the first four arguments and the stack frame to pass additional arguments.  \n  \n The following compiler option helps you optimize your application for [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]:  \n  \n-   [/favor (Optimize for Architecture Specifics)](../build/reference/favor-optimize-for-architecture-specifics.md)  \n  \n## Calling convention  \n The [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] Application Binary Interface (ABI) uses a four register fast-call calling convention by default. Space is allocated on the call stack as a shadow store for callees to save those registers. There is a strict one-to-one correspondence between the arguments to a function call and the registers used for those arguments. Any argument that doesn’t fit in 8 bytes, or is not 1, 2, 4, or 8 bytes, must be passed by reference. There is no attempt to spread a single argument across multiple registers. The x87 register stack is unused. It may be used by the callee, but must be considered volatile across function calls. All floating point operations are done using the 16 XMM registers. Integer arguments are passed in registers RCX, RDX, R8, and R9. Floating point arguments are passed in XMM0L, XMM1L, XMM2L, and XMM3L. 16-byte arguments are passed by reference. Parameter passing is described in detail in [Parameter Passing](../build/parameter-passing.md). In addition to these registers, RAX, R10, R11, XMM4, and XMM5 are considered volatile. All other registers are non-volatile. Register usage is documented in detail in [Register Usage](../build/register-usage.md) and [Caller/Callee Saved Registers](../build/caller-callee-saved-registers.md).  \n  \n The caller is responsible for allocating space for parameters to the callee, and must always allocate sufficient space to store four register parameters, even if the callee doesn’t take that many parameters. This simplifies support for unprototyped C-language functions, and vararg C/C++ functions. For vararg or unprototyped functions, any floating point values must be duplicated in the corresponding general-purpose register. Any parameters beyond the first four must be stored on the stack, above the shadow store for the first four, prior to the call. Vararg function details can be found in [Varargs](../build/varargs.md). Unprototyped function information is detailed in [Unprototyped Functions](../build/unprototyped-functions.md).  \n  \n## Alignment  \n Most structures are aligned to their natural alignment. The primary exceptions are the stack pointer and `malloc` or `alloca` memory, which are aligned to 16 bytes in order to aid performance. Alignment above 16 bytes must be done manually, but since 16 bytes is a common alignment size for XMM operations, this should work for most code. For more information about structure layout and alignment see [Types and Storage](../build/types-and-storage.md). For information about the stack layout, see [Stack Usage](../build/stack-usage.md).  \n  \n## Unwindability  \n Leaf functions are functions that do not change any non-volatile registers. A non-leaf function may change non-volatile RSP, for example, by calling a function or allocating additional stack space for local variables. In order to recover non-volatile registers when an exception is handled, non-leaf functions must be annotated with static data that describes how to properly unwind the function at an arbitrary instruction. This data is stored as *pdata*, or procedure data, which in turn refers to *xdata*, the exception handling data. The xdata contains the unwinding information, and can point to additional pdata or an exception handler function. Prologs and epilogs are highly restricted so that they can be properly described in xdata. The stack pointer must be aligned to 16 bytes in any region of code that isn’t part of an epilog or prolog, except within leaf functions. Leaf functions can be unwound simply by simulating a return, so pdata and xdata are not required. For details about the proper structure of function prologs and epilogs, see [Prolog and Epilog](../build/prolog-and-epilog.md). For more information about exception handling, and the exception handling and unwinding of pdata and xdata, see [Exception Handling (x64)](../build/exception-handling-x64.md).  \n  \n## See Also  \n [x64 Software Conventions](../build/x64-software-conventions.md)"}