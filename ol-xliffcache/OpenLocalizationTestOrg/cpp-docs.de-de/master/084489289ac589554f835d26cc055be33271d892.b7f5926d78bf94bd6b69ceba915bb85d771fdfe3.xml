{"nodes":[{"pos":[12,68],"content":"Transporting Exceptions Between Threads | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Transporting Exceptions Between Threads | Microsoft Docs","pos":[0,56]}]},{"content":"Transporting Exceptions Between Threads","pos":[907,946]},{"content":"Visual C++ supports <bpt id=\"p1\">*</bpt>transporting an exception<ept id=\"p1\">*</ept> from one thread to another.","pos":[947,1022],"source":"Visual C++ supports *transporting an exception* from one thread to another."},{"content":"Transporting exceptions enables you to catch an exception in one thread and then make the exception appear to be thrown in a different thread.","pos":[1023,1165]},{"content":"For example, you can use this feature to write a multithreaded application where the primary thread handles all the exceptions thrown by its secondary threads.","pos":[1166,1325]},{"content":"Transporting exceptions is useful mostly to developers who create parallel programming libraries or systems.","pos":[1326,1434]},{"content":"To implement transporting exceptions, Visual C++ provides the <bpt id=\"p1\">[</bpt>exception_ptr<ept id=\"p1\">](../standard-library/exception-typedefs.md#exception_ptr)</ept> type and the <bpt id=\"p2\">[</bpt>current_exception<ept id=\"p2\">](../standard-library/exception-typedefs.md#current_exception)</ept>, <bpt id=\"p3\">[</bpt>rethrow_exception<ept id=\"p3\">](../standard-library/exception-functions.md#rethrow_exception)</ept>, and <bpt id=\"p4\">[</bpt>make_exception_ptr<ept id=\"p4\">](../standard-library/exception-functions.md#make_exception_ptr)</ept> functions.","pos":[1435,1846],"source":" To implement transporting exceptions, Visual C++ provides the [exception_ptr](../standard-library/exception-typedefs.md#exception_ptr) type and the [current_exception](../standard-library/exception-typedefs.md#current_exception), [rethrow_exception](../standard-library/exception-functions.md#rethrow_exception), and [make_exception_ptr](../standard-library/exception-functions.md#make_exception_ptr) functions."},{"content":"Syntax","pos":[1855,1861]},{"content":"Parameters","pos":[2120,2130]},{"content":"Parameter","pos":[2137,2146]},{"content":"Description","pos":[2147,2158]},{"pos":[2215,2296],"content":"An unspecified internal class that is used to implement the <ph id=\"ph1\">`exception_ptr`</ph> type.","source":"An unspecified internal class that is used to implement the `exception_ptr` type."},{"pos":[2305,2360],"content":"An <ph id=\"ph1\">`exception_ptr`</ph> object that references an exception.","source":"An `exception_ptr` object that references an exception."},{"content":"A class that represents an exception.","pos":[2369,2406]},{"pos":[2415,2454],"content":"An instance of the parameter <ph id=\"ph1\">`E`</ph> class.","source":"An instance of the parameter `E` class."},{"content":"Return Value","pos":[2464,2476]},{"content":"The <ph id=\"ph1\">`current_exception`</ph> function returns an <ph id=\"ph2\">`exception_ptr`</ph> object that references the exception that is currently in progress.","pos":[2480,2607],"source":"The `current_exception` function returns an `exception_ptr` object that references the exception that is currently in progress."},{"content":"If no exception is in progress, the function returns an <ph id=\"ph1\">`exception_ptr`</ph> object that is not associated with any exception.","pos":[2608,2729],"source":" If no exception is in progress, the function returns an `exception_ptr` object that is not associated with any exception."},{"pos":[2736,2865],"content":"The <ph id=\"ph1\">`make_exception_ptr`</ph> function returns an <ph id=\"ph2\">`exception_ptr`</ph> object that references the exception specified by the <ph id=\"ph3\">`e`</ph> parameter.","source":"The `make_exception_ptr` function returns an `exception_ptr` object that references the exception specified by the `e` parameter."},{"content":"Remarks","pos":[2874,2881]},{"content":"Scenario","pos":[2890,2898]},{"content":"Imagine that you want to create an application that can scale to handle a variable amount of work.","pos":[2902,3000]},{"content":"To achieve this objective, you design a multithreaded application where an initial, primary thread creates as many secondary threads as it needs in order to do the job.","pos":[3001,3169]},{"content":"The secondary threads help the primary thread to manage resources, to balance loads, and to improve throughput.","pos":[3170,3281]},{"content":"By distributing the work, the multithreaded application performs better than a single-threaded application.","pos":[3282,3389]},{"content":"However, if a secondary thread throws an exception, you want the primary thread to handle it.","pos":[3396,3489]},{"content":"This is because you want your application to handle exceptions in a consistent, unified manner regardless of the number of secondary threads.","pos":[3490,3631]},{"content":"Solution","pos":[3640,3648]},{"content":"To handle the previous scenario, the C++ Standard supports transporting an exception between threads.","pos":[3652,3753]},{"content":"If a secondary thread throws an exception, that exception becomes the <bpt id=\"p1\">*</bpt>current exception<ept id=\"p1\">*</ept>.","pos":[3754,3844],"source":" If a secondary thread throws an exception, that exception becomes the *current exception*."},{"content":"By analogy to the real world, the current exception is said to be <bpt id=\"p1\">*</bpt>in flight<ept id=\"p1\">*</ept>.","pos":[3845,3923],"source":" By analogy to the real world, the current exception is said to be *in flight*."},{"content":"The current exception is in flight from the time it is thrown until the exception handler that catches it returns.","pos":[3924,4038]},{"content":"The secondary thread can catch the current exception in a <ph id=\"ph1\">`catch`</ph> block, and then call the <ph id=\"ph2\">`current_exception`</ph> function to store the exception in an <ph id=\"ph3\">`exception_ptr`</ph> object.","pos":[4045,4217],"source":"The secondary thread can catch the current exception in a `catch` block, and then call the `current_exception` function to store the exception in an `exception_ptr` object."},{"content":"The <ph id=\"ph1\">`exception_ptr`</ph> object must be available to the secondary thread and to the primary thread.","pos":[4218,4313],"source":" The `exception_ptr` object must be available to the secondary thread and to the primary thread."},{"content":"For example, the <ph id=\"ph1\">`exception_ptr`</ph> object can be a global variable whose access is controlled by a mutex.","pos":[4314,4417],"source":" For example, the `exception_ptr` object can be a global variable whose access is controlled by a mutex."},{"content":"The term <bpt id=\"p1\">*</bpt>transport an exception<ept id=\"p1\">*</ept> means an exception in one thread can be converted to a form that can be accessed by another thread.","pos":[4418,4551],"source":" The term *transport an exception* means an exception in one thread can be converted to a form that can be accessed by another thread."},{"content":"Next, the primary thread calls the <ph id=\"ph1\">`rethrow_exception`</ph> function, which extracts and then throws the exception from the <ph id=\"ph2\">`exception_ptr`</ph> object.","pos":[4558,4700],"source":"Next, the primary thread calls the `rethrow_exception` function, which extracts and then throws the exception from the `exception_ptr` object."},{"content":"When the exception is thrown, it becomes the current exception in the primary thread.","pos":[4701,4786]},{"content":"That is, the exception appears to originate in the primary thread.","pos":[4787,4853]},{"content":"Finally, the primary thread can catch the current exception in a <ph id=\"ph1\">`catch`</ph> block and then process it or throw it to a higher level exception handler.","pos":[4860,5007],"source":"Finally, the primary thread can catch the current exception in a `catch` block and then process it or throw it to a higher level exception handler."},{"content":"Or, the primary thread can ignore the exception and allow the process to end.","pos":[5008,5085]},{"content":"Most applications do not have to transport exceptions between threads.","pos":[5092,5162]},{"content":"However, this feature is useful in a parallel computing system because the system can divide work among secondary threads, processors, or cores.","pos":[5163,5307]},{"content":"In a parallel computing environment, a single, dedicated thread can handle all the exceptions from the secondary threads and can present a consistent exception-handling model to any application.","pos":[5308,5502]},{"content":"For more information about the C++ Standards committee proposal, search the Internet for document number N2179, titled \"Language Support for Transporting Exceptions between Threads\".","pos":[5509,5691]},{"content":"Exception-Handling Models and Compiler Options","pos":[5700,5746]},{"content":"Your application's exception-handling model determines whether it can catch and transport an exception.","pos":[5750,5853]},{"content":"Visual C++ supports three models that can handle C++ exceptions, structured exception handling (SEH) exceptions, and common language runtime (CLR) exceptions.","pos":[5854,6012]},{"content":"Use the <bpt id=\"p1\">[</bpt>/EH<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept> and <bpt id=\"p2\">[</bpt>/clr<ept id=\"p2\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler options to specify your application's exception-handling model.","pos":[6013,6224],"source":" Use the [/EH](../build/reference/eh-exception-handling-model.md) and [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler options to specify your application's exception-handling model."},{"content":"Only the following combination of compiler options and programming statements can transport an exception.","pos":[6231,6336]},{"content":"Other combinations either cannot catch exceptions, or can catch but cannot transport exceptions.","pos":[6337,6433]},{"pos":[6443,6535],"content":"The <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> compiler option and the <ph id=\"ph1\">`catch`</ph> statement can transport SEH and C++ exceptions.","source":"The **/EHa** compiler option and the `catch` statement can transport SEH and C++ exceptions."},{"pos":[6545,6655],"content":"The <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/EHs<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>/EHsc<ept id=\"p3\">**</ept> compiler options and the <ph id=\"ph1\">`catch`</ph> statement can transport C++ exceptions.","source":"The **/EHa**, **/EHs**, and **/EHsc** compiler options and the `catch` statement can transport C++ exceptions."},{"content":"The <bpt id=\"p1\">**</bpt>/CLR<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/CLR:pure<ept id=\"p2\">**</ept> compiler option and the <ph id=\"ph1\">`catch`</ph> statement can transport C++ exceptions.","pos":[6665,6766],"source":"The **/CLR** or **/CLR:pure** compiler option and the `catch` statement can transport C++ exceptions."},{"content":"The <bpt id=\"p1\">**</bpt>/CLR<ept id=\"p1\">**</ept> compiler options imply specification of the <bpt id=\"p2\">**</bpt>/EHa<ept id=\"p2\">**</ept> option.","pos":[6767,6840],"source":" The **/CLR** compiler options imply specification of the **/EHa** option."},{"content":"Note that the compiler does not support transporting managed exceptions.","pos":[6841,6913]},{"content":"This is because managed exceptions, which are derived from the <bpt id=\"p1\">[</bpt>System.Exception class<ept id=\"p1\">](../standard-library/exception-class.md)</ept>, are already objects that you can move between threads by using the facilities of the common languange runtime.","pos":[6914,7153],"source":" This is because managed exceptions, which are derived from the [System.Exception class](../standard-library/exception-class.md), are already objects that you can move between threads by using the facilities of the common languange runtime."},{"pos":[7165,7794],"content":"[!IMPORTANT]\n We recommend that you specify the **/EHsc** compiler option and catch only C++ exceptions. You expose yourself to a security threat if you use the **/EHa** or **/CLR** compiler option and a **catch** statement with an ellipsis *exception-declaration* (`catch(...)`). You probably intend to use the `catch` statement to capture a few specific exceptions. However, the `catch(...)` statement captures all C++ and SEH exceptions, including unexpected ones that should be fatal. If you ignore or mishandle an unexpected exception, malicious code can use that opportunity to undermine the security of your program.","leadings":["","    > "],"nodes":[{"content":" We recommend that you specify the **/EHsc** compiler option and catch only C++ exceptions. You expose yourself to a security threat if you use the **/EHa** or **/CLR** compiler option and a **catch** statement with an ellipsis *exception-declaration* (`catch(...)`). You probably intend to use the `catch` statement to capture a few specific exceptions. However, the `catch(...)` statement captures all C++ and SEH exceptions, including unexpected ones that should be fatal. If you ignore or mishandle an unexpected exception, malicious code can use that opportunity to undermine the security of your program.","pos":[13,623],"nodes":[{"content":"We recommend that you specify the <bpt id=\"p1\">**</bpt>/EHsc<ept id=\"p1\">**</ept> compiler option and catch only C++ exceptions.","pos":[1,91],"source":" We recommend that you specify the **/EHsc** compiler option and catch only C++ exceptions."},{"content":"You expose yourself to a security threat if you use the <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/CLR<ept id=\"p2\">**</ept> compiler option and a <bpt id=\"p3\">**</bpt>catch<ept id=\"p3\">**</ept> statement with an ellipsis <bpt id=\"p4\">*</bpt>exception-declaration<ept id=\"p4\">*</ept> (<ph id=\"ph1\">`catch(...)`</ph>).","pos":[92,267],"source":" You expose yourself to a security threat if you use the **/EHa** or **/CLR** compiler option and a **catch** statement with an ellipsis *exception-declaration* (`catch(...)`)."},{"content":"You probably intend to use the <ph id=\"ph1\">`catch`</ph> statement to capture a few specific exceptions.","pos":[268,354],"source":" You probably intend to use the `catch` statement to capture a few specific exceptions."},{"content":"However, the <ph id=\"ph1\">`catch(...)`</ph> statement captures all C++ and SEH exceptions, including unexpected ones that should be fatal.","pos":[355,475],"source":" However, the `catch(...)` statement captures all C++ and SEH exceptions, including unexpected ones that should be fatal."},{"content":"If you ignore or mishandle an unexpected exception, malicious code can use that opportunity to undermine the security of your program.","pos":[476,610]}]}]},{"content":"Usage","pos":[7803,7808]},{"pos":[7812,7992],"content":"The following sections describe how to transport exceptions by using the <ph id=\"ph1\">`exception_ptr`</ph> type, and the <ph id=\"ph2\">`current_exception`</ph>, <ph id=\"ph3\">`rethrow_exception`</ph>, and <ph id=\"ph4\">`make_exception_ptr`</ph> functions.","source":"The following sections describe how to transport exceptions by using the `exception_ptr` type, and the `current_exception`, `rethrow_exception`, and `make_exception_ptr` functions."},{"content":"exception_ptr Type","pos":[8002,8020]},{"content":"Use an <ph id=\"ph1\">`exception_ptr`</ph> object to reference the current exception or an instance of a user-specified exception.","pos":[8024,8134],"source":"Use an `exception_ptr` object to reference the current exception or an instance of a user-specified exception."},{"content":"In the Microsoft implementation, an exception is represented by an <bpt id=\"p1\">[</bpt>EXCEPTION_RECORD<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa363082)</ept> structure.","pos":[8135,8291],"source":" In the Microsoft implementation, an exception is represented by an [EXCEPTION_RECORD](http://msdn.microsoft.com/library/windows/desktop/aa363082) structure."},{"content":"Each <ph id=\"ph1\">`exception_ptr`</ph> object includes an exception reference field that points to a copy of the <ph id=\"ph2\">`EXCEPTION_RECORD`</ph> structure that represents the exception.","pos":[8292,8446],"source":" Each `exception_ptr` object includes an exception reference field that points to a copy of the `EXCEPTION_RECORD` structure that represents the exception."},{"content":"When you declare an <ph id=\"ph1\">`exception_ptr`</ph> variable, the variable is not associated with any exception.","pos":[8453,8549],"source":"When you declare an `exception_ptr` variable, the variable is not associated with any exception."},{"content":"That is, its exception reference field is NULL.","pos":[8550,8597]},{"content":"Such an <ph id=\"ph1\">`exception_ptr`</ph> object is called a <bpt id=\"p1\">*</bpt>null exception_ptr<ept id=\"p1\">*</ept>.","pos":[8598,8662],"source":" Such an `exception_ptr` object is called a *null exception_ptr*."},{"content":"Use the <ph id=\"ph1\">`current_exception`</ph> or <ph id=\"ph2\">`make_exception_ptr`</ph> function to assign an exception to an <ph id=\"ph3\">`exception_ptr`</ph> object.","pos":[8669,8782],"source":"Use the `current_exception` or `make_exception_ptr` function to assign an exception to an `exception_ptr` object."},{"content":"When you assign an exception to an <ph id=\"ph1\">`exception_ptr`</ph> variable, the variable's exception reference field points to a copy of the exception.","pos":[8783,8919],"source":" When you assign an exception to an `exception_ptr` variable, the variable's exception reference field points to a copy of the exception."},{"content":"If there is insufficient memory to copy the exception, the exception reference field points to a copy of a <bpt id=\"p1\">[</bpt>std::bad_alloc<ept id=\"p1\">](../standard-library/bad-alloc-class.md)</ept> exception.","pos":[8920,9094],"source":" If there is insufficient memory to copy the exception, the exception reference field points to a copy of a [std::bad_alloc](../standard-library/bad-alloc-class.md) exception."},{"content":"If the <ph id=\"ph1\">`current_exception`</ph> or <ph id=\"ph2\">`make_exception_ptr`</ph> function cannot copy the exception for any other reason, the function calls the <bpt id=\"p1\">[</bpt>terminate<ept id=\"p1\">](../c-runtime-library/reference/terminate-crt.md)</ept> function to exit the current process.","pos":[9095,9324],"source":" If the `current_exception` or `make_exception_ptr` function cannot copy the exception for any other reason, the function calls the [terminate](../c-runtime-library/reference/terminate-crt.md) function to exit the current process."},{"content":"Despite its name, an <ph id=\"ph1\">`exception_ptr`</ph> object is not itself a pointer.","pos":[9331,9399],"source":"Despite its name, an `exception_ptr` object is not itself a pointer."},{"content":"It does not obey pointer semantics and cannot be used with the pointer member access (<ph id=\"ph1\">`-&gt;`</ph>) or indirection (*) operators.","pos":[9400,9521],"source":" It does not obey pointer semantics and cannot be used with the pointer member access (`->`) or indirection (*) operators."},{"content":"The <ph id=\"ph1\">`exception_ptr`</ph> object has no public data members or member functions.","pos":[9522,9596],"source":" The `exception_ptr` object has no public data members or member functions."},{"content":"Comparisons:","pos":[9605,9617]},{"content":"You can use the equal (<ph id=\"ph1\">`==`</ph>) and not-equal (<ph id=\"ph2\">`!=`</ph>) operators to compare two <ph id=\"ph3\">`exception_ptr`</ph> objects.","pos":[9626,9725],"source":"You can use the equal (`==`) and not-equal (`!=`) operators to compare two `exception_ptr` objects."},{"content":"The operators do not compare the binary value (bit pattern) of the <ph id=\"ph1\">`EXCEPTION_RECORD`</ph> structures that represent the exceptions.","pos":[9726,9853],"source":" The operators do not compare the binary value (bit pattern) of the `EXCEPTION_RECORD` structures that represent the exceptions."},{"content":"Instead, the operators compare the addresses in the exception reference field of the <ph id=\"ph1\">`exception_ptr`</ph> objects.","pos":[9854,9963],"source":" Instead, the operators compare the addresses in the exception reference field of the `exception_ptr` objects."},{"content":"Consequently, a null <ph id=\"ph1\">`exception_ptr`</ph> and the NULL value compare as equal.","pos":[9964,10037],"source":" Consequently, a null `exception_ptr` and the NULL value compare as equal."},{"content":"current_exception Function","pos":[10047,10073]},{"content":"Call the <ph id=\"ph1\">`current_exception`</ph> function in a <ph id=\"ph2\">`catch`</ph> block.","pos":[10077,10134],"source":"Call the `current_exception` function in a `catch` block."},{"content":"If an exception is in flight and the <ph id=\"ph1\">`catch`</ph> block can catch the exception, the <ph id=\"ph2\">`current_exception`</ph> function returns an <ph id=\"ph3\">`exception_ptr`</ph> object that references the exception.","pos":[10135,10308],"source":" If an exception is in flight and the `catch` block can catch the exception, the `current_exception` function returns an `exception_ptr` object that references the exception."},{"content":"Otherwise, the function returns a null <ph id=\"ph1\">`exception_ptr`</ph> object.","pos":[10309,10371],"source":" Otherwise, the function returns a null `exception_ptr` object."},{"content":"Details:","pos":[10380,10388]},{"pos":[10397,10608],"content":"The <ph id=\"ph1\">`current_exception`</ph> function captures the exception that is in flight regardless of whether the <ph id=\"ph2\">`catch`</ph> statement specifies an <bpt id=\"p1\">[</bpt>exception-declaration<ept id=\"p1\">](../cpp/try-throw-and-catch-statements-cpp.md)</ept> statement.","source":"The `current_exception` function captures the exception that is in flight regardless of whether the `catch` statement specifies an [exception-declaration](../cpp/try-throw-and-catch-statements-cpp.md) statement."},{"content":"The destructor for the current exception is called at the end of the <ph id=\"ph1\">`catch`</ph> block if you do not rethrow the exception.","pos":[10615,10734],"source":"The destructor for the current exception is called at the end of the `catch` block if you do not rethrow the exception."},{"content":"However, even if you call the <ph id=\"ph1\">`current_exception`</ph> function in the destructor, the function returns an <ph id=\"ph2\">`exception_ptr`</ph> object that references the current exception.","pos":[10735,10898],"source":" However, even if you call the `current_exception` function in the destructor, the function returns an `exception_ptr` object that references the current exception."},{"content":"Successive calls to the <ph id=\"ph1\">`current_exception`</ph> function return <ph id=\"ph2\">`exception_ptr`</ph> objects that refer to different copies of the current exception.","pos":[10905,11045],"source":"Successive calls to the `current_exception` function return `exception_ptr` objects that refer to different copies of the current exception."},{"content":"Consequently, the objects compare as unequal because they refer to different copies, even though the copies have the same binary value.","pos":[11046,11181]},{"content":"SEH Exceptions:","pos":[11190,11205]},{"content":"If you use the <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> compiler option, you can catch an SEH exception in a C++ <ph id=\"ph1\">`catch`</ph> block.","pos":[11214,11309],"source":"If you use the **/EHa** compiler option, you can catch an SEH exception in a C++ `catch` block."},{"content":"The <ph id=\"ph1\">`current_exception`</ph> function returns an <ph id=\"ph2\">`exception_ptr`</ph> object that references the SEH exception.","pos":[11310,11411],"source":" The `current_exception` function returns an `exception_ptr` object that references the SEH exception."},{"content":"And the <ph id=\"ph1\">`rethrow_exception`</ph> function throws the SEH exception if you call it with thetransported <ph id=\"ph2\">`exception_ptr`</ph> object as its argument.","pos":[11412,11548],"source":" And the `rethrow_exception` function throws the SEH exception if you call it with thetransported `exception_ptr` object as its argument."},{"pos":[11555,11746],"content":"The <ph id=\"ph1\">`current_exception`</ph> function returns a null <ph id=\"ph2\">`exception_ptr`</ph> if you call it in an SEH <ph id=\"ph3\">`__finally`</ph> termination handler, an <ph id=\"ph4\">`__except`</ph> exception handler, or the <ph id=\"ph5\">`__except`</ph> filter expression.","source":"The `current_exception` function returns a null `exception_ptr` if you call it in an SEH `__finally` termination handler, an `__except` exception handler, or the `__except` filter expression."},{"content":"A transported exception does not support nested exceptions.","pos":[11753,11812]},{"content":"A nested exception occurs if another exception is thrown while an exception is being handled.","pos":[11813,11906]},{"content":"If you catch a nested exception, the <ph id=\"ph1\">`EXCEPTION_RECORD.ExceptionRecord`</ph> data member points to a chain of <ph id=\"ph2\">`EXCEPTION_RECORD`</ph> structures that describe the associated exceptions.","pos":[11907,12082],"source":" If you catch a nested exception, the `EXCEPTION_RECORD.ExceptionRecord` data member points to a chain of `EXCEPTION_RECORD` structures that describe the associated exceptions."},{"content":"The <ph id=\"ph1\">`current_exception`</ph> function does not support nested exceptions because it returns an <ph id=\"ph2\">`exception_ptr`</ph> object whose <ph id=\"ph3\">`ExceptionRecord`</ph> data member is zeroed out.","pos":[12083,12246],"source":" The `current_exception` function does not support nested exceptions because it returns an `exception_ptr` object whose `ExceptionRecord` data member is zeroed out."},{"content":"If you catch an SEH exception, you must manage the memory referenced by any pointer in the <ph id=\"ph1\">`EXCEPTION_RECORD.ExceptionInformation`</ph> data member array.","pos":[12253,12402],"source":"If you catch an SEH exception, you must manage the memory referenced by any pointer in the `EXCEPTION_RECORD.ExceptionInformation` data member array."},{"content":"You must guarantee that the memory is valid during the lifetime of the corresponding <ph id=\"ph1\">`exception_ptr`</ph> object, and that the memory is freed when the <ph id=\"ph2\">`exception_ptr`</ph> object is deleted.","pos":[12403,12584],"source":" You must guarantee that the memory is valid during the lifetime of the corresponding `exception_ptr` object, and that the memory is freed when the `exception_ptr` object is deleted."},{"content":"You can use structured exception (SE) translator functions together with the transport exceptions feature.","pos":[12591,12697]},{"content":"If an SEH exception is translated to a C++ exception, the <ph id=\"ph1\">`current_exception`</ph> function returns an <ph id=\"ph2\">`exception_ptr`</ph> that references the translated exception instead of the original SEH exception.","pos":[12698,12891],"source":" If an SEH exception is translated to a C++ exception, the `current_exception` function returns an `exception_ptr` that references the translated exception instead of the original SEH exception."},{"content":"The <ph id=\"ph1\">`rethrow_exception`</ph> function subsequently throws the translated exception, not the original exception.","pos":[12892,12998],"source":" The `rethrow_exception` function subsequently throws the translated exception, not the original exception."},{"content":"For more information about SE translator functions, see <bpt id=\"p1\">[</bpt>_set_se_translator<ept id=\"p1\">](../c-runtime-library/reference/set-se-translator.md)</ept>.","pos":[12999,13129],"source":" For more information about SE translator functions, see [_set_se_translator](../c-runtime-library/reference/set-se-translator.md)."},{"content":"rethrow_exception Function","pos":[13139,13165]},{"content":"After you store a caught exception in an <ph id=\"ph1\">`exception_ptr`</ph> object, the primary thread can process the object.","pos":[13169,13276],"source":"After you store a caught exception in an `exception_ptr` object, the primary thread can process the object."},{"content":"In your primary thread, call the <ph id=\"ph1\">`rethrow_exception`</ph> function together with the <ph id=\"ph2\">`exception_ptr`</ph> object as its argument.","pos":[13277,13396],"source":" In your primary thread, call the `rethrow_exception` function together with the `exception_ptr` object as its argument."},{"content":"The <ph id=\"ph1\">`rethrow_exception`</ph> function extracts the exception from the <ph id=\"ph2\">`exception_ptr`</ph> object and then throws the exception in the context of the primary thread.","pos":[13397,13552],"source":" The `rethrow_exception` function extracts the exception from the `exception_ptr` object and then throws the exception in the context of the primary thread."},{"content":"If the <ph id=\"ph1\">`p`</ph> parameter of the <ph id=\"ph2\">`rethrow_exception`</ph> function is a null <ph id=\"ph3\">`exception_ptr`</ph>, the function throws <bpt id=\"p1\">[</bpt>std::bad_exception<ept id=\"p1\">](../standard-library/bad-exception-class.md)</ept>.","pos":[13553,13722],"source":" If the `p` parameter of the `rethrow_exception` function is a null `exception_ptr`, the function throws [std::bad_exception](../standard-library/bad-exception-class.md)."},{"content":"The extracted exception is now the current exception in the primary thread, and you can handle it as you would any other exception.","pos":[13729,13860]},{"content":"If you catch the exception, you can handle it immediately or use a <ph id=\"ph1\">`throw`</ph> statement to send it to a higher level exception handler.","pos":[13861,13993],"source":" If you catch the exception, you can handle it immediately or use a `throw` statement to send it to a higher level exception handler."},{"content":"Otherwise, do nothing and let the default system exception handler terminate your process.","pos":[13994,14084]},{"content":"make_exception_ptr Function","pos":[14094,14121]},{"content":"The <ph id=\"ph1\">`make_exception_ptr`</ph> function takes an instance of a class as its argument and then returns an <ph id=\"ph2\">`exception_ptr`</ph> that references the instance.","pos":[14125,14269],"source":"The `make_exception_ptr` function takes an instance of a class as its argument and then returns an `exception_ptr` that references the instance."},{"content":"Usually, you specify an <bpt id=\"p1\">[</bpt>exception class<ept id=\"p1\">](../standard-library/exception-class.md)</ept> object as the argument to the <ph id=\"ph1\">`make_exception_ptr`</ph> function, although any class object can be the argument.","pos":[14270,14459],"source":" Usually, you specify an [exception class](../standard-library/exception-class.md) object as the argument to the `make_exception_ptr` function, although any class object can be the argument."},{"content":"Calling the <ph id=\"ph1\">`make_exception_ptr`</ph> function is equivalent to throwing a C++ exception, catching it in a <ph id=\"ph2\">`catch`</ph> block, and then calling the <ph id=\"ph3\">`current_exception`</ph> function to return an <ph id=\"ph4\">`exception_ptr`</ph> object that references the exception.","pos":[14466,14699],"source":"Calling the `make_exception_ptr` function is equivalent to throwing a C++ exception, catching it in a `catch` block, and then calling the `current_exception` function to return an `exception_ptr` object that references the exception."},{"content":"The Microsoft implementation of the <ph id=\"ph1\">`make_exception_ptr`</ph> function is more efficient than throwing and then catching an exception.","pos":[14700,14829],"source":" The Microsoft implementation of the `make_exception_ptr` function is more efficient than throwing and then catching an exception."},{"pos":[14836,14939],"content":"An application typically does not require the <ph id=\"ph1\">`make_exception_ptr`</ph> function, and we discourage its use.","source":"An application typically does not require the `make_exception_ptr` function, and we discourage its use."},{"content":"Example","pos":[14948,14955]},{"content":"The following example transports a standard C++ exception and a custom C++ exception from one thread to another.","pos":[14959,15071]},{"content":"Requirements","pos":[18211,18223]},{"pos":[18227,18251],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>exception&gt;","source":"**Header:** \\<exception>"},{"content":"See Also","pos":[18260,18268]},{"content":"Exception Handling","pos":[18273,18291]},{"content":"/EH (Exception Handling Model)","pos":[18344,18374]},{"content":"/clr (Common Language Runtime Compilation)","pos":[18432,18474]}],"content":"---\ntitle: \"Transporting Exceptions Between Threads | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"std::current_exception\"\n  - \"transporting exceptions between threads\"\n  - \"std::copy_exception\"\n  - \"exception_ptr\"\n  - \"std::exception_ptr\"\n  - \"std::rethrow_exception\"\n  - \"current_exception\"\n  - \"transport exceptions between threads\"\n  - \"copy_exception\"\n  - \"rethrow_exception\"\n  - \"move exceptions between threads\"\nms.assetid: 5c95d57b-acf5-491f-8122-57c5df0edd98\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Transporting Exceptions Between Threads\nVisual C++ supports *transporting an exception* from one thread to another. Transporting exceptions enables you to catch an exception in one thread and then make the exception appear to be thrown in a different thread. For example, you can use this feature to write a multithreaded application where the primary thread handles all the exceptions thrown by its secondary threads. Transporting exceptions is useful mostly to developers who create parallel programming libraries or systems. To implement transporting exceptions, Visual C++ provides the [exception_ptr](../standard-library/exception-typedefs.md#exception_ptr) type and the [current_exception](../standard-library/exception-typedefs.md#current_exception), [rethrow_exception](../standard-library/exception-functions.md#rethrow_exception), and [make_exception_ptr](../standard-library/exception-functions.md#make_exception_ptr) functions.  \n  \n## Syntax  \n  \n```  \nnamespace std   \n{  \n   typedef unspecified exception_ptr;   \n   exception_ptr current_exception();  \n   void rethrow_exception(exception_ptr p);  \n   template<class E>   \n       exception_ptr make_exception_ptr(E e) noexcept;  \n}  \n```  \n  \n#### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`unspecified`|An unspecified internal class that is used to implement the `exception_ptr` type.|  \n|`p`|An `exception_ptr` object that references an exception.|  \n|`E`|A class that represents an exception.|  \n|`e`|An instance of the parameter `E` class.|  \n  \n## Return Value  \n The `current_exception` function returns an `exception_ptr` object that references the exception that is currently in progress. If no exception is in progress, the function returns an `exception_ptr` object that is not associated with any exception.  \n  \n The `make_exception_ptr` function returns an `exception_ptr` object that references the exception specified by the `e` parameter.  \n  \n## Remarks  \n  \n## Scenario  \n Imagine that you want to create an application that can scale to handle a variable amount of work. To achieve this objective, you design a multithreaded application where an initial, primary thread creates as many secondary threads as it needs in order to do the job. The secondary threads help the primary thread to manage resources, to balance loads, and to improve throughput. By distributing the work, the multithreaded application performs better than a single-threaded application.  \n  \n However, if a secondary thread throws an exception, you want the primary thread to handle it. This is because you want your application to handle exceptions in a consistent, unified manner regardless of the number of secondary threads.  \n  \n## Solution  \n To handle the previous scenario, the C++ Standard supports transporting an exception between threads. If a secondary thread throws an exception, that exception becomes the *current exception*. By analogy to the real world, the current exception is said to be *in flight*. The current exception is in flight from the time it is thrown until the exception handler that catches it returns.  \n  \n The secondary thread can catch the current exception in a `catch` block, and then call the `current_exception` function to store the exception in an `exception_ptr` object. The `exception_ptr` object must be available to the secondary thread and to the primary thread. For example, the `exception_ptr` object can be a global variable whose access is controlled by a mutex. The term *transport an exception* means an exception in one thread can be converted to a form that can be accessed by another thread.  \n  \n Next, the primary thread calls the `rethrow_exception` function, which extracts and then throws the exception from the `exception_ptr` object. When the exception is thrown, it becomes the current exception in the primary thread. That is, the exception appears to originate in the primary thread.  \n  \n Finally, the primary thread can catch the current exception in a `catch` block and then process it or throw it to a higher level exception handler. Or, the primary thread can ignore the exception and allow the process to end.  \n  \n Most applications do not have to transport exceptions between threads. However, this feature is useful in a parallel computing system because the system can divide work among secondary threads, processors, or cores. In a parallel computing environment, a single, dedicated thread can handle all the exceptions from the secondary threads and can present a consistent exception-handling model to any application.  \n  \n For more information about the C++ Standards committee proposal, search the Internet for document number N2179, titled \"Language Support for Transporting Exceptions between Threads\".  \n  \n## Exception-Handling Models and Compiler Options  \n Your application's exception-handling model determines whether it can catch and transport an exception. Visual C++ supports three models that can handle C++ exceptions, structured exception handling (SEH) exceptions, and common language runtime (CLR) exceptions. Use the [/EH](../build/reference/eh-exception-handling-model.md) and [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler options to specify your application's exception-handling model.  \n  \n Only the following combination of compiler options and programming statements can transport an exception. Other combinations either cannot catch exceptions, or can catch but cannot transport exceptions.  \n  \n-   The **/EHa** compiler option and the `catch` statement can transport SEH and C++ exceptions.  \n  \n-   The **/EHa**, **/EHs**, and **/EHsc** compiler options and the `catch` statement can transport C++ exceptions.  \n  \n-   The **/CLR** or **/CLR:pure** compiler option and the `catch` statement can transport C++ exceptions. The **/CLR** compiler options imply specification of the **/EHa** option. Note that the compiler does not support transporting managed exceptions. This is because managed exceptions, which are derived from the [System.Exception class](../standard-library/exception-class.md), are already objects that you can move between threads by using the facilities of the common languange runtime.  \n  \n    > [!IMPORTANT]\n    >  We recommend that you specify the **/EHsc** compiler option and catch only C++ exceptions. You expose yourself to a security threat if you use the **/EHa** or **/CLR** compiler option and a **catch** statement with an ellipsis *exception-declaration* (`catch(...)`). You probably intend to use the `catch` statement to capture a few specific exceptions. However, the `catch(...)` statement captures all C++ and SEH exceptions, including unexpected ones that should be fatal. If you ignore or mishandle an unexpected exception, malicious code can use that opportunity to undermine the security of your program.  \n  \n## Usage  \n The following sections describe how to transport exceptions by using the `exception_ptr` type, and the `current_exception`, `rethrow_exception`, and `make_exception_ptr` functions.  \n  \n### exception_ptr Type  \n Use an `exception_ptr` object to reference the current exception or an instance of a user-specified exception. In the Microsoft implementation, an exception is represented by an [EXCEPTION_RECORD](http://msdn.microsoft.com/library/windows/desktop/aa363082) structure. Each `exception_ptr` object includes an exception reference field that points to a copy of the `EXCEPTION_RECORD` structure that represents the exception.  \n  \n When you declare an `exception_ptr` variable, the variable is not associated with any exception. That is, its exception reference field is NULL. Such an `exception_ptr` object is called a *null exception_ptr*.  \n  \n Use the `current_exception` or `make_exception_ptr` function to assign an exception to an `exception_ptr` object. When you assign an exception to an `exception_ptr` variable, the variable's exception reference field points to a copy of the exception. If there is insufficient memory to copy the exception, the exception reference field points to a copy of a [std::bad_alloc](../standard-library/bad-alloc-class.md) exception. If the `current_exception` or `make_exception_ptr` function cannot copy the exception for any other reason, the function calls the [terminate](../c-runtime-library/reference/terminate-crt.md) function to exit the current process.  \n  \n Despite its name, an `exception_ptr` object is not itself a pointer. It does not obey pointer semantics and cannot be used with the pointer member access (`->`) or indirection (*) operators. The `exception_ptr` object has no public data members or member functions.  \n  \n **Comparisons:**  \n  \n You can use the equal (`==`) and not-equal (`!=`) operators to compare two `exception_ptr` objects. The operators do not compare the binary value (bit pattern) of the `EXCEPTION_RECORD` structures that represent the exceptions. Instead, the operators compare the addresses in the exception reference field of the `exception_ptr` objects. Consequently, a null `exception_ptr` and the NULL value compare as equal.  \n  \n### current_exception Function  \n Call the `current_exception` function in a `catch` block. If an exception is in flight and the `catch` block can catch the exception, the `current_exception` function returns an `exception_ptr` object that references the exception. Otherwise, the function returns a null `exception_ptr` object.  \n  \n **Details:**  \n  \n The `current_exception` function captures the exception that is in flight regardless of whether the `catch` statement specifies an [exception-declaration](../cpp/try-throw-and-catch-statements-cpp.md) statement.  \n  \n The destructor for the current exception is called at the end of the `catch` block if you do not rethrow the exception. However, even if you call the `current_exception` function in the destructor, the function returns an `exception_ptr` object that references the current exception.  \n  \n Successive calls to the `current_exception` function return `exception_ptr` objects that refer to different copies of the current exception. Consequently, the objects compare as unequal because they refer to different copies, even though the copies have the same binary value.  \n  \n **SEH Exceptions:**  \n  \n If you use the **/EHa** compiler option, you can catch an SEH exception in a C++ `catch` block. The `current_exception` function returns an `exception_ptr` object that references the SEH exception. And the `rethrow_exception` function throws the SEH exception if you call it with thetransported `exception_ptr` object as its argument.  \n  \n The `current_exception` function returns a null `exception_ptr` if you call it in an SEH `__finally` termination handler, an `__except` exception handler, or the `__except` filter expression.  \n  \n A transported exception does not support nested exceptions. A nested exception occurs if another exception is thrown while an exception is being handled. If you catch a nested exception, the `EXCEPTION_RECORD.ExceptionRecord` data member points to a chain of `EXCEPTION_RECORD` structures that describe the associated exceptions. The `current_exception` function does not support nested exceptions because it returns an `exception_ptr` object whose `ExceptionRecord` data member is zeroed out.  \n  \n If you catch an SEH exception, you must manage the memory referenced by any pointer in the `EXCEPTION_RECORD.ExceptionInformation` data member array. You must guarantee that the memory is valid during the lifetime of the corresponding `exception_ptr` object, and that the memory is freed when the `exception_ptr` object is deleted.  \n  \n You can use structured exception (SE) translator functions together with the transport exceptions feature. If an SEH exception is translated to a C++ exception, the `current_exception` function returns an `exception_ptr` that references the translated exception instead of the original SEH exception. The `rethrow_exception` function subsequently throws the translated exception, not the original exception. For more information about SE translator functions, see [_set_se_translator](../c-runtime-library/reference/set-se-translator.md).  \n  \n### rethrow_exception Function  \n After you store a caught exception in an `exception_ptr` object, the primary thread can process the object. In your primary thread, call the `rethrow_exception` function together with the `exception_ptr` object as its argument. The `rethrow_exception` function extracts the exception from the `exception_ptr` object and then throws the exception in the context of the primary thread. If the `p` parameter of the `rethrow_exception` function is a null `exception_ptr`, the function throws [std::bad_exception](../standard-library/bad-exception-class.md).  \n  \n The extracted exception is now the current exception in the primary thread, and you can handle it as you would any other exception. If you catch the exception, you can handle it immediately or use a `throw` statement to send it to a higher level exception handler. Otherwise, do nothing and let the default system exception handler terminate your process.  \n  \n### make_exception_ptr Function  \n The `make_exception_ptr` function takes an instance of a class as its argument and then returns an `exception_ptr` that references the instance. Usually, you specify an [exception class](../standard-library/exception-class.md) object as the argument to the `make_exception_ptr` function, although any class object can be the argument.  \n  \n Calling the `make_exception_ptr` function is equivalent to throwing a C++ exception, catching it in a `catch` block, and then calling the `current_exception` function to return an `exception_ptr` object that references the exception. The Microsoft implementation of the `make_exception_ptr` function is more efficient than throwing and then catching an exception.  \n  \n An application typically does not require the `make_exception_ptr` function, and we discourage its use.  \n  \n## Example  \n The following example transports a standard C++ exception and a custom C++ exception from one thread to another.  \n  \n```  \n// transport_exception.cpp  \n// compile with: /EHsc /MD  \n#include <windows.h>  \n#include <stdio.h>   \n#include <exception>  \n#include <stdexcept>  \n  \nusing namespace std;  \n  \n// Define thread-specific information.  \n#define THREADCOUNT 2  \nexception_ptr aException[THREADCOUNT];   \nint           aArg[THREADCOUNT];  \n  \nDWORD WINAPI ThrowExceptions( LPVOID );   \n  \n// Specify a user-defined, custom exception.   \n// As a best practice, derive your exception   \n// directly or indirectly from std::exception.   \nclass myException : public std::exception {   \n};  \nint main()  \n{  \n    HANDLE aThread[THREADCOUNT];  \n    DWORD ThreadID;  \n  \n    // Create secondary threads.  \n    for( int i=0; i < THREADCOUNT; i++ )  \n    {  \n        aArg[i] = i;  \n        aThread[i] = CreateThread(   \n            NULL,       // Default security attributes.  \n            0,          // Default stack size.  \n            (LPTHREAD_START_ROUTINE) ThrowExceptions,   \n            (LPVOID) &aArg[i], // Thread function argument.  \n            0,          // Default creation flags.  \n            &ThreadID); // Receives thread identifier.  \n        if( aThread[i] == NULL )  \n        {  \n            printf(\"CreateThread error: %d\\n\", GetLastError());  \n            return -1;  \n        }  \n    }   \n  \n    // Wait for all threads to terminate.  \n    WaitForMultipleObjects(THREADCOUNT, aThread, TRUE, INFINITE);   \n    // Close thread handles.  \n    for( int i=0; i < THREADCOUNT; i++ ) {  \n        CloseHandle(aThread[i]);   \n    }  \n  \n    // Rethrow and catch the transported exceptions.  \n    for ( int i = 0; i < THREADCOUNT; i++ ) {  \n        try {  \n            if (aException[i] == NULL) {  \n                printf(\"exception_ptr %d: No exception was transported.\\n\", i);  \n            }  \n            else {  \n                rethrow_exception( aException[i] );  \n            }    \n        }  \n        catch( const invalid_argument & ) {  \n            printf(\"exception_ptr %d: Caught an invalid_argument exception.\\n\", i);  \n        }  \n        catch( const myException & ) {  \n            printf(\"exception_ptr %d: Caught a  myException exception.\\n\", i);  \n        }  \n    }  \n}   \n// Each thread throws an exception depending on its thread   \n// function argument, and then ends.   \nDWORD WINAPI ThrowExceptions( LPVOID lpParam )   \n{   \n    int x = *((int*)lpParam);  \n    if (x == 0) {  \n        try {  \n            // Standard C++ exception.  \n            // This example explicitly throws invalid_argument exception.   \n            // In practice, your application performs an operation that   \n            // implicitly throws an exception.  \n            throw invalid_argument(\"A C++ exception.\");  \n        }    \n        catch ( const invalid_argument & ) {   \n            aException[x] = current_exception();  \n        }   \n    }  \n    else {  \n        // User-defined exception.  \n        aException[x] = make_exception_ptr( myException() );   \n    }  \n    return TRUE;   \n}  \n```  \n  \n```Output  \nexception_ptr 0: Caught an invalid_argument exception.  \nexception_ptr 1: Caught a  myException exception.  \n```  \n  \n## Requirements  \n **Header:** \\<exception>  \n  \n## See Also  \n [Exception Handling](../cpp/exception-handling-in-visual-cpp.md)     \n [/EH (Exception Handling Model)](../build/reference/eh-exception-handling-model.md)   \n [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)"}