{"nodes":[{"pos":[12,47],"content":"Constructors (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Constructors (C++) | Microsoft Docs","pos":[0,35]}]},{"content":"Constructors (C++)","pos":[644,662]},{"content":"A constructor is a kind of member function that initializes an instance of its class.","pos":[663,748]},{"content":"A constructor has the same name as the class and no return value.","pos":[749,814]},{"content":"A constructor can have any number of parameters and a class may have any number of overloaded constructors.","pos":[815,922]},{"content":"Constructors may have any accessibility, public, protected or private.","pos":[923,993]},{"content":"If you don't define any constructors, the compiler will generate a default constructor that takes no parameters; you can override this behavior by declaring a default constructor as deleted.","pos":[994,1184]},{"content":"In this topic","pos":[1193,1206]},{"content":"Order of Construction","pos":[1217,1238]},{"content":"Member Lists","pos":[1274,1286]},{"content":"Explicit Constructors","pos":[1313,1334]},{"content":"Default Constructors","pos":[1370,1390]},{"content":"Copy and Move Constructors","pos":[1425,1451]},{"content":"Explicitly Defaulted and Deleted Constructors","pos":[1492,1537]},{"content":"Constructors in Derived Classes","pos":[1597,1628]},{"content":"Virtual Functions in Constructors","pos":[1674,1707]},{"content":"Constructors and Composite Classes","pos":[1755,1789]},{"content":"Delegating Constructors","pos":[1837,1860]},{"content":"Inheriting constructors (C++11)","pos":[1898,1929]},{"content":"Rules for Declaring Constructors","pos":[1967,1999]},{"content":"Default and Copy Constructors","pos":[2045,2074]},{"content":"Explicitly invoking constructors","pos":[2085,2117]},{"pos":[2200,2221],"content":"Order of Construction"},{"content":"A constructor performs its work in this order:","pos":[2225,2271]},{"content":"It calls base class and member constructors in the order of declaration.","pos":[2281,2353]},{"content":"If the class is derived from virtual base classes, it initializes the object's virtual base pointers.","pos":[2363,2464]},{"content":"If the class has or inherits virtual functions, it initializes the object's virtual function pointers.","pos":[2474,2576]},{"content":"Virtual function pointers point to the class's virtual function table to enable correct binding of virtual function calls to code.","pos":[2577,2707]},{"content":"It executes any code in its function body.","pos":[2717,2759]},{"content":"The following example shows the order in which base class and member constructors are called in the constructor for a derived class.","pos":[2766,2898]},{"content":"First, the base constructor is called, then the base-class members are initialized in the order in which they appear in the class declaration, and then the derived constructor is called.","pos":[2899,3085]},{"content":"Here's the output:","pos":[3982,4000]},{"content":"If a constructor throws an exception, the order of destruction is the reverse of the order of construction:","pos":[4161,4268]},{"content":"The code in the body of the constructor function is unwound.","pos":[4278,4338]},{"content":"Base class and member objects are destroyed, in the reverse order of declaration.","pos":[4348,4429]},{"content":"If the constructor is non-delegating, all fully-constructed base class objects and members are destroyed.","pos":[4439,4544]},{"content":"However, because the object itself is not fully constructed, the destructor is not run.","pos":[4545,4632]},{"pos":[4670,4682],"content":"Member Lists"},{"content":"Initialize class members from constructor arguments by using a member initializer list.","pos":[4686,4773]},{"content":"This method uses <bpt id=\"p1\">*</bpt>direct initialization<ept id=\"p1\">*</ept>, which is more efficient than using assignment operators inside the constructor body.","pos":[4774,4900],"source":" This method uses *direct initialization*, which is more efficient than using assignment operators inside the constructor body."},{"content":"Create a Box object:","pos":[5228,5248]},{"pos":[5373,5394],"content":"Explicit Constructors"},{"content":"If a class has a constructor with a single parameter, or if all parameters except one have a default value, the parameter type can be implicitly converted to the class type.","pos":[5398,5571]},{"content":"For example, if the <ph id=\"ph1\">`Box`</ph> class has a constructor like this:","pos":[5572,5632],"source":" For example, if the `Box` class has a constructor like this:"},{"content":"It is possible to initialize a Box like this:","pos":[5719,5764]},{"content":"Or pass an int to a function that takes a Box:","pos":[5800,5846]},{"content":"Such conversions can be useful in some cases, but more often they can lead to subtle but serious errors in your code.","pos":[6093,6210]},{"content":"As a general rule, you should use the <ph id=\"ph1\">`explicit`</ph> keyword on a constructor (and user-defined operators) to prevent this kind of implicit type conversion:","pos":[6211,6363],"source":" As a general rule, you should use the `explicit` keyword on a constructor (and user-defined operators) to prevent this kind of implicit type conversion:"},{"content":"When the constructor is explicit, this line causes a compiler error: <ph id=\"ph1\">`ShippingOrder so(42, 10.8);`</ph>.","pos":[6462,6561],"source":"When the constructor is explicit, this line causes a compiler error: `ShippingOrder so(42, 10.8);`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>User-Defined Type Conversions<ept id=\"p1\">](../cpp/user-defined-type-conversions-cpp.md)</ept>.","pos":[6563,6666],"source":"  For more information, see [User-Defined Type Conversions](../cpp/user-defined-type-conversions-cpp.md)."},{"pos":[6712,6732],"content":"Default Constructors"},{"pos":[6736,6816],"content":"<bpt id=\"p1\">*</bpt>Default constructors<ept id=\"p1\">*</ept> have no parameters; they follow slightly different rules:","source":"*Default constructors* have no parameters; they follow slightly different rules:"},{"pos":[6823,6975],"content":"Default constructors are one of the <bpt id=\"p1\">*</bpt>special member functions<ept id=\"p1\">*</ept>; if no constructors are declared in a class, the compiler provides a default constructor:","source":"Default constructors are one of the *special member functions*; if no constructors are declared in a class, the compiler provides a default constructor:"},{"content":"When you call a default constructor and try to use parentheses, a warning is issued:","pos":[7270,7354]},{"content":"This is an example of the Most Vexing Parse problem.","pos":[7523,7575]},{"content":"Because the example expression can be interpreted either as the declaration of a function or as the invocation of a default constructor, and because C++ parsers favor declarations over other things, the expression is treated as a function declaration.","pos":[7576,7827]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Most Vexing Parse<ept id=\"p1\">](http://en.wikipedia.org/wiki/Most_vexing_parse)</ept>.","pos":[7828,7922],"source":" For more information, see [Most Vexing Parse](http://en.wikipedia.org/wiki/Most_vexing_parse)."},{"content":"If any non-default constructors are declared, the compiler does not provide a default constructor:","pos":[7929,8027]},{"content":"If a class has no default constructor, an array of objects of that class cannot be constructed by using square-bracket syntax alone.","pos":[8429,8561]},{"content":"For example, given the previous code block, an array of Boxes cannot be declared like this:","pos":[8562,8653]},{"content":"However, you can use a set of initializer lists to initialize an array of Boxes:","pos":[8770,8850]},{"pos":[8977,9003],"content":"Copy and Move Constructors"},{"content":"A <bpt id=\"p1\">*</bpt>copy constructor<ept id=\"p1\">*</ept> is a special member function that takes as input a reference to an object of the same type, and makes a copy of it.","pos":[9007,9143],"source":"A *copy constructor* is a special member function that takes as input a reference to an object of the same type, and makes a copy of it."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Copy Constructors and Copy Assignment Operators (C++)<ept id=\"p1\">](../cpp/copy-constructors-and-copy-assignment-operators-cpp.md)</ept>.","pos":[9144,9289],"source":" For more information, see [Copy Constructors and Copy Assignment Operators (C++)](../cpp/copy-constructors-and-copy-assignment-operators-cpp.md)."},{"content":"A move is also a special member function constructor moves ownership of an existing object to a new variable without copying the original data.","pos":[9290,9433]},{"content":"For more information, see  <bpt id=\"p1\">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id=\"p1\">](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db)</ept> and  <bpt id=\"p2\">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id=\"p2\">](../cpp/move-constructors-and-move-assignment-operators-cpp.md)</ept>.","pos":[9434,9711],"source":" For more information, see  [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db) and  [Move Constructors and Move Assignment Operators (C++)](../cpp/move-constructors-and-move-assignment-operators-cpp.md)."},{"pos":[9782,9827],"content":"Explicitly Defaulted and Deleted Constructors"},{"content":"You can explicitly default copy constructors, default constructors, move constructors, copy assignment operators, move assignment operators, and destructors.","pos":[9831,9988]},{"content":"You can explicitly delete all of the special member functions.","pos":[9989,10051]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Explicitly Defaulted and Deleted Functions<ept id=\"p1\">](../cpp/explicitly-defaulted-and-deleted-functions.md)</ept>.","pos":[10052,10177],"source":" For more information, see [Explicitly Defaulted and Deleted Functions](../cpp/explicitly-defaulted-and-deleted-functions.md)."},{"pos":[10234,10265],"content":"Constructors in Derived Classes"},{"content":"A derived class constructor always calls a base class constructor, so that it can rely on completely constructed base classes before any extra work is done.","pos":[10269,10425]},{"content":"The base class constructors are called in order of derivation—for example, if ClassA is derived from ClassB, which is derived from ClassC, the ClassC constructor is called first, then the ClassB constructor, then the ClassA constructor.","pos":[10426,10662]},{"content":"If a base class does not have a default constructor, you must supply the base class constructor parameters in the derived class constructor:","pos":[10669,10809]},{"content":"Constructors for Classes That Have Multiple Inheritance","pos":[11399,11454]},{"content":"If a class is derived from multiple base classes, the base class constructors are invoked in the order in which they are listed in the declaration of the derived class:","pos":[11458,11626]},{"content":"You should expect the following output:","pos":[12283,12322]},{"pos":[12502,12535],"content":"Virtual Functions in Constructors"},{"content":"We recommend that you be careful when you call virtual functions in constructors.","pos":[12539,12620]},{"content":"Because the base class constructor is always invoked before the derived class constructor, the function that's called in the base constructor is the base class version, not the derived class version.","pos":[12621,12820]},{"content":"In the following example, constructing a <ph id=\"ph1\">`DerivedClass`</ph> causes the <ph id=\"ph2\">`BaseClass`</ph> implementation of <ph id=\"ph3\">`print_it()`</ph> to execute before the <ph id=\"ph4\">`DerivedClass`</ph> constructor causes the <ph id=\"ph5\">`DerivedClass`</ph> implementation of <ph id=\"ph6\">`print_it()`</ph> to execute:","pos":[12821,13048],"source":" In the following example, constructing a `DerivedClass` causes the `BaseClass` implementation of `print_it()` to execute before the `DerivedClass` constructor causes the `DerivedClass` implementation of `print_it()` to execute:"},{"content":"Here's the output:","pos":[13544,13562]},{"pos":[13682,13716],"content":"Constructors and Composite Classes"},{"content":"Classes that contain class-type members are known as <bpt id=\"p1\">*</bpt>composite classes<ept id=\"p1\">*</ept>.","pos":[13720,13793],"source":"Classes that contain class-type members are known as *composite classes*."},{"content":"When a class-type member of a composite class is created, the constructor is called before the class's own constructor.","pos":[13794,13913]},{"content":"When a contained class lacks a default constructor, you must use an initialization list in the constructor of the composite class.","pos":[13914,14044]},{"content":"In the earlier <ph id=\"ph1\">`StorageBox`</ph> example, if you change the type of the <ph id=\"ph2\">`m_label`</ph> member variable to a new <ph id=\"ph3\">`Label`</ph> class, you must call both the base class constructor and initialize the <ph id=\"ph4\">`m_label`</ph> variable in the <ph id=\"ph5\">`StorageBox`</ph> constructor:","pos":[14045,14278],"source":" In the earlier `StorageBox` example, if you change the type of the `m_label` member variable to a new `Label` class, you must call both the base class constructor and initialize the `m_label` variable in the `StorageBox` constructor:"},{"pos":[15091,15114],"content":"Delegating Constructors"},{"content":"A <bpt id=\"p1\">*</bpt>delegating constructor<ept id=\"p1\">*</ept> calls a different constructor in the same class to do some of the work of initialization.","pos":[15118,15234],"source":"A *delegating constructor* calls a different constructor in the same class to do some of the work of initialization."},{"content":"In the following example, the derived class has three constructors—the second constructor delegates to the first, and the third constructor delegates to the second:","pos":[15235,15399]},{"content":"Here's the output:","pos":[16300,16318]},{"content":"The object created by the constructors is fully initialized as soon as any constructor is finished.","pos":[16486,16585]},{"content":"succeeds, but <ph id=\"ph1\">`DerivedContainer(int int1, int int2)`</ph> fails and the destructor is called.","pos":[16615,16703],"source":" succeeds, but `DerivedContainer(int int1, int int2)` fails and the destructor is called."},{"content":"Output:","pos":[17628,17635]},{"pos":[17790,17931],"content":"For more information, see <bpt id=\"p1\">[</bpt>Uniform Initialization and Delegating Constructors<ept id=\"p1\">](../cpp/uniform-initialization-and-delegating-constructors.md)</ept>.","source":"For more information, see [Uniform Initialization and Delegating Constructors](../cpp/uniform-initialization-and-delegating-constructors.md)."},{"pos":[17980,18011],"content":"Inheriting constructors (C++11)"},{"content":"A derived class can inherit the constructors from a direct base class by using a using declaration as shown in the following example:","pos":[18015,18148]},{"content":"The using statement brings into scope all constructors from the base class except those that have an identical signature to constructors in the derived class.","pos":[19385,19543]},{"content":"In general, it is best to use inheriting constructors when the derived class declares no new data members or constructors.","pos":[19544,19666]},{"content":"A class template can inherit all the constructors from a type argument if that type specifies a base class:","pos":[19673,19780]},{"content":"A deriving class cannot inherit from multiple base classes if those base classes have constructors that have an identical signature.","pos":[19925,20057]},{"pos":[20115,20147],"content":"Rules for Declaring Constructors"},{"content":"A constructor has the same name as its class.","pos":[20151,20196]},{"content":"Any number of constructors can be declared, subject to the rules of overloaded functions.","pos":[20197,20286]},{"pos":[20293,20338],"content":"The <ph id=\"ph1\">`argument-declaration-list`</ph> may be empty.","source":"The `argument-declaration-list` may be empty."},{"content":"C++ defines two special kinds of constructors, default and copy constructors, described in the following table.","pos":[20345,20456]},{"content":"Default and Copy Constructors","pos":[20466,20495]},{"content":"Kind of Construction","pos":[20502,20522]},{"content":"Arguments","pos":[20523,20532]},{"content":"Purpose","pos":[20533,20540]},{"content":"Default constructor","pos":[20606,20625]},{"content":"Can be called with no arguments","pos":[20626,20657]},{"content":"Construct a default object of the class type","pos":[20658,20702]},{"content":"Copy constructor","pos":[20707,20723]},{"content":"Can accept a single argument of reference to same class type","pos":[20724,20784]},{"content":"Copy objects of the class type","pos":[20785,20815]},{"content":"Default constructors can be called with no arguments.","pos":[20823,20876]},{"content":"However, you can declare a default constructor with an argument list, provided all arguments have defaults.","pos":[20877,20984]},{"content":"Similarly, copy constructors must accept a single argument of reference to the same class type.","pos":[20985,21080]},{"content":"More arguments can be supplied, provided all subsequent arguments have defaults.","pos":[21081,21161]},{"content":"If you do not supply any constructors, the compiler attempts to generate a default constructor.","pos":[21168,21263]},{"content":"If you do not supply a copy constructor, the compiler attempts to generate one.","pos":[21264,21343]},{"content":"These compiler-generated constructors are considered public member functions.","pos":[21344,21421]},{"content":"An error is generated if you specify a copy constructor with a first argument that is an object and not a reference.","pos":[21422,21538]},{"content":"A compiler-generated default constructor sets up the object (initializes vftables and vbtables, as described previously), and it calls the default constructors for base classes and members, but it takes no other action.","pos":[21545,21764]},{"content":"Base class and member constructors are called only if they exist, are accessible, and are unambiguous.","pos":[21765,21867]},{"content":"A compiler-generated copy constructor sets up a new object and performs a memberwise copy of the contents of the object to be copied.","pos":[21874,22007]},{"content":"If base class or member constructors exist, they are called; otherwise, bitwise copying is performed.","pos":[22008,22109]},{"content":"If all base and member classes of a class <ph id=\"ph1\">`type`</ph> have copy constructors that accept a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> argument, the compiler-generated copy constructor accepts a single argument of type <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> <ph id=\"ph2\">`type`</ph><bpt id=\"p3\">**</bpt><ph id=\"ph3\">&amp;</ph><ept id=\"p3\">**</ept>.","pos":[22116,22318],"source":"If all base and member classes of a class `type` have copy constructors that accept a **const** argument, the compiler-generated copy constructor accepts a single argument of type **const** `type`**&**."},{"content":"Otherwise, the compiler-generated copy constructor accepts a single argument of type <ph id=\"ph1\">`type`</ph><bpt id=\"p1\">**</bpt><ph id=\"ph2\">&amp;</ph><ept id=\"p1\">**</ept>.","pos":[22319,22416],"source":" Otherwise, the compiler-generated copy constructor accepts a single argument of type `type`**&**."},{"content":"You can use a constructor to initialize a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> object, but the constructor itself cannot be declared as <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> or <ph id=\"ph2\">`volatile`</ph>.","pos":[22423,22570],"source":"You can use a constructor to initialize a **const** or `volatile` object, but the constructor itself cannot be declared as **const** or `volatile`."},{"content":"The only legal storage class for a constructor is <bpt id=\"p1\">**</bpt>inline<ept id=\"p1\">**</ept>; use of any other storage-class modifier, including the <ph id=\"ph1\">`__declspec`</ph> keyword, with a constructor causes a compiler error.","pos":[22571,22753],"source":" The only legal storage class for a constructor is **inline**; use of any other storage-class modifier, including the `__declspec` keyword, with a constructor causes a compiler error."},{"content":"The stdcall calling convention is used on static member functions and global functions declared with the <bpt id=\"p1\">**</bpt>__stdcall<ept id=\"p1\">**</ept> keyword, and that do not use a variable argument list.","pos":[22760,22933],"source":"The stdcall calling convention is used on static member functions and global functions declared with the **__stdcall** keyword, and that do not use a variable argument list."},{"content":"When you use the <bpt id=\"p1\">**</bpt>__stdcall<ept id=\"p1\">**</ept> keyword on a non-static member function, such as a constructor, the compiler will use the thiscall calling convention.\"","pos":[22934,23084],"source":" When you use the **__stdcall** keyword on a non-static member function, such as a constructor, the compiler will use the thiscall calling convention.\""},{"content":"Constructors of base classes are not inherited by derived classes.","pos":[23091,23157]},{"content":"When an object of derived class type is created, it is constructed starting with the base class components; then it moves to the derived class components.","pos":[23158,23312]},{"content":"The compiler uses each base class's constructor as that part of the complete object is initialized (except in cases of virtual derivation.","pos":[23313,23451]},{"pos":[23509,23541],"content":"Explicitly invoking constructors"},{"content":"Constructors can be explicitly called in a program to create objects of a given type.","pos":[23545,23630]},{"content":"For example, to create two <ph id=\"ph1\">`Point`</ph> objects that describe the ends of a line, the following code can be written:","pos":[23631,23742],"source":" For example, to create two `Point` objects that describe the ends of a line, the following code can be written:"},{"pos":[23812,23951],"content":"Two objects of type <ph id=\"ph1\">`Point`</ph> are created, passed to the function <ph id=\"ph2\">`DrawLine`</ph>, and destroyed at the end of the expression (the function call).","source":"Two objects of type `Point` are created, passed to the function `DrawLine`, and destroyed at the end of the expression (the function call)."},{"content":"Another context in which a constructor is explicitly called is in an initialization:","pos":[23958,24042]},{"pos":[24093,24209],"content":"An object of type <ph id=\"ph1\">`Point`</ph> is created and initialized using the constructor that accepts two arguments of type <ph id=\"ph2\">`int`</ph>.","source":"An object of type `Point` is created and initialized using the constructor that accepts two arguments of type `int`."},{"content":"Objects that are created by calling constructors explicitly, as in the preceding two examples, are unnamed and have a lifetime of the expression in which they are created.","pos":[24216,24387]},{"content":"This is discussed in greater detail in <bpt id=\"p1\">[</bpt>Temporary Objects<ept id=\"p1\">](../cpp/temporary-objects.md)</ept>.","pos":[24388,24476],"source":" This is discussed in greater detail in [Temporary Objects](../cpp/temporary-objects.md)."},{"content":"It is usually safe to call any member function from within a constructor because the object has been completely set up (virtual tables have been initialized and so on) prior to the execution of the first line of user code.","pos":[24483,24705]},{"content":"However, it is potentially unsafe for a member function to call a virtual member function for an abstract base class during construction or destruction.","pos":[24706,24858]},{"content":"Constructors can call virtual functions.","pos":[24865,24905]},{"content":"When virtual functions are called, the function invoked is the function defined for the constructor's own class (or inherited from its bases).","pos":[24906,25048]},{"content":"The following example shows what happens when a virtual function is called from within a constructor:","pos":[25049,25150]},{"pos":[26068,26171],"content":"When the preceding program is run, the declaration <ph id=\"ph1\">`Derived d`</ph> causes the following sequence of events:","source":"When the preceding program is run, the declaration `Derived d` causes the following sequence of events:"},{"pos":[26181,26248],"content":"The constructor for class <ph id=\"ph1\">`Derived`</ph> (<ph id=\"ph2\">`Derived::Derived`</ph>) is called.","source":"The constructor for class `Derived` (`Derived::Derived`) is called."},{"pos":[26258,26381],"content":"Prior to entering the body of the <ph id=\"ph1\">`Derived`</ph> class's constructor, the constructor for class <ph id=\"ph2\">`Base`</ph> (<ph id=\"ph3\">`Base::Base`</ph>) is called.","source":"Prior to entering the body of the `Derived` class's constructor, the constructor for class `Base` (`Base::Base`) is called."},{"content":"calls the function <ph id=\"ph1\">`f`</ph>, which is a virtual function.","pos":[26401,26453],"source":" calls the function `f`, which is a virtual function."},{"content":"Ordinarily, <ph id=\"ph1\">`Derived::f`</ph> would be called because the object <ph id=\"ph2\">`d`</ph> is of type <ph id=\"ph3\">`Derived`</ph>.","pos":[26454,26539],"source":" Ordinarily, `Derived::f` would be called because the object `d` is of type `Derived`."},{"content":"Because the <ph id=\"ph1\">`Base::Base`</ph> function is a constructor, the object is not yet of the <ph id=\"ph2\">`Derived`</ph> type, and <ph id=\"ph3\">`Base::f`</ph> is called.","pos":[26540,26661],"source":" Because the `Base::Base` function is a constructor, the object is not yet of the `Derived` type, and `Base::f` is called."}],"content":"---\ntitle: \"Constructors (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"constructors [C++]\"\n  - \"objects [C++], creating\"\n  - \"instance constructors\"\nms.assetid: 3e9f7211-313a-4a92-9584-337452e061a9\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Constructors (C++)\nA constructor is a kind of member function that initializes an instance of its class. A constructor has the same name as the class and no return value. A constructor can have any number of parameters and a class may have any number of overloaded constructors. Constructors may have any accessibility, public, protected or private. If you don't define any constructors, the compiler will generate a default constructor that takes no parameters; you can override this behavior by declaring a default constructor as deleted.  \n  \n## In this topic  \n  \n-   [Order of Construction](#order_of_construction)  \n  \n-   [Member Lists](#member_lists)  \n  \n-   [Explicit Constructors](#explicit_constructors)  \n  \n-   [Default Constructors](#default_constructors)  \n  \n-   [Copy and Move Constructors](#copy_and_move_constructors)  \n  \n-   [Explicitly Defaulted and Deleted Constructors](#explicitly_defaulted_and_deleted_constructors)  \n  \n-   [Constructors in Derived Classes](#constructors_in_derived_classes)  \n  \n-   [Virtual Functions in Constructors](#virtual_functions_in_constructors)  \n  \n-   [Constructors and Composite Classes](#constructors_in_composite_classes)  \n  \n-   [Delegating Constructors](#delegating_constructors)  \n  \n-   [Inheriting constructors (C++11)](#inheriting_constructors)  \n  \n-   [Rules for Declaring Constructors](#rules_for_declaring_constructors)  \n  \n-   Default and Copy Constructors  \n  \n-   [Explicitly invoking constructors](#explicitly_invoking_constructors)  \n  \n##  <a name=\"order_of_construction\"></a> Order of Construction  \n A constructor performs its work in this order:  \n  \n1.  It calls base class and member constructors in the order of declaration.  \n  \n2.  If the class is derived from virtual base classes, it initializes the object's virtual base pointers.  \n  \n3.  If the class has or inherits virtual functions, it initializes the object's virtual function pointers. Virtual function pointers point to the class's virtual function table to enable correct binding of virtual function calls to code.  \n  \n4.  It executes any code in its function body.  \n  \n The following example shows the order in which base class and member constructors are called in the constructor for a derived class. First, the base constructor is called, then the base-class members are initialized in the order in which they appear in the class declaration, and then the derived constructor is called.  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nclass Contained1 {  \npublic:  \n    Contained1() {  \n        cout << \"Contained1 constructor.\" << endl;  \n    }  \n};  \n  \nclass Contained2 {  \npublic:  \n    Contained2() {  \n        cout << \"Contained2 constructor.\" << endl;  \n    }  \n};  \n  \nclass Contained3 {  \npublic:  \n    Contained3() {  \n        cout << \"Contained3 constructor.\" << endl;  \n    }  \n};  \n  \nclass BaseContainer {  \npublic:  \n    BaseContainer() {  \n        cout << \"BaseContainer constructor.\" << endl;  \n    }  \nprivate:  \n    Contained1 c1;  \n    Contained2 c2;  \n};  \n  \nclass DerivedContainer : public BaseContainer {  \npublic:  \n    DerivedContainer() : BaseContainer() {  \n        cout << \"DerivedContainer constructor.\" << endl;  \n    }  \nprivate:  \n    Contained3 c3;  \n};  \n  \nint main() {  \n    DerivedContainer dc;  \n    int x = 3;  \n}  \n  \n```  \n  \n Here's the output:  \n  \n```  \nContained1 constructor.  \nContained2 constructor.  \nBaseContainer constructor.  \nContained3 constructor.  \nDerivedContainer constructor.  \n```  \n  \n If a constructor throws an exception, the order of destruction is the reverse of the order of construction:  \n  \n1.  The code in the body of the constructor function is unwound.  \n  \n2.  Base class and member objects are destroyed, in the reverse order of declaration.  \n  \n3.  If the constructor is non-delegating, all fully-constructed base class objects and members are destroyed. However, because the object itself is not fully constructed, the destructor is not run.  \n  \n##  <a name=\"member_lists\"></a> Member Lists  \n Initialize class members from constructor arguments by using a member initializer list. This method uses *direct initialization*, which is more efficient than using assignment operators inside the constructor body.  \n  \n```cpp  \nclass Box {  \npublic:  \n    Box(int width, int length, int height)   \n        : m_width(width), m_length(length), m_height(height) // member init list  \n    {}  \n    int Volume() {return m_width * m_length * m_height; }  \nprivate:  \n    int m_width;  \n    int m_length;  \n    int m_height;  \n  \n};  \n  \n```  \n  \n Create a Box object:  \n  \n```  \nBox b(42, 21, 12);  \ncout << \"The volume is \" << b.Volume();  \n```  \n  \n##  <a name=\"explicit_constructors\"></a> Explicit Constructors  \n If a class has a constructor with a single parameter, or if all parameters except one have a default value, the parameter type can be implicitly converted to the class type. For example, if the `Box` class has a constructor like this:  \n  \n```  \nBox(int size): m_width(size), m_length(size), m_height(size){}  \n```  \n  \n It is possible to initialize a Box like this:  \n  \n```  \nBox b = 42;  \n```  \n  \n Or pass an int to a function that takes a Box:  \n  \n```  \nclass ShippingOrder  \n{  \npublic:  \n    ShippingOrder(Box b, double postage) : m_box(b), m_postage(postage){}  \n  \nprivate:  \n    Box m_box;  \n    double m_postage;  \n}  \n//elsewhere...  \n    ShippingOrder so(42, 10.8);  \n  \n```  \n  \n Such conversions can be useful in some cases, but more often they can lead to subtle but serious errors in your code. As a general rule, you should use the `explicit` keyword on a constructor (and user-defined operators) to prevent this kind of implicit type conversion:  \n  \n```  \n  \nexplicit Box(int size): m_width(size), m_length(size), m_height(size){}  \n```  \n  \n When the constructor is explicit, this line causes a compiler error: `ShippingOrder so(42, 10.8);`.  For more information, see [User-Defined Type Conversions](../cpp/user-defined-type-conversions-cpp.md).  \n  \n##  <a name=\"default_constructors\"></a> Default Constructors  \n *Default constructors* have no parameters; they follow slightly different rules:  \n  \n Default constructors are one of the *special member functions*; if no constructors are declared in a class, the compiler provides a default constructor:  \n  \n```cpp  \nclass Box {  \n    Box(int width, int length, int height)   \n        : m_width(width), m_length(length), m_height(height){}  \n};  \n  \nint main(){  \n  \n    Box box1{}; // call compiler-generated default ctor  \n    Box box2;   // call compiler-generated default ctor  \n}  \n```  \n  \n When you call a default constructor and try to use parentheses, a warning is issued:  \n  \n```cpp  \nclass myclass{};  \nint main(){  \nmyclass mc();     // warning C4930: prototyped function not called (was a variable definition intended?)  \n}  \n```  \n  \n This is an example of the Most Vexing Parse problem. Because the example expression can be interpreted either as the declaration of a function or as the invocation of a default constructor, and because C++ parsers favor declarations over other things, the expression is treated as a function declaration. For more information, see [Most Vexing Parse](http://en.wikipedia.org/wiki/Most_vexing_parse).  \n  \n If any non-default constructors are declared, the compiler does not provide a default constructor:  \n  \n```cpp  \nclass Box {  \n    Box(int width, int length, int height)   \n        : m_width(width), m_length(length), m_height(height){}  \n};  \nprivate:  \n    int m_width;  \n    int m_length;  \n    int m_height;  \n  \n};  \n  \nint main(){  \n  \n    Box box1(1, 2, 3);  \n    Box box2{ 2, 3, 4 };  \n    Box box4;     // compiler error C2512: no appropriate default constructor available  \n}  \n  \n```  \n  \n If a class has no default constructor, an array of objects of that class cannot be constructed by using square-bracket syntax alone. For example, given the previous code block, an array of Boxes cannot be declared like this:  \n  \n```cpp  \nBox boxes[3];    // compiler error C2512: no appropriate default constructor available  \n  \n```  \n  \n However, you can use a set of initializer lists to initialize an array of Boxes:  \n  \n```cpp  \nBox boxes[3]{ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };  \n```  \n  \n##  <a name=\"copy_and_move_constructors\"></a> Copy and Move Constructors  \n A *copy constructor* is a special member function that takes as input a reference to an object of the same type, and makes a copy of it. For more information, see [Copy Constructors and Copy Assignment Operators (C++)](../cpp/copy-constructors-and-copy-assignment-operators-cpp.md). A move is also a special member function constructor moves ownership of an existing object to a new variable without copying the original data. For more information, see  [Move Constructors and Move Assignment Operators (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db) and  [Move Constructors and Move Assignment Operators (C++)](../cpp/move-constructors-and-move-assignment-operators-cpp.md).  \n  \n##  <a name=\"explicitly_defaulted_and_deleted_constructors\"></a> Explicitly Defaulted and Deleted Constructors  \n You can explicitly default copy constructors, default constructors, move constructors, copy assignment operators, move assignment operators, and destructors. You can explicitly delete all of the special member functions. For more information, see [Explicitly Defaulted and Deleted Functions](../cpp/explicitly-defaulted-and-deleted-functions.md).  \n  \n##  <a name=\"constructors_in_derived_classes\"></a> Constructors in Derived Classes  \n A derived class constructor always calls a base class constructor, so that it can rely on completely constructed base classes before any extra work is done. The base class constructors are called in order of derivation—for example, if ClassA is derived from ClassB, which is derived from ClassC, the ClassC constructor is called first, then the ClassB constructor, then the ClassA constructor.  \n  \n If a base class does not have a default constructor, you must supply the base class constructor parameters in the derived class constructor:  \n  \n```cpp  \nclass Box {  \npublic:  \n    Box(int width, int length, int height){  \n       m_width = width;  \n       m_length = length;  \n       m_height = height;  \n    }  \n  \nprivate:  \n    int m_width;  \n    int m_length;  \n    int m_height;  \n};  \n  \nclass StorageBox : public Box {  \npublic:  \n    StorageBox(int width, int length, int height, const string label&) : Box(width, length, height){  \n        m_label = label;  \n    }  \nprivate:  \n    string m_label;  \n};  \n  \nint main(){  \n  \n    const string aLabel = \"aLabel\";  \n    StorageBox sb(1, 2, 3, aLabel);  \n}   \n```  \n  \n### Constructors for Classes That Have Multiple Inheritance  \n If a class is derived from multiple base classes, the base class constructors are invoked in the order in which they are listed in the declaration of the derived class:  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nclass BaseClass1 {  \npublic:  \n    BaseClass1() {  \n        cout << \"BaseClass1 constructor.\" << endl;  \n    }  \n};  \nclass BaseClass2 {  \npublic:  \n    BaseClass2() {  \n        cout << \"BaseClass2 constructor.\" << endl;  \n    }  \n};  \nclass BaseClass3{  \npublic:  \n    BaseClass3() {  \n        cout << \"BaseClass3 constructor.\" << endl;  \n    }  \n};  \nclass DerivedClass : public BaseClass1, public BaseClass2, public BaseClass3  {  \npublic:  \n    DerivedClass() {  \n        cout << \"DerivedClass constructor.\" << endl;  \n    }  \n};  \n  \nint main() {  \n    DerivedClass dc;  \n}  \n  \n```  \n  \n You should expect the following output:  \n  \n```  \nBaseClass1 constructor.  \nBaseClass2 constructor.  \nBaseClass3 constructor.  \nDerivedClass constructor.  \n```  \n  \n##  <a name=\"virtual_functions_in_constructors\"></a> Virtual Functions in Constructors  \n We recommend that you be careful when you call virtual functions in constructors. Because the base class constructor is always invoked before the derived class constructor, the function that's called in the base constructor is the base class version, not the derived class version. In the following example, constructing a `DerivedClass` causes the `BaseClass` implementation of `print_it()` to execute before the `DerivedClass` constructor causes the `DerivedClass` implementation of `print_it()` to execute:  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nclass BaseClass{  \npublic:  \n    BaseClass(){  \n        print_it();  \n    }  \n    virtual void print_it() {  \n        cout << \"BaseClass print_it\" << endl;  \n    }  \n};  \n  \nclass DerivedClass : public BaseClass {  \npublic:  \n    DerivedClass() {  \n        print_it();  \n    }  \n    virtual void print_it(){  \n        cout << \"Derived Class print_it\" << endl;  \n    }  \n};  \n  \nint main() {  \n  \n    DerivedClass dc;  \n}  \n```  \n  \n Here's the output:  \n  \n```  \nBaseClass print_it  \nDerived Class print_it  \n```  \n  \n##  <a name=\"constructors_in_composite_classes\"></a> Constructors and Composite Classes  \n Classes that contain class-type members are known as *composite classes*. When a class-type member of a composite class is created, the constructor is called before the class's own constructor. When a contained class lacks a default constructor, you must use an initialization list in the constructor of the composite class. In the earlier `StorageBox` example, if you change the type of the `m_label` member variable to a new `Label` class, you must call both the base class constructor and initialize the `m_label` variable in the `StorageBox` constructor:  \n  \n```cpp  \nclass Label {  \npublic:  \n    Label(const string& name, const string& address) { m_name = name; m_address = address; }  \n    string m_name;  \n    string m_address;  \n};  \n  \nclass StorageBox : public Box {  \npublic:  \n    StorageBox(int width, int length, int height, Label label)   \n        : Box(width, length, height), m_label(label){}  \nprivate:  \n    Label m_label;  \n};  \n  \nint main(){  \n// passing a named Label  \n    Label label1{ \"some_name\", \"some_address\" };  \n    StorageBox sb1(1, 2, 3, label1);  \n  \n    // passing a temporary label  \n    StorageBox sb2(3, 4, 5, Label{ \"another name\", \"another address\" });  \n  \n    // passing a temporary label as an initializer list  \n    StorageBox sb3(1, 2, 3, {\"myname\", \"myaddress\"});  \n}  \n```  \n  \n##  <a name=\"delegating_constructors\"></a> Delegating Constructors  \n A *delegating constructor* calls a different constructor in the same class to do some of the work of initialization. In the following example, the derived class has three constructors—the second constructor delegates to the first, and the third constructor delegates to the second:  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nclass ConstructorDestructor {  \npublic:  \n    ConstructorDestructor() {  \n        cout << \"ConstructorDestructor default constructor.\" << endl;  \n    }  \n    ConstructorDestructor(int int1) {  \n        cout << \"ConstructorDestructor constructor with 1 int.\" << endl;  \n    }  \n    ConstructorDestructor(int int1, int int2) : ConstructorDestructor(int1) {  \n        cout << \"ConstructorDestructor constructor with 2 ints.\" << endl;  \n  \n        throw exception();  \n    }  \n    ConstructorDestructor(int int1, int int2, int int3) : ConstructorDestructor(int1, int2) {  \n        cout << \"ConstructorDestructor constructor with 3 ints.\" << endl;  \n    }  \n    ~ConstructorDestructor() {  \n        cout << \"ConstructorDestructor destructor.\" << endl;  \n    }  \n};  \n  \nint main() {  \n    ConstructorDestructor dc(1, 2, 3);  \n}  \n  \n```  \n  \n Here's the output:  \n  \n```  \nConstructorDestructor constructor with 1 int.  \nConstructorDestructor constructor with 2 ints.  \nConstructorDestructor constructor with 3 ints.  \n```  \n  \n The object created by the constructors is fully initialized as soon as any constructor is finished. `DerivedContainer(int int1)` succeeds, but `DerivedContainer(int int1, int int2)` fails and the destructor is called.  \n  \n```cpp  \nclass ConstructorDestructor {  \npublic:  \n    ConstructorDestructor() {  \n        cout << \"ConstructorDestructor default constructor.\" << endl;  \n    }  \n    ConstructorDestructor(int int1) {  \n        cout << \"ConstructorDestructor constructor with 1 int.\" << endl;  \n    }  \n    ConstructorDestructor(int int1, int int2) : ConstructorDestructor(int1) {  \n        cout << \"ConstructorDestructor constructor with 2 ints.\" << endl;  \n        throw exception();  \n    }  \n    ConstructorDestructor(int int1, int int2, int int3) : ConstructorDestructor(int1, int2) {  \n        cout << \"ConstructorDestructor constructor with 3 ints.\" << endl;  \n    }  \n  \n    ~ConstructorDestructor() {  \n        cout << \"ConstructorDestructor destructor.\" << endl;  \n    }  \n};  \n  \nint main() {  \n  \n    try {  \n        ConstructorDestructor cd{ 1, 2, 3 };  \n    }  \n    catch (const exception& ex){  \n    }  \n}  \n  \n```  \n  \n Output:  \n  \n```  \nConstructorDestructor constructor with 1 int.  \nConstructorDestructor constructor with 2 ints.  \nConstructorDestructor destructor.  \n```  \n  \n For more information, see [Uniform Initialization and Delegating Constructors](../cpp/uniform-initialization-and-delegating-constructors.md).  \n  \n##  <a name=\"inheriting_constructors\"></a> Inheriting constructors (C++11)  \n A derived class can inherit the constructors from a direct base class by using a using declaration as shown in the following example:  \n  \n```  \n#include <iostream>  \nusing namespace std;  \n  \nclass Base  \n{  \npublic:      \n    Base() { cout << \"Base()\" << endl; }  \n    Base(const Base& other) { cout << \"Base(Base&)\" << endl; }  \n    explicit Base(int i) : num(i) { cout << \"Base(int)\" << endl; }  \n    explicit Base(char c) : letter(c) { cout << \"Base(char)\" << endl; }  \n  \nprivate:  \n    int num;  \n    char letter;  \n};  \n  \nclass Derived : Base  \n{  \npublic:  \n    // Inherit all constructors from Base  \n    using Base::Base;  \n  \nprivate:  \n    // Can't initialize newMember from Base constructors.  \n    int newMember{ 0 };  \n};  \n  \nint main(int argc, char argv[])  \n{  \n    cout << \"Derived d1(5) calls: \";   \n    Derived d1(5);  \n    cout << \"Derived d1('c') calls: \";  \n    Derived d2('c');  \n    cout << \"Derived d3 = d2 calls: \" ;  \n    Derived d3 = d2;  \n    cout << \"Derived d4 calls: \";  \n    Derived d4;   \n  \n    // Keep console open in debug mode:  \n    cout << endl << \"Press Enter to exit.\";  \n    char in[1];  \n    cin.getline(in, 1);  \n    return 0;  \n}  \n  \n/* Output:  \nDerived d1(5) calls: Base(int)  \nDerived d1('c') calls: Base(char)  \nDerived d3 = d2 calls: Base(Base&)  \nDerived d4 calls: Base()  \n  \nPress Enter to exit.  \n  \n```  \n  \n The using statement brings into scope all constructors from the base class except those that have an identical signature to constructors in the derived class. In general, it is best to use inheriting constructors when the derived class declares no new data members or constructors.  \n  \n A class template can inherit all the constructors from a type argument if that type specifies a base class:  \n  \n```  \ntemplate< typename T >  \nclass Derived : T {  \n    using T::T;   // declare the constructors from T  \n    // ...  \n};  \n  \n```  \n  \n A deriving class cannot inherit from multiple base classes if those base classes have constructors that have an identical signature.  \n  \n##  <a name=\"rules_for_declaring_constructors\"></a> Rules for Declaring Constructors  \n A constructor has the same name as its class. Any number of constructors can be declared, subject to the rules of overloaded functions.  \n  \n The `argument-declaration-list` may be empty.  \n  \n C++ defines two special kinds of constructors, default and copy constructors, described in the following table.  \n  \n### Default and Copy Constructors  \n  \n|Kind of Construction|Arguments|Purpose|  \n|--------------------------|---------------|-------------|  \n|Default constructor|Can be called with no arguments|Construct a default object of the class type|  \n|Copy constructor|Can accept a single argument of reference to same class type|Copy objects of the class type|  \n  \n Default constructors can be called with no arguments. However, you can declare a default constructor with an argument list, provided all arguments have defaults. Similarly, copy constructors must accept a single argument of reference to the same class type. More arguments can be supplied, provided all subsequent arguments have defaults.  \n  \n If you do not supply any constructors, the compiler attempts to generate a default constructor. If you do not supply a copy constructor, the compiler attempts to generate one. These compiler-generated constructors are considered public member functions. An error is generated if you specify a copy constructor with a first argument that is an object and not a reference.  \n  \n A compiler-generated default constructor sets up the object (initializes vftables and vbtables, as described previously), and it calls the default constructors for base classes and members, but it takes no other action. Base class and member constructors are called only if they exist, are accessible, and are unambiguous.  \n  \n A compiler-generated copy constructor sets up a new object and performs a memberwise copy of the contents of the object to be copied. If base class or member constructors exist, they are called; otherwise, bitwise copying is performed.  \n  \n If all base and member classes of a class `type` have copy constructors that accept a **const** argument, the compiler-generated copy constructor accepts a single argument of type **const** `type`**&**. Otherwise, the compiler-generated copy constructor accepts a single argument of type `type`**&**.  \n  \n You can use a constructor to initialize a **const** or `volatile` object, but the constructor itself cannot be declared as **const** or `volatile`. The only legal storage class for a constructor is **inline**; use of any other storage-class modifier, including the `__declspec` keyword, with a constructor causes a compiler error.  \n  \n The stdcall calling convention is used on static member functions and global functions declared with the **__stdcall** keyword, and that do not use a variable argument list. When you use the **__stdcall** keyword on a non-static member function, such as a constructor, the compiler will use the thiscall calling convention.\"  \n  \n Constructors of base classes are not inherited by derived classes. When an object of derived class type is created, it is constructed starting with the base class components; then it moves to the derived class components. The compiler uses each base class's constructor as that part of the complete object is initialized (except in cases of virtual derivation.  \n  \n##  <a name=\"explicitly_invoking_constructors\"></a> Explicitly invoking constructors  \n Constructors can be explicitly called in a program to create objects of a given type. For example, to create two `Point` objects that describe the ends of a line, the following code can be written:  \n  \n```  \nDrawLine( Point( 13, 22 ), Point( 87, 91 ) );  \n```  \n  \n Two objects of type `Point` are created, passed to the function `DrawLine`, and destroyed at the end of the expression (the function call).  \n  \n Another context in which a constructor is explicitly called is in an initialization:  \n  \n```  \nPoint pt = Point( 7, 11 );  \n```  \n  \n An object of type `Point` is created and initialized using the constructor that accepts two arguments of type `int`.  \n  \n Objects that are created by calling constructors explicitly, as in the preceding two examples, are unnamed and have a lifetime of the expression in which they are created. This is discussed in greater detail in [Temporary Objects](../cpp/temporary-objects.md).  \n  \n It is usually safe to call any member function from within a constructor because the object has been completely set up (virtual tables have been initialized and so on) prior to the execution of the first line of user code. However, it is potentially unsafe for a member function to call a virtual member function for an abstract base class during construction or destruction.  \n  \n Constructors can call virtual functions. When virtual functions are called, the function invoked is the function defined for the constructor's own class (or inherited from its bases). The following example shows what happens when a virtual function is called from within a constructor:  \n  \n```  \n// specl_calling_virtual_functions.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nclass Base  \n{  \npublic:  \n    Base();             // Default constructor.  \n    virtual void f();   // Virtual member function.  \n};  \n  \nBase::Base()  \n{  \n    cout << \"Constructing Base sub-object\\n\";  \n    f();                // Call virtual member function  \n}                       //  from inside constructor.  \n  \nvoid Base::f()  \n{  \n    cout << \"Called Base::f()\\n\";  \n}  \n  \nclass Derived : public Base  \n{  \npublic:  \n    Derived();          // Default constructor.  \n    void f();           // Implementation of virtual  \n};                      //  function f for this class.  \n  \nDerived::Derived()  \n{  \n    cout << \"Constructing Derived object\\n\";  \n}  \n  \nvoid Derived::f()  \n{  \n    cout << \"Called Derived::f()\\n\";  \n}  \n  \nint main()  \n{  \n    Derived d;  \n}  \n```  \n  \n When the preceding program is run, the declaration `Derived d` causes the following sequence of events:  \n  \n1.  The constructor for class `Derived` (`Derived::Derived`) is called.  \n  \n2.  Prior to entering the body of the `Derived` class's constructor, the constructor for class `Base` (`Base::Base`) is called.  \n  \n `Base::Base` calls the function `f`, which is a virtual function. Ordinarily, `Derived::f` would be called because the object `d` is of type `Derived`. Because the `Base::Base` function is a constructor, the object is not yet of the `Derived` type, and `Base::f` is called.  \n  \n"}