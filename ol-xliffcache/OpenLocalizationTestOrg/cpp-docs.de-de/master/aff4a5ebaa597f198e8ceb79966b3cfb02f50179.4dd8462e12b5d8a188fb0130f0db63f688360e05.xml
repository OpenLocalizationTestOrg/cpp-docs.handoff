{"nodes":[{"pos":[12,77],"content":"#if, #elif, #else, and #endif Directives (C-C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"if, #elif, #else, and #endif Directives (C-C++) | Microsoft Doc","pos":[1,64]}]},{"content":"if, #elif, #else, and #endif Directives (C/C++)","pos":[962,1009]},{"content":"The <ph id=\"ph1\">`#if`</ph> directive, with the <ph id=\"ph2\">`#elif`</ph>, <ph id=\"ph3\">`#else`</ph>, and <ph id=\"ph4\">`#endif`</ph> directives, controls compilation of portions of a source file.","pos":[1010,1133],"source":"The `#if` directive, with the `#elif`, `#else`, and `#endif` directives, controls compilation of portions of a source file."},{"content":"If the expression you write (after the <ph id=\"ph1\">`#if`</ph>) has a nonzero value, the line group immediately following the <ph id=\"ph2\">`#if`</ph> directive is retained in the translation unit.","pos":[1134,1294],"source":" If the expression you write (after the `#if`) has a nonzero value, the line group immediately following the `#if` directive is retained in the translation unit."},{"content":"Grammar","pos":[1303,1310]},{"content":"<bpt id=\"p1\">*</bpt>conditional<ept id=\"p1\">*</ept> :","pos":[1314,1329],"source":"*conditional* :"},{"content":"<bpt id=\"p1\"> *</bpt>if-part elif-parts<ept id=\"p1\">*</ept>opt<bpt id=\"p2\">*</bpt>else-part<ept id=\"p2\">*</ept>opt<bpt id=\"p3\">*</bpt>endif-line<ept id=\"p3\">*</ept>","pos":[1332,1382],"source":" *if-part elif-parts*opt*else-part*opt*endif-line*"},{"content":"<bpt id=\"p1\">*</bpt>if-part<ept id=\"p1\">*</ept> :","pos":[1389,1400],"source":"*if-part* :"},{"content":"if-line text","pos":[1405,1417]},{"content":"<bpt id=\"p1\">*</bpt>if-line<ept id=\"p1\">*</ept> :","pos":[1425,1436],"source":"*if-line* :"},{"content":"<bpt id=\"p1\"> **</bpt>#if<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>constant-expression<ept id=\"p2\">*</ept>","pos":[1439,1470],"source":" **#if**  *constant-expression*"},{"pos":[1477,1501],"content":"<bpt id=\"p1\">**</bpt>#ifdef<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>","source":"**#ifdef**  *identifier*"},{"pos":[1508,1533],"content":"<bpt id=\"p1\">**</bpt>#ifndef<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>","source":"**#ifndef**  *identifier*"},{"content":"<bpt id=\"p1\">*</bpt>elif-parts<ept id=\"p1\">*</ept> :","pos":[1540,1554],"source":"*elif-parts* :"},{"content":"elif-line text","pos":[1559,1573]},{"content":"elif-parts elif-line text","pos":[1582,1607]},{"content":"<bpt id=\"p1\">*</bpt>elif-line<ept id=\"p1\">*</ept> :","pos":[1615,1628],"source":"*elif-line* :"},{"content":"<bpt id=\"p1\"> **</bpt>#elif<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>constant-expression<ept id=\"p2\">*</ept>","pos":[1631,1664],"source":" **#elif**  *constant-expression*"},{"content":"<bpt id=\"p1\">*</bpt>else-part<ept id=\"p1\">*</ept> :","pos":[1671,1684],"source":"*else-part* :"},{"content":"else-line text","pos":[1689,1703]},{"content":"<bpt id=\"p1\">*</bpt>else-line<ept id=\"p1\">*</ept> :","pos":[1711,1724],"source":"*else-line* :"},{"content":"<bpt id=\"p1\">*</bpt>endif-line<ept id=\"p1\">*</ept> :","pos":[1742,1756],"source":"*endif-line* :"},{"content":"Each <ph id=\"ph1\">`#if`</ph> directive in a source file must be matched by a closing <ph id=\"ph2\">`#endif`</ph> directive.","pos":[1775,1861],"source":"Each `#if` directive in a source file must be matched by a closing `#endif` directive."},{"content":"Any number of <ph id=\"ph1\">`#elif`</ph> directives can appear between the <ph id=\"ph2\">`#if`</ph> and <ph id=\"ph3\">`#endif`</ph> directives, but at most one <ph id=\"ph4\">`#else`</ph> directive is allowed.","pos":[1862,1994],"source":" Any number of `#elif` directives can appear between the `#if` and `#endif` directives, but at most one `#else` directive is allowed."},{"content":"The <ph id=\"ph1\">`#else`</ph> directive, if present, must be the last directive before <ph id=\"ph2\">`#endif`</ph>.","pos":[1995,2073],"source":" The `#else` directive, if present, must be the last directive before `#endif`."},{"content":"The <ph id=\"ph1\">`#if`</ph>, <ph id=\"ph2\">`#elif`</ph>, <ph id=\"ph3\">`#else`</ph>, and <ph id=\"ph4\">`#endif`</ph> directives can nest in the text portions of other <ph id=\"ph5\">`#if`</ph> directives.","pos":[2080,2189],"source":"The `#if`, `#elif`, `#else`, and `#endif` directives can nest in the text portions of other `#if` directives."},{"content":"Each nested <ph id=\"ph1\">`#else`</ph>, <ph id=\"ph2\">`#elif`</ph>, or <ph id=\"ph3\">`#endif`</ph> directive belongs to the closest preceding <ph id=\"ph4\">`#if`</ph> directive.","pos":[2190,2291],"source":" Each nested `#else`, `#elif`, or `#endif` directive belongs to the closest preceding `#if` directive."},{"content":"All conditional-compilation directives, such as <ph id=\"ph1\">`#if`</ph> and <bpt id=\"p1\">**</bpt>#ifdef<ept id=\"p1\">**</ept>, must be matched with closing <ph id=\"ph2\">`#endif`</ph> directives prior to the end of file; otherwise, an error message is generated.","pos":[2298,2484],"source":"All conditional-compilation directives, such as `#if` and **#ifdef**, must be matched with closing `#endif` directives prior to the end of file; otherwise, an error message is generated."},{"content":"When conditional-compilation directives are contained in include files, they must satisfy the same conditions: There must be no unmatched conditional-compilation directives at the end of the include file.","pos":[2485,2689]},{"pos":[2696,2853],"content":"Macro replacement is performed within the part of the command line that follows an <ph id=\"ph1\">`#elif`</ph> command, so a macro call can be used in the <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept>.","source":"Macro replacement is performed within the part of the command line that follows an `#elif` command, so a macro call can be used in the *constant-expression*."},{"content":"The preprocessor selects one of the given occurrences of <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> for further processing.","pos":[2860,2947],"source":"The preprocessor selects one of the given occurrences of *text* for further processing."},{"content":"A block specified in <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> can be any sequence of text.","pos":[2948,3004],"source":" A block specified in *text* can be any sequence of text."},{"content":"It can occupy more than one line.","pos":[3005,3038]},{"content":"Usually <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> is program text that has meaning to the compiler or the preprocessor.","pos":[3039,3123],"source":" Usually *text* is program text that has meaning to the compiler or the preprocessor."},{"content":"The preprocessor processes the selected <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> and passes it to the compiler.","pos":[3130,3207],"source":"The preprocessor processes the selected *text* and passes it to the compiler."},{"content":"If <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> contains preprocessor directives, the preprocessor carries out those directives.","pos":[3208,3298],"source":" If *text* contains preprocessor directives, the preprocessor carries out those directives."},{"content":"Only text blocks selected by the preprocessor are compiled.","pos":[3299,3358]},{"content":"The preprocessor selects a single <bpt id=\"p1\">*</bpt>text<ept id=\"p1\">*</ept> item by evaluating the constant expression following each <ph id=\"ph1\">`#if`</ph> or <ph id=\"ph2\">`#elif`</ph> directive until it finds a true (nonzero) constant expression.","pos":[3365,3543],"source":"The preprocessor selects a single *text* item by evaluating the constant expression following each `#if` or `#elif` directive until it finds a true (nonzero) constant expression."},{"content":"It selects all text (including other preprocessor directives beginning with <bpt id=\"p1\">**</bpt><ph id=\"ph1\">#</ph><ept id=\"p1\">**</ept>) up to its associated <ph id=\"ph2\">`#elif`</ph>, <ph id=\"ph3\">`#else`</ph>, or <ph id=\"ph4\">`#endif`</ph>.","pos":[3544,3678],"source":" It selects all text (including other preprocessor directives beginning with **#**) up to its associated `#elif`, `#else`, or `#endif`."},{"content":"If all occurrences of <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> are false, or if no <ph id=\"ph1\">`#elif`</ph> directives appear, the preprocessor selects the text block after the <ph id=\"ph2\">`#else`</ph> clause.","pos":[3685,3841],"source":"If all occurrences of *constant-expression* are false, or if no `#elif` directives appear, the preprocessor selects the text block after the `#else` clause."},{"content":"If the <ph id=\"ph1\">`#else`</ph> clause is omitted and all instances of <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> in the <ph id=\"ph2\">`#if`</ph> block are false, no text block is selected.","pos":[3842,3974],"source":" If the `#else` clause is omitted and all instances of *constant-expression* in the `#if` block are false, no text block is selected."},{"pos":[3981,4076],"content":"The <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> is an integer constant expression with these additional restrictions:","source":"The *constant-expression* is an integer constant expression with these additional restrictions:"},{"pos":[4086,4212],"content":"Expressions must have integral type and can include only integer constants, character constants, and the <bpt id=\"p1\">**</bpt>defined<ept id=\"p1\">**</ept> operator.","source":"Expressions must have integral type and can include only integer constants, character constants, and the **defined** operator."},{"pos":[4222,4281],"content":"The expression cannot use <ph id=\"ph1\">`sizeof`</ph> or a type-cast operator.","source":"The expression cannot use `sizeof` or a type-cast operator."},{"content":"The target environment may not be able to represent all ranges of integers.","pos":[4291,4366]},{"pos":[4376,4488],"content":"The translation represents type <ph id=\"ph1\">`int`</ph> the same as type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, and <ph id=\"ph2\">`unsigned int`</ph> the same as <ph id=\"ph3\">`unsigned long`</ph>.","source":"The translation represents type `int` the same as type **long**, and `unsigned int` the same as `unsigned long`."},{"content":"The translator can translate character constants to a set of code values different from the set for the target environment.","pos":[4498,4621]},{"content":"To determine the properties of the target environment, check values of macros from LIMITS.H in an application built for the target environment.","pos":[4622,4765]},{"content":"The expression must not perform any environmental inquiries and must remain insulated from implementation details on the target computer.","pos":[4775,4912]},{"pos":[4919,5035],"content":"The preprocessor operator <bpt id=\"p1\">**</bpt>defined<ept id=\"p1\">**</ept> can be used in special constant expressions, as shown by the following syntax:","source":"The preprocessor operator **defined** can be used in special constant expressions, as shown by the following syntax:"},{"pos":[5042,5065],"content":"defined( <ph id=\"ph1\">`identifier`</ph> )","source":"defined( `identifier` )"},{"pos":[5072,5079],"content":"defined"},{"content":"This constant expression is considered true (nonzero) if the <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> is currently defined; otherwise, the condition is false (0).","pos":[5099,5233],"source":"This constant expression is considered true (nonzero) if the *identifier* is currently defined; otherwise, the condition is false (0)."},{"content":"An identifier defined as empty text is considered defined.","pos":[5234,5292]},{"content":"The <bpt id=\"p1\">**</bpt>defined<ept id=\"p1\">**</ept> directive can be used in an <ph id=\"ph1\">`#if`</ph> and an <ph id=\"ph2\">`#elif`</ph> directive, but nowhere else.","pos":[5293,5386],"source":" The **defined** directive can be used in an `#if` and an `#elif` directive, but nowhere else."},{"pos":[5393,5504],"content":"In the following example, the <ph id=\"ph1\">`#if`</ph> and <ph id=\"ph2\">`#endif`</ph> directives control compilation of one of three function calls:","source":"In the following example, the `#if` and `#endif` directives control compilation of one of three function calls:"},{"content":"The function call to <ph id=\"ph1\">`credit`</ph> is compiled if the identifier <ph id=\"ph2\">`CREDIT`</ph> is defined.","pos":[5639,5719],"source":"The function call to `credit` is compiled if the identifier `CREDIT` is defined."},{"content":"If the identifier <ph id=\"ph1\">`DEBIT`</ph> is defined, the function call to <ph id=\"ph2\">`debit`</ph> is compiled.","pos":[5720,5799],"source":" If the identifier `DEBIT` is defined, the function call to `debit` is compiled."},{"content":"If neither identifier is defined, the call to <ph id=\"ph1\">`printerror`</ph> is compiled.","pos":[5800,5871],"source":" If neither identifier is defined, the call to `printerror` is compiled."},{"content":"Note that <ph id=\"ph1\">`CREDIT`</ph> and <ph id=\"ph2\">`credit`</ph> are distinct identifiers in C and C++ because their cases are different.","pos":[5872,5976],"source":" Note that `CREDIT` and `credit` are distinct identifiers in C and C++ because their cases are different."},{"pos":[5983,6108],"content":"The conditional compilation statements in the following example assume a previously defined symbolic constant named <ph id=\"ph1\">`DLEVEL`</ph>.","source":"The conditional compilation statements in the following example assume a previously defined symbolic constant named `DLEVEL`."},{"content":"The first <ph id=\"ph1\">`#if`</ph> block shows two sets of nested <ph id=\"ph2\">`#if`</ph>, <ph id=\"ph3\">`#else`</ph>, and <ph id=\"ph4\">`#endif`</ph> directives.","pos":[6600,6687],"source":"The first `#if` block shows two sets of nested `#if`, `#else`, and `#endif` directives."},{"content":"The first set of directives is processed only if <ph id=\"ph1\">`DLEVEL &gt; 5`</ph> is true.","pos":[6688,6758],"source":" The first set of directives is processed only if `DLEVEL > 5` is true."},{"content":"Otherwise, the statements after #<bpt id=\"p1\">**</bpt>else<ept id=\"p1\">**</ept> are processed.","pos":[6759,6815],"source":" Otherwise, the statements after #**else** are processed."},{"content":"The <ph id=\"ph1\">`#elif`</ph> and <ph id=\"ph2\">`#else`</ph> directives in the second example are used to make one of four choices, based on the value of <ph id=\"ph3\">`DLEVEL`</ph>.","pos":[6822,6948],"source":"The `#elif` and `#else` directives in the second example are used to make one of four choices, based on the value of `DLEVEL`."},{"content":"The constant <ph id=\"ph1\">`STACK`</ph> is set to 0, 100, or 200, depending on the definition of <ph id=\"ph2\">`DLEVEL`</ph>.","pos":[6949,7036],"source":" The constant `STACK` is set to 0, 100, or 200, depending on the definition of `DLEVEL`."},{"content":"If <ph id=\"ph1\">`DLEVEL`</ph> is greater than 5, then the statement","pos":[7037,7086],"source":" If `DLEVEL` is greater than 5, then the statement"},{"pos":[7148,7187],"content":"is compiled and <ph id=\"ph1\">`STACK`</ph> is not defined.","source":"is compiled and `STACK` is not defined."},{"content":"A common use for conditional compilation is to prevent multiple inclusions of the same header file.","pos":[7194,7293]},{"content":"In C++, where classes are often defined in header files, constructs like the following can be used to prevent multiple definitions:","pos":[7294,7425]},{"content":"The preceding code checks to see if the symbolic constant <ph id=\"ph1\">`EXAMPLE_H`</ph> is defined.","pos":[7608,7689],"source":"The preceding code checks to see if the symbolic constant `EXAMPLE_H` is defined."},{"content":"If so, the file has already been included and need not be reprocessed.","pos":[7690,7760]},{"content":"If not, the constant <ph id=\"ph1\">`EXAMPLE_H`</ph> is defined to mark EXAMPLE.H as already processed.","pos":[7761,7844],"source":" If not, the constant `EXAMPLE_H` is defined to mark EXAMPLE.H as already processed."},{"content":"See Also","pos":[7853,7861]},{"content":"Preprocessor Directives","pos":[7866,7889]}],"content":"---\ntitle: \"#if, #elif, #else, and #endif Directives (C-C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"#else\"\n  - \"#endif\"\n  - \"#if\"\n  - \"#elif\"\n  - \"Defined\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"#elif directive\"\n  - \"conditional compilation, directives\"\n  - \"endif directive (#endif)\"\n  - \"preprocessor, directives\"\n  - \"#else directive\"\n  - \"#endif directive\"\n  - \"if directive (#if)\"\n  - \"else directive (#else)\"\n  - \"#if directive\"\n  - \"elif directive (#elif)\"\n  - \"defined directive\"\nms.assetid: c77a175f-6ca8-47d4-8df9-7bac5943d01b\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# #if, #elif, #else, and #endif Directives (C/C++)\nThe `#if` directive, with the `#elif`, `#else`, and `#endif` directives, controls compilation of portions of a source file. If the expression you write (after the `#if`) has a nonzero value, the line group immediately following the `#if` directive is retained in the translation unit.  \n  \n## Grammar  \n *conditional* :  \n *if-part elif-parts*opt*else-part*opt*endif-line*  \n  \n *if-part* :  \n *if-line text*  \n  \n *if-line* :  \n **#if**  *constant-expression*  \n  \n **#ifdef**  *identifier*  \n  \n **#ifndef**  *identifier*  \n  \n *elif-parts* :  \n *elif-line text*  \n  \n *elif-parts elif-line text*  \n  \n *elif-line* :  \n **#elif**  *constant-expression*  \n  \n *else-part* :  \n *else-line text*  \n  \n *else-line* :  \n `#else`  \n  \n *endif-line* :  \n `#endif`  \n  \n Each `#if` directive in a source file must be matched by a closing `#endif` directive. Any number of `#elif` directives can appear between the `#if` and `#endif` directives, but at most one `#else` directive is allowed. The `#else` directive, if present, must be the last directive before `#endif`.  \n  \n The `#if`, `#elif`, `#else`, and `#endif` directives can nest in the text portions of other `#if` directives. Each nested `#else`, `#elif`, or `#endif` directive belongs to the closest preceding `#if` directive.  \n  \n All conditional-compilation directives, such as `#if` and **#ifdef**, must be matched with closing `#endif` directives prior to the end of file; otherwise, an error message is generated. When conditional-compilation directives are contained in include files, they must satisfy the same conditions: There must be no unmatched conditional-compilation directives at the end of the include file.  \n  \n Macro replacement is performed within the part of the command line that follows an `#elif` command, so a macro call can be used in the *constant-expression*.  \n  \n The preprocessor selects one of the given occurrences of *text* for further processing. A block specified in *text* can be any sequence of text. It can occupy more than one line. Usually *text* is program text that has meaning to the compiler or the preprocessor.  \n  \n The preprocessor processes the selected *text* and passes it to the compiler. If *text* contains preprocessor directives, the preprocessor carries out those directives. Only text blocks selected by the preprocessor are compiled.  \n  \n The preprocessor selects a single *text* item by evaluating the constant expression following each `#if` or `#elif` directive until it finds a true (nonzero) constant expression. It selects all text (including other preprocessor directives beginning with **#**) up to its associated `#elif`, `#else`, or `#endif`.  \n  \n If all occurrences of *constant-expression* are false, or if no `#elif` directives appear, the preprocessor selects the text block after the `#else` clause. If the `#else` clause is omitted and all instances of *constant-expression* in the `#if` block are false, no text block is selected.  \n  \n The *constant-expression* is an integer constant expression with these additional restrictions:  \n  \n-   Expressions must have integral type and can include only integer constants, character constants, and the **defined** operator.  \n  \n-   The expression cannot use `sizeof` or a type-cast operator.  \n  \n-   The target environment may not be able to represent all ranges of integers.  \n  \n-   The translation represents type `int` the same as type **long**, and `unsigned int` the same as `unsigned long`.  \n  \n-   The translator can translate character constants to a set of code values different from the set for the target environment. To determine the properties of the target environment, check values of macros from LIMITS.H in an application built for the target environment.  \n  \n-   The expression must not perform any environmental inquiries and must remain insulated from implementation details on the target computer.  \n  \n The preprocessor operator **defined** can be used in special constant expressions, as shown by the following syntax:  \n  \n defined( `identifier` )  \n  \n defined `identifier`  \n  \n This constant expression is considered true (nonzero) if the *identifier* is currently defined; otherwise, the condition is false (0). An identifier defined as empty text is considered defined. The **defined** directive can be used in an `#if` and an `#elif` directive, but nowhere else.  \n  \n In the following example, the `#if` and `#endif` directives control compilation of one of three function calls:  \n  \n```  \n#if defined(CREDIT)  \n    credit();  \n#elif defined(DEBIT)  \n    debit();  \n#else  \n    printerror();  \n#endif  \n```  \n  \n The function call to `credit` is compiled if the identifier `CREDIT` is defined. If the identifier `DEBIT` is defined, the function call to `debit` is compiled. If neither identifier is defined, the call to `printerror` is compiled. Note that `CREDIT` and `credit` are distinct identifiers in C and C++ because their cases are different.  \n  \n The conditional compilation statements in the following example assume a previously defined symbolic constant named `DLEVEL`.  \n  \n```  \n#if DLEVEL > 5  \n    #define SIGNAL  1  \n    #if STACKUSE == 1  \n        #define STACK   200  \n    #else  \n        #define STACK   100  \n    #endif  \n#else  \n    #define SIGNAL  0  \n    #if STACKUSE == 1  \n        #define STACK   100  \n    #else  \n        #define STACK   50  \n    #endif  \n#endif  \n#if DLEVEL == 0  \n    #define STACK 0  \n#elif DLEVEL == 1  \n    #define STACK 100  \n#elif DLEVEL > 5  \n    display( debugptr );  \n#else  \n    #define STACK 200  \n#endif  \n```  \n  \n The first `#if` block shows two sets of nested `#if`, `#else`, and `#endif` directives. The first set of directives is processed only if `DLEVEL > 5` is true. Otherwise, the statements after #**else** are processed.  \n  \n The `#elif` and `#else` directives in the second example are used to make one of four choices, based on the value of `DLEVEL`. The constant `STACK` is set to 0, 100, or 200, depending on the definition of `DLEVEL`. If `DLEVEL` is greater than 5, then the statement  \n  \n```  \n#elif DLEVEL > 5  \ndisplay(debugptr);  \n```  \n  \n is compiled and `STACK` is not defined.  \n  \n A common use for conditional compilation is to prevent multiple inclusions of the same header file. In C++, where classes are often defined in header files, constructs like the following can be used to prevent multiple definitions:  \n  \n```  \n/*  EXAMPLE.H - Example header file  */  \n#if !defined( EXAMPLE_H )  \n#define EXAMPLE_H  \n  \nclass Example  \n{  \n...  \n};  \n  \n#endif // !defined( EXAMPLE_H )  \n```  \n  \n The preceding code checks to see if the symbolic constant `EXAMPLE_H` is defined. If so, the file has already been included and need not be reprocessed. If not, the constant `EXAMPLE_H` is defined to mark EXAMPLE.H as already processed.  \n  \n## See Also  \n [Preprocessor Directives](../preprocessor/preprocessor-directives.md)"}