{"nodes":[{"pos":[12,80],"content":"How to: Embed a Manifest Inside a C-C++ Application | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Embed a Manifest Inside a C-C++ Application | Microsoft Docs","pos":[0,68]}]},{"content":"How to: Embed a Manifest Inside a C/C++ Application","pos":[675,726]},{"content":"It is recommended that a C/C++ application (or library) have its manifest embedded inside the final binary because this guarantees correct runtime behavior in most scenarios.","pos":[727,901]},{"content":"By default, <ph id=\"ph1\">[!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)]</ph> tries to embed the manifest when it builds a project from source files; see <bpt id=\"p1\">[</bpt>Manifest Generation in Visual Studio<ept id=\"p1\">](../build/manifest-generation-in-visual-studio.md)</ept> for more information.","pos":[902,1160],"source":" By default, [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)] tries to embed the manifest when it builds a project from source files; see [Manifest Generation in Visual Studio](../build/manifest-generation-in-visual-studio.md) for more information."},{"content":"However if an application is built by using nmake, some changes to the existing makefile are necessary.","pos":[1161,1264]},{"content":"This section demonstrates how to change existing makefiles to automatically embed the manifest inside the final binary.","pos":[1265,1384]},{"content":"Two approaches","pos":[1393,1407]},{"content":"There are two ways to embed the manifest inside an application or library.","pos":[1411,1485]},{"content":"If you are not doing an incremental build you can directly embed the manifest using a command line similar to the following as a post-build step:","pos":[1495,1640]},{"content":"mt.exe –manifest MyApp.exe.manifest -outputresource:MyApp.exe;1","pos":[1653,1716]},{"content":"or","pos":[1729,1731]},{"content":"mt.exe –manifest MyLibrary.dll.manifest -outputresource:MyLibrary.dll;2","pos":[1744,1815]},{"content":"(1 for an EXE, 2 for a DLL.)","pos":[1828,1856]},{"content":"If you are doing an incremental build, directly editing the resource as shown here will disable incremental building and cause a full rebuild; therefore a different approach should be taken:","pos":[1866,2056]},{"content":"Link the binary to generate the MyApp.exe.manifest file.","pos":[2070,2126]},{"content":"Convert the manifest to a resource file.","pos":[2140,2180]},{"content":"Re-link (incrementally) to embed the manifest resource into the binary.","pos":[2194,2265]},{"content":"The following examples show how to change makefiles to incorporate both techniques.","pos":[2272,2355]},{"content":"Makefiles (Before)","pos":[2364,2382]},{"content":"Consider the nmake script for MyApp.exe, a simple application built from one file:","pos":[2386,2468]},{"content":"If this script is run unchanged with Visual C++, it successfully creates MyApp.exe.","pos":[2769,2852]},{"content":"It also creates the external manifest file MyApp.exe.manifest, for use by the operating system to load dependent assemblies at runtime.","pos":[2853,2988]},{"content":"The nmake script for MyLibrary.dll looks very similar:","pos":[2995,3049]},{"content":"Makefiles (After)","pos":[3415,3432]},{"content":"To build with embedded manifests you have to make four small changes to the original makefiles.","pos":[3436,3531]},{"content":"For the MyApp.exe makefile:","pos":[3532,3559]},{"content":"For the MyLibrary.dll makefile:","pos":[4194,4225]},{"content":"The makefiles now include two files that do the real work, makefile.inc and makefile.targ.inc.","pos":[4925,5019]},{"content":"Create makefile.inc and copy the following into it:","pos":[5026,5077]},{"content":"Now create makefile.targ.inc and copy the following into it:","pos":[6992,7052]},{"content":"See Also","pos":[7851,7859]},{"content":"Understanding Manifest Generation for C/C++ Programs","pos":[7864,7916]}],"content":"---\ntitle: \"How to: Embed a Manifest Inside a C-C++ Application | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"manifests [C++]\"\n  - \"embedding manifests\"\n  - \"makefiles, updating to embed manifest\"\nms.assetid: ec0bac69-2fdc-466c-ab0d-710a22974e5d\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Embed a Manifest Inside a C/C++ Application\nIt is recommended that a C/C++ application (or library) have its manifest embedded inside the final binary because this guarantees correct runtime behavior in most scenarios. By default, [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)] tries to embed the manifest when it builds a project from source files; see [Manifest Generation in Visual Studio](../build/manifest-generation-in-visual-studio.md) for more information. However if an application is built by using nmake, some changes to the existing makefile are necessary. This section demonstrates how to change existing makefiles to automatically embed the manifest inside the final binary.  \n  \n## Two approaches  \n There are two ways to embed the manifest inside an application or library.  \n  \n-   If you are not doing an incremental build you can directly embed the manifest using a command line similar to the following as a post-build step:  \n  \n     **mt.exe –manifest MyApp.exe.manifest -outputresource:MyApp.exe;1**  \n  \n     or  \n  \n     **mt.exe –manifest MyLibrary.dll.manifest -outputresource:MyLibrary.dll;2**  \n  \n     (1 for an EXE, 2 for a DLL.)  \n  \n-   If you are doing an incremental build, directly editing the resource as shown here will disable incremental building and cause a full rebuild; therefore a different approach should be taken:  \n  \n    -   Link the binary to generate the MyApp.exe.manifest file.  \n  \n    -   Convert the manifest to a resource file.  \n  \n    -   Re-link (incrementally) to embed the manifest resource into the binary.  \n  \n The following examples show how to change makefiles to incorporate both techniques.  \n  \n## Makefiles (Before)  \n Consider the nmake script for MyApp.exe, a simple application built from one file:  \n  \n```  \n# build MyApp.exe  \n!if \"$(DEBUG)\" == \"1\"  \nCPPFLAGS=$(CPPFLAGS) /MDd  \nLFLAGS=$(LFLAGS) /INCREMENTAL  \n!else  \nCPPFLAGS=$(CPPFLAGS) /MD  \n!endif  \n  \nMyApp.exe : MyApp.obj  \n    link $** /out:$@ $(LFLAGS)  \n  \nMyApp.obj : MyApp.cpp  \n  \nclean :   \n    del MyApp.obj MyApp.exe  \n```  \n  \n If this script is run unchanged with Visual C++, it successfully creates MyApp.exe. It also creates the external manifest file MyApp.exe.manifest, for use by the operating system to load dependent assemblies at runtime.  \n  \n The nmake script for MyLibrary.dll looks very similar:  \n  \n```  \n# build MyLibrary.dll  \n!if \"$(DEBUG)\" == \"1\"  \nCPPFLAGS=$(CPPFLAGS) /MDd  \nLFLAGS=$(LFLAGS) /DLL /INCREMENTAL  \n  \n!else  \nCPPFLAGS=$(CPPFLAGS) /MD  \nLFLAGS=$(LFLAGS) /DLL  \n  \n!endif  \n  \nMyLibrary.dll : MyLibrary.obj  \n    link $** /out:$@ $(LFLAGS)  \n  \nMyLibrary.obj : MyLibrary.cpp  \n  \nclean :   \n    del MyLibrary.obj MyLibrary.dll  \n```  \n  \n## Makefiles (After)  \n To build with embedded manifests you have to make four small changes to the original makefiles. For the MyApp.exe makefile:  \n  \n```  \n# build MyApp.exe  \n!include makefile.inc  \n#^^^^^^^^^^^^^^^^^^^^ Change #1. (Add full path if necessary.)  \n  \n!if \"$(DEBUG)\" == \"1\"  \nCPPFLAGS=$(CPPFLAGS) /MDd  \nLFLAGS=$(LFLAGS) /INCREMENTAL  \n!else  \nCPPFLAGS=$(CPPFLAGS) /MD  \n!endif  \n  \nMyApp.exe : MyApp.obj  \n    link $** /out:$@ $(LFLAGS)  \n    $(_VC_MANIFEST_EMBED_EXE)  \n#^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Change #2  \n  \nMyApp.obj : MyApp.cpp  \n  \nclean :   \n    del MyApp.obj MyApp.exe  \n    $(_VC_MANIFEST_CLEAN)  \n#^^^^^^^^^^^^^^^^^^^^^^^^ Change #3  \n  \n!include makefile.targ.inc  \n#^^^^^^^^^^^^^^^^^^^^^^^^^ Change #4. (Add full path if necessary.)  \n```  \n  \n For the MyLibrary.dll makefile:  \n  \n```  \n# build MyLibrary.dll  \n!include makefile.inc  \n#^^^^^^^^^^^^^^^^^^^^ Change #1. (Add full path if necessary.)  \n  \n!if \"$(DEBUG)\" == \"1\"  \nCPPFLAGS=$(CPPFLAGS) /MDd  \nLFLAGS=$(LFLAGS) /DLL /INCREMENTAL  \n  \n!else  \nCPPFLAGS=$(CPPFLAGS) /MD  \nLFLAGS=$(LFLAGS) /DLL  \n  \n!endif  \n  \nMyLibrary.dll : MyLibrary.obj  \n    link $** /out:$@ $(LFLAGS)  \n    $(_VC_MANIFEST_EMBED_DLL)  \n#^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Change #2.  \n  \nMyLibrary.obj : MyLibrary.cpp  \n  \nclean :   \n    del MyLibrary.obj MyLibrary.dll  \n    $(_VC_MANIFEST_CLEAN)  \n#^^^^^^^^^^^^^^^^^^^^^^^^ Change #3.  \n  \n!include makefile.targ.inc  \n#^^^^^^^^^^^^^^^^^^^^^^^^^ Change #4. (Add full path if necessary.)  \n```  \n  \n The makefiles now include two files that do the real work, makefile.inc and makefile.targ.inc.  \n  \n Create makefile.inc and copy the following into it:  \n  \n```  \n# makefile.inc -- Include this file into existing makefile at the very top.  \n  \n# _VC_MANIFEST_INC specifies whether build is incremental (1 - incremental).  \n# _VC_MANIFEST_BASENAME specifies name of a temporary resource file.  \n  \n!if \"$(DEBUG)\" == \"1\"  \nCPPFLAGS=$(CPPFLAGS) /MDd  \nLFLAGS=$(LFLAGS) /INCREMENTAL  \n_VC_MANIFEST_INC=1  \n_VC_MANIFEST_BASENAME=__VC90.Debug  \n  \n!else  \nCPPFLAGS=$(CPPFLAGS) /MD  \n_VC_MANIFEST_INC=0  \n_VC_MANIFEST_BASENAME=__VC90  \n  \n!endif  \n  \n####################################################  \n# Specifying name of temporary resource file used only in incremental builds:  \n  \n!if \"$(_VC_MANIFEST_INC)\" == \"1\"  \n_VC_MANIFEST_AUTO_RES=$(_VC_MANIFEST_BASENAME).auto.res  \n!else  \n_VC_MANIFEST_AUTO_RES=  \n!endif  \n  \n####################################################  \n# _VC_MANIFEST_EMBED_EXE - command to embed manifest in EXE:  \n  \n!if \"$(_VC_MANIFEST_INC)\" == \"1\"  \n  \n#MT_SPECIAL_RETURN=1090650113  \n#MT_SPECIAL_SWITCH=-notify_resource_update  \nMT_SPECIAL_RETURN=0  \nMT_SPECIAL_SWITCH=  \n_VC_MANIFEST_EMBED_EXE= \\  \nif exist $@.manifest mt.exe -manifest $@.manifest -out:$(_VC_MANIFEST_BASENAME).auto.manifest $(MT_SPECIAL_SWITCH) & \\  \nif \"%ERRORLEVEL%\" == \"$(MT_SPECIAL_RETURN)\" \\  \nrc /r $(_VC_MANIFEST_BASENAME).auto.rc & \\  \nlink $** /out:$@ $(LFLAGS)  \n  \n!else  \n  \n_VC_MANIFEST_EMBED_EXE= \\  \nif exist $@.manifest mt.exe -manifest $@.manifest -outputresource:$@;1  \n  \n!endif  \n  \n####################################################  \n# _VC_MANIFEST_CLEAN - command to clean resources files generated temporarily:  \n  \n!if \"$(_VC_MANIFEST_INC)\" == \"1\"  \n  \n_VC_MANIFEST_CLEAN=-del $(_VC_MANIFEST_BASENAME).auto.res \\  \n    $(_VC_MANIFEST_BASENAME).auto.rc \\  \n    $(_VC_MANIFEST_BASENAME).auto.manifest  \n  \n!else  \n  \n_VC_MANIFEST_CLEAN=  \n  \n!endif  \n  \n# End of makefile.inc   \n####################################################  \n```  \n  \n Now create makefile.targ.inc and copy the following into it:  \n  \n```  \n# makefile.targ.inc - include this at the very bottom of the existing makefile  \n  \n####################################################  \n# Commands to generate initial empty manifest file and the RC file  \n# that references it, and for generating the .res file:  \n  \n$(_VC_MANIFEST_BASENAME).auto.res : $(_VC_MANIFEST_BASENAME).auto.rc  \n  \n$(_VC_MANIFEST_BASENAME).auto.rc : $(_VC_MANIFEST_BASENAME).auto.manifest  \n    type <<$@  \n#include <winuser.h>  \n1RT_MANIFEST\"$(_VC_MANIFEST_BASENAME).auto.manifest\"  \n<< KEEP  \n  \n$(_VC_MANIFEST_BASENAME).auto.manifest :  \n    type <<$@  \n<?xml version='1.0' encoding='UTF-8' standalone='yes'?>  \n<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>  \n</assembly>  \n<< KEEP  \n  \n# end of makefile.targ.inc  \n```  \n  \n## See Also  \n [Understanding Manifest Generation for C/C++ Programs](../build/understanding-manifest-generation-for-c-cpp-programs.md)"}