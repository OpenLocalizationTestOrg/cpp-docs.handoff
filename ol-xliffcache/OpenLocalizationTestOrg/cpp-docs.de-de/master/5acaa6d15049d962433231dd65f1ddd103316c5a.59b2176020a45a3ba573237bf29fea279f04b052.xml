{"nodes":[{"pos":[12,56],"content":"Overloading Unary Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overloading Unary Operators | Microsoft Docs","pos":[0,44]}]},{"content":"Overloading Unary Operators","pos":[817,844]},{"content":"The unary operators that can be overloaded are the following:","pos":[845,906]},{"pos":[920,979],"content":"(<bpt id=\"p1\">[</bpt>logical NOT<ept id=\"p1\">](../cpp/logical-negation-operator-exclpt.md)</ept>)","source":" ([logical NOT](../cpp/logical-negation-operator-exclpt.md))"},{"pos":[993,1042],"content":"(<bpt id=\"p1\">[</bpt>address-of<ept id=\"p1\">](../cpp/address-of-operator-amp.md)</ept>)","source":" ([address-of](../cpp/address-of-operator-amp.md))"},{"pos":[1056,1119],"content":"(<bpt id=\"p1\">[</bpt>one's complement<ept id=\"p1\">](../cpp/one-s-complement-operator-tilde.md)</ept>)","source":" ([one's complement](../cpp/one-s-complement-operator-tilde.md))"},{"pos":[1133,1193],"content":"(<bpt id=\"p1\">[</bpt>pointer dereference<ept id=\"p1\">](../cpp/indirection-operator-star.md)</ept>)","source":" ([pointer dereference](../cpp/indirection-operator-star.md))"},{"pos":[1207,1260],"content":"(<bpt id=\"p1\">[</bpt>unary plus<ept id=\"p1\">](../cpp/additive-operators-plus-and.md)</ept>)","source":" ([unary plus](../cpp/additive-operators-plus-and.md))"},{"pos":[1274,1331],"content":"(<bpt id=\"p1\">[</bpt>unary negation<ept id=\"p1\">](../cpp/additive-operators-plus-and.md)</ept>)","source":" ([unary negation](../cpp/additive-operators-plus-and.md))"},{"pos":[1346,1435],"content":"(<bpt id=\"p1\">[</bpt>increment<ept id=\"p1\">](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md)</ept>)","source":" ([increment](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md))"},{"pos":[1450,1539],"content":"(<bpt id=\"p1\">[</bpt>decrement<ept id=\"p1\">](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md)</ept>)","source":" ([decrement](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md))"},{"content":"conversion operators","pos":[1548,1568]},{"pos":[1575,1751],"content":"The postfix increment and decrement operators (<ph id=\"ph1\">`++`</ph> and <bpt id=\"p1\">**</bpt>––<ept id=\"p1\">**</ept>) are treated separately in <bpt id=\"p2\">[</bpt>Increment and Decrement<ept id=\"p2\">](../cpp/increment-and-decrement-operator-overloading-cpp.md)</ept>.","source":"The postfix increment and decrement operators (`++` and **––**) are treated separately in [Increment and Decrement](../cpp/increment-and-decrement-operator-overloading-cpp.md)."},{"pos":[1758,1900],"content":"Conversion operators are also discussed in a separate topic; see <bpt id=\"p1\">[</bpt>User-Defined Type Conversions<ept id=\"p1\">](../cpp/user-defined-type-conversions-cpp.md)</ept>.","source":"Conversion operators are also discussed in a separate topic; see [User-Defined Type Conversions](../cpp/user-defined-type-conversions-cpp.md)."},{"content":"The following rules are true of all other unary operators.","pos":[1907,1965]},{"content":"To declare a unary operator function as a nonstatic member, you must declare it in the form:","pos":[1966,2058]},{"pos":[2101,2200],"content":"where <ph id=\"ph1\">`ret-type`</ph> is the return type and <ph id=\"ph2\">`op`</ph> is one of the operators listed in the preceding table.","source":"where `ret-type` is the return type and `op` is one of the operators listed in the preceding table."},{"content":"To declare a unary operator function as a global function, you must declare it in the form:","pos":[2207,2298]},{"pos":[2330,2338],"content":"(<ph id=\"ph1\">`arg`</ph> )","source":" (`arg` )"},{"pos":[2345,2481],"content":"where <ph id=\"ph1\">`ret-type`</ph> and <ph id=\"ph2\">`op`</ph> are as described for member operator functions and the <ph id=\"ph3\">`arg`</ph> is an argument of class type on which to operate.","source":"where `ret-type` and `op` are as described for member operator functions and the `arg` is an argument of class type on which to operate."},{"pos":[2489,2672],"content":"[!NOTE]\n There is no restriction on the return types of the unary operators. For example, it makes sense for logical NOT (`!`) to return an integral value, but this is not enforced.","leadings":["","> "],"nodes":[{"content":" There is no restriction on the return types of the unary operators. For example, it makes sense for logical NOT (`!`) to return an integral value, but this is not enforced.","pos":[8,181],"nodes":[{"content":"There is no restriction on the return types of the unary operators.","pos":[1,68]},{"content":"For example, it makes sense for logical NOT (<ph id=\"ph1\">`!`</ph>) to return an integral value, but this is not enforced.","pos":[69,173],"source":" For example, it makes sense for logical NOT (`!`) to return an integral value, but this is not enforced."}]}]},{"content":"See Also","pos":[2681,2689]},{"content":"Operator Overloading","pos":[2694,2714]}],"content":"---\ntitle: \"Overloading Unary Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"unary operators, plus\"\n  - \"increment operators, overloaded\"\n  - \"unary operators, minus\"\n  - \"operators [C++], unary\"\n  - \"redefinable unary operators\"\n  - \"unary operators\"\n  - \"pointer dereference operator overloading\"\n  - \"plus operator\"\nms.assetid: 7683ef08-42a4-4283-928f-d3dd4f3ab4c0\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overloading Unary Operators\nThe unary operators that can be overloaded are the following:  \n  \n1.  `!` ([logical NOT](../cpp/logical-negation-operator-exclpt.md))  \n  \n2.  `&` ([address-of](../cpp/address-of-operator-amp.md))  \n  \n3.  `~` ([one's complement](../cpp/one-s-complement-operator-tilde.md))  \n  \n4.  `*` ([pointer dereference](../cpp/indirection-operator-star.md))  \n  \n5.  `+` ([unary plus](../cpp/additive-operators-plus-and.md))  \n  \n6.  `-` ([unary negation](../cpp/additive-operators-plus-and.md))  \n  \n7.  `++` ([increment](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md))  \n  \n8.  `--` ([decrement](../cpp/prefix-increment-and-decrement-operators-increment-and-decrement.md))  \n  \n9. conversion operators  \n  \n The postfix increment and decrement operators (`++` and **––**) are treated separately in [Increment and Decrement](../cpp/increment-and-decrement-operator-overloading-cpp.md).  \n  \n Conversion operators are also discussed in a separate topic; see [User-Defined Type Conversions](../cpp/user-defined-type-conversions-cpp.md).  \n  \n The following rules are true of all other unary operators. To declare a unary operator function as a nonstatic member, you must declare it in the form:  \n  \n `ret-type operator` `op` `()`  \n  \n where `ret-type` is the return type and `op` is one of the operators listed in the preceding table.  \n  \n To declare a unary operator function as a global function, you must declare it in the form:  \n  \n `ret-type operator` `op` (`arg` )  \n  \n where `ret-type` and `op` are as described for member operator functions and the `arg` is an argument of class type on which to operate.  \n  \n> [!NOTE]\n>  There is no restriction on the return types of the unary operators. For example, it makes sense for logical NOT (`!`) to return an integral value, but this is not enforced.  \n  \n## See Also  \n [Operator Overloading](../cpp/operator-overloading.md)"}