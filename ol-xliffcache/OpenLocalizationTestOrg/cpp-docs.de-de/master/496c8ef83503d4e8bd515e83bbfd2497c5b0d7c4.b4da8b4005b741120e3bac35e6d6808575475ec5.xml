{"nodes":[{"pos":[12,77],"content":"Simplifying Data Access with Database Attributes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Simplifying Data Access with Database Attributes | Microsoft Docs","pos":[0,65]}]},{"content":"Simplifying Data Access with Database Attributes","pos":[1045,1093]},{"content":"This topic demonstrates the use of database attributes to simplify database operations.","pos":[1094,1181]},{"content":"The basic way to access information from a database is to create a command (or table) class and a user record class for a particular table in the database.","pos":[1188,1343]},{"content":"The database attributes simplify some of the template declarations that you previously had to do.","pos":[1344,1441]},{"content":"To demonstrate the use of database attributes, the following sections show two equivalent table and user record class declarations: the first uses attributes and the second uses OLE DB Templates.","pos":[1448,1643]},{"content":"Such declaration code is typically placed in a header file named for the table or command object, for example, Authors.h.","pos":[1644,1765]},{"content":"By comparing the two files, you can see how much simpler it is to use attributes.","pos":[1772,1853]},{"content":"Among the differences are:","pos":[1854,1880]},{"pos":[1890,2048],"content":"Using attributes, you only have to declare one class: <ph id=\"ph1\">`CAuthors`</ph>, while with templates you have to declare two: <ph id=\"ph2\">`CAuthorsNoAttrAccessor`</ph> and <ph id=\"ph3\">`CAuthorsNoAttr`</ph>.","source":"Using attributes, you only have to declare one class: `CAuthors`, while with templates you have to declare two: `CAuthorsNoAttrAccessor` and `CAuthorsNoAttr`."},{"pos":[2058,2178],"content":"The <ph id=\"ph1\">`db_source`</ph> call in the attributed version is equivalent to the <ph id=\"ph2\">`OpenDataSource()`</ph> call in the template declaration.","source":"The `db_source` call in the attributed version is equivalent to the `OpenDataSource()` call in the template declaration."},{"pos":[2188,2288],"content":"The <bpt id=\"p1\">**</bpt>db_table<ept id=\"p1\">**</ept> call in the attributed version is equivalent to the following template declaration:","source":"The **db_table** call in the attributed version is equivalent to the following template declaration:"},{"pos":[2400,2555],"content":"The <bpt id=\"p1\">**</bpt>db_column<ept id=\"p1\">**</ept> calls in the attributed version are equivalent to the column map (see <ph id=\"ph1\">`BEGIN_COLUMN_MAP ... END_COLUMN_MAP`</ph>) in the template declaration.","source":"The **db_column** calls in the attributed version are equivalent to the column map (see `BEGIN_COLUMN_MAP ... END_COLUMN_MAP`) in the template declaration."},{"content":"The attributes inject a user record class declaration for you.","pos":[2562,2624]},{"content":"The user record class is equivalent to <ph id=\"ph1\">`CAuthorsNoAttrAccessor`</ph> in the template declaration.","pos":[2625,2717],"source":" The user record class is equivalent to `CAuthorsNoAttrAccessor` in the template declaration."},{"content":"If your table class is <ph id=\"ph1\">`CAuthors`</ph>, the injected user record class is named <ph id=\"ph2\">`CAuthorsAccessor`</ph>, and you can only view its declaration in injected code.","pos":[2718,2868],"source":" If your table class is `CAuthors`, the injected user record class is named `CAuthorsAccessor`, and you can only view its declaration in injected code."},{"content":"For more information, see \"Attribute-Injected User Record Classes\" in <bpt id=\"p1\">[</bpt>User Records<ept id=\"p1\">](../../data/oledb/user-records.md)</ept>.","pos":[2869,2988],"source":" For more information, see \"Attribute-Injected User Record Classes\" in [User Records](../../data/oledb/user-records.md)."},{"pos":[2995,3115],"content":"Note that in both the attributed and the templated code, you must set rowset properties using <ph id=\"ph1\">`CDBPropSet::AddProperty`</ph>.","source":"Note that in both the attributed and the templated code, you must set rowset properties using `CDBPropSet::AddProperty`."},{"pos":[3122,3262],"content":"For information about the attributes discussed in this topic, see <bpt id=\"p1\">[</bpt>OLE DB Consumer Attributes<ept id=\"p1\">](../../windows/ole-db-consumer-attributes.md)</ept>.","source":"For information about the attributes discussed in this topic, see [OLE DB Consumer Attributes](../../windows/ole-db-consumer-attributes.md)."},{"content":"Table and Accessor Declaration Using Attributes","pos":[3271,3318]},{"content":"The following code calls <ph id=\"ph1\">`db_source`</ph> and <bpt id=\"p1\">**</bpt>db_table<ept id=\"p1\">**</ept> on the table class.","pos":[3322,3395],"source":"The following code calls `db_source` and **db_table** on the table class."},{"content":"specifies the data source and connection to be used.","pos":[3408,3460]},{"content":"<bpt id=\"p1\">**</bpt>db_table<ept id=\"p1\">**</ept> injects the appropriate template code to declare a table class.","pos":[3461,3537],"source":"**db_table** injects the appropriate template code to declare a table class."},{"content":"<bpt id=\"p1\">**</bpt>db_column<ept id=\"p1\">**</ept> specify the column map and inject the accessor declaration.","pos":[3538,3611],"source":"**db_column** specify the column map and inject the accessor declaration."},{"content":"You can use OLE DB consumer attributes in any project that supports ATL.","pos":[3612,3684]},{"content":"Here is the table and accessor declaration using attributes:","pos":[3691,3751]},{"content":"Table and Accessor Declaration Using Templates","pos":[4902,4948]},{"content":"Here is the table and accessor declaration using templates.","pos":[4952,5011]},{"content":"See Also","pos":[7817,7825]},{"content":"OLE DB Consumer Attributes","pos":[7830,7856]},{"content":"Attributes Walkthroughs","pos":[7908,7931]}],"content":"---\ntitle: \"Simplifying Data Access with Database Attributes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-attr.db_param\"\n  - \"vc-attr.db_column\"\n  - \"vc-attr.db_accessor\"\n  - \"vc-attr.db_command\"\n  - \"vc-attr.db_table\"\n  - \"vc-attr.db_source\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"attributes [C++], database\"\n  - \"attributes [C++], data access\"\n  - \"databases [C++], attributes\"\n  - \"data [C++], simplifying access\"\n  - \"data access [C++], database attributes\"\n  - \"database attributes [C++]\"\n  - \"OLE DB consumers [C++], database attributes\"\n  - \"attributes [C++], OLE DB consumer\"\nms.assetid: 560d2456-e307-4cb7-ba7b-4d0ed674697f\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Simplifying Data Access with Database Attributes\nThis topic demonstrates the use of database attributes to simplify database operations.  \n  \n The basic way to access information from a database is to create a command (or table) class and a user record class for a particular table in the database. The database attributes simplify some of the template declarations that you previously had to do.  \n  \n To demonstrate the use of database attributes, the following sections show two equivalent table and user record class declarations: the first uses attributes and the second uses OLE DB Templates. Such declaration code is typically placed in a header file named for the table or command object, for example, Authors.h.  \n  \n By comparing the two files, you can see how much simpler it is to use attributes. Among the differences are:  \n  \n-   Using attributes, you only have to declare one class: `CAuthors`, while with templates you have to declare two: `CAuthorsNoAttrAccessor` and `CAuthorsNoAttr`.  \n  \n-   The `db_source` call in the attributed version is equivalent to the `OpenDataSource()` call in the template declaration.  \n  \n-   The **db_table** call in the attributed version is equivalent to the following template declaration:  \n  \n    ```  \n    class CAuthorsNoAttr : public CTable<CAccessor<CAuthorsNoAttrAccessor> >  \n    ```  \n  \n-   The **db_column** calls in the attributed version are equivalent to the column map (see `BEGIN_COLUMN_MAP ... END_COLUMN_MAP`) in the template declaration.  \n  \n The attributes inject a user record class declaration for you. The user record class is equivalent to `CAuthorsNoAttrAccessor` in the template declaration. If your table class is `CAuthors`, the injected user record class is named `CAuthorsAccessor`, and you can only view its declaration in injected code. For more information, see \"Attribute-Injected User Record Classes\" in [User Records](../../data/oledb/user-records.md).  \n  \n Note that in both the attributed and the templated code, you must set rowset properties using `CDBPropSet::AddProperty`.  \n  \n For information about the attributes discussed in this topic, see [OLE DB Consumer Attributes](../../windows/ole-db-consumer-attributes.md).  \n  \n## Table and Accessor Declaration Using Attributes  \n The following code calls `db_source` and **db_table** on the table class. `db_source` specifies the data source and connection to be used. **db_table** injects the appropriate template code to declare a table class. **db_column** specify the column map and inject the accessor declaration. You can use OLE DB consumer attributes in any project that supports ATL.  \n  \n Here is the table and accessor declaration using attributes:  \n  \n```  \n//////////////////////////////////////////////////////////////////////  \n// Table and accessor declaration using attributes  \n// authors.h  \n//////////////////////////////////////////////////////////////////////  \n  \n// Table class declaration  \n// (Note that you must provide your own connection string for db_source.)  \n[  \n   db_source(L\"your connection string\"),  \n   db_table(\"Authors\")  \n]  \nclass CAuthors  \n{  \npublic:  \n   DWORD m_dwAuIDStatus;  \n   DWORD m_dwAuthorStatus;  \n   DWORD m_dwYearBornStatus;  \n   DWORD m_dwAuIDLength;  \n   DWORD m_dwAuthorLength;  \n   DWORD m_dwYearBornLength;  \n   [ db_column(1, status=m_dwAuIDStatus, length=m_dwAuIDLength) ] LONG m_AuID;  \n   [ db_column(2, status=m_dwAuthorStatus, length=m_dwAuthorLength) ] TCHAR m_Author[51];  \n   [ db_column(3, status=m_dwYearBornStatus, length=m_dwYearBornLength) ] SHORT m_YearBorn;  \n   void GetRowsetProperties(CDBPropSet* pPropSet)  \n   {  \n      pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true);  \n      pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true);  \n      pPropSet->AddProperty(DBPROP_IRowsetChange, true);  \n   }  \n};  \n```  \n  \n## Table and Accessor Declaration Using Templates  \n Here is the table and accessor declaration using templates.  \n  \n```  \n//////////////////////////////////////////////////////////////////////  \n// Table and user record class declaration using templates  \n// authors.h  \n//////////////////////////////////////////////////////////////////////  \n  \n// User record class declaration  \nclass CAuthorsNoAttrAccessor  \n{  \npublic:  \n   DWORD m_dwAuIDStatus;  \n   DWORD m_dwAuthorStatus;  \n   DWORD m_dwYearBornStatus;  \n   DWORD m_dwAuIDLength;  \n   DWORD m_dwAuthorLength;  \n   DWORD m_dwYearBornLength;  \n   LONG m_AuID;  \n   TCHAR m_Author[51];  \n   SHORT m_YearBorn;  \n   void GetRowsetProperties(CDBPropSet* pPropSet)  \n   {  \n      pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true);  \n      pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true);  \n      pPropSet->AddProperty(DBPROP_IRowsetChange, true);  \n   }  \n   HRESULT OpenDataSource()  \n   {  \n      CDataSource _db;  \n      HRESULT hr;  \n      hr = _db.OpenFromInitializationString(L\"your connection string\");  \n      if (FAILED(hr))  \n      {  \n#ifdef _DEBUG  \n         AtlTraceErrorRecords(hr);  \n#endif  \n         return hr;  \n      }  \n      return m_session.Open(_db);  \n   }  \n   void CloseDataSource()  \n   {  \n      m_session.Close();  \n   }  \n   operator const CSession&()  \n   {  \n      return m_session;  \n   }  \n   CSession m_session;  \n   BEGIN_COLUMN_MAP(CAuthorsNoAttrAccessor)  \n      COLUMN_ENTRY_LENGTH_STATUS(1, m_AuID, m_dwAuIDLength, m_dwAuIDStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(2, m_Author, m_dwAuthorLength, m_dwAuthorStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(3, m_YearBorn, m_dwYearBornLength, m_dwYearBornStatus)  \n   END_COLUMN_MAP()  \n};  \nclass CAuthorsNoAttr : public CTable<CAccessor<CAuthorsNoAttrAccessor> >  \n{  \npublic:  \n   HRESULT OpenAll()  \n   {  \n      HRESULT hr;  \n      hr = OpenDataSource();  \n      if (FAILED(hr))  \n         return hr;  \n      __if_exists(GetRowsetProperties)  \n      {  \n         CDBPropSet propset(DBPROPSET_ROWSET);  \n         __if_exists(HasBookmark)  \n         {  \n            propset.AddProperty(DBPROP_IRowsetLocate, true);  \n         }  \n         GetRowsetProperties(&propset);  \n         return OpenRowset(&propset);  \n      }  \n      __if_not_exists(GetRowsetProperties)  \n      {  \n         __if_exists(HasBookmark)  \n         {  \n            CDBPropSet propset(DBPROPSET_ROWSET);  \n            propset.AddProperty(DBPROP_IRowsetLocate, true);  \n            return OpenRowset(&propset);  \n         }  \n      }  \n      return OpenRowset();  \n   }  \n   HRESULT OpenRowset(DBPROPSET *pPropSet = NULL)  \n   {  \n      HRESULT hr = Open(m_session, \"Authors\", pPropSet);  \n#ifdef _DEBUG  \n      if(FAILED(hr))  \n         AtlTraceErrorRecords(hr);  \n#endif  \n      return hr;  \n   }  \n   void CloseAll()  \n   {  \n      Close();  \n      CloseDataSource();  \n   }  \n};  \n```  \n  \n## See Also  \n [OLE DB Consumer Attributes](../../windows/ole-db-consumer-attributes.md)   \n [Attributes Walkthroughs](http://msdn.microsoft.com/en-us/73df1d5d-261a-4521-98fb-06dcbf5ec0d0)"}