{"nodes":[{"pos":[12,42],"content":"CLR Enum Type | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CLR Enum Type | Microsoft Docs","pos":[0,30]}]},{"content":"CLR Enum Type","pos":[633,646]},{"pos":[647,804],"content":"The declaration and behavior of enums has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The declaration and behavior of enums has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"The Managed Extensions enum declaration is preceded by the <ph id=\"ph1\">`__value`</ph> keyword.","pos":[811,888],"source":"The Managed Extensions enum declaration is preceded by the `__value` keyword."},{"content":"The idea here is to distinguish the native enum from the CLR enum which is derived from <ph id=\"ph1\">`System::ValueType`</ph>, while suggesting an analogous functionality.","pos":[889,1042],"source":" The idea here is to distinguish the native enum from the CLR enum which is derived from `System::ValueType`, while suggesting an analogous functionality."},{"content":"For example:","pos":[1043,1055]},{"content":"The new syntax solves the problem of distinguishing native and CLR enums by emphasizing the class nature of the latter rather than its value type roots.","pos":[1206,1358]},{"content":"As such, the <ph id=\"ph1\">`__value`</ph> keyword is discarded, replaced with the spaced keyword pair of <ph id=\"ph2\">`enum class`</ph>.","pos":[1359,1458],"source":" As such, the `__value` keyword is discarded, replaced with the spaced keyword pair of `enum class`."},{"content":"This provides a paired keyword symmetry to the declarations of the reference, value, and interface classes:","pos":[1459,1566]},{"pos":[1661,1750],"content":"The translation of the enumeration pair <ph id=\"ph1\">`e1`</ph> and <ph id=\"ph2\">`e2`</ph> in the new syntax looks as follows:","source":"The translation of the enumeration pair `e1` and `e2` in the new syntax looks as follows:"},{"content":"Apart from this small syntactic change, the behavior of the CLR enum type has been changed in a number of ways:","pos":[1895,2006]},{"content":"A forward declaration of a CLR enum is no longer supported.","pos":[2016,2075]},{"content":"There is no mapping.","pos":[2076,2096]},{"content":"It is simply flagged as a compile-time error.","pos":[2097,2142]},{"content":"The overload resolution between the built-in arithmetic types and the <ph id=\"ph1\">`Object`</ph> class hierarchy has reversed between the two language versions!","pos":[2260,2402],"source":"The overload resolution between the built-in arithmetic types and the `Object` class hierarchy has reversed between the two language versions!"},{"content":"As a side-effect, CLR enums are no longer implicitly converted to arithmetic types.","pos":[2403,2486]},{"content":"In the new syntax, a CLR enum maintains its own scope, which is not the case in Managed Extensions.","pos":[2496,2595]},{"content":"Previously, the enumerators were visible within the containing scope of the enum.","pos":[2596,2677]},{"content":"Now, the enumerators are encapsulated within the scope of the enum.","pos":[2678,2745]},{"content":"CLR Enums are a Kind of Object","pos":[2754,2784]},{"content":"Consider the following code fragment:","pos":[2788,2825]},{"content":"For the native C++ programmer, the natural answer to the question of which instance of the overloaded <ph id=\"ph1\">`f()`</ph> is invoked is that of <ph id=\"ph2\">`f(int)`</ph>.","pos":[3088,3227],"source":"For the native C++ programmer, the natural answer to the question of which instance of the overloaded `f()` is invoked is that of `f(int)`."},{"content":"An enum is a symbolic integral constant, and it participates in the standard integral promotions which take precedence in this case.","pos":[3228,3360]},{"content":"And in fact in Managed Extensions this was the instance to which the call resolves.","pos":[3362,3445]},{"content":"This caused a number of surprises – not when we used them in a native C++ frame of mind – but when we needed them to interact with the existing BCL (Base Class Library) framework, where an <ph id=\"ph1\">`Enum`</ph> is a class indirectly derived from <ph id=\"ph2\">`Object`</ph>.","pos":[3446,3686],"source":" This caused a number of surprises – not when we used them in a native C++ frame of mind – but when we needed them to interact with the existing BCL (Base Class Library) framework, where an `Enum` is a class indirectly derived from `Object`."},{"content":"In the <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph> language design, the instance of <ph id=\"ph2\">`f()`</ph> invoked is that of <ph id=\"ph3\">`f(Object^)`</ph>.","pos":[3687,3837],"source":" In the [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] language design, the instance of `f()` invoked is that of `f(Object^)`."},{"content":"The way <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph> has chosen to enforce this is to not support implicit conversions between a CLR enum type and the arithmetic types.","pos":[3844,4039],"source":"The way [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] has chosen to enforce this is to not support implicit conversions between a CLR enum type and the arithmetic types."},{"content":"This means that any assignment of an object of a CLR enum type to an arithmetic type will require an explicit cast.","pos":[4040,4155]},{"content":"So, for example, given","pos":[4156,4178]},{"content":"as a non-overloaded method, in Managed Extensions, the call","pos":[4217,4276]},{"content":"is ok, and the value contained within <ph id=\"ph1\">`rslt`</ph> is implicitly converted into an integer value.","pos":[4356,4447],"source":"is ok, and the value contained within `rslt` is implicitly converted into an integer value."},{"content":"In <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>, this call fails to compile.","pos":[4448,4551],"source":" In [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], this call fails to compile."},{"content":"To correctly translate it, we must insert a conversion operator:","pos":[4552,4616]},{"content":"The Scope of the CLR Enum Type","pos":[4688,4718]},{"content":"One of the changes between the C and C++ languages was the addition in C++ of scope within the struct facility.","pos":[4722,4833]},{"content":"In C, a struct is just a data aggregate without support of either an interface or an associated scope.","pos":[4834,4936]},{"content":"This was quite a radical change at the time and was a contentious issue for many new C++ users coming from the C language.","pos":[4937,5059]},{"content":"The relationship between the native and CLR enum is analogous.","pos":[5060,5122]},{"content":"In Managed Extensions, an attempt was made to define weakly injected names for the enumerators of a CLR enum in order to simulate the absence of scope within the native enum.","pos":[5129,5303]},{"content":"This did not prove successful.","pos":[5304,5334]},{"content":"The problem is that this causes the enumerators to spill into the global namespace, resulting in difficult to manage name-collisions.","pos":[5335,5468]},{"content":"In the new syntax, we have conformed to the other CLR languages in supporting scopes within the CLR enum.","pos":[5469,5574]},{"content":"This means that any unqualified use of an enumerator of a CLR enum will not be recognized by the new syntax.","pos":[5581,5689]},{"content":"Let's look at a real-world example.","pos":[5690,5725]},{"content":"Each of the three unqualified uses of the enumerator names (<ph id=\"ph1\">`(1)`</ph>, <ph id=\"ph2\">`(2)`</ph>, and <ph id=\"ph3\">`(3)`</ph>) will need to be qualified in the translation to the new syntax in order for the source code to compile.","pos":[6572,6760],"source":"Each of the three unqualified uses of the enumerator names (`(1)`, `(2)`, and `(3)`) will need to be qualified in the translation to the new syntax in order for the source code to compile."},{"content":"Here is a correct translation of the original source code:","pos":[6761,6819]},{"content":"This changes the design strategy between a native and a CLR enum.","pos":[7590,7655]},{"content":"With a CLR enum maintaining an associated scope in <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>, it is neither necessary nor effective to encapsulate the declaration of the enum within a class.","pos":[7656,7876],"source":" With a CLR enum maintaining an associated scope in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], it is neither necessary nor effective to encapsulate the declaration of the enum within a class."},{"content":"This idiom evolved around the time of cfront 2.0 within Bell Laboratories also in order to solve the global name pollution problem.","pos":[7877,8008]},{"content":"In the original beta release of the new iostream library by Jerry Schwarz at Bell Laboratories, Jerry did not encapsulate all the associated enums defined for the library, and the common enumerators such as <ph id=\"ph1\">`read`</ph>, <ph id=\"ph2\">`write`</ph>, <ph id=\"ph3\">`append`</ph>, and so on, made it nearly impossible for users to compile their existing code.","pos":[8015,8327],"source":"In the original beta release of the new iostream library by Jerry Schwarz at Bell Laboratories, Jerry did not encapsulate all the associated enums defined for the library, and the common enumerators such as `read`, `write`, `append`, and so on, made it nearly impossible for users to compile their existing code."},{"content":"One solution would have been to mangle the names, such as <ph id=\"ph1\">`io_read`</ph>, <ph id=\"ph2\">`io_write`</ph>, etc. A second solution would have been to modify the language by adding scope to an enum, but this was not practicable at the time.","pos":[8328,8540],"source":" One solution would have been to mangle the names, such as `io_read`, `io_write`, etc. A second solution would have been to modify the language by adding scope to an enum, but this was not practicable at the time."},{"content":"The middle solution was to encapsulate the enum within the class, or class hierarchy, where both the tag name and enumerators of the enum populate the enclosing class scope.) That is, the motivation for placing enums within classes, at least originally, was not philosophical, but a practical response to the global name-space pollution problem.","pos":[8541,8886]},{"content":"With the <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph> enum, there is no longer any compelling benefit to encapsulating an enum within a class.","pos":[8893,9062],"source":"With the [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] enum, there is no longer any compelling benefit to encapsulating an enum within a class."},{"content":"In fact, if you look at the <ph id=\"ph1\">`System`</ph> namespaces, you will see that enums, classes, and interfaces all inhabit the same declaration space.","pos":[9063,9200],"source":" In fact, if you look at the `System` namespaces, you will see that enums, classes, and interfaces all inhabit the same declaration space."},{"content":"See Also","pos":[9209,9217]},{"content":"Value Types and Their Behaviors (C++/CLI)","pos":[9222,9263]},{"content":"enum class","pos":[9324,9334]}],"content":"---\ntitle: \"CLR Enum Type | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"scope, of CLR enum\"\n  - \"enum struct keyword [C++]\"\n  - \"enum class keyword [C++]\"\nms.assetid: 4541d952-97bb-4e35-a7f8-d14f5f6a6606\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CLR Enum Type\nThe declaration and behavior of enums has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n The Managed Extensions enum declaration is preceded by the `__value` keyword. The idea here is to distinguish the native enum from the CLR enum which is derived from `System::ValueType`, while suggesting an analogous functionality. For example:  \n  \n```  \n__value enum e1 { fail, pass };  \npublic __value enum e2 : unsigned short  {   \n   not_ok = 1024,   \n   maybe, ok = 2048   \n};  \n```  \n  \n The new syntax solves the problem of distinguishing native and CLR enums by emphasizing the class nature of the latter rather than its value type roots. As such, the `__value` keyword is discarded, replaced with the spaced keyword pair of `enum class`. This provides a paired keyword symmetry to the declarations of the reference, value, and interface classes:  \n  \n```  \nenum class ec;  \nvalue class vc;  \nref class rc;  \ninterface class ic;  \n```  \n  \n The translation of the enumeration pair `e1` and `e2` in the new syntax looks as follows:  \n  \n```  \nenum class e1 { fail, pass };  \npublic enum class e2 : unsigned short {   \n   not_ok = 1024,  \n   maybe, ok = 2048   \n};  \n```  \n  \n Apart from this small syntactic change, the behavior of the CLR enum type has been changed in a number of ways:  \n  \n-   A forward declaration of a CLR enum is no longer supported. There is no mapping. It is simply flagged as a compile-time error.  \n  \n```  \n__value enum status; // Managed Extensions: ok  \nenum class status;   // new syntax: error  \n```  \n  \n-   The overload resolution between the built-in arithmetic types and the `Object` class hierarchy has reversed between the two language versions! As a side-effect, CLR enums are no longer implicitly converted to arithmetic types.  \n  \n-   In the new syntax, a CLR enum maintains its own scope, which is not the case in Managed Extensions. Previously, the enumerators were visible within the containing scope of the enum. Now, the enumerators are encapsulated within the scope of the enum.  \n  \n## CLR Enums are a Kind of Object  \n Consider the following code fragment:  \n  \n```  \n__value enum status { fail, pass };  \n  \nvoid f( Object* ){ Console::WriteLine(\"f(Object)\\n\"); }  \nvoid f( int ){ Console::WriteLine(\"f(int)\\n\"); }  \n  \nint main()  \n{  \n   status rslt = fail;  \n  \n   f( rslt ); // which f is invoked?  \n}  \n```  \n  \n For the native C++ programmer, the natural answer to the question of which instance of the overloaded `f()` is invoked is that of `f(int)`. An enum is a symbolic integral constant, and it participates in the standard integral promotions which take precedence in this case.  And in fact in Managed Extensions this was the instance to which the call resolves. This caused a number of surprises – not when we used them in a native C++ frame of mind – but when we needed them to interact with the existing BCL (Base Class Library) framework, where an `Enum` is a class indirectly derived from `Object`. In the [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] language design, the instance of `f()` invoked is that of `f(Object^)`.  \n  \n The way [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] has chosen to enforce this is to not support implicit conversions between a CLR enum type and the arithmetic types. This means that any assignment of an object of a CLR enum type to an arithmetic type will require an explicit cast. So, for example, given  \n  \n```  \nvoid f( int );  \n```  \n  \n as a non-overloaded method, in Managed Extensions, the call  \n  \n```  \nf( rslt ); // ok: Managed Extensions; error: new syntax  \n```  \n  \n is ok, and the value contained within `rslt` is implicitly converted into an integer value. In [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], this call fails to compile. To correctly translate it, we must insert a conversion operator:  \n  \n```  \nf( safe_cast<int>( rslt )); // ok: new syntax  \n```  \n  \n## The Scope of the CLR Enum Type  \n One of the changes between the C and C++ languages was the addition in C++ of scope within the struct facility. In C, a struct is just a data aggregate without support of either an interface or an associated scope. This was quite a radical change at the time and was a contentious issue for many new C++ users coming from the C language. The relationship between the native and CLR enum is analogous.  \n  \n In Managed Extensions, an attempt was made to define weakly injected names for the enumerators of a CLR enum in order to simulate the absence of scope within the native enum. This did not prove successful. The problem is that this causes the enumerators to spill into the global namespace, resulting in difficult to manage name-collisions. In the new syntax, we have conformed to the other CLR languages in supporting scopes within the CLR enum.  \n  \n This means that any unqualified use of an enumerator of a CLR enum will not be recognized by the new syntax. Let's look at a real-world example.  \n  \n```  \n// Managed Extensions supporting weak injection  \n__gc class XDCMake {  \npublic:  \n   __value enum _recognizerEnum {   \n      UNDEFINED,  \n      OPTION_USAGE,   \n      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,  \n      XDC0002_ERR_CANNOT_WRITE_TO = 2,  \n      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,  \n      XDC0004_WRN_XML_LOAD_FAILURE = 4,  \n      XDC0006_WRN_NONEXISTENT_FILES = 6,  \n   };  \n  \n   ListDictionary* optionList;  \n   ListDictionary* itagList;  \n  \n   XDCMake() {  \n      optionList = new ListDictionary;  \n  \n      // here are the problems …  \n      optionList->Add(S\"?\", __box(OPTION_USAGE)); // (1)  \n      optionList->Add(S\"help\", __box(OPTION_USAGE)); // (2)  \n  \n      itagList = new ListDictionary;  \n      itagList->Add(S\"returns\",   \n         __box(XDC0004_WRN_XML_LOAD_FAILURE)); // (3)  \n   }  \n};  \n```  \n  \n Each of the three unqualified uses of the enumerator names (`(1)`, `(2)`, and `(3)`) will need to be qualified in the translation to the new syntax in order for the source code to compile. Here is a correct translation of the original source code:  \n  \n```  \nref class XDCMake {  \npublic:  \n   enum class _recognizerEnum {  \n      UNDEFINED, OPTION_USAGE,   \n      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,  \n      XDC0002_ERR_CANNOT_WRITE_TO = 2,  \n      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,  \n      XDC0004_WRN_XML_LOAD_FAILURE = 4,  \n      XDC0006_WRN_NONEXISTENT_FILES = 6  \n   };  \n  \n   ListDictionary^ optionList;  \n   ListDictionary^ itagList;  \n  \n   XDCMake() {  \n      optionList = gcnew ListDictionary;  \n      optionList->Add(\"?\",_recognizerEnum::OPTION_USAGE); // (1)  \n      optionList->Add(\"help\",_recognizerEnum::OPTION_USAGE); //(2)  \n      itagList = gcnew ListDictionary;  \n      itagList->Add( \"returns\",   \n         _recognizerEnum::XDC0004_WRN_XML_LOAD_FAILURE); //(3)  \n   }  \n};  \n```  \n  \n This changes the design strategy between a native and a CLR enum. With a CLR enum maintaining an associated scope in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], it is neither necessary nor effective to encapsulate the declaration of the enum within a class. This idiom evolved around the time of cfront 2.0 within Bell Laboratories also in order to solve the global name pollution problem.  \n  \n In the original beta release of the new iostream library by Jerry Schwarz at Bell Laboratories, Jerry did not encapsulate all the associated enums defined for the library, and the common enumerators such as `read`, `write`, `append`, and so on, made it nearly impossible for users to compile their existing code. One solution would have been to mangle the names, such as `io_read`, `io_write`, etc. A second solution would have been to modify the language by adding scope to an enum, but this was not practicable at the time. The middle solution was to encapsulate the enum within the class, or class hierarchy, where both the tag name and enumerators of the enum populate the enclosing class scope.) That is, the motivation for placing enums within classes, at least originally, was not philosophical, but a practical response to the global name-space pollution problem.  \n  \n With the [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] enum, there is no longer any compelling benefit to encapsulating an enum within a class. In fact, if you look at the `System` namespaces, you will see that enums, classes, and interfaces all inhabit the same declaration space.  \n  \n## See Also  \n [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   \n [enum class](../windows/enum-class-cpp-component-extensions.md)"}