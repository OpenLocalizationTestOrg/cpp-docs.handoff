{"nodes":[{"pos":[12,61],"content":"_bittestandset, _bittestandset64 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_bittestandset, _bittestandset64 | Microsoft Docs","pos":[0,49]}]},{"content":"_bittestandset, _bittestandset64","pos":[760,792]},{"content":"Microsoft Specific","pos":[795,813]},{"pos":[822,938],"content":"Generate an instruction which examines bit <ph id=\"ph1\">`b`</ph> of the address <ph id=\"ph2\">`a`</ph>, returns its current value, and sets the bit to 1.","source":"Generate an instruction which examines bit `b` of the address `a`, returns its current value, and sets the bit to 1."},{"content":"Syntax","pos":[947,953]},{"content":"Parameters","pos":[1113,1123]},{"content":"[in, out]","pos":[1127,1136]},{"content":"A pointer to the memory to examine.","pos":[1144,1179]},{"content":"[in]","pos":[1186,1190]},{"content":"The bit position to test.","pos":[1198,1223]},{"content":"Return Value","pos":[1232,1244]},{"content":"The bit at the position specified.","pos":[1248,1282]},{"content":"Requirements","pos":[1291,1303]},{"content":"Intrinsic","pos":[1310,1319]},{"content":"Architecture","pos":[1320,1332]},{"pos":[1393,1402],"content":"x86, ARM,"},{"pos":[1561,1588],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1597,1604]},{"content":"This routine is only available as an intrinsic.","pos":[1608,1655]},{"content":"Example","pos":[1664,1671]},{"content":"END Microsoft Specific","pos":[3581,3603]},{"content":"See Also","pos":[3612,3620]},{"content":"Compiler Intrinsics","pos":[3625,3644]}],"content":"---\ntitle: \"_bittestandset, _bittestandset64 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_bittestandset_cpp\"\n  - \"_bittestandset64_cpp\"\n  - \"_bittestandset64\"\n  - \"_bittestandset\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"bts instruction\"\n  - \"_bittestandset intrinsic\"\n  - \"_bittestandset64 intrinsic\"\nms.assetid: 6d6c8670-fea0-4c1c-9aad-2bb842715203\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _bittestandset, _bittestandset64\n**Microsoft Specific**  \n  \n Generate an instruction which examines bit `b` of the address `a`, returns its current value, and sets the bit to 1.  \n  \n## Syntax  \n  \n```  \nunsigned char _bittestandset(  \n   long *a,  \n   long b  \n);  \nunsigned char _bittestandset64(  \n   __int64 *a,  \n   __int64 b  \n);  \n```  \n  \n#### Parameters  \n [in, out] `a`  \n A pointer to the memory to examine.  \n  \n [in] `b`  \n The bit position to test.  \n  \n## Return Value  \n The bit at the position specified.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`_bittestandset`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n|`_bittestandset64`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n This routine is only available as an intrinsic.  \n  \n## Example  \n  \n```  \n// bittestandset.cpp  \n// processor: x86, ARM, x64  \n// This example uses several of the _bittest family of intrinsics  \n// to implement a Flags class that allows bit level access to an  \n// integer field.  \n#include <stdio.h>  \n#include <intrin.h>  \n  \n#pragma intrinsic(_bittestandset, _bittestandreset,\\  \n                  _bittestandcomplement, _bittest)  \n  \nclass Flags  \n{  \nprivate:  \n    long flags;  \n    long* oldValues;  \n  \npublic:  \n    Flags() : flags(0)  \n    {  \n        oldValues = new long[32];  \n    }  \n  \n    ~Flags()  \n    {  \n        delete oldValues;  \n    }  \n  \n    void SetFlagBit(long nBit)  \n    {  \n        // We omit range checks on the argument  \n        oldValues[nBit] = _bittestandset(&flags, nBit);  \n        printf_s(\"Flags: 0x%x\\n\", flags);  \n    }  \n    void ClearFlagBit(long nBit)  \n    {  \n        oldValues[nBit] = _bittestandreset(&flags, nBit);  \n        printf_s(\"Flags: 0x%x\\n\", flags);  \n    }  \n    unsigned char GetFlagBit(long nBit)  \n    {  \n        unsigned char result = _bittest(&flags, nBit);  \n        printf_s(\"Flags: 0x%x\\n\", flags);  \n        return result;  \n    }  \n    void RestoreFlagBit(long nBit)  \n    {  \n        if (oldValues[nBit])  \n            oldValues[nBit] = _bittestandset(&flags, nBit);  \n        else  \n            oldValues[nBit] = _bittestandreset(&flags, nBit);  \n        printf_s(\"Flags: 0x%x\\n\", flags);       \n    }  \n    unsigned char ToggleBit(long nBit)  \n    {  \n        unsigned char result = _bittestandcomplement(&flags, nBit);  \n        printf_s(\"Flags: 0x%x\\n\", flags);  \n        return result;  \n    }  \n};  \n  \nint main()  \n{  \n    Flags f;  \n    f.SetFlagBit(1);  \n    f.SetFlagBit(2);  \n    f.SetFlagBit(3);  \n    f.ClearFlagBit(3);  \n    f.ToggleBit(1);  \n    f.RestoreFlagBit(2);  \n}  \n```  \n  \n```Output  \nFlags: 0x2  \nFlags: 0x6  \nFlags: 0xe  \nFlags: 0x6  \nFlags: 0x4  \nFlags: 0x0  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}