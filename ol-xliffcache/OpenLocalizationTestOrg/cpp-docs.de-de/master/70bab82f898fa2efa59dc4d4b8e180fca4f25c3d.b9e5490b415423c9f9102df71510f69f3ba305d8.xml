{"nodes":[{"pos":[12,64],"content":"partial  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"partial  (C++ Component Extensions) | Microsoft Docs","pos":[0,52]}]},{"content":"partial  (C++ Component Extensions)","pos":[670,705]},{"pos":[706,826],"content":"The <ph id=\"ph1\">`partial`</ph> keyword enables different parts of the same ref class to be authored independently and in different files.","source":"The `partial` keyword enables different parts of the same ref class to be authored independently and in different files."},{"content":"All Runtimes","pos":[835,847]},{"pos":[851,948],"content":"(This language feature applies only to the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.)","source":"(This language feature applies only to the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].)"},{"content":"For a ref class that has two partial definitions, the <ph id=\"ph1\">`partial`</ph> keyword is applied to the first occurrence of the definition, and this is typically done by auto-generated code, so that a human coder doesn’t use the keyword very often.","pos":[1013,1247],"source":"For a ref class that has two partial definitions, the `partial` keyword is applied to the first occurrence of the definition, and this is typically done by auto-generated code, so that a human coder doesn’t use the keyword very often."},{"content":"For all subsequent partial definitions of the class, omit the <ph id=\"ph1\">`partial`</ph> modifier from the <bpt id=\"p1\">*</bpt>class-key<ept id=\"p1\">*</ept> keyword and class identifier.","pos":[1248,1379],"source":" For all subsequent partial definitions of the class, omit the `partial` modifier from the *class-key* keyword and class identifier."},{"content":"When the compiler encounters a previously defined ref class and class identifier but no <ph id=\"ph1\">`partial`</ph> keyword, it internally combines all of the parts of the ref class definition into one definition.","pos":[1380,1575],"source":" When the compiler encounters a previously defined ref class and class identifier but no `partial` keyword, it internally combines all of the parts of the ref class definition into one definition."},{"content":"Syntax","pos":[1585,1591]},{"content":"Parameters","pos":[1943,1953]},{"content":"class-key","pos":[1958,1967]},{"content":"A keyword that declares a class or struct that is supported by the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.","pos":[1972,2092],"source":" A keyword that declares a class or struct that is supported by the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]."},{"content":"Either <ph id=\"ph1\">`ref class`</ph>, <ph id=\"ph2\">`value class`</ph>, <ph id=\"ph3\">`ref struct`</ph>, or <ph id=\"ph4\">`value struct`</ph>.","pos":[2093,2160],"source":" Either `ref class`, `value class`, `ref struct`, or `value struct`."},{"content":"identifier","pos":[2168,2178]},{"content":"The name of the defined type.","pos":[2183,2212]},{"content":"Remarks","pos":[2222,2229]},{"content":"A partial class supports scenarios where you modify one part of a class definition in one file, and automatic code-generating software—for example, the XAML designer—modifies code in the same class in another file.","pos":[2233,2447]},{"content":"By using a partial class, you can prevent the automatic code generator from overwriting your code.","pos":[2448,2546]},{"content":"In a Visual Studio project, the <ph id=\"ph1\">`partial`</ph> modifier is applied automatically to the generated file.","pos":[2547,2645],"source":" In a Visual Studio project, the `partial` modifier is applied automatically to the generated file."},{"content":"Contents: With two exceptions, a partial class definition can contain anything that the full class definition could contain if the <ph id=\"ph1\">`partial`</ph> keyword was omitted.","pos":[2652,2813],"source":"Contents: With two exceptions, a partial class definition can contain anything that the full class definition could contain if the `partial` keyword was omitted."},{"content":"However, you can't specify class accessibility (for example, <ph id=\"ph1\">`public partial class X {…};`</ph>),  or a <ph id=\"ph2\">`declspec`</ph>.","pos":[2814,2924],"source":" However, you can't specify class accessibility (for example, `public partial class X {…};`),  or a `declspec`."},{"content":"Access specifiers used in a partial class definition for <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> do not affect the default accessibility in a subsequent partial or full class definition for <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>.","pos":[2931,3107],"source":"Access specifiers used in a partial class definition for *identifier* do not affect the default accessibility in a subsequent partial or full class definition for *identifier*."},{"content":"Inline definitions of static data members are allowed.","pos":[3108,3162]},{"content":"Declaration: A partial definition of a class <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> only introduces the name <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>, but <bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept> cannot be used in a way that requires a class definition.","pos":[3169,3340],"source":"Declaration: A partial definition of a class *identifier* only introduces the name *identifier*, but *identifier* cannot be used in a way that requires a class definition."},{"content":"The name <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> can't be used to know the size of <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>, or to use a base or member of <bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept> until after the compiler encounters the full definition of <bpt id=\"p4\">*</bpt>identifier<ept id=\"p4\">*</ept>.","pos":[3341,3526],"source":" The name *identifier* can't be used to know the size of *identifier*, or to use a base or member of *identifier* until after the compiler encounters the full definition of *identifier*."},{"content":"Number and ordering: There can be zero or more partial class definitions for <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept>.","pos":[3533,3623],"source":"Number and ordering: There can be zero or more partial class definitions for *identifier*."},{"content":"Every partial class definition of <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> must lexically precede the one full definition of <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept> (if there is a full definition; otherwise, the class can't be used except as if forward-declared) but need not precede forward declarations of <bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept>.","pos":[3624,3890],"source":" Every partial class definition of *identifier* must lexically precede the one full definition of *identifier* (if there is a full definition; otherwise, the class can't be used except as if forward-declared) but need not precede forward declarations of *identifier*."},{"content":"All class-keys must match.","pos":[3891,3917]},{"pos":[3924,4190],"content":"Full definition: At the point of the full definition of the class <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept>, the behavior is the same as if the definition of <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept> had declared all base classes, members, etc. in the order in which they were encountered and defined in the partial classes.","source":"Full definition: At the point of the full definition of the class *identifier*, the behavior is the same as if the definition of *identifier* had declared all base classes, members, etc. in the order in which they were encountered and defined in the partial classes."},{"content":"Templates: A partial class cannot be a template.","pos":[4197,4245]},{"content":"Generics: A partial class can be a generic if the full definition could be generic.","pos":[4252,4335]},{"content":"But every partial and full class must have exactly the same generic parameters, including formal parameter names.","pos":[4336,4449]},{"pos":[4456,4597],"content":"For more information about how to use the <ph id=\"ph1\">`partial`</ph> keyword, see <bpt id=\"p1\">[</bpt>Partial Classes (C++/CX)<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=249023)</ept>.","source":"For more information about how to use the `partial` keyword, see [Partial Classes (C++/CX)](http://go.microsoft.com/fwlink/p/?LinkId=249023)."},{"content":"Requirements","pos":[4607,4619]},{"pos":[4623,4647],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[4656,4679]},{"content":"(This language feature does not apply to the Common Language Runtime.)","pos":[4683,4753]},{"content":"See Also","pos":[4762,4770]},{"content":"Partial Classes (C++/CX)","pos":[4775,4799]}],"content":"---\ntitle: \"partial  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"partial_CPP\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"partial\"\n  - \"C++/CX,partial\"\nms.assetid: 43adf1f5-10c5-44aa-a66f-7507e2bdabf8\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# partial  (C++ Component Extensions)\nThe `partial` keyword enables different parts of the same ref class to be authored independently and in different files.  \n  \n## All Runtimes  \n (This language feature applies only to the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].)  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n For a ref class that has two partial definitions, the `partial` keyword is applied to the first occurrence of the definition, and this is typically done by auto-generated code, so that a human coder doesn’t use the keyword very often. For all subsequent partial definitions of the class, omit the `partial` modifier from the *class-key* keyword and class identifier. When the compiler encounters a previously defined ref class and class identifier but no `partial` keyword, it internally combines all of the parts of the ref class definition into one definition.  \n  \n### Syntax  \n  \n```cpp  \n  \n      partial  \n      class-key  \n      identifier {  \n   /* The first part of the partial class definition. This is typically auto-generated*/  \n}  \n// ...  \nclass-keyidentifier {  \n   /* The subsequent part(s) of the class definition. The same identifier is specified, but the \"partial\" keyword is omitted. */  \n}  \n  \n```  \n  \n### Parameters  \n *class-key*  \n A keyword that declares a class or struct that is supported by the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]. Either `ref class`, `value class`, `ref struct`, or `value struct`.  \n  \n *identifier*  \n The name of the defined type.  \n  \n### Remarks  \n A partial class supports scenarios where you modify one part of a class definition in one file, and automatic code-generating software—for example, the XAML designer—modifies code in the same class in another file. By using a partial class, you can prevent the automatic code generator from overwriting your code. In a Visual Studio project, the `partial` modifier is applied automatically to the generated file.  \n  \n Contents: With two exceptions, a partial class definition can contain anything that the full class definition could contain if the `partial` keyword was omitted. However, you can't specify class accessibility (for example, `public partial class X {…};`),  or a `declspec`.  \n  \n Access specifiers used in a partial class definition for *identifier* do not affect the default accessibility in a subsequent partial or full class definition for *identifier*. Inline definitions of static data members are allowed.  \n  \n Declaration: A partial definition of a class *identifier* only introduces the name *identifier*, but *identifier* cannot be used in a way that requires a class definition. The name *identifier* can't be used to know the size of *identifier*, or to use a base or member of *identifier* until after the compiler encounters the full definition of *identifier*.  \n  \n Number and ordering: There can be zero or more partial class definitions for *identifier*. Every partial class definition of *identifier* must lexically precede the one full definition of *identifier* (if there is a full definition; otherwise, the class can't be used except as if forward-declared) but need not precede forward declarations of *identifier*. All class-keys must match.  \n  \n Full definition: At the point of the full definition of the class *identifier*, the behavior is the same as if the definition of *identifier* had declared all base classes, members, etc. in the order in which they were encountered and defined in the partial classes.  \n  \n Templates: A partial class cannot be a template.  \n  \n Generics: A partial class can be a generic if the full definition could be generic. But every partial and full class must have exactly the same generic parameters, including formal parameter names.  \n  \n For more information about how to use the `partial` keyword, see [Partial Classes (C++/CX)](http://go.microsoft.com/fwlink/p/?LinkId=249023).  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n (This language feature does not apply to the Common Language Runtime.)  \n  \n## See Also  \n [Partial Classes (C++/CX)](http://go.microsoft.com/fwlink/p/?LinkId=249023)"}