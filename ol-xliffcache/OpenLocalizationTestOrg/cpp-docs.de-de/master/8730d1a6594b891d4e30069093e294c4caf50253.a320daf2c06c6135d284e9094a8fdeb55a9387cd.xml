{"nodes":[{"pos":[12,86],"content":"Importing into an Application Using __declspec(dllimport) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Importing into an Application Using __declspec(dllimport) | Microsoft Docs","pos":[0,74]}]},{"content":"Importing into an Application Using __declspec(dllimport)","pos":[727,784]},{"content":"A program that uses public symbols defined by a DLL is said to import them.","pos":[785,860]},{"content":"When you create header files for applications that use your DLLs to build with, use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> on the declarations of the public symbols.","pos":[861,1013],"source":" When you create header files for applications that use your DLLs to build with, use **__declspec(dllimport)** on the declarations of the public symbols."},{"content":"The keyword <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> works whether you export with .def files or with the <bpt id=\"p2\">**</bpt>__declspec(dllexport)<ept id=\"p2\">**</ept> keyword.","pos":[1014,1139],"source":" The keyword **__declspec(dllimport)** works whether you export with .def files or with the **__declspec(dllexport)** keyword."},{"pos":[1146,1279],"content":"To make your code more readable, define a macro for <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> and then use the macro to declare each imported symbol:","source":"To make your code more readable, define a macro for **__declspec(dllimport)** and then use the macro to declare each imported symbol:"},{"content":"Using <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> is optional on function declarations, but the compiler produces more efficient code if you use this keyword.","pos":[1395,1535],"source":"Using **__declspec(dllimport)** is optional on function declarations, but the compiler produces more efficient code if you use this keyword."},{"content":"However, you must use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> for the importing executable to access the DLL's public data symbols and objects.","pos":[1536,1665],"source":" However, you must use **__declspec(dllimport)** for the importing executable to access the DLL's public data symbols and objects."},{"content":"Note that the users of your DLL still need to link with an import library.","pos":[1666,1740]},{"content":"You can use the same header file for both the DLL and the client application.","pos":[1747,1824]},{"content":"To do this, use a special preprocessor symbol that indicates whether you are building the DLL or building the client application.","pos":[1825,1954]},{"content":"For example:","pos":[1955,1967]},{"content":"What do you want to do?","pos":[2219,2242]},{"content":"Initialize a DLL","pos":[2253,2269]},{"content":"What do you want to know more about?","pos":[2311,2347]},{"content":"Importing and exporting inline functions","pos":[2358,2398]},{"content":"Mutual imports","pos":[2464,2478]},{"content":"See Also","pos":[2516,2524]},{"content":"Importing into an Application","pos":[2529,2558]}],"content":"---\ntitle: \"Importing into an Application Using __declspec(dllimport) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__declspec\"\n  - \"dllimport\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__declspec(dllimport) keyword [C++]\"\n  - \"importing DLLs [C++], __declspec(dllimport)\"\nms.assetid: edb4da4e-f83a-44cf-a668-9239d49dbe42\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Importing into an Application Using __declspec(dllimport)\nA program that uses public symbols defined by a DLL is said to import them. When you create header files for applications that use your DLLs to build with, use **__declspec(dllimport)** on the declarations of the public symbols. The keyword **__declspec(dllimport)** works whether you export with .def files or with the **__declspec(dllexport)** keyword.  \n  \n To make your code more readable, define a macro for **__declspec(dllimport)** and then use the macro to declare each imported symbol:  \n  \n```  \n#define DllImport   __declspec( dllimport )  \n  \nDllImport int  j;  \nDllImport void func();  \n```  \n  \n Using **__declspec(dllimport)** is optional on function declarations, but the compiler produces more efficient code if you use this keyword. However, you must use **__declspec(dllimport)** for the importing executable to access the DLL's public data symbols and objects. Note that the users of your DLL still need to link with an import library.  \n  \n You can use the same header file for both the DLL and the client application. To do this, use a special preprocessor symbol that indicates whether you are building the DLL or building the client application. For example:  \n  \n```  \n#ifdef _EXPORTING  \n   #define CLASS_DECLSPEC    __declspec(dllexport)  \n#else  \n   #define CLASS_DECLSPEC    __declspec(dllimport)  \n#endif  \n  \nclass CLASS_DECLSPEC CExampleA : public CObject  \n{ ... class definition ... };  \n```  \n  \n## What do you want to do?  \n  \n-   [Initialize a DLL](../build/initializing-a-dll.md)  \n  \n## What do you want to know more about?  \n  \n-   [Importing and exporting inline functions](../build/importing-and-exporting-inline-functions.md)  \n  \n-   [Mutual imports](../build/mutual-imports.md)  \n  \n## See Also  \n [Importing into an Application](../build/importing-into-an-application.md)"}