{"nodes":[{"pos":[12,46],"content":"Cast Operator: () | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Cast Operator: () | Microsoft Docs","pos":[0,34]}]},{"content":"Cast Operator: ()","pos":[604,621]},{"content":"A type cast provides a method for explicit conversion of the type of an object in a specific situation.","pos":[622,725]},{"content":"Syntax","pos":[734,740]},{"content":"Remarks","pos":[824,831]},{"content":"Any unary expression is considered a cast expression.","pos":[835,888]},{"content":"The compiler treats <bpt id=\"p1\">*</bpt>cast-expression<ept id=\"p1\">*</ept> as type <bpt id=\"p2\">*</bpt>type-name<ept id=\"p2\">*</ept> after a type cast has been made.","pos":[895,985],"source":"The compiler treats *cast-expression* as type *type-name* after a type cast has been made."},{"content":"Casts can be used to convert objects of any scalar type to or from any other scalar type.","pos":[986,1075]},{"content":"Explicit type casts are constrained by the same rules that determine the effects of implicit conversions.","pos":[1076,1181]},{"content":"Additional restraints on casts may result from the actual sizes or representation of specific types.","pos":[1182,1282]},{"content":"Example","pos":[1291,1298]},{"content":"Example","pos":[1637,1644]},{"content":"See Also","pos":[3258,3266]},{"content":"Expressions with Unary Operators","pos":[3271,3303]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[3354,3406]},{"content":"Explicit Type Conversion Operator: ()","pos":[3476,3513]},{"content":"Casting Operators","pos":[3572,3589]},{"content":"Cast Operators","pos":[3625,3639]}],"content":"---\ntitle: \"Cast Operator: () | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"cast operators\"\n  - \"() cast operator\"\nms.assetid: 4c99eb92-1b19-4a5d-9840-5d8c29b8453e\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Cast Operator: ()\nA type cast provides a method for explicit conversion of the type of an object in a specific situation.  \n  \n## Syntax  \n  \n```  \n  \n      unary-expression  \n( type-name ) cast-expression  \n```  \n  \n## Remarks  \n Any unary expression is considered a cast expression.  \n  \n The compiler treats *cast-expression* as type *type-name* after a type cast has been made. Casts can be used to convert objects of any scalar type to or from any other scalar type. Explicit type casts are constrained by the same rules that determine the effects of implicit conversions. Additional restraints on casts may result from the actual sizes or representation of specific types.  \n  \n## Example  \n  \n```  \n// expre_CastOperator.cpp  \n// compile with: /EHsc  \n// Demonstrate cast operator  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    double x = 3.1;  \n    int i;  \n    cout << \"x = \" << x << endl;  \n    i = (int)x;   // assign i the integer part of x  \n    cout << \"i = \" << i << endl;  \n}  \n```  \n  \n## Example  \n  \n```  \n// expre_CastOperator2.cpp  \n// The following sample shows how to define and use a cast operator.   \n#include <string.h>  \n#include <stdio.h>  \n  \nclass CountedAnsiString  \n{  \npublic:  \n    // Assume source is not null terminated  \n    CountedAnsiString(const char *pStr, size_t nSize) :  \n                      m_nSize(nSize)  \n    {  \n        m_pStr = new char[sizeOfBuffer];  \n  \n        strncpy_s(m_pStr, sizeOfBuffer, pStr, m_nSize);  \n        memset(&m_pStr[m_nSize], '!', 9); // for demonstration purposes.  \n    }  \n  \n    // Various string-like methods...  \n  \n    const char *GetRawBytes() const  \n    {  \n        return(m_pStr);  \n    }  \n  \n    //   \n    // operator to cast to a const char *  \n    //   \n    operator const char *()  \n    {  \n        m_pStr[m_nSize] = '\\0';  \n        return(m_pStr);  \n    }  \n  \n    enum  \n    {  \n        sizeOfBuffer = 20  \n    } size;  \n  \nprivate:  \n    char *m_pStr;  \n    const size_t m_nSize;  \n};  \n  \nint main()  \n{  \n    const char *kStr = \"Excitinggg\";  \n    CountedAnsiString myStr(kStr, 8);  \n  \n    const char *pRaw = myStr.GetRawBytes();  \n    printf_s(\"RawBytes truncated to 10 chars:   %.10s\\n\", pRaw);  \n  \n    const char *pCast = myStr; // or (const char *)myStr;  \n    printf_s(\"Casted Bytes:   %s\\n\", pCast);  \n  \n    puts(\"Note that the cast changed the raw internal string\");  \n    printf_s(\"Raw Bytes after cast:   %s\\n\", pRaw);  \n}  \n```  \n  \n```Output  \nRawBytes truncated to 10 chars:   Exciting!!  \nCasted Bytes:   Exciting  \nNote that the cast changed the raw internal string  \nRaw Bytes after cast:   Exciting  \n```  \n  \n## See Also  \n [Expressions with Unary Operators](../cpp/expressions-with-unary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Explicit Type Conversion Operator: ()](../cpp/explicit-type-conversion-operator-parens.md)   \n [Casting Operators](../cpp/casting-operators.md)   \n [Cast Operators](../c-language/cast-operators.md)"}