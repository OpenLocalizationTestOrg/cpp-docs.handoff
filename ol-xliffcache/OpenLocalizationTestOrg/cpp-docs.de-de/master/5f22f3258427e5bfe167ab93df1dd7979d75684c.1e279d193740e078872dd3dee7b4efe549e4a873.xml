{"nodes":[{"pos":[12,54],"content":"Importing Using DEF Files | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Importing Using DEF Files | Microsoft Docs","pos":[0,42]}]},{"content":"Importing Using DEF Files","pos":[742,767]},{"pos":[768,972],"content":"If you choose to use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> along with a .def file, you should change the .def file to use DATA in place of CONSTANT to reduce the likelihood that incorrect coding will cause a problem:","source":"If you choose to use **__declspec(dllimport)** along with a .def file, you should change the .def file to use DATA in place of CONSTANT to reduce the likelihood that incorrect coding will cause a problem:"},{"content":"The following table shows why.","pos":[1063,1093]},{"content":"Keyword","pos":[1100,1107]},{"content":"Emits in the import library","pos":[1108,1135]},{"content":"Exports","pos":[1136,1143]},{"content":"Using <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> and CONSTANT lists both the <ph id=\"ph1\">`imp`</ph> version and the undecorated name in the .lib DLL import library that is created to allow explicit linking.","pos":[1323,1495],"source":"Using **__declspec(dllimport)** and CONSTANT lists both the `imp` version and the undecorated name in the .lib DLL import library that is created to allow explicit linking."},{"content":"Using <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> and DATA lists just the <ph id=\"ph1\">`imp`</ph> version of the name.","pos":[1496,1578],"source":" Using **__declspec(dllimport)** and DATA lists just the `imp` version of the name."},{"pos":[1585,1682],"content":"If you use CONSTANT, either of the following code constructs can be used to access <ph id=\"ph1\">`ulDataInDll`</ph>:","source":"If you use CONSTANT, either of the following code constructs can be used to access `ulDataInDll`:"},{"content":"-or-","pos":[1813,1817]},{"pos":[1932,2063],"content":"However, if you use DATA in your .def file, only code compiled with the following definition can access the variable <ph id=\"ph1\">`ulDataInDll`</ph>:","source":"However, if you use DATA in your .def file, only code compiled with the following definition can access the variable `ulDataInDll`:"},{"content":"Using CONSTANT is more risky because if you forget to use the extra level of indirection, you could potentially access the import address table's pointer to the variable — not the variable itself.","pos":[2183,2379]},{"content":"This type of problem can often manifest as an access violation because the import address table is currently made read-only by the compiler and linker.","pos":[2380,2531]},{"content":"The current Visual C++ linker issues a warning if it sees CONSTANT in the .def file to account for this case.","pos":[2538,2647]},{"content":"The only real reason to use CONSTANT is if you cannot recompile some object file where the header file did not list <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> on the prototype.","pos":[2648,2807],"source":" The only real reason to use CONSTANT is if you cannot recompile some object file where the header file did not list **__declspec(dllimport)** on the prototype."},{"content":"See Also","pos":[2816,2824]},{"content":"Importing into an Application","pos":[2829,2858]}],"content":"---\ntitle: \"Importing Using DEF Files | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"importing DLLs [C++], DEF files\"\n  - \"def files [C++], importing with\"\n  - \".def files [C++], importing with\"\n  - \"dllimport attribute [C++], DEF files\"\n  - \"DLLs [C++], DEF files\"\nms.assetid: aefdbf50-f603-488a-b0d7-ed737bae311d\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Importing Using DEF Files\nIf you choose to use **__declspec(dllimport)** along with a .def file, you should change the .def file to use DATA in place of CONSTANT to reduce the likelihood that incorrect coding will cause a problem:  \n  \n```  \n// project.def  \nLIBRARY project  \nEXPORTS  \n   ulDataInDll   DATA  \n```  \n  \n The following table shows why.  \n  \n|Keyword|Emits in the import library|Exports|  \n|-------------|---------------------------------|-------------|  \n|`CONSTANT`|`_imp_ulDataInDll_ulDataInDll`|`_ulDataInDll`|  \n|`DATA`|`_imp_ulDataInDll`|`_ulDataInDll`|  \n  \n Using **__declspec(dllimport)** and CONSTANT lists both the `imp` version and the undecorated name in the .lib DLL import library that is created to allow explicit linking. Using **__declspec(dllimport)** and DATA lists just the `imp` version of the name.  \n  \n If you use CONSTANT, either of the following code constructs can be used to access `ulDataInDll`:  \n  \n```  \n__declspec(dllimport) ULONG ulDataInDll; /*prototype*/  \nif (ulDataInDll == 0L)   /*sample code fragment*/  \n```  \n  \n -or-  \n  \n```  \nULONG *ulDataInDll;      /*prototype*/  \nif (*ulDataInDll == 0L)  /*sample code fragment*/  \n```  \n  \n However, if you use DATA in your .def file, only code compiled with the following definition can access the variable `ulDataInDll`:  \n  \n```  \n__declspec(dllimport) ULONG ulDataInDll;  \n  \nif (ulDataInDll == 0L)   /*sample code fragment*/  \n```  \n  \n Using CONSTANT is more risky because if you forget to use the extra level of indirection, you could potentially access the import address table's pointer to the variable — not the variable itself. This type of problem can often manifest as an access violation because the import address table is currently made read-only by the compiler and linker.  \n  \n The current Visual C++ linker issues a warning if it sees CONSTANT in the .def file to account for this case. The only real reason to use CONSTANT is if you cannot recompile some object file where the header file did not list **__declspec(dllimport)** on the prototype.  \n  \n## See Also  \n [Importing into an Application](../build/importing-into-an-application.md)"}