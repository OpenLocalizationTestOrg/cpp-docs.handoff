{"nodes":[{"pos":[12,59],"content":"Windows Sockets: Byte Ordering | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Sockets: Byte Ordering | Microsoft Docs","pos":[0,47]}]},{"content":"Windows Sockets: Byte Ordering","pos":[695,725]},{"content":"This article and two companion articles explain several issues in Windows Sockets programming.","pos":[726,820]},{"content":"This article covers byte ordering.","pos":[821,855]},{"content":"The other issues are covered in the articles: <bpt id=\"p1\">[</bpt>Windows Sockets: Blocking<ept id=\"p1\">](../mfc/windows-sockets-blocking.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Converting Strings<ept id=\"p2\">](../mfc/windows-sockets-converting-strings.md)</ept>.","pos":[856,1054],"source":" The other issues are covered in the articles: [Windows Sockets: Blocking](../mfc/windows-sockets-blocking.md) and [Windows Sockets: Converting Strings](../mfc/windows-sockets-converting-strings.md)."},{"content":"If you use or derive from class <bpt id=\"p1\">[</bpt>CAsyncSocket<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md)</ept>, you will need to manage these issues yourself.","pos":[1061,1195],"source":"If you use or derive from class [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you will need to manage these issues yourself."},{"content":"If you use or derive from class <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept>, MFC manages them for you.","pos":[1196,1299],"source":" If you use or derive from class [CSocket](../mfc/reference/csocket-class.md), MFC manages them for you."},{"content":"Byte Ordering","pos":[1308,1321]},{"content":"Different machine architectures sometimes store data using different byte orders.","pos":[1325,1406]},{"content":"For example, Intel-based machines store data in the reverse order of Macintosh (Motorola) machines.","pos":[1407,1506]},{"content":"The Intel byte order, called \"little-Endian,\" is also the reverse of the network standard \"big-Endian\" order.","pos":[1507,1616]},{"content":"The following table explains these terms.","pos":[1617,1658]},{"content":"Big- and Little-Endian Byte Ordering","pos":[1668,1704]},{"content":"Byte ordering","pos":[1711,1724]},{"content":"Meaning","pos":[1725,1732]},{"content":"Big-Endian","pos":[1775,1785]},{"content":"The most significant byte is on the left end of a word.","pos":[1786,1841]},{"content":"Little-Endian","pos":[1846,1859]},{"content":"The most significant byte is on the right end of a word.","pos":[1860,1916]},{"content":"Typically, you do not have to worry about byte-order conversion for data that you send and receive over the network, but there are situations in which you must convert byte orders.","pos":[1924,2104]},{"content":"When You Must Convert Byte Orders","pos":[2113,2146]},{"content":"You need to convert byte orders in the following situations:","pos":[2150,2210]},{"content":"You are passing information that needs to be interpreted by the network, as opposed to the data you are sending to another machine.","pos":[2220,2351]},{"content":"For example, you might pass ports and addresses, which the network must understand.","pos":[2352,2435]},{"content":"The server application with which you are communicating is not an MFC application (and you do not have source code for it).","pos":[2445,2568]},{"content":"This calls for byte order conversions if the two machines do not share the same byte ordering.","pos":[2569,2663]},{"content":"When You Do Not Have to Convert Byte Orders","pos":[2672,2715]},{"content":"You can avoid the work of converting byte orders in the following situations:","pos":[2719,2796]},{"content":"The machines on both ends can agree not to swap bytes, and both machines use the same byte order.","pos":[2806,2903]},{"content":"The server you are communicating with is an MFC application.","pos":[2913,2973]},{"content":"You have source code for the server you're communicating with, so you can tell explicitly whether you must convert byte orders or not.","pos":[2983,3117]},{"content":"You can port the server to MFC.","pos":[3127,3158]},{"content":"This is fairly easy to do, and the result is usually smaller, faster code.","pos":[3159,3233]},{"content":"Working with <bpt id=\"p1\">[</bpt>CAsyncSocket<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md)</ept>, you must manage any necessary byte-order conversions yourself.","pos":[3240,3371],"source":"Working with [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you must manage any necessary byte-order conversions yourself."},{"content":"Windows Sockets standardizes the \"big-Endian\" byte-order model and provides functions to convert between this order and others.","pos":[3372,3499]},{"content":"<bpt id=\"p1\">[</bpt>CArchive<ept id=\"p1\">](../mfc/reference/carchive-class.md)</ept>, however, which you use with <bpt id=\"p2\">[</bpt>CSocket<ept id=\"p2\">](../mfc/reference/csocket-class.md)</ept>, uses the opposite (\"little-Endian\") order, but <ph id=\"ph1\">`CArchive`</ph> takes care of the details of byte-order conversions for you.","pos":[3500,3740],"source":"[CArchive](../mfc/reference/carchive-class.md), however, which you use with [CSocket](../mfc/reference/csocket-class.md), uses the opposite (\"little-Endian\") order, but `CArchive` takes care of the details of byte-order conversions for you."},{"content":"By using this standard ordering in your applications, or using Windows Sockets byte-order conversion functions, you can make your code more portable.","pos":[3741,3890]},{"content":"The ideal case for using MFC sockets is when you are writing both ends of the communication: using MFC at both ends.","pos":[3897,4013]},{"content":"If you are writing an application that will communicate with non-MFC applications, such as an FTP server, you will probably need to manage byte-swapping yourself before you pass data to the archive object, using the Windows Sockets conversion routines <bpt id=\"p1\">**</bpt>ntohs<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>ntohl<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>htons<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>htonl<ept id=\"p4\">**</ept>.","pos":[4014,4313],"source":" If you are writing an application that will communicate with non-MFC applications, such as an FTP server, you will probably need to manage byte-swapping yourself before you pass data to the archive object, using the Windows Sockets conversion routines **ntohs**, **ntohl**, **htons**, and **htonl**."},{"content":"An example of these functions used in communicating with a non-MFC application appears later in this article.","pos":[4314,4423]},{"pos":[4431,4764],"content":"[!NOTE]\n When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from `CObject` into your archive because the receiver will not be able to handle them. See the note in [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md).","leadings":["","> "],"nodes":[{"content":" When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from `CObject` into your archive because the receiver will not be able to handle them. See the note in [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md).","pos":[8,331],"nodes":[{"content":"When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from <ph id=\"ph1\">`CObject`</ph> into your archive because the receiver will not be able to handle them.","pos":[1,204],"source":" When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from `CObject` into your archive because the receiver will not be able to handle them."},{"content":"See the note in <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","pos":[205,323],"source":" See the note in [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md)."}]}]},{"pos":[4771,4916],"content":"For more information about byte orders, see the Windows Sockets specification, available in the <ph id=\"ph1\">[!INCLUDE[winSDK](../atl/includes/winsdk_md.md)]</ph>.","source":"For more information about byte orders, see the Windows Sockets specification, available in the [!INCLUDE[winSDK](../atl/includes/winsdk_md.md)]."},{"content":"A Byte-Order Conversion Example","pos":[4925,4956]},{"content":"The following example shows a serialization function for a <ph id=\"ph1\">`CSocket`</ph> object that uses an archive.","pos":[4960,5057],"source":"The following example shows a serialization function for a `CSocket` object that uses an archive."},{"content":"It also illustrates using the byte-order conversion functions in the Windows Sockets API.","pos":[5058,5147]},{"content":"This example presents a scenario in which you are writing a client that communicates with a non-MFC server application for which you have no access to the source code.","pos":[5154,5321]},{"content":"In this scenario, you must assume that the non-MFC server uses standard network byte order.","pos":[5322,5413]},{"content":"In contrast, your MFC client application uses a <ph id=\"ph1\">`CArchive`</ph> object with a <ph id=\"ph2\">`CSocket`</ph> object, and <ph id=\"ph3\">`CArchive`</ph> uses \"little-Endian\" byte order, the opposite of the network standard.","pos":[5414,5590],"source":" In contrast, your MFC client application uses a `CArchive` object with a `CSocket` object, and `CArchive` uses \"little-Endian\" byte order, the opposite of the network standard."},{"content":"Suppose the non-MFC server with which you plan to communicate has an established protocol for a message packet like the following:","pos":[5597,5727]},{"pos":[5745,5766],"content":"NVC_MFCSimpleSocket#5"},{"content":"In MFC terms, this would be expressed as follows:","pos":[5835,5884]},{"pos":[5902,5923],"content":"NVC_MFCSimpleSocket#6"},{"content":"In C++, a <ph id=\"ph1\">`struct`</ph> is essentially the same thing as a class.","pos":[5992,6052],"source":"In C++, a `struct` is essentially the same thing as a class."},{"content":"The <ph id=\"ph1\">`Message`</ph> structure can have member functions, such as the <ph id=\"ph2\">`Serialize`</ph> member function declared above.","pos":[6053,6159],"source":" The `Message` structure can have member functions, such as the `Serialize` member function declared above."},{"content":"The <ph id=\"ph1\">`Serialize`</ph> member function might look like this:","pos":[6160,6213],"source":" The `Serialize` member function might look like this:"},{"pos":[6231,6252],"content":"NVC_MFCSimpleSocket#7"},{"content":"This example calls for byte-order conversions of data because there is a clear mismatch between the byte ordering of the non-MFC server application on one end and the <ph id=\"ph1\">`CArchive`</ph> used in your MFC client application on the other end.","pos":[6321,6552],"source":"This example calls for byte-order conversions of data because there is a clear mismatch between the byte ordering of the non-MFC server application on one end and the `CArchive` used in your MFC client application on the other end."},{"content":"The example illustrates several of the byte-order conversion functions that Windows Sockets supplies.","pos":[6553,6654]},{"content":"The following table describes these functions.","pos":[6655,6701]},{"content":"Windows Sockets Byte-Order Conversion Functions","pos":[6711,6758]},{"content":"Function","pos":[6765,6773]},{"content":"Purpose","pos":[6774,6781]},{"content":"ntohs","pos":[6821,6826]},{"content":"Convert a 16-bit quantity from network byte order to host byte order (big-Endian to little-Endian).","pos":[6829,6928]},{"content":"ntohl","pos":[6935,6940]},{"content":"Convert a 32-bit quantity from network byte order to host byte order (big-Endian to little-Endian).","pos":[6943,7042]},{"content":"Htons","pos":[7049,7054]},{"content":"Convert a 16-bit quantity from host byte order to network byte order (little-Endian to big-Endian).","pos":[7057,7156]},{"content":"Htonl","pos":[7163,7168]},{"content":"Convert a 32-bit quantity from host byte order to network byte order (little-Endian to big-Endian).","pos":[7171,7270]},{"content":"Another point of this example is that when the socket application on the other end of the communication is a non-MFC application, you must avoid doing something like the following:","pos":[7278,7458]},{"content":"where <ph id=\"ph1\">`pMsg`</ph> is a pointer to a C++ object derived from class <ph id=\"ph2\">`CObject`</ph>.","pos":[7485,7556],"source":"where `pMsg` is a pointer to a C++ object derived from class `CObject`."},{"content":"This will send extra MFC information associated with objects and the server will not understand it, as it would if it were an MFC application.","pos":[7557,7699]},{"content":"For more information, see:","pos":[7706,7732]},{"content":"Windows Sockets: Using Class CAsyncSocket","pos":[7743,7784]},{"content":"Windows Sockets: Background","pos":[7848,7875]},{"content":"Windows Sockets: Stream Sockets","pos":[7925,7956]},{"content":"Windows Sockets: Datagram Sockets","pos":[8010,8043]},{"content":"See Also","pos":[8097,8105]},{"content":"Windows Sockets in MFC","pos":[8110,8132]}],"content":"---\ntitle: \"Windows Sockets: Byte Ordering | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"byte order issues in sockets programming\"\n  - \"sockets [C++], byte order issues\"\n  - \"Windows Sockets [C++], byte order issues\"\nms.assetid: 8a787a65-f9f4-4002-a02f-ac25a5dace5d\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Windows Sockets: Byte Ordering\nThis article and two companion articles explain several issues in Windows Sockets programming. This article covers byte ordering. The other issues are covered in the articles: [Windows Sockets: Blocking](../mfc/windows-sockets-blocking.md) and [Windows Sockets: Converting Strings](../mfc/windows-sockets-converting-strings.md).  \n  \n If you use or derive from class [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you will need to manage these issues yourself. If you use or derive from class [CSocket](../mfc/reference/csocket-class.md), MFC manages them for you.  \n  \n## Byte Ordering  \n Different machine architectures sometimes store data using different byte orders. For example, Intel-based machines store data in the reverse order of Macintosh (Motorola) machines. The Intel byte order, called \"little-Endian,\" is also the reverse of the network standard \"big-Endian\" order. The following table explains these terms.  \n  \n### Big- and Little-Endian Byte Ordering  \n  \n|Byte ordering|Meaning|  \n|-------------------|-------------|  \n|Big-Endian|The most significant byte is on the left end of a word.|  \n|Little-Endian|The most significant byte is on the right end of a word.|  \n  \n Typically, you do not have to worry about byte-order conversion for data that you send and receive over the network, but there are situations in which you must convert byte orders.  \n  \n## When You Must Convert Byte Orders  \n You need to convert byte orders in the following situations:  \n  \n-   You are passing information that needs to be interpreted by the network, as opposed to the data you are sending to another machine. For example, you might pass ports and addresses, which the network must understand.  \n  \n-   The server application with which you are communicating is not an MFC application (and you do not have source code for it). This calls for byte order conversions if the two machines do not share the same byte ordering.  \n  \n## When You Do Not Have to Convert Byte Orders  \n You can avoid the work of converting byte orders in the following situations:  \n  \n-   The machines on both ends can agree not to swap bytes, and both machines use the same byte order.  \n  \n-   The server you are communicating with is an MFC application.  \n  \n-   You have source code for the server you're communicating with, so you can tell explicitly whether you must convert byte orders or not.  \n  \n-   You can port the server to MFC. This is fairly easy to do, and the result is usually smaller, faster code.  \n  \n Working with [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you must manage any necessary byte-order conversions yourself. Windows Sockets standardizes the \"big-Endian\" byte-order model and provides functions to convert between this order and others. [CArchive](../mfc/reference/carchive-class.md), however, which you use with [CSocket](../mfc/reference/csocket-class.md), uses the opposite (\"little-Endian\") order, but `CArchive` takes care of the details of byte-order conversions for you. By using this standard ordering in your applications, or using Windows Sockets byte-order conversion functions, you can make your code more portable.  \n  \n The ideal case for using MFC sockets is when you are writing both ends of the communication: using MFC at both ends. If you are writing an application that will communicate with non-MFC applications, such as an FTP server, you will probably need to manage byte-swapping yourself before you pass data to the archive object, using the Windows Sockets conversion routines **ntohs**, **ntohl**, **htons**, and **htonl**. An example of these functions used in communicating with a non-MFC application appears later in this article.  \n  \n> [!NOTE]\n>  When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from `CObject` into your archive because the receiver will not be able to handle them. See the note in [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n For more information about byte orders, see the Windows Sockets specification, available in the [!INCLUDE[winSDK](../atl/includes/winsdk_md.md)].  \n  \n## A Byte-Order Conversion Example  \n The following example shows a serialization function for a `CSocket` object that uses an archive. It also illustrates using the byte-order conversion functions in the Windows Sockets API.  \n  \n This example presents a scenario in which you are writing a client that communicates with a non-MFC server application for which you have no access to the source code. In this scenario, you must assume that the non-MFC server uses standard network byte order. In contrast, your MFC client application uses a `CArchive` object with a `CSocket` object, and `CArchive` uses \"little-Endian\" byte order, the opposite of the network standard.  \n  \n Suppose the non-MFC server with which you plan to communicate has an established protocol for a message packet like the following:  \n  \n [!code-cpp[NVC_MFCSimpleSocket#5](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_1.cpp)]  \n  \n In MFC terms, this would be expressed as follows:  \n  \n [!code-cpp[NVC_MFCSimpleSocket#6](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_2.cpp)]  \n  \n In C++, a `struct` is essentially the same thing as a class. The `Message` structure can have member functions, such as the `Serialize` member function declared above. The `Serialize` member function might look like this:  \n  \n [!code-cpp[NVC_MFCSimpleSocket#7](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_3.cpp)]  \n  \n This example calls for byte-order conversions of data because there is a clear mismatch between the byte ordering of the non-MFC server application on one end and the `CArchive` used in your MFC client application on the other end. The example illustrates several of the byte-order conversion functions that Windows Sockets supplies. The following table describes these functions.  \n  \n### Windows Sockets Byte-Order Conversion Functions  \n  \n|Function|Purpose|  \n|--------------|-------------|  \n|**ntohs**|Convert a 16-bit quantity from network byte order to host byte order (big-Endian to little-Endian).|  \n|**ntohl**|Convert a 32-bit quantity from network byte order to host byte order (big-Endian to little-Endian).|  \n|**Htons**|Convert a 16-bit quantity from host byte order to network byte order (little-Endian to big-Endian).|  \n|**Htonl**|Convert a 32-bit quantity from host byte order to network byte order (little-Endian to big-Endian).|  \n  \n Another point of this example is that when the socket application on the other end of the communication is a non-MFC application, you must avoid doing something like the following:  \n  \n `ar << pMsg;`  \n  \n where `pMsg` is a pointer to a C++ object derived from class `CObject`. This will send extra MFC information associated with objects and the server will not understand it, as it would if it were an MFC application.  \n  \n For more information, see:  \n  \n-   [Windows Sockets: Using Class CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)  \n  \n-   [Windows Sockets: Background](../mfc/windows-sockets-background.md)  \n  \n-   [Windows Sockets: Stream Sockets](../mfc/windows-sockets-stream-sockets.md)  \n  \n-   [Windows Sockets: Datagram Sockets](../mfc/windows-sockets-datagram-sockets.md)  \n  \n## See Also  \n [Windows Sockets in MFC](../mfc/windows-sockets-in-mfc.md)\n\n"}