{"nodes":[{"pos":[12,61],"content":"Welcome Back to C++ (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Welcome Back to C++ (Modern C++) | Microsoft Docs","pos":[0,49]}]},{"content":"Welcome Back to C++ (Modern C++)","pos":[542,574]},{"content":"C++ is one of the most widely used programming languages in the world.","pos":[575,645]},{"content":"Well-written C++ programs are fast and efficient.","pos":[646,695]},{"content":"The language is more flexible than other languages because you can use it to create a wide range of apps—from fun and exciting games, to high-performance scientific software, to device drivers, embedded programs, and Windows client apps.","pos":[696,933]},{"content":"For more than 20 years, C++ has been used to solve problems like these and many others.","pos":[934,1021]},{"content":"What you might not know is that an increasing number of C++ programmers have folded up the dowdy C-style programming of yesterday and have donned modern C++ instead.","pos":[1022,1187]},{"content":"One of the original requirements for C++ was backward compatibility with the C language.","pos":[1194,1282]},{"content":"Since then, C++ has evolved through several iterations—C with Classes, then the original C++ language specification, and then the many subsequent enhancements.","pos":[1283,1442]},{"content":"Because of this heritage, C++ is often referred to as a multi-paradigm programming language.","pos":[1443,1535]},{"content":"In C++, you can do purely procedural C-style programming that involves raw pointers, arrays, null-terminated character strings, custom data structures, and other features that may enable great performance but can also spawn bugs and complexity.","pos":[1536,1780]},{"content":"Because C-style programming is fraught with perils like these, one of the founding goals for C++ was to make programs both type-safe and easier to write, extend, and maintain.","pos":[1782,1957]},{"content":"Early on, C++ embraced programming paradigms such as object-oriented programming.","pos":[1958,2039]},{"content":"Over the years, features have been added to the language, together with highly-tested standard libraries of data structures and algorithms.","pos":[2040,2179]},{"content":"It's these additions that have made the modern C++ style possible.","pos":[2180,2246]},{"content":"Modern C++ emphasizes:","pos":[2253,2275]},{"content":"Stack-based scope instead of heap or static global scope.","pos":[2285,2342]},{"content":"Auto type inference instead of explicit type names.","pos":[2352,2403]},{"content":"Smart pointers instead of raw pointers.","pos":[2413,2452]},{"pos":[2476,2581],"content":"and <ph id=\"ph1\">`std::wstring`</ph> types (see <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>string&gt;<ept id=\"p1\">](../standard-library/string.md)</ept>) instead of raw <ph id=\"ph3\">`char[]`</ph> arrays.","source":" and `std::wstring` types (see [\\<string>](../standard-library/string.md)) instead of raw `char[]` arrays."},{"content":"<bpt id=\"p1\">[</bpt>Standard template library<ept id=\"p1\">](../standard-library/cpp-standard-library-header-files.md)</ept> (STL) containers like <ph id=\"ph1\">`vector`</ph>, <ph id=\"ph2\">`list`</ph>, and <ph id=\"ph3\">`map`</ph> instead of raw arrays or custom containers.","pos":[2591,2770],"source":"[Standard template library](../standard-library/cpp-standard-library-header-files.md) (STL) containers like `vector`, `list`, and `map` instead of raw arrays or custom containers."},{"content":"See <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>vector&gt;<ept id=\"p1\">](../standard-library/vector.md)</ept>, <bpt id=\"p2\">[</bpt><ph id=\"ph2\">\\&lt;</ph>list&gt;<ept id=\"p2\">](../standard-library/list.md)</ept>, and <bpt id=\"p3\">[</bpt><ph id=\"ph3\">\\&lt;</ph>map&gt;<ept id=\"p3\">](../standard-library/map.md)</ept>.","pos":[2771,2900],"source":" See [\\<vector>](../standard-library/vector.md), [\\<list>](../standard-library/list.md), and [\\<map>](../standard-library/map.md)."},{"pos":[2910,2992],"content":"<bpt id=\"p1\">[</bpt>STL algorithms<ept id=\"p1\">](../standard-library/algorithm.md)</ept> instead of manually coded ones.","source":"[STL algorithms](../standard-library/algorithm.md) instead of manually coded ones."},{"content":"Exceptions, to report and handle error conditions.","pos":[3002,3052]},{"pos":[3062,3229],"content":"Lock-free inter-thread communication using STL <ph id=\"ph1\">`std::atomic&lt;&gt;`</ph> (see <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>atomic&gt;<ept id=\"p1\">](../standard-library/atomic.md)</ept>) instead of other inter-thread communication mechanisms.","source":"Lock-free inter-thread communication using STL `std::atomic<>` (see [\\<atomic>](../standard-library/atomic.md)) instead of other inter-thread communication mechanisms."},{"pos":[3239,3352],"content":"Inline <bpt id=\"p1\">[</bpt>lambda functions<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept> instead of small functions implemented separately.","source":"Inline [lambda functions](../cpp/lambda-expressions-in-cpp.md) instead of small functions implemented separately."},{"content":"Range-based for loops to write more robust loops that work with arrays, STL containers, and <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> collections in the form <ph id=\"ph2\">`for ( for-range-declaration : expression )`</ph>.","pos":[3362,3576],"source":"Range-based for loops to write more robust loops that work with arrays, STL containers, and [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] collections in the form `for ( for-range-declaration : expression )`."},{"content":"This is part of the Core Language support.","pos":[3577,3619]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Range-based for Statement (C++)<ept id=\"p1\">](../cpp/range-based-for-statement-cpp.md)</ept>.","pos":[3620,3721],"source":" For more information, see [Range-based for Statement (C++)](../cpp/range-based-for-statement-cpp.md)."},{"content":"The C++ language itself has also evolved.","pos":[3728,3769]},{"content":"Compare the following code snippets.","pos":[3770,3806]},{"content":"This one shows how things used to be in C++:","pos":[3807,3851]},{"content":"Here's how the same thing is accomplished in modern C++:","pos":[4284,4340]},{"content":"In modern C++, you don't have to use new/delete or explicit exception handling because you can use smart pointers instead.","pos":[4691,4813]},{"content":"When you use the <ph id=\"ph1\">`auto`</ph> type deduction and <bpt id=\"p1\">[</bpt>lambda function<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept>, you can write code quicker, tighten it, and understand it better.","pos":[4814,4978],"source":" When you use the `auto` type deduction and [lambda function](../cpp/lambda-expressions-in-cpp.md), you can write code quicker, tighten it, and understand it better."},{"content":"And <ph id=\"ph1\">`for_each`</ph> is cleaner, easier to use, and less prone to unintended errors than a <ph id=\"ph2\">`for`</ph> loop.","pos":[4979,5075],"source":" And `for_each` is cleaner, easier to use, and less prone to unintended errors than a `for` loop."},{"content":"You can use boilerplate together with minimal lines of code to write your app.","pos":[5076,5154]},{"content":"And you can make that code exception-safe and memory-safe, and have no allocation/deallocation or error codes to deal with.","pos":[5155,5278]},{"content":"Modern C++ incorporates two kinds of polymorphism: compile-time, through templates, and run-time, through inheritance and virtualization.","pos":[5285,5422]},{"content":"You can mix the two kinds of polymorphism to great effect.","pos":[5423,5481]},{"content":"The STL template <ph id=\"ph1\">`shared_ptr`</ph> uses internal virtual methods to accomplish its apparently effortless type erasure.","pos":[5482,5595],"source":" The STL template `shared_ptr` uses internal virtual methods to accomplish its apparently effortless type erasure."},{"content":"But don't over-use virtualization for polymorphism when a template is the better choice.","pos":[5596,5684]},{"content":"Templates can be very powerful.","pos":[5685,5716]},{"content":"If you're coming to C++ from another language, especially from a managed language in which most of the types are reference types and very few are value types, know that C++ classes are value types by default.","pos":[5723,5931]},{"content":"But you can specify them as reference types to enable polymorphic behavior that supports object-oriented programming.","pos":[5932,6049]},{"content":"A helpful perspective: value types are more about memory and layout control, reference types are more about base classes and virtual functions to support polymorphism.","pos":[6050,6217]},{"content":"By default, value types are copyable—they each have a copy constructor and a copy assignment operator.","pos":[6218,6320]},{"content":"When you specify a reference type, make the class non-copyable—disable the copy constructor and copy assignment operator—and use a virtual destructor, which supports the polymorphism.","pos":[6321,6504]},{"content":"Value types are also about the contents, which, when they are copied, give you two independent values that you can modify separately.","pos":[6505,6638]},{"content":"But reference types are about identity—what kind of object it is—and for this reason are sometimes referred to as polymorphic types.","pos":[6639,6771]},{"content":"C++ is experiencing a renaissance because power is king again.","pos":[6778,6840]},{"content":"Languages like Java and C# are good when programmer productivity is important, but they show their limitations when power and performance are paramount.","pos":[6841,6993]},{"content":"For high efficiency and power, especially on devices that have limited hardware, nothing beats modern C++.","pos":[6994,7100]},{"content":"Not only the language is modern, the development tools are, too.","pos":[7107,7171]},{"content":"makes all parts of the development cycle robust and efficient.","pos":[7232,7294]},{"content":"It includes Application Lifecycle Management (ALM) tools, IDE enhancements like IntelliSense, tool-friendly mechanisms like XAML, and building, debugging, and many other tools.","pos":[7295,7471]},{"content":"The articles in this part of the documentation provide high-level guidelines and best practices for the most important features and techniques for writing modern C++ programs.","pos":[7478,7653]},{"content":"Support For C++11/14/17 Features (Modern C++)","pos":[7664,7709]},{"content":"C++ Type System","pos":[7776,7791]},{"content":"Uniform Initialization and Delegating Constructors","pos":[7841,7891]},{"content":"Object Lifetime And Resource Management","pos":[7965,8004]},{"content":"Objects Own Resources (RAII)","pos":[8078,8106]},{"content":"Smart Pointers","pos":[8156,8170]},{"content":"Pimpl For Compile-Time Encapsulation","pos":[8219,8255]},{"content":"Containers","pos":[8326,8336]},{"content":"Algorithms","pos":[8381,8391]},{"content":"String and I/O Formatting (Modern C++)","pos":[8436,8474]},{"content":"Errors and Exception Handling","pos":[8534,8563]},{"content":"Portability At ABI Boundaries","pos":[8627,8656]},{"pos":[8716,8856],"content":"For more information, see the StackOverflow article <bpt id=\"p1\">[</bpt>what C++ idioms are deprecated in C++11<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=402836)</ept>","source":"For more information, see the StackOverflow article [what C++ idioms are deprecated in C++11](http://go.microsoft.com/fwlink/?LinkId=402836)"},{"content":"See Also","pos":[8865,8873]},{"content":"C++ Language Reference","pos":[8878,8900]},{"content":"Lambda Expressions","pos":[8941,8959]},{"content":"C++ Standard Library","pos":[9003,9023]}],"content":"---\ntitle: \"Welcome Back to C++ (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 1cb1b849-ed9c-4721-a972-fd8f3dab42e2\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Welcome Back to C++ (Modern C++)\nC++ is one of the most widely used programming languages in the world. Well-written C++ programs are fast and efficient. The language is more flexible than other languages because you can use it to create a wide range of apps—from fun and exciting games, to high-performance scientific software, to device drivers, embedded programs, and Windows client apps. For more than 20 years, C++ has been used to solve problems like these and many others. What you might not know is that an increasing number of C++ programmers have folded up the dowdy C-style programming of yesterday and have donned modern C++ instead.  \n  \n One of the original requirements for C++ was backward compatibility with the C language. Since then, C++ has evolved through several iterations—C with Classes, then the original C++ language specification, and then the many subsequent enhancements. Because of this heritage, C++ is often referred to as a multi-paradigm programming language. In C++, you can do purely procedural C-style programming that involves raw pointers, arrays, null-terminated character strings, custom data structures, and other features that may enable great performance but can also spawn bugs and complexity.  Because C-style programming is fraught with perils like these, one of the founding goals for C++ was to make programs both type-safe and easier to write, extend, and maintain. Early on, C++ embraced programming paradigms such as object-oriented programming. Over the years, features have been added to the language, together with highly-tested standard libraries of data structures and algorithms. It's these additions that have made the modern C++ style possible.  \n  \n Modern C++ emphasizes:  \n  \n-   Stack-based scope instead of heap or static global scope.  \n  \n-   Auto type inference instead of explicit type names.  \n  \n-   Smart pointers instead of raw pointers.  \n  \n-   `std::string` and `std::wstring` types (see [\\<string>](../standard-library/string.md)) instead of raw `char[]` arrays.  \n  \n-   [Standard template library](../standard-library/cpp-standard-library-header-files.md) (STL) containers like `vector`, `list`, and `map` instead of raw arrays or custom containers. See [\\<vector>](../standard-library/vector.md), [\\<list>](../standard-library/list.md), and [\\<map>](../standard-library/map.md).  \n  \n-   [STL algorithms](../standard-library/algorithm.md) instead of manually coded ones.  \n  \n-   Exceptions, to report and handle error conditions.  \n  \n-   Lock-free inter-thread communication using STL `std::atomic<>` (see [\\<atomic>](../standard-library/atomic.md)) instead of other inter-thread communication mechanisms.  \n  \n-   Inline [lambda functions](../cpp/lambda-expressions-in-cpp.md) instead of small functions implemented separately.  \n  \n-   Range-based for loops to write more robust loops that work with arrays, STL containers, and [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] collections in the form `for ( for-range-declaration : expression )`. This is part of the Core Language support. For more information, see [Range-based for Statement (C++)](../cpp/range-based-for-statement-cpp.md).  \n  \n The C++ language itself has also evolved. Compare the following code snippets. This one shows how things used to be in C++:  \n  \n```cpp  \n  \n// circle and shape are user-defined types  \ncircle* p = new circle( 42 );   \nvector<shape*> v = load_shapes();  \n  \nfor( vector<circle*>::iterator i = v.begin(); i != v.end(); ++i ) {  \n    if( *i && **i == *p )  \n        cout << **i << “ is a match\\n”;  \n}  \n  \nfor( vector<circle*>::iterator i = v.begin();  \n        i != v.end(); ++i ) {  \n    delete *i; // not exception safe  \n}  \n  \ndelete p;  \n  \n```  \n  \n Here's how the same thing is accomplished in modern C++:  \n  \n```cpp  \n  \n#include <memory>  \n#include <vector>  \n// ...  \n// circle and shape are user-defined types  \nauto p = make_shared<circle>( 42 );  \nvector<shared_ptr<shape>> v = load_shapes();  \n  \nfor_each( begin(v), end(v), [&](const shared_ptr<shape>& s) {  \n    if( s && *s == *p )  \n        cout << *s << \" is a match\\n\";  \n} );  \n  \n```  \n  \n In modern C++, you don't have to use new/delete or explicit exception handling because you can use smart pointers instead. When you use the `auto` type deduction and [lambda function](../cpp/lambda-expressions-in-cpp.md), you can write code quicker, tighten it, and understand it better. And `for_each` is cleaner, easier to use, and less prone to unintended errors than a `for` loop. You can use boilerplate together with minimal lines of code to write your app. And you can make that code exception-safe and memory-safe, and have no allocation/deallocation or error codes to deal with.  \n  \n Modern C++ incorporates two kinds of polymorphism: compile-time, through templates, and run-time, through inheritance and virtualization. You can mix the two kinds of polymorphism to great effect. The STL template `shared_ptr` uses internal virtual methods to accomplish its apparently effortless type erasure. But don't over-use virtualization for polymorphism when a template is the better choice. Templates can be very powerful.  \n  \n If you're coming to C++ from another language, especially from a managed language in which most of the types are reference types and very few are value types, know that C++ classes are value types by default. But you can specify them as reference types to enable polymorphic behavior that supports object-oriented programming. A helpful perspective: value types are more about memory and layout control, reference types are more about base classes and virtual functions to support polymorphism. By default, value types are copyable—they each have a copy constructor and a copy assignment operator. When you specify a reference type, make the class non-copyable—disable the copy constructor and copy assignment operator—and use a virtual destructor, which supports the polymorphism. Value types are also about the contents, which, when they are copied, give you two independent values that you can modify separately. But reference types are about identity—what kind of object it is—and for this reason are sometimes referred to as polymorphic types.  \n  \n C++ is experiencing a renaissance because power is king again. Languages like Java and C# are good when programmer productivity is important, but they show their limitations when power and performance are paramount. For high efficiency and power, especially on devices that have limited hardware, nothing beats modern C++.  \n  \n Not only the language is modern, the development tools are, too. [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)] makes all parts of the development cycle robust and efficient. It includes Application Lifecycle Management (ALM) tools, IDE enhancements like IntelliSense, tool-friendly mechanisms like XAML, and building, debugging, and many other tools.  \n  \n The articles in this part of the documentation provide high-level guidelines and best practices for the most important features and techniques for writing modern C++ programs.  \n  \n-   [Support For C++11/14/17 Features (Modern C++)](../cpp/support-for-cpp11-14-17-features-modern-cpp.md)  \n  \n-   [C++ Type System](../cpp/cpp-type-system-modern-cpp.md)  \n  \n-   [Uniform Initialization and Delegating Constructors](../cpp/uniform-initialization-and-delegating-constructors.md)  \n  \n-   [Object Lifetime And Resource Management](../cpp/object-lifetime-and-resource-management-modern-cpp.md)  \n  \n-   [Objects Own Resources (RAII)](../cpp/objects-own-resources-raii.md)  \n  \n-   [Smart Pointers](../cpp/smart-pointers-modern-cpp.md)  \n  \n-   [Pimpl For Compile-Time Encapsulation](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md)  \n  \n-   [Containers](../cpp/containers-modern-cpp.md)  \n  \n-   [Algorithms](../cpp/algorithms-modern-cpp.md)  \n  \n-   [String and I/O Formatting (Modern C++)](../cpp/string-and-i-o-formatting-modern-cpp.md)  \n  \n-   [Errors and Exception Handling](../cpp/errors-and-exception-handling-modern-cpp.md)  \n  \n-   [Portability At ABI Boundaries](../cpp/portability-at-abi-boundaries-modern-cpp.md)  \n  \n For more information, see the StackOverflow article [what C++ idioms are deprecated in C++11](http://go.microsoft.com/fwlink/?LinkId=402836)  \n  \n## See Also  \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}