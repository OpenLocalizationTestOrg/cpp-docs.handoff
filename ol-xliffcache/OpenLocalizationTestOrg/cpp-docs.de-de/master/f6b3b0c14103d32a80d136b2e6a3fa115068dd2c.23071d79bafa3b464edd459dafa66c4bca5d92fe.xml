{"nodes":[{"pos":[12,42],"content":"&lt;mutex&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"mutex<ph id=\"ph1\">&amp;gt;</ph> | Microsoft Docs","pos":[4,30],"source":"mutex&gt; | Microsoft Docs"}]},{"content":"mutex","pos":[555,560]},{"pos":[565,819],"content":"Include the standard header <ph id=\"ph1\">\\&lt;</ph>mutex&gt; to define the classes <ph id=\"ph2\">`mutex`</ph>, <ph id=\"ph3\">`recursive_mutex`</ph>, <ph id=\"ph4\">`timed_mutex`</ph>, and <ph id=\"ph5\">`recursive_timed_mutex`</ph>; the templates <ph id=\"ph6\">`lock_guard`</ph> and <ph id=\"ph7\">`unique_lock`</ph>; and supporting types and functions that define mutual-exclusion code regions.","source":"Include the standard header \\<mutex> to define the classes `mutex`, `recursive_mutex`, `timed_mutex`, and `recursive_timed_mutex`; the templates `lock_guard` and `unique_lock`; and supporting types and functions that define mutual-exclusion code regions."},{"pos":[827,1099],"content":"[!WARNING]\n The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in \\<mutex> should not be used with any ConcRT types or functions.","leadings":["","> "],"nodes":[{"content":" The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in \\<mutex> should not be used with any ConcRT types or functions.","pos":[11,270],"nodes":[{"content":"The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP).","pos":[1,174]},{"content":"The types defined in <ph id=\"ph1\">\\&lt;</ph>mutex&gt; should not be used with any ConcRT types or functions.","pos":[175,259],"source":" The types defined in \\<mutex> should not be used with any ConcRT types or functions."}]}]},{"content":"Syntax","pos":[1108,1114]},{"content":"Remarks","pos":[1160,1167]},{"pos":[1175,1270],"content":"[!NOTE]\n In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked.","leadings":["","> "],"nodes":[{"content":"In code that is compiled by using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, this header is blocked.","pos":[9,93],"source":" In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked."}]},{"content":"The classes <ph id=\"ph1\">`mutex`</ph> and <ph id=\"ph2\">`recursive_mutex`</ph> are <bpt id=\"p1\">*</bpt>mutex types<ept id=\"p1\">*</ept>.","pos":[1277,1337],"source":"The classes `mutex` and `recursive_mutex` are *mutex types*."},{"content":"A mutex type has a default constructor and a destructor that does not throw exceptions.","pos":[1338,1425]},{"content":"These objects have methods that provide mutual exclusion when multiple threads try to lock the same object.","pos":[1426,1533]},{"content":"Specifically, a mutex type contains the methods <ph id=\"ph1\">`lock`</ph>, <ph id=\"ph2\">`try_lock`</ph>, and <ph id=\"ph3\">`unlock`</ph>:","pos":[1534,1615],"source":" Specifically, a mutex type contains the methods `lock`, `try_lock`, and `unlock`:"},{"content":"The <ph id=\"ph1\">`lock`</ph> method blocks the calling thread until the thread obtains ownership of the mutex.","pos":[1625,1717],"source":"The `lock` method blocks the calling thread until the thread obtains ownership of the mutex."},{"content":"Its return value is ignored.","pos":[1718,1746]},{"content":"The <ph id=\"ph1\">`try_lock`</ph> method tries to obtain ownership of the mutex without blocking.","pos":[1756,1834],"source":"The `try_lock` method tries to obtain ownership of the mutex without blocking."},{"content":"Its return type is convertible to <ph id=\"ph1\">`bool`</ph> and is <ph id=\"ph2\">`true`</ph> if the method obtains ownership, but is otherwise <ph id=\"ph3\">`false`</ph>.","pos":[1835,1948],"source":" Its return type is convertible to `bool` and is `true` if the method obtains ownership, but is otherwise `false`."},{"pos":[1958,2038],"content":"The <ph id=\"ph1\">`unlock`</ph> method releases the ownership of the mutex from the calling thread.","source":"The `unlock` method releases the ownership of the mutex from the calling thread."},{"content":"You can use mutex types as type arguments to instantiate the templates <ph id=\"ph1\">`lock_guard`</ph> and <ph id=\"ph2\">`unique_lock`</ph>.","pos":[2045,2147],"source":"You can use mutex types as type arguments to instantiate the templates `lock_guard` and `unique_lock`."},{"content":"You can use objects of these types as the <ph id=\"ph1\">`Lock`</ph> argument to the wait member functions in the template <bpt id=\"p1\">[</bpt>condition_variable_any<ept id=\"p1\">](../standard-library/condition-variable-any-class.md)</ept>.","pos":[2148,2329],"source":" You can use objects of these types as the `Lock` argument to the wait member functions in the template [condition_variable_any](../standard-library/condition-variable-any-class.md)."},{"content":"A <bpt id=\"p1\">*</bpt>timed mutex type<ept id=\"p1\">*</ept> satisfies the requirements for a mutex type.","pos":[2336,2401],"source":"A *timed mutex type* satisfies the requirements for a mutex type."},{"content":"In addition, it has the <ph id=\"ph1\">`try_lock_for`</ph> and <ph id=\"ph2\">`try_lock_until`</ph> methods that must be callable by using one argument and must return a type that is convertible to <ph id=\"ph3\">`bool`</ph>.","pos":[2402,2567],"source":" In addition, it has the `try_lock_for` and `try_lock_until` methods that must be callable by using one argument and must return a type that is convertible to `bool`."},{"content":"A timed mutex type can define these functions by using additional arguments, provided that those additional arguments all have default values.","pos":[2568,2710]},{"content":"The <ph id=\"ph1\">`try_lock_for`</ph> method must be callable by using one argument, <ph id=\"ph2\">`Rel_time`</ph>, whose type is an instantiation of <bpt id=\"p1\">[</bpt>chrono::duration<ept id=\"p1\">](../standard-library/duration-class.md)</ept>.","pos":[2720,2890],"source":"The `try_lock_for` method must be callable by using one argument, `Rel_time`, whose type is an instantiation of [chrono::duration](../standard-library/duration-class.md)."},{"content":"The method tries to obtain ownership of the mutex, but returns within the time that is designated by <ph id=\"ph1\">`Rel_time`</ph>, regardless of success.","pos":[2891,3026],"source":" The method tries to obtain ownership of the mutex, but returns within the time that is designated by `Rel_time`, regardless of success."},{"content":"The return value converts to <ph id=\"ph1\">`true`</ph> if the method obtains ownership; otherwise, the return value converts to <ph id=\"ph2\">`false`</ph>.","pos":[3027,3144],"source":" The return value converts to `true` if the method obtains ownership; otherwise, the return value converts to `false`."},{"content":"The <ph id=\"ph1\">`try_lock_until`</ph> method must be callable by using one argument, <ph id=\"ph2\">`Abs_time`</ph>, whose type is an instantiation of <bpt id=\"p1\">[</bpt>chrono::time_point<ept id=\"p1\">](../standard-library/time-point-class.md)</ept>.","pos":[3154,3330],"source":"The `try_lock_until` method must be callable by using one argument, `Abs_time`, whose type is an instantiation of [chrono::time_point](../standard-library/time-point-class.md)."},{"content":"The method tries to obtain ownership of the mutex, but returns no later than the time that is designated by <ph id=\"ph1\">`Abs_time`</ph>, regardless of success.","pos":[3331,3473],"source":" The method tries to obtain ownership of the mutex, but returns no later than the time that is designated by `Abs_time`, regardless of success."},{"content":"The return value converts to <ph id=\"ph1\">`true`</ph> if the method obtains ownership; otherwise, the return value converts to <ph id=\"ph2\">`false`</ph>.","pos":[3474,3591],"source":" The return value converts to `true` if the method obtains ownership; otherwise, the return value converts to `false`."},{"content":"A mutex type is also known as a <bpt id=\"p1\">*</bpt>lockable type<ept id=\"p1\">*</ept>.","pos":[3598,3646],"source":"A mutex type is also known as a *lockable type*."},{"content":"If it does not provide the member function <ph id=\"ph1\">`try_lock`</ph>, it is a <bpt id=\"p1\">*</bpt>basic lockable type<ept id=\"p1\">*</ept>.","pos":[3647,3732],"source":" If it does not provide the member function `try_lock`, it is a *basic lockable type*."},{"content":"A timed mutex type is also known as a <bpt id=\"p1\">*</bpt>timed lockable type<ept id=\"p1\">*</ept>.","pos":[3733,3793],"source":" A timed mutex type is also known as a *timed lockable type*."},{"content":"Classes","pos":[3803,3810]},{"content":"Name","pos":[3817,3821]},{"content":"Description","pos":[3822,3833]},{"content":"lock_guard Class","pos":[3872,3888]},{"pos":[3931,4033],"content":"Represents a template that can be instantiated to create an object whose destructor unlocks a <ph id=\"ph1\">`mutex`</ph>.","source":"Represents a template that can be instantiated to create an object whose destructor unlocks a `mutex`."},{"content":"mutex Class (STL)","pos":[4039,4056]},{"content":"Represents a mutex type.","pos":[4098,4122]},{"content":"Use objects of this type to enforce mutual exclusion within a program.","pos":[4123,4193]},{"content":"recursive_mutex Class","pos":[4199,4220]},{"content":"Represents a mutex type.","pos":[4268,4292]},{"content":"In constrast to the <ph id=\"ph1\">`mutex`</ph> class, the behavior of calling locking methods for objects that are already locked is well-defined.","pos":[4293,4420],"source":" In constrast to the `mutex` class, the behavior of calling locking methods for objects that are already locked is well-defined."},{"content":"recursive_timed_mutex Class","pos":[4426,4453]},{"content":"Represents a timed mutex type.","pos":[4507,4537]},{"content":"Use objects of this type to enforce mutual exclusion that has time-limited blocking within a program.","pos":[4538,4639]},{"content":"Unlike objects of type <ph id=\"ph1\">`timed_mutex`</ph>, the effect of calling locking methods for <ph id=\"ph2\">`recursive_timed_mutex`</ph> objects is well-defined.","pos":[4640,4768],"source":" Unlike objects of type `timed_mutex`, the effect of calling locking methods for `recursive_timed_mutex` objects is well-defined."},{"content":"timed_mutex Class","pos":[4774,4791]},{"content":"Represents a timed mutex type.","pos":[4835,4865]},{"content":"Use objects of this type to enforce mutual exclusion that has time-limited blocking within a program.","pos":[4866,4967]},{"content":"unique_lock Class","pos":[4973,4990]},{"pos":[5034,5150],"content":"Represents a template that can be instantiated to create objects that manage the locking and unlocking of a <ph id=\"ph1\">`mutex`</ph>.","source":"Represents a template that can be instantiated to create objects that manage the locking and unlocking of a `mutex`."},{"content":"Functions","pos":[5161,5170]},{"content":"Name","pos":[5177,5181]},{"content":"Description","pos":[5182,5193]},{"content":"call_once Function","pos":[5232,5250]},{"content":"Provides a mechanism for calling a specified callable object exactly once during execution.","pos":[5311,5402]},{"content":"lock Function","pos":[5408,5421]},{"content":"Attempts to lock all arguments without deadlock.","pos":[5477,5525]},{"content":"Structs","pos":[5536,5543]},{"content":"Name","pos":[5550,5554]},{"content":"Description","pos":[5555,5566]},{"content":"adopt_lock_t Structure","pos":[5605,5627]},{"pos":[5676,5733],"content":"Represents a type that is used to define an <ph id=\"ph1\">`adopt_lock`</ph>.","source":"Represents a type that is used to define an `adopt_lock`."},{"content":"defer_lock_t Structure","pos":[5739,5761]},{"pos":[5810,5938],"content":"Represents a type that defines a <ph id=\"ph1\">`defer_lock`</ph> object that is used to select one of the overloaded constructors of <ph id=\"ph2\">`unique_lock`</ph>.","source":"Represents a type that defines a `defer_lock` object that is used to select one of the overloaded constructors of `unique_lock`."},{"content":"once_flag Structure","pos":[5944,5963]},{"pos":[6009,6193],"content":"Represents a <ph id=\"ph1\">`struct`</ph> that is used with the template function <ph id=\"ph2\">`call_once`</ph> to ensure that initialization code is called only once, even in the presence of multiple threads of execution.","source":"Represents a `struct` that is used with the template function `call_once` to ensure that initialization code is called only once, even in the presence of multiple threads of execution."},{"content":"try_to_lock_t Structure","pos":[6199,6222]},{"pos":[6272,6404],"content":"Represents a <ph id=\"ph1\">`struct`</ph> that defines a <ph id=\"ph2\">`try_to_lock`</ph> object and is used to select one of the overloaded constructors of <ph id=\"ph3\">`unique_lock`</ph>.","source":"Represents a `struct` that defines a `try_to_lock` object and is used to select one of the overloaded constructors of `unique_lock`."},{"content":"Variables","pos":[6415,6424]},{"content":"Name","pos":[6431,6435]},{"content":"Description","pos":[6436,6447]},{"content":"adopt_lock Variable","pos":[6486,6505]},{"pos":[6567,6747],"content":"Represents an object that can be passed to constructors for <ph id=\"ph1\">`lock_guard`</ph> and <ph id=\"ph2\">`unique_lock`</ph> to indicate that the mutex object that is also being passed to the constructor is locked.","source":"Represents an object that can be passed to constructors for `lock_guard` and `unique_lock` to indicate that the mutex object that is also being passed to the constructor is locked."},{"content":"defer_lock Variable","pos":[6753,6772]},{"pos":[6834,7010],"content":"Represents an object that can be passed to the constructor for <ph id=\"ph1\">`unique_lock`</ph>, to indicate that the constructor should not lock the mutex object that is also being passed to it.","source":"Represents an object that can be passed to the constructor for `unique_lock`, to indicate that the constructor should not lock the mutex object that is also being passed to it."},{"content":"try_to_lock Variable","pos":[7016,7036]},{"pos":[7099,7291],"content":"Represents an object that can be passed to the constructor for <ph id=\"ph1\">`unique_lock`</ph> to indicate that the constructor should try to unlock the <ph id=\"ph2\">`mutex`</ph> that is also being passed to it without blocking.","source":"Represents an object that can be passed to the constructor for `unique_lock` to indicate that the constructor should try to unlock the `mutex` that is also being passed to it without blocking."},{"content":"See Also","pos":[7301,7309]},{"content":"Header Files Reference","pos":[7314,7336]}],"content":"---\ntitle: \"&lt;mutex&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"<mutex>\"\ndev_langs: \n  - \"C++\"\nms.assetid: efb60c89-687a-4e38-8fe4-694e11c4e8a3\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;mutex&gt;\nInclude the standard header \\<mutex> to define the classes `mutex`, `recursive_mutex`, `timed_mutex`, and `recursive_timed_mutex`; the templates `lock_guard` and `unique_lock`; and supporting types and functions that define mutual-exclusion code regions.  \n  \n> [!WARNING]\n>  The STL synchronization types in Visual Studio 2015 are based on Windows synchronization primitives and no longer use ConcRT (except when the target platform is Windows XP). The types defined in \\<mutex> should not be used with any ConcRT types or functions.  \n  \n## Syntax  \n  \n```cpp  \n#include <mutex>  \n```  \n  \n## Remarks  \n  \n> [!NOTE]\n>  In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked.  \n  \n The classes `mutex` and `recursive_mutex` are *mutex types*. A mutex type has a default constructor and a destructor that does not throw exceptions. These objects have methods that provide mutual exclusion when multiple threads try to lock the same object. Specifically, a mutex type contains the methods `lock`, `try_lock`, and `unlock`:  \n  \n-   The `lock` method blocks the calling thread until the thread obtains ownership of the mutex. Its return value is ignored.  \n  \n-   The `try_lock` method tries to obtain ownership of the mutex without blocking. Its return type is convertible to `bool` and is `true` if the method obtains ownership, but is otherwise `false`.  \n  \n-   The `unlock` method releases the ownership of the mutex from the calling thread.  \n  \n You can use mutex types as type arguments to instantiate the templates `lock_guard` and `unique_lock`. You can use objects of these types as the `Lock` argument to the wait member functions in the template [condition_variable_any](../standard-library/condition-variable-any-class.md).  \n  \n A *timed mutex type* satisfies the requirements for a mutex type. In addition, it has the `try_lock_for` and `try_lock_until` methods that must be callable by using one argument and must return a type that is convertible to `bool`. A timed mutex type can define these functions by using additional arguments, provided that those additional arguments all have default values.  \n  \n-   The `try_lock_for` method must be callable by using one argument, `Rel_time`, whose type is an instantiation of [chrono::duration](../standard-library/duration-class.md). The method tries to obtain ownership of the mutex, but returns within the time that is designated by `Rel_time`, regardless of success. The return value converts to `true` if the method obtains ownership; otherwise, the return value converts to `false`.  \n  \n-   The `try_lock_until` method must be callable by using one argument, `Abs_time`, whose type is an instantiation of [chrono::time_point](../standard-library/time-point-class.md). The method tries to obtain ownership of the mutex, but returns no later than the time that is designated by `Abs_time`, regardless of success. The return value converts to `true` if the method obtains ownership; otherwise, the return value converts to `false`.  \n  \n A mutex type is also known as a *lockable type*. If it does not provide the member function `try_lock`, it is a *basic lockable type*. A timed mutex type is also known as a *timed lockable type*.  \n  \n### Classes  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[lock_guard Class](../standard-library/lock-guard-class.md)|Represents a template that can be instantiated to create an object whose destructor unlocks a `mutex`.|  \n|[mutex Class (STL)](../standard-library/mutex-class-stl.md)|Represents a mutex type. Use objects of this type to enforce mutual exclusion within a program.|  \n|[recursive_mutex Class](../standard-library/recursive-mutex-class.md)|Represents a mutex type. In constrast to the `mutex` class, the behavior of calling locking methods for objects that are already locked is well-defined.|  \n|[recursive_timed_mutex Class](../standard-library/recursive-timed-mutex-class.md)|Represents a timed mutex type. Use objects of this type to enforce mutual exclusion that has time-limited blocking within a program. Unlike objects of type `timed_mutex`, the effect of calling locking methods for `recursive_timed_mutex` objects is well-defined.|  \n|[timed_mutex Class](../standard-library/timed-mutex-class.md)|Represents a timed mutex type. Use objects of this type to enforce mutual exclusion that has time-limited blocking within a program.|  \n|[unique_lock Class](../standard-library/unique-lock-class.md)|Represents a template that can be instantiated to create objects that manage the locking and unlocking of a `mutex`.|  \n  \n### Functions  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[call_once Function](../standard-library/mutex-functions.md#call_once_function)|Provides a mechanism for calling a specified callable object exactly once during execution.|  \n|[lock Function](../standard-library/mutex-functions.md#lock_function)|Attempts to lock all arguments without deadlock.|  \n  \n### Structs  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[adopt_lock_t Structure](../standard-library/adopt-lock-t-structure.md)|Represents a type that is used to define an `adopt_lock`.|  \n|[defer_lock_t Structure](../standard-library/defer-lock-t-structure.md)|Represents a type that defines a `defer_lock` object that is used to select one of the overloaded constructors of `unique_lock`.|  \n|[once_flag Structure](../standard-library/once-flag-structure.md)|Represents a `struct` that is used with the template function `call_once` to ensure that initialization code is called only once, even in the presence of multiple threads of execution.|  \n|[try_to_lock_t Structure](../standard-library/try-to-lock-t-structure.md)|Represents a `struct` that defines a `try_to_lock` object and is used to select one of the overloaded constructors of `unique_lock`.|  \n  \n### Variables  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[adopt_lock Variable](../standard-library/mutex-functions.md#adopt_lock_variable)|Represents an object that can be passed to constructors for `lock_guard` and `unique_lock` to indicate that the mutex object that is also being passed to the constructor is locked.|  \n|[defer_lock Variable](../standard-library/mutex-functions.md#defer_lock_variable)|Represents an object that can be passed to the constructor for `unique_lock`, to indicate that the constructor should not lock the mutex object that is also being passed to it.|  \n|[try_to_lock Variable](../standard-library/mutex-functions.md#try_to_lock_variable)|Represents an object that can be passed to the constructor for `unique_lock` to indicate that the constructor should try to unlock the `mutex` that is also being passed to it without blocking.|  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)\n\n\n\n"}