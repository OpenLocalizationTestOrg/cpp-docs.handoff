{"nodes":[{"pos":[12,43],"content":"CMemFile Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CMemFile Class | Microsoft Docs","pos":[0,31]}]},{"pos":[653,667],"content":"CMemFile Class","linkify":"CMemFile Class","nodes":[{"content":"CMemFile Class","pos":[0,14]}]},{"pos":[668,757],"content":"The <bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../../mfc/reference/cfile-class.md)</ept>-derived class that supports memory files.","source":"The [CFile](../../mfc/reference/cfile-class.md)-derived class that supports memory files."},{"pos":[766,772],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[828,835],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[845,864],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[871,875]},{"content":"Description","pos":[876,887]},{"pos":[925,966],"content":"<bpt id=\"p1\">[</bpt>CMemFile::CMemFile<ept id=\"p1\">](#cmemfile__cmemfile)</ept>","source":"[CMemFile::CMemFile](#cmemfile__cmemfile)"},{"content":"Constructs a memory file object.","pos":[967,999]},{"pos":[1010,1024],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1031,1035]},{"content":"Description","pos":[1036,1047]},{"pos":[1085,1122],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Attach<ept id=\"p1\">](#cmemfile__attach)</ept>","source":"[CMemFile::Attach](#cmemfile__attach)"},{"pos":[1123,1164],"content":"Attaches a block of memory to <ph id=\"ph1\">`CMemFile`</ph>.","source":"Attaches a block of memory to `CMemFile`."},{"pos":[1169,1206],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Detach<ept id=\"p1\">](#cmemfile__detach)</ept>","source":"[CMemFile::Detach](#cmemfile__detach)"},{"pos":[1207,1306],"content":"Detaches the block of memory from <ph id=\"ph1\">`CMemFile`</ph> and returns a pointer to the block of memory detached.","source":"Detaches the block of memory from `CMemFile` and returns a pointer to the block of memory detached."},{"pos":[1317,1334],"content":"Protected Methods","linkify":"Protected Methods","nodes":[{"content":"Protected Methods","pos":[0,17]}]},{"content":"Name","pos":[1341,1345]},{"content":"Description","pos":[1346,1357]},{"pos":[1395,1430],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Alloc<ept id=\"p1\">](#cmemfile__alloc)</ept>","source":"[CMemFile::Alloc](#cmemfile__alloc)"},{"content":"Override to modify memory allocation behavior.","pos":[1431,1477]},{"pos":[1482,1515],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Free<ept id=\"p1\">](#cmemfile__free)</ept>","source":"[CMemFile::Free](#cmemfile__free)"},{"content":"Override to modify memory deallocation behavior.","pos":[1516,1564]},{"pos":[1569,1610],"content":"<bpt id=\"p1\">[</bpt>CMemFile::GrowFile<ept id=\"p1\">](#cmemfile__growfile)</ept>","source":"[CMemFile::GrowFile](#cmemfile__growfile)"},{"content":"Override to modify behavior when growing a file.","pos":[1611,1659]},{"pos":[1664,1701],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Memcpy<ept id=\"p1\">](#cmemfile__memcpy)</ept>","source":"[CMemFile::Memcpy](#cmemfile__memcpy)"},{"content":"Override to modify memory copy behavior when reading and writing files.","pos":[1702,1773]},{"pos":[1778,1817],"content":"<bpt id=\"p1\">[</bpt>CMemFile::Realloc<ept id=\"p1\">](#cmemfile__realloc)</ept>","source":"[CMemFile::Realloc](#cmemfile__realloc)"},{"content":"Override to modify memory reallocation behavior.","pos":[1818,1866]},{"pos":[1876,1883],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"These memory files behave like disk files except that the file is stored in RAM rather than on disk.","pos":[1887,1987]},{"content":"A memory file is useful for fast temporary storage or for transferring raw bytes or serialized objects between independent processes.","pos":[1988,2121]},{"content":"<ph id=\"ph1\">`CMemFile`</ph> objects can automatically allocate their own memory or you can attach your own memory block to the <ph id=\"ph2\">`CMemFile`</ph> object by calling <bpt id=\"p1\">[</bpt>Attach<ept id=\"p1\">](#cmemfile__attach)</ept>.","pos":[2128,2295],"source":"`CMemFile` objects can automatically allocate their own memory or you can attach your own memory block to the `CMemFile` object by calling [Attach](#cmemfile__attach)."},{"content":"In either case, memory for growing the memory file automatically is allocated in <ph id=\"ph1\">`nGrowBytes`</ph>-sized increments if <ph id=\"ph2\">`nGrowBytes`</ph> is not zero.","pos":[2296,2435],"source":" In either case, memory for growing the memory file automatically is allocated in `nGrowBytes`-sized increments if `nGrowBytes` is not zero."},{"pos":[2442,2682],"content":"The memory block will automatically be deleted upon destruction of the <ph id=\"ph1\">`CMemFile`</ph> object if the memory was originally allocated by the <ph id=\"ph2\">`CMemFile`</ph> object; otherwise, you are responsible for deallocating the memory you attached to the object.","source":"The memory block will automatically be deleted upon destruction of the `CMemFile` object if the memory was originally allocated by the `CMemFile` object; otherwise, you are responsible for deallocating the memory you attached to the object."},{"pos":[2689,2835],"content":"You can access the memory block through the pointer supplied when you detach it from the <ph id=\"ph1\">`CMemFile`</ph> object by calling <bpt id=\"p1\">[</bpt>Detach<ept id=\"p1\">](#cmemfile__detach)</ept>.","source":"You can access the memory block through the pointer supplied when you detach it from the `CMemFile` object by calling [Detach](#cmemfile__detach)."},{"content":"The most common use of <ph id=\"ph1\">`CMemFile`</ph> is to create a <ph id=\"ph2\">`CMemFile`</ph> object and use it by calling <bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../../mfc/reference/cfile-class.md)</ept> member functions.","pos":[2842,2992],"source":"The most common use of `CMemFile` is to create a `CMemFile` object and use it by calling [CFile](../../mfc/reference/cfile-class.md) member functions."},{"content":"Note that creating a <ph id=\"ph1\">`CMemFile`</ph> automatically opens it: you do not call <bpt id=\"p1\">[</bpt>CFile::Open<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__open)</ept>, which is only used for disk files.","pos":[2993,3162],"source":" Note that creating a `CMemFile` automatically opens it: you do not call [CFile::Open](../../mfc/reference/cfile-class.md#cfile__open), which is only used for disk files."},{"content":"Because <ph id=\"ph1\">`CMemFile`</ph> doesn't use a disk file, the data member <ph id=\"ph2\">`CFile::m_hFile`</ph> is not used.","pos":[3163,3252],"source":" Because `CMemFile` doesn't use a disk file, the data member `CFile::m_hFile` is not used."},{"content":"The <ph id=\"ph1\">`CFile`</ph> member functions <bpt id=\"p1\">[</bpt>Duplicate<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__duplicate)</ept>, <bpt id=\"p2\">[</bpt>LockRange<ept id=\"p2\">](../../mfc/reference/cfile-class.md#cfile__lockrange)</ept>, and <bpt id=\"p3\">[</bpt>UnlockRange<ept id=\"p3\">](../../mfc/reference/cfile-class.md#cfile__unlockrange)</ept> are not implemented for <ph id=\"ph2\">`CMemFile`</ph>.","pos":[3259,3528],"source":"The `CFile` member functions [Duplicate](../../mfc/reference/cfile-class.md#cfile__duplicate), [LockRange](../../mfc/reference/cfile-class.md#cfile__lockrange), and [UnlockRange](../../mfc/reference/cfile-class.md#cfile__unlockrange) are not implemented for `CMemFile`."},{"content":"If you call these functions on a <ph id=\"ph1\">`CMemFile`</ph> object, you will get a <bpt id=\"p1\">[</bpt>CNotSupportedException<ept id=\"p1\">](../../mfc/reference/cnotsupportedexception-class.md)</ept>.","pos":[3529,3674],"source":" If you call these functions on a `CMemFile` object, you will get a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md)."},{"content":"<ph id=\"ph1\">`CMemFile`</ph> uses the run-time library functions <bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept>, <bpt id=\"p2\">[</bpt>realloc<ept id=\"p2\">](../../c-runtime-library/reference/realloc.md)</ept>, and <bpt id=\"p3\">[</bpt>free<ept id=\"p3\">](../../c-runtime-library/reference/free.md)</ept> to allocate, reallocate, and deallocate memory; and the intrinsic <bpt id=\"p4\">[</bpt>memcpy<ept id=\"p4\">](../../c-runtime-library/reference/memcpy-wmemcpy.md)</ept> to block copy memory when reading and writing.","pos":[3681,4068],"source":"`CMemFile` uses the run-time library functions [malloc](../../c-runtime-library/reference/malloc.md), [realloc](../../c-runtime-library/reference/realloc.md), and [free](../../c-runtime-library/reference/free.md) to allocate, reallocate, and deallocate memory; and the intrinsic [memcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md) to block copy memory when reading and writing."},{"content":"If you'd like to change this behavior or the behavior when <ph id=\"ph1\">`CMemFile`</ph> grows a file, derive your own class from <ph id=\"ph2\">`CMemFile`</ph> and override the appropriate functions.","pos":[4069,4230],"source":" If you'd like to change this behavior or the behavior when `CMemFile` grows a file, derive your own class from `CMemFile` and override the appropriate functions."},{"pos":[4237,4496],"content":"For more information on <ph id=\"ph1\">`CMemFile`</ph>, see the articles <bpt id=\"p1\">[</bpt>Files in MFC<ept id=\"p1\">](../../mfc/files-in-mfc.md)</ept> and <bpt id=\"p2\">[</bpt>Memory Management (MFC)<ept id=\"p2\">](../../mfc/memory-management.md)</ept> and see <bpt id=\"p3\">[</bpt>File Handling<ept id=\"p3\">](../../c-runtime-library/file-handling.md)</ept> in the <bpt id=\"p4\">*</bpt>Run-Time Library Reference<ept id=\"p4\">*</ept>.","source":"For more information on `CMemFile`, see the articles [Files in MFC](../../mfc/files-in-mfc.md) and [Memory Management (MFC)](../../mfc/memory-management.md) and see [File Handling](../../c-runtime-library/file-handling.md) in the *Run-Time Library Reference*."},{"pos":[4505,4526],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[4530,4577],"content":"<bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>","source":"[CObject](../../mfc/reference/cobject-class.md)"},{"pos":[4584,4627],"content":"<bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../../mfc/reference/cfile-class.md)</ept>","source":"[CFile](../../mfc/reference/cfile-class.md)"},{"pos":[4653,4665],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4669,4686],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afx.h","source":"**Header:** afx.h"},{"pos":[4696,4743],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__alloc\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Alloc","linkify":"<a name=\"cmemfile__alloc\"></a>  CMemFile::Alloc","source":"<a name=\"cmemfile__alloc\"></a>  CMemFile::Alloc"},{"pos":[4747,4802],"content":"This function is called by <ph id=\"ph1\">`CMemFile`</ph> member functions.","source":"This function is called by `CMemFile` member functions."},{"pos":[4863,4873],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Number of bytes of memory to be allocated.","pos":[4889,4931]},{"pos":[4941,4953],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[4957,5044],"content":"A pointer to the memory block that was allocated, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the allocation failed.","source":"A pointer to the memory block that was allocated, or **NULL** if the allocation failed."},{"pos":[5054,5061],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Override this function to implement custom memory allocation.","pos":[5065,5126]},{"content":"If you override this function, you'll probably want to override <bpt id=\"p1\">[</bpt>Free<ept id=\"p1\">](#cmemfile__free)</ept> and <bpt id=\"p2\">[</bpt>Realloc<ept id=\"p2\">](#cmemfile__realloc)</ept> as well.","pos":[5127,5257],"source":" If you override this function, you'll probably want to override [Free](#cmemfile__free) and [Realloc](#cmemfile__realloc) as well."},{"pos":[5264,5399],"content":"The default implementation uses the run-time library function <bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept> to allocate memory.","source":"The default implementation uses the run-time library function [malloc](../../c-runtime-library/reference/malloc.md) to allocate memory."},{"pos":[5409,5458],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__attach\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Attach","linkify":"<a name=\"cmemfile__attach\"></a>  CMemFile::Attach","source":"<a name=\"cmemfile__attach\"></a>  CMemFile::Attach"},{"pos":[5462,5523],"content":"Call this function to attach a block of memory to <ph id=\"ph1\">`CMemFile`</ph>.","source":"Call this function to attach a block of memory to `CMemFile`."},{"pos":[5633,5643],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to the buffer to be attached to <ph id=\"ph1\">`CMemFile`</ph>.","pos":[5661,5712],"source":" Pointer to the buffer to be attached to `CMemFile`."},{"content":"An integer that specifies the size of the buffer in bytes.","pos":[5736,5794]},{"content":"The memory allocation increment in bytes.","pos":[5817,5858]},{"pos":[5868,5875],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5879,5948],"content":"This causes <ph id=\"ph1\">`CMemFile`</ph> to use the block of memory as the memory file.","source":"This causes `CMemFile` to use the block of memory as the memory file."},{"content":"If <ph id=\"ph1\">`nGrowBytes`</ph> is 0, <ph id=\"ph2\">`CMemFile`</ph> will set the file length to <ph id=\"ph3\">`nBufferSize`</ph>.","pos":[5955,6030],"source":"If `nGrowBytes` is 0, `CMemFile` will set the file length to `nBufferSize`."},{"content":"This means that the data in the memory block before it was attached to <ph id=\"ph1\">`CMemFile`</ph> will be used as the file.","pos":[6031,6138],"source":" This means that the data in the memory block before it was attached to `CMemFile` will be used as the file."},{"content":"Memory files created in this manner cannot be grown.","pos":[6139,6191]},{"content":"Since the file cannot be grown, be careful not to cause <ph id=\"ph1\">`CMemFile`</ph> to attempt to grow the file.","pos":[6198,6293],"source":"Since the file cannot be grown, be careful not to cause `CMemFile` to attempt to grow the file."},{"content":"For example, don't call the <ph id=\"ph1\">`CMemFile`</ph> overrides of <bpt id=\"p1\">[</bpt>CFile:Write<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__write)</ept> to write past the end or don't call <bpt id=\"p2\">[</bpt>CFile:SetLength<ept id=\"p2\">](../../mfc/reference/cfile-class.md#cfile__setlength)</ept> with a length longer than <ph id=\"ph2\">`nBufferSize`</ph>.","pos":[6294,6556],"source":" For example, don't call the `CMemFile` overrides of [CFile:Write](../../mfc/reference/cfile-class.md#cfile__write) to write past the end or don't call [CFile:SetLength](../../mfc/reference/cfile-class.md#cfile__setlength) with a length longer than `nBufferSize`."},{"content":"If <ph id=\"ph1\">`nGrowBytes`</ph> is greater than 0, <ph id=\"ph2\">`CMemFile`</ph> will ignore the contents of the memory block you've attached.","pos":[6563,6670],"source":"If `nGrowBytes` is greater than 0, `CMemFile` will ignore the contents of the memory block you've attached."},{"content":"You'll have to write the contents of the memory file from scratch using the <ph id=\"ph1\">`CMemFile`</ph> override of <ph id=\"ph2\">`CFile::Write`</ph>.","pos":[6671,6785],"source":" You'll have to write the contents of the memory file from scratch using the `CMemFile` override of `CFile::Write`."},{"content":"If you attempt to write past the end of the file or grow the file by calling the <ph id=\"ph1\">`CMemFile`</ph> override of <ph id=\"ph2\">`CFile::SetLength`</ph>, <ph id=\"ph3\">`CMemFile`</ph> will grow the memory allocation in increments of <ph id=\"ph4\">`nGrowBytes`</ph>.","pos":[6786,6983],"source":" If you attempt to write past the end of the file or grow the file by calling the `CMemFile` override of `CFile::SetLength`, `CMemFile` will grow the memory allocation in increments of `nGrowBytes`."},{"content":"Growing the memory allocation will fail if the memory block you pass to <bpt id=\"p1\">**</bpt>Attach<ept id=\"p1\">**</ept> wasn't allocated with a method compatible with <bpt id=\"p2\">[</bpt>Alloc<ept id=\"p2\">](#cmemfile__alloc)</ept>.","pos":[6984,7140],"source":" Growing the memory allocation will fail if the memory block you pass to **Attach** wasn't allocated with a method compatible with [Alloc](#cmemfile__alloc)."},{"content":"To be compatible with the default implementation of <ph id=\"ph1\">`Alloc`</ph>, you must allocate the memory with the run-time library function <bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept> or <bpt id=\"p2\">[</bpt>calloc<ept id=\"p2\">](../../c-runtime-library/reference/calloc.md)</ept>.","pos":[7141,7377],"source":" To be compatible with the default implementation of `Alloc`, you must allocate the memory with the run-time library function [malloc](../../c-runtime-library/reference/malloc.md) or [calloc](../../c-runtime-library/reference/calloc.md)."},{"pos":[7387,7440],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__cmemfile\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::CMemFile","linkify":"<a name=\"cmemfile__cmemfile\"></a>  CMemFile::CMemFile","source":"<a name=\"cmemfile__cmemfile\"></a>  CMemFile::CMemFile"},{"content":"The first overload opens an empty memory file.","pos":[7444,7490]},{"pos":[7639,7649],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The memory allocation increment in bytes.","pos":[7669,7710]},{"content":"<bpt id=\"p1\">*</bpt>lpBuffe<ept id=\"p1\">*</ept>r","pos":[7717,7727],"source":"*lpBuffe*r"},{"content":"Pointer to a buffer that receives information of the size <ph id=\"ph1\">`nBufferSize`</ph>.","pos":[7731,7803],"source":" Pointer to a buffer that receives information of the size `nBufferSize`."},{"content":"An integer that specifies the size of the file buffer, in bytes.","pos":[7827,7891]},{"pos":[7901,7908],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7912,8051],"content":"Note that the file is opened by the constructor and that you should not call <bpt id=\"p1\">[</bpt>CFile::Open<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__open)</ept>.","source":"Note that the file is opened by the constructor and that you should not call [CFile::Open](../../mfc/reference/cfile-class.md#cfile__open)."},{"content":"The second overload acts the same as if you used the first constructor and immediately called <bpt id=\"p1\">[</bpt>Attach<ept id=\"p1\">](#cmemfile__attach)</ept> with the same parameters.","pos":[8058,8205],"source":"The second overload acts the same as if you used the first constructor and immediately called [Attach](#cmemfile__attach) with the same parameters."},{"content":"See <bpt id=\"p1\">**</bpt>Attach<ept id=\"p1\">**</ept> for details.","pos":[8206,8233],"source":" See **Attach** for details."},{"pos":[8243,8250],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8254,8351],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCFiles#36<ept id=\"p2\">](../../atl-mfc-shared/reference/codesnippet/cpp/cmemfile-class_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCFiles#36](../../atl-mfc-shared/reference/codesnippet/cpp/cmemfile-class_1.cpp)]"},{"pos":[8361,8410],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__detach\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Detach","linkify":"<a name=\"cmemfile__detach\"></a>  CMemFile::Detach","source":"<a name=\"cmemfile__detach\"></a>  CMemFile::Detach"},{"pos":[8414,8495],"content":"Call this function to get a pointer to the memory block being used by <ph id=\"ph1\">`CMemFile`</ph>.","source":"Call this function to get a pointer to the memory block being used by `CMemFile`."},{"pos":[8536,8548],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A pointer to the memory block that contains the contents of the memory file.","pos":[8552,8628]},{"pos":[8638,8645],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Calling this function also closes the <ph id=\"ph1\">`CMemFile`</ph>.","pos":[8649,8698],"source":"Calling this function also closes the `CMemFile`."},{"content":"You can reattach the memory block to <ph id=\"ph1\">`CMemFile`</ph> by calling <bpt id=\"p1\">[</bpt>Attach<ept id=\"p1\">](#cmemfile__attach)</ept>.","pos":[8699,8786],"source":" You can reattach the memory block to `CMemFile` by calling [Attach](#cmemfile__attach)."},{"content":"If you want to reattach the file and use the data in it, you should call <bpt id=\"p1\">[</bpt>CFile::GetLength<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__getlength)</ept> to get the length of the file before calling <bpt id=\"p2\">**</bpt>Detach<ept id=\"p2\">**</ept>.","pos":[8787,8988],"source":" If you want to reattach the file and use the data in it, you should call [CFile::GetLength](../../mfc/reference/cfile-class.md#cfile__getlength) to get the length of the file before calling **Detach**."},{"content":"Note that if you attach a memory block to <ph id=\"ph1\">`CMemFile`</ph> so that you can use its data ( <ph id=\"ph2\">`nGrowBytes`</ph> == 0), then you won't be able to grow the memory file.","pos":[8989,9140],"source":" Note that if you attach a memory block to `CMemFile` so that you can use its data ( `nGrowBytes` == 0), then you won't be able to grow the memory file."},{"pos":[9150,9195],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__free\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Free","linkify":"<a name=\"cmemfile__free\"></a>  CMemFile::Free","source":"<a name=\"cmemfile__free\"></a>  CMemFile::Free"},{"pos":[9199,9254],"content":"This function is called by <ph id=\"ph1\">`CMemFile`</ph> member functions.","source":"This function is called by `CMemFile` member functions."},{"pos":[9311,9321],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to the memory to be deallocated <bpt id=\"p1\">*</bpt>.<ept id=\"p1\">*</ept>","pos":[9336,9379],"source":" Pointer to the memory to be deallocated *.*"},{"pos":[9389,9396],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Override this function to implement custom memory deallocation.","pos":[9400,9463]},{"content":"If you override this function, you'll probably want to override <bpt id=\"p1\">[</bpt>Alloc<ept id=\"p1\">](#cmemfile__alloc)</ept> and <bpt id=\"p2\">[</bpt>Realloc<ept id=\"p2\">](#cmemfile__realloc)</ept> as well.","pos":[9464,9596],"source":" If you override this function, you'll probably want to override [Alloc](#cmemfile__alloc) and [Realloc](#cmemfile__realloc) as well."},{"pos":[9606,9659],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__growfile\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::GrowFile","linkify":"<a name=\"cmemfile__growfile\"></a>  CMemFile::GrowFile","source":"<a name=\"cmemfile__growfile\"></a>  CMemFile::GrowFile"},{"pos":[9663,9733],"content":"This function is called by several of the <ph id=\"ph1\">`CMemFile`</ph> member functions.","source":"This function is called by several of the `CMemFile` member functions."},{"pos":[9798,9808],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"New size of the memory file.","pos":[9826,9854]},{"pos":[9864,9871],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You can override it if you want to change how <ph id=\"ph1\">`CMemFile`</ph> grows its file.","pos":[9875,9947],"source":"You can override it if you want to change how `CMemFile` grows its file."},{"content":"The default implementation calls <bpt id=\"p1\">[</bpt>Realloc<ept id=\"p1\">](#cmemfile__realloc)</ept> to grow an existing block (or <bpt id=\"p2\">[</bpt>Alloc<ept id=\"p2\">](#cmemfile__alloc)</ept> to create a memory block), allocating memory in multiples of the <ph id=\"ph1\">`nGrowBytes`</ph> value specified in the constructor or <bpt id=\"p3\">[</bpt>Attach<ept id=\"p3\">](#cmemfile__attach)</ept> call.","pos":[9948,10216],"source":" The default implementation calls [Realloc](#cmemfile__realloc) to grow an existing block (or [Alloc](#cmemfile__alloc) to create a memory block), allocating memory in multiples of the `nGrowBytes` value specified in the constructor or [Attach](#cmemfile__attach) call."},{"pos":[10226,10275],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__memcpy\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Memcpy","linkify":"<a name=\"cmemfile__memcpy\"></a>  CMemFile::Memcpy","source":"<a name=\"cmemfile__memcpy\"></a>  CMemFile::Memcpy"},{"pos":[10279,10509],"content":"This function is called by the <ph id=\"ph1\">`CMemFile`</ph> overrides of <bpt id=\"p1\">[</bpt>CFile::Read<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__read)</ept> and <bpt id=\"p2\">[</bpt>CFile::Write<ept id=\"p2\">](../../mfc/reference/cfile-class.md#cfile__write)</ept> to transfer data to and from the memory file.","source":"This function is called by the `CMemFile` overrides of [CFile::Read](../../mfc/reference/cfile-class.md#cfile__read) and [CFile::Write](../../mfc/reference/cfile-class.md#cfile__write) to transfer data to and from the memory file."},{"pos":[10632,10642],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to the memory block into which the source memory will be copied.","pos":[10663,10735]},{"content":"Pointer to the source memory block.","pos":[10759,10794]},{"content":"Number of bytes to be copied.","pos":[10813,10842]},{"pos":[10852,10864],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[10868,10892],"content":"A copy of <ph id=\"ph1\">`lpMemTarget`</ph>.","source":"A copy of `lpMemTarget`."},{"pos":[10902,10909],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[10913,11007],"content":"Override this function if you want to change the way that <ph id=\"ph1\">`CMemFile`</ph> does these memory copies.","source":"Override this function if you want to change the way that `CMemFile` does these memory copies."},{"pos":[11017,11068],"content":"<bpt id=\"p1\">&lt;a name=\"cmemfile__realloc\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CMemFile::Realloc","linkify":"<a name=\"cmemfile__realloc\"></a>  CMemFile::Realloc","source":"<a name=\"cmemfile__realloc\"></a>  CMemFile::Realloc"},{"pos":[11072,11127],"content":"This function is called by <ph id=\"ph1\">`CMemFile`</ph> member functions.","source":"This function is called by `CMemFile` member functions."},{"pos":[11214,11224],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the memory block to be reallocated.","pos":[11239,11287]},{"content":"New size for the memory block.","pos":[11306,11336]},{"pos":[11346,11358],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[11362,11474],"content":"A pointer to the memory block that was reallocated (and possibly moved), or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the reallocation failed.","source":"A pointer to the memory block that was reallocated (and possibly moved), or **NULL** if the reallocation failed."},{"pos":[11484,11491],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Override this function to implement custom memory reallocation.","pos":[11495,11558]},{"content":"If you override this function, you'll probably want to override <bpt id=\"p1\">[</bpt>Alloc<ept id=\"p1\">](#cmemfile__alloc)</ept> and <bpt id=\"p2\">[</bpt>Free<ept id=\"p2\">](#cmemfile__free)</ept> as well.","pos":[11559,11685],"source":" If you override this function, you'll probably want to override [Alloc](#cmemfile__alloc) and [Free](#cmemfile__free) as well."},{"pos":[11694,11702],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>CFile Class<ept id=\"p1\">](../../mfc/reference/cfile-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[11706,11756],"source":"[CFile Class](../../mfc/reference/cfile-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept>","pos":[11759,11807],"source":" [Hierarchy Chart](../../mfc/hierarchy-chart.md)"}],"content":"---\ntitle: \"CMemFile Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CMemFile\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"memory files\"\n  - \"CMemFile class\"\n  - \"temporary files, memory files\"\nms.assetid: 20e86515-e465-4f73-b2ea-e49789d63165\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CMemFile Class\nThe [CFile](../../mfc/reference/cfile-class.md)-derived class that supports memory files.  \n  \n## Syntax  \n  \n```  \nclass CMemFile : public CFile  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMemFile::CMemFile](#cmemfile__cmemfile)|Constructs a memory file object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMemFile::Attach](#cmemfile__attach)|Attaches a block of memory to `CMemFile`.|  \n|[CMemFile::Detach](#cmemfile__detach)|Detaches the block of memory from `CMemFile` and returns a pointer to the block of memory detached.|  \n  \n### Protected Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMemFile::Alloc](#cmemfile__alloc)|Override to modify memory allocation behavior.|  \n|[CMemFile::Free](#cmemfile__free)|Override to modify memory deallocation behavior.|  \n|[CMemFile::GrowFile](#cmemfile__growfile)|Override to modify behavior when growing a file.|  \n|[CMemFile::Memcpy](#cmemfile__memcpy)|Override to modify memory copy behavior when reading and writing files.|  \n|[CMemFile::Realloc](#cmemfile__realloc)|Override to modify memory reallocation behavior.|  \n  \n## Remarks  \n These memory files behave like disk files except that the file is stored in RAM rather than on disk. A memory file is useful for fast temporary storage or for transferring raw bytes or serialized objects between independent processes.  \n  \n `CMemFile` objects can automatically allocate their own memory or you can attach your own memory block to the `CMemFile` object by calling [Attach](#cmemfile__attach). In either case, memory for growing the memory file automatically is allocated in `nGrowBytes`-sized increments if `nGrowBytes` is not zero.  \n  \n The memory block will automatically be deleted upon destruction of the `CMemFile` object if the memory was originally allocated by the `CMemFile` object; otherwise, you are responsible for deallocating the memory you attached to the object.  \n  \n You can access the memory block through the pointer supplied when you detach it from the `CMemFile` object by calling [Detach](#cmemfile__detach).  \n  \n The most common use of `CMemFile` is to create a `CMemFile` object and use it by calling [CFile](../../mfc/reference/cfile-class.md) member functions. Note that creating a `CMemFile` automatically opens it: you do not call [CFile::Open](../../mfc/reference/cfile-class.md#cfile__open), which is only used for disk files. Because `CMemFile` doesn't use a disk file, the data member `CFile::m_hFile` is not used.  \n  \n The `CFile` member functions [Duplicate](../../mfc/reference/cfile-class.md#cfile__duplicate), [LockRange](../../mfc/reference/cfile-class.md#cfile__lockrange), and [UnlockRange](../../mfc/reference/cfile-class.md#cfile__unlockrange) are not implemented for `CMemFile`. If you call these functions on a `CMemFile` object, you will get a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md).  \n  \n `CMemFile` uses the run-time library functions [malloc](../../c-runtime-library/reference/malloc.md), [realloc](../../c-runtime-library/reference/realloc.md), and [free](../../c-runtime-library/reference/free.md) to allocate, reallocate, and deallocate memory; and the intrinsic [memcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md) to block copy memory when reading and writing. If you'd like to change this behavior or the behavior when `CMemFile` grows a file, derive your own class from `CMemFile` and override the appropriate functions.  \n  \n For more information on `CMemFile`, see the articles [Files in MFC](../../mfc/files-in-mfc.md) and [Memory Management (MFC)](../../mfc/memory-management.md) and see [File Handling](../../c-runtime-library/file-handling.md) in the *Run-Time Library Reference*.  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n [CFile](../../mfc/reference/cfile-class.md)  \n  \n `CMemFile`  \n  \n## Requirements  \n **Header:** afx.h  \n  \n##  <a name=\"cmemfile__alloc\"></a>  CMemFile::Alloc  \n This function is called by `CMemFile` member functions.  \n  \n```  \nvirtual BYTE* Alloc(SIZE_T nBytes);\n```  \n  \n### Parameters  \n `nBytes`  \n Number of bytes of memory to be allocated.  \n  \n### Return Value  \n A pointer to the memory block that was allocated, or **NULL** if the allocation failed.  \n  \n### Remarks  \n Override this function to implement custom memory allocation. If you override this function, you'll probably want to override [Free](#cmemfile__free) and [Realloc](#cmemfile__realloc) as well.  \n  \n The default implementation uses the run-time library function [malloc](../../c-runtime-library/reference/malloc.md) to allocate memory.  \n  \n##  <a name=\"cmemfile__attach\"></a>  CMemFile::Attach  \n Call this function to attach a block of memory to `CMemFile`.  \n  \n```  \nvoid Attach(\n    BYTE* lpBuffer,  \n    UINT nBufferSize,  \n    UINT nGrowBytes = 0);\n```  \n  \n### Parameters  \n `lpBuffer`  \n Pointer to the buffer to be attached to `CMemFile`.  \n  \n `nBufferSize`  \n An integer that specifies the size of the buffer in bytes.  \n  \n `nGrowBytes`  \n The memory allocation increment in bytes.  \n  \n### Remarks  \n This causes `CMemFile` to use the block of memory as the memory file.  \n  \n If `nGrowBytes` is 0, `CMemFile` will set the file length to `nBufferSize`. This means that the data in the memory block before it was attached to `CMemFile` will be used as the file. Memory files created in this manner cannot be grown.  \n  \n Since the file cannot be grown, be careful not to cause `CMemFile` to attempt to grow the file. For example, don't call the `CMemFile` overrides of [CFile:Write](../../mfc/reference/cfile-class.md#cfile__write) to write past the end or don't call [CFile:SetLength](../../mfc/reference/cfile-class.md#cfile__setlength) with a length longer than `nBufferSize`.  \n  \n If `nGrowBytes` is greater than 0, `CMemFile` will ignore the contents of the memory block you've attached. You'll have to write the contents of the memory file from scratch using the `CMemFile` override of `CFile::Write`. If you attempt to write past the end of the file or grow the file by calling the `CMemFile` override of `CFile::SetLength`, `CMemFile` will grow the memory allocation in increments of `nGrowBytes`. Growing the memory allocation will fail if the memory block you pass to **Attach** wasn't allocated with a method compatible with [Alloc](#cmemfile__alloc). To be compatible with the default implementation of `Alloc`, you must allocate the memory with the run-time library function [malloc](../../c-runtime-library/reference/malloc.md) or [calloc](../../c-runtime-library/reference/calloc.md).  \n  \n##  <a name=\"cmemfile__cmemfile\"></a>  CMemFile::CMemFile  \n The first overload opens an empty memory file.  \n  \n```  \nCMemFile(\n    UINT nGrowBytes = 1024);\n\n \nCMemFile(\n    BYTE* lpBuffer,  \n    UINT nBufferSize,  \n    UINT nGrowBytes = 0);\n```  \n  \n### Parameters  \n `nGrowBytes`  \n The memory allocation increment in bytes.  \n  \n *lpBuffe*r  \n Pointer to a buffer that receives information of the size `nBufferSize`.  \n  \n `nBufferSize`  \n An integer that specifies the size of the file buffer, in bytes.  \n  \n### Remarks  \n Note that the file is opened by the constructor and that you should not call [CFile::Open](../../mfc/reference/cfile-class.md#cfile__open).  \n  \n The second overload acts the same as if you used the first constructor and immediately called [Attach](#cmemfile__attach) with the same parameters. See **Attach** for details.  \n  \n### Example  \n [!code-cpp[NVC_MFCFiles#36](../../atl-mfc-shared/reference/codesnippet/cpp/cmemfile-class_1.cpp)]  \n  \n##  <a name=\"cmemfile__detach\"></a>  CMemFile::Detach  \n Call this function to get a pointer to the memory block being used by `CMemFile`.  \n  \n```  \nBYTE* Detach();\n```  \n  \n### Return Value  \n A pointer to the memory block that contains the contents of the memory file.  \n  \n### Remarks  \n Calling this function also closes the `CMemFile`. You can reattach the memory block to `CMemFile` by calling [Attach](#cmemfile__attach). If you want to reattach the file and use the data in it, you should call [CFile::GetLength](../../mfc/reference/cfile-class.md#cfile__getlength) to get the length of the file before calling **Detach**. Note that if you attach a memory block to `CMemFile` so that you can use its data ( `nGrowBytes` == 0), then you won't be able to grow the memory file.  \n  \n##  <a name=\"cmemfile__free\"></a>  CMemFile::Free  \n This function is called by `CMemFile` member functions.  \n  \n```  \nvirtual void Free(BYTE* lpMem);\n```  \n  \n### Parameters  \n `lpMem`  \n Pointer to the memory to be deallocated *.*  \n  \n### Remarks  \n Override this function to implement custom memory deallocation. If you override this function, you'll probably want to override [Alloc](#cmemfile__alloc) and [Realloc](#cmemfile__realloc) as well.  \n  \n##  <a name=\"cmemfile__growfile\"></a>  CMemFile::GrowFile  \n This function is called by several of the `CMemFile` member functions.  \n  \n```  \nvirtual void GrowFile(SIZE_T dwNewLen);\n```  \n  \n### Parameters  \n `dwNewLen`  \n New size of the memory file.  \n  \n### Remarks  \n You can override it if you want to change how `CMemFile` grows its file. The default implementation calls [Realloc](#cmemfile__realloc) to grow an existing block (or [Alloc](#cmemfile__alloc) to create a memory block), allocating memory in multiples of the `nGrowBytes` value specified in the constructor or [Attach](#cmemfile__attach) call.  \n  \n##  <a name=\"cmemfile__memcpy\"></a>  CMemFile::Memcpy  \n This function is called by the `CMemFile` overrides of [CFile::Read](../../mfc/reference/cfile-class.md#cfile__read) and [CFile::Write](../../mfc/reference/cfile-class.md#cfile__write) to transfer data to and from the memory file.  \n  \n```  \nvirtual BYTE* Memcpy(\n    BYTE* lpMemTarget,  \n    const BYTE* lpMemSource,  \n    SIZE_T nBytes);\n```  \n  \n### Parameters  \n `lpMemTarget`  \n Pointer to the memory block into which the source memory will be copied.  \n  \n `lpMemSource`  \n Pointer to the source memory block.  \n  \n `nBytes`  \n Number of bytes to be copied.  \n  \n### Return Value  \n A copy of `lpMemTarget`.  \n  \n### Remarks  \n Override this function if you want to change the way that `CMemFile` does these memory copies.  \n  \n##  <a name=\"cmemfile__realloc\"></a>  CMemFile::Realloc  \n This function is called by `CMemFile` member functions.  \n  \n```  \nvirtual BYTE* Realloc(\n    BYTE* lpMem,  \n    SIZE_T nBytes);\n```  \n  \n### Parameters  \n `lpMem`  \n A pointer to the memory block to be reallocated.  \n  \n `nBytes`  \n New size for the memory block.  \n  \n### Return Value  \n A pointer to the memory block that was reallocated (and possibly moved), or **NULL** if the reallocation failed.  \n  \n### Remarks  \n Override this function to implement custom memory reallocation. If you override this function, you'll probably want to override [Alloc](#cmemfile__alloc) and [Free](#cmemfile__free) as well.  \n  \n## See Also  \n [CFile Class](../../mfc/reference/cfile-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n\n\n"}