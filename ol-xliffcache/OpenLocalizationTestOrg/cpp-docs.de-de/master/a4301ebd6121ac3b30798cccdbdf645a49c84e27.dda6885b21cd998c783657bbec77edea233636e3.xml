{"nodes":[{"pos":[12,47],"content":"regex_traits Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"regex_traits Class | Microsoft Docs","pos":[0,35]}]},{"pos":[670,688],"content":"regex_traits Class","linkify":"regex_traits Class","nodes":[{"content":"regex_traits Class","pos":[0,18]}]},{"content":"Describes characteristics of elements for matching.","pos":[689,740]},{"pos":[749,755],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1674,1684],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element type to describe.","pos":[1698,1727]},{"pos":[1736,1743],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes various regular expression traits for type <ph id=\"ph1\">`Elem`</ph>.","pos":[1747,1826],"source":"The template class describes various regular expression traits for type `Elem`."},{"content":"The template class <bpt id=\"p1\">[</bpt>basic_regex Class<ept id=\"p1\">](../standard-library/basic-regex-class.md)</ept> uses this information to manipulate elements of type <ph id=\"ph1\">`Elem`</ph>.","pos":[1827,1968],"source":" The template class [basic_regex Class](../standard-library/basic-regex-class.md) uses this information to manipulate elements of type `Elem`."},{"content":"Each <ph id=\"ph1\">`regex_traits`</ph> object holds an object of type <ph id=\"ph2\">`regex_traits::locale`</ph> which is used by some of its member functions.","pos":[1975,2095],"source":"Each `regex_traits` object holds an object of type `regex_traits::locale` which is used by some of its member functions."},{"content":"The default locale is a copy of <ph id=\"ph1\">`regex_traits::locale()`</ph>.","pos":[2096,2153],"source":" The default locale is a copy of `regex_traits::locale()`."},{"content":"The member function <ph id=\"ph1\">`imbue`</ph> replaces the locale object, and the member function <ph id=\"ph2\">`getloc`</ph> returns a copy of the locale object.","pos":[2154,2279],"source":" The member function `imbue` replaces the locale object, and the member function `getloc` returns a copy of the locale object."},{"pos":[2288,2300],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2304,2324],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[2331,2349],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2359,2434],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__char_class_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::char_class_type","linkify":"<a name=\"regex_traits__char_class_type\"></a>  regex_traits::char_class_type","source":"<a name=\"regex_traits__char_class_type\"></a>  regex_traits::char_class_type"},{"content":"The type of character class designators.","pos":[2438,2478]},{"pos":[2533,2540],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type is a synonym for an unspecified type that designates character classes.","pos":[2544,2624]},{"content":"Values of this type can be combined using the <ph id=\"ph1\">`|`</ph> operator to designate character classes that are the union of the classes designated by the operands.","pos":[2625,2776],"source":" Values of this type can be combined using the `|` operator to designate character classes that are the union of the classes designated by the operands."},{"pos":[2786,2793],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4885,4948],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::char_type","linkify":"<a name=\"regex_traits__char_type\"></a>  regex_traits::char_type","source":"<a name=\"regex_traits__char_type\"></a>  regex_traits::char_type"},{"content":"The type of an element.","pos":[4952,4975]},{"pos":[5026,5033],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5037,5095],"content":"The typedef is a synonym for the template argument <ph id=\"ph1\">`Elem`</ph>.","source":"The typedef is a synonym for the template argument `Elem`."},{"pos":[5105,5112],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7198,7255],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__getloc\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::getloc","linkify":"<a name=\"regex_traits__getloc\"></a>  regex_traits::getloc","source":"<a name=\"regex_traits__getloc\"></a>  regex_traits::getloc"},{"content":"Returns the stored locale object.","pos":[7259,7292]},{"pos":[7345,7352],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7356,7411],"content":"The member function returns the stored <ph id=\"ph1\">`locale`</ph> object.","source":"The member function returns the stored `locale` object."},{"pos":[7421,7428],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9511,9566],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__imbue\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::imbue","linkify":"<a name=\"regex_traits__imbue\"></a>  regex_traits::imbue","source":"<a name=\"regex_traits__imbue\"></a>  regex_traits::imbue"},{"content":"Alters the stored locale object.","pos":[9570,9602]},{"pos":[9663,9673],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The locale object to store.","pos":[9686,9713]},{"pos":[9723,9730],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[9734,9868],"content":"The member function copies <ph id=\"ph1\">`loc`</ph> to the stored <ph id=\"ph2\">`locale`</ph> object and returns a copy of the previous value of the stored <ph id=\"ph3\">`locale`</ph> object.","source":"The member function copies `loc` to the stored `locale` object and returns a copy of the previous value of the stored `locale` object."},{"pos":[9878,9885],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11967,12026],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__isctype\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::isctype","linkify":"<a name=\"regex_traits__isctype\"></a>  regex_traits::isctype","source":"<a name=\"regex_traits__isctype\"></a>  regex_traits::isctype"},{"content":"Tests for class membership.","pos":[12030,12057]},{"pos":[12137,12147],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element to test.","pos":[12159,12179]},{"content":"The classes to test for.","pos":[12195,12219]},{"pos":[12229,12236],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12240,12346],"content":"The member function returns true only if the character <ph id=\"ph1\">`ch`</ph> is in the character class designated by <ph id=\"ph2\">`cls`</ph>.","source":"The member function returns true only if the character `ch` is in the character class designated by `cls`."},{"pos":[12356,12363],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14447,14504],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::length","linkify":"<a name=\"regex_traits__length\"></a>  regex_traits::length","source":"<a name=\"regex_traits__length\"></a>  regex_traits::length"},{"content":"Returns the length of a nul-terminated sequence.","pos":[14508,14556]},{"pos":[14628,14638],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The nul-terminated sequence.","pos":[14651,14679]},{"pos":[14689,14696],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[14700,14778],"content":"The static member function returns <ph id=\"ph1\">`std::char_traits&lt;char_type&gt;::length(str)`</ph>.","source":"The static member function returns `std::char_traits<char_type>::length(str)`."},{"pos":[14788,14795],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16878,16945],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__locale_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::locale_type","linkify":"<a name=\"regex_traits__locale_type\"></a>  regex_traits::locale_type","source":"<a name=\"regex_traits__locale_type\"></a>  regex_traits::locale_type"},{"content":"The type of the stored locale object.","pos":[16949,16986]},{"pos":[17037,17044],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The typedef is a synonym for a type that encapsulates locales.","pos":[17048,17110]},{"content":"In the specializations <ph id=\"ph1\">`regex_traits&lt;char&gt;`</ph> and <ph id=\"ph2\">`regex_traits&lt;wchar_t&gt;`</ph> it is a synonym for <ph id=\"ph3\">`std::locale`</ph>.","pos":[17111,17217],"source":" In the specializations `regex_traits<char>` and `regex_traits<wchar_t>` it is a synonym for `std::locale`."},{"pos":[17227,17234],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19322,19399],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__lookup_classname\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::lookup_classname","linkify":"<a name=\"regex_traits__lookup_classname\"></a>  regex_traits::lookup_classname","source":"<a name=\"regex_traits__lookup_classname\"></a>  regex_traits::lookup_classname"},{"content":"Maps a sequence to a character class.","pos":[19403,19440]},{"pos":[19555,19565],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to look up.","pos":[19580,19613]},{"content":"End of sequence to look up.","pos":[19630,19657]},{"pos":[19667,19674],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a value that designates the character class named by the character sequence pointed to by its arguments.","pos":[19678,19810]},{"content":"The value does not depend on the case of the characters in the sequence.","pos":[19811,19883]},{"pos":[19890,20136],"content":"The specialization <ph id=\"ph1\">`regex_traits&lt;char&gt;`</ph> recognizes the names <ph id=\"ph2\">`\"d\"`</ph>, <ph id=\"ph3\">`\"s\"`</ph>, <ph id=\"ph4\">`\"w\"`</ph>, <ph id=\"ph5\">`\"alnum\"`</ph>, <ph id=\"ph6\">`\"alpha\"`</ph>, <ph id=\"ph7\">`\"blank\"`</ph>, <ph id=\"ph8\">`\"cntrl\"`</ph>, <ph id=\"ph9\">`\"digit\"`</ph>, <ph id=\"ph10\">`\"graph\"`</ph>, <ph id=\"ph11\">`\"lower\"`</ph>, <ph id=\"ph12\">`\"print\"`</ph>, <ph id=\"ph13\">`\"punct\"`</ph>, <ph id=\"ph14\">`\"space\"`</ph>, <ph id=\"ph15\">`\"upper\"`</ph>, and <ph id=\"ph16\">`\"xdigit\"`</ph>, all without regard to case.","source":"The specialization `regex_traits<char>` recognizes the names `\"d\"`, `\"s\"`, `\"w\"`, `\"alnum\"`, `\"alpha\"`, `\"blank\"`, `\"cntrl\"`, `\"digit\"`, `\"graph\"`, `\"lower\"`, `\"print\"`, `\"punct\"`, `\"space\"`, `\"upper\"`, and `\"xdigit\"`, all without regard to case."},{"pos":[20143,20407],"content":"The specialization <ph id=\"ph1\">`regex_traits&lt;wchar_t&gt;`</ph> recognizes the names <ph id=\"ph2\">`L\"d\"`</ph>, <ph id=\"ph3\">`L\"s\"`</ph>, <ph id=\"ph4\">`L\"w\"`</ph>, <ph id=\"ph5\">`L\"alnum\"`</ph>, <ph id=\"ph6\">`L\"alpha\"`</ph>, <ph id=\"ph7\">`L\"blank\"`</ph>, <ph id=\"ph8\">`L\"cntrl\"`</ph>, <ph id=\"ph9\">`L\"digit\"`</ph>, <ph id=\"ph10\">`L\"graph\"`</ph>, <ph id=\"ph11\">`L\"lower\"`</ph>, <ph id=\"ph12\">`L\"print\"`</ph>, <ph id=\"ph13\">`L\"punct\"`</ph>, <ph id=\"ph14\">`L\"space\"`</ph>, <ph id=\"ph15\">`L\"upper\"`</ph>, and <ph id=\"ph16\">`L\"xdigit\"`</ph>, all without regard to case.","source":"The specialization `regex_traits<wchar_t>` recognizes the names `L\"d\"`, `L\"s\"`, `L\"w\"`, `L\"alnum\"`, `L\"alpha\"`, `L\"blank\"`, `L\"cntrl\"`, `L\"digit\"`, `L\"graph\"`, `L\"lower\"`, `L\"print\"`, `L\"punct\"`, `L\"space\"`, `L\"upper\"`, and `L\"xdigit\"`, all without regard to case."},{"pos":[20417,20424],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22517,22598],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__lookup_collatename\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::lookup_collatename","linkify":"<a name=\"regex_traits__lookup_collatename\"></a>  regex_traits::lookup_collatename","source":"<a name=\"regex_traits__lookup_collatename\"></a>  regex_traits::lookup_collatename"},{"content":"Maps a sequence to a collating element.","pos":[22602,22641]},{"pos":[22754,22764],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to look up.","pos":[22779,22812]},{"content":"End of sequence to look up.","pos":[22829,22856]},{"pos":[22866,22873],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[22877,23069],"content":"The member function returns a string object containing the collating element corresponding to the sequence <ph id=\"ph1\">`[first, last)`</ph>, or an empty string if the sequence is not a valid collating element.","source":"The member function returns a string object containing the collating element corresponding to the sequence `[first, last)`, or an empty string if the sequence is not a valid collating element."},{"pos":[23079,23086],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25181,25250],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__regex_traits\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::regex_traits","linkify":"<a name=\"regex_traits__regex_traits\"></a>  regex_traits::regex_traits","source":"<a name=\"regex_traits__regex_traits\"></a>  regex_traits::regex_traits"},{"content":"Constructs the object.","pos":[25254,25276]},{"pos":[25317,25324],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25328,25431],"content":"The constructor constructs an object whose stored <ph id=\"ph1\">`locale`</ph> object is initialized to the default locale.","source":"The constructor constructs an object whose stored `locale` object is initialized to the default locale."},{"pos":[25441,25448],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27534,27597],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__size_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::size_type","linkify":"<a name=\"regex_traits__size_type\"></a>  regex_traits::size_type","source":"<a name=\"regex_traits__size_type\"></a>  regex_traits::size_type"},{"content":"The type of a sequence length.","pos":[27601,27631]},{"pos":[27680,27687],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The typedef is a synonym for an unsigned integral type.","pos":[27691,27746]},{"content":"In the specializations <ph id=\"ph1\">`regex_traits&lt;char&gt;`</ph> and <ph id=\"ph2\">`regex_traits&lt;wchar_t&gt;`</ph> it is a synonym for <ph id=\"ph3\">`std::size_t`</ph>.","pos":[27747,27853],"source":" In the specializations `regex_traits<char>` and `regex_traits<wchar_t>` it is a synonym for `std::size_t`."},{"pos":[27860,27903],"content":"The typedef is a synonym for <ph id=\"ph1\">`std::size_t`</ph>.","source":"The typedef is a synonym for `std::size_t`."},{"pos":[27913,27920],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[30006,30073],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__string_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::string_type","linkify":"<a name=\"regex_traits__string_type\"></a>  regex_traits::string_type","source":"<a name=\"regex_traits__string_type\"></a>  regex_traits::string_type"},{"content":"The type of a string of elements.","pos":[30077,30110]},{"pos":[30177,30184],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[30188,30238],"content":"The typedef is a synonym for <ph id=\"ph1\">`basic_string&lt;Elem&gt;`</ph>.","source":"The typedef is a synonym for `basic_string<Elem>`."},{"pos":[30248,30255],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[32343,32406],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__transform\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::transform","linkify":"<a name=\"regex_traits__transform\"></a>  regex_traits::transform","source":"<a name=\"regex_traits__transform\"></a>  regex_traits::transform"},{"content":"Converts to equivalent ordered sequence.","pos":[32410,32450]},{"pos":[32554,32564],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to transform.","pos":[32579,32614]},{"content":"End of sequence to transform.","pos":[32631,32660]},{"pos":[32670,32677],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a string that it generates by using a transformation rule that depends on the stored <ph id=\"ph1\">`locale`</ph> object.","pos":[32681,32810],"source":"The member function returns a string that it generates by using a transformation rule that depends on the stored `locale` object."},{"content":"For two character sequences designated by the iterator ranges <ph id=\"ph1\">`[first1, last1)`</ph> and <ph id=\"ph2\">`[first2, last2)`</ph>, <ph id=\"ph3\">`transform(first1, last1) &lt; transform(first2, last2)`</ph> if the character sequence designated by the iterator range <ph id=\"ph4\">`[first1, last1)`</ph> sorts before the character sequence designated by the iterator range <ph id=\"ph5\">`[first2, last2)`</ph>.","pos":[32811,33132],"source":" For two character sequences designated by the iterator ranges `[first1, last1)` and `[first2, last2)`, `transform(first1, last1) < transform(first2, last2)` if the character sequence designated by the iterator range `[first1, last1)` sorts before the character sequence designated by the iterator range `[first2, last2)`."},{"pos":[33142,33149],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[35235,35314],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__transform_primary\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::transform_primary","linkify":"<a name=\"regex_traits__transform_primary\"></a>  regex_traits::transform_primary","source":"<a name=\"regex_traits__transform_primary\"></a>  regex_traits::transform_primary"},{"content":"Converts to equivalent caseless ordered sequence.","pos":[35318,35367]},{"pos":[35479,35489],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to transform.","pos":[35504,35539]},{"content":"End of sequence to transform.","pos":[35556,35585]},{"pos":[35595,35602],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a string that it generates by using a transformation rule that depends on the stored <ph id=\"ph1\">`locale`</ph> object.","pos":[35606,35735],"source":"The member function returns a string that it generates by using a transformation rule that depends on the stored `locale` object."},{"content":"For two character sequences designated by the iterator ranges <ph id=\"ph1\">`[first1, last1)`</ph> and <ph id=\"ph2\">`[first2, last2)`</ph>, <ph id=\"ph3\">`transform_primary(first1, last1) &lt; transform_primary(first2, last2)`</ph> if the character sequence designated by the iterator range <ph id=\"ph4\">`[first1, last1)`</ph> sorts before the character sequence designated by the iterator range <ph id=\"ph5\">`[first2, last2)`</ph> without regard for case or accents.","pos":[35736,36108],"source":" For two character sequences designated by the iterator ranges `[first1, last1)` and `[first2, last2)`, `transform_primary(first1, last1) < transform_primary(first2, last2)` if the character sequence designated by the iterator range `[first1, last1)` sorts before the character sequence designated by the iterator range `[first2, last2)` without regard for case or accents."},{"pos":[36118,36125],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[38219,38282],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__translate\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::translate","linkify":"<a name=\"regex_traits__translate\"></a>  regex_traits::translate","source":"<a name=\"regex_traits__translate\"></a>  regex_traits::translate"},{"content":"Converts to equivalent matching element.","pos":[38286,38326]},{"pos":[38392,38402],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element to convert.","pos":[38414,38437]},{"pos":[38447,38454],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a character that it generates by using a transformation rule that depends on the stored <ph id=\"ph1\">`locale`</ph> object.","pos":[38458,38590],"source":"The member function returns a character that it generates by using a transformation rule that depends on the stored `locale` object."},{"content":"For two <ph id=\"ph1\">`char_type`</ph> objects <ph id=\"ph2\">`ch1`</ph> and <ph id=\"ph3\">`ch2`</ph>, <ph id=\"ph4\">`translate(ch1) == translate(ch2)`</ph> only if <ph id=\"ph5\">`ch1`</ph> and <ph id=\"ph6\">`ch2`</ph> should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a locale-sensitive match.","pos":[38591,38862],"source":" For two `char_type` objects `ch1` and `ch2`, `translate(ch1) == translate(ch2)` only if `ch1` and `ch2` should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a locale-sensitive match."},{"pos":[38872,38879],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[40965,41042],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__translate_nocase\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::translate_nocase","linkify":"<a name=\"regex_traits__translate_nocase\"></a>  regex_traits::translate_nocase","source":"<a name=\"regex_traits__translate_nocase\"></a>  regex_traits::translate_nocase"},{"content":"Converts to equivalent caseless matching element.","pos":[41046,41095]},{"pos":[41168,41178],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element to convert.","pos":[41190,41213]},{"pos":[41223,41230],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a character that it generates by using a transformation rule that depends on the stored <ph id=\"ph1\">`locale`</ph> object.","pos":[41234,41366],"source":"The member function returns a character that it generates by using a transformation rule that depends on the stored `locale` object."},{"content":"For two <ph id=\"ph1\">`char_type`</ph> objects <ph id=\"ph2\">`ch1`</ph> and <ph id=\"ph3\">`ch2`</ph>, <ph id=\"ph4\">`translate_nocase(ch1) == translate_nocase(ch2)`</ph> only if <ph id=\"ph5\">`ch1`</ph> and <ph id=\"ph6\">`ch2`</ph> should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a case-insensitive match.","pos":[41367,41652],"source":" For two `char_type` objects `ch1` and `ch2`, `translate_nocase(ch1) == translate_nocase(ch2)` only if `ch1` and `ch2` should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a case-insensitive match."},{"pos":[41662,41669],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[43762,43817],"content":"<bpt id=\"p1\">&lt;a name=\"regex_traits__value\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_traits::value","linkify":"<a name=\"regex_traits__value\"></a>  regex_traits::value","source":"<a name=\"regex_traits__value\"></a>  regex_traits::value"},{"content":"Converts an element to a digit value.","pos":[43821,43858]},{"pos":[43920,43930],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element to convert.","pos":[43942,43965]},{"content":"The arithmetic base to use.","pos":[43983,44010]},{"pos":[44020,44027],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns the value represented by the character <ph id=\"ph1\">`ch`</ph> in the base <ph id=\"ph2\">`radix`</ph>, or -1 if <ph id=\"ph3\">`ch`</ph> is not a valid digit in the base <ph id=\"ph4\">`radix`</ph>.","pos":[44031,44179],"source":"The member function returns the value represented by the character `ch` in the base `radix`, or -1 if `ch` is not a valid digit in the base `radix`."},{"content":"The function will only be called with a <ph id=\"ph1\">`radix`</ph> argument of 8, 10, or 16.","pos":[44180,44253],"source":" The function will only be called with a `radix` argument of 8, 10, or 16."},{"pos":[44263,44270],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[46351,46359],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept><ph id=\"ph2\"> </ph>","pos":[46363,46404],"source":"[\\<regex>](../standard-library/regex.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_traits<ept id=\"p1\">](../standard-library/regex-traits-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[46407,46466],"source":" [regex_traits](../standard-library/regex-traits-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_traits<ph id=\"ph1\">\\&lt;</ph>char&gt; Class<ept id=\"p1\">](../standard-library/regex-traits-char-class.md)</ept><ph id=\"ph2\"> </ph>","pos":[46469,46546],"source":" [regex_traits\\<char> Class](../standard-library/regex-traits-char-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_traits&lt;wchar_t&gt; Class<ept id=\"p1\">](../standard-library/regex-traits-wchar-t-class.md)</ept>","pos":[46549,46630],"source":" [regex_traits<wchar_t> Class](../standard-library/regex-traits-wchar-t-class.md)"}],"content":"---\ntitle: \"regex_traits Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"regex_traits\"\n  - \"std::tr1::regex_traits\"\n  - \"std.tr1.regex_traits\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regex_traits class [TR1]\"\nms.assetid: bc5a5eed-32fc-4eb7-913d-71c42e729e81\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# regex_traits Class\nDescribes characteristics of elements for matching.  \n  \n## Syntax  \n```  \nstruct regex_traits {  \n   regex_traits();\n   static size_type length(const char_type *str);\n   char_type translate(char_type ch) const;\n   char_type translate_nocase(char_type ch) const;\n   template <class FwdIt>  \n   string_type transform(FwdIt first, FwdIt last) const;\n   template <class FwdIt>  \n   string_type transform_primary(FwdIt first, FwdIt last) const;\n   template <class FwdIt>  \n   char_class_type lookup_classname(FwdIt first, FwdIt last) const;\n   template <class FwdIt>  \n   string_type lookup_collatename(FwdIt first, FwdIt last) const;\n   bool isctype(char_type ch, char_class_type cls) const;\n   int value(Elem ch, int base) const;\n   locale_type imbue(locale_type loc);\n   locale_type getloc() const;\n   typedef Elem char_type;  \n   typedef T6 size_type;  \n   typedef basic_string<Elem>  \n   string_type;  \n   typedef T7 locale_type;  \n   typedef T8 char_class_type;  \n   };  \n ``` \n#### Parameters  \n `Elem`  \n The element type to describe.  \n  \n## Remarks  \n The template class describes various regular expression traits for type `Elem`. The template class [basic_regex Class](../standard-library/basic-regex-class.md) uses this information to manipulate elements of type `Elem`.  \n  \n Each `regex_traits` object holds an object of type `regex_traits::locale` which is used by some of its member functions. The default locale is a copy of `regex_traits::locale()`. The member function `imbue` replaces the locale object, and the member function `getloc` returns a copy of the locale object.  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"regex_traits__char_class_type\"></a>  regex_traits::char_class_type  \n The type of character class designators.  \n  \n```  \ntypedef T8 char_class_type;  \n```  \n  \n### Remarks  \n The type is a synonym for an unspecified type that designates character classes. Values of this type can be combined using the `|` operator to designate character classes that are the union of the classes designated by the operands.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_char_class_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__char_type\"></a>  regex_traits::char_type  \n The type of an element.  \n  \n```  \ntypedef Elem char_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the template argument `Elem`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_char_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__getloc\"></a>  regex_traits::getloc  \n Returns the stored locale object.  \n  \n```  \nlocale_type getloc() const;\n```  \n  \n### Remarks  \n The member function returns the stored `locale` object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_getloc.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__imbue\"></a>  regex_traits::imbue  \n Alters the stored locale object.  \n  \n```  \nlocale_type imbue(locale_type loc);\n```  \n  \n### Parameters  \n `loc`  \n The locale object to store.  \n  \n### Remarks  \n The member function copies `loc` to the stored `locale` object and returns a copy of the previous value of the stored `locale` object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_imbue.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__isctype\"></a>  regex_traits::isctype  \n Tests for class membership.  \n  \n```  \nbool isctype(char_type ch, char_class_type cls) const;\n```  \n  \n### Parameters  \n `ch`  \n The element to test.  \n  \n `cls`  \n The classes to test for.  \n  \n### Remarks  \n The member function returns true only if the character `ch` is in the character class designated by `cls`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_isctype.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__length\"></a>  regex_traits::length  \n Returns the length of a nul-terminated sequence.  \n  \n```  \nstatic size_type length(const char_type *str);\n```  \n  \n### Parameters  \n `str`  \n The nul-terminated sequence.  \n  \n### Remarks  \n The static member function returns `std::char_traits<char_type>::length(str)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_length.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__locale_type\"></a>  regex_traits::locale_type  \n The type of the stored locale object.  \n  \n```  \ntypedef T7 locale_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for a type that encapsulates locales. In the specializations `regex_traits<char>` and `regex_traits<wchar_t>` it is a synonym for `std::locale`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_locale_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__lookup_classname\"></a>  regex_traits::lookup_classname  \n Maps a sequence to a character class.  \n  \n```  \ntemplate <class FwdIt>  \nchar_class_type lookup_classname(FwdIt first, FwdIt last) const;\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to look up.  \n  \n `last`  \n End of sequence to look up.  \n  \n### Remarks  \n The member function returns a value that designates the character class named by the character sequence pointed to by its arguments. The value does not depend on the case of the characters in the sequence.  \n  \n The specialization `regex_traits<char>` recognizes the names `\"d\"`, `\"s\"`, `\"w\"`, `\"alnum\"`, `\"alpha\"`, `\"blank\"`, `\"cntrl\"`, `\"digit\"`, `\"graph\"`, `\"lower\"`, `\"print\"`, `\"punct\"`, `\"space\"`, `\"upper\"`, and `\"xdigit\"`, all without regard to case.  \n  \n The specialization `regex_traits<wchar_t>` recognizes the names `L\"d\"`, `L\"s\"`, `L\"w\"`, `L\"alnum\"`, `L\"alpha\"`, `L\"blank\"`, `L\"cntrl\"`, `L\"digit\"`, `L\"graph\"`, `L\"lower\"`, `L\"print\"`, `L\"punct\"`, `L\"space\"`, `L\"upper\"`, and `L\"xdigit\"`, all without regard to case.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_lookup_classname.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__lookup_collatename\"></a>  regex_traits::lookup_collatename  \n Maps a sequence to a collating element.  \n  \n```  \ntemplate <class FwdIt>  \nstring_type lookup_collatename(FwdIt first, FwdIt last) const;\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to look up.  \n  \n `last`  \n End of sequence to look up.  \n  \n### Remarks  \n The member function returns a string object containing the collating element corresponding to the sequence `[first, last)`, or an empty string if the sequence is not a valid collating element.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_lookup_collatename.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__regex_traits\"></a>  regex_traits::regex_traits  \n Constructs the object.  \n  \n```  \nregex_traits();\n```  \n  \n### Remarks  \n The constructor constructs an object whose stored `locale` object is initialized to the default locale.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_construct.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__size_type\"></a>  regex_traits::size_type  \n The type of a sequence length.  \n  \n```  \ntypedef T6 size_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for an unsigned integral type. In the specializations `regex_traits<char>` and `regex_traits<wchar_t>` it is a synonym for `std::size_t`.  \n  \n The typedef is a synonym for `std::size_t`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_size_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__string_type\"></a>  regex_traits::string_type  \n The type of a string of elements.  \n  \n```  \ntypedef basic_string<Elem> string_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for `basic_string<Elem>`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_string_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__transform\"></a>  regex_traits::transform  \n Converts to equivalent ordered sequence.  \n  \n```  \ntemplate <class FwdIt>  \nstring_type transform(FwdIt first, FwdIt last) const;\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to transform.  \n  \n `last`  \n End of sequence to transform.  \n  \n### Remarks  \n The member function returns a string that it generates by using a transformation rule that depends on the stored `locale` object. For two character sequences designated by the iterator ranges `[first1, last1)` and `[first2, last2)`, `transform(first1, last1) < transform(first2, last2)` if the character sequence designated by the iterator range `[first1, last1)` sorts before the character sequence designated by the iterator range `[first2, last2)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_transform.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__transform_primary\"></a>  regex_traits::transform_primary  \n Converts to equivalent caseless ordered sequence.  \n  \n```  \ntemplate <class FwdIt>  \nstring_type transform_primary(FwdIt first, FwdIt last) const;\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to transform.  \n  \n `last`  \n End of sequence to transform.  \n  \n### Remarks  \n The member function returns a string that it generates by using a transformation rule that depends on the stored `locale` object. For two character sequences designated by the iterator ranges `[first1, last1)` and `[first2, last2)`, `transform_primary(first1, last1) < transform_primary(first2, last2)` if the character sequence designated by the iterator range `[first1, last1)` sorts before the character sequence designated by the iterator range `[first2, last2)` without regard for case or accents.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_transform_primary.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__translate\"></a>  regex_traits::translate  \n Converts to equivalent matching element.  \n  \n```  \nchar_type translate(char_type ch) const;\n```  \n  \n### Parameters  \n `ch`  \n The element to convert.  \n  \n### Remarks  \n The member function returns a character that it generates by using a transformation rule that depends on the stored `locale` object. For two `char_type` objects `ch1` and `ch2`, `translate(ch1) == translate(ch2)` only if `ch1` and `ch2` should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a locale-sensitive match.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_translate.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__translate_nocase\"></a>  regex_traits::translate_nocase  \n Converts to equivalent caseless matching element.  \n  \n```  \nchar_type translate_nocase(char_type ch) const;\n```  \n  \n### Parameters  \n `ch`  \n The element to convert.  \n  \n### Remarks  \n The member function returns a character that it generates by using a transformation rule that depends on the stored `locale` object. For two `char_type` objects `ch1` and `ch2`, `translate_nocase(ch1) == translate_nocase(ch2)` only if `ch1` and `ch2` should match when one occurs in the regular expression definition and the other occurs at a corresponding position in the target sequence for a case-insensitive match.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_translate_nocase.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n##  <a name=\"regex_traits__value\"></a>  regex_traits::value  \n Converts an element to a digit value.  \n  \n```  \nint value(Elem ch, int radix) const;\n```  \n  \n### Parameters  \n `ch`  \n The element to convert.  \n  \n `radix`  \n The arithmetic base to use.  \n  \n### Remarks  \n The member function returns the value represented by the character `ch` in the base `radix`, or -1 if `ch` is not a valid digit in the base `radix`. The function will only be called with a `radix` argument of 8, 10, or 16.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_traits_value.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_traits<char> Mytr;   \nint main()   \n    {   \n    Mytr tr;   \n  \n    Mytr::char_type ch = tr.translate('a');   \n    std::cout << \"translate('a') == 'a' == \" << std::boolalpha   \n        << (ch == 'a') << std::endl;   \n  \n    std::cout << \"nocase 'a' == 'A' == \" << std::boolalpha   \n        << (tr.translate_nocase('a') == tr.translate_nocase('A'))   \n        << std::endl;   \n  \n    const char *lbegin = \"abc\";   \n    const char *lend = lbegin + strlen(lbegin);   \n    Mytr::size_type size = tr.length(lbegin);   \n    std::cout << \"length(\\\"abc\\\") == \" << size <<std::endl;   \n  \n    Mytr::string_type str = tr.transform(lbegin, lend);   \n    std::cout << \"transform(\\\"abc\\\") < \\\"abc\\\" == \" << std::boolalpha   \n        << (str < \"abc\") << std::endl;   \n  \n    const char *ubegin = \"ABC\";   \n    const char *uend = ubegin + strlen(ubegin);   \n    std::cout << \"primary \\\"ABC\\\" < \\\"abc\\\" == \" << std::boolalpha   \n        << (tr.transform_primary(ubegin, uend) <   \n            tr.transform_primary(lbegin, lend))   \n        << std::endl;   \n  \n    const char *dig = \"digit\";   \n    Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);   \n    std::cout << \"class digit == d == \" << std::boolalpha   \n        << (cl == tr.lookup_classname(dig, dig + 1))   \n        << std::endl;   \n  \n    std::cout << \"'3' is digit == \" <<std::boolalpha   \n        << tr.isctype('3', tr.lookup_classname(dig, dig + 5))   \n        << std::endl;   \n  \n    std::cout << \"hex C == \" << tr.value('C', 16) << std::endl;   \n  \n// other members   \n    str = tr.lookup_collatename(dig, dig + 5);   \n  \n    Mytr::locale_type loc = tr.getloc();   \n    tr.imbue(loc);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ntranslate('a') == 'a' == true  \nnocase 'a' == 'A' == true  \nlength(\"abc\") == 3  \ntransform(\"abc\") < \"abc\" == false  \nprimary \"ABC\" < \"abc\" == false  \nclass digit == d == true  \n'3' is digit == true  \nhex C == 12  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)   \n [regex_traits](../standard-library/regex-traits-class.md)   \n [regex_traits\\<char> Class](../standard-library/regex-traits-char-class.md)   \n [regex_traits<wchar_t> Class](../standard-library/regex-traits-wchar-t-class.md)\n\n"}