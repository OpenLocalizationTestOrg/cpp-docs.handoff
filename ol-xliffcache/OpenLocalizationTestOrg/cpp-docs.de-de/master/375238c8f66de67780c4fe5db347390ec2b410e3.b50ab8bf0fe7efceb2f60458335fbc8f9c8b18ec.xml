{"nodes":[{"pos":[12,34],"content":"_pipe | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_pipe | Microsoft Docs","pos":[0,22]}]},{"pos":[988,993],"content":"_pipe","linkify":"_pipe","nodes":[{"content":"_pipe","pos":[0,5]}]},{"content":"Creates a pipe for reading and writing.","pos":[994,1033]},{"pos":[1041,1301],"content":"[!IMPORTANT]\n This API cannot be used in applications that execute in the [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","leadings":["","> "],"nodes":[{"content":" This API cannot be used in applications that execute in the [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","pos":[13,258],"nodes":[{"content":"This API cannot be used in applications that execute in the <ph id=\"ph1\">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph>.","pos":[1,117],"source":" This API cannot be used in applications that execute in the [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CRT functions not supported with /ZW<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)</ept>.","pos":[118,245],"source":" For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)."}]}]},{"pos":[1310,1316],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1420,1430],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<ph id=\"ph1\">`pfds`</ph>[2]","pos":[1434,1443],"source":"`pfds`[2]"},{"content":"Array to hold read and write file descriptors.","pos":[1447,1493]},{"content":"Amount of memory to reserve.","pos":[1511,1539]},{"content":"File mode.","pos":[1560,1570]},{"pos":[1579,1591],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns 0 if successful.","pos":[1595,1619]},{"content":"Returns –1 to indicate an error.","pos":[1620,1652]},{"content":"On error, <ph id=\"ph1\">`errno`</ph> is set to one of these values:","pos":[1653,1701],"source":" On error, `errno` is set to one of these values:"},{"pos":[1711,1781],"content":"<ph id=\"ph1\">`EMFILE`</ph>, which indicates that no more file descriptors are available.","source":"`EMFILE`, which indicates that no more file descriptors are available."},{"pos":[1791,1846],"content":"<ph id=\"ph1\">`ENFILE`</ph>, which indicates a system-file-table overflow.","source":"`ENFILE`, which indicates a system-file-table overflow."},{"pos":[1856,1983],"content":"<ph id=\"ph1\">`EINVAL`</ph>, which indicates that either the array <ph id=\"ph2\">`pfds`</ph> is a null pointer or that an invalid value for <ph id=\"ph3\">`textmode`</ph> was passed in.","source":"`EINVAL`, which indicates that either the array `pfds` is a null pointer or that an invalid value for `textmode` was passed in."},{"pos":[1990,2167],"content":"For more information about these and other return codes, see <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","source":"For more information about these and other return codes, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"pos":[2176,2183],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_pipe`</ph> function creates a <bpt id=\"p1\">*</bpt>pipe<ept id=\"p1\">*</ept>, which is an artificial I/O channel that a program uses to pass information to other programs.","pos":[2187,2319],"source":"The `_pipe` function creates a *pipe*, which is an artificial I/O channel that a program uses to pass information to other programs."},{"content":"A pipe resembles a file because it has a file pointer, a file descriptor, or both, and it can be read from or written to by using the Standard Library input and output functions.","pos":[2320,2498]},{"content":"However, a pipe does not represent a specific file or device.","pos":[2499,2560]},{"content":"Instead, it represents temporary storage in memory that is independent of the program's own memory and is controlled entirely by the operating system.","pos":[2561,2711]},{"content":"<ph id=\"ph1\">`_pipe`</ph> resembles <ph id=\"ph2\">`_open`</ph> but opens the pipe for reading and writing and returns two file descriptors instead of one.","pos":[2718,2835],"source":"`_pipe` resembles `_open` but opens the pipe for reading and writing and returns two file descriptors instead of one."},{"content":"The program can use both sides of the pipe or close the one that it doesn't need.","pos":[2836,2917]},{"content":"For example, the command processor in Windows creates a pipe when it executes a command such as <ph id=\"ph1\">`PROGRAM1 | PROGRAM2`</ph>.","pos":[2918,3036],"source":" For example, the command processor in Windows creates a pipe when it executes a command such as `PROGRAM1 | PROGRAM2`."},{"content":"The standard output descriptor of <ph id=\"ph1\">`PROGRAM1`</ph> is attached to the pipe's write descriptor.","pos":[3043,3131],"source":"The standard output descriptor of `PROGRAM1` is attached to the pipe's write descriptor."},{"content":"The standard input descriptor of <ph id=\"ph1\">`PROGRAM2`</ph> is attached to the pipe's read descriptor.","pos":[3132,3218],"source":" The standard input descriptor of `PROGRAM2` is attached to the pipe's read descriptor."},{"content":"This eliminates the need to create temporary files to pass information to other programs.","pos":[3219,3308]},{"content":"The <ph id=\"ph1\">`_pipe`</ph> function returns two file descriptors to the pipe in the <ph id=\"ph2\">`pfds`</ph> argument.","pos":[3315,3400],"source":"The `_pipe` function returns two file descriptors to the pipe in the `pfds` argument."},{"content":"The element <ph id=\"ph1\">`pfds`</ph>[0] contains the read descriptor, and the element <ph id=\"ph2\">`pfds`</ph>[1] contains the write descriptor.","pos":[3401,3509],"source":" The element `pfds`[0] contains the read descriptor, and the element `pfds`[1] contains the write descriptor."},{"content":"Pipe file descriptors are used in the same way as other file descriptors.","pos":[3510,3583]},{"content":"(The low-level input and output functions <ph id=\"ph1\">`_read`</ph> and <ph id=\"ph2\">`_write`</ph> can read from and write to a pipe.) To detect the end-of-pipe condition, check for a <ph id=\"ph3\">`_read`</ph> request that returns 0 as the number of bytes read.","pos":[3584,3791],"source":" (The low-level input and output functions `_read` and `_write` can read from and write to a pipe.) To detect the end-of-pipe condition, check for a `_read` request that returns 0 as the number of bytes read."},{"content":"The <ph id=\"ph1\">`psize`</ph> argument specifies the amount of memory, in bytes, to reserve for the pipe.","pos":[3798,3885],"source":"The `psize` argument specifies the amount of memory, in bytes, to reserve for the pipe."},{"content":"The <ph id=\"ph1\">`textmode`</ph> argument specifies the translation mode for the pipe.","pos":[3886,3954],"source":" The `textmode` argument specifies the translation mode for the pipe."},{"content":"The manifest constant <ph id=\"ph1\">`_O_TEXT`</ph> specifies a text translation, and the constant <ph id=\"ph2\">`_O_BINARY`</ph> specifies binary translation.","pos":[3955,4075],"source":" The manifest constant `_O_TEXT` specifies a text translation, and the constant `_O_BINARY` specifies binary translation."},{"content":"(See <bpt id=\"p1\">[</bpt>fopen, _wfopen<ept id=\"p1\">](../../c-runtime-library/reference/fopen-wfopen.md)</ept> for a description of text and binary modes.) If the <ph id=\"ph1\">`textmode`</ph> argument is 0, <ph id=\"ph2\">`_pipe`</ph> uses the default translation mode that's specified by the default-mode variable <bpt id=\"p2\">[</bpt>_fmode<ept id=\"p2\">](../../c-runtime-library/fmode.md)</ept>.","pos":[4076,4358],"source":" (See [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md) for a description of text and binary modes.) If the `textmode` argument is 0, `_pipe` uses the default translation mode that's specified by the default-mode variable [_fmode](../../c-runtime-library/fmode.md)."},{"content":"In multithreaded programs, no locking is performed.","pos":[4365,4416]},{"content":"The file descriptors that are returned are newly opened and should not be referenced by any thread until after the <ph id=\"ph1\">`_pipe`</ph> call is complete.","pos":[4417,4557],"source":" The file descriptors that are returned are newly opened and should not be referenced by any thread until after the `_pipe` call is complete."},{"content":"To use the <ph id=\"ph1\">`_pipe`</ph> function to communicate between a parent process and a child process, each process must have only one descriptor open on the pipe.","pos":[4564,4713],"source":"To use the `_pipe` function to communicate between a parent process and a child process, each process must have only one descriptor open on the pipe."},{"content":"The descriptors must be opposites: if the parent has a read descriptor open, then the child must have a write descriptor open.","pos":[4714,4840]},{"content":"The easiest way to do this is to <ph id=\"ph1\">`OR`</ph> (<ph id=\"ph2\">`|`</ph>) the <ph id=\"ph3\">`_O_NOINHERIT`</ph> flag with <ph id=\"ph4\">`textmode`</ph>.","pos":[4841,4925],"source":" The easiest way to do this is to `OR` (`|`) the `_O_NOINHERIT` flag with `textmode`."},{"content":"Then, use <ph id=\"ph1\">`_dup`</ph> or <ph id=\"ph2\">`_dup2`</ph> to create an inheritable copy of the pipe descriptor that you want to pass to the child.","pos":[4926,5042],"source":" Then, use `_dup` or `_dup2` to create an inheritable copy of the pipe descriptor that you want to pass to the child."},{"content":"Close the original descriptor, and then spawn the child process.","pos":[5043,5107]},{"content":"On returning from the spawn call, close the duplicate descriptor in the parent process.","pos":[5108,5195]},{"content":"For more information, see example 2 later in this article.","pos":[5196,5254]},{"content":"In the Windows operating system, a pipe is destroyed when all of its descriptors have been closed.","pos":[5261,5359]},{"content":"(If all read descriptors on the pipe have been closed, then writing to the pipe causes an error.) All read and write operations on the pipe wait until there is enough data or enough buffer space to complete the I/O request.","pos":[5360,5583]},{"pos":[5592,5604],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[5611,5618]},{"content":"Required header","pos":[5619,5634]},{"content":"Optional header","pos":[5635,5650]},{"content":"<ph id=\"ph1\">\\&lt;</ph>io.h&gt;","pos":[5725,5732],"source":"\\<io.h>"},{"content":"<ph id=\"ph1\">\\&lt;</ph>fcntl.h&gt;,1 <ph id=\"ph2\">\\&lt;</ph>errno.h&gt;2","pos":[5733,5757],"source":"\\<fcntl.h>,1 \\<errno.h>2"},{"pos":[5765,5809],"content":"1 For <ph id=\"ph1\">`_O_BINARY`</ph> and <ph id=\"ph2\">`_O_TEXT`</ph> definitions.","source":"1 For `_O_BINARY` and `_O_TEXT` definitions."},{"pos":[5816,5838],"content":"2 <ph id=\"ph1\">`errno`</ph> definitions.","source":"2 `errno` definitions."},{"pos":[5845,5943],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"pos":[5952,5961],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[5965,6057],"content":"All versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md)."},{"pos":[6066,6075],"content":"Example 1","linkify":"Example 1","nodes":[{"content":"Example 1","pos":[0,9]}]},{"pos":[8380,8393],"content":"Sample Output","linkify":"Sample Output","nodes":[{"content":"Sample Output","pos":[0,13]}]},{"pos":[9065,9074],"content":"Example 2","linkify":"Example 2","nodes":[{"content":"Example 2","pos":[0,9]}]},{"content":"This is a basic filter application.","pos":[9078,9113]},{"content":"It spawns the application crt_pipe_beeper after it creates a pipe that directs the spawned application's stdout to the filter.","pos":[9114,9240]},{"content":"The filter removes ASCII 7 (beep) characters.","pos":[9241,9286]},{"content":"The actual filter application:","pos":[9538,9568]},{"pos":[11857,11863],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[12238,12263],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[12267,12282]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[12283,12330],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[12331,12456],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[12465,12473],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Process and Environment Control<ept id=\"p1\">](../../c-runtime-library/process-and-environment-control.md)</ept><ph id=\"ph1\"> </ph>","pos":[12477,12571],"source":"[Process and Environment Control](../../c-runtime-library/process-and-environment-control.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_open, _wopen<ept id=\"p1\">](../../c-runtime-library/reference/open-wopen.md)</ept>","pos":[12574,12639],"source":" [_open, _wopen](../../c-runtime-library/reference/open-wopen.md)"}],"content":"---\ntitle: \"_pipe | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_pipe\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-stdio-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"pipe\"\n  - \"_pipe\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"pipes, creating\"\n  - \"_pipe function\"\n  - \"pipes\"\n  - \"pipe function\"\nms.assetid: 8d3e9800-4041-44b5-9e93-2df0b0354a75\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# _pipe\nCreates a pipe for reading and writing.  \n  \n> [!IMPORTANT]\n>  This API cannot be used in applications that execute in the [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).  \n  \n## Syntax  \n  \n```  \n  \n      int _pipe(  \nint *pfds,  \nunsigned int psize,  \nint textmode   \n);  \n```  \n  \n#### Parameters  \n `pfds`[2]  \n Array to hold read and write file descriptors.  \n  \n `psize`  \n Amount of memory to reserve.  \n  \n `textmode`  \n File mode.  \n  \n## Return Value  \n Returns 0 if successful. Returns –1 to indicate an error. On error, `errno` is set to one of these values:  \n  \n-   `EMFILE`, which indicates that no more file descriptors are available.  \n  \n-   `ENFILE`, which indicates a system-file-table overflow.  \n  \n-   `EINVAL`, which indicates that either the array `pfds` is a null pointer or that an invalid value for `textmode` was passed in.  \n  \n For more information about these and other return codes, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n## Remarks  \n The `_pipe` function creates a *pipe*, which is an artificial I/O channel that a program uses to pass information to other programs. A pipe resembles a file because it has a file pointer, a file descriptor, or both, and it can be read from or written to by using the Standard Library input and output functions. However, a pipe does not represent a specific file or device. Instead, it represents temporary storage in memory that is independent of the program's own memory and is controlled entirely by the operating system.  \n  \n `_pipe` resembles `_open` but opens the pipe for reading and writing and returns two file descriptors instead of one. The program can use both sides of the pipe or close the one that it doesn't need. For example, the command processor in Windows creates a pipe when it executes a command such as `PROGRAM1 | PROGRAM2`.  \n  \n The standard output descriptor of `PROGRAM1` is attached to the pipe's write descriptor. The standard input descriptor of `PROGRAM2` is attached to the pipe's read descriptor. This eliminates the need to create temporary files to pass information to other programs.  \n  \n The `_pipe` function returns two file descriptors to the pipe in the `pfds` argument. The element `pfds`[0] contains the read descriptor, and the element `pfds`[1] contains the write descriptor. Pipe file descriptors are used in the same way as other file descriptors. (The low-level input and output functions `_read` and `_write` can read from and write to a pipe.) To detect the end-of-pipe condition, check for a `_read` request that returns 0 as the number of bytes read.  \n  \n The `psize` argument specifies the amount of memory, in bytes, to reserve for the pipe. The `textmode` argument specifies the translation mode for the pipe. The manifest constant `_O_TEXT` specifies a text translation, and the constant `_O_BINARY` specifies binary translation. (See [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md) for a description of text and binary modes.) If the `textmode` argument is 0, `_pipe` uses the default translation mode that's specified by the default-mode variable [_fmode](../../c-runtime-library/fmode.md).  \n  \n In multithreaded programs, no locking is performed. The file descriptors that are returned are newly opened and should not be referenced by any thread until after the `_pipe` call is complete.  \n  \n To use the `_pipe` function to communicate between a parent process and a child process, each process must have only one descriptor open on the pipe. The descriptors must be opposites: if the parent has a read descriptor open, then the child must have a write descriptor open. The easiest way to do this is to `OR` (`|`) the `_O_NOINHERIT` flag with `textmode`. Then, use `_dup` or `_dup2` to create an inheritable copy of the pipe descriptor that you want to pass to the child. Close the original descriptor, and then spawn the child process. On returning from the spawn call, close the duplicate descriptor in the parent process. For more information, see example 2 later in this article.  \n  \n In the Windows operating system, a pipe is destroyed when all of its descriptors have been closed. (If all read descriptors on the pipe have been closed, then writing to the pipe causes an error.) All read and write operations on the pipe wait until there is enough data or enough buffer space to complete the I/O request.  \n  \n## Requirements  \n  \n|Routine|Required header|Optional header|  \n|-------------|---------------------|---------------------|  \n|`_pipe`|\\<io.h>|\\<fcntl.h>,1 \\<errno.h>2|  \n  \n 1 For `_O_BINARY` and `_O_TEXT` definitions.  \n  \n 2 `errno` definitions.  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Libraries  \n All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md).  \n  \n## Example 1  \n  \n```  \n  \n      // crt_pipe.c  \n/* This program uses the _pipe function to pass streams of  \n * text to spawned processes.  \n */  \n  \n#include <stdlib.h>  \n#include <stdio.h>  \n#include <io.h>  \n#include <fcntl.h>  \n#include <process.h>  \n#include <math.h>  \n  \nenum PIPES { READ, WRITE }; /* Constants 0 and 1 for READ and WRITE */  \n#define NUMPROBLEM 8  \n  \nint main( int argc, char *argv[] )  \n{  \n  \n   int fdpipe[2];  \n   char hstr[20];  \n   int pid, problem, c;  \n   int termstat;  \n  \n   /* If no arguments, this is the spawning process */  \n   if( argc == 1 )  \n   {  \n  \n      setvbuf( stdout, NULL, _IONBF, 0 );  \n  \n      /* Open a set of pipes */  \n      if( _pipe( fdpipe, 256, O_BINARY ) == -1 )  \n          exit( 1 );  \n  \n      /* Convert pipe read descriptor to string and pass as argument   \n       * to spawned program. Program spawns itself (argv[0]).  \n       */  \n      _itoa_s( fdpipe[READ], hstr, sizeof(hstr), 10 );  \n      if( ( pid = _spawnl( P_NOWAIT, argv[0], argv[0],   \n            hstr, NULL ) ) == -1 )  \n          printf( \"Spawn failed\" );  \n  \n      /* Put problem in write pipe. Since spawned program is   \n       * running simultaneously, first solutions may be done   \n       * before last problem is given.  \n       */  \n      for( problem = 1000; problem <= NUMPROBLEM * 1000; problem += 1000)  \n      {  \n  \n         printf( \"Son, what is the square root of %d?\\n\", problem );  \n         _write( fdpipe[WRITE], (char *)&problem, sizeof( int ) );  \n  \n      }  \n  \n      /* Wait until spawned program is done processing. */  \n      _cwait( &termstat, pid, WAIT_CHILD );  \n      if( termstat & 0x0 )  \n         printf( \"Child failed\\n\" );  \n  \n      _close( fdpipe[READ] );  \n      _close( fdpipe[WRITE] );  \n  \n   }  \n  \n   /* If there is an argument, this must be the spawned process. */  \n   else  \n   {  \n  \n      /* Convert passed string descriptor to integer descriptor. */  \n      fdpipe[READ] = atoi( argv[1] );  \n  \n      /* Read problem from pipe and calculate solution. */  \n      for( c = 0; c < NUMPROBLEM; c++ )  \n      {  \n  \n        _read( fdpipe[READ], (char *)&problem, sizeof( int ) );  \n        printf( \"Dad, the square root of %d is %3.2f.\\n\",  \n                 problem, sqrt( ( double )problem ) );  \n  \n      }  \n   }  \n}  \n```  \n  \n## Sample Output  \n  \n```  \nSon, what is the square root of 1000?  \nSon, what is the square root of 2000?  \nSon, what iDad, the square root of 1000 is 31.62.  \nDad, the square root of 2000 is 44.72.  \ns the square root of 3000?  \nDad, the square root of 3000 is 54.77.  \nSon, what is the square root of 4000?  \nDad, the square root of 4000 is 63.25.  \nSon, what is the square root of 5000?  \nDad, the square root of 5000 is 70.71.  \nSon, what is the square root of 6000?  \nSonDad, the square root of 6000 is 77.46.  \n, what is the square root of 7000?  \nDad, the square root of 7000 is 83.67.  \nSon, what is the square root of 8000?  \nDad, the square root of 8000 is 89.44.  \n```  \n  \n## Example 2  \n This is a basic filter application. It spawns the application crt_pipe_beeper after it creates a pipe that directs the spawned application's stdout to the filter. The filter removes ASCII 7 (beep) characters.  \n  \n```  \n// crt_pipe_beeper.c  \n  \n#include <stdio.h>  \n#include <string.h>  \n  \nint main()  \n{  \n   int   i;  \n   for(i=0;i<10;++i)  \n      {  \n         printf(\"This is speaker beep number %d...\\n\\7\", i+1);  \n      }  \n   return 0;  \n}  \n```  \n  \n The actual filter application:  \n  \n```  \n// crt_pipe_BeepFilter.C  \n// arguments: crt_pipe_beeper.exe  \n  \n#include <windows.h>  \n#include <process.h>  \n#include <memory.h>  \n#include <string.h>  \n#include <stdio.h>  \n#include <fcntl.h>  \n#include <io.h>  \n  \n#define   OUT_BUFF_SIZE 512  \n#define   READ_FD 0  \n#define   WRITE_FD 1  \n#define   BEEP_CHAR 7  \n  \nchar szBuffer[OUT_BUFF_SIZE];  \n  \nint Filter(char* szBuff, ULONG nSize, int nChar)  \n{  \n   char* szPos = szBuff + nSize -1;  \n   char* szEnd = szPos;  \n   int nRet = nSize;  \n  \n   while (szPos > szBuff)  \n   {  \n      if (*szPos == nChar)  \n         {  \n            memmove(szPos, szPos+1, szEnd - szPos);  \n            --nRet;  \n         }  \n      --szPos;  \n   }  \n   return nRet;  \n}  \n  \nint main(int argc, char** argv)  \n{  \n   int nExitCode = STILL_ACTIVE;  \n   if (argc >= 2)  \n   {  \n      HANDLE hProcess;  \n      int fdStdOut;  \n      int fdStdOutPipe[2];  \n  \n      // Create the pipe  \n      if(_pipe(fdStdOutPipe, 512, O_NOINHERIT) == -1)  \n         return   1;  \n  \n      // Duplicate stdout file descriptor (next line will close original)  \n      fdStdOut = _dup(_fileno(stdout));  \n  \n      // Duplicate write end of pipe to stdout file descriptor  \n      if(_dup2(fdStdOutPipe[WRITE_FD], _fileno(stdout)) != 0)  \n         return   2;  \n  \n      // Close original write end of pipe  \n      _close(fdStdOutPipe[WRITE_FD]);  \n  \n      // Spawn process  \n      hProcess = (HANDLE)_spawnvp(P_NOWAIT, argv[1],   \n       (const char* const*)&argv[1]);  \n  \n      // Duplicate copy of original stdout back into stdout  \n      if(_dup2(fdStdOut, _fileno(stdout)) != 0)  \n         return   3;  \n  \n      // Close duplicate copy of original stdout  \n      _close(fdStdOut);  \n  \n      if(hProcess)  \n      {  \n         int nOutRead;  \n         while   (nExitCode == STILL_ACTIVE)  \n         {  \n            nOutRead = _read(fdStdOutPipe[READ_FD],   \n             szBuffer, OUT_BUFF_SIZE);  \n            if(nOutRead)  \n            {  \n               nOutRead = Filter(szBuffer, nOutRead, BEEP_CHAR);  \n               fwrite(szBuffer, 1, nOutRead, stdout);  \n            }  \n  \n            if(!GetExitCodeProcess(hProcess,(unsigned long*)&nExitCode))  \n               return 4;  \n         }  \n      }  \n   }  \n   return nExitCode;  \n}  \n```  \n  \n## Output  \n  \n```  \nThis is speaker beep number 1...  \nThis is speaker beep number 2...  \nThis is speaker beep number 3...  \nThis is speaker beep number 4...  \nThis is speaker beep number 5...  \nThis is speaker beep number 6...  \nThis is speaker beep number 7...  \nThis is speaker beep number 8...  \nThis is speaker beep number 9...  \nThis is speaker beep number 10...  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Process and Environment Control](../../c-runtime-library/process-and-environment-control.md)   \n [_open, _wopen](../../c-runtime-library/reference/open-wopen.md)"}