{"nodes":[{"pos":[12,41],"content":"CEvent Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CEvent Class | Microsoft Docs","pos":[0,29]}]},{"pos":[673,685],"content":"CEvent Class","linkify":"CEvent Class","nodes":[{"content":"CEvent Class","pos":[0,12]}]},{"content":"Represents an event, which is a synchronization object that enables one thread to notify another that an event has occurred.","pos":[686,810]},{"pos":[819,825],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[885,892],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[902,921],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[928,932]},{"content":"Description","pos":[933,944]},{"pos":[982,1015],"content":"<bpt id=\"p1\">[</bpt>CEvent::CEvent<ept id=\"p1\">](#cevent__cevent)</ept>","source":"[CEvent::CEvent](#cevent__cevent)"},{"pos":[1016,1045],"content":"Constructs a <ph id=\"ph1\">`CEvent`</ph> object.","source":"Constructs a `CEvent` object."},{"pos":[1056,1070],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1077,1081]},{"content":"Description","pos":[1082,1093]},{"pos":[1131,1172],"content":"<bpt id=\"p1\">[</bpt>CEvent::PulseEvent<ept id=\"p1\">](#cevent__pulseevent)</ept>","source":"[CEvent::PulseEvent](#cevent__pulseevent)"},{"content":"Sets the event to available (signaled), releases waiting threads, and sets the event to unavailable (nonsignaled).","pos":[1173,1287]},{"pos":[1292,1333],"content":"<bpt id=\"p1\">[</bpt>CEvent::ResetEvent<ept id=\"p1\">](#cevent__resetevent)</ept>","source":"[CEvent::ResetEvent](#cevent__resetevent)"},{"content":"Sets the event to unavailable (nonsignaled).","pos":[1334,1378]},{"pos":[1383,1420],"content":"<bpt id=\"p1\">[</bpt>CEvent::SetEvent<ept id=\"p1\">](#cevent__setevent)</ept>","source":"[CEvent::SetEvent](#cevent__setevent)"},{"content":"Sets the event to available (signaled) and releases any waiting threads.","pos":[1421,1493]},{"pos":[1498,1531],"content":"<bpt id=\"p1\">[</bpt>CEvent::Unlock<ept id=\"p1\">](#cevent__unlock)</ept>","source":"[CEvent::Unlock](#cevent__unlock)"},{"content":"Releases the event object.","pos":[1532,1558]},{"pos":[1568,1575],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Events are useful when a thread must know when to perform its task.","pos":[1579,1646]},{"content":"For example, a thread that copies data to a data archive must be notified when new data is available.","pos":[1647,1748]},{"content":"By using a <ph id=\"ph1\">`CEvent`</ph> object to notify the copy thread when new data is available, the thread can perform its task as soon as possible.","pos":[1749,1882],"source":" By using a `CEvent` object to notify the copy thread when new data is available, the thread can perform its task as soon as possible."},{"pos":[1889,1943],"content":"<ph id=\"ph1\">`CEvent`</ph> objects have two types: manual and automatic.","source":"`CEvent` objects have two types: manual and automatic."},{"content":"An automatic <ph id=\"ph1\">`CEvent`</ph> object automatically returns to a non-signaled (unavailable) state after at least one thread is released.","pos":[1950,2077],"source":"An automatic `CEvent` object automatically returns to a non-signaled (unavailable) state after at least one thread is released."},{"content":"By default, a <ph id=\"ph1\">`CEvent`</ph> object is automatic unless you pass <ph id=\"ph2\">`TRUE`</ph> for the <ph id=\"ph3\">`bManualReset`</ph> parameter during construction.","pos":[2078,2197],"source":" By default, a `CEvent` object is automatic unless you pass `TRUE` for the `bManualReset` parameter during construction."},{"content":"A manual <ph id=\"ph1\">`CEvent`</ph> object stays in the state set by <bpt id=\"p1\">[</bpt>SetEvent<ept id=\"p1\">](#cevent__setevent)</ept> or <bpt id=\"p2\">[</bpt>ResetEvent<ept id=\"p2\">](#cevent__resetevent)</ept> until the other function is called.","pos":[2204,2357],"source":"A manual `CEvent` object stays in the state set by [SetEvent](#cevent__setevent) or [ResetEvent](#cevent__resetevent) until the other function is called."},{"content":"To create a manual <ph id=\"ph1\">`CEvent`</ph> object, pass <ph id=\"ph2\">`TRUE`</ph> for the <ph id=\"ph3\">`bManualReset`</ph> parameter during construction.","pos":[2358,2459],"source":" To create a manual `CEvent` object, pass `TRUE` for the `bManualReset` parameter during construction."},{"content":"To use a <ph id=\"ph1\">`CEvent`</ph> object, construct the <ph id=\"ph2\">`CEvent`</ph> object when it is required.","pos":[2466,2542],"source":"To use a `CEvent` object, construct the `CEvent` object when it is required."},{"content":"Specify the name of the event you want to wait on, and also specify that your application should initially own it.","pos":[2543,2657]},{"content":"You can then access the event when the constructor returns.","pos":[2658,2717]},{"content":"Call <bpt id=\"p1\">[</bpt>SetEvent<ept id=\"p1\">](#cevent__setevent)</ept> to signal (make available) the event object and then call <bpt id=\"p2\">[</bpt>Unlock<ept id=\"p2\">](#cevent__unlock)</ept> when you are done accessing the controlled resource.","pos":[2718,2889],"source":" Call [SetEvent](#cevent__setevent) to signal (make available) the event object and then call [Unlock](#cevent__unlock) when you are done accessing the controlled resource."},{"content":"An alternative method for using <ph id=\"ph1\">`CEvent`</ph> objects is to add a variable of type <ph id=\"ph2\">`CEvent`</ph> as a data member to the class you want to control.","pos":[2896,3033],"source":"An alternative method for using `CEvent` objects is to add a variable of type `CEvent` as a data member to the class you want to control."},{"content":"During construction of the controlled object, call the constructor of the <ph id=\"ph1\">`CEvent`</ph> data member and specify whether the event is initially signaled, and also specifythe type of event object you want, the name of the event (if it will be used across process boundaries), and any security attributes you want.","pos":[3034,3340],"source":" During construction of the controlled object, call the constructor of the `CEvent` data member and specify whether the event is initially signaled, and also specifythe type of event object you want, the name of the event (if it will be used across process boundaries), and any security attributes you want."},{"content":"To access a resource controlled by a <ph id=\"ph1\">`CEvent`</ph> object in this manner, first create a variable of either type <bpt id=\"p1\">[</bpt>CSingleLock<ept id=\"p1\">](../../mfc/reference/csinglelock-class.md)</ept> or type <bpt id=\"p2\">[</bpt>CMultiLock<ept id=\"p2\">](../../mfc/reference/cmultilock-class.md)</ept> in the access method of your resource.","pos":[3347,3611],"source":"To access a resource controlled by a `CEvent` object in this manner, first create a variable of either type [CSingleLock](../../mfc/reference/csinglelock-class.md) or type [CMultiLock](../../mfc/reference/cmultilock-class.md) in the access method of your resource."},{"content":"Then call the <ph id=\"ph1\">`Lock`</ph> method of the lock object (for example, <bpt id=\"p1\">[</bpt>CMultiLock::Lock<ept id=\"p1\">](../../mfc/reference/cmultilock-class.md#cmultilock__lock)</ept>).","pos":[3612,3751],"source":" Then call the `Lock` method of the lock object (for example, [CMultiLock::Lock](../../mfc/reference/cmultilock-class.md#cmultilock__lock))."},{"content":"At this point, your thread will either gain access to the resource, wait for the resource to be released and gain access, or wait for the resource to be released, time out, and fail to gain access to the resource.","pos":[3752,3965]},{"content":"In any case, your resource has been accessed in a thread-safe manner.","pos":[3966,4035]},{"content":"To release the resource, call <ph id=\"ph1\">`SetEvent`</ph> to signal the event object, and then use the <ph id=\"ph2\">`Unlock`</ph> method of the lock object (for example, <bpt id=\"p1\">[</bpt>CMultiLock::Unlock<ept id=\"p1\">](../../mfc/reference/cmultilock-class.md#cmultilock__unlock)</ept>), or let the lock object fall out of scope.","pos":[4036,4295],"source":" To release the resource, call `SetEvent` to signal the event object, and then use the `Unlock` method of the lock object (for example, [CMultiLock::Unlock](../../mfc/reference/cmultilock-class.md#cmultilock__unlock)), or let the lock object fall out of scope."},{"pos":[4302,4492],"content":"For more information about how to use <ph id=\"ph1\">`CEvent`</ph> objects, see <bpt id=\"p1\">[</bpt>Multithreading: How to Use the Synchronization Classes<ept id=\"p1\">](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)</ept>.","source":"For more information about how to use `CEvent` objects, see [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)."},{"pos":[4501,4508],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4512,4591],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFC_Utilities#45<ept id=\"p2\">](../../mfc/codesnippet/cpp/cevent-class_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFC_Utilities#45](../../mfc/codesnippet/cpp/cevent-class_1.cpp)]"},{"pos":[4598,4677],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFC_Utilities#46<ept id=\"p2\">](../../mfc/codesnippet/cpp/cevent-class_2.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFC_Utilities#46](../../mfc/codesnippet/cpp/cevent-class_2.cpp)]"},{"pos":[4686,4707],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[4711,4758],"content":"<bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>","source":"[CObject](../../mfc/reference/cobject-class.md)"},{"pos":[4765,4820],"content":"<bpt id=\"p1\">[</bpt>CSyncObject<ept id=\"p1\">](../../mfc/reference/csyncobject-class.md)</ept>","source":"[CSyncObject](../../mfc/reference/csyncobject-class.md)"},{"pos":[4844,4856],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4860,4879],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxmt.h","source":"**Header:** afxmt.h"},{"pos":[4889,4934],"content":"<bpt id=\"p1\">&lt;a name=\"cevent__cevent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CEvent::CEvent","linkify":"<a name=\"cevent__cevent\"></a>  CEvent::CEvent","source":"<a name=\"cevent__cevent\"></a>  CEvent::CEvent"},{"pos":[4938,4984],"content":"Constructs a named or unnamed <ph id=\"ph1\">`CEvent`</ph> object.","source":"Constructs a named or unnamed `CEvent` object."},{"pos":[5164,5174],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"If <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>, the thread for the <bpt id=\"p2\">**</bpt>CMultilock<ept id=\"p2\">**</ept> or <ph id=\"ph1\">`CSingleLock`</ph> object is enabled.","pos":[5197,5279],"source":" If **TRUE**, the thread for the **CMultilock** or `CSingleLock` object is enabled."},{"content":"Otherwise, all threads wanting to access the resource must wait.","pos":[5280,5344]},{"content":"<bpt id=\"p1\">*</bpt>bManualReset<ept id=\"p1\">*</ept>","pos":[5351,5365],"source":"*bManualReset*"},{"content":"If <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>, specifies that the event object is a manual event, otherwise the event object is an automatic event.","pos":[5369,5482],"source":" If **TRUE**, specifies that the event object is a manual event, otherwise the event object is an automatic event."},{"content":"Name of the <ph id=\"ph1\">`CEvent`</ph> object.","pos":[5503,5531],"source":" Name of the `CEvent` object."},{"content":"Must be supplied if the object will be used across process boundaries.","pos":[5532,5602]},{"content":"If the name matches an existing event, the constructor builds a new <ph id=\"ph1\">`CEvent`</ph> object which references the event of that name.","pos":[5603,5727],"source":" If the name matches an existing event, the constructor builds a new `CEvent` object which references the event of that name."},{"content":"If the name matches an existing synchronization object that is not an event, the construction will fail.","pos":[5728,5832]},{"content":"If <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the name will be null.","pos":[5833,5868],"source":" If **NULL**, the name will be null."},{"content":"Security attributes for the event object.","pos":[5894,5935]},{"content":"For a full description of this structure, see <bpt id=\"p1\">[</bpt>SECURITY_ATTRIBUTES<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa379560)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[5936,6123],"source":" For a full description of this structure, see [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[6133,6140],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6144,6485],"content":"To access or release a <ph id=\"ph1\">`CEvent`</ph> object, create a <bpt id=\"p1\">[</bpt>CMultiLock<ept id=\"p1\">](../../mfc/reference/cmultilock-class.md)</ept> or <bpt id=\"p2\">[</bpt>CSingleLock<ept id=\"p2\">](../../mfc/reference/csinglelock-class.md)</ept> object and call its <bpt id=\"p3\">[</bpt>Lock<ept id=\"p3\">](../../mfc/reference/csinglelock-class.md#csinglelock__lock)</ept> and <bpt id=\"p4\">[</bpt>Unlock<ept id=\"p4\">](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)</ept> member functions.","source":"To access or release a `CEvent` object, create a [CMultiLock](../../mfc/reference/cmultilock-class.md) or [CSingleLock](../../mfc/reference/csinglelock-class.md) object and call its [Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock) and [Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock) member functions."},{"content":"To change the state of a <ph id=\"ph1\">`CEvent`</ph> object to signaled (threads do not have to wait), call <bpt id=\"p1\">[</bpt>SetEvent<ept id=\"p1\">](#cevent__setevent)</ept> or <bpt id=\"p2\">[</bpt>PulseEvent<ept id=\"p2\">](#cevent__pulseevent)</ept>.","pos":[6492,6648],"source":"To change the state of a `CEvent` object to signaled (threads do not have to wait), call [SetEvent](#cevent__setevent) or [PulseEvent](#cevent__pulseevent)."},{"content":"To set the state of a <ph id=\"ph1\">`CEvent`</ph> object to nonsignaled (threads must wait), call <bpt id=\"p1\">[</bpt>ResetEvent<ept id=\"p1\">](#cevent__resetevent)</ept>.","pos":[6649,6762],"source":" To set the state of a `CEvent` object to nonsignaled (threads must wait), call [ResetEvent](#cevent__resetevent)."},{"pos":[6770,7225],"content":"[!IMPORTANT]\n After creating the `CEvent` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex didn't already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","leadings":["","> "],"nodes":[{"content":" After creating the `CEvent` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex didn't already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","pos":[13,453],"nodes":[{"content":"After creating the <ph id=\"ph1\">`CEvent`</ph> object, use <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept> to ensure that the mutex didn't already exist.","pos":[1,162],"source":" After creating the `CEvent` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex didn't already exist."},{"content":"If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously.","pos":[163,295]},{"content":"In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","pos":[296,440]}]}]},{"pos":[7235,7288],"content":"<bpt id=\"p1\">&lt;a name=\"cevent__pulseevent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CEvent::PulseEvent","linkify":"<a name=\"cevent__pulseevent\"></a>  CEvent::PulseEvent","source":"<a name=\"cevent__pulseevent\"></a>  CEvent::PulseEvent"},{"content":"Sets the state of the event to signaled (available), releases any waiting threads, and resets it to nonsignaled (unavailable) automatically.","pos":[7292,7432]},{"pos":[7476,7488],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function was successful; otherwise 0.","pos":[7492,7544]},{"pos":[7554,7561],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If the event is manual, all waiting threads are released, the event is set to nonsignaled, and <ph id=\"ph1\">`PulseEvent`</ph> returns.","pos":[7565,7681],"source":"If the event is manual, all waiting threads are released, the event is set to nonsignaled, and `PulseEvent` returns."},{"content":"If the event is automatic, a single thread is released, the event is set to nonsignaled, and <ph id=\"ph1\">`PulseEvent`</ph> returns.","pos":[7682,7796],"source":" If the event is automatic, a single thread is released, the event is set to nonsignaled, and `PulseEvent` returns."},{"pos":[7803,7941],"content":"If no threads are waiting, or no threads can be released immediately, <ph id=\"ph1\">`PulseEvent`</ph> sets the state of the event to nonsignaled and returns.","source":"If no threads are waiting, or no threads can be released immediately, `PulseEvent` sets the state of the event to nonsignaled and returns."},{"content":"<ph id=\"ph1\">`PulseEvent`</ph> uses the underlying Win32 <ph id=\"ph2\">`PulseEvent`</ph> function, which can be momentarily removed from the wait state by a kernel-mode asynchronous procedure call.","pos":[7948,8108],"source":"`PulseEvent` uses the underlying Win32 `PulseEvent` function, which can be momentarily removed from the wait state by a kernel-mode asynchronous procedure call."},{"content":"Therefore, <ph id=\"ph1\">`PulseEvent`</ph> is unreliable and should not be used by new applications.","pos":[8109,8190],"source":" Therefore, `PulseEvent` is unreliable and should not be used by new applications."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>PulseEvent function<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms684914)</ept>.","pos":[8191,8303],"source":" For more information, see the [PulseEvent function](http://msdn.microsoft.com/library/windows/desktop/ms684914)."},{"pos":[8313,8366],"content":"<bpt id=\"p1\">&lt;a name=\"cevent__resetevent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CEvent::ResetEvent","linkify":"<a name=\"cevent__resetevent\"></a>  CEvent::ResetEvent","source":"<a name=\"cevent__resetevent\"></a>  CEvent::ResetEvent"},{"pos":[8370,8499],"content":"Sets the state of the event to nonsignaled until explicitly set to signaled by the <bpt id=\"p1\">[</bpt>SetEvent<ept id=\"p1\">](#cevent__setevent)</ept> member function.","source":"Sets the state of the event to nonsignaled until explicitly set to signaled by the [SetEvent](#cevent__setevent) member function."},{"pos":[8543,8555],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function was successful; otherwise 0.","pos":[8559,8611]},{"pos":[8621,8628],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This causes all threads wishing to access this event to wait.","pos":[8632,8693]},{"content":"This member function is not used by automatic events.","pos":[8700,8753]},{"pos":[8763,8812],"content":"<bpt id=\"p1\">&lt;a name=\"cevent__setevent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CEvent::SetEvent","linkify":"<a name=\"cevent__setevent\"></a>  CEvent::SetEvent","source":"<a name=\"cevent__setevent\"></a>  CEvent::SetEvent"},{"content":"Sets the state of the event to signaled, releasing any waiting threads.","pos":[8816,8887]},{"pos":[8929,8941],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the function was successful, otherwise 0.","pos":[8945,8997]},{"pos":[9007,9014],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If the event is manual, the event will remain signaled until <bpt id=\"p1\">[</bpt>ResetEvent<ept id=\"p1\">](#cevent__resetevent)</ept> is called.","pos":[9018,9123],"source":"If the event is manual, the event will remain signaled until [ResetEvent](#cevent__resetevent) is called."},{"content":"More than one thread can be released in this case.","pos":[9124,9174]},{"content":"If the event is automatic, the event will remain signaled until a single thread is released.","pos":[9175,9267]},{"content":"The system will then set the state of the event to nonsignaled.","pos":[9268,9331]},{"content":"If no threads are waiting, the state remains signaled until one thread is released.","pos":[9332,9415]},{"pos":[9425,9470],"content":"<bpt id=\"p1\">&lt;a name=\"cevent__unlock\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CEvent::Unlock","linkify":"<a name=\"cevent__unlock\"></a>  CEvent::Unlock","source":"<a name=\"cevent__unlock\"></a>  CEvent::Unlock"},{"content":"Releases the event object.","pos":[9474,9500]},{"pos":[9540,9552],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the thread owned the event object and the event is an automatic event; otherwise 0.","pos":[9556,9650]},{"pos":[9660,9667],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This member function is called by threads that currently own an automatic event to release it after they are done, if their lock object is to be reused.","pos":[9671,9823]},{"content":"If the lock object is not to be reused, this function will be called by the lock object's destructor.","pos":[9824,9925]},{"pos":[9934,9942],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>CSyncObject Class<ept id=\"p1\">](../../mfc/reference/csyncobject-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[9946,10008],"source":"[CSyncObject Class](../../mfc/reference/csyncobject-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept>","pos":[10011,10059],"source":" [Hierarchy Chart](../../mfc/hierarchy-chart.md)"}],"content":"---\ntitle: \"CEvent Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CEvent\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"synchronization objects, event\"\n  - \"synchronization classes, CEvent class\"\n  - \"CEvent class\"\nms.assetid: df676042-ce27-4702-800a-e73ff4f44395\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CEvent Class\nRepresents an event, which is a synchronization object that enables one thread to notify another that an event has occurred.  \n  \n## Syntax  \n  \n```  \nclass CEvent : public CSyncObject  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CEvent::CEvent](#cevent__cevent)|Constructs a `CEvent` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CEvent::PulseEvent](#cevent__pulseevent)|Sets the event to available (signaled), releases waiting threads, and sets the event to unavailable (nonsignaled).|  \n|[CEvent::ResetEvent](#cevent__resetevent)|Sets the event to unavailable (nonsignaled).|  \n|[CEvent::SetEvent](#cevent__setevent)|Sets the event to available (signaled) and releases any waiting threads.|  \n|[CEvent::Unlock](#cevent__unlock)|Releases the event object.|  \n  \n## Remarks  \n Events are useful when a thread must know when to perform its task. For example, a thread that copies data to a data archive must be notified when new data is available. By using a `CEvent` object to notify the copy thread when new data is available, the thread can perform its task as soon as possible.  \n  \n `CEvent` objects have two types: manual and automatic.  \n  \n An automatic `CEvent` object automatically returns to a non-signaled (unavailable) state after at least one thread is released. By default, a `CEvent` object is automatic unless you pass `TRUE` for the `bManualReset` parameter during construction.  \n  \n A manual `CEvent` object stays in the state set by [SetEvent](#cevent__setevent) or [ResetEvent](#cevent__resetevent) until the other function is called. To create a manual `CEvent` object, pass `TRUE` for the `bManualReset` parameter during construction.  \n  \n To use a `CEvent` object, construct the `CEvent` object when it is required. Specify the name of the event you want to wait on, and also specify that your application should initially own it. You can then access the event when the constructor returns. Call [SetEvent](#cevent__setevent) to signal (make available) the event object and then call [Unlock](#cevent__unlock) when you are done accessing the controlled resource.  \n  \n An alternative method for using `CEvent` objects is to add a variable of type `CEvent` as a data member to the class you want to control. During construction of the controlled object, call the constructor of the `CEvent` data member and specify whether the event is initially signaled, and also specifythe type of event object you want, the name of the event (if it will be used across process boundaries), and any security attributes you want.  \n  \n To access a resource controlled by a `CEvent` object in this manner, first create a variable of either type [CSingleLock](../../mfc/reference/csinglelock-class.md) or type [CMultiLock](../../mfc/reference/cmultilock-class.md) in the access method of your resource. Then call the `Lock` method of the lock object (for example, [CMultiLock::Lock](../../mfc/reference/cmultilock-class.md#cmultilock__lock)). At this point, your thread will either gain access to the resource, wait for the resource to be released and gain access, or wait for the resource to be released, time out, and fail to gain access to the resource. In any case, your resource has been accessed in a thread-safe manner. To release the resource, call `SetEvent` to signal the event object, and then use the `Unlock` method of the lock object (for example, [CMultiLock::Unlock](../../mfc/reference/cmultilock-class.md#cmultilock__unlock)), or let the lock object fall out of scope.  \n  \n For more information about how to use `CEvent` objects, see [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).  \n  \n## Example  \n [!code-cpp[NVC_MFC_Utilities#45](../../mfc/codesnippet/cpp/cevent-class_1.cpp)]  \n  \n [!code-cpp[NVC_MFC_Utilities#46](../../mfc/codesnippet/cpp/cevent-class_2.cpp)]  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n [CSyncObject](../../mfc/reference/csyncobject-class.md)  \n  \n `CEvent`  \n  \n## Requirements  \n **Header:** afxmt.h  \n  \n##  <a name=\"cevent__cevent\"></a>  CEvent::CEvent  \n Constructs a named or unnamed `CEvent` object.  \n  \n```  \nCEvent(\n    BOOL bInitiallyOwn = FALSE,  \n    BOOL bManualReset = FALSE,  \n    LPCTSTR lpszName = NULL,  \n    LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);\n```  \n  \n### Parameters  \n `bInitiallyOwn`  \n If **TRUE**, the thread for the **CMultilock** or `CSingleLock` object is enabled. Otherwise, all threads wanting to access the resource must wait.  \n  \n *bManualReset*  \n If **TRUE**, specifies that the event object is a manual event, otherwise the event object is an automatic event.  \n  \n `lpszName`  \n Name of the `CEvent` object. Must be supplied if the object will be used across process boundaries. If the name matches an existing event, the constructor builds a new `CEvent` object which references the event of that name. If the name matches an existing synchronization object that is not an event, the construction will fail. If **NULL**, the name will be null.  \n  \n `lpsaAttribute`  \n Security attributes for the event object. For a full description of this structure, see [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Remarks  \n To access or release a `CEvent` object, create a [CMultiLock](../../mfc/reference/cmultilock-class.md) or [CSingleLock](../../mfc/reference/csinglelock-class.md) object and call its [Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock) and [Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock) member functions.  \n  \n To change the state of a `CEvent` object to signaled (threads do not have to wait), call [SetEvent](#cevent__setevent) or [PulseEvent](#cevent__pulseevent). To set the state of a `CEvent` object to nonsignaled (threads must wait), call [ResetEvent](#cevent__resetevent).  \n  \n> [!IMPORTANT]\n>  After creating the `CEvent` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex didn't already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.  \n  \n##  <a name=\"cevent__pulseevent\"></a>  CEvent::PulseEvent  \n Sets the state of the event to signaled (available), releases any waiting threads, and resets it to nonsignaled (unavailable) automatically.  \n  \n```  \nBOOL PulseEvent();\n```  \n  \n### Return Value  \n Nonzero if the function was successful; otherwise 0.  \n  \n### Remarks  \n If the event is manual, all waiting threads are released, the event is set to nonsignaled, and `PulseEvent` returns. If the event is automatic, a single thread is released, the event is set to nonsignaled, and `PulseEvent` returns.  \n  \n If no threads are waiting, or no threads can be released immediately, `PulseEvent` sets the state of the event to nonsignaled and returns.  \n  \n `PulseEvent` uses the underlying Win32 `PulseEvent` function, which can be momentarily removed from the wait state by a kernel-mode asynchronous procedure call. Therefore, `PulseEvent` is unreliable and should not be used by new applications. For more information, see the [PulseEvent function](http://msdn.microsoft.com/library/windows/desktop/ms684914).  \n  \n##  <a name=\"cevent__resetevent\"></a>  CEvent::ResetEvent  \n Sets the state of the event to nonsignaled until explicitly set to signaled by the [SetEvent](#cevent__setevent) member function.  \n  \n```  \nBOOL ResetEvent();\n```  \n  \n### Return Value  \n Nonzero if the function was successful; otherwise 0.  \n  \n### Remarks  \n This causes all threads wishing to access this event to wait.  \n  \n This member function is not used by automatic events.  \n  \n##  <a name=\"cevent__setevent\"></a>  CEvent::SetEvent  \n Sets the state of the event to signaled, releasing any waiting threads.  \n  \n```  \nBOOL SetEvent();\n```  \n  \n### Return Value  \n Nonzero if the function was successful, otherwise 0.  \n  \n### Remarks  \n If the event is manual, the event will remain signaled until [ResetEvent](#cevent__resetevent) is called. More than one thread can be released in this case. If the event is automatic, the event will remain signaled until a single thread is released. The system will then set the state of the event to nonsignaled. If no threads are waiting, the state remains signaled until one thread is released.  \n  \n##  <a name=\"cevent__unlock\"></a>  CEvent::Unlock  \n Releases the event object.  \n  \n```  \nBOOL Unlock();\n```  \n  \n### Return Value  \n Nonzero if the thread owned the event object and the event is an automatic event; otherwise 0.  \n  \n### Remarks  \n This member function is called by threads that currently own an automatic event to release it after they are done, if their lock object is to be reused. If the lock object is not to be reused, this function will be called by the lock object's destructor.  \n  \n## See Also  \n [CSyncObject Class](../../mfc/reference/csyncobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n"}