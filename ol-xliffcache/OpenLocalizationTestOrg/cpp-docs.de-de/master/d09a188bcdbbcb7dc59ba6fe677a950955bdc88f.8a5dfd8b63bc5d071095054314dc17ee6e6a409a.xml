{"nodes":[{"pos":[12,49],"content":"CAutoVectorPtr Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CAutoVectorPtr Class | Microsoft Docs","pos":[0,37]}]},{"pos":[724,744],"content":"CAutoVectorPtr Class","linkify":"CAutoVectorPtr Class","nodes":[{"content":"CAutoVectorPtr Class","pos":[0,20]}]},{"content":"This class represents a smart pointer object using vector new and delete operators.","pos":[745,828]},{"pos":[836,946],"content":"[!IMPORTANT]\n This class and its members cannot be used in applications that execute in the Windows Runtime.","leadings":["","> "],"nodes":[{"content":"This class and its members cannot be used in applications that execute in the Windows Runtime.","pos":[14,108]}]},{"pos":[955,961],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1027,1037],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The pointer type.","pos":[1048,1065]},{"pos":[1074,1081],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[1091,1110],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[1117,1121]},{"content":"Description","pos":[1122,1133]},{"pos":[1171,1236],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::CAutoVectorPtr<ept id=\"p1\">](#cautovectorptr__cautovectorptr)</ept>","source":"[CAutoVectorPtr::CAutoVectorPtr](#cautovectorptr__cautovectorptr)"},{"content":"The constructor.","pos":[1237,1253]},{"pos":[1258,1329],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::~CAutoVectorPtr<ept id=\"p1\">](#cautovectorptr___dtorcautovectorptr)</ept>","source":"[CAutoVectorPtr::~CAutoVectorPtr](#cautovectorptr___dtorcautovectorptr)"},{"content":"The destructor.","pos":[1330,1345]},{"pos":[1356,1370],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1377,1381]},{"content":"Description","pos":[1382,1393]},{"pos":[1431,1484],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::Allocate<ept id=\"p1\">](#cautovectorptr__allocate)</ept>","source":"[CAutoVectorPtr::Allocate](#cautovectorptr__allocate)"},{"pos":[1485,1589],"content":"Call this method to allocate the memory required by the array of objects pointed to by <ph id=\"ph1\">`CAutoVectorPtr`</ph>.","source":"Call this method to allocate the memory required by the array of objects pointed to by `CAutoVectorPtr`."},{"pos":[1594,1643],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::Attach<ept id=\"p1\">](#cautovectorptr__attach)</ept>","source":"[CAutoVectorPtr::Attach](#cautovectorptr__attach)"},{"content":"Call this method to take ownership of an existing pointer.","pos":[1644,1702]},{"pos":[1707,1756],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::Detach<ept id=\"p1\">](#cautovectorptr__detach)</ept>","source":"[CAutoVectorPtr::Detach](#cautovectorptr__detach)"},{"content":"Call this method to release ownership of a pointer.","pos":[1757,1808]},{"pos":[1813,1858],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::Free<ept id=\"p1\">](#cautovectorptr__free)</ept>","source":"[CAutoVectorPtr::Free](#cautovectorptr__free)"},{"pos":[1859,1929],"content":"Call this method to delete an object pointed to by a <ph id=\"ph1\">`CAutoVectorPtr`</ph>.","source":"Call this method to delete an object pointed to by a `CAutoVectorPtr`."},{"pos":[1940,1956],"content":"Public Operators","linkify":"Public Operators","nodes":[{"content":"Public Operators","pos":[0,16]}]},{"content":"Name","pos":[1963,1967]},{"content":"Description","pos":[1968,1979]},{"pos":[2017,2082],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::operator T *<ept id=\"p1\">](#cautovectorptr__operator_t__star)</ept>","source":"[CAutoVectorPtr::operator T *](#cautovectorptr__operator_t__star)"},{"content":"The cast operator.","pos":[2083,2101]},{"pos":[2106,2164],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::operator =<ept id=\"p1\">](#cautovectorptr__operator_eq)</ept>","source":"[CAutoVectorPtr::operator =](#cautovectorptr__operator_eq)"},{"content":"The assignment operator.","pos":[2165,2189]},{"pos":[2200,2219],"content":"Public Data Members","linkify":"Public Data Members","nodes":[{"content":"Public Data Members","pos":[0,19]}]},{"content":"Name","pos":[2226,2230]},{"content":"Description","pos":[2231,2242]},{"pos":[2280,2323],"content":"<bpt id=\"p1\">[</bpt>CAutoVectorPtr::m_p<ept id=\"p1\">](#cautovectorptr__m_p)</ept>","source":"[CAutoVectorPtr::m_p](#cautovectorptr__m_p)"},{"content":"The pointer data member variable.","pos":[2324,2357]},{"pos":[2367,2374],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This class provides methods for creating and managing a smart pointer, which will help protect against memory leaks by automatically freeing resources when it falls out of scope.","pos":[2378,2556]},{"content":"<ph id=\"ph1\">`CAutoVectorPtr`</ph> is similar to <ph id=\"ph2\">`CAutoPtr`</ph>, the only difference being that <ph id=\"ph3\">`CAutoVectorPtr`</ph> uses <bpt id=\"p1\">[</bpt>vector new&amp;#91;&amp;#93;<ept id=\"p1\">](../../standard-library/new-operators.md#operator_new_arr)</ept> and <bpt id=\"p2\">[</bpt>vector delete&amp;#91;&amp;#93;<ept id=\"p2\">](../../standard-library/new-operators.md#operator_delete_arr)</ept> to allocate and free memory instead of the C++ <bpt id=\"p3\">**</bpt>new<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>delete<ept id=\"p4\">**</ept> operators.","pos":[2557,2905],"source":"`CAutoVectorPtr` is similar to `CAutoPtr`, the only difference being that `CAutoVectorPtr` uses [vector new&#91;&#93;](../../standard-library/new-operators.md#operator_new_arr) and [vector delete&#91;&#93;](../../standard-library/new-operators.md#operator_delete_arr) to allocate and free memory instead of the C++ **new** and **delete** operators."},{"content":"See <bpt id=\"p1\">[</bpt>CAutoVectorPtrElementTraits<ept id=\"p1\">](../../atl/reference/cautovectorptrelementtraits-class.md)</ept> if collection classes of <ph id=\"ph1\">`CAutoVectorPtr`</ph> are required.","pos":[2906,3053],"source":" See [CAutoVectorPtrElementTraits](../../atl/reference/cautovectorptrelementtraits-class.md) if collection classes of `CAutoVectorPtr` are required."},{"pos":[3061,3161],"content":"See <bpt id=\"p1\">[</bpt>CAutoPtr<ept id=\"p1\">](../../atl/reference/cautoptr-class.md)</ept> for an example of using a smart pointer class.","source":"See [CAutoPtr](../../atl/reference/cautoptr-class.md) for an example of using a smart pointer class."},{"pos":[3170,3182],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[3186,3207],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> atlbase.h","source":"**Header:** atlbase.h"},{"pos":[3217,3282],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__allocate\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::Allocate","linkify":"<a name=\"cautovectorptr__allocate\"></a>  CAutoVectorPtr::Allocate","source":"<a name=\"cautovectorptr__allocate\"></a>  CAutoVectorPtr::Allocate"},{"pos":[3286,3390],"content":"Call this method to allocate the memory required by the array of objects pointed to by <ph id=\"ph1\">`CAutoVectorPtr`</ph>.","source":"Call this method to allocate the memory required by the array of objects pointed to by `CAutoVectorPtr`."},{"pos":[3454,3464],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The number of elements in the array.","pos":[3483,3519]},{"pos":[3529,3541],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns true if the memory is successfully allocated, false on failure.","pos":[3545,3616]},{"pos":[3626,3633],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[3637,3825],"content":"In debug builds, an assertion failure will occur if the <bpt id=\"p1\">[</bpt>CAutoVectorPtr::m_p<ept id=\"p1\">](#cautovectorptr__m_p)</ept> member variable currently points to an existing value; that is, it is not equal to NULL.","source":"In debug builds, an assertion failure will occur if the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable currently points to an existing value; that is, it is not equal to NULL."},{"pos":[3835,3896],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__attach\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::Attach","linkify":"<a name=\"cautovectorptr__attach\"></a>  CAutoVectorPtr::Attach","source":"<a name=\"cautovectorptr__attach\"></a>  CAutoVectorPtr::Attach"},{"content":"Call this method to take ownership of an existing pointer.","pos":[3900,3958]},{"pos":[4008,4018],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <ph id=\"ph1\">`CAutoVectorPtr`</ph> object will take ownership of this pointer.","pos":[4029,4093],"source":" The `CAutoVectorPtr` object will take ownership of this pointer."},{"pos":[4103,4110],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"When a <ph id=\"ph1\">`CAutoVectorPtr`</ph> object takes ownership of a pointer, it will automatically delete the pointer and any allocated data when it goes out of scope.","pos":[4114,4265],"source":"When a `CAutoVectorPtr` object takes ownership of a pointer, it will automatically delete the pointer and any allocated data when it goes out of scope."},{"content":"If <bpt id=\"p1\">[</bpt>CAutoVectorPtr::Detach<ept id=\"p1\">](#cautovectorptr__detach)</ept> is called, the programmer is again given responsibility for freeing any allocated resources.","pos":[4266,4411],"source":" If [CAutoVectorPtr::Detach](#cautovectorptr__detach) is called, the programmer is again given responsibility for freeing any allocated resources."},{"pos":[4418,4606],"content":"In debug builds, an assertion failure will occur if the <bpt id=\"p1\">[</bpt>CAutoVectorPtr::m_p<ept id=\"p1\">](#cautovectorptr__m_p)</ept> member variable currently points to an existing value; that is, it is not equal to NULL.","source":"In debug builds, an assertion failure will occur if the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable currently points to an existing value; that is, it is not equal to NULL."},{"pos":[4616,4693],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__cautovectorptr\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::CAutoVectorPtr","linkify":"<a name=\"cautovectorptr__cautovectorptr\"></a>  CAutoVectorPtr::CAutoVectorPtr","source":"<a name=\"cautovectorptr__cautovectorptr\"></a>  CAutoVectorPtr::CAutoVectorPtr"},{"content":"The constructor.","pos":[4697,4713]},{"pos":[4847,4857],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An existing pointer.","pos":[4868,4888]},{"pos":[4898,4905],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[4909,5031],"content":"The <ph id=\"ph1\">`CAutoVectorPtr`</ph> object can be created using an existing pointer, in which case it transfers ownership of the pointer.","source":"The `CAutoVectorPtr` object can be created using an existing pointer, in which case it transfers ownership of the pointer."},{"pos":[5041,5124],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr___dtorcautovectorptr\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::~CAutoVectorPtr","linkify":"<a name=\"cautovectorptr___dtorcautovectorptr\"></a>  CAutoVectorPtr::~CAutoVectorPtr","source":"<a name=\"cautovectorptr___dtorcautovectorptr\"></a>  CAutoVectorPtr::~CAutoVectorPtr"},{"content":"The destructor.","pos":[5128,5143]},{"pos":[5193,5200],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Frees any allocated resources.","pos":[5204,5234]},{"content":"Calls <bpt id=\"p1\">[</bpt>CAutoVectorPtr::Free<ept id=\"p1\">](#cautovectorptr__free)</ept>.","pos":[5235,5287],"source":" Calls [CAutoVectorPtr::Free](#cautovectorptr__free)."},{"pos":[5297,5358],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__detach\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::Detach","linkify":"<a name=\"cautovectorptr__detach\"></a>  CAutoVectorPtr::Detach","source":"<a name=\"cautovectorptr__detach\"></a>  CAutoVectorPtr::Detach"},{"content":"Call this method to release ownership of a pointer.","pos":[5362,5413]},{"pos":[5457,5469],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns a copy of the pointer.","pos":[5473,5503]},{"pos":[5513,5520],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Releases ownership of a pointer, sets the <bpt id=\"p1\">[</bpt>CAutoVectorPtr::m_p<ept id=\"p1\">](#cautovectorptr__m_p)</ept> member variable to NULL, and returns a copy of the pointer.","pos":[5524,5669],"source":"Releases ownership of a pointer, sets the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable to NULL, and returns a copy of the pointer."},{"content":"After calling <bpt id=\"p1\">**</bpt>Detach<ept id=\"p1\">**</ept>, it is up to the programmer to free any allocated resources over which the <ph id=\"ph1\">`CAutoVectorPtr`</ph> object may have previously assumed responsibility.","pos":[5670,5837],"source":" After calling **Detach**, it is up to the programmer to free any allocated resources over which the `CAutoVectorPtr` object may have previously assumed responsibility."},{"pos":[5847,5904],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__free\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::Free","linkify":"<a name=\"cautovectorptr__free\"></a>  CAutoVectorPtr::Free","source":"<a name=\"cautovectorptr__free\"></a>  CAutoVectorPtr::Free"},{"pos":[5908,5978],"content":"Call this method to delete an object pointed to by a <ph id=\"ph1\">`CAutoVectorPtr`</ph>.","source":"Call this method to delete an object pointed to by a `CAutoVectorPtr`."},{"pos":[6022,6029],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6033,6172],"content":"The object pointed to by the <ph id=\"ph1\">`CAutoVectorPtr`</ph> is freed, and the <bpt id=\"p1\">[</bpt>CAutoVectorPtr::m_p<ept id=\"p1\">](#cautovectorptr__m_p)</ept> member variable is set to NULL.","source":"The object pointed to by the `CAutoVectorPtr` is freed, and the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable is set to NULL."},{"pos":[6182,6237],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__m_p\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::m_p","linkify":"<a name=\"cautovectorptr__m_p\"></a>  CAutoVectorPtr::m_p","source":"<a name=\"cautovectorptr__m_p\"></a>  CAutoVectorPtr::m_p"},{"content":"The pointer data member variable.","pos":[6241,6274]},{"pos":[6305,6312],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This member variable holds the pointer information.","pos":[6316,6367]},{"pos":[6377,6447],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::operator =","linkify":"<a name=\"cautovectorptr__operator_eq\"></a>  CAutoVectorPtr::operator =","source":"<a name=\"cautovectorptr__operator_eq\"></a>  CAutoVectorPtr::operator ="},{"content":"The assignment operator.","pos":[6451,6475]},{"pos":[6559,6569],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer.","pos":[6580,6590]},{"pos":[6600,6612],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[6616,6666],"content":"Returns a reference to a <bpt id=\"p1\">**</bpt>CAutoVectorPtr<ph id=\"ph1\">\\&lt;</ph> T &gt;<ept id=\"p1\">**</ept>.","source":"Returns a reference to a **CAutoVectorPtr\\< T >**."},{"pos":[6676,6683],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6687,6821],"content":"The assignment operator detaches the <ph id=\"ph1\">`CAutoVectorPtr`</ph> object from any current pointer and attaches the new pointer, <ph id=\"ph2\">`p`</ph>, in its place.","source":"The assignment operator detaches the `CAutoVectorPtr` object from any current pointer and attaches the new pointer, `p`, in its place."},{"pos":[6831,6908],"content":"<bpt id=\"p1\">&lt;a name=\"cautovectorptr__operator_t__star\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CAutoVectorPtr::operator T *","linkify":"<a name=\"cautovectorptr__operator_t__star\"></a>  CAutoVectorPtr::operator T *","source":"<a name=\"cautovectorptr__operator_t__star\"></a>  CAutoVectorPtr::operator T *"},{"content":"The cast operator.","pos":[6912,6930]},{"content":"```operator T*() const throw();","pos":[6936,6967]}],"content":"---\ntitle: \"CAutoVectorPtr Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"ATL::CAutoVectorPtr\"\n  - \"ATL.CAutoVectorPtr\"\n  - \"ATL.CAutoVectorPtr<T>\"\n  - \"CAutoVectorPtr\"\n  - \"ATL::CAutoVectorPtr<T>\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CAutoVectorPtr class\"\nms.assetid: 0030362b-6bc4-4a47-9b5b-3c3899dceab4\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CAutoVectorPtr Class\nThis class represents a smart pointer object using vector new and delete operators.  \n  \n> [!IMPORTANT]\n>  This class and its members cannot be used in applications that execute in the Windows Runtime.  \n  \n## Syntax  \n  \n```\ntemplate<typename T> class CAutoVectorPtr\n```  \n  \n#### Parameters  \n `T`  \n The pointer type.  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAutoVectorPtr::CAutoVectorPtr](#cautovectorptr__cautovectorptr)|The constructor.|  \n|[CAutoVectorPtr::~CAutoVectorPtr](#cautovectorptr___dtorcautovectorptr)|The destructor.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAutoVectorPtr::Allocate](#cautovectorptr__allocate)|Call this method to allocate the memory required by the array of objects pointed to by `CAutoVectorPtr`.|  \n|[CAutoVectorPtr::Attach](#cautovectorptr__attach)|Call this method to take ownership of an existing pointer.|  \n|[CAutoVectorPtr::Detach](#cautovectorptr__detach)|Call this method to release ownership of a pointer.|  \n|[CAutoVectorPtr::Free](#cautovectorptr__free)|Call this method to delete an object pointed to by a `CAutoVectorPtr`.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAutoVectorPtr::operator T *](#cautovectorptr__operator_t__star)|The cast operator.|  \n|[CAutoVectorPtr::operator =](#cautovectorptr__operator_eq)|The assignment operator.|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAutoVectorPtr::m_p](#cautovectorptr__m_p)|The pointer data member variable.|  \n  \n## Remarks  \n This class provides methods for creating and managing a smart pointer, which will help protect against memory leaks by automatically freeing resources when it falls out of scope. `CAutoVectorPtr` is similar to `CAutoPtr`, the only difference being that `CAutoVectorPtr` uses [vector new&#91;&#93;](../../standard-library/new-operators.md#operator_new_arr) and [vector delete&#91;&#93;](../../standard-library/new-operators.md#operator_delete_arr) to allocate and free memory instead of the C++ **new** and **delete** operators. See [CAutoVectorPtrElementTraits](../../atl/reference/cautovectorptrelementtraits-class.md) if collection classes of `CAutoVectorPtr` are required.  \n\n  \n See [CAutoPtr](../../atl/reference/cautoptr-class.md) for an example of using a smart pointer class.  \n  \n## Requirements  \n **Header:** atlbase.h  \n  \n##  <a name=\"cautovectorptr__allocate\"></a>  CAutoVectorPtr::Allocate  \n Call this method to allocate the memory required by the array of objects pointed to by `CAutoVectorPtr`.  \n  \n```\nbool Allocate(size_t nElements) throw();\n```  \n  \n### Parameters  \n `nElements`  \n The number of elements in the array.  \n  \n### Return Value  \n Returns true if the memory is successfully allocated, false on failure.  \n  \n### Remarks  \n In debug builds, an assertion failure will occur if the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable currently points to an existing value; that is, it is not equal to NULL.  \n  \n##  <a name=\"cautovectorptr__attach\"></a>  CAutoVectorPtr::Attach  \n Call this method to take ownership of an existing pointer.  \n  \n```\nvoid Attach(T* p) throw();\n```  \n  \n### Parameters  \n `p`  \n The `CAutoVectorPtr` object will take ownership of this pointer.  \n  \n### Remarks  \n When a `CAutoVectorPtr` object takes ownership of a pointer, it will automatically delete the pointer and any allocated data when it goes out of scope. If [CAutoVectorPtr::Detach](#cautovectorptr__detach) is called, the programmer is again given responsibility for freeing any allocated resources.  \n  \n In debug builds, an assertion failure will occur if the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable currently points to an existing value; that is, it is not equal to NULL.  \n  \n##  <a name=\"cautovectorptr__cautovectorptr\"></a>  CAutoVectorPtr::CAutoVectorPtr  \n The constructor.  \n  \n```\nCAutoVectorPtr() throw();\nexplicit CAutoVectorPtr(T* p) throw();\nCAutoVectorPtr(CAutoVectorPtr<T>& p) throw();\n```  \n  \n### Parameters  \n `p`  \n An existing pointer.  \n  \n### Remarks  \n The `CAutoVectorPtr` object can be created using an existing pointer, in which case it transfers ownership of the pointer.  \n  \n##  <a name=\"cautovectorptr___dtorcautovectorptr\"></a>  CAutoVectorPtr::~CAutoVectorPtr  \n The destructor.  \n  \n```\n~CAutoVectorPtr() throw();\n```  \n  \n### Remarks  \n Frees any allocated resources. Calls [CAutoVectorPtr::Free](#cautovectorptr__free).  \n  \n##  <a name=\"cautovectorptr__detach\"></a>  CAutoVectorPtr::Detach  \n Call this method to release ownership of a pointer.  \n  \n```\nT* Detach() throw();\n```  \n  \n### Return Value  \n Returns a copy of the pointer.  \n  \n### Remarks  \n Releases ownership of a pointer, sets the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable to NULL, and returns a copy of the pointer. After calling **Detach**, it is up to the programmer to free any allocated resources over which the `CAutoVectorPtr` object may have previously assumed responsibility.  \n  \n##  <a name=\"cautovectorptr__free\"></a>  CAutoVectorPtr::Free  \n Call this method to delete an object pointed to by a `CAutoVectorPtr`.  \n  \n```\nvoid Free() throw();\n```  \n  \n### Remarks  \n The object pointed to by the `CAutoVectorPtr` is freed, and the [CAutoVectorPtr::m_p](#cautovectorptr__m_p) member variable is set to NULL.  \n  \n##  <a name=\"cautovectorptr__m_p\"></a>  CAutoVectorPtr::m_p  \n The pointer data member variable.  \n  \n```\nT* m_p;\n```  \n  \n### Remarks  \n This member variable holds the pointer information.  \n  \n##  <a name=\"cautovectorptr__operator_eq\"></a>  CAutoVectorPtr::operator =  \n The assignment operator.  \n  \n```\nCAutoVectorPtr<T>& operator= (CAutoVectorPtr<T>& p) throw();\n```  \n  \n### Parameters  \n `p`  \n A pointer.  \n  \n### Return Value  \n Returns a reference to a **CAutoVectorPtr\\< T >**.  \n  \n### Remarks  \n The assignment operator detaches the `CAutoVectorPtr` object from any current pointer and attaches the new pointer, `p`, in its place.  \n  \n##  <a name=\"cautovectorptr__operator_t__star\"></a>  CAutoVectorPtr::operator T *  \n The cast operator.  \n  \n```operator T*() const throw();\n```  \n  \n### Remarks  \n Returns a pointer to the object data type defined in the class template.  \n  \n## See Also  \n [CAutoPtr Class](../../atl/reference/cautoptr-class.md)   \n [Class Overview](../../atl/atl-class-overview.md)\n"}