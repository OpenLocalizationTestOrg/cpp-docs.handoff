{"nodes":[{"pos":[12,59],"content":"-EH (Exception Handling Model) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"-EH (Exception Handling Model) | Microsoft Docs","pos":[0,47]}]},{"content":"/EH (Exception Handling Model)","pos":[897,927]},{"content":"Specifies the kind of exception handling used by the compiler, when to optimize away exception checks, and whether to destroy C++ objects that go out of scope because of an exception.","pos":[928,1111]},{"content":"If <bpt id=\"p1\">**</bpt>/EH<ept id=\"p1\">**</ept> is not specified, the compiler catches both asynchronous structured exceptions and C++ exceptions, but does not destroy C++ objects that go out of scope because of an asynchronous exception.","pos":[1112,1313],"source":" If **/EH** is not specified, the compiler catches both asynchronous structured exceptions and C++ exceptions, but does not destroy C++ objects that go out of scope because of an asynchronous exception."},{"content":"Syntax","pos":[1322,1328]},{"content":"Arguments","pos":[1372,1381]},{"content":"a","pos":[1387,1388]},{"content":"The exception-handling model that catches both asynchronous (structured) and synchronous (C++) exceptions.","pos":[1394,1500]},{"content":"s","pos":[1509,1510]},{"content":"The exception-handling model that catches C++ exceptions only and tells the compiler to assume that functions declared as <ph id=\"ph1\">`extern \"C\"`</ph> may throw an exception.","pos":[1516,1674],"source":" The exception-handling model that catches C++ exceptions only and tells the compiler to assume that functions declared as `extern \"C\"` may throw an exception."},{"content":"c","pos":[1683,1684]},{"content":"If used with <bpt id=\"p1\">**</bpt>s<ept id=\"p1\">**</ept> (<bpt id=\"p2\">**</bpt>/EHsc<ept id=\"p2\">**</ept>), catches C++ exceptions only and tells the compiler to assume that functions declared as <ph id=\"ph1\">`extern \"C\"`</ph> never throw a C++ exception.","pos":[1690,1851],"source":" If used with **s** (**/EHsc**), catches C++ exceptions only and tells the compiler to assume that functions declared as `extern \"C\"` never throw a C++ exception."},{"pos":[1858,1894],"content":"<bpt id=\"p1\">**</bpt>/EHca<ept id=\"p1\">**</ept> is equivalent to <bpt id=\"p2\">**</bpt>/EHa<ept id=\"p2\">**</ept>.","source":"**/EHca** is equivalent to **/EHa**."},{"content":"r","pos":[1903,1904]},{"content":"Tells the compiler to always generate runtime termination checks for all <ph id=\"ph1\">`noexcept`</ph> functions.","pos":[1910,2004],"source":" Tells the compiler to always generate runtime termination checks for all `noexcept` functions."},{"content":"By default, runtime checks for <ph id=\"ph1\">`noexcept`</ph> may be optimized away if the compiler determines the function calls only non-throwing functions.","pos":[2005,2143],"source":" By default, runtime checks for `noexcept` may be optimized away if the compiler determines the function calls only non-throwing functions."},{"content":"Remarks","pos":[2152,2159]},{"content":"The <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> compiler option is used to support asynchronous structured exception handling (SEH) with the native C++ <ph id=\"ph1\">`catch(...)`</ph> clause.","pos":[2163,2300],"source":"The **/EHa** compiler option is used to support asynchronous structured exception handling (SEH) with the native C++ `catch(...)` clause."},{"content":"To implement SEH without specifying <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept>, you may use the <ph id=\"ph1\">`__try`</ph>, <ph id=\"ph2\">`__except`</ph>, and <ph id=\"ph3\">`__finally`</ph> syntax.","pos":[2301,2407],"source":" To implement SEH without specifying **/EHa**, you may use the `__try`, `__except`, and `__finally` syntax."},{"content":"Although Windows and Visual C++ support SEH, we strongly recommend that you use ISO-standard C++ exception handling (<bpt id=\"p1\">**</bpt>/EHs<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/EHsc<ept id=\"p2\">**</ept>) because it makes code more portable and flexible.","pos":[2408,2597],"source":" Although Windows and Visual C++ support SEH, we strongly recommend that you use ISO-standard C++ exception handling (**/EHs** or **/EHsc**) because it makes code more portable and flexible."},{"content":"Nevertheless, in existing code or for particular kinds of programs—for example, in code compiled to support the common language runtime (<bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept>)—you still might have to use SEH.","pos":[2598,2879],"source":" Nevertheless, in existing code or for particular kinds of programs—for example, in code compiled to support the common language runtime ([/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md))—you still might have to use SEH."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Structured Exception Handling (C/C++)<ept id=\"p1\">](../../cpp/structured-exception-handling-c-cpp.md)</ept>.","pos":[2880,2996],"source":" For more information, see [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)."},{"content":"Specifying <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> and trying to handle all exceptions by using <ph id=\"ph1\">`catch(...)`</ph> can be dangerous.","pos":[3003,3098],"source":"Specifying **/EHa** and trying to handle all exceptions by using `catch(...)` can be dangerous."},{"content":"In most cases, asynchronous exceptions are unrecoverable and should be considered fatal.","pos":[3099,3187]},{"content":"Catching them and proceeding can cause process corruption and lead to bugs that are hard to find and fix.","pos":[3188,3293]},{"content":"If you use <bpt id=\"p1\">**</bpt>/EHs<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/EHsc<ept id=\"p2\">**</ept>, then your <ph id=\"ph1\">`catch(...)`</ph> clause does not catch asynchronous structured exceptions.","pos":[3300,3414],"source":"If you use **/EHs** or **/EHsc**, then your `catch(...)` clause does not catch asynchronous structured exceptions."},{"content":"Access violations and managed &lt;xref:System.Exception?displayProperty=fullName&gt; exceptions are not caught, and objects in scope when an asynchronous exception is generated are not destroyed even if the asynchronous exception is handled.","pos":[3415,3650],"source":" Access violations and managed <xref:System.Exception?displayProperty=fullName> exceptions are not caught, and objects in scope when an asynchronous exception is generated are not destroyed even if the asynchronous exception is handled."},{"content":"If you use <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept>, the image may be larger and might perform less well because the compiler does not optimize a <ph id=\"ph1\">`try`</ph> block as aggressively.","pos":[3657,3799],"source":"If you use **/EHa**, the image may be larger and might perform less well because the compiler does not optimize a `try` block as aggressively."},{"content":"It also leaves in exception filters that automatically call the destructors of all local objects even if the compiler does not see any code that can throw a C++ exception.","pos":[3800,3971]},{"content":"This enables safe stack unwinding for asynchronous exceptions as well as for C++ exceptions.","pos":[3972,4064]},{"content":"When you use <bpt id=\"p1\">**</bpt>/EHs<ept id=\"p1\">**</ept>, the compiler assumes that exceptions can only occur at a <ph id=\"ph1\">`throw`</ph> statement or at a function call.","pos":[4065,4185],"source":" When you use **/EHs**, the compiler assumes that exceptions can only occur at a `throw` statement or at a function call."},{"content":"This allows the compiler to eliminate code for tracking the lifetime of many unwindable objects, and this can significantly reduce code size.","pos":[4186,4327]},{"content":"We recommend that you not link objects compiled by using <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> together with objects compiled by using <bpt id=\"p2\">**</bpt>/EHs<ept id=\"p2\">**</ept> in the same executable module.","pos":[4334,4479],"source":"We recommend that you not link objects compiled by using **/EHa** together with objects compiled by using **/EHs** in the same executable module."},{"content":"If you have to handle an asynchronous exception by using <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> anywhere in your module, use <bpt id=\"p2\">**</bpt>/EHa<ept id=\"p2\">**</ept> to compile all the code in the module.","pos":[4480,4622],"source":" If you have to handle an asynchronous exception by using **/EHa** anywhere in your module, use **/EHa** to compile all the code in the module."},{"content":"You can use structured exception handling syntax in the same module as code that's compiled by using <bpt id=\"p1\">**</bpt>/EHs<ept id=\"p1\">**</ept>, but you can’t mix the SEH syntax with <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`throw`</ph>, and <ph id=\"ph3\">`catch`</ph> in the same function.","pos":[4623,4821],"source":" You can use structured exception handling syntax in the same module as code that's compiled by using **/EHs**, but you can’t mix the SEH syntax with `try`, `throw`, and `catch` in the same function."},{"content":"Use <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> if you want to catch an exception that's raised by something other than a <ph id=\"ph1\">`throw`</ph>.","pos":[4828,4923],"source":"Use **/EHa** if you want to catch an exception that's raised by something other than a `throw`."},{"content":"This example generates and catches a structured exception:","pos":[4924,4982]},{"content":"The <bpt id=\"p1\">**</bpt>/EHc<ept id=\"p1\">**</ept> option requires that <bpt id=\"p2\">**</bpt>/EHs<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>/EHa<ept id=\"p3\">**</ept> is specified.","pos":[5781,5849],"source":"The **/EHc** option requires that **/EHs** or **/EHa** is specified."},{"content":"The <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> option implies <bpt id=\"p2\">**</bpt>/EHa<ept id=\"p2\">**</ept> (that is, <bpt id=\"p3\">**</bpt>/clr /EHa<ept id=\"p3\">**</ept> is redundant).","pos":[5850,5925],"source":" The **/clr** option implies **/EHa** (that is, **/clr /EHa** is redundant)."},{"content":"The compiler generates an error if <bpt id=\"p1\">**</bpt>/EHs[c]<ept id=\"p1\">**</ept> is used after <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept>.","pos":[5926,5996],"source":" The compiler generates an error if **/EHs[c]** is used after **/clr**."},{"content":"Optimizations do not affect this behavior.","pos":[5997,6039]},{"content":"When an exception is caught, the compiler invokes the class destructor or destructors for the object or objects that are in the same scope as the exception.","pos":[6040,6196]},{"content":"When an exception is not caught, those destructors are not run.","pos":[6197,6260]},{"pos":[6267,6418],"content":"For information about exception handling restrictions under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>_set_se_translator<ept id=\"p2\">](../../c-runtime-library/reference/set-se-translator.md)</ept>.","source":"For information about exception handling restrictions under **/clr**, see [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md)."},{"content":"The option can be cleared by using the symbol <bpt id=\"p1\">**</bpt><ph id=\"ph1\">-</ph><ept id=\"p1\">**</ept>.","pos":[6425,6477],"source":"The option can be cleared by using the symbol **-**."},{"content":"For example, <bpt id=\"p1\">**</bpt>/EHsc-<ept id=\"p1\">**</ept> is interpreted as <bpt id=\"p2\">**</bpt>/EHs /EHc-<ept id=\"p2\">**</ept> and is equivalent to <bpt id=\"p3\">**</bpt>/EHs<ept id=\"p3\">**</ept>.","pos":[6478,6565],"source":" For example, **/EHsc-** is interpreted as **/EHs /EHc-** and is equivalent to **/EHs**."},{"content":"The <bpt id=\"p1\">**</bpt>/EHr<ept id=\"p1\">**</ept> compiler option forces runtime termination checks in all functions that have a <ph id=\"ph1\">`noexcept`</ph> attribute.","pos":[6572,6685],"source":"The **/EHr** compiler option forces runtime termination checks in all functions that have a `noexcept` attribute."},{"content":"By default, runtime checks may be optimized away if the compiler back end determines that a function only calls <bpt id=\"p1\">*</bpt>non-throwing<ept id=\"p1\">*</ept> functions.","pos":[6686,6823],"source":" By default, runtime checks may be optimized away if the compiler back end determines that a function only calls *non-throwing* functions."},{"content":"Non-throwing functions are any functions that have an attribute that specifies no exceptions may be thrown.","pos":[6824,6931]},{"content":"This includes functions marked <ph id=\"ph1\">`noexcept`</ph>, <ph id=\"ph2\">`throw()`</ph>, <ph id=\"ph3\">`__declspec(nothrow)`</ph>, and, when <bpt id=\"p1\">**</bpt>/EHc<ept id=\"p1\">**</ept> is specified, <ph id=\"ph4\">`extern \"C\"`</ph> functions.","pos":[6932,7065],"source":" This includes functions marked `noexcept`, `throw()`, `__declspec(nothrow)`, and, when **/EHc** is specified, `extern \"C\"` functions."},{"content":"Non-throwing functions also include any that the compiler has determined are non-throwing by inspection.","pos":[7066,7170]},{"content":"You can explicitly set the default by using <bpt id=\"p1\">**</bpt>/EHr-<ept id=\"p1\">**</ept>.","pos":[7171,7225],"source":" You can explicitly set the default by using **/EHr-**."},{"content":"However, the non-throwing attribute is not a guarantee that no exceptions can be thrown by a function.","pos":[7232,7334]},{"content":"Unlike the behavior of a <ph id=\"ph1\">`noexcept`</ph> function, the Visual C++ compiler considers an exception thrown by a function declared using <ph id=\"ph2\">`throw()`</ph>, <ph id=\"ph3\">`__declspec(nothrow)`</ph>, or <ph id=\"ph4\">`extern \"C\"`</ph> as undefined behavior.","pos":[7335,7536],"source":" Unlike the behavior of a `noexcept` function, the Visual C++ compiler considers an exception thrown by a function declared using `throw()`, `__declspec(nothrow)`, or `extern \"C\"` as undefined behavior."},{"content":"Functions that use these three declaration attributes do not enforce runtime termination checks for exceptions.","pos":[7537,7648]},{"content":"You can use the <bpt id=\"p1\">**</bpt>/EHr<ept id=\"p1\">**</ept> option to help you identify this undefined behavior, by forcing the compiler to generate runtime checks for unhandled exceptions that escape a <ph id=\"ph1\">`noexcept`</ph> function.","pos":[7649,7837],"source":" You can use the **/EHr** option to help you identify this undefined behavior, by forcing the compiler to generate runtime checks for unhandled exceptions that escape a `noexcept` function."},{"content":"To set this compiler option in the Visual Studio development environment","pos":[7847,7919]},{"content":"Open the project's <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept> dialog box.","pos":[7929,7978],"source":"Open the project's **Property Pages** dialog box."},{"content":"For details, see <bpt id=\"p1\">[</bpt>Working with Project Properties<ept id=\"p1\">](../../ide/working-with-project-properties.md)</ept>.","pos":[7979,8076],"source":" For details, see [Working with Project Properties](../../ide/working-with-project-properties.md)."},{"pos":[8086,8172],"content":"In the left pane, expand <bpt id=\"p1\">**</bpt>Configuration Properties<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>C/C++<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Code Generation<ept id=\"p3\">**</ept>.","source":"In the left pane, expand **Configuration Properties**, **C/C++**, **Code Generation**."},{"pos":[8182,8228],"content":"Modify the <bpt id=\"p1\">**</bpt>Enable C++ Exceptions<ept id=\"p1\">**</ept> property.","source":"Modify the **Enable C++ Exceptions** property."},{"pos":[8239,8391],"content":"Or, set <bpt id=\"p1\">**</bpt>Enable C++ Exceptions<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>No<ept id=\"p2\">**</ept>, and then on the <bpt id=\"p3\">**</bpt>Command Line<ept id=\"p3\">**</ept> property page, in the <bpt id=\"p4\">**</bpt>Additional Options<ept id=\"p4\">**</ept> box, add the compiler option.","source":"Or, set **Enable C++ Exceptions** to **No**, and then on the **Command Line** property page, in the **Additional Options** box, add the compiler option."},{"content":"To set this compiler option programmatically","pos":[8401,8445]},{"content":"See &lt;xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A&gt;.","pos":[8455,8543],"source":"See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>."},{"content":"See Also","pos":[8552,8560]},{"content":"Compiler Options","pos":[8565,8581]},{"content":"Setting Compiler Options","pos":[8631,8655]},{"content":"Errors and Exception Handling","pos":[8713,8742]},{"content":"Exception Specifications (throw)","pos":[8804,8836]},{"content":"Structured Exception Handling (C/C++)","pos":[8892,8929]}],"content":"---\ntitle: \"-EH (Exception Handling Model) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"VC.Project.VCCLWCECompilerTool.ExceptionHandling\"\n  - \"/eh\"\n  - \"VC.Project.VCCLCompilerTool.ExceptionHandling\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"exception handling, compiler model\"\n  - \"cl.exe compiler, exception handling\"\n  - \"EH compiler option [C++]\"\n  - \"-EH compiler option [C++]\"\n  - \"/EH compiler option [C++]\"\nms.assetid: 754b916f-d206-4472-b55a-b6f1b0f2cb4d\ncaps.latest.revision: 29\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# /EH (Exception Handling Model)\nSpecifies the kind of exception handling used by the compiler, when to optimize away exception checks, and whether to destroy C++ objects that go out of scope because of an exception. If **/EH** is not specified, the compiler catches both asynchronous structured exceptions and C++ exceptions, but does not destroy C++ objects that go out of scope because of an asynchronous exception.  \n  \n## Syntax  \n  \n```  \n/EH{s|a}[c][r][-]  \n```  \n  \n## Arguments  \n **a**  \n The exception-handling model that catches both asynchronous (structured) and synchronous (C++) exceptions.  \n  \n **s**  \n The exception-handling model that catches C++ exceptions only and tells the compiler to assume that functions declared as `extern \"C\"` may throw an exception.  \n  \n **c**  \n If used with **s** (**/EHsc**), catches C++ exceptions only and tells the compiler to assume that functions declared as `extern \"C\"` never throw a C++ exception.  \n  \n **/EHca** is equivalent to **/EHa**.  \n  \n **r**  \n Tells the compiler to always generate runtime termination checks for all `noexcept` functions. By default, runtime checks for `noexcept` may be optimized away if the compiler determines the function calls only non-throwing functions.  \n  \n## Remarks  \n The **/EHa** compiler option is used to support asynchronous structured exception handling (SEH) with the native C++ `catch(...)` clause. To implement SEH without specifying **/EHa**, you may use the `__try`, `__except`, and `__finally` syntax. Although Windows and Visual C++ support SEH, we strongly recommend that you use ISO-standard C++ exception handling (**/EHs** or **/EHsc**) because it makes code more portable and flexible. Nevertheless, in existing code or for particular kinds of programs—for example, in code compiled to support the common language runtime ([/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md))—you still might have to use SEH. For more information, see [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md).  \n  \n Specifying **/EHa** and trying to handle all exceptions by using `catch(...)` can be dangerous. In most cases, asynchronous exceptions are unrecoverable and should be considered fatal. Catching them and proceeding can cause process corruption and lead to bugs that are hard to find and fix.  \n  \n If you use **/EHs** or **/EHsc**, then your `catch(...)` clause does not catch asynchronous structured exceptions. Access violations and managed <xref:System.Exception?displayProperty=fullName> exceptions are not caught, and objects in scope when an asynchronous exception is generated are not destroyed even if the asynchronous exception is handled.  \n  \n If you use **/EHa**, the image may be larger and might perform less well because the compiler does not optimize a `try` block as aggressively. It also leaves in exception filters that automatically call the destructors of all local objects even if the compiler does not see any code that can throw a C++ exception. This enables safe stack unwinding for asynchronous exceptions as well as for C++ exceptions. When you use **/EHs**, the compiler assumes that exceptions can only occur at a `throw` statement or at a function call. This allows the compiler to eliminate code for tracking the lifetime of many unwindable objects, and this can significantly reduce code size.  \n  \n We recommend that you not link objects compiled by using **/EHa** together with objects compiled by using **/EHs** in the same executable module. If you have to handle an asynchronous exception by using **/EHa** anywhere in your module, use **/EHa** to compile all the code in the module. You can use structured exception handling syntax in the same module as code that's compiled by using **/EHs**, but you can’t mix the SEH syntax with `try`, `throw`, and `catch` in the same function.  \n  \n Use **/EHa** if you want to catch an exception that's raised by something other than a `throw`. This example generates and catches a structured exception:  \n  \n```  \n  \n      // compiler_options_EHA.cpp  \n// compile with: /EHa  \n#include <iostream>  \n#include <excpt.h>  \nusing namespace std;  \n  \nvoid fail() {   // generates SE and attempts to catch it using catch(...)  \n   try {  \n      int i = 0, j = 1;  \n      j /= i;   // This will throw a SE (divide by zero).  \n      printf(\"%d\", j);   \n   }  \n   catch(...) {   // catch block will only be executed under /EHa  \n      cout<<\"Caught an exception in catch(...).\"<<endl;  \n   }  \n}  \n  \nint main() {  \n   __try {  \n      fail();   \n   }  \n  \n   // __except will only catch an exception here  \n   __except(EXCEPTION_EXECUTE_HANDLER) {     \n   // if the exception was not caught by the catch(...) inside fail()  \n      cout << \"An exception was caught in __except.\" << endl;  \n   }  \n}  \n```  \n  \n The **/EHc** option requires that **/EHs** or **/EHa** is specified. The **/clr** option implies **/EHa** (that is, **/clr /EHa** is redundant). The compiler generates an error if **/EHs[c]** is used after **/clr**. Optimizations do not affect this behavior. When an exception is caught, the compiler invokes the class destructor or destructors for the object or objects that are in the same scope as the exception. When an exception is not caught, those destructors are not run.  \n  \n For information about exception handling restrictions under **/clr**, see [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md).  \n  \n The option can be cleared by using the symbol **-**. For example, **/EHsc-** is interpreted as **/EHs /EHc-** and is equivalent to **/EHs**.  \n  \n The **/EHr** compiler option forces runtime termination checks in all functions that have a `noexcept` attribute. By default, runtime checks may be optimized away if the compiler back end determines that a function only calls *non-throwing* functions. Non-throwing functions are any functions that have an attribute that specifies no exceptions may be thrown. This includes functions marked `noexcept`, `throw()`, `__declspec(nothrow)`, and, when **/EHc** is specified, `extern \"C\"` functions. Non-throwing functions also include any that the compiler has determined are non-throwing by inspection. You can explicitly set the default by using **/EHr-**.  \n  \n However, the non-throwing attribute is not a guarantee that no exceptions can be thrown by a function. Unlike the behavior of a `noexcept` function, the Visual C++ compiler considers an exception thrown by a function declared using `throw()`, `__declspec(nothrow)`, or `extern \"C\"` as undefined behavior. Functions that use these three declaration attributes do not enforce runtime termination checks for exceptions. You can use the **/EHr** option to help you identify this undefined behavior, by forcing the compiler to generate runtime checks for unhandled exceptions that escape a `noexcept` function.  \n  \n### To set this compiler option in the Visual Studio development environment  \n  \n1.  Open the project's **Property Pages** dialog box. For details, see [Working with Project Properties](../../ide/working-with-project-properties.md).  \n  \n2.  In the left pane, expand **Configuration Properties**, **C/C++**, **Code Generation**.  \n  \n3.  Modify the **Enable C++ Exceptions** property.  \n  \n     Or, set **Enable C++ Exceptions** to **No**, and then on the **Command Line** property page, in the **Additional Options** box, add the compiler option.  \n  \n### To set this compiler option programmatically  \n  \n-   See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>.  \n  \n## See Also  \n [Compiler Options](../../build/reference/compiler-options.md)   \n [Setting Compiler Options](../../build/reference/setting-compiler-options.md)   \n [Errors and Exception Handling](../../cpp/errors-and-exception-handling-modern-cpp.md)   \n [Exception Specifications (throw)](../../cpp/exception-specifications-throw-cpp.md)   \n [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)"}