{"nodes":[{"pos":[12,56],"content":"&lt;algorithm&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"algorithm<ph id=\"ph1\">&amp;gt;</ph> functions | Microsoft Docs","pos":[4,44],"source":"algorithm&gt; functions | Microsoft Docs"}]},{"content":"algorithm<ph id=\"ph1\">&amp;gt;</ph> functions","pos":[6511,6534],"source":"algorithm&gt; functions"},{"content":"move","pos":[6554,6558]},{"content":"adjacent_find","pos":[6572,6585]},{"content":"all_of","pos":[6604,6610]},{"content":"any_of","pos":[6626,6632]},{"content":"binary_search","pos":[6644,6657]},{"content":"copy","pos":[6676,6680]},{"content":"copy_backward","pos":[6694,6707]},{"content":"copy_if","pos":[6726,6733]},{"content":"copy_n","pos":[6746,6752]},{"content":"count","pos":[6768,6773]},{"content":"count_if","pos":[6784,6792]},{"content":"equal","pos":[6806,6811]},{"content":"equal_range","pos":[6826,6837]},{"content":"fill","pos":[6854,6858]},{"content":"fill_n","pos":[6868,6874]},{"content":"find","pos":[6890,6894]},{"content":"find_end","pos":[6904,6912]},{"content":"find_first_of","pos":[6926,6939]},{"content":"find_if","pos":[6962,6969]},{"content":"find_if_not","pos":[6982,6993]},{"content":"for_each","pos":[7010,7018]},{"content":"generate","pos":[7036,7044]},{"content":"generate_n","pos":[7058,7068]},{"content":"includes","pos":[7084,7092]},{"content":"inplace_merge","pos":[7110,7123]},{"content":"is_heap","pos":[7142,7149]},{"content":"is_heap_until","pos":[7162,7175]},{"content":"is_partitioned","pos":[7198,7212]},{"content":"is_permutation","pos":[7232,7246]},{"content":"is_sorted","pos":[7266,7275]},{"content":"is_sorted_until","pos":[7294,7309]},{"content":"iter_swap","pos":[7330,7339]},{"content":"lexicographical_compare","pos":[7354,7377]},{"content":"lower_bound","pos":[7410,7421]},{"content":"make_heap","pos":[7438,7447]},{"content":"max","pos":[7462,7465]},{"content":"max_element","pos":[7478,7489]},{"content":"merge","pos":[7506,7511]},{"content":"min","pos":[7522,7525]},{"content":"min_element","pos":[7538,7549]},{"content":"minmax","pos":[7566,7572]},{"content":"minmax_element","pos":[7584,7598]},{"content":"mismatch","pos":[7622,7630]},{"content":"move_backward","pos":[7644,7657]},{"content":"next_permutation","pos":[7676,7692]},{"content":"none_of","pos":[7718,7725]},{"content":"nth_element","pos":[7738,7749]},{"content":"partial_sort","pos":[7766,7778]},{"content":"partial_sort_copy","pos":[7800,7817]},{"content":"partition","pos":[7840,7849]},{"content":"partition_copy","pos":[7864,7878]},{"content":"partition_point","pos":[7902,7917]},{"content":"pop_heap","pos":[7938,7946]},{"content":"prev_permutation","pos":[7960,7976]},{"content":"push_heap","pos":[8002,8011]},{"content":"random_shuffle","pos":[8026,8040]},{"content":"remove","pos":[8060,8066]},{"content":"remove_copy","pos":[8082,8093]},{"content":"remove_copy_if","pos":[8110,8124]},{"content":"remove_if","pos":[8144,8153]},{"content":"replace","pos":[8172,8179]},{"content":"replace_copy","pos":[8192,8204]},{"content":"replace_copy_if","pos":[8222,8237]},{"content":"replace_if","pos":[8262,8272]},{"content":"reverse","pos":[8288,8295]},{"content":"reverse_copy","pos":[8308,8320]},{"content":"rotate","pos":[8342,8348]},{"content":"rotate_copy","pos":[8360,8371]},{"content":"search","pos":[8388,8394]},{"content":"search_n","pos":[8410,8418]},{"content":"set_difference","pos":[8432,8446]},{"content":"set_intersection","pos":[8466,8482]},{"content":"set_symmetric_difference","pos":[8508,8532]},{"content":"set_union","pos":[8562,8571]},{"content":"sort","pos":[8586,8590]},{"content":"sort_heap","pos":[8604,8613]},{"content":"stable_partition","pos":[8628,8644]},{"content":"stable_sort","pos":[8666,8677]},{"content":"std::shuffle","pos":[8698,8710]},{"content":"swap","pos":[8728,8732]},{"content":"swap_ranges","pos":[8742,8753]},{"content":"transform","pos":[8774,8783]},{"content":"unique","pos":[8798,8804]},{"content":"unique_copy","pos":[8816,8827]},{"content":"upper_bound","pos":[8848,8859]},{"pos":[8915,8928],"content":"adjacent_find"},{"content":"Searches for two adjacent elements that are either equal or satisfy a specified condition.","pos":[8932,9022]},{"content":"Parameters","pos":[9381,9391]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[9407,9499]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[9516,9614]},{"content":"The binary predicate giving the condition to be satisfied by the values of the adjacent elements in the range being searched.","pos":[9631,9756]},{"content":"Return Value","pos":[9766,9778]},{"content":"A forward iterator to the first element of the adjacent pair that are either equal to each other (in the first version) or that satisfy the condition given by the binary predicate (in the second version), provided that such a pair of elements is found.","pos":[9782,10034]},{"content":"Otherwise, an iterator pointing to <ph id=\"ph1\">`last`</ph> is returned.","pos":[10035,10089],"source":" Otherwise, an iterator pointing to `last` is returned."},{"content":"Remarks","pos":[10099,10106]},{"content":"The <ph id=\"ph1\">`adjacent_find`</ph> algorithm is a nonmutating sequence algorithm.","pos":[10110,10176],"source":"The `adjacent_find` algorithm is a nonmutating sequence algorithm."},{"content":"The range to be searched must be valid; all pointers must be dereferenceable and the last position is reachable from the first by incrementation.","pos":[10177,10322]},{"content":"The time complexity of the algorithm is linear in the number of elements contained in the range.","pos":[10323,10419]},{"pos":[10426,10545],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between elements must impose an equivalence relation between its operands."},{"content":"Example","pos":[10555,10562]},{"pos":[12282,12288],"content":"all_of"},{"pos":[12292,12370],"content":"Returns <ph id=\"ph1\">`true`</ph> when a condition is present at each element in the given range.","source":"Returns `true` when a condition is present at each element in the given range."},{"content":"Parameters","pos":[12558,12568]},{"content":"An input iterator that indicates where to start to check for a condition.","pos":[12584,12657]},{"content":"The iterator marks where a range of elements starts.","pos":[12658,12710]},{"content":"An input iterator that indicates the end of the range of elements to check for a condition.","pos":[12727,12818]},{"content":"A condition to test for.","pos":[12835,12859]},{"content":"This is a user-defined predicate function object that defines the condition to be satisfied by an element being checked.","pos":[12860,12980]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[12981,13047],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Return Value","pos":[13057,13069]},{"pos":[13073,13220],"content":"Returns <ph id=\"ph1\">`true`</ph> if the condition is detected at each element in the indicated range, and <ph id=\"ph2\">`false`</ph> if the condition is not detected at least one time.","source":"Returns `true` if the condition is detected at each element in the indicated range, and `false` if the condition is not detected at least one time."},{"content":"Remarks","pos":[13230,13237]},{"pos":[13241,13379],"content":"The template function returns <ph id=\"ph1\">`true`</ph> only if, for each <ph id=\"ph2\">`N`</ph> in the range <ph id=\"ph3\">`[0,Last - first)`</ph>, the predicate <ph id=\"ph4\">`comp(*(_First + N))`</ph> is <ph id=\"ph5\">`true`</ph>.","source":"The template function returns `true` only if, for each `N` in the range `[0,Last - first)`, the predicate `comp(*(_First + N))` is `true`."},{"pos":[13412,13418],"content":"any_of"},{"pos":[13422,13514],"content":"Returns <ph id=\"ph1\">`true`</ph> when a condition is present at least once in the specified range of elements.","source":"Returns `true` when a condition is present at least once in the specified range of elements."},{"content":"Parameters","pos":[13707,13717]},{"content":"An input iterator that indicates where to start checking a range of elements for a condition.","pos":[13733,13826]},{"content":"An input iterator that indicates the end of the range of elements to check for a condition.","pos":[13843,13934]},{"content":"A condition to test for.","pos":[13951,13975]},{"content":"This is provided by a user-defined predicate function object.","pos":[13976,14037]},{"content":"The predicate defines the condition to be satisfied by the element being tested.","pos":[14038,14118]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[14119,14185],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Return Value","pos":[14195,14207]},{"pos":[14211,14336],"content":"Returns <ph id=\"ph1\">`true`</ph> if the condition is detected at least once in the indicated range, <ph id=\"ph2\">`false`</ph> if the condition is never detected.","source":"Returns `true` if the condition is detected at least once in the indicated range, `false` if the condition is never detected."},{"content":"Remarks","pos":[14346,14353]},{"pos":[14357,14428],"content":"The template function returns <ph id=\"ph1\">`true`</ph> only if, for some <ph id=\"ph2\">`N`</ph> in the range","source":"The template function returns `true` only if, for some `N` in the range"},{"pos":[14467,14519],"content":", the predicate <ph id=\"ph1\">`comp``(*(`</ph> <ph id=\"ph2\">`first`</ph> <ph id=\"ph3\">`+ N))`</ph> is true.","source":", the predicate `comp``(*(` `first` `+ N))` is true."},{"pos":[14559,14572],"content":"binary_search"},{"content":"Tests whether there is an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.","pos":[14576,14734]},{"content":"Parameters","pos":[15151,15161]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[15176,15268]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[15285,15383]},{"content":"The value required to be matched by the value of the element or that must satisfy the condition with the element value specified by the binary predicate.","pos":[15401,15554]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[15571,15671]},{"content":"A binary predicate takes two arguments and returns <ph id=\"ph1\">`true`</ph>when satisfied and <ph id=\"ph2\">`false`</ph> when not satisfied.","pos":[15672,15775],"source":" A binary predicate takes two arguments and returns `true`when satisfied and `false` when not satisfied."},{"content":"Return Value","pos":[15785,15797]},{"pos":[15808,15915],"content":"if an element is found in the range that is equal or equivalent to the specified value; otherwise, <ph id=\"ph1\">`false`</ph>.","source":" if an element is found in the range that is equal or equivalent to the specified value; otherwise, `false`."},{"content":"Remarks","pos":[15925,15932]},{"content":"The sorted source range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.","pos":[15936,16118]},{"pos":[16125,16333],"content":"The sorted range must each be arranged as a precondition to the application of the <ph id=\"ph1\">`binary_search`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","source":"The sorted range must each be arranged as a precondition to the application of the `binary_search` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"pos":[16340,16394],"content":"The source ranges are not modified by <ph id=\"ph1\">`binary_search`</ph>.","source":"The source ranges are not modified by `binary_search`."},{"content":"The value types of the forward iterators need to be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[16401,16657]},{"content":"This results in an ordering between the nonequivalent elements","pos":[16658,16720]},{"pos":[16727,16885],"content":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id=\"ph1\">`last`</ph> – <ph id=\"ph2\">`first`</ph>).","source":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last` – `first`)."},{"content":"Example","pos":[16895,16902]},{"pos":[19201,19205],"content":"copy"},{"content":"Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.","pos":[19209,19390]},{"content":"Parameters","pos":[19588,19598]},{"content":"An input iterator addressing the position of the first element in the source range.","pos":[19614,19697]},{"content":"An input iterator addressing the position that is one past the final element in the source range.","pos":[19714,19811]},{"content":"destBeg","pos":[19819,19826]},{"content":"An output iterator addressing the position of the first element in the destination range.","pos":[19831,19920]},{"content":"Return Value","pos":[19930,19942]},{"pos":[19946,20115],"content":"An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <ph id=\"ph1\">`result`</ph> + ( <ph id=\"ph2\">`last`</ph> –  <ph id=\"ph3\">`first`</ph> ).","source":"An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses `result` + ( `last` –  `first` )."},{"content":"Remarks","pos":[20125,20132]},{"content":"The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.","pos":[20136,20259]},{"content":"Because the algorithm copies the source elements in order beginning with the first element, the destination range can overlap with the source range provided the <ph id=\"ph1\">`last`</ph> position of the source range is not contained in the destination range.","pos":[20266,20505],"source":"Because the algorithm copies the source elements in order beginning with the first element, the destination range can overlap with the source range provided the `last` position of the source range is not contained in the destination range."},{"content":"<bpt id=\"p1\">**</bpt>copy<ept id=\"p1\">**</ept> can be used to shift elements to the left but not the right, unless there is no overlap between the source and destination ranges.","pos":[20506,20645],"source":"**copy** can be used to shift elements to the left but not the right, unless there is no overlap between the source and destination ranges."},{"content":"To shift to the right any number of positions, use the <bpt id=\"p1\">[</bpt>copy_backward<ept id=\"p1\">](../standard-library/algorithm-functions.md#copy_backward)</ept> algorithm.","pos":[20646,20785],"source":" To shift to the right any number of positions, use the [copy_backward](../standard-library/algorithm-functions.md#copy_backward) algorithm."},{"content":"The <bpt id=\"p1\">**</bpt>copy<ept id=\"p1\">**</ept> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range.","pos":[20792,20923],"source":"The **copy** algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range."},{"content":"It cannot be used to create new elements and cannot insert elements into an empty container directly.","pos":[20924,21025]},{"content":"Example","pos":[21035,21042]},{"pos":[22600,22613],"content":"copy_backward"},{"content":"Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.","pos":[22617,22799]},{"content":"Parameters","pos":[23057,23067]},{"content":"A bidirectional iterator addressing the position of the first element in the source range.","pos":[23083,23173]},{"content":"A bidirectional iterator addressing the position that is one past the final element in the source range.","pos":[23190,23294]},{"content":"A bidirectional iterator addressing the position of one past the final element in the destination range.","pos":[23314,23418]},{"content":"Return Value","pos":[23428,23440]},{"pos":[23444,23614],"content":"An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <ph id=\"ph1\">`destEnd`</ph> – ( <ph id=\"ph2\">`last`</ph> –  <ph id=\"ph3\">`first`</ph> ).","source":"An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses `destEnd` – ( `last` –  `first` )."},{"content":"Remarks","pos":[23624,23631]},{"content":"The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.","pos":[23635,23758]},{"content":"The <ph id=\"ph1\">`copy_backward`</ph> algorithm imposes more stringent requirements than that the copy algorithm.","pos":[23765,23860],"source":"The `copy_backward` algorithm imposes more stringent requirements than that the copy algorithm."},{"content":"Both its input and output iterators must be bidirectional.","pos":[23861,23919]},{"pos":[23926,24176],"content":"The <ph id=\"ph1\">`copy_backward`</ph> and <bpt id=\"p1\">[</bpt>move_backward<ept id=\"p1\">](../standard-library/algorithm-functions.md#move_backward)</ept> algorithms are the only Standard Template Library algorithms designating the output range with an iterator pointing to the end of the destination range.","source":"The `copy_backward` and [move_backward](../standard-library/algorithm-functions.md#move_backward) algorithms are the only Standard Template Library algorithms designating the output range with an iterator pointing to the end of the destination range."},{"content":"Because the algorithm copies the source elements in order beginning with the last element, the destination range can overlap with the source range provided the  <ph id=\"ph1\">`first`</ph> position of the source range is not contained in the destination range.","pos":[24183,24423],"source":"Because the algorithm copies the source elements in order beginning with the last element, the destination range can overlap with the source range provided the  `first` position of the source range is not contained in the destination range."},{"content":"can be used to shift elements to the right but not the left, unless there is no overlap between the source and destination ranges.","pos":[24440,24570]},{"content":"To shift to the left any number of positions, use the <bpt id=\"p1\">[</bpt>copy<ept id=\"p1\">](../standard-library/algorithm-functions.md#copy)</ept> algorithm.","pos":[24571,24691],"source":" To shift to the left any number of positions, use the [copy](../standard-library/algorithm-functions.md#copy) algorithm."},{"content":"The <ph id=\"ph1\">`copy_backward`</ph> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range.","pos":[24698,24836],"source":"The `copy_backward` algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range."},{"content":"It cannot be used to create new elements and cannot insert elements into an empty container directly.","pos":[24837,24938]},{"content":"Example","pos":[24948,24955]},{"pos":[26336,26343],"content":"copy_if"},{"pos":[26347,26435],"content":"In a range of elements, copies the elements that are <ph id=\"ph1\">`true`</ph> for the specified condition.","source":"In a range of elements, copies the elements that are `true` for the specified condition."},{"content":"Parameters","pos":[26687,26697]},{"content":"An input iterator that indicates the start of a range to check for the condition.","pos":[26713,26794]},{"content":"An input iterator that indicates the end of the range.","pos":[26811,26865]},{"content":"The output iterator that indicates the destination for the copied elements.","pos":[26882,26957]},{"content":"The condition against which every element in the range is tested.","pos":[26975,27040]},{"content":"This condition is provided by a user-defined predicate function object.","pos":[27041,27112]},{"content":"A predicate takes one argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[27113,27174],"source":" A predicate takes one argument and returns `true` or `false`."},{"content":"Return Value","pos":[27184,27196]},{"content":"An output iterator that equals <ph id=\"ph1\">`dest`</ph> incremented once for each element that fulfills the condition.","pos":[27200,27300],"source":"An output iterator that equals `dest` incremented once for each element that fulfills the condition."},{"content":"In other words, the return value minus <ph id=\"ph1\">`dest`</ph> equals the number of copied elements.","pos":[27301,27384],"source":" In other words, the return value minus `dest` equals the number of copied elements."},{"content":"Remarks","pos":[27394,27401]},{"content":"The template function evaluates","pos":[27405,27436]},{"content":"once for each <ph id=\"ph1\">`N`</ph> in the range <ph id=\"ph2\">`[0, last - first)`</ph>, for strictly increasing values of <ph id=\"ph3\">`N`</ph> starting with the lowest value.","pos":[27501,27622],"source":"once for each `N` in the range `[0, last - first)`, for strictly increasing values of `N` starting with the lowest value."},{"content":"If <ph id=\"ph1\">`dest`</ph> and  <ph id=\"ph2\">`first`</ph> designate regions of storage, <ph id=\"ph3\">`dest`</ph> must not be in the range <ph id=\"ph4\">`[`</ph> <ph id=\"ph5\">`first``,`</ph> <ph id=\"ph6\">`last``)`</ph>.","pos":[27623,27733],"source":" If `dest` and  `first` designate regions of storage, `dest` must not be in the range `[` `first``,` `last``)`."},{"pos":[27766,27772],"content":"copy_n"},{"content":"Copies a specified number of elements.","pos":[27776,27814]},{"content":"Parameters","pos":[28015,28025]},{"content":"An input iterator that indicates where to copy elements from.","pos":[28040,28101]},{"content":"A signed or unsigned integer type specifying the number of elements to copy.","pos":[28119,28195]},{"content":"An output iterator that indicates where to copy elements to.","pos":[28212,28272]},{"content":"Return Value","pos":[28282,28294]},{"content":"Returns an output iterator where elements have been copied to.","pos":[28298,28360]},{"content":"It is the same as the returned value of the third parameter, <ph id=\"ph1\">`dest`</ph>.","pos":[28361,28429],"source":" It is the same as the returned value of the third parameter, `dest`."},{"content":"Remarks","pos":[28439,28446]},{"content":"The template function evaluates <ph id=\"ph1\">`*(dest + N) = *(first + N))`</ph> once for each <ph id=\"ph2\">`N`</ph> in the range <ph id=\"ph3\">`[0,`</ph> <ph id=\"ph4\">`count``)`</ph>, for strictly increasing values of <ph id=\"ph5\">`N`</ph> starting with the lowest value.","pos":[28450,28630],"source":"The template function evaluates `*(dest + N) = *(first + N))` once for each `N` in the range `[0,` `count``)`, for strictly increasing values of `N` starting with the lowest value."},{"content":"It then returns <ph id=\"ph1\">`dest`</ph> <ph id=\"ph2\">`+ N`</ph>.","pos":[28631,28660],"source":" It then returns `dest` `+ N`."},{"content":"If <ph id=\"ph1\">`dest`</ph> and <ph id=\"ph2\">`first`</ph> designate regions of storage, <ph id=\"ph3\">`dest`</ph> must not be in the range <ph id=\"ph4\">`[``first``,`</ph> <ph id=\"ph5\">`Last``)`</ph>.","pos":[28661,28769],"source":" If `dest` and `first` designate regions of storage, `dest` must not be in the range `[``first``,` `Last``)`."},{"pos":[28801,28806],"content":"count"},{"content":"Returns the number of elements in a range whose values match a specified value.","pos":[28810,28889]},{"content":"Parameters","pos":[29112,29122]},{"content":"An input iterator addressing the position of the first element in the range to be traversed.","pos":[29138,29230]},{"content":"An input iterator addressing the position one past the final element in the range to be traversed.","pos":[29247,29345]},{"content":"The value of the elements to be counted.","pos":[29361,29401]},{"content":"Return Value","pos":[29411,29423]},{"pos":[29427,29563],"content":"The difference type of the <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept> that counts the number of elements in the range [  <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph> ) that have value <ph id=\"ph3\">`val`</ph>.","source":"The difference type of the **InputIterator** that counts the number of elements in the range [  `first`, `last` ) that have value `val`."},{"content":"Remarks","pos":[29573,29580]},{"pos":[29584,29729],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"pos":[29736,29902],"content":"This algorithm is generalized to count elements that satisfy any predicate with the template function <bpt id=\"p1\">[</bpt>count_if<ept id=\"p1\">](../standard-library/algorithm-functions.md#count_if)</ept>.","source":"This algorithm is generalized to count elements that satisfy any predicate with the template function [count_if](../standard-library/algorithm-functions.md#count_if)."},{"content":"Example","pos":[29912,29919]},{"pos":[30710,30718],"content":"count_if"},{"content":"Returns the number of elements in a range whose values satisfy a specified condition.","pos":[30722,30807]},{"content":"Parameters","pos":[31036,31046]},{"content":"An input iterator addressing the position of the first element in the range to be searched.","pos":[31062,31153]},{"content":"An input iterator addressing the position one past the final element in the range to be searched.","pos":[31170,31267]},{"content":"User-defined predicate function object that defines the condition to be satisfied if an element is to be counted.","pos":[31285,31398]},{"content":"A predicate takes single argument and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","pos":[31399,31467],"source":" A predicate takes single argument and returns **true** or **false**."},{"content":"Return Value","pos":[31477,31489]},{"content":"The number of elements that satisfy the condition specified by the predicate.","pos":[31493,31570]},{"content":"Remarks","pos":[31580,31587]},{"pos":[31591,31779],"content":"This template function is a generalization of the algorithm <bpt id=\"p1\">[</bpt>count<ept id=\"p1\">](../standard-library/algorithm-functions.md#count)</ept>, replacing the predicate \"equals a specific value\" with any predicate.","source":"This template function is a generalization of the algorithm [count](../standard-library/algorithm-functions.md#count), replacing the predicate \"equals a specific value\" with any predicate."},{"content":"Example","pos":[31789,31796]},{"pos":[32715,32720],"content":"equal"},{"content":"Compares two ranges element by element for equality or equivalence in a sense specified by a binary predicate.","pos":[32724,32834]},{"content":"Use <ph id=\"ph1\">`std::equal`</ph> when comparing elements in different container types (for example <ph id=\"ph2\">`vector`</ph> and <ph id=\"ph3\">`list`</ph>) or when comparing different element types, or when you need to compare sub-ranges of containers.","pos":[32841,33041],"source":"Use `std::equal` when comparing elements in different container types (for example `vector` and `list`) or when comparing different element types, or when you need to compare sub-ranges of containers."},{"content":"Otherwise, when comparing elements of the same type in the same container type, use the non-member <ph id=\"ph1\">`operator==`</ph> that is provided for each container.","pos":[33042,33190],"source":" Otherwise, when comparing elements of the same type in the same container type, use the non-member `operator==` that is provided for each container."},{"content":"Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.","pos":[33197,33486]},{"content":"Parameters","pos":[34326,34336]},{"content":"An input iterator addressing the position of the first element in the first range to be tested.","pos":[34352,34447]},{"content":"An input iterator addressing the position one past the last element in the first range to be tested.","pos":[34465,34565]},{"content":"An input iterator addressing the position of the first element in the second range to be tested.","pos":[34584,34680]},{"content":"An input iterator addressing the position of one past the last element in the second range to be tested.","pos":[34699,34803]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[34820,34948]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[34949,35057],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[35067,35079]},{"pos":[35083,35228],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if and only if the ranges are identical or equivalent under the binary predicate when compared element by element; otherwise, <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if and only if the ranges are identical or equivalent under the binary predicate when compared element by element; otherwise, **false**."},{"content":"Remarks","pos":[35238,35245]},{"content":"The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.","pos":[35249,35395]},{"content":"If the two ranges are equal length, then the time complexity of the algorithm is linear in the number of elements contained in the range.","pos":[35402,35539]},{"content":"Otherwise the function immediately returns <ph id=\"ph1\">`false`</ph>.","pos":[35540,35591],"source":" Otherwise the function immediately returns `false`."},{"pos":[35598,35762],"content":"Neither the <ph id=\"ph1\">`operator==`</ph> nor the user-defined predicate is required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.","source":"Neither the `operator==` nor the user-defined predicate is required to impose an equivalence relation that symmetric, reflexive and transitive between its operands."},{"content":"Example","pos":[35772,35779]},{"pos":[36642,36653],"content":"equal_range"},{"content":"Given an ordered range, finds the subrange in which all elements are equivalent to a given value.","pos":[36657,36754]},{"content":"Parameters","pos":[37182,37192]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[37207,37299]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[37316,37414]},{"content":"The value being searched for in the ordered range.","pos":[37430,37480]},{"content":"User-defined predicate function object that defines the sense in which one element is less than another.","pos":[37497,37601]},{"content":"Return Value","pos":[37611,37623]},{"pos":[37627,37862],"content":"A pair of forward iterators that specify a subrange, contained within the range searched, in which all of the elements are equivalent to <ph id=\"ph1\">`val`</ph> in the sense defined by the binary predicate used (either <ph id=\"ph2\">`comp`</ph> or the default, less-than).","source":"A pair of forward iterators that specify a subrange, contained within the range searched, in which all of the elements are equivalent to `val` in the sense defined by the binary predicate used (either `comp` or the default, less-than)."},{"pos":[37869,38065],"content":"If no elements in the range are equivalent to <ph id=\"ph1\">`val`</ph>, the returned pair of forward iterators are equal and specify the point where <ph id=\"ph2\">`val`</ph> could be inserted without disturbing the order of the range.","source":"If no elements in the range are equivalent to `val`, the returned pair of forward iterators are equal and specify the point where `val` could be inserted without disturbing the order of the range."},{"content":"Remarks","pos":[38075,38082]},{"pos":[38086,38314],"content":"The first iterator of the pair returned by the algorithm is <bpt id=\"p1\">[</bpt>lower_bound<ept id=\"p1\">](../standard-library/algorithm-functions.md#lower_bound)</ept>, and the second iterator is <bpt id=\"p2\">[</bpt>upper_bound<ept id=\"p2\">](../standard-library/algorithm-functions.md#upper_bound)</ept>.","source":"The first iterator of the pair returned by the algorithm is [lower_bound](../standard-library/algorithm-functions.md#lower_bound), and the second iterator is [upper_bound](../standard-library/algorithm-functions.md#upper_bound)."},{"content":"The range must be sorted according to the predicate provided to <ph id=\"ph1\">`equal_range`</ph>.","pos":[38321,38399],"source":"The range must be sorted according to the predicate provided to `equal_range`."},{"content":"For example, if you are going to use the greater-than predicate, the range must be sorted in descending order.","pos":[38400,38510]},{"pos":[38517,38687],"content":"Elements in the possibly empty subrange defined by the pair of iterators returned by <ph id=\"ph1\">`equal_range`</ph> will be equivalent to <ph id=\"ph2\">`val`</ph> in the sense defined by the predicate used.","source":"Elements in the possibly empty subrange defined by the pair of iterators returned by `equal_range` will be equivalent to `val` in the sense defined by the predicate used."},{"pos":[38694,38852],"content":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id=\"ph1\">`last`</ph> – <ph id=\"ph2\">`first`</ph>).","source":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last` – `first`)."},{"content":"Example","pos":[38862,38869]},{"pos":[42123,42127],"content":"fill"},{"content":"Assigns the same new value to every element in a specified range.","pos":[42131,42196]},{"content":"Parameters","pos":[42357,42367]},{"content":"A forward iterator addressing the position of the first element in the range to be traversed.","pos":[42383,42476]},{"content":"A forward iterator addressing the position one past the final element in the range to be traversed.","pos":[42493,42592]},{"content":"The value to be assigned to elements in the range [  <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph>).","pos":[42608,42678],"source":" The value to be assigned to elements in the range [  `first`, `last`)."},{"content":"Remarks","pos":[42688,42695]},{"content":"The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation.","pos":[42699,42842]},{"content":"The complexity is linear with the size of the range.","pos":[42843,42895]},{"content":"Example","pos":[42905,42912]},{"pos":[43797,43803],"content":"fill_n"},{"content":"Assigns a new value to a specified number of elements in a range beginning with a particular element.","pos":[43807,43908]},{"content":"Parameters","pos":[44082,44092]},{"content":"An output iterator addressing the position of the first element in the range to be assigned the value <ph id=\"ph1\">`Val`</ph>.","pos":[44107,44215],"source":" An output iterator addressing the position of the first element in the range to be assigned the value `Val`."},{"content":"A signed or unsigned integer type specifying the number of elements to be assigned the value.","pos":[44233,44326]},{"content":"The value to be assigned to elements in the range [ <ph id=\"ph1\">`First`</ph>,          <bpt id=\"p1\">*</bpt>First + Count<ept id=\"p1\">*</ept>).","pos":[44342,44429],"source":" The value to be assigned to elements in the range [ `First`,          *First + Count*)."},{"content":"Return Value","pos":[44439,44451]},{"pos":[44455,44566],"content":"An iterator to the element that follows the last element filled if <ph id=\"ph1\">`Count`</ph> &gt; zero, otherwise the first element.","source":"An iterator to the element that follows the last element filled if `Count` > zero, otherwise the first element."},{"content":"Remarks","pos":[44576,44583]},{"content":"The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation.","pos":[44587,44730]},{"content":"The complexity is linear with the size of the range.","pos":[44731,44783]},{"content":"Example","pos":[44793,44800]},{"pos":[45937,45941],"content":"find"},{"content":"Locates the position of the first occurrence of an element in a range that has a specified value.","pos":[45945,46042]},{"content":"Parameters","pos":[46202,46212]},{"content":"An input iterator addressing the position of the first element in the range to be searched for the specified value.","pos":[46227,46342]},{"content":"An input iterator addressing the position one past the final element in the range to be searched for the specified value.","pos":[46359,46480]},{"content":"The value to be searched for.","pos":[46496,46525]},{"content":"Return Value","pos":[46535,46547]},{"content":"An input iterator addressing the first occurrence of the specified value in the range being searched.","pos":[46551,46652]},{"content":"If no element is found with an equivalent value, returns <ph id=\"ph1\">`last`</ph>.","pos":[46653,46717],"source":" If no element is found with an equivalent value, returns `last`."},{"content":"Remarks","pos":[46727,46734]},{"pos":[46738,46883],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"pos":[46890,46991],"content":"For a code example using <ph id=\"ph1\">`find()`</ph>, see <bpt id=\"p1\">[</bpt>find_if<ept id=\"p1\">](../standard-library/algorithm-functions.md#find_if)</ept>.","source":"For a code example using `find()`, see [find_if](../standard-library/algorithm-functions.md#find_if)."},{"pos":[47026,47034],"content":"find_end"},{"content":"Looks in a range for the last subsequence that is identical to a specified sequence or that is equivalent in a sense specified by a binary predicate.","pos":[47038,47187]},{"content":"Parameters","pos":[47668,47678]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[47694,47786]},{"content":"A forward iterator addressing the position one past the last element in the range to be searched.","pos":[47804,47901]},{"content":"A forward iterator addressing the position of the first element in the range to search for.","pos":[47920,48011]},{"content":"A forward iterator addressing the position one past the last element in the range to search for.","pos":[48029,48125]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[48142,48270]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[48271,48379],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[48389,48401]},{"content":"A forward iterator addressing the position of the first element of the last subsequence within [First1, Last1) that matches the specified sequence [First2, Last2).","pos":[48405,48568]},{"content":"Remarks","pos":[48578,48585]},{"pos":[48589,48734],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.","pos":[48741,48906]},{"content":"Example","pos":[48916,48923]},{"pos":[51586,51599],"content":"find_first_of"},{"content":"Searches for the first occurrence of any of several values within a target range or for the first occurrence of any of several elements that are equivalent in a sense specified by a binary predicate to a specified set of the elements.","pos":[51603,51837]},{"content":"Parameters","pos":[52355,52365]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[52382,52474]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[52492,52590]},{"content":"A forward iterator addressing the position of the first element in the range to be matched.","pos":[52610,52701]},{"content":"A forward iterator addressing the position one past the final element in the range to be matched.","pos":[52719,52816]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[52833,52961]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[52962,53070],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[53080,53092]},{"content":"A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.","pos":[53096,53286]},{"content":"Remarks","pos":[53296,53303]},{"pos":[53307,53452],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.","pos":[53459,53624]},{"content":"Example","pos":[53634,53641]},{"pos":[56407,56414],"content":"find_if"},{"content":"Locates the position of the first occurrence of an element in a range that satisfies a specified condition.","pos":[56418,56525]},{"content":"Parameters","pos":[56696,56706]},{"content":"An input iterator addressing the position of the first element in the range to be searched.","pos":[56721,56812]},{"content":"An input iterator addressing the position one past the final element in the range to be searched.","pos":[56829,56926]},{"content":"User-defined predicate function object or <bpt id=\"p1\">[</bpt>lambda expression<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept> that defines the condition to be satisfied by the element being searched for.","pos":[56943,57119],"source":" User-defined predicate function object or [lambda expression](../cpp/lambda-expressions-in-cpp.md) that defines the condition to be satisfied by the element being searched for."},{"content":"A predicate takes single argument and returns <ph id=\"ph1\">`true`</ph> (satisfied) or <ph id=\"ph2\">`false`</ph> (not satisfied).","pos":[57120,57212],"source":" A predicate takes single argument and returns `true` (satisfied) or `false` (not satisfied)."},{"content":"The signature of <ph id=\"ph1\">`pred`</ph> must effectively be <ph id=\"ph2\">`bool pred(const T&amp; arg);`</ph>, where <ph id=\"ph3\">`T`</ph> is a type to which <ph id=\"ph4\">`InputIterator`</ph> can be implicitly converted when dereferenced.","pos":[57213,57376],"source":" The signature of `pred` must effectively be `bool pred(const T& arg);`, where `T` is a type to which `InputIterator` can be implicitly converted when dereferenced."},{"content":"The <ph id=\"ph1\">`const`</ph> keyword is shown only to illustrate that the function object or lambda should not modify the argument.","pos":[57377,57491],"source":" The `const` keyword is shown only to illustrate that the function object or lambda should not modify the argument."},{"content":"Return Value","pos":[57501,57513]},{"content":"An input iterator that refers to the first element in the range that satisfies the condition specified by the predicate (the predicate results in <ph id=\"ph1\">`true`</ph>).","pos":[57517,57671],"source":"An input iterator that refers to the first element in the range that satisfies the condition specified by the predicate (the predicate results in `true`)."},{"content":"If no element is found to satisfy the predicate, returns <ph id=\"ph1\">`last`</ph>.","pos":[57672,57736],"source":" If no element is found to satisfy the predicate, returns `last`."},{"content":"Remarks","pos":[57746,57753]},{"content":"This template function is a generalization of the algorithm <bpt id=\"p1\">[</bpt>find<ept id=\"p1\">](../standard-library/algorithm-functions.md#find)</ept>, replacing the predicate \"equals a specific value\" with any predicate.","pos":[57757,57943],"source":"This template function is a generalization of the algorithm [find](../standard-library/algorithm-functions.md#find), replacing the predicate \"equals a specific value\" with any predicate."},{"content":"For the logical opposite (find the first element that does not satisfy the predicate), see <bpt id=\"p1\">[</bpt>find_if_not<ept id=\"p1\">](../standard-library/algorithm-functions.md#find_if_not)</ept>.","pos":[57944,58105],"source":" For the logical opposite (find the first element that does not satisfy the predicate), see [find_if_not](../standard-library/algorithm-functions.md#find_if_not)."},{"content":"Example","pos":[58115,58122]},{"pos":[60759,60770],"content":"find_if_not"},{"content":"Returns the first element in the indicated range that does not satisfy a condition.","pos":[60774,60857]},{"content":"Parameters","pos":[61034,61044]},{"content":"An input iterator addressing the position of the first element in the range to be searched.","pos":[61059,61150]},{"content":"An input iterator addressing the position one past the final element in the range to be searched.","pos":[61167,61264]},{"content":"User-defined predicate function object or <bpt id=\"p1\">[</bpt>lambda expression<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept> that defines the condition to be not satisfied by the element being searched for.","pos":[61281,61461],"source":" User-defined predicate function object or [lambda expression](../cpp/lambda-expressions-in-cpp.md) that defines the condition to be not satisfied by the element being searched for."},{"content":"A predicate takes single argument and returns <ph id=\"ph1\">`true`</ph> (satisfied) or <ph id=\"ph2\">`false`</ph> (not satisfied).","pos":[61462,61554],"source":" A predicate takes single argument and returns `true` (satisfied) or `false` (not satisfied)."},{"content":"The signature of <ph id=\"ph1\">`pred`</ph> must effectively be <ph id=\"ph2\">`bool pred(const T&amp; arg);`</ph>, where <ph id=\"ph3\">`T`</ph> is a type to which <ph id=\"ph4\">`InputIterator`</ph> can be implicitly converted when dereferenced.","pos":[61555,61718],"source":" The signature of `pred` must effectively be `bool pred(const T& arg);`, where `T` is a type to which `InputIterator` can be implicitly converted when dereferenced."},{"content":"The <ph id=\"ph1\">`const`</ph> keyword is shown only to illustrate that the function object or lambda should not modify the argument.","pos":[61719,61833],"source":" The `const` keyword is shown only to illustrate that the function object or lambda should not modify the argument."},{"content":"Return Value","pos":[61843,61855]},{"content":"An input iterator that refers to the first element in the range that does not satisfy the condition specified by the predicate (the predicate results in <ph id=\"ph1\">`false`</ph>).","pos":[61859,62021],"source":"An input iterator that refers to the first element in the range that does not satisfy the condition specified by the predicate (the predicate results in `false`)."},{"content":"If all elements satisfy the predicate (the predicate results in <ph id=\"ph1\">`true`</ph> for every element), returns <ph id=\"ph2\">`last`</ph>.","pos":[62022,62128],"source":" If all elements satisfy the predicate (the predicate results in `true` for every element), returns `last`."},{"content":"Remarks","pos":[62138,62145]},{"content":"This template function is a generalization of the algorithm <bpt id=\"p1\">[</bpt>find<ept id=\"p1\">](../standard-library/algorithm-functions.md#find)</ept>, replacing the predicate \"equals a specific value\" with any predicate.","pos":[62149,62335],"source":"This template function is a generalization of the algorithm [find](../standard-library/algorithm-functions.md#find), replacing the predicate \"equals a specific value\" with any predicate."},{"content":"For the logical opposite (find the first element that does satisfy the predicate), see <bpt id=\"p1\">[</bpt>find_if<ept id=\"p1\">](../standard-library/algorithm-functions.md#find_if)</ept>.","pos":[62336,62485],"source":" For the logical opposite (find the first element that does satisfy the predicate), see [find_if](../standard-library/algorithm-functions.md#find_if)."},{"pos":[62492,62615],"content":"For a code example readily adaptable to <ph id=\"ph1\">`find_if_not()`</ph>, see <bpt id=\"p1\">[</bpt>find_if<ept id=\"p1\">](../standard-library/algorithm-functions.md#find_if)</ept>.","source":"For a code example readily adaptable to `find_if_not()`, see [find_if](../standard-library/algorithm-functions.md#find_if)."},{"pos":[62650,62658],"content":"for_each"},{"content":"Applies a specified function object to each element in a forward order within a range and returns the function object.","pos":[62662,62780]},{"content":"Parameters","pos":[62946,62956]},{"content":"An input iterator addressing the position of the first element in the range to be operated on.","pos":[62972,63066]},{"content":"An input iterator addressing the position one past the final element in the range operated on.","pos":[63083,63177]},{"content":"User-defined function object that is applied to each element in the range.","pos":[63195,63269]},{"content":"Return Value","pos":[63279,63291]},{"content":"A copy of the function object after it has been applied to all of the elements in the range.","pos":[63295,63387]},{"content":"Remarks","pos":[63397,63404]},{"content":"The algorithm <ph id=\"ph1\">`for_each`</ph> is very flexible, allowing the modification of each element within a range in different, user-specified ways.","pos":[63408,63542],"source":"The algorithm `for_each` is very flexible, allowing the modification of each element within a range in different, user-specified ways."},{"content":"Templatized functions may be reused in a modified form by passing different parameters.","pos":[63543,63630]},{"content":"User-defined functions may accumulate information within an internal state that the algorithm may return after processing all of the elements in the range.","pos":[63631,63786]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.","pos":[63793,63961]},{"pos":[63968,64039],"content":"The complexity is linear with at most ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons.","source":"The complexity is linear with at most ( `last` –  `first`) comparisons."},{"content":"Example","pos":[64049,64056]},{"pos":[67260,67268],"content":"generate"},{"content":"Assigns the values generated by a function object to each element in a range.","pos":[67272,67349]},{"content":"Parameters","pos":[67518,67528]},{"content":"A forward iterator addressing the position of the first element in the range to which values are to be assigned.","pos":[67544,67656]},{"content":"A forward iterator addressing the position one past the final element in the range to which values are to be assigned.","pos":[67673,67791]},{"content":"A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.","pos":[67808,67947]},{"content":"Remarks","pos":[67957,67964]},{"content":"The function object is invoked for each element in the range and does not need to return the same value each time it is called.","pos":[67968,68095]},{"content":"It may, for example, read from a file or refer to and modify a local state.","pos":[68096,68171]},{"content":"The generator's result type must be convertible to the value type of the forward iterators for the range.","pos":[68172,68277]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.","pos":[68284,68452]},{"pos":[68459,68557],"content":"The complexity is linear, with exactly ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) calls to the generator being required.","source":"The complexity is linear, with exactly ( `last` –  `first`) calls to the generator being required."},{"content":"Example","pos":[68567,68574]},{"pos":[69639,69649],"content":"generate_n"},{"content":"Assigns the values generated by a function object to a specified number of elements in a range and returns to the position one past the last assigned value.","pos":[69653,69809]},{"content":"Parameters","pos":[69980,69990]},{"content":"An output iterator addressing the position of first element in the range to which values are to be assigned.","pos":[70005,70113]},{"content":"A signed or unsigned integer type specifying the number of elements to be assigned a value by the generator function.","pos":[70131,70248]},{"content":"A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.","pos":[70264,70403]},{"content":"Remarks","pos":[70413,70420]},{"content":"The function object is invoked for each element in the range and does not need to return the same value each time it is called.","pos":[70424,70551]},{"content":"It may, for example, read from a file or refer to and modify a local state.","pos":[70552,70627]},{"content":"The generator's result type must be convertible to the value type of the forward iterators for the range.","pos":[70628,70733]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.","pos":[70740,70908]},{"pos":[70915,71000],"content":"The complexity is linear, with exactly <ph id=\"ph1\">`Count`</ph> calls to the generator being required.","source":"The complexity is linear, with exactly `Count` calls to the generator being required."},{"content":"Example","pos":[71010,71017]},{"pos":[71989,71997],"content":"includes"},{"content":"Tests whether one sorted range contains all the elements contained in a second sorted range, where the ordering or equivalence criterion between elements may be specified by a binary predicate.","pos":[72001,72194]},{"content":"Parameters","pos":[72648,72658]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.","pos":[72675,72862]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.","pos":[72880,73072]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.","pos":[73092,73288]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.","pos":[73306,73507]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[73524,73624]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[73625,73733],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[73743,73755]},{"pos":[73759,73869],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the first sorted range contains all the elements in the second sorted range; otherwise, <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the first sorted range contains all the elements in the second sorted range; otherwise, **false**."},{"content":"Remarks","pos":[73879,73886]},{"content":"Another way to think of this test is that it determined whether the second source range is a subset of the first source range.","pos":[73890,74016]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.","pos":[74023,74207]},{"content":"The sorted source ranges must each be arranged as a precondition to the application of the algorithm includes in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","pos":[74214,74423]},{"pos":[74430,74492],"content":"The source ranges are not modified by the algorithm <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept>.","source":"The source ranges are not modified by the algorithm **merge**."},{"content":"The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[74499,74750]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[74751,74814]},{"content":"More precisely, the algorithm tests whether all the elements in the first sorted range under a specified binary predicate have equivalent ordering to those in the second sorted range.","pos":[74815,74998]},{"pos":[75005,75155],"content":"The complexity of the algorithm is linear with at most 2 <ph id=\"ph1\">\\*</ph> ( ( <bpt id=\"p1\">*</bpt>last1 – first1<ept id=\"p1\">*</ept>) – ( <bpt id=\"p2\">*</bpt> last2 – first2<ept id=\"p2\">*</ept>) ) – 1 comparisons for nonempty source ranges.","source":"The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( * last2 – first2*) ) – 1 comparisons for nonempty source ranges."},{"content":"Example","pos":[75165,75172]},{"pos":[80608,80621],"content":"inplace_merge"},{"content":"Combines the elements from two consecutive sorted ranges into a single sorted range, where the ordering criterion may be specified by a binary predicate.","pos":[80625,80778]},{"content":"Parameters","pos":[81187,81197]},{"content":"A bidirectional iterator addressing the position of the first element in the first of two consecutive sorted ranges to be combined and sorted into a single range.","pos":[81213,81375]},{"content":"A bidirectional iterator addressing the position of the first element in the second of two consecutive sorted ranges to be combined and sorted into a single range.","pos":[81394,81557]},{"content":"A bidirectional iterator addressing the position one past the last element in the second of two consecutive sorted ranges to be combined and sorted into a single range.","pos":[81574,81742]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[81759,81866]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[81867,82014],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Remarks","pos":[82024,82031]},{"content":"The sorted consecutive ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.","pos":[82035,82224]},{"content":"The sorted consecutive ranges must each be arranged as a precondition to the application of the <ph id=\"ph1\">`inplace_merge`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","pos":[82231,82452],"source":"The sorted consecutive ranges must each be arranged as a precondition to the application of the `inplace_merge` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"content":"The operation is stable as the relative order of elements within each range is preserved.","pos":[82453,82542]},{"content":"When there are equivalent elements in both source ranges, the element is the first range precedes the element from the second in the combined range.","pos":[82543,82691]},{"content":"The complexity depends on the available memory as the algorithm allocates memory to a temporary buffer.","pos":[82698,82801]},{"content":"If sufficient memory is available, the best case is linear with ( <bpt id=\"p1\">*</bpt> last – first<ept id=\"p1\">*</ept>) – 1 comparisons; if no auxiliary memory is available, the worst case is  <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept> log <bpt id=\"p3\">*</bpt>(N)<ept id=\"p3\">*</ept>, where  <bpt id=\"p4\">*</bpt>N<ept id=\"p4\">*</ept> = ( <bpt id=\"p5\">*</bpt> last – first<ept id=\"p5\">*</ept>).","pos":[82802,83005],"source":" If sufficient memory is available, the best case is linear with ( * last – first*) – 1 comparisons; if no auxiliary memory is available, the worst case is  *N* log *(N)*, where  *N* = ( * last – first*)."},{"content":"Example","pos":[83015,83022]},{"pos":[86974,86981],"content":"is_heap"},{"pos":[86985,87051],"content":"Returns <ph id=\"ph1\">`true`</ph> if the elements in the specified range form a heap.","source":"Returns `true` if the elements in the specified range form a heap."},{"content":"Parameters","pos":[87375,87385]},{"content":"A random access iterator that indicates the start of a range to check for a heap.","pos":[87401,87482]},{"content":"A random access iterator that indicates the end of a range.","pos":[87499,87558]},{"content":"A condition to test to order elements.","pos":[87575,87613]},{"content":"A binary predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph>or <ph id=\"ph2\">`false`</ph>.","pos":[87614,87686],"source":" A binary predicate takes a single argument and returns `true`or `false`."},{"content":"Return Value","pos":[87696,87708]},{"pos":[87712,87802],"content":"Returns <ph id=\"ph1\">`true`</ph> if the elements in the specified range form a heap, <ph id=\"ph2\">`false`</ph> if they do not.","source":"Returns `true` if the elements in the specified range form a heap, `false` if they do not."},{"content":"Remarks","pos":[87812,87819]},{"pos":[87823,87967],"content":"The first template function returns <bpt id=\"p1\">[</bpt>is_heap_until<ept id=\"p1\">](../standard-library/algorithm-functions.md#is_heap_until)</ept><ph id=\"ph1\">`(`</ph> <ph id=\"ph2\">`first``,`</ph> <ph id=\"ph3\">`last``) ==`</ph> <ph id=\"ph4\">`last`</ph>.","source":"The first template function returns [is_heap_until](../standard-library/algorithm-functions.md#is_heap_until)`(` `first``,` `last``) ==` `last`."},{"content":"The second template function returns","pos":[87974,88010]},{"pos":[88084,88085],"content":"."},{"pos":[88125,88138],"content":"is_heap_until"},{"pos":[88142,88311],"content":"Returns an iterator positioned at the first element in the range [ <ph id=\"ph1\">`begin`</ph>, <ph id=\"ph2\">`end`</ph>) that does not satisfy the heap ordering condition, or <ph id=\"ph3\">`end`</ph> if the range forms a heap.","source":"Returns an iterator positioned at the first element in the range [ `begin`, `end`) that does not satisfy the heap ordering condition, or `end` if the range forms a heap."},{"content":"Parameters","pos":[88687,88697]},{"content":"A random access iterator that specifies the first element of a range to check for a heap.","pos":[88712,88801]},{"content":"A random access iterator that specifies the end of the range to check for a heap.","pos":[88817,88898]},{"content":"A binary predicate that specifies the strict weak ordering condition that defines a heap.","pos":[88918,89007]},{"content":"The default predicate when <ph id=\"ph1\">`compare`</ph> is not specified is <ph id=\"ph2\">`std::less&lt;&gt;`</ph>.","pos":[89008,89079],"source":" The default predicate when `compare` is not specified is `std::less<>`."},{"content":"Return Value","pos":[89089,89101]},{"content":"Returns <ph id=\"ph1\">`end`</ph> if the specified range forms a heap or contains one or fewer elements.","pos":[89105,89189],"source":"Returns `end` if the specified range forms a heap or contains one or fewer elements."},{"content":"Otherwise, returns an iterator for the first element found that does not satisfy the heap condition.","pos":[89190,89290]},{"content":"Remarks","pos":[89300,89307]},{"content":"The first template function returns the last iterator <ph id=\"ph1\">`next`</ph> in <ph id=\"ph2\">`[``begin``,`</ph> <ph id=\"ph3\">`end``]`</ph> where <ph id=\"ph4\">`[``begin``, next)`</ph> is a heap ordered by the function object <ph id=\"ph5\">`std::less&lt;&gt;`</ph>.","pos":[89311,89479],"source":"The first template function returns the last iterator `next` in `[``begin``,` `end``]` where `[``begin``, next)` is a heap ordered by the function object `std::less<>`."},{"content":"If the distance <ph id=\"ph1\">`end`</ph> <ph id=\"ph2\">`-`</ph> <ph id=\"ph3\">`begin`</ph> <ph id=\"ph4\">`&lt; 2`</ph>, the function returns <ph id=\"ph5\">`end`</ph>.","pos":[89480,89548],"source":" If the distance `end` `-` `begin` `< 2`, the function returns `end`."},{"pos":[89555,89715],"content":"The second template function behaves the same as the first, except that it uses the predicate <ph id=\"ph1\">`compare`</ph> instead of <ph id=\"ph2\">`std::less&lt;&gt;`</ph> as the heap ordering condition.","source":"The second template function behaves the same as the first, except that it uses the predicate `compare` instead of `std::less<>` as the heap ordering condition."},{"pos":[89756,89770],"content":"is_partitioned"},{"pos":[89774,89904],"content":"Returns <ph id=\"ph1\">`true`</ph> if all the elements in the given range that test <ph id=\"ph2\">`true`</ph> for a condition come before any elements that test <ph id=\"ph3\">`false`</ph>.","source":"Returns `true` if all the elements in the given range that test `true` for a condition come before any elements that test `false`."},{"content":"Parameters","pos":[90090,90100]},{"content":"An input iterator that indicates where a range starts to check for a condition.","pos":[90116,90195]},{"content":"An input iterator that indicates the end of a range.","pos":[90212,90264]},{"content":"The condition to test for.","pos":[90281,90307]},{"content":"This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for.","pos":[90308,90446]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph>or <ph id=\"ph2\">`false`</ph>.","pos":[90447,90512],"source":" A predicate takes a single argument and returns `true`or `false`."},{"content":"Return Value","pos":[90522,90534]},{"pos":[90538,90702],"content":"Returns true when all of the elements in the given range that test <ph id=\"ph1\">`true`</ph> for a condition come before any elements that test <ph id=\"ph2\">`false`</ph>, and otherwise returns <ph id=\"ph3\">`false`</ph>.","source":"Returns true when all of the elements in the given range that test `true` for a condition come before any elements that test `false`, and otherwise returns `false`."},{"content":"Remarks","pos":[90712,90719]},{"pos":[90723,90983],"content":"The template function returns <ph id=\"ph1\">`true`</ph> only if all elements in <ph id=\"ph2\">`[`</ph> <ph id=\"ph3\">`first``,`</ph> <ph id=\"ph4\">`last``)`</ph> are partitioned by <ph id=\"ph5\">`comp`</ph>; that is, all elements <ph id=\"ph6\">`X`</ph> in <ph id=\"ph7\">`[`</ph> <ph id=\"ph8\">`first``,`</ph> <ph id=\"ph9\">`last``)`</ph> for which <ph id=\"ph10\">`comp``(X)`</ph> is true occur before all elements <ph id=\"ph11\">`Y`</ph> for which <ph id=\"ph12\">`comp``(Y)`</ph> is <ph id=\"ph13\">`false`</ph>.","source":"The template function returns `true` only if all elements in `[` `first``,` `last``)` are partitioned by `comp`; that is, all elements `X` in `[` `first``,` `last``)` for which `comp``(X)` is true occur before all elements `Y` for which `comp``(Y)` is `false`."},{"pos":[91024,91038],"content":"is_permutation"},{"content":"Returns true if both ranges contain the same elements, whether or not the elements are in the same order.","pos":[91042,91147]},{"content":"Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.","pos":[91148,91437]},{"content":"Parameters","pos":[92288,92298]},{"content":"A forward iterator that refers to the first element of the range.","pos":[92314,92379]},{"content":"A forward iterator that refers one past the last element of the range.","pos":[92397,92467]},{"content":"A forward iterator that refers to the first element of a second range, used for comparison.","pos":[92486,92577]},{"content":"A forward iterator that refers to one past the last element of a second range, used for comparison.","pos":[92595,92694]},{"content":"A predicate that tests for equivalence and returns a <ph id=\"ph1\">`bool`</ph>.","pos":[92711,92771],"source":" A predicate that tests for equivalence and returns a `bool`."},{"content":"Return Value","pos":[92781,92793]},{"pos":[92804,92918],"content":"when the ranges can be rearranged so as to be identical according to the comparator predicate; otherwise, <ph id=\"ph1\">`false`</ph>.","source":" when the ranges can be rearranged so as to be identical according to the comparator predicate; otherwise, `false`."},{"content":"Remarks","pos":[92928,92935]},{"pos":[92956,92999],"content":"has quadratic complexity in the worst case."},{"content":"The first template function assumes that there are as many elements in the range beginning at <ph id=\"ph1\">`First2`</ph> as there are in the range designated by [ <ph id=\"ph2\">`First1`</ph>, <ph id=\"ph3\">`Last1`</ph>).","pos":[93006,93170],"source":"The first template function assumes that there are as many elements in the range beginning at `First2` as there are in the range designated by [ `First1`, `Last1`)."},{"content":"If there are more elements in the second range, they are ignored; if there are less, undefined behavior will occur.","pos":[93171,93286]},{"content":"The third template function (C++14 and later) does not make this assumption.","pos":[93287,93363]},{"content":"Both return <ph id=\"ph1\">`true`</ph> only if, for each element X in the range designated by [ <ph id=\"ph2\">`First1`</ph>, <ph id=\"ph3\">`Last1`</ph>) there are as many elements Y in the same range for which X == Y as there are in the range beginning at <ph id=\"ph4\">`First2`</ph> or [ <ph id=\"ph5\">`First2, Last2).`</ph> Here, <ph id=\"ph6\">`operator==`</ph> must perform a pairwise comparison between its operands.","pos":[93365,93670],"source":"  Both return `true` only if, for each element X in the range designated by [ `First1`, `Last1`) there are as many elements Y in the same range for which X == Y as there are in the range beginning at `First2` or [ `First2, Last2).` Here, `operator==` must perform a pairwise comparison between its operands."},{"content":"The second and fourth template functions behave the same, except that they replace <ph id=\"ph1\">`operator==(X, Y)`</ph> with <ph id=\"ph2\">`Pred(X, Y)`</ph>.","pos":[93677,93797],"source":"The second and fourth template functions behave the same, except that they replace `operator==(X, Y)` with `Pred(X, Y)`."},{"content":"To behave correctly, the predicate must be symmetric, reflexive and transitive.","pos":[93798,93877]},{"content":"Example","pos":[93887,93894]},{"pos":[93899,93955],"content":"The following example shows how to use <ph id=\"ph1\">`is_permutation`</ph>:","source":"The following example shows how to use `is_permutation`:"},{"pos":[95747,95756],"content":"is_sorted"},{"pos":[95760,95834],"content":"Returns <ph id=\"ph1\">`true`</ph> if the elements in the specified range are in sorted order.","source":"Returns `true` if the elements in the specified range are in sorted order."},{"content":"Parameters","pos":[96132,96142]},{"content":"A forward iterator that indicates where the range to check begins.","pos":[96158,96224]},{"content":"A forward iterator that indicates the end of a range.","pos":[96241,96294]},{"content":"The condition to test to determine an order between two elements.","pos":[96311,96376]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[96377,96443],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"This performs the same task as <ph id=\"ph1\">`operator&lt;`</ph>.","pos":[96444,96487],"source":" This performs the same task as `operator<`."},{"content":"Remarks","pos":[96497,96504]},{"content":"The first template function returns <bpt id=\"p1\">[</bpt>is_sorted_until<ept id=\"p1\">](http://msdn.microsoft.com/en-us/bbad99d0-deaa-4fe6-ae58-eb5b3e4dded0)</ept><ph id=\"ph1\">`(`</ph> <ph id=\"ph2\">`first``,`</ph> <ph id=\"ph3\">`last``) ==`</ph> <ph id=\"ph4\">`last`</ph>.","pos":[96508,96666],"source":"The first template function returns [is_sorted_until](http://msdn.microsoft.com/en-us/bbad99d0-deaa-4fe6-ae58-eb5b3e4dded0)`(` `first``,` `last``) ==` `last`."},{"content":"The operator&lt; function performs the order comparison.","pos":[96667,96720],"source":" The operator< function performs the order comparison."},{"content":"The second template function returns <ph id=\"ph1\">`is_sorted_until``(`</ph> <ph id=\"ph2\">`first``,`</ph> <ph id=\"ph3\">`last``,`</ph> <ph id=\"ph4\">`comp``) ==`</ph> <ph id=\"ph5\">`last`</ph>.","pos":[96727,96826],"source":"The second template function returns `is_sorted_until``(` `first``,` `last``,` `comp``) ==` `last`."},{"content":"The <ph id=\"ph1\">`comp`</ph> predicate function performs the order comparison.","pos":[96827,96887],"source":" The `comp` predicate function performs the order comparison."},{"pos":[96929,96944],"content":"is_sorted_until"},{"pos":[96948,97055],"content":"Returns a <ph id=\"ph1\">`ForwardIterator`</ph> that is set to the last element that is in sorted order from a specified range.","source":"Returns a `ForwardIterator` that is set to the last element that is in sorted order from a specified range."},{"pos":[97062,97214],"content":"The second version lets you provide a <ph id=\"ph1\">`BinaryPredicate`</ph> function that returns <ph id=\"ph2\">`true`</ph> when two given elements are in sorted order, and <ph id=\"ph3\">`false`</ph> otherwise.","source":"The second version lets you provide a `BinaryPredicate` function that returns `true` when two given elements are in sorted order, and `false` otherwise."},{"content":"Parameters","pos":[97589,97599]},{"content":"A forward iterator that indicates where the range to check starts.","pos":[97615,97681]},{"content":"A forward iterator that indicates the end of a range.","pos":[97698,97751]},{"content":"The condition to test to determine an order between two elements.","pos":[97768,97833]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[97834,97900],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Return Value","pos":[97910,97922]},{"content":"Returns a <ph id=\"ph1\">`ForwardIterator`</ph> set to the last element in sorted order.","pos":[97926,97994],"source":"Returns a `ForwardIterator` set to the last element in sorted order."},{"content":"The sorted sequence starts from  <ph id=\"ph1\">`first`</ph>.","pos":[97995,98036],"source":" The sorted sequence starts from  `first`."},{"content":"Remarks","pos":[98046,98053]},{"content":"The first template function returns the last iterator <ph id=\"ph1\">`next`</ph> in <ph id=\"ph2\">`[`</ph> <ph id=\"ph3\">`first``,`</ph> <ph id=\"ph4\">`last``]`</ph> so that <ph id=\"ph5\">`[`</ph> <ph id=\"ph6\">`first``, next)`</ph> is a sorted sequence ordered by <ph id=\"ph7\">`operator&lt;`</ph>.","pos":[98057,98219],"source":"The first template function returns the last iterator `next` in `[` `first``,` `last``]` so that `[` `first``, next)` is a sorted sequence ordered by `operator<`."},{"content":"If <ph id=\"ph1\">`distance()`</ph> <ph id=\"ph2\">`&lt; 2`</ph> the function returns <ph id=\"ph3\">`last`</ph>.","pos":[98220,98270],"source":" If `distance()` `< 2` the function returns `last`."},{"pos":[98277,98386],"content":"The second template function behaves the same, except that it replaces <ph id=\"ph1\">`operator&lt;(X, Y)`</ph> with <ph id=\"ph2\">`comp``(X, Y)`</ph>.","source":"The second template function behaves the same, except that it replaces `operator<(X, Y)` with `comp``(X, Y)`."},{"pos":[98422,98431],"content":"iter_swap"},{"content":"Exchanges two values referred to by a pair of specified iterators.","pos":[98435,98501]},{"content":"Parameters","pos":[98655,98665]},{"content":"One of the forward iterators whose value is to be exchanged.","pos":[98679,98739]},{"content":"The second of the forward iterators whose value is to be exchanged.","pos":[98757,98824]},{"content":"Remarks","pos":[98834,98841]},{"content":"should be used in preference to i <bpt id=\"p1\">**</bpt>ter_swap<ept id=\"p1\">**</ept>, which was included in the C++ Standard for backward compatibility.","pos":[98852,98966],"source":" should be used in preference to i **ter_swap**, which was included in the C++ Standard for backward compatibility."},{"content":"If <ph id=\"ph1\">`Fit1`</ph> and <ph id=\"ph2\">`Fit2`</ph> are forward iterators, then <ph id=\"ph3\">`iter_swap`</ph> ( <ph id=\"ph4\">`Fit1`</ph>, <ph id=\"ph5\">`Fit2`</ph> ), is equivalent to <ph id=\"ph6\">`swap`</ph> ( * <ph id=\"ph7\">`Fit1`</ph>, <ph id=\"ph8\">\\*</ph> <ph id=\"ph9\">`Fit2`</ph> ).","pos":[98967,99096],"source":" If `Fit1` and `Fit2` are forward iterators, then `iter_swap` ( `Fit1`, `Fit2` ), is equivalent to `swap` ( * `Fit1`, \\* `Fit2` )."},{"content":"The value types of the input forward iterators must have the same value.","pos":[99103,99175]},{"content":"Example","pos":[99185,99192]},{"pos":[103102,103125],"content":"lexicographical_compare"},{"content":"Compares element by element between two sequences to determine which is lesser of the two.","pos":[103129,103219]},{"content":"Parameters","pos":[103724,103734]},{"content":"An input iterator addressing the position of the first element in the first range to be compared.","pos":[103751,103848]},{"content":"An input iterator addressing the position one past the final element in the first range to be compared.","pos":[103866,103969]},{"content":"An input iterator addressing the position of the first element in the second range to be compared.","pos":[103989,104087]},{"content":"An input iterator addressing the position one past the final element in the second range to be compared.","pos":[104105,104209]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[104226,104326]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[104327,104435],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[104445,104457]},{"pos":[104461,104558],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the first range is lexicographically less than the second range; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the first range is lexicographically less than the second range; otherwise **false**."},{"content":"Remarks","pos":[104568,104575]},{"content":"A lexicographical comparison between sequences compares them element by element until:","pos":[104579,104665]},{"content":"It finds two corresponding elements unequal, and the result of their comparison is taken as the result of the comparison between sequences.","pos":[104675,104814]},{"content":"No inequalities are found, but one sequence has more elements than the other, and the shorter sequence is considered less than the longer sequence.","pos":[104824,104971]},{"content":"No inequalities are found and the sequences have the same number of elements, and so the sequences are equal and the result of the comparison is false.","pos":[104981,105132]},{"content":"Example","pos":[105142,105149]},{"pos":[107830,107841],"content":"lower_bound"},{"content":"Finds the position of the first element in an ordered range that has a value greater than or equivalent to a specified value, where the ordering criterion may be specified by a binary predicate.","pos":[107845,108039]},{"content":"Parameters","pos":[108453,108463]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[108478,108570]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[108587,108685]},{"content":"The value whose first position or possible first position is being searched for in the ordered range.","pos":[108703,108804]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[108821,108921]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[108922,109030],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[109040,109052]},{"content":"A forward iterator at the position of the first element in an ordered range with a value that is greater than or equivalent to a specified value, where the equivalence is specified with a binary predicate.","pos":[109056,109261]},{"content":"Remarks","pos":[109271,109278]},{"content":"The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.","pos":[109282,109463]},{"pos":[109470,109599],"content":"A sorted range is a precondition of using <ph id=\"ph1\">`lower_bound`</ph> and where the ordering is the same as specified by with binary predicate.","source":"A sorted range is a precondition of using `lower_bound` and where the ordering is the same as specified by with binary predicate."},{"pos":[109606,109663],"content":"The range is not modified by the algorithm <ph id=\"ph1\">`lower_bound`</ph>.","source":"The range is not modified by the algorithm `lower_bound`."},{"content":"The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[109670,109923]},{"content":"This results in an ordering between the nonequivalent elements","pos":[109924,109986]},{"pos":[109993,110149],"content":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id=\"ph1\">`last – first`</ph>).","source":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last – first`)."},{"content":"Example","pos":[110159,110166]},{"pos":[112885,112894],"content":"make_heap"},{"content":"Converts elements from a specified range into a heap in which the first element is the largest and for which a sorting criterion may be specified with a binary predicate.","pos":[112898,113068]},{"content":"Parameters","pos":[113411,113421]},{"content":"A random-access iterator addressing the position of the first element in the range to be converted into a heap.","pos":[113437,113548]},{"content":"A random-access iterator addressing the position one past the final element in the range to be converted into a heap.","pos":[113565,113682]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[113699,113799]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[113800,113908],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[113918,113925]},{"content":"Heaps have two properties:","pos":[113929,113955]},{"content":"The first element is always the largest.","pos":[113965,114005]},{"content":"Elements may be added or removed in logarithmic time.","pos":[114015,114068]},{"pos":[114075,114286],"content":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id=\"p1\">[</bpt>priority_queue Class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept>.","source":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md)."},{"pos":[114293,114365],"content":"The complexity is linear, requiring 3 <ph id=\"ph1\">\\*</ph> ( <bpt id=\"p1\">*</bpt> last – first<ept id=\"p1\">*</ept>) comparisons.","source":"The complexity is linear, requiring 3 \\* ( * last – first*) comparisons."},{"content":"Example","pos":[114375,114382]},{"pos":[115541,115544],"content":"max"},{"content":"Compares two objects and returns the larger of the two, where the ordering criterion may be specified by a binary predicate.","pos":[115548,115672]},{"content":"Parameters","pos":[116187,116197]},{"content":"The first of the two objects being compared.","pos":[116211,116255]},{"content":"The second of the two objects being compared.","pos":[116273,116318]},{"content":"A binary predicate used to compare the two objects.","pos":[116335,116386]},{"content":"The initializer list that contains the objects to be compared.","pos":[116405,116467]},{"content":"Return Value","pos":[116477,116489]},{"content":"The greater of the two objects, unless neither is greater; in that case, it returns the first of the two objects.","pos":[116493,116606]},{"content":"In the case of an initializer_list, it returns the greatest of the objects in the list.","pos":[116607,116694]},{"content":"Remarks","pos":[116704,116711]},{"content":"The <ph id=\"ph1\">`max`</ph> algorithm is unusual in having objects passed as parameters.","pos":[116715,116785],"source":"The `max` algorithm is unusual in having objects passed as parameters."},{"content":"Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters.","pos":[116786,116921]},{"content":"If you need a function that operates on a range of elements, use <bpt id=\"p1\">[</bpt>max_element<ept id=\"p1\">](../standard-library/algorithm-functions.md#max_element)</ept> instead.","pos":[116922,117065],"source":" If you need a function that operates on a range of elements, use [max_element](../standard-library/algorithm-functions.md#max_element) instead."},{"content":"Example","pos":[117075,117082]},{"pos":[121935,121946],"content":"max_element"},{"content":"Finds the first occurrence of largest element in a specified range where the ordering criterion may be specified by a binary predicate.","pos":[121950,122085]},{"content":"Parameters","pos":[122383,122393]},{"content":"A forward iterator addressing the position of the first element in the range to be searched for the largest element.","pos":[122409,122525]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched for the largest element.","pos":[122542,122664]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[122681,122788]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[122789,122936],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[122946,122958]},{"content":"A forward iterator addressing the position of the first occurrence of the largest element in the range searched.","pos":[122962,123074]},{"content":"Remarks","pos":[123084,123091]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.","pos":[123095,123257]},{"pos":[123264,123361],"content":"The complexity is linear: ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) – 1 comparisons are required for a nonempty range.","source":"The complexity is linear: ( `last` –  `first`) – 1 comparisons are required for a nonempty range."},{"content":"Example","pos":[123371,123378]},{"pos":[126048,126053],"content":"merge"},{"content":"Combines all of the elements from two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.","pos":[126057,126225]},{"content":"Parameters","pos":[126822,126832]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be combined and sorted into a single range.","pos":[126849,126999]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be combined and sorted into a single range.","pos":[127017,127172]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be combined and sorted into a single range.","pos":[127192,127351]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be combined and sorted into a single range.","pos":[127369,127533]},{"content":"An output iterator addressing the position of the first element in the destination range where the two source ranges are to be combined into a single sorted range.","pos":[127552,127715]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[127732,127839]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[127840,127987],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[127997,128009]},{"content":"An output iterator addressing the position one past the last element in the sorted destination range.","pos":[128013,128114]},{"content":"Remarks","pos":[128124,128131]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[128135,128317]},{"content":"The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.","pos":[128324,128453]},{"pos":[128460,128670],"content":"The sorted source ranges must each be arranged as a precondition to the application of the <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","source":"The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"content":"The operation is stable as the relative order of elements within each range is preserved in the destination range.","pos":[128677,128791]},{"content":"The source ranges are not modified by the algorithm <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept>.","pos":[128792,128854],"source":" The source ranges are not modified by the algorithm **merge**."},{"content":"The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[128861,129112]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[129113,129176]},{"content":"When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.","pos":[129177,129342]},{"pos":[129349,129464],"content":"The complexity of the algorithm is linear with at most ( <bpt id=\"p1\">*</bpt> last1 – first1<ept id=\"p1\">*</ept>) – ( <bpt id=\"p2\">*</bpt> last2 – first2<ept id=\"p2\">*</ept>) – 1 comparisons.","source":"The complexity of the algorithm is linear with at most ( * last1 – first1*) – ( * last2 – first2*) – 1 comparisons."},{"pos":[129471,129593],"content":"The <bpt id=\"p1\">[</bpt>list class<ept id=\"p1\">](../standard-library/list-class.md)</ept> provides a member function \"merge\" to merge the elements of two lists.","source":"The [list class](../standard-library/list-class.md) provides a member function \"merge\" to merge the elements of two lists."},{"content":"Example","pos":[129603,129610]},{"pos":[133789,133792],"content":"min"},{"content":"Compares two objects and returns the lesser of the two, where the ordering criterion may be specified by a binary predicate.","pos":[133796,133920]},{"content":"Parameters","pos":[134423,134433]},{"content":"The first of the two objects being compared.","pos":[134447,134491]},{"content":"The second of the two objects being compared.","pos":[134509,134554]},{"content":"A binary predicate used to compare the two objects.","pos":[134571,134622]},{"content":"The initializer_list that contains the members to be compared.","pos":[134641,134703]},{"content":"Return Value","pos":[134713,134725]},{"content":"The lesser of the two objects, unless neither is lesser; in that case, it returns the first of the two objects.","pos":[134729,134840]},{"content":"In the case of an initializer_list, it returns the least of the objects in the list.","pos":[134841,134925]},{"content":"Remarks","pos":[134935,134942]},{"content":"The <ph id=\"ph1\">`min`</ph> algorithm is unusual in having objects passed as parameters.","pos":[134946,135016],"source":"The `min` algorithm is unusual in having objects passed as parameters."},{"content":"Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters.","pos":[135017,135152]},{"content":"If you need a function that uses a range of elements, use <bpt id=\"p1\">[</bpt>min_element<ept id=\"p1\">](../standard-library/algorithm-functions.md#min_element)</ept>.","pos":[135153,135281],"source":" If you need a function that uses a range of elements, use [min_element](../standard-library/algorithm-functions.md#min_element)."},{"content":"Example","pos":[135291,135298]},{"pos":[140136,140147],"content":"min_element"},{"content":"Finds the first occurrence of smallest element in a specified range where the ordering criterion may be specified by a binary predicate.","pos":[140151,140287]},{"content":"Parameters","pos":[140586,140596]},{"content":"A forward iterator addressing the position of the first element in the range to be searched for the smallest element.","pos":[140611,140728]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched for the smallest element.","pos":[140745,140868]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[140885,140992]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[140993,141140],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[141150,141162]},{"content":"A forward iterator addressing the position of the first occurrence of the smallest element in the range searched.","pos":[141166,141279]},{"content":"Remarks","pos":[141289,141296]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.","pos":[141300,141462]},{"pos":[141469,141565],"content":"The complexity is linear: ( <ph id=\"ph1\">`last`</ph> – <ph id=\"ph2\">`first`</ph>) – 1 comparisons are required for a nonempty range.","source":"The complexity is linear: ( `last` – `first`) – 1 comparisons are required for a nonempty range."},{"content":"Example","pos":[141575,141582]},{"pos":[144527,144541],"content":"minmax_element"},{"pos":[144545,144620],"content":"Performs the work performed by <ph id=\"ph1\">`min_element`</ph> and <ph id=\"ph2\">`max_element`</ph> in one call.","source":"Performs the work performed by `min_element` and `max_element` in one call."},{"content":"Parameters","pos":[145111,145121]},{"content":"A forward iterator that indicates the beginning of a range.","pos":[145137,145196]},{"content":"A forward iterator that indicates the end of a range.","pos":[145213,145266]},{"content":"An optional test used to order elements.","pos":[145283,145323]},{"content":"Return Value","pos":[145333,145345]},{"content":"Returns","pos":[145349,145356]},{"pos":[145414,145594],"content":"<bpt id=\"p1\">[</bpt>min_element<ept id=\"p1\">](../standard-library/algorithm-functions.md#min_element)</ept>(  <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph>), <bpt id=\"p2\">[</bpt>max_element<ept id=\"p2\">](../standard-library/algorithm-functions.md#max_element)</ept>(  <ph id=\"ph3\">`first`</ph>, <ph id=\"ph4\">`last`</ph>)).","source":"[min_element](../standard-library/algorithm-functions.md#min_element)(  `first`, `last`), [max_element](../standard-library/algorithm-functions.md#max_element)(  `first`, `last`))."},{"content":"Remarks","pos":[145604,145611]},{"content":"The first template function returns","pos":[145615,145650]},{"pos":[145756,145757],"content":"."},{"pos":[145764,145873],"content":"The second template function behaves the same, except that it replaces <ph id=\"ph1\">`operator&lt;(X, Y)`</ph> with <ph id=\"ph2\">`comp``(X, Y)`</ph>.","source":"The second template function behaves the same, except that it replaces `operator<(X, Y)` with `comp``(X, Y)`."},{"pos":[145880,145990],"content":"If the sequence is non-empty, the function performs at most <ph id=\"ph1\">`3 * (``last`</ph> <ph id=\"ph2\">`-`</ph>  <ph id=\"ph3\">`first`</ph> <ph id=\"ph4\">`- 1) / 2`</ph> comparisons.","source":"If the sequence is non-empty, the function performs at most `3 * (``last` `-`  `first` `- 1) / 2` comparisons."},{"pos":[146023,146029],"content":"minmax"},{"content":"Compares two input parameters and returns them as a pair, in order of lesser to greater.","pos":[146033,146121]},{"content":"Parameters","pos":[146820,146830]},{"content":"The first of the two objects being compared.","pos":[146844,146888]},{"content":"The second of the two objects being compared.","pos":[146906,146951]},{"content":"A binary predicate used to compare the two objects.","pos":[146968,147019]},{"content":"The initializer_list that contains the members to be compared.","pos":[147038,147100]},{"content":"Remarks","pos":[147110,147117]},{"content":"The first template function returns <ph id=\"ph1\">`pair&lt;const Type&amp;, const Type&amp;&gt;(``right``,`</ph> <ph id=\"ph2\">`left``)`</ph> if <ph id=\"ph3\">`right`</ph> is less than <ph id=\"ph4\">`left`</ph>.","pos":[147121,147242],"source":"The first template function returns `pair<const Type&, const Type&>(``right``,` `left``)` if `right` is less than `left`."},{"content":"Otherwise, it returns <ph id=\"ph1\">`pair&lt;const Type&amp;, const Type&amp;&gt;(``left``,`</ph> <ph id=\"ph2\">`right``)`</ph>.","pos":[147243,147319],"source":" Otherwise, it returns `pair<const Type&, const Type&>(``left``,` `right``)`."},{"pos":[147326,147474],"content":"The second member function returns a pair where the first element is the lesser and the second is the greater when compared by the predicate <ph id=\"ph1\">`comp`</ph>.","source":"The second member function returns a pair where the first element is the lesser and the second is the greater when compared by the predicate `comp`."},{"pos":[147481,147604],"content":"The remaining template functions behave the same, except that they replace the <ph id=\"ph1\">`left`</ph> and <ph id=\"ph2\">`right`</ph> parameters with <ph id=\"ph3\">`_IList`</ph>.","source":"The remaining template functions behave the same, except that they replace the `left` and `right` parameters with `_IList`."},{"content":"The function performs exactly one comparison.","pos":[147611,147656]},{"pos":[147691,147699],"content":"mismatch"},{"content":"Compares two ranges element by element and locates the first position where a difference occurs.","pos":[147703,147799]},{"content":"Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.","pos":[147806,148095]},{"content":"Parameters","pos":[149087,149097]},{"content":"An input iterator addressing the position of the first element in the first range to be tested.","pos":[149113,149208]},{"content":"An input iterator addressing the position one past the last element in the first range to be tested.","pos":[149226,149326]},{"content":"An input iterator addressing the position of the first element in the second range to be tested.","pos":[149345,149441]},{"content":"An input iterator addressing the position of one past the last element in the second range to be tested.","pos":[149459,149563]},{"content":"User-defined predicate function object that compares the current elements in each range and determines whether they are equivalent.","pos":[149580,149711]},{"content":"It returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[149712,149780],"source":" It returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[149790,149802]},{"content":"A pair of iterators addressing the positions of the mismatch in the two ranges, the first component iterator to the position in the first range and the second component iterator to the position in the second range.","pos":[149806,150020]},{"content":"If there is no difference between the elements in the ranges compared or if the binary predicate in the second version is satisfied by all element pairs from the two ranges, then the first component iterator points to the position one past the final element in the first range and the second component iterator to position one past the final element tested in the second range.","pos":[150021,150398]},{"content":"Remarks","pos":[150408,150415]},{"content":"The first template function assumes that there are as many elements in the range beginning at first2 as there are in the range designated by [first1, last1).","pos":[150419,150576]},{"content":"If there are more in the second range, they are ignored; if there are less then undefined behavior will result.","pos":[150577,150688]},{"content":"The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.","pos":[150695,150841]},{"content":"The time complexity of the algorithm is linear in the number of elements contained in the shorter range.","pos":[150848,150952]},{"content":"The user-defined predicate is not required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.","pos":[150959,151098]},{"content":"Example","pos":[151108,151115]},{"content":"The following example demonstrates how to use mismatch.","pos":[151120,151175]},{"content":"The C++03 overload is shown only in order to demonstrate how it can produce an unexpected result.","pos":[151176,151273]},{"pos":[154912,154924],"content":"alg<ph id=\"ph1\">&amp;gt;</ph> move","source":"alg&gt; move"},{"content":"Move elements associated with a specified range.","pos":[154928,154976]},{"content":"Parameters","pos":[155197,155207]},{"content":"An input iterator that indicates where to start the range of elements to move.","pos":[155223,155301]},{"content":"An input iterator that indicates the end of a range of elements to move.","pos":[155318,155390]},{"content":"The output iterator that is to contain the moved elements.","pos":[155407,155465]},{"content":"Remarks","pos":[155475,155482]},{"content":"The template function evaluates <ph id=\"ph1\">`*(``dest`</ph> <ph id=\"ph2\">`+ N) =`</ph>  move <ph id=\"ph3\">`(*(`</ph> <ph id=\"ph4\">`first`</ph> <ph id=\"ph5\">`+ N)))`</ph> once for each <ph id=\"ph6\">`N`</ph> in the range <ph id=\"ph7\">`[0,`</ph> <ph id=\"ph8\">`last`</ph> <ph id=\"ph9\">`-`</ph>  <ph id=\"ph10\">`first``)`</ph>, for strictly increasing values of <ph id=\"ph11\">`N`</ph> starting with the lowest value.","pos":[155486,155697],"source":"The template function evaluates `*(``dest` `+ N) =`  move `(*(` `first` `+ N)))` once for each `N` in the range `[0,` `last` `-`  `first``)`, for strictly increasing values of `N` starting with the lowest value."},{"content":"It then returns <ph id=\"ph1\">`dest`</ph> <ph id=\"ph2\">`+ N`</ph>.","pos":[155698,155727],"source":" It then returns `dest` `+ N`."},{"content":"If <ph id=\"ph1\">`dest`</ph>and  <ph id=\"ph2\">`first`</ph> designate regions of storage, <ph id=\"ph3\">`dest`</ph> must not be in the range <ph id=\"ph4\">`[`</ph> <ph id=\"ph5\">`first``,`</ph> <ph id=\"ph6\">`last``)`</ph>.","pos":[155728,155837],"source":" If `dest`and  `first` designate regions of storage, `dest` must not be in the range `[` `first``,` `last``)`."},{"pos":[155877,155890],"content":"move_backward"},{"content":"Moves the elements of one iterator to another.","pos":[155894,155940]},{"content":"The move starts with the last element in a specified range, and ends with the first element in that range.","pos":[155941,156047]},{"content":"Parameters","pos":[156307,156317]},{"content":"An iterator that indicates the start of a range to move elements from.","pos":[156333,156403]},{"content":"An iterator that indicates the end of a range to move elements from.","pos":[156420,156488]},{"content":"This element is not moved.","pos":[156489,156515]},{"content":"A bidirectional iterator addressing the position of one past the final element in the destination range.","pos":[156535,156639]},{"content":"Remarks","pos":[156649,156656]},{"content":"The template function evaluates <ph id=\"ph1\">`*(``destEnd`</ph> <ph id=\"ph2\">`- N - 1) =`</ph> <ph id=\"ph3\">`move``(*(``last`</ph> <ph id=\"ph4\">`- N - 1)))`</ph> once for each <ph id=\"ph5\">`N`</ph> in the range <ph id=\"ph6\">`[0,`</ph> <ph id=\"ph7\">`last`</ph> <ph id=\"ph8\">`-`</ph>  <ph id=\"ph9\">`first``)`</ph>, for strictly increasing values of <ph id=\"ph10\">`N`</ph> starting with the lowest value.","pos":[156660,156880],"source":"The template function evaluates `*(``destEnd` `- N - 1) =` `move``(*(``last` `- N - 1)))` once for each `N` in the range `[0,` `last` `-`  `first``)`, for strictly increasing values of `N` starting with the lowest value."},{"content":"It then returns <ph id=\"ph1\">`destEnd`</ph> <ph id=\"ph2\">`- (``last`</ph> <ph id=\"ph3\">`-`</ph>  <ph id=\"ph4\">`first``)`</ph>.","pos":[156881,156935],"source":" It then returns `destEnd` `- (``last` `-`  `first``)`."},{"content":"If <ph id=\"ph1\">`destEnd`</ph> and  <ph id=\"ph2\">`first`</ph> designate regions of storage, <ph id=\"ph3\">`destEnd`</ph> must not be in the range <ph id=\"ph4\">`[`</ph> <ph id=\"ph5\">`first``,`</ph> <ph id=\"ph6\">`last``)`</ph>.","pos":[156936,157052],"source":" If `destEnd` and  `first` designate regions of storage, `destEnd` must not be in the range `[` `first``,` `last``)`."},{"pos":[157066,157171],"content":"and <ph id=\"ph1\">`move_backward`</ph> are functionally equivalent to using <ph id=\"ph2\">`copy`</ph> and <ph id=\"ph3\">`copy_backward`</ph> with a move iterator.","source":" and `move_backward` are functionally equivalent to using `copy` and `copy_backward` with a move iterator."},{"pos":[157214,157230],"content":"next_permutation"},{"content":"Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.","pos":[157234,157438]},{"content":"Parameters","pos":[157758,157768]},{"content":"A bidirectional iterator pointing to the position of the first element in the range to be permuted.","pos":[157784,157883]},{"content":"A bidirectional iterator pointing to the position one past the final element in the range to be permuted.","pos":[157900,158005]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[158022,158154]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[158155,158263],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[158273,158285]},{"pos":[158289,158511],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the lexicographically next permutation exists and has replaced the original ordering of the range; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>, in which case the ordering is transformed into the lexicographically smallest permutation.","source":"**true** if the lexicographically next permutation exists and has replaced the original ordering of the range; otherwise **false**, in which case the ordering is transformed into the lexicographically smallest permutation."},{"content":"Remarks","pos":[158521,158528]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[158532,158693]},{"content":"The default binary predicate is less than and the elements in the range must be less than comparable to insure that the next permutation is well defined.","pos":[158700,158853]},{"pos":[158860,158925],"content":"The complexity is linear with at most ( <bpt id=\"p1\">*</bpt> last – first<ept id=\"p1\">*</ept>)/2 swaps.","source":"The complexity is linear with at most ( * last – first*)/2 swaps."},{"content":"Example","pos":[158935,158942]},{"pos":[163236,163247],"content":"nth_element"},{"pos":[163251,163518],"content":"Partitions a range of elements, correctly locating the                 <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept>th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it.","source":"Partitions a range of elements, correctly locating the                 *n*th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it."},{"content":"Parameters","pos":[163880,163890]},{"content":"A random-access iterator addressing the position of the first element in the range to be partitioned.","pos":[163906,164007]},{"content":"_Nth","pos":[164015,164019]},{"content":"A random-access iterator addressing the position of element to be correctly ordered on the boundary of the partition.","pos":[164024,164141]},{"content":"A random-access iterator addressing the position one past the final element in the range to be partitioned.","pos":[164158,164265]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[164282,164414]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[164415,164523],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[164533,164540]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[164544,164705]},{"content":"The <ph id=\"ph1\">`nth_element`</ph> algorithm does not guarantee that elements in the sub-ranges either side of the  <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept>th element are sorted.","pos":[164712,164836],"source":"The `nth_element` algorithm does not guarantee that elements in the sub-ranges either side of the  *n*th element are sorted."},{"content":"It thus makes fewer guarantees than <ph id=\"ph1\">`partial_sort`</ph>, which orders the elements in the range below some chosen element, and may be used as a faster alternative to <ph id=\"ph2\">`partial_sort`</ph> when the ordering of the lower range is not required.","pos":[164837,165066],"source":" It thus makes fewer guarantees than `partial_sort`, which orders the elements in the range below some chosen element, and may be used as a faster alternative to `partial_sort` when the ordering of the lower range is not required."},{"content":"Elements are equivalent, but not necessarily equal, if neither is less than the other.","pos":[165073,165159]},{"pos":[165166,165242],"content":"The average of a sort complexity is linear with respect to  <bpt id=\"p1\">*</bpt> last – first<ept id=\"p1\">*</ept>.","source":"The average of a sort complexity is linear with respect to  * last – first*."},{"content":"Example","pos":[165252,165259]},{"pos":[167278,167285],"content":"none_of"},{"pos":[167289,167372],"content":"Returns <ph id=\"ph1\">`true`</ph> when a condition is never present among elements in the given range.","source":"Returns `true` when a condition is never present among elements in the given range."},{"content":"Parameters","pos":[167531,167541]},{"content":"An input iterator that indicates where to start to check a range of elements for a condition.","pos":[167557,167650]},{"content":"An input iterator that indicates the end of a range of elements.","pos":[167667,167731]},{"content":"The condition to test for.","pos":[167748,167774]},{"content":"This is provided by a user-defined predicate function object that defines the condition.","pos":[167775,167863]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[167864,167930],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Return Value","pos":[167940,167952]},{"pos":[167956,168083],"content":"Returns <ph id=\"ph1\">`true`</ph> if the condition is not detected at least once in the indicated range, and <ph id=\"ph2\">`false`</ph> if the condition is detected.","source":"Returns `true` if the condition is not detected at least once in the indicated range, and `false` if the condition is detected."},{"content":"Remarks","pos":[168093,168100]},{"pos":[168104,168266],"content":"The template function returns <ph id=\"ph1\">`true`</ph> only if, for some <ph id=\"ph2\">`N`</ph> in the range <ph id=\"ph3\">`[0,`</ph> <ph id=\"ph4\">`last`</ph> <ph id=\"ph5\">`-`</ph>  <ph id=\"ph6\">`first``)`</ph>, the predicate <ph id=\"ph7\">`comp``(*(`</ph> <ph id=\"ph8\">`first`</ph> <ph id=\"ph9\">`+ N))`</ph> is always <ph id=\"ph10\">`false`</ph>.","source":"The template function returns `true` only if, for some `N` in the range `[0,` `last` `-`  `first``)`, the predicate `comp``(*(` `first` `+ N))` is always `false`."},{"pos":[168305,168317],"content":"partial_sort"},{"content":"Arranges a specified number of the smaller elements in a range into a nondescending order or according to an ordering criterion specified by a binary predicate.","pos":[168321,168481]},{"content":"Parameters","pos":[168908,168918]},{"content":"A random-access iterator addressing the position of the first element in the range to be sorted.","pos":[168933,169029]},{"content":"A random-access iterator addressing the position one past the final element in the subrange to be sorted.","pos":[169049,169154]},{"content":"A random-access iterator addressing the position one past the final element in the range to be partially sorted.","pos":[169171,169283]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[169300,169432]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[169433,169541],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[169551,169558]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[169562,169723]},{"content":"Elements are equivalent, but not necessarily equal, if neither is less than the other.","pos":[169730,169816]},{"content":"The <bpt id=\"p1\">**</bpt>sort<ept id=\"p1\">**</ept> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved.","pos":[169817,169945],"source":" The **sort** algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved."},{"content":"The algorithm <ph id=\"ph1\">`stable_sort`</ph> does preserve this original ordering.","pos":[169946,170011],"source":" The algorithm `stable_sort` does preserve this original ordering."},{"pos":[170018,170108],"content":"The average partial sort complexity is  <bpt id=\"p1\">*</bpt>O<ept id=\"p1\">*</ept>(( <ph id=\"ph1\">`last`- `first`</ph>) log ( <ph id=\"ph2\">`sortEnd`- `first`</ph>)).","source":"The average partial sort complexity is  *O*(( `last`- `first`) log ( `sortEnd`- `first`))."},{"content":"Example","pos":[170118,170125]},{"pos":[172170,172187],"content":"partial_sort_copy"},{"content":"Copies elements from a source range into a destination range where the source elements are ordered by either less than or another specified binary predicate.","pos":[172191,172348]},{"content":"Parameters","pos":[172893,172903]},{"content":"An input iterator addressing the position of the first element in the source range.","pos":[172920,173003]},{"content":"An input iterator addressing the position one past the final element in the source range.","pos":[173021,173110]},{"content":"A random-access iterator addressing the position of the first element in the sorted destination range.","pos":[173130,173232]},{"content":"A random-access iterator addressing the position one past the final element in the sorted destination range.","pos":[173250,173358]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[173375,173503]},{"content":"A binary predicate takes two arguments and returns <ph id=\"ph1\">`true`</ph> when satisfied and <ph id=\"ph2\">`false`</ph> when not satisfied.","pos":[173504,173608],"source":" A binary predicate takes two arguments and returns `true` when satisfied and `false` when not satisfied."},{"content":"Return Value","pos":[173618,173630]},{"content":"A random-access iterator addressing the element in the destination range one position beyond the last element inserted from the source range.","pos":[173634,173775]},{"content":"Remarks","pos":[173785,173792]},{"content":"The source and destination ranges must not overlap and must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[173796,173997]},{"content":"The binary predicate must provide a strict weak ordering so that elements that are not equivalent are ordered, but elements that are equivalent are not.","pos":[174004,174156]},{"content":"Two elements are equivalent under less than, but not necessarily equal, if neither is less than the other.","pos":[174157,174263]},{"content":"Example","pos":[174273,174280]},{"pos":[176504,176513],"content":"partition"},{"content":"Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it.","pos":[176517,176661]},{"content":"Parameters","pos":[176882,176892]},{"content":"A bidirectional iterator addressing the position of the first element in the range to be partitioned.","pos":[176908,177009]},{"content":"A bidirectional iterator addressing the position one past the final element in the range to be partitioned.","pos":[177026,177133]},{"content":"User-defined predicate function object that defines the condition to be satisfied if an element is to be classified.","pos":[177150,177266]},{"content":"A predicate takes a single argument and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","pos":[177267,177337],"source":" A predicate takes a single argument and returns **true** or **false**."},{"content":"Return Value","pos":[177347,177359]},{"content":"A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.","pos":[177363,177485]},{"content":"Remarks","pos":[177495,177502]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[177506,177667]},{"content":"Elements  <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept> and  <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept> are equivalent, but not necessarily equal, if both  <bpt id=\"p3\">*</bpt>Pr<ept id=\"p3\">*</ept> ( <bpt id=\"p4\">*</bpt>a<ept id=\"p4\">*</ept>,  <bpt id=\"p5\">*</bpt>b<ept id=\"p5\">*</ept>) is false and  <bpt id=\"p6\">*</bpt>Pr<ept id=\"p6\">*</ept> ( <bpt id=\"p7\">*</bpt>b<ept id=\"p7\">*</ept>,  <bpt id=\"p8\">*</bpt>a<ept id=\"p8\">*</ept>) if false, where  <bpt id=\"p9\">*</bpt>Pr<ept id=\"p9\">*</ept> is the parameter-specified predicate.","pos":[177674,177858],"source":"Elements  *a* and  *b* are equivalent, but not necessarily equal, if both  *Pr* ( *a*,  *b*) is false and  *Pr* ( *b*,  *a*) if false, where  *Pr* is the parameter-specified predicate."},{"content":"The <bpt id=\"p1\">**</bpt>partition<ept id=\"p1\">**</ept> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved.","pos":[177859,177992],"source":" The **partition** algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved."},{"content":"The algorithm <bpt id=\"p1\">**</bpt>stable_ partition<ept id=\"p1\">**</ept> does preserve this original ordering.","pos":[177993,178066],"source":" The algorithm **stable_ partition** does preserve this original ordering."},{"pos":[178073,178194],"content":"The complexity is linear: there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) applications of <ph id=\"ph3\">`comp`</ph> and at most ( <ph id=\"ph4\">`last`</ph> –  <ph id=\"ph5\">`first`</ph>)/2 swaps.","source":"The complexity is linear: there are ( `last` –  `first`) applications of `comp` and at most ( `last` –  `first`)/2 swaps."},{"content":"Example","pos":[178204,178211]},{"pos":[179150,179164],"content":"partition_copy"},{"content":"Copies elements for which a condition is <ph id=\"ph1\">`true`</ph> to one destination, and for which the condition is <ph id=\"ph2\">`false`</ph> to another.","pos":[179168,179286],"source":"Copies elements for which a condition is `true` to one destination, and for which the condition is `false` to another."},{"content":"The elements must come from a specified range.","pos":[179287,179333]},{"content":"Parameters","pos":[179712,179722]},{"content":"An input iterator that indicates the beginning of a range to check for a condition.","pos":[179738,179821]},{"content":"An input iterator that indicates the end of a range.","pos":[179838,179890]},{"content":"An output iterator used to copy elements that return true for a condition tested by using <ph id=\"ph1\">`_Pred`</ph>.","pos":[179908,180006],"source":" An output iterator used to copy elements that return true for a condition tested by using `_Pred`."},{"content":"An output iterator used to copy elements that return false for a condition tested by using <ph id=\"ph1\">`_Pred`</ph>.","pos":[180024,180123],"source":" An output iterator used to copy elements that return false for a condition tested by using `_Pred`."},{"content":"The condition to test for.","pos":[180141,180167]},{"content":"This is provided by a user-defined predicate function object that defines the condition to be tested.","pos":[180168,180269]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[180270,180336],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Remarks","pos":[180346,180353]},{"content":"The template function copies each element <ph id=\"ph1\">`X`</ph> in <ph id=\"ph2\">`[`</ph> <ph id=\"ph3\">`first``,`</ph> <ph id=\"ph4\">`last``)`</ph> to <ph id=\"ph5\">`*``dest1``++`</ph> if <ph id=\"ph6\">`_Pred``(X)`</ph> is true, or to <ph id=\"ph7\">`*``dest2``++ if not`</ph>.","pos":[180357,180502],"source":"The template function copies each element `X` in `[` `first``,` `last``)` to `*``dest1``++` if `_Pred``(X)` is true, or to `*``dest2``++ if not`."},{"content":"It returns <ph id=\"ph1\">`pair&lt;OutputIterator1, OutputIterator2&gt;(``dest1``,`</ph> <ph id=\"ph2\">`dest2``)`</ph>.","pos":[180503,180577],"source":" It returns `pair<OutputIterator1, OutputIterator2>(``dest1``,` `dest2``)`."},{"pos":[180619,180634],"content":"partition_point"},{"content":"Returns the first element in the given range that does not satisfy the condition.","pos":[180638,180719]},{"content":"The elements are sorted so that those that satisfy the condition come before those that do not.","pos":[180720,180815]},{"content":"Parameters","pos":[181030,181040]},{"content":"A <ph id=\"ph1\">`ForwardIterator`</ph> that indicates the start of a range to check for a condition.","pos":[181056,181137],"source":" A `ForwardIterator` that indicates the start of a range to check for a condition."},{"content":"A <ph id=\"ph1\">`ForwardIterator`</ph> that indicates the end of a range.","pos":[181154,181208],"source":" A `ForwardIterator` that indicates the end of a range."},{"content":"The condition to test for.","pos":[181225,181251]},{"content":"This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for.","pos":[181252,181390]},{"content":"A predicate takes a single argument and returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[181391,181457],"source":" A predicate takes a single argument and returns `true` or `false`."},{"content":"Return Value","pos":[181467,181479]},{"pos":[181483,181640],"content":"Returns a <ph id=\"ph1\">`ForwardIterator`</ph> that refers to the first element that does not fulfill the condition tested for by <ph id=\"ph2\">`comp`</ph>, or returns <ph id=\"ph3\">`last`</ph> if one is not found.","source":"Returns a `ForwardIterator` that refers to the first element that does not fulfill the condition tested for by `comp`, or returns `last` if one is not found."},{"content":"Remarks","pos":[181650,181657]},{"content":"The template function finds the first iterator <ph id=\"ph1\">`it`</ph> in <ph id=\"ph2\">`[`</ph> <ph id=\"ph3\">`first``,``last``)`</ph> for which <ph id=\"ph4\">`comp(*it)`</ph> is <ph id=\"ph5\">`false`</ph>.","pos":[181661,181773],"source":"The template function finds the first iterator `it` in `[` `first``,``last``)` for which `comp(*it)` is `false`."},{"content":"The sequence must be ordered by <ph id=\"ph1\">`comp`</ph>.","pos":[181774,181813],"source":" The sequence must be ordered by `comp`."},{"pos":[181848,181856],"content":"pop_heap"},{"content":"Removes the largest element from the front of a heap to the next-to-last position in the range and then forms a new heap from the remaining elements.","pos":[181860,182009]},{"content":"Parameters","pos":[182308,182318]},{"content":"A random-access iterator addressing the position of the first element in the heap.","pos":[182334,182416]},{"content":"A random-access iterator addressing the position one past the final element in the heap.","pos":[182433,182521]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[182538,182638]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[182639,182747],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[182757,182764]},{"pos":[182768,183097],"content":"The <ph id=\"ph1\">`pop_heap`</ph> algorithm is the inverse of the operation performed by the push_heap algorithm, in which an element at the next-to-last position of a range is added to a heap consisting of the prior elements in the range, in the case when the element being added to the heap is larger than any of the elements already in the heap.","source":"The `pop_heap` algorithm is the inverse of the operation performed by the push_heap algorithm, in which an element at the next-to-last position of a range is added to a heap consisting of the prior elements in the range, in the case when the element being added to the heap is larger than any of the elements already in the heap."},{"content":"Heaps have two properties:","pos":[183104,183130]},{"content":"The first element is always the largest.","pos":[183140,183180]},{"content":"Elements may be added or removed in logarithmic time.","pos":[183190,183243]},{"pos":[183250,183461],"content":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id=\"p1\">[</bpt>priority_queue Class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept>.","source":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md)."},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[183468,183629]},{"content":"The range excluding the newly added element at the end must be a heap.","pos":[183636,183706]},{"pos":[183713,183797],"content":"The complexity is logarithmic, requiring at most log ( <bpt id=\"p1\">*</bpt> last – first<ept id=\"p1\">*</ept>) comparisons.","source":"The complexity is logarithmic, requiring at most log ( * last – first*) comparisons."},{"content":"Example","pos":[183807,183814]},{"pos":[185894,185910],"content":"prev_permutation"},{"content":"Reorders the elements in a range so that the original ordering is replaced by the lexicographically previous greater permutation if it exists, where the sense of previous may be specified with a binary predicate.","pos":[185914,186126]},{"content":"Parameters","pos":[186492,186502]},{"content":"A bidirectional iterator pointing to the position of the first element in the range to be permuted.","pos":[186518,186617]},{"content":"A bidirectional iterator pointing to the position one past the final element in the range to be permuted.","pos":[186634,186739]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[186756,186888]},{"content":"A binary predicate takes two arguments and returns <ph id=\"ph1\">`true`</ph> when satisfied and <ph id=\"ph2\">`false`</ph> when not satisfied.","pos":[186889,186993],"source":" A binary predicate takes two arguments and returns `true` when satisfied and `false` when not satisfied."},{"content":"Return Value","pos":[187003,187015]},{"pos":[187026,187240],"content":"if the lexicographically previous permutation exists and has replaced the original ordering of the range; otherwise <ph id=\"ph1\">`false`</ph>, in which case the ordering is transformed into the lexicographically largest permutation.","source":" if the lexicographically previous permutation exists and has replaced the original ordering of the range; otherwise `false`, in which case the ordering is transformed into the lexicographically largest permutation."},{"content":"Remarks","pos":[187250,187257]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[187261,187422]},{"content":"The default binary predicate is less than and the elements in the range must be less-than comparable to ensure that the previous permutation is well defined.","pos":[187429,187586]},{"pos":[187593,187661],"content":"The complexity is linear, with at most ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>)/2 swaps.","source":"The complexity is linear, with at most ( `last` –  `first`)/2 swaps."},{"content":"Example","pos":[187671,187678]},{"pos":[192012,192021],"content":"push_heap"},{"content":"Adds an element that is at the end of a range to an existing heap consisting of the prior elements in the range.","pos":[192025,192137]},{"content":"Parameters","pos":[192440,192450]},{"content":"A random-access iterator addressing the position of the first element in the heap.","pos":[192466,192548]},{"content":"A random-access iterator addressing the position one past the final element in the range to be converted into a heap.","pos":[192565,192682]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[192699,192799]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[192800,192908],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[192918,192925]},{"content":"The element must first be pushed back to the end of an existing heap and then the algorithm is used to add this element to the existing heap.","pos":[192929,193070]},{"content":"Heaps have two properties:","pos":[193077,193103]},{"content":"The first element is always the largest.","pos":[193113,193153]},{"content":"Elements may be added or removed in logarithmic time.","pos":[193163,193216]},{"pos":[193223,193434],"content":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id=\"p1\">[</bpt>priority_queue Class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept>.","source":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md)."},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[193441,193602]},{"content":"The range excluding the newly added element at the end must be a heap.","pos":[193609,193679]},{"pos":[193686,193769],"content":"The complexity is logarithmic, requiring at most log ( <bpt id=\"p1\">*</bpt>last – first<ept id=\"p1\">*</ept>) comparisons.","source":"The complexity is logarithmic, requiring at most log ( *last – first*) comparisons."},{"content":"Example","pos":[193779,193786]},{"pos":[195896,195910],"content":"random_shuffle"},{"content":"The std::random_shuffle() function is deprecated, replaced by <bpt id=\"p1\">[</bpt>std::shuffle()<ept id=\"p1\">](../standard-library/algorithm-functions.md#std__shuffle)</ept>.","pos":[195914,196050],"source":"The std::random_shuffle() function is deprecated, replaced by [std::shuffle()](../standard-library/algorithm-functions.md#std__shuffle)."},{"content":"For a code example and more information, see <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>random&gt;<ept id=\"p1\">](../standard-library/random.md)</ept> and the Stackoverflow posting                 <bpt id=\"p2\">[</bpt>Why are std::random_shuffle methods being deprecated in C++14?<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=397954)</ept>.","pos":[196051,196297],"source":" For a code example and more information, see [\\<random>](../standard-library/random.md) and the Stackoverflow posting                 [Why are std::random_shuffle methods being deprecated in C++14?](http://go.microsoft.com/fwlink/?LinkId=397954)."},{"pos":[196330,196336],"content":"remove"},{"content":"Eliminates a specified value from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.","pos":[196340,196508]},{"content":"Parameters","pos":[196671,196681]},{"content":"A forward iterator addressing the position of the first element in the range from which elements are being removed.","pos":[196697,196812]},{"content":"A forward iterator addressing the position one past the final element in the range from which elements are being removed.","pos":[196829,196950]},{"content":"The value that is to be removed from the range.","pos":[196966,197013]},{"content":"Return Value","pos":[197023,197035]},{"content":"A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.","pos":[197039,197192]},{"content":"Remarks","pos":[197202,197209]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[197213,197374]},{"content":"The order of the elements not removed remains stable.","pos":[197381,197434]},{"pos":[197441,197563],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[197570,197652],"content":"The complexity is linear; there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality.","source":"The complexity is linear; there are ( `last` –  `first`) comparisons for equality."},{"pos":[197659,197799],"content":"The <bpt id=\"p1\">[</bpt>list class<ept id=\"p1\">](../standard-library/list-class.md)</ept> has a more efficient member function version of <bpt id=\"p2\">**</bpt>remove<ept id=\"p2\">**</ept>, which also relinks pointers.","source":"The [list class](../standard-library/list-class.md) has a more efficient member function version of **remove**, which also relinks pointers."},{"content":"Example","pos":[197809,197816]},{"pos":[199017,199028],"content":"remove_copy"},{"content":"Copies elements from a source range to a destination range, except that elements of a specified value are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.","pos":[199032,199254]},{"content":"Parameters","pos":[199460,199470]},{"content":"An input iterator addressing the position of the first element in the range from which elements are being removed.","pos":[199486,199600]},{"content":"An input iterator addressing the position one past the final element in the range from which elements are being removed.","pos":[199617,199737]},{"content":"An output iterator addressing the position of the first element in the destination range to which elements are being removed.","pos":[199756,199881]},{"content":"The value that is to be removed from the range.","pos":[199897,199944]},{"content":"Return Value","pos":[199954,199966]},{"content":"A forward iterator addressing the new end position of the destination range, one past the final element of the copy of the remnant sequence free of the specified value.","pos":[199970,200138]},{"content":"Remarks","pos":[200148,200155]},{"content":"The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[200159,200344]},{"content":"There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.","pos":[200351,200505]},{"content":"The order of the elements not removed remains stable.","pos":[200512,200565]},{"pos":[200572,200694],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[200701,200828],"content":"The complexity is linear; there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments.","source":"The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments."},{"content":"Example","pos":[200838,200845]},{"pos":[202018,202032],"content":"remove_copy_if"},{"content":"Copies elements from a source range to a destination range, except that satisfying a predicate are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.","pos":[202036,202251]},{"content":"Parameters","pos":[202463,202473]},{"content":"An input iterator addressing the position of the first element in the range from which elements are being removed.","pos":[202489,202603]},{"content":"An input iterator addressing the position one past the final element in the range from which elements are being removed.","pos":[202620,202740]},{"content":"An output iterator addressing the position of the first element in the destination range to which elements are being removed.","pos":[202759,202884]},{"content":"The unary predicate that must be satisfied is the value of an element is to be replaced.","pos":[202902,202990]},{"content":"Return Value","pos":[203000,203012]},{"content":"A forward iterator addressing the new end position of the destination range, one past the final element of the remnant sequence free of the elements satisfying the predicate.","pos":[203016,203190]},{"content":"Remarks","pos":[203200,203207]},{"content":"The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[203211,203379]},{"content":"There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.","pos":[203386,203540]},{"content":"The order of the elements not removed remains stable.","pos":[203547,203600]},{"pos":[203607,203729],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[203736,203863],"content":"The complexity is linear: there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments.","source":"The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments."},{"pos":[203870,203983],"content":"For information on how these functions behave, see <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept>.","source":"For information on how these functions behave, see [Checked Iterators](../standard-library/checked-iterators.md)."},{"content":"Example","pos":[203993,204000]},{"pos":[205351,205360],"content":"remove_if"},{"content":"Eliminates elements that satisfy a predicate from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.","pos":[205364,205548]},{"content":"Parameters","pos":[205718,205728]},{"content":"A forward iterator pointing to the position of the first element in the range from which elements are being removed.","pos":[205744,205860]},{"content":"A forward iterator pointing to the position one past the final element in the range from which elements are being removed.","pos":[205877,205999]},{"content":"The unary predicate that must be satisfied is the value of an element is to be replaced.","pos":[206017,206105]},{"content":"Return Value","pos":[206115,206127]},{"content":"A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.","pos":[206131,206284]},{"content":"Remarks","pos":[206294,206301]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[206305,206466]},{"content":"The order of the elements not removed remains stable.","pos":[206473,206526]},{"pos":[206533,206655],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[206662,206744],"content":"The complexity is linear: there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality.","source":"The complexity is linear: there are ( `last` –  `first`) comparisons for equality."},{"content":"List has a more efficient member function version of remove which relinks pointers.","pos":[206751,206834]},{"content":"Example","pos":[206844,206851]},{"pos":[208178,208185],"content":"replace"},{"content":"Examines each element in a range and replaces it if it matches a specified value.","pos":[208189,208270]},{"content":"Parameters","pos":[208444,208454]},{"content":"A forward iterator pointing to the position of the first element in the range from which elements are being replaced.","pos":[208470,208587]},{"content":"A forward iterator pointing to the position one past the final element in the range from which elements are being replaced.","pos":[208604,208727]},{"content":"The old value of the elements being replaced.","pos":[208747,208792]},{"content":"The new value being assigned to the elements with the old value.","pos":[208812,208876]},{"content":"Remarks","pos":[208886,208893]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[208897,209058]},{"content":"The order of the elements not replaced remains stable.","pos":[209065,209119]},{"pos":[209126,209248],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[209255,209396],"content":"The complexity is linear; there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments of new values.","source":"The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values."},{"content":"Example","pos":[209406,209413]},{"pos":[210380,210392],"content":"replace_copy"},{"content":"Examines each element in a source range and replaces it if it matches a specified value while copying the result into a new destination range.","pos":[210396,210538]},{"content":"Parameters","pos":[210808,210818]},{"content":"An input iterator pointing to the position of the first element in the range from which elements are being replaced.","pos":[210834,210950]},{"content":"An input iterator pointing to the position one past the final element in the range from which elements are being replaced.","pos":[210967,211089]},{"content":"An output iterator pointing to the first element in the destination range to where the altered sequence of elements is being copied.","pos":[211108,211240]},{"content":"The old value of the elements being replaced.","pos":[211260,211305]},{"content":"The new value being assigned to the elements with the old value.","pos":[211325,211389]},{"content":"Return Value","pos":[211399,211411]},{"content":"An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.","pos":[211415,211569]},{"content":"Remarks","pos":[211579,211586]},{"content":"The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.","pos":[211590,211802]},{"content":"The order of the elements not replaced remains stable.","pos":[211809,211863]},{"pos":[211870,211992],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[211999,212140],"content":"The complexity is linear: there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments of new values.","source":"The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values."},{"content":"Example","pos":[212150,212157]},{"pos":[213808,213823],"content":"replace_copy_if"},{"content":"Examines each element in a source range and replaces it if it satisfies a specified predicate while copying the result into a new destination range.","pos":[213827,213975]},{"content":"Parameters","pos":[214248,214258]},{"content":"An input iterator pointing to the position of the first element in the range from which elements are being replaced.","pos":[214274,214390]},{"content":"An input iterator pointing to the position one past the final element in the range from which elements are being replaced.","pos":[214407,214529]},{"content":"An output iterator pointing to the position of the first element in the destination range to which elements are being copied.","pos":[214548,214673]},{"content":"The unary predicate that must be satisfied is the value of an element is to be replaced.","pos":[214691,214779]},{"content":"The new value being assigned to the elements whose old value satisfies the predicate.","pos":[214795,214880]},{"content":"Return Value","pos":[214890,214902]},{"content":"An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.","pos":[214906,215060]},{"content":"Remarks","pos":[215070,215077]},{"content":"The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.","pos":[215081,215293]},{"content":"The order of the elements not replaced remains stable.","pos":[215300,215354]},{"pos":[215361,215483],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[215490,215631],"content":"The complexity is linear; there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments of new values.","source":"The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values."},{"content":"Example","pos":[215641,215648]},{"pos":[217493,217503],"content":"replace_if"},{"content":"Examines each element in a range and replaces it if it satisfies a specified predicate.","pos":[217507,217594]},{"content":"Parameters","pos":[217782,217792]},{"content":"A forward iterator pointing to the position of the first element in the range from which elements are being replaced.","pos":[217808,217925]},{"content":"An iterator pointing to the position one past the final element in the range from which elements are being replaced.","pos":[217942,218058]},{"content":"The unary predicate that must be satisfied is the value of an element is to be replaced.","pos":[218076,218164]},{"content":"The new value being assigned to the elements whose old value satisfies the predicate.","pos":[218180,218265]},{"content":"Remarks","pos":[218275,218282]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[218286,218447]},{"content":"The order of the elements not replaced remains stable.","pos":[218454,218508]},{"pos":[218515,218683],"content":"The algorithm <ph id=\"ph1\">`replace_if`</ph> is a generalization of the algorithm <bpt id=\"p1\">**</bpt>replace<ept id=\"p1\">**</ept>, allowing any predicate to be specified, rather than equality to a specified constant value.","source":"The algorithm `replace_if` is a generalization of the algorithm **replace**, allowing any predicate to be specified, rather than equality to a specified constant value."},{"pos":[218690,218812],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands."},{"pos":[218819,218960],"content":"The complexity is linear: there are ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons for equality and at most ( <ph id=\"ph3\">`last`</ph> –  <ph id=\"ph4\">`first`</ph>) assignments of new values.","source":"The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values."},{"content":"Example","pos":[218970,218977]},{"pos":[220093,220100],"content":"reverse"},{"content":"Reverses the order of the elements within a range.","pos":[220104,220154]},{"content":"Parameters","pos":[220296,220306]},{"content":"A bidirectional iterator pointing to the position of the first element in the range within which the elements are being permuted.","pos":[220322,220451]},{"content":"A bidirectional iterator pointing to the position one past the final element in the range within which the elements are being permuted.","pos":[220468,220603]},{"content":"Remarks","pos":[220613,220620]},{"content":"The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[220624,220792]},{"content":"Example","pos":[220802,220809]},{"pos":[221785,221797],"content":"reverse_copy"},{"content":"Reverses the order of the elements within a source range while copying them into a destination range","pos":[221801,221901]},{"content":"Parameters","pos":[222124,222134]},{"content":"A bidirectional iterator pointing to the position of the first element in the source range within which the elements are being permuted.","pos":[222150,222286]},{"content":"A bidirectional iterator pointing to the position one past the final element in the source range within which the elements are being permuted.","pos":[222303,222445]},{"content":"An output iterator pointing to the position of the first element in the destination range to which elements are being copied.","pos":[222464,222589]},{"content":"Return Value","pos":[222599,222611]},{"content":"An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.","pos":[222615,222769]},{"content":"Remarks","pos":[222779,222786]},{"content":"The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[222790,222975]},{"content":"Example","pos":[222985,222992]},{"pos":[224033,224039],"content":"rotate"},{"content":"Exchanges the elements in two adjacent ranges.","pos":[224043,224089]},{"content":"Parameters","pos":[224236,224246]},{"content":"A forward iterator addressing the position of the first element in the range to be rotated.","pos":[224262,224353]},{"content":"A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.","pos":[224372,224588]},{"content":"A forward iterator addressing the position one past the final element in the range to be rotated.","pos":[224604,224701]},{"content":"Remarks","pos":[224711,224718]},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[224722,224884]},{"pos":[224891,224956],"content":"The complexity is linear with at most ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) swaps.","source":"The complexity is linear with at most ( `last` –  `first`) swaps."},{"content":"Example","pos":[224966,224973]},{"pos":[227178,227189],"content":"rotate_copy"},{"content":"Exchanges the elements in two adjacent ranges within a source range and copies the result to a destination range.","pos":[227193,227306]},{"content":"Parameters","pos":[227538,227548]},{"content":"A forward iterator addressing the position of the first element in the range to be rotated.","pos":[227564,227655]},{"content":"A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.","pos":[227674,227890]},{"content":"_","pos":[227897,227898]},{"content":"A forward iterator addressing the position one past the final element in the range to be rotated.","pos":[227909,228006]},{"content":"An output iterator addressing the position of the first element in the destination range.","pos":[228025,228114]},{"content":"Return Value","pos":[228124,228136]},{"content":"An output iterator addressing the position one past the final element in the destination range.","pos":[228140,228235]},{"content":"Remarks","pos":[228245,228252]},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[228256,228418]},{"pos":[228425,228490],"content":"The complexity is linear with at most ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) swaps.","source":"The complexity is linear with at most ( `last` –  `first`) swaps."},{"content":"Example","pos":[228500,228507]},{"pos":[230296,230302],"content":"search"},{"content":"Searches for the first occurrence of a sequence within a target range whose elements are equal to those in a given sequence of elements or whose elements are equivalent in a sense specified by a binary predicate to the elements in the given sequence.","pos":[230306,230556]},{"content":"Parameters","pos":[231067,231077]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[231094,231186]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[231204,231302]},{"content":"A forward iterator addressing the position of the first element in the range to be matched.","pos":[231322,231413]},{"content":"A forward iterator addressing the position one past the final element in the range to be matched.","pos":[231431,231528]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[231545,231673]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[231674,231782],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[231792,231804]},{"content":"A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.","pos":[231808,231998]},{"content":"Remarks","pos":[232008,232015]},{"pos":[232019,232164],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.","pos":[232171,232334]},{"content":"Average complexity is linear with respect to the size of the searched range, and worst case complexity is also linear with respect to the size of the sequence being searched for.","pos":[232341,232519]},{"content":"Example","pos":[232529,232536]},{"pos":[235278,235286],"content":"search_n"},{"content":"Searches for the first subsequence in a range that of a specified number of elements having a particular value or a relation to that value as specified by a binary predicate.","pos":[235290,235464]},{"content":"Parameters","pos":[235956,235966]},{"content":"A forward iterator addressing the position of the first element in the range to be searched.","pos":[235983,236075]},{"content":"A forward iterator addressing the position one past the final element in the range to be searched.","pos":[236093,236191]},{"content":"The size of the subsequence being searched for.","pos":[236209,236256]},{"content":"The value of the elements in the sequence being searched for.","pos":[236272,236333]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[236350,236478]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[236479,236587],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[236597,236609]},{"content":"A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.","pos":[236613,236803]},{"content":"Remarks","pos":[236813,236820]},{"pos":[236824,236969],"content":"The <ph id=\"ph1\">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.","source":"The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands."},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[236976,237137]},{"content":"Complexity is linear with respect to the size of the searched.","pos":[237144,237206]},{"content":"Example","pos":[237216,237223]},{"pos":[239565,239579],"content":"set_difference"},{"content":"Unites all of the elements that belong to one sorted source range, but not to a second sorted source range, into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.","pos":[239583,239800]},{"content":"Parameters","pos":[240412,240422]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.","pos":[240438,240639]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.","pos":[240657,240863]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.","pos":[240882,241092]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.","pos":[241110,241325]},{"content":"An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the difference of the two source ranges.","pos":[241344,241558]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[241575,241682]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[241683,241830],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[241840,241852]},{"content":"An output iterator addressing the position one past the last element in the sorted destination range representing the difference of the two source ranges.","pos":[241856,242010]},{"content":"Remarks","pos":[242020,242027]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[242031,242213]},{"content":"The destination range should not overlap either of the source ranges and should be large enough to contain the first source range.","pos":[242220,242350]},{"pos":[242357,242574],"content":"The sorted source ranges must each be arranged as a precondition to the application of the <ph id=\"ph1\">`set_difference`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","source":"The sorted source ranges must each be arranged as a precondition to the application of the `set_difference` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"content":"The operation is stable as the relative order of elements within each range is preserved in the destination range.","pos":[242581,242695]},{"content":"The source ranges are not modified by the algorithm merge.","pos":[242696,242754]},{"content":"The value types of the input iterators need be less-than-comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[242761,243012]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[243013,243076]},{"content":"When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.","pos":[243077,243242]},{"content":"If the source ranges contain duplicates of an element such that there are more in the first source range than in the second, then the destination range will contain the number by which the occurrences of those elements in the first source range exceed the occurrences of those elements in the second source range.","pos":[243243,243556]},{"pos":[243563,243712],"content":"The complexity of the algorithm is linear with at most 2 <ph id=\"ph1\">\\*</ph> ( ( <bpt id=\"p1\">*</bpt>last1 – first1<ept id=\"p1\">*</ept>) – ( <bpt id=\"p2\">*</bpt>last2 – first2<ept id=\"p2\">*</ept>) ) – 1 comparisons for nonempty source ranges.","source":"The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( *last2 – first2*) ) – 1 comparisons for nonempty source ranges."},{"content":"Example","pos":[243722,243729]},{"pos":[248185,248201],"content":"set_intersection"},{"content":"Unites all of the elements that belong to both sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.","pos":[248205,248382]},{"content":"Parameters","pos":[249003,249013]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.","pos":[249030,249233]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.","pos":[249251,249459]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.","pos":[249479,249691]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.","pos":[249709,249926]},{"content":"<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Result<ept id=\"p2\">*</ept>","pos":[249933,249947],"source":"**_** *Result*"},{"content":"An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the intersection of the two source ranges.","pos":[249951,250167]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[250184,250291]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[250292,250439],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[250449,250461]},{"content":"An output iterator addressing the position one past the last element in the sorted destination range representing the intersection of the two source ranges.","pos":[250465,250621]},{"content":"Remarks","pos":[250631,250638]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[250642,250824]},{"content":"The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.","pos":[250831,250960]},{"content":"The sorted source ranges must each be arranged as a precondition to the application of the merge algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","pos":[250967,251173]},{"content":"The operation is stable as the relative order of elements within each range is preserved in the destination range.","pos":[251180,251294]},{"content":"The source ranges are not modified by the algorithm.","pos":[251295,251347]},{"content":"The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[251354,251605]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[251606,251669]},{"content":"When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.","pos":[251670,251835]},{"content":"If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.","pos":[251836,252001]},{"pos":[252008,252157],"content":"The complexity of the algorithm is linear with at most 2 <ph id=\"ph1\">\\*</ph> ( ( <bpt id=\"p1\">*</bpt>last1 – first1<ept id=\"p1\">*</ept>) + ( <bpt id=\"p2\">*</bpt>last2 – first2<ept id=\"p2\">*</ept>) ) – 1 comparisons for nonempty source ranges.","source":"The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) + ( *last2 – first2*) ) – 1 comparisons for nonempty source ranges."},{"content":"Example","pos":[252167,252174]},{"pos":[256619,256643],"content":"set_symmetric_difference"},{"content":"Unites all of the elements that belong to one, but not both, of the sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.","pos":[256647,256845]},{"content":"Parameters","pos":[257458,257468]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.","pos":[257485,257696]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.","pos":[257714,257930]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.","pos":[257950,258170]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.","pos":[258188,258413]},{"content":"<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Result<ept id=\"p2\">*</ept>","pos":[258420,258434],"source":"**_** *Result*"},{"content":"An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the symmetric difference of the two source ranges.","pos":[258438,258662]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[258679,258786]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[258787,258934],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[258944,258956]},{"content":"An output iterator addressing the position one past the last element in the sorted destination range representing the symmetric difference of the two source ranges.","pos":[258960,259124]},{"content":"Remarks","pos":[259134,259141]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[259145,259327]},{"content":"The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.","pos":[259334,259463]},{"pos":[259470,259680],"content":"The sorted source ranges must each be arranged as a precondition to the application of the <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","source":"The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"content":"The operation is stable as the relative order of elements within each range is preserved in the destination range.","pos":[259687,259801]},{"content":"The source ranges are not modified by the algorithm merge.","pos":[259802,259860]},{"content":"The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[259867,260118]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[260119,260182]},{"content":"When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.","pos":[260183,260348]},{"content":"If the source ranges contain duplicates of an element, then the destination range will contain the absolute value of the number by which the occurrences of those elements in the one of the source ranges exceeds the occurrences of those elements in the second source range.","pos":[260349,260621]},{"pos":[260628,260775],"content":"The complexity of the algorithm is linear with at most 2 <ph id=\"ph1\">\\*</ph> ( (<bpt id=\"p1\">*</bpt>last1 – first1<ept id=\"p1\">*</ept>) – (<bpt id=\"p2\">*</bpt>last2 – first2<ept id=\"p2\">*</ept>) ) – 1 comparisons for nonempty source ranges.","source":"The complexity of the algorithm is linear with at most 2 \\* ( (*last1 – first1*) – (*last2 – first2*) ) – 1 comparisons for nonempty source ranges."},{"content":"Example","pos":[260785,260792]},{"pos":[265337,265346],"content":"set_union"},{"content":"Unites all of the elements that belong to at least one of two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.","pos":[265350,265542]},{"content":"Parameters","pos":[266124,266134]},{"content":"An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.","pos":[266151,266347]},{"content":"An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.","pos":[266365,266566]},{"content":"An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.","pos":[266586,266791]},{"content":"An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.","pos":[266809,267019]},{"content":"<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Result<ept id=\"p2\">*</ept>","pos":[267026,267040],"source":"**_** *Result*"},{"content":"An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the union of the two source ranges.","pos":[267044,267253]},{"content":"User-defined predicate function object that defines the sense in which one element is greater than another.","pos":[267270,267377]},{"content":"The binary predicate takes two arguments and should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when the first element is less than the second element and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> otherwise.","pos":[267378,267525],"source":" The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise."},{"content":"Return Value","pos":[267535,267547]},{"content":"An output iterator addressing the position one past the last element in the sorted destination range representing the union of the two source ranges.","pos":[267551,267700]},{"content":"Remarks","pos":[267710,267717]},{"content":"The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[267721,267903]},{"content":"The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.","pos":[267910,268039]},{"pos":[268046,268256],"content":"The sorted source ranges must each be arranged as a precondition to the application of the <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.","source":"The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges."},{"content":"The operation is stable as the relative order of elements within each range is preserved in the destination range.","pos":[268263,268377]},{"content":"The source ranges are not modified by the algorithm <bpt id=\"p1\">**</bpt>merge<ept id=\"p1\">**</ept>.","pos":[268378,268440],"source":" The source ranges are not modified by the algorithm **merge**."},{"content":"The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[268447,268698]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[268699,268762]},{"content":"When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.","pos":[268763,268928]},{"content":"If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.","pos":[268929,269094]},{"pos":[269101,269223],"content":"The complexity of the algorithm is linear with at most 2 <ph id=\"ph1\">\\*</ph> ( ( <bpt id=\"p1\">*</bpt>last1 – first1<ept id=\"p1\">*</ept>) – ( <bpt id=\"p2\">*</bpt>last2 – first2<ept id=\"p2\">*</ept>) ) – 1 comparisons.","source":"The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( *last2 – first2*) ) – 1 comparisons."},{"content":"Example","pos":[269233,269240]},{"pos":[273643,273655],"content":"std::shuffle"},{"content":"Shuffles (rearranges) elements for a given range by using a random number generator.","pos":[273659,273743]},{"content":"Parameters","pos":[273962,273972]},{"content":"An iterator to the first element in the range to be shuffled, inclusive.","pos":[273987,274059]},{"content":"Must meet the requirements of <ph id=\"ph1\">`RandomAccessIterator`</ph> and <ph id=\"ph2\">`ValueSwappable`</ph>.","pos":[274060,274134],"source":" Must meet the requirements of `RandomAccessIterator` and `ValueSwappable`."},{"content":"An iterator to the last element in the range to be shuffled, exclusive.","pos":[274151,274222]},{"content":"Must meet the requirements of <ph id=\"ph1\">`RandomAccessIterator`</ph> and <ph id=\"ph2\">`ValueSwappable`</ph>.","pos":[274223,274297],"source":" Must meet the requirements of `RandomAccessIterator` and `ValueSwappable`."},{"content":"The random number generator that the <ph id=\"ph1\">`shuffle()`</ph> function will use for the operation.","pos":[274313,274398],"source":" The random number generator that the `shuffle()` function will use for the operation."},{"content":"Must meet the requirements of a <ph id=\"ph1\">`UniformRandomNumberGenerator`</ph>.","pos":[274399,274462],"source":" Must meet the requirements of a `UniformRandomNumberGenerator`."},{"content":"Remarks","pos":[274472,274479]},{"pos":[274483,274593],"content":"For more information, and a code sample that uses <ph id=\"ph1\">`shuffle()`</ph>, see <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>random&gt;<ept id=\"p1\">](../standard-library/random.md)</ept>.","source":"For more information, and a code sample that uses `shuffle()`, see [\\<random>](../standard-library/random.md)."},{"pos":[274624,274628],"content":"sort"},{"content":"Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.","pos":[274632,274772]},{"content":"Parameters","pos":[275097,275107]},{"content":"A random-access iterator addressing the position of the first element in the range to be sorted.","pos":[275122,275218]},{"content":"A random-access iterator addressing the position one past the final element in the range to be sorted.","pos":[275235,275337]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[275354,275486]},{"content":"This binary predicate takes two arguments and returns <ph id=\"ph1\">`true`</ph> if the two arguments are in order and <ph id=\"ph2\">`false`</ph> otherwise.","pos":[275487,275604],"source":" This binary predicate takes two arguments and returns `true` if the two arguments are in order and `false` otherwise."},{"content":"This comparator function must impose a strict weak ordering on pairs of elements from the sequence.","pos":[275605,275704]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Algorithms<ept id=\"p1\">](../standard-library/algorithms.md)</ept>.","pos":[275705,275779],"source":" For more information, see [Algorithms](../standard-library/algorithms.md)."},{"content":"Remarks","pos":[275789,275796]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[275800,275961]},{"content":"Elements are equivalent, but not necessarily equal, if neither is less than the other.","pos":[275968,276054]},{"content":"The <ph id=\"ph1\">`sort`</ph> algorithm is not stable and so does not guarantee that the relative ordering of equivalent elements will be preserved.","pos":[276055,276184],"source":" The `sort` algorithm is not stable and so does not guarantee that the relative ordering of equivalent elements will be preserved."},{"content":"The algorithm <ph id=\"ph1\">`stable_sort`</ph> does preserve this original ordering.","pos":[276185,276250],"source":" The algorithm `stable_sort` does preserve this original ordering."},{"pos":[276257,276343],"content":"The average of a sort complexity is  <bpt id=\"p1\">*</bpt>O<ept id=\"p1\">*</ept>( <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept> log  <bpt id=\"p3\">*</bpt>N<ept id=\"p3\">*</ept>), where  <bpt id=\"p4\">*</bpt>N<ept id=\"p4\">*</ept><ph id=\"ph1\"> =  </ph><bpt id=\"p5\">*</bpt>last – first<ept id=\"p5\">*</ept>.","source":"The average of a sort complexity is  *O*( *N* log  *N*), where  *N* =  *last – first*."},{"content":"Example","pos":[276353,276360]},{"pos":[278216,278225],"content":"sort_heap"},{"content":"Converts a heap into a sorted range.","pos":[278229,278265]},{"content":"Parameters","pos":[278598,278608]},{"content":"A random-access iterator addressing the position of the first element in the target heap.","pos":[278624,278713]},{"content":"A random-access iterator addressing the position one past the final element in the target heap.","pos":[278730,278825]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[278842,278942]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[278943,279051],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[279061,279068]},{"content":"Heaps have two properties:","pos":[279072,279098]},{"content":"The first element is always the largest.","pos":[279108,279148]},{"content":"Elements may be added or removed in logarithmic time.","pos":[279158,279211]},{"content":"After the application if this algorithm, the range it was applied to is no longer a heap.","pos":[279218,279307]},{"content":"This is not a stable sort because the relative order of equivalent elements is not necessarily preserved.","pos":[279314,279419]},{"pos":[279426,279637],"content":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id=\"p1\">[</bpt>priority_queue Class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept>.","source":"Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md)."},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[279644,279805]},{"pos":[279812,279884],"content":"The complexity is at most  <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> log  <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept>, where  <bpt id=\"p3\">*</bpt>N<ept id=\"p3\">*</ept> = ( <bpt id=\"p4\">*</bpt>last – first<ept id=\"p4\">*</ept>).","source":"The complexity is at most  *N* log  *N*, where  *N* = ( *last – first*)."},{"content":"Example","pos":[279894,279901]},{"pos":[281077,281093],"content":"stable_partition"},{"content":"Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it, preserving the relative order of equivalent elements.","pos":[281097,281295]},{"content":"Parameters","pos":[281515,281525]},{"content":"A bidirectional iterator addressing the position of the first element in the range to be partitioned.","pos":[281541,281642]},{"content":"A bidirectional iterator addressing the position one past the final element in the range to be partitioned.","pos":[281659,281766]},{"content":"User-defined predicate function object that defines the condition to be satisfied if an element is to be classified.","pos":[281784,281900]},{"content":"A predicate takes single argument and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","pos":[281901,281969],"source":" A predicate takes single argument and returns **true** or **false**."},{"content":"Return Value","pos":[281979,281991]},{"content":"A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.","pos":[281995,282117]},{"content":"Remarks","pos":[282127,282134]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[282138,282299]},{"content":"Elements  <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept> and  <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept> are equivalent, but not necessarily equal, if both  <bpt id=\"p3\">*</bpt>Pr<ept id=\"p3\">*</ept> ( <bpt id=\"p4\">*</bpt>a<ept id=\"p4\">*</ept>,  <bpt id=\"p5\">*</bpt>b<ept id=\"p5\">*</ept>) is false and  <bpt id=\"p6\">*</bpt>Pr<ept id=\"p6\">*</ept> ( <bpt id=\"p7\">*</bpt>b<ept id=\"p7\">*</ept>,  <bpt id=\"p8\">*</bpt>a<ept id=\"p8\">*</ept>) if false, where  <bpt id=\"p9\">*</bpt>Pr<ept id=\"p9\">*</ept> is the parameter-specified predicate.","pos":[282306,282490],"source":"Elements  *a* and  *b* are equivalent, but not necessarily equal, if both  *Pr* ( *a*,  *b*) is false and  *Pr* ( *b*,  *a*) if false, where  *Pr* is the parameter-specified predicate."},{"content":"The <bpt id=\"p1\">**</bpt>stable_ partition<ept id=\"p1\">**</ept> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.","pos":[282491,282620],"source":" The **stable_ partition** algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved."},{"content":"The algorithm <bpt id=\"p1\">**</bpt>partition<ept id=\"p1\">**</ept> does not necessarily preserve this original ordering.","pos":[282621,282702],"source":" The algorithm **partition** does not necessarily preserve this original ordering."},{"content":"Example","pos":[282712,282719]},{"pos":[283889,283900],"content":"stable_sort"},{"content":"Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate and preserves the relative ordering of equivalent elements.","pos":[283904,284103]},{"content":"Parameters","pos":[284438,284448]},{"content":"A bidirectional iterator addressing the position of the first element in the range to be sorted.","pos":[284464,284560]},{"content":"A bidirectional iterator addressing the position one past the final element in the range to be sorted.","pos":[284577,284679]},{"content":"User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.","pos":[284696,284828]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[284829,284937],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Remarks","pos":[284947,284954]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[284958,285119]},{"content":"Elements are equivalent, but not necessarily equal, if neither is less than the other.","pos":[285126,285212]},{"content":"The <bpt id=\"p1\">**</bpt>sort<ept id=\"p1\">**</ept> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.","pos":[285213,285329],"source":" The **sort** algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved."},{"content":"The run-time complexity of <ph id=\"ph1\">`stable_sort`</ph> depends on the amount of memory available, but the best case (given sufficient memory) is  <bpt id=\"p1\">*</bpt>O<ept id=\"p1\">*</ept>( <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept> log  <bpt id=\"p3\">*</bpt>N<ept id=\"p3\">*</ept>) and the worst case is  <bpt id=\"p4\">*</bpt>O<ept id=\"p4\">*</ept>(  <bpt id=\"p5\">*</bpt>N<ept id=\"p5\">*</ept> ( log  <bpt id=\"p6\">*</bpt>N<ept id=\"p6\">*</ept> )2 ), where  <bpt id=\"p7\">*</bpt>N<ept id=\"p7\">*</ept><ph id=\"ph2\"> =  </ph><bpt id=\"p8\">*</bpt>last – First.<ept id=\"p8\">*</ept>","pos":[285336,285566],"source":"The run-time complexity of `stable_sort` depends on the amount of memory available, but the best case (given sufficient memory) is  *O*( *N* log  *N*) and the worst case is  *O*(  *N* ( log  *N* )2 ), where  *N* =  *last – First.*"},{"content":"Usually, the <bpt id=\"p1\">**</bpt>sort<ept id=\"p1\">**</ept> algorithm is significantly faster than <ph id=\"ph1\">`stable_sort`</ph>.","pos":[285567,285642],"source":" Usually, the **sort** algorithm is significantly faster than `stable_sort`."},{"content":"Example","pos":[285652,285659]},{"pos":[287514,287518],"content":"swap"},{"content":"The first override exchanges the values of two objects.","pos":[287522,287577]},{"content":"The second override exchanges the values between two arrays of objects.","pos":[287578,287649]},{"content":"Parameters","pos":[287862,287872]},{"content":"For the first override, the first object to have its contents exchanged.","pos":[287886,287958]},{"content":"For the second override, the first array of objects to have its contents exchanged.","pos":[287959,288042]},{"content":"For the first override, the second object to have its contents exchanged.","pos":[288060,288133]},{"content":"For the second override, the second array of objects to have its contents exchanged.","pos":[288134,288218]},{"content":"Remarks","pos":[288228,288235]},{"content":"The first overload is designed to operate on individual objects.","pos":[288239,288303]},{"content":"The second overload swaps the contents of objects between two arrays.","pos":[288304,288373]},{"content":"Example","pos":[288383,288390]},{"pos":[289673,289684],"content":"swap_ranges"},{"content":"Exchanges the elements of one range with the elements of another, equal sized range.","pos":[289688,289772]},{"content":"Parameters","pos":[289983,289993]},{"content":"A forward iterator pointing to the first position of the first range whose elements are to be exchanged.","pos":[290010,290114]},{"content":"A forward iterator pointing to one past the final position of the first range whose elements are to be exchanged.","pos":[290132,290245]},{"content":"A forward iterator pointing to the first position of the second range whose elements are to be exchanged.","pos":[290265,290370]},{"content":"Return Value","pos":[290380,290392]},{"content":"A forward iterator pointing to one past the final position of the second range whose elements are to be exchanged.","pos":[290396,290510]},{"content":"Remarks","pos":[290520,290527]},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.","pos":[290531,290694]},{"content":"The second range has to be as large as the first range.","pos":[290695,290750]},{"content":"The complexity is linear with <ph id=\"ph1\">`last1`</ph> –  <ph id=\"ph2\">`first1`</ph> swaps performed.","pos":[290757,290823],"source":"The complexity is linear with `last1` –  `first1` swaps performed."},{"content":"If elements from containers of the same type are being swapped, them the <ph id=\"ph1\">`swap`</ph> member function from that container should be used, because the member function typically has constant complexity.","pos":[290824,291018],"source":" If elements from containers of the same type are being swapped, them the `swap` member function from that container should be used, because the member function typically has constant complexity."},{"content":"Example","pos":[291028,291035]},{"pos":[292542,292551],"content":"transform"},{"content":"Applies a specified function object to each element in a source range or to a pair of elements from two source ranges and copies the return values of the function object into a destination range.","pos":[292555,292750]},{"content":"Parameters","pos":[293272,293282]},{"content":"An input iterator addressing the position of the first element in the first source range to be operated on.","pos":[293299,293406]},{"content":"An input iterator addressing the position one past the final element in the first source range operated on.","pos":[293424,293531]},{"content":"An input iterator addressing the position of the first element in the second source range to be operated on.","pos":[293551,293659]},{"content":"An output iterator addressing the position of the first element in the destination range.","pos":[293678,293767]},{"content":"User-defined unary function object used in the first version of the algorithm that is applied to each element in the first source range or A user-defined (UD) binary function object used in the second version of the algorithm that is applied pairwise, in a forward order, to the two source ranges.","pos":[293785,294082]},{"content":"Return Value","pos":[294092,294104]},{"content":"An output iterator addressing the position one past the final element in the destination range that is receiving the output elements transformed by the function object.","pos":[294108,294276]},{"content":"Remarks","pos":[294286,294293]},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.","pos":[294297,294465]},{"content":"The destination range must be large enough to contain the transformed source range.","pos":[294466,294549]},{"content":"If <ph id=\"ph1\">`result`</ph> is set equal to  <ph id=\"ph2\">`first1`</ph> in the first version of the algorithm <bpt id=\"p1\">*</bpt>,<ept id=\"p1\">*</ept> then the source and destination ranges will be the same and the sequence will be modified in place.","pos":[294556,294735],"source":"If `result` is set equal to  `first1` in the first version of the algorithm *,* then the source and destination ranges will be the same and the sequence will be modified in place."},{"content":"But the <ph id=\"ph1\">`result`</ph> may not address a position within the range [  <ph id=\"ph2\">`first1`</ph> +1, <ph id=\"ph3\">`last1`</ph>).","pos":[294736,294822],"source":" But the `result` may not address a position within the range [  `first1` +1, `last1`)."},{"pos":[294829,294902],"content":"The complexity is linear with at most ( <ph id=\"ph1\">`last1`</ph> –  <ph id=\"ph2\">`first1`</ph>) comparisons.","source":"The complexity is linear with at most ( `last1` –  `first1`) comparisons."},{"content":"Example","pos":[294912,294919]},{"pos":[297643,297649],"content":"unique"},{"content":"Removes duplicate elements that are adjacent to each other in a specified range.","pos":[297653,297733]},{"content":"Parameters","pos":[298053,298063]},{"content":"A forward iterator addressing the position of the first element in the range to be scanned for duplicate removal.","pos":[298079,298192]},{"content":"A forward iterator addressing the position one past the final element in the range to be scanned for duplicate removal.","pos":[298209,298328]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[298345,298473]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[298474,298582],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[298592,298604]},{"content":"A forward iterator to the new end of the modified sequence that contains no consecutive duplicates, addressing the position one past the last element not removed.","pos":[298608,298770]},{"content":"Remarks","pos":[298780,298787]},{"content":"Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.","pos":[298791,298887]},{"content":"The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.","pos":[298894,299003]},{"content":"The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.","pos":[299010,299171]},{"content":"he number of elements in the sequence is not changed by the algorithm <bpt id=\"p1\">**</bpt>unique<ept id=\"p1\">**</ept> and the elements beyond the end of the modified sequence are dereferenceable but not specified.","pos":[299172,299348],"source":" he number of elements in the sequence is not changed by the algorithm **unique** and the elements beyond the end of the modified sequence are dereferenceable but not specified."},{"pos":[299355,299428],"content":"The complexity is linear, requiring ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) – 1 comparisons.","source":"The complexity is linear, requiring ( `last` –  `first`) – 1 comparisons."},{"content":"List provides a more efficient member function \"unique\", which may perform better.","pos":[299435,299517]},{"content":"These algorithms cannot be used on an associative container.","pos":[299524,299584]},{"content":"Example","pos":[299594,299601]},{"pos":[302136,302147],"content":"unique_copy"},{"content":"Copies elements from a source range into a destination range except for the duplicate elements that are adjacent to each other.","pos":[302151,302278]},{"content":"Parameters","pos":[302686,302696]},{"content":"A forward iterator addressing the position of the first element in the source range to be copied.","pos":[302712,302809]},{"content":"A forward iterator addressing the position one past the final element in the source range to be copied.","pos":[302826,302929]},{"content":"An output iterator addressing the position of the first element in the destination range that is receiving the copy with consecutive duplicates removed.","pos":[302948,303100]},{"content":"User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.","pos":[303117,303245]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[303246,303354],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[303364,303376]},{"content":"An output iterator addressing the position one past the final element in the destination range that is receiving the copy with consecutive duplicates removed.","pos":[303380,303538]},{"content":"Remarks","pos":[303548,303555]},{"content":"Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.","pos":[303559,303655]},{"content":"The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.","pos":[303662,303771]},{"content":"The ranges referenced must be valid; all pointers must be dereferenceable and within a sequence the last position is reachable from the first by incrementation.","pos":[303778,303938]},{"pos":[303945,304014],"content":"The complexity is linear, requiring ( <ph id=\"ph1\">`last`</ph> –  <ph id=\"ph2\">`first`</ph>) comparisons.","source":"The complexity is linear, requiring ( `last` –  `first`) comparisons."},{"content":"Example","pos":[304024,304031]},{"pos":[306100,306111],"content":"upper_bound"},{"content":"Finds the position of the first element in an ordered range that has a value that is greater than a specified value, where the ordering criterion may be specified by a binary predicate.","pos":[306115,306300]},{"content":"Parameters","pos":[306708,306718]},{"content":"The position of the first element in the range to be searched.","pos":[306733,306795]},{"content":"The position one past the final element in the range to be searched.","pos":[306812,306880]},{"content":"The value in the ordered range that needs to be exceeded by the value of the element addressed by the iterator returned.","pos":[306898,307018]},{"content":"User-defined predicate function object that defines sense in which one element is less than another.","pos":[307035,307135]},{"content":"A binary predicate takes two arguments and returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> when satisfied and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> when not satisfied.","pos":[307136,307244],"source":" A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied."},{"content":"Return Value","pos":[307254,307266]},{"content":"A forward iterator to the position of the first element that has a value greater than a specified value.","pos":[307270,307374]},{"content":"Remarks","pos":[307384,307391]},{"content":"The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.","pos":[307395,307576]},{"pos":[307583,307726],"content":"A sorted range is a precondition of the use of <ph id=\"ph1\">`upper_bound`</ph> and where the ordering criterion is the same as specified by the binary predicate.","source":"A sorted range is a precondition of the use of `upper_bound` and where the ordering criterion is the same as specified by the binary predicate."},{"pos":[307733,307776],"content":"The range is not modified by <ph id=\"ph1\">`upper_bound`</ph>.","source":"The range is not modified by `upper_bound`."},{"content":"The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[307783,308036]},{"content":"This results in an ordering between the nonequivalent elements","pos":[308037,308099]},{"pos":[308106,308262],"content":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id=\"ph1\">`last - first`</ph>).","source":"The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last - first`)."},{"content":"Example","pos":[308272,308279]},{"content":"See Also","pos":[310968,310976]},{"content":"algorithm&gt;","pos":[310984,310994],"source":"algorithm>"}],"content":"---\ntitle: \"&lt;algorithm&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"algorithm/std::adjacent_find\"\n  - \"std::adjacent_find\"\n  - \"adjacent_find\"\n  - \"algorithm/std::all_of\"\n  - \"std::all_of\"\n  - \"all_of\"\n  - \"algorithm/std::any_of\"\n  - \"std::any_of\"\n  - \"any_of\"\n  - \"algorithm/std::binary_search\"\n  - \"std::binary_search\"\n  - \"binary_search\"\n  - \"algorithm/std::copy\"\n  - \"std::copy\"\n  - \"copy\"\n  - \"algorithm/std::copy_backward\"\n  - \"std::copy_backward\"\n  - \"copy_backward\"\n  - \"algorithm/std::copy_if\"\n  - \"std::copy_if\"\n  - \"copy_if\"\n  - \"algorithm/std::copy_n\"\n  - \"std::copy_n\"\n  - \"copy_n\"\n  - \"algorithm/std::equal\"\n  - \"std::equal\"\n  - \"equal\"\n  - \"algorithm/std::equal_range\"\n  - \"std::equal_range\"\n  - \"equal_range\"\n  - \"algorithm/std::fill\"\n  - \"std::fill\"\n  - \"fill\"\n  - \"algorithm/std::fill_n\"\n  - \"std::fill_n\"\n  - \"fill_n\"\n  - \"algorithm/std::find\"\n  - \"std::find\"\n  - \"find\"\n  - \"algorithm/std::find_end\"\n  - \"std::find_end\"\n  - \"find_end\"\n  - \"algorithm/std::find_first_of\"\n  - \"std::find_first_of\"\n  - \"find_first_of\"\n  - \"algorithm/std::find_if\"\n  - \"std::find_if\"\n  - \"find_if\"\n  - \"algorithm/std::find_if_not\"\n  - \"std::find_if_not\"\n  - \"find_if_not\"\n  - \"algorithm/std::for_each\"\n  - \"std::for_each\"\n  - \"for_each\"\n  - \"algorithm/std::generate\"\n  - \"std::generate\"\n  - \"generate\"\n  - \"algorithm/std::generate_n\"\n  - \"std::generate_n\"\n  - \"generate_n\"\n  - \"algorithm/std::includes\"\n  - \"std::includes\"\n  - \"includes\"\n  - \"algorithm/std::inplace_merge\"\n  - \"std::inplace_merge\"\n  - \"inplace_merge\"\n  - \"algorithm/std::is_heap\"\n  - \"std::is_heap\"\n  - \"is_heap\"\n  - \"algorithm/std::is_heap_until\"\n  - \"std::is_heap_until\"\n  - \"is_heap_until\"\n  - \"algorithm/std::is_partitioned\"\n  - \"std::is_partitioned\"\n  - \"is_partitioned\"\n  - \"algorithm/std::is_permutation\"\n  - \"std::is_permutation\"\n  - \"is_permutation\"\n  - \"algorithm/std::is_sorted\"\n  - \"std::is_sorted\"\n  - \"is_sorted\"\n  - \"algorithm/std::is_sorted_until\"\n  - \"std::is_sorted_until\"\n  - \"is_sorted_until\"\n  - \"algorithm/std::iter_swap\"\n  - \"std::iter_swap\"\n  - \"iter_swap\"\n  - \"algorithm/std::lexicographical_compare\"\n  - \"std::lexicographical_compare\"\n  - \"lexicographical_compare\"\n  - \"algorithm/std::lower_bound\"\n  - \"std::lower_bound\"\n  - \"lower_bound\"\n  - \"algorithm/std::make_heap\"\n  - \"std::make_heap\"\n  - \"make_heap\"\n  - \"algorithm/std::max\"\n  - \"std::max\"\n  - \"max\"\n  - \"algorithm/std::max_element\"\n  - \"std::max_element\"\n  - \"max_element\"\n  - \"algorithm/std::merge\"\n  - \"std::merge\"\n  - \"merge\"\n  - \"algorithm/std::min\"\n  - \"std::min\"\n  - \"min\"\n  - \"algorithm/std::minmax\"\n  - \"std::minmax\"\n  - \"minmax\"\n  - \"algorithm/std::minmax_element\"\n  - \"std::minmax_element\"\n  - \"minmax_element\"\n  - \"algorithm/std::min_element\"\n  - \"std::min_element\"\n  - \"min_element\"\n  - \"algorithm/std::mismatch\"\n  - \"std::mismatch\"\n  - \"mismatch\"\n  - \"algorithm/std::move\"\n  - \"std::move\"\n  - \"move\"\n  - \"algorithm/std::move_backward\"\n  - \"std::move_backward\"\n  - \"move_backward\"\n  - \"algorithm/std::next_permutation\"\n  - \"std::next_permutation\"\n  - \"next_permutation\"\n  - \"algorithm/std::none_of\"\n  - \"std::none_of\"\n  - \"none_of\"\n  - \"algorithm/std::nth_element\"\n  - \"std::nth_element\"\n  - \"nth_element\"\n  - \"algorithm/std::partial_sort\"\n  - \"std::partial_sort\"\n  - \"partial_sort\"\n  - \"algorithm/std::partial_sort_copy\"\n  - \"std::partial_sort_copy\"\n  - \"partial_sort_copy\"\n  - \"algorithm/std::partition\"\n  - \"std::partition\"\n  - \"partition\"\n  - \"algorithm/std::partition_point\"\n  - \"std::partition_point\"\n  - \"partition_point\"\n  - \"algorithm/std::pop_heap\"\n  - \"std::pop_heap\"\n  - \"pop_heap\"\n  - \"algorithm/std::prev_permutation\"\n  - \"std::prev_permutation\"\n  - \"prev_permutation\"\n  - \"algorithm/std::push_heap\"\n  - \"std::push_heap\"\n  - \"push_heap\"\n  - \"algorithm/std::random_shuffle\"\n  - \"std::random_shuffle\"\n  - \"random_shuffle\"\n  - \"algorithm/std::remove\"\n  - \"std::remove\"\n  - \"remove\"\n  - \"algorithm/std::remove_copy\"\n  - \"std::remove_copy\"\n  - \"remove_copy\"\n  - \"algorithm/std::remove_copy_if\"\n  - \"std::remove_copy_if\"\n  - \"remove_copy_if\"\n  - \"algorithm/std::remove_if\"\n  - \"std::remove_if\"\n  - \"remove_if\"\n  - \"algorithm/std::replace\"\n  - \"std::replace\"\n  - \"replace\"\n  - \"algorithm/std::replace_copy\"\n  - \"std::replace_copy\"\n  - \"replace_copy\"\n  - \"algorithm/std::replace_copy_if\"\n  - \"std::replace_copy_if\"\n  - \"replace_copy_if\"\n  - \"algorithm/std::replace_if\"\n  - \"std::replace_if\"\n  - \"replace_if\"\n  - \"algorithm/std::reverse\"\n  - \"std::reverse\"\n  - \"reverse\"\n  - \"algorithm/std::reverse_copy\"\n  - \"std::reverse_copy\"\n  - \"reverse_copy\"\n  - \"algorithm/std::rotate\"\n  - \"std::rotate\"\n  - \"rotate\"\n  - \"algorithm/std::rotate_copy\"\n  - \"std::rotate_copy\"\n  - \"rotate_copy\"\n  - \"algorithm/std::search\"\n  - \"std::search\"\n  - \"search\"\n  - \"algorithm/std::search_n\"\n  - \"std::search_n\"\n  - \"search_n\"\n  - \"algorithm/std::set_difference\"\n  - \"std::set_difference\"\n  - \"set_difference\"\n  - \"algorithm/std::set_intersection\"\n  - \"std::set_intersection\"\n  - \"set_intersection\"\n  - \"algorithm/std::set_symmetric_difference\"\n  - \"std::set_symmetric_difference\"\n  - \"set_symmetric_difference\"\n  - \"algorithm/std::set_union\"\n  - \"std::set_union\"\n  - \"set_union\"\n  - \"algorithm/std::shuffle\"\n  - \"std::shuffle\"\n  - \"shuffle\"\n  - \"algorithm/std::sort\"\n  - \"std::sort\"\n  - \"sort\"\n  - \"algorithm/std::sort_heap\"\n  - \"std::sort_heap\"\n  - \"sort_heap\"\n  - \"algorithm/std::stable_partition\"\n  - \"std::stable_partition\"\n  - \"stable_partition\"\n  - \"algorithm/std::stable_sort\"\n  - \"std::stable_sort\"\n  - \"stable_sort\"\n  - \"algorithm/std::swap_ranges\"\n  - \"std::swap_ranges\"\n  - \"swap_ranges\"\n  - \"algorithm/std::transform\"\n  - \"std::transform\"\n  - \"transform\"\n  - \"algorithm/std::unique\"\n  - \"std::unique\"\n  - \"unique\"\n  - \"algorithm/std::unique_copy\"\n  - \"std::unique_copy\"\n  - \"unique_copy\"\n  - \"algorithm/std::upper_bound\"\n  - \"std::upper_bound\"\n  - \"upper_bound\"\n  - \"xutility/std::copy\"\n  - \"xutility/std::copy_backward\"\n  - \"xutility/std::copy_n\"\n  - \"xutility/std::count\"\n  - \"std::count\"\n  - \"count\"\n  - \"xutility/std::equal\"\n  - \"xutility/std::fill\"\n  - \"xutility/std::fill_n\"\n  - \"xutility/std::find\"\n  - \"xutility/std::is_permutation\"\n  - \"xutility/std::lexicographical_compare\"\n  - \"xutility/std::move\"\n  - \"xutility/std::move_backward\"\n  - \"xutility/std::reverse\"\n  - \"xutility/std::rotate\"\nms.assetid: c10b0c65-410c-4c83-abf8-8b7f61bba8d0\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\n---\n# &lt;algorithm&gt; functions\n||||  \n|-|-|-|  \n|[move](#alg_move)|[adjacent_find](#adjacent_find)|[all_of](#all_of)|  \n|[any_of](#any_of)|[binary_search](#binary_search)|[copy](#copy)|  \n|[copy_backward](#copy_backward)|[copy_if](#copy_if)|[copy_n](#copy_n)|  \n|[count](#count)|[count_if](#count_if)|[equal](#equal)|  \n|[equal_range](#equal_range)|[fill](#fill)|[fill_n](#fill_n)|  \n|[find](#find)|[find_end](#find_end)|[find_first_of](#find_first_of)|  \n|[find_if](#find_if)|[find_if_not](#find_if_not)|[for_each](#for_each)|  \n|[generate](#generate)|[generate_n](#generate_n)|[includes](#includes)|  \n|[inplace_merge](#inplace_merge)|[is_heap](#is_heap)|[is_heap_until](#is_heap_until)|  \n|[is_partitioned](#is_partitioned)|[is_permutation](#is_permutation)|[is_sorted](#is_sorted)|  \n|[is_sorted_until](#is_sorted_until)|[iter_swap](#iter_swap)|[lexicographical_compare](#lexicographical_compare)|  \n|[lower_bound](#lower_bound)|[make_heap](#make_heap)|[max](#max)|  \n|[max_element](#max_element)|[merge](#merge)|[min](#min)|  \n|[min_element](#min_element)|[minmax](#minmax)|[minmax_element](#minmax_element)|  \n|[mismatch](#mismatch)|[move_backward](#move_backward)|[next_permutation](#next_permutation)|  \n|[none_of](#none_of)|[nth_element](#nth_element)|[partial_sort](#partial_sort)|  \n|[partial_sort_copy](#partial_sort_copy)|[partition](#partition)|[partition_copy](#partition_copy)|  \n|[partition_point](#partition_point)|[pop_heap](#pop_heap)|[prev_permutation](#prev_permutation)|  \n|[push_heap](#push_heap)|[random_shuffle](#random_shuffle)|[remove](#remove)|  \n|[remove_copy](#remove_copy)|[remove_copy_if](#remove_copy_if)|[remove_if](#remove_if)|  \n|[replace](#replace)|[replace_copy](#replace_copy)|[replace_copy_if](#replace_copy_if)|  \n|[replace_if](#replace_if)|[reverse](#reverse)|[reverse_copy](#reverse_copy)|  \n|[rotate](#rotate)|[rotate_copy](#rotate_copy)|[search](#search)|  \n|[search_n](#search_n)|[set_difference](#set_difference)|[set_intersection](#set_intersection)|  \n|[set_symmetric_difference](#set_symmetric_difference)|[set_union](#set_union)|[sort](#sort)|  \n|[sort_heap](#sort_heap)|[stable_partition](#stable_partition)|[stable_sort](#stable_sort)|  \n|[std::shuffle](#std__shuffle)|[swap](#swap)|[swap_ranges](#swap_ranges)|  \n|[transform](#transform)|[unique](#unique)|[unique_copy](#unique_copy)|  \n|[upper_bound](#upper_bound)|  \n  \n##  <a name=\"adjacent_find\"></a>  adjacent_find  \n Searches for two adjacent elements that are either equal or satisfy a specified condition.  \n  \n```  \ntemplate<class ForwardIterator>  \n    ForwardIterator adjacent_find(  \n        ForwardIterator first,   \n        ForwardIterator last);\n  \ntemplate<class ForwardIterator , class BinaryPredicate>  \n    ForwardIterator adjacent_find(  \n        ForwardIterator first,   \n        ForwardIterator last,   \n        BinaryPredicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n `comp`  \n The binary predicate giving the condition to be satisfied by the values of the adjacent elements in the range being searched.  \n  \n### Return Value  \n A forward iterator to the first element of the adjacent pair that are either equal to each other (in the first version) or that satisfy the condition given by the binary predicate (in the second version), provided that such a pair of elements is found. Otherwise, an iterator pointing to `last` is returned.  \n  \n### Remarks  \n The `adjacent_find` algorithm is a nonmutating sequence algorithm. The range to be searched must be valid; all pointers must be dereferenceable and the last position is reachable from the first by incrementation. The time complexity of the algorithm is linear in the number of elements contained in the range.  \n  \n The `operator==` used to determine the match between elements must impose an equivalence relation between its operands.  \n  \n### Example  \n  \n```cpp  \n// alg_adj_fnd.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Returns whether second element is twice the first  \nbool twice (int elem1, int elem2 )  \n{  \n   return elem1 * 2 == elem2;  \n}  \n  \nint main()   \n{  \n   using namespace std;  \n   list <int> L;  \n   list <int>::iterator Iter;  \n   list <int>::iterator result1, result2;  \n  \n   L.push_back( 50 );  \n   L.push_back( 40 );  \n   L.push_back( 10 );  \n   L.push_back( 20 );  \n   L.push_back( 20 );  \n  \n   cout << \"L = ( \" ;  \n   for ( Iter = L.begin( ) ; Iter != L.end( ) ; Iter++ )  \n      cout << *Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   result1 = adjacent_find( L.begin( ), L.end( ) );  \n   if ( result1 == L.end( ) )  \n      cout << \"There are not two adjacent elements that are equal.\"  \n           << endl;  \n   else  \n      cout << \"There are two adjacent elements that are equal.\"  \n           << \"\\n They have a value of \"  \n           <<  *( result1 ) << \".\" << endl;  \n  \n   result2 = adjacent_find( L.begin( ), L.end( ), twice );  \n   if ( result2 == L.end( ) )  \n      cout << \"There are not two adjacent elements where the \"  \n           << \" second is twice the first.\" << endl;  \n   else  \n      cout << \"There are two adjacent elements where \"  \n           << \"the second is twice the first.\"  \n           << \"\\n They have values of \" << *(result2++);  \n      cout << \" & \" << *result2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nL = ( 50 40 10 20 20 )  \nThere are two adjacent elements that are equal.  \n They have a value of 20.  \nThere are two adjacent elements where the second is twice the first.  \n They have values of 10 & 20.  \n```  \n  \n##  <a name=\"all_of\"></a>  all_of  \n Returns `true` when a condition is present at each element in the given range.  \n  \n```  \ntemplate<class InputIterator, class Predicate>  \n    bool all_of(  \n        InputIterator first,   \n        InputIterator last,   \n        BinaryPredicatecomp);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates where to start to check for a condition. The iterator marks where a range of elements starts.  \n  \n `last`  \n An input iterator that indicates the end of the range of elements to check for a condition.  \n  \n `comp`  \n A condition to test for. This is a user-defined predicate function object that defines the condition to be satisfied by an element being checked. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Return Value  \n Returns `true` if the condition is detected at each element in the indicated range, and `false` if the condition is not detected at least one time.  \n  \n### Remarks  \n The template function returns `true` only if, for each `N` in the range `[0,Last - first)`, the predicate `comp(*(_First + N))` is `true`.  \n  \n##  <a name=\"any_of\"></a>  any_of  \n Returns `true` when a condition is present at least once in the specified range of elements.  \n  \n```  \ntemplate<class InputIterator, class UnaryPredicate>  \n    bool any_of(  \n        InputIterator first,   \n        InputIterator last,   \n        UnaryPredicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates where to start checking a range of elements for a condition.  \n  \n `last`  \n An input iterator that indicates the end of the range of elements to check for a condition.  \n  \n `comp`  \n A condition to test for. This is provided by a user-defined predicate function object. The predicate defines the condition to be satisfied by the element being tested. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Return Value  \n Returns `true` if the condition is detected at least once in the indicated range, `false` if the condition is never detected.  \n  \n### Remarks  \n The template function returns `true` only if, for some `N` in the range  \n  \n `[0,`  `last`  `-`   `first` `)`, the predicate `comp``(*(` `first` `+ N))` is true.  \n  \n##  <a name=\"binary_search\"></a>  binary_search  \n Tests whether there is an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.  \n  \n```  \ntemplate<class ForwardIterator, class Type>      \n    bool binary_search(\n        ForwardIterator first, \n        ForwardIterator last, \n        const Type& value);  \n  \ntemplate<class ForwardIterator,  class Type,  class BinaryPredicate>  \n    bool binary_search(\n        ForwardIterator first, \n        ForwardIterator last, \n        const Type& value, \n        BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n `first`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n `value`  \n The value required to be matched by the value of the element or that must satisfy the condition with the element value specified by the binary predicate.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns `true`when satisfied and `false` when not satisfied.  \n  \n### Return Value  \n `true` if an element is found in the range that is equal or equivalent to the specified value; otherwise, `false`.  \n  \n### Remarks  \n The sorted source range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.  \n  \n The sorted range must each be arranged as a precondition to the application of the `binary_search` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The source ranges are not modified by `binary_search`.  \n  \n The value types of the forward iterators need to be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements  \n  \n The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last` – `first`).  \n  \n### Example  \n  \n```cpp  \n// alg_bin_srch.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser( int elem1, int elem2 )  \n{  \n    if (elem1 < 0)  \n        elem1 = - elem1;  \n    if (elem2 < 0)  \n        elem2 = - elem2;  \n    return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n    using namespace std;  \n  \n    list <int> List1;  \n  \n    List1.push_back( 50 );  \n    List1.push_back( 10 );  \n    List1.push_back( 30 );  \n    List1.push_back( 20 );  \n    List1.push_back( 25 );  \n    List1.push_back( 5 );  \n  \n    List1.sort();  \n  \n    cout << \"List1 = ( \" ;  \n    for ( auto Iter : List1 )  \n        cout << Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    // default binary search for 10  \n    if( binary_search(List1.begin(), List1.end(), 10) )  \n        cout << \"There is an element in list List1 with a value equal to 10.\"  \n        << endl;  \n    else  \n        cout << \"There is no element in list List1 with a value equal to 10.\"  \n        << endl;  \n  \n    // a binary_search under the binary predicate greater  \n    List1.sort(greater<int>());  \n    if( binary_search(List1.begin(), List1.end(), 10, greater<int>()) )  \n        cout << \"There is an element in list List1 with a value greater than 10 \"  \n        << \"under greater than.\" << endl;  \n    else  \n        cout << \"No element in list List1 with a value greater than 10 \"  \n        << \"under greater than.\" << endl;  \n  \n    // a binary_search under the user-defined binary predicate mod_lesser  \n    vector<int> v1;  \n  \n    for( auto i = -2; i <= 4; ++i )  \n    {  \n        v1.push_back(i);  \n    }  \n  \n    sort(v1.begin(), v1.end(), mod_lesser);  \n  \n    cout << \"Ordered using mod_lesser, vector v1 = ( \" ;  \n    for( auto Iter : v1 )  \n        cout << Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    if( binary_search(v1.begin(), v1.end(), -3, mod_lesser) )  \n        cout << \"There is an element with a value equivalent to -3 \"  \n        << \"under mod_lesser.\" << endl;  \n    else  \n        cout << \"There is not an element with a value equivalent to -3 \"  \n        << \"under mod_lesser.\" << endl;  \n}   \n```  \n  \n##  <a name=\"copy\"></a>  copy  \n Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator>  \n    OutputIterator copy(\n        InputIterator first, \n        InputIterator last, \n        OutputIterator destBeg);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the source range.  \n  \n `last`  \n An input iterator addressing the position that is one past the final element in the source range.  \n  \n *destBeg*  \n An output iterator addressing the position of the first element in the destination range.  \n  \n### Return Value  \n An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses `result` + ( `last` –  `first` ).  \n  \n### Remarks  \n The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.  \n  \n Because the algorithm copies the source elements in order beginning with the first element, the destination range can overlap with the source range provided the `last` position of the source range is not contained in the destination range. **copy** can be used to shift elements to the left but not the right, unless there is no overlap between the source and destination ranges. To shift to the right any number of positions, use the [copy_backward](../standard-library/algorithm-functions.md#copy_backward) algorithm.  \n  \n The **copy** algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range. It cannot be used to create new elements and cannot insert elements into an empty container directly.  \n  \n### Example  \n  \n```cpp  \n// alg_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n      v1.push_back( 10 * i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 10 ; ii++ )  \n      v2.push_back( 3 * ii );  \n  \n   cout << \"v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To copy the first 3 elements of v1 into the middle of v2  \n   copy( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 4 );  \n  \n   cout << \"v2 with v1 insert = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To shift the elements inserted into v2 two positions  \n   // to the left  \n   copy( v2.begin( )+4, v2.begin( ) + 7, v2.begin( ) + 2 );  \n  \n   cout << \"v2 with shifted insert = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nv1 = ( 0 10 20 30 40 50 )  \nv2 = ( 0 3 6 9 12 15 18 21 24 27 30 )  \nv2 with v1 insert = ( 0 3 6 9 0 10 20 21 24 27 30 )  \nv2 with shifted insert = ( 0 3 0 10 20 10 20 21 24 27 30 )  \n```  \n  \n##  <a name=\"copy_backward\"></a>  copy_backward  \n Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.  \n  \n```  \ntemplate<class BidirectionalIterator1, class BidirectionalIterator2>  \n    BidirectionalIterator2 copy_backward(\n        BidirectionalIterator1 first, \n        BidirectionalIterator1 last, \n        BidirectionalIterator2 destEnd);  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator addressing the position of the first element in the source range.  \n  \n `last`  \n A bidirectional iterator addressing the position that is one past the final element in the source range.  \n  \n `destEnd`  \n A bidirectional iterator addressing the position of one past the final element in the destination range.  \n  \n### Return Value  \n An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses `destEnd` – ( `last` –  `first` ).  \n  \n### Remarks  \n The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.  \n  \n The `copy_backward` algorithm imposes more stringent requirements than that the copy algorithm. Both its input and output iterators must be bidirectional.  \n  \n The `copy_backward` and [move_backward](../standard-library/algorithm-functions.md#move_backward) algorithms are the only Standard Template Library algorithms designating the output range with an iterator pointing to the end of the destination range.  \n  \n Because the algorithm copies the source elements in order beginning with the last element, the destination range can overlap with the source range provided the  `first` position of the source range is not contained in the destination range. `copy_backward` can be used to shift elements to the right but not the left, unless there is no overlap between the source and destination ranges. To shift to the left any number of positions, use the [copy](../standard-library/algorithm-functions.md#copy) algorithm.  \n  \n The `copy_backward` algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range. It cannot be used to create new elements and cannot insert elements into an empty container directly.  \n  \n### Example  \n  \n```cpp  \n// alg_copy_bkwd.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; ++i )  \n      v1.push_back( 10 * i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 10 ; ++ii )  \n      v2.push_back( 3 * ii );  \n  \n   cout << \"v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; ++Iter1 )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To copy_backward the first 3 elements of v1 into the middle of v2  \n   copy_backward( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 7 );  \n  \n   cout << \"v2 with v1 insert = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To shift the elements inserted into v2 two positions  \n   // to the right  \n   copy_backward( v2.begin( )+4, v2.begin( ) + 7, v2.begin( ) + 9 );  \n  \n   cout << \"v2 with shifted insert = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n##  <a name=\"copy_if\"></a>  copy_if  \n In a range of elements, copies the elements that are `true` for the specified condition.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator, class BinaryPredicate>  \n    OutputIterator copy_if(  \n        InputIterator first,   \n        InputIterator last,  \n        OutputIterator dest,  \n        Predicate pred);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates the start of a range to check for the condition.  \n  \n `last`  \n An input iterator that indicates the end of the range.  \n  \n `dest`  \n The output iterator that indicates the destination for the copied elements.  \n  \n `_Pred`  \n The condition against which every element in the range is tested. This condition is provided by a user-defined predicate function object. A predicate takes one argument and returns `true` or `false`.  \n  \n### Return Value  \n An output iterator that equals `dest` incremented once for each element that fulfills the condition. In other words, the return value minus `dest` equals the number of copied elements.  \n  \n### Remarks  \n The template function evaluates  \n  \n `if (_Pred(*_First + N)) * dest++ = *(_First + N))`  \n  \n once for each `N` in the range `[0, last - first)`, for strictly increasing values of `N` starting with the lowest value. If `dest` and  `first` designate regions of storage, `dest` must not be in the range `[` `first``,` `last``)`.  \n  \n##  <a name=\"copy_n\"></a>  copy_n  \n Copies a specified number of elements.  \n  \n```  \ntemplate<class InputIterator, class Size, class OutputIterator>  \n    OutputIterator copy_n(\n        InputIterator first, \n        Size count, \n        OutputIterator dest);  \n```  \n  \n### Parameters  \n `first`  \n An input iterator that indicates where to copy elements from.  \n  \n `count`  \n A signed or unsigned integer type specifying the number of elements to copy.  \n  \n `dest`  \n An output iterator that indicates where to copy elements to.  \n  \n### Return Value  \n Returns an output iterator where elements have been copied to. It is the same as the returned value of the third parameter, `dest`.  \n  \n### Remarks  \n The template function evaluates `*(dest + N) = *(first + N))` once for each `N` in the range `[0,` `count``)`, for strictly increasing values of `N` starting with the lowest value. It then returns `dest` `+ N`. If `dest` and `first` designate regions of storage, `dest` must not be in the range `[``first``,` `Last``)`.  \n  \n##  <a name=\"count\"></a>  count  \n Returns the number of elements in a range whose values match a specified value.  \n  \n```  \ntemplate<class InputIterator, class Type> \n    typename iterator_traits<InputIterator>::difference_type count(\n        InputIterator first, \n        InputIterator last, \n        const Type& val);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the range to be traversed.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range to be traversed.  \n  \n `val`  \n The value of the elements to be counted.  \n  \n### Return Value  \n The difference type of the **InputIterator** that counts the number of elements in the range [  `first`, `last` ) that have value `val`.  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n This algorithm is generalized to count elements that satisfy any predicate with the template function [count_if](../standard-library/algorithm-functions.md#count_if).  \n  \n### Example  \n  \n```cpp  \n// alg_count.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace std;  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    v1.push_back(10);  \n    v1.push_back(20);  \n    v1.push_back(10);  \n    v1.push_back(40);  \n    v1.push_back(10);  \n  \n    cout << \"v1 = ( \" ;  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    vector<int>::iterator::difference_type result;  \n    result = count(v1.begin(), v1.end(), 10);  \n    cout << \"The number of 10s in v2 is: \" << result << \".\" << endl;  \n}  \n```  \n  \n```Output  \nv1 = ( 10 20 10 40 10 )  \nThe number of 10s in v2 is: 3.  \n```  \n  \n##  <a name=\"count_if\"></a>  count_if  \n Returns the number of elements in a range whose values satisfy a specified condition.  \n  \n```  \ntemplate<class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type count_if(\n        InputIterator first, \n        InputIterator last, \n        Predicate pred);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range to be searched.  \n  \n `_Pred`  \n User-defined predicate function object that defines the condition to be satisfied if an element is to be counted. A predicate takes single argument and returns **true** or **false**.  \n  \n### Return Value  \n The number of elements that satisfy the condition specified by the predicate.  \n  \n### Remarks  \n This template function is a generalization of the algorithm [count](../standard-library/algorithm-functions.md#count), replacing the predicate \"equals a specific value\" with any predicate.  \n  \n### Example  \n  \n```cpp  \n// alg_count_if.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater10(int value)  \n{  \n    return value >10;  \n}  \n  \nint main()  \n{  \n    using namespace std;  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    v1.push_back(10);  \n    v1.push_back(20);  \n    v1.push_back(10);  \n    v1.push_back(40);  \n    v1.push_back(10);  \n  \n    cout << \"v1 = ( \";  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    vector<int>::iterator::difference_type result1;  \n    result1 = count_if(v1.begin(), v1.end(), greater10);  \n    cout << \"The number of elements in v1 greater than 10 is: \"  \n         << result1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nv1 = ( 10 20 10 40 10 )  \nThe number of elements in v1 greater than 10 is: 2.  \n```  \n  \n##  <a name=\"equal\"></a>  equal  \n Compares two ranges element by element for equality or equivalence in a sense specified by a binary predicate.  \n  \n Use `std::equal` when comparing elements in different container types (for example `vector` and `list`) or when comparing different element types, or when you need to compare sub-ranges of containers. Otherwise, when comparing elements of the same type in the same container type, use the non-member `operator==` that is provided for each container.  \n  \n Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.  \n  \n```  \ntemplate<class InputIterator1, class InputIterator2>  \nbool equal(  \n    InputIterator1  First1,  \n    InputIterator1  Last1,  \n    InputIterator2  First2);   \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate>  \nbool equal(  \n    InputIterator1  First1,  \n    InputIterator1  Last1,  \n    InputIterator2  First2,  \n    BinaryPredicate Comp); // C++14  \n  \ntemplate<class InputIterator1, class InputIterator2>  \nbool equal(  \n    InputIterator1  First1,  \n    InputIterator1  Last1,  \n    InputIterator2  First2,  \n    InputIterator2  Last2);  \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate>  \nbool equal(  \n    InputIterator1  First1,  \n    InputIterator1  Last1,  \n    InputIterator2  First2,  \n    InputIterator2  Last2,  \n    BinaryPredicate Comp);  \n```  \n  \n### Parameters  \n `First1`  \n An input iterator addressing the position of the first element in the first range to be tested.  \n  \n `Last1`  \n An input iterator addressing the position one past the last element in the first range to be tested.  \n  \n `First2`  \n An input iterator addressing the position of the first element in the second range to be tested.  \n  \n `First2`  \n An input iterator addressing the position of one past the last element in the second range to be tested.  \n  \n `Comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n **true** if and only if the ranges are identical or equivalent under the binary predicate when compared element by element; otherwise, **false**.  \n  \n### Remarks  \n The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.  \n  \n If the two ranges are equal length, then the time complexity of the algorithm is linear in the number of elements contained in the range. Otherwise the function immediately returns `false`.  \n  \n Neither the `operator==` nor the user-defined predicate is required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.  \n  \n### Example  \n  \n```cpp  \n#include <iostream>  \n#include <vector>  \n#include <algorithm>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    vector<int> v1 { 0, 5, 10, 15, 20, 25 };  \n    vector<int> v2 { 0, 5, 10, 15, 20, 25 };  \n    vector<int> v3 { 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50 };  \n  \n    // Using range-and-a-half equal:  \n    bool b = equal(v1.begin(), v1.end(), v2.begin());  \n    cout << \"v1 and v2 are equal: \"  \n       << b << endl; // true, as expected  \n  \n    b = equal(v1.begin(), v1.end(), v3.begin());  \n    cout << \"v1 and v3 are equal: \"  \n       << b << endl; // true, surprisingly  \n  \n    // Using dual-range equal:  \n    b = equal(v1.begin(), v1.end(), v3.begin(), v3.end());  \n    cout << \"v1 and v3 are equal with dual-range overload: \"  \n       << b << endl; // false  \n  \n    return 0;  \n}  \n  \n```  \n  \n##  <a name=\"equal_range\"></a>  equal_range  \n Given an ordered range, finds the subrange in which all elements are equivalent to a given value.  \n  \n```  \ntemplate<class ForwardIterator, class Type>  \npair<ForwardIterator, ForwardIterator> equal_range(  \n    ForwardIterator first,  \n    ForwardIterator last,   \n    const Type& val);\n\ntemplate<class ForwardIterator, class Type, class Predicate>  \npair<ForwardIterator, ForwardIterator> equal_range(  \n    ForwardIterator first,  \n    ForwardIterator last,   \n    const Type& val,   \n    Predicate comp);  \n```  \n  \n### Parameters  \n `first`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n `val`  \n The value being searched for in the ordered range.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is less than another.  \n  \n### Return Value  \n A pair of forward iterators that specify a subrange, contained within the range searched, in which all of the elements are equivalent to `val` in the sense defined by the binary predicate used (either `comp` or the default, less-than).  \n  \n If no elements in the range are equivalent to `val`, the returned pair of forward iterators are equal and specify the point where `val` could be inserted without disturbing the order of the range.  \n  \n### Remarks  \n The first iterator of the pair returned by the algorithm is [lower_bound](../standard-library/algorithm-functions.md#lower_bound), and the second iterator is [upper_bound](../standard-library/algorithm-functions.md#upper_bound).  \n  \n The range must be sorted according to the predicate provided to `equal_range`. For example, if you are going to use the greater-than predicate, the range must be sorted in descending order.  \n  \n Elements in the possibly empty subrange defined by the pair of iterators returned by `equal_range` will be equivalent to `val` in the sense defined by the predicate used.  \n  \n The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last` – `first`).  \n  \n### Example  \n  \n```cpp  \n// alg_equal_range.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // greater<int>()  \n#include <iostream>  \n#include <string>  \nusing namespace std;  \n  \ntemplate<class T> void dump_vector( const vector<T>& v, pair< typename vector<T>::iterator, typename vector<T>::iterator > range )  \n{  \n    // prints vector v with range delimited by [ and ]  \n  \n    for( typename vector<T>::const_iterator i = v.begin(); i != v.end(); ++i )  \n    {  \n        if( i == range.first )  \n        {  \n            cout << \"[ \";  \n        }  \n        if( i == range.second )  \n        {  \n            cout << \"] \";  \n        }  \n  \n        cout << *i << \" \";  \n    }  \n    cout << endl;  \n}  \n  \ntemplate<class T> void equal_range_demo( const vector<T>& original_vector, T val )  \n{  \n    vector<T> v(original_vector);  \n  \n    sort( v.begin(), v.end() );  \n    cout << \"Vector sorted by the default binary predicate <:\" << endl << '\\t';  \n    for( vector<T>::const_iterator i = v.begin(); i != v.end(); ++i )  \n    {  \n        cout << *i << \" \";  \n    }  \n    cout << endl << endl;  \n  \n    pair< vector<T>::iterator, vector<T>::iterator > result  \n        = equal_range( v.begin(), v.end(), val );  \n  \n    cout << \"Result of equal_range with val = \" << val << \":\" << endl << '\\t';  \n    dump_vector( v, result );  \n    cout << endl;  \n}  \n  \ntemplate<class T, class F> void equal_range_demo( const vector<T>& original_vector, T val, F pred, string predname )  \n{  \n    vector<T> v(original_vector);  \n  \n    sort( v.begin(), v.end(), pred );  \n    cout << \"Vector sorted by the binary predicate \" << predname << \":\" << endl << '\\t';  \n    for( typename vector<T>::const_iterator i = v.begin(); i != v.end(); ++i )  \n    {  \n        cout << *i << \" \";  \n    }  \n    cout << endl << endl;  \n  \n    pair< typename vector<T>::iterator, typename vector<T>::iterator > result  \n        = equal_range( v.begin(), v.end(), val, pred );  \n  \n    cout << \"Result of equal_range with val = \" << val << \":\" << endl << '\\t';  \n    dump_vector( v, result );  \n    cout << endl;  \n}  \n  \n// Return whether absolute value of elem1 is less than absolute value of elem2  \nbool abs_lesser( int elem1, int elem2 )  \n{  \n    return abs(elem1) < abs(elem2);  \n}  \n  \n// Return whether string l is shorter than string r  \nbool shorter_than(const string& l, const string& r)  \n{  \n    return l.size() < r.size();  \n}  \n  \nint main()  \n{  \n    vector<int> v1;  \n  \n    // Constructing vector v1 with default less than ordering  \n    for( int i = -1; i <= 4; ++i )  \n    {  \n        v1.push_back(i);  \n    }  \n  \n    for( int i =-3; i <= 0; ++i )  \n    {  \n        v1.push_back( i );  \n    }  \n  \n    equal_range_demo( v1, 3 );  \n    equal_range_demo( v1, 3, greater<int>(), \"greater\" );  \n    equal_range_demo( v1, 3, abs_lesser, \"abs_lesser\" );  \n  \n    vector<string> v2;  \n  \n    v2.push_back(\"cute\");  \n    v2.push_back(\"fluffy\");  \n    v2.push_back(\"kittens\");  \n    v2.push_back(\"fun\");  \n    v2.push_back(\"meowmeowmeow\");  \n    v2.push_back(\"blah\");  \n  \n    equal_range_demo<string>( v2, \"fred\" );  \n    equal_range_demo<string>( v2, \"fred\", shorter_than, \"shorter_than\" );  \n}  \n  \n```  \n  \n##  <a name=\"fill\"></a>  fill  \n Assigns the same new value to every element in a specified range.  \n  \n```  \ntemplate<class ForwardIterator, class Type>  \nvoid fill(\n    ForwardIterator first, \n    ForwardIterator last, \n    const Type& val);  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be traversed.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be traversed.  \n  \n `val`  \n The value to be assigned to elements in the range [  `first`, `last`).  \n  \n### Remarks  \n The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation. The complexity is linear with the size of the range.  \n  \n### Example  \n  \n```cpp  \n// alg_fill.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // Fill the last 5 positions with a value of 2  \n   fill( v1.begin( ) + 5, v1.end( ), 2 );  \n  \n   cout << \"Modified v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 30 35 40 45 )  \nModified v1 = ( 0 5 10 15 20 2 2 2 2 2 )  \n```  \n  \n##  <a name=\"fill_n\"></a>  fill_n  \n Assigns a new value to a specified number of elements in a range beginning with a particular element.  \n  \n```  \ntemplate<class OutputIterator, class Size, class Type>  \nOutputIterator fill_n(\n    OutputIterator First, \n    Size Count, \n    const Type& Val);   \n```  \n  \n### Parameters  \n `First`  \n An output iterator addressing the position of the first element in the range to be assigned the value `Val`.  \n  \n `Count`  \n A signed or unsigned integer type specifying the number of elements to be assigned the value.  \n  \n `Val`  \n The value to be assigned to elements in the range [ `First`,          *First + Count*).  \n  \n### Return Value  \n An iterator to the element that follows the last element filled if `Count` > zero, otherwise the first element.  \n  \n### Remarks  \n The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation. The complexity is linear with the size of the range.  \n  \n### Example  \n  \n```cpp  \n// alg_fill_n.cpp  \n// compile using /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main()   \n{  \n    using namespace std;  \n    vector <int> v;  \n  \n    for ( auto i = 0 ; i < 9 ; ++i )  \n        v.push_back( 0 );  \n  \n    cout << \"  vector v = ( \" ;  \n    for ( const auto &w : v )  \n        cout << w << \" \";  \n    cout << \")\" << endl;  \n  \n    // Fill the first 3 positions with a value of 1, saving position.  \n    auto pos = fill_n( v.begin(), 3, 1 );  \n  \n    cout << \"modified v = ( \" ;  \n    for ( const auto &w : v )  \n        cout << w << \" \";  \n    cout << \")\" << endl;  \n  \n    // Fill the next 3 positions with a value of 2, using last position.  \n    fill_n( pos, 3, 2 );  \n  \n    cout << \"modified v = ( \" ;  \n    for ( const auto &w : v )  \n        cout << w << \" \";  \n    cout << \")\" << endl;  \n  \n    // Fill the last 3 positions with a value of 3, using relative math.  \n    fill_n( v.end()-3, 3, 3 );  \n  \n    cout << \"modified v = ( \" ;  \n    for ( const auto &w : v )  \n        cout << w << \" \";  \n    cout << \")\" << endl;  \n}  \n  \n```  \n  \n##  <a name=\"find\"></a>  find  \n Locates the position of the first occurrence of an element in a range that has a specified value.  \n  \n```  \ntemplate<class InputIterator, class T>  \nInputIterator find(\n    InputIterator first, \n    InputIterator last,   \n    const T& val);  \n```  \n  \n### Parameters  \n `first`  \n An input iterator addressing the position of the first element in the range to be searched for the specified value.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range to be searched for the specified value.  \n  \n `val`  \n The value to be searched for.  \n  \n### Return Value  \n An input iterator addressing the first occurrence of the specified value in the range being searched. If no element is found with an equivalent value, returns `last`.  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n For a code example using `find()`, see [find_if](../standard-library/algorithm-functions.md#find_if).  \n  \n##  <a name=\"find_end\"></a>  find_end  \n Looks in a range for the last subsequence that is identical to a specified sequence or that is equivalent in a sense specified by a binary predicate.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nForwardIterator1 find_end(  \n    ForwardIterator1 First1,   \n    ForwardIterator1 Last1,  \n    ForwardIterator2 First2,   \n    ForwardIterator2 Last2);  \n\ntemplate<class ForwardIterator1, class ForwardIterator2, class Pred>  \nForwardIterator1 find_end(  \n    ForwardIterator1 First1,   \n    ForwardIterator1 Last1,  \n    ForwardIterator2 First2,   \n    ForwardIterator2 Last2,  \n    Pred Comp);  \n```  \n  \n### Parameters  \n `First1`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `Last1`  \n A forward iterator addressing the position one past the last element in the range to be searched.  \n  \n `First2`  \n A forward iterator addressing the position of the first element in the range to search for.  \n  \n `Last2`  \n A forward iterator addressing the position one past the last element in the range to search for.  \n  \n `Comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator addressing the position of the first element of the last subsequence within [First1, Last1) that matches the specified sequence [First2, Last2).  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.  \n  \n### Example  \n  \n```cpp  \n// alg_find_end.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Return whether second element is twice the first  \nbool twice ( int elem1, int elem2 )  \n{  \n   return 2 * elem1 == elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1, v2;  \n   list <int> L1;  \n   vector <int>::iterator Iter1, Iter2;  \n   list <int>::iterator L1_Iter, L1_inIter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   int ii;  \n   for ( ii = 1 ; ii <= 4 ; ii++ )  \n   {  \n      L1.push_back( 5 * ii );  \n   }  \n  \n   int iii;  \n   for ( iii = 2 ; iii <= 4 ; iii++ )  \n   {  \n      v2.push_back( 10 * iii );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"List L1 = ( \" ;  \n   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )  \n      cout << *L1_Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"Vector v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n      cout << \")\" << endl;  \n  \n   // Searching v1 for a match to L1 under identity  \n   vector <int>::iterator result1;  \n   result1 = find_end ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );  \n  \n   if ( result1 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is a match of L1 in v1 that begins at \"  \n           << \"position \"<< result1 - v1.begin( ) << \".\" << endl;  \n  \n   // Searching v1 for a match to L1 under the binary predicate twice  \n   vector <int>::iterator result2;  \n   result2 = find_end ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );  \n  \n   if ( result2 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is a sequence of elements in v1 that \"  \n           << \"are equivalent to those\\n in v2 under the binary \"  \n           << \"predicate twice and that begins at position \"  \n           << result2 - v1.begin( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )  \nList L1 = ( 5 10 15 20 )  \nVector v2 = ( 20 30 40 )  \nThere is a match of L1 in v1 that begins at position 7.  \nThere is a sequence of elements in v1 that are equivalent to those  \n in v2 under the binary predicate twice and that begins at position 8.  \n```  \n  \n##  <a name=\"find_first_of\"></a>  find_first_of  \n Searches for the first occurrence of any of several values within a target range or for the first occurrence of any of several elements that are equivalent in a sense specified by a binary predicate to a specified set of the elements.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nForwardIterator1 find_first_of(    \n    ForwardIterator1  first1,  \n    ForwardIterator1 Last1,  \n    ForwardIterator2  first2,  \n    ForwardIterator2 Last2);  \n  \ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>  \nForwardIterator1 find_first_of(  \n    ForwardIterator1  first1,  \n    ForwardIterator1 Last1,  \n    ForwardIterator2  first2,  \n    ForwardIterator2 Last2,  \n    BinaryPredicate  comp);  \n```  \n  \n### Parameters  \n  `first1`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last1`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n  `first2`  \n A forward iterator addressing the position of the first element in the range to be matched.  \n  \n `last2`  \n A forward iterator addressing the position one past the final element in the range to be matched.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.  \n  \n### Example  \n  \n```cpp  \n// alg_find_first_of.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Return whether second element is twice the first  \nbool twice ( int elem1, int elem2 )  \n{  \n   return 2 * elem1 == elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1, v2;  \n   list <int> L1;  \n   vector <int>::iterator Iter1, Iter2;  \n   list <int>::iterator L1_Iter, L1_inIter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   int ii;  \n   for ( ii = 3 ; ii <= 4 ; ii++ )  \n   {  \n      L1.push_back( 5 * ii );  \n   }  \n  \n   int iii;  \n   for ( iii = 2 ; iii <= 4 ; iii++ )  \n   {  \n      v2.push_back( 10 * iii );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"List L1 = ( \" ;  \n   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )  \n      cout << *L1_Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"Vector v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n      cout << \")\" << endl;  \n  \n   // Searching v1 for first match to L1 under identity  \n   vector <int>::iterator result1;  \n   result1 = find_first_of ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );  \n  \n   if ( result1 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is at least one match of L1 in v1\"  \n           << \"\\n and the first one begins at \"  \n           << \"position \"<< result1 - v1.begin( ) << \".\" << endl;  \n  \n   // Searching v1 for a match to L1 under the binary predicate twice  \n   vector <int>::iterator result2;  \n   result2 = find_first_of ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );  \n  \n   if ( result2 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is a sequence of elements in v1 that \"  \n           << \"are equivalent\\n to those in v2 under the binary \"  \n           << \"predicate twice\\n and the first one begins at position \"  \n           << result2 - v1.begin( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )  \nList L1 = ( 15 20 )  \nVector v2 = ( 20 30 40 )  \nThere is at least one match of L1 in v1  \n and the first one begins at position 3.  \nThere is a sequence of elements in v1 that are equivalent  \n to those in v2 under the binary predicate twice  \n and the first one begins at position 2.  \n```  \n  \n##  <a name=\"find_if\"></a>  find_if  \n Locates the position of the first occurrence of an element in a range that satisfies a specified condition.  \n  \n```  \ntemplate<class InputIterator, class Predicate>  \nInputIterator find_if(\n    InputIterator first, \n    InputIterator last, \n    Predicate pred);  \n```  \n  \n### Parameters  \n `first`  \n An input iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range to be searched.  \n  \n `pred`  \n User-defined predicate function object or [lambda expression](../cpp/lambda-expressions-in-cpp.md) that defines the condition to be satisfied by the element being searched for. A predicate takes single argument and returns `true` (satisfied) or `false` (not satisfied). The signature of `pred` must effectively be `bool pred(const T& arg);`, where `T` is a type to which `InputIterator` can be implicitly converted when dereferenced. The `const` keyword is shown only to illustrate that the function object or lambda should not modify the argument.  \n  \n### Return Value  \n An input iterator that refers to the first element in the range that satisfies the condition specified by the predicate (the predicate results in `true`). If no element is found to satisfy the predicate, returns `last`.  \n  \n### Remarks  \n This template function is a generalization of the algorithm [find](../standard-library/algorithm-functions.md#find), replacing the predicate \"equals a specific value\" with any predicate. For the logical opposite (find the first element that does not satisfy the predicate), see [find_if_not](../standard-library/algorithm-functions.md#find_if_not).  \n  \n### Example  \n  \n```cpp  \n// cl.exe /W4 /nologo /EHsc /MTd  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n#include <string>  \n  \nusing namespace std;  \n  \ntemplate <typename S> void print(const S& s) {  \n    for (const auto& p : s) {  \n        cout << \"(\" << p << \") \";  \n    }  \n    cout << endl;  \n}  \n  \n// Test std::find()  \ntemplate <class InputIterator, class T>  \nvoid find_print_result(InputIterator first, InputIterator last, const T& value) {  \n  \n    // call <algorithm> std::find()  \n    auto p = find(first, last, value);  \n  \n    cout << \"value \" << value;  \n    if (p == last) {  \n        cout << \" not found.\" << endl;  \n    } else {  \n        cout << \" found.\" << endl;  \n    }  \n}  \n  \n// Test std::find_if()  \ntemplate <class InputIterator, class Predicate>  \nvoid find_if_print_result(InputIterator first, InputIterator last,  \n    Predicate Pred, const string& Str) {  \n  \n    // call <algorithm> std::find_if()  \n    auto p = find_if(first, last, Pred);  \n  \n    if (p == last) {  \n        cout << Str << \" not found.\" << endl;  \n    } else {  \n        cout << \"first \" << Str << \" found: \" << *p << endl;  \n    }  \n}  \n  \n// Function to use as the UnaryPredicate argument to find_if() in this example  \nbool is_odd_int(int i) {  \n    return ((i % 2) != 0);  \n}  \n  \nint main()  \n{  \n    // Test using a plain old array.  \n    const int x[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };  \n    cout << \"array x[] contents: \";  \n    print(x);  \n    // Using non-member std::begin()/std::end() to get input iterators for the plain old array.  \n    cout << \"Test std::find() with array...\" << endl;  \n    find_print_result(begin(x), end(x), 10);  \n    find_print_result(begin(x), end(x), 42);  \n    cout << \"Test std::find_if() with array...\" << endl;  \n    find_if_print_result(begin(x), end(x), is_odd_int, \"odd integer\"); // function name  \n    find_if_print_result(begin(x), end(x), // lambda  \n        [](int i){ return ((i % 2) == 0); }, \"even integer\");  \n  \n    // Test using a vector.  \n    vector<int> v;  \n    for (int i = 0; i < 10; ++i) {  \n        v.push_back((i + 1) * 10);  \n    }  \n    cout << endl << \"vector v contents: \";  \n    print(v);  \n    cout << \"Test std::find() with vector...\" << endl;  \n    find_print_result(v.begin(), v.end(), 20);  \n    find_print_result(v.begin(), v.end(), 12);  \n    cout << \"Test std::find_if() with vector...\" << endl;  \n    find_if_print_result(v.begin(), v.end(), is_odd_int, \"odd integer\");  \n    find_if_print_result(v.begin(), v.end(), // lambda  \n        [](int i){ return ((i % 2) == 0); }, \"even integer\");  \n}  \n  \n```  \n  \n##  <a name=\"find_if_not\"></a>  find_if_not  \n Returns the first element in the indicated range that does not satisfy a condition.  \n  \n```  \ntemplate<class InputIterator, class Predicate>  \nInputIterator find_if_not(\n    InputIterator first, \n    InputIterator last,   \n    Predicate pred);  \n```  \n  \n### Parameters  \n `first`  \n An input iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range to be searched.  \n  \n `pred`  \n User-defined predicate function object or [lambda expression](../cpp/lambda-expressions-in-cpp.md) that defines the condition to be not satisfied by the element being searched for. A predicate takes single argument and returns `true` (satisfied) or `false` (not satisfied). The signature of `pred` must effectively be `bool pred(const T& arg);`, where `T` is a type to which `InputIterator` can be implicitly converted when dereferenced. The `const` keyword is shown only to illustrate that the function object or lambda should not modify the argument.  \n  \n### Return Value  \n An input iterator that refers to the first element in the range that does not satisfy the condition specified by the predicate (the predicate results in `false`). If all elements satisfy the predicate (the predicate results in `true` for every element), returns `last`.  \n  \n### Remarks  \n This template function is a generalization of the algorithm [find](../standard-library/algorithm-functions.md#find), replacing the predicate \"equals a specific value\" with any predicate. For the logical opposite (find the first element that does satisfy the predicate), see [find_if](../standard-library/algorithm-functions.md#find_if).  \n  \n For a code example readily adaptable to `find_if_not()`, see [find_if](../standard-library/algorithm-functions.md#find_if).  \n  \n##  <a name=\"for_each\"></a>  for_each  \n Applies a specified function object to each element in a forward order within a range and returns the function object.  \n  \n```  \ntemplate<class InputIterator, class Function>  \nFunction for_each(\n    InputIterator first, \n    InputIterator last, \n    Function _Func);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the range to be operated on.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range operated on.  \n  \n `_Func`  \n User-defined function object that is applied to each element in the range.  \n  \n### Return Value  \n A copy of the function object after it has been applied to all of the elements in the range.  \n  \n### Remarks  \n The algorithm `for_each` is very flexible, allowing the modification of each element within a range in different, user-specified ways. Templatized functions may be reused in a modified form by passing different parameters. User-defined functions may accumulate information within an internal state that the algorithm may return after processing all of the elements in the range.  \n  \n The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.  \n  \n The complexity is linear with at most ( `last` –  `first`) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_for_each.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \n// The function object multiplies an element by a Factor  \ntemplate <class Type>  \nclass MultValue  \n{  \nprivate:  \n   Type Factor;   // The value to multiply by  \npublic:  \n   // Constructor initializes the value to multiply by  \n   MultValue ( const Type& val ) : Factor ( val ) {  \n   }  \n  \n   // The function call for the element to be multiplied  \n   void operator ( ) ( Type& elem ) const  \n   {  \n      elem *= Factor;  \n   }  \n};  \n  \n// The function object to determine the average  \nclass Average  \n{  \nprivate:  \n   long num;      // The number of elements  \n   long sum;      // The sum of the elements  \npublic:  \n   // Constructor initializes the value to multiply by  \n   Average ( ) : num ( 0 ) , sum ( 0 )  \n   {  \n   }  \n  \n   // The function call to process the next elment  \n   void operator ( ) ( int elem ) \\  \n   {  \n      num++;      // Increment the element count  \n      sum += elem;   // Add the value to the partial sum  \n   }  \n  \n   // return Average  \n   operator double ( )  \n   {  \n      return  static_cast <double> (sum) /  \n      static_cast <double> (num);  \n   }  \n};  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   // Constructing vector v1  \n   int i;  \n   for ( i = -4 ; i <= 2 ; i++ )  \n   {  \n      v1.push_back(  i );  \n   }  \n  \n   cout << \"Original vector  v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Using for_each to multiply each element by a Factor  \n   for_each ( v1.begin ( ) , v1.end ( ) , MultValue<int> ( -2 ) );  \n  \n   cout << \"Multiplying the elements of the vector v1\\n \"  \n        <<  \"by the factor -2 gives:\\n v1mod1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The function object is templatized and so can be  \n   // used again on the elements with a different Factor  \n   for_each (v1.begin ( ) , v1.end ( ) , MultValue<int> (5 ) );  \n  \n   cout << \"Multiplying the elements of the vector v1mod\\n \"  \n        <<  \"by the factor 5 gives:\\n v1mod2 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The local state of a function object can accumulate  \n   // information about a sequence of actions that the  \n   // return value can make available, here the Average  \n   double avemod2 = for_each ( v1.begin ( ) , v1.end ( ) ,  \n      Average ( ) );  \n   cout << \"The average of the elements of v1 is:\\n Average ( v1mod2 ) = \"  \n        << avemod2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector  v1 = ( -4 -3 -2 -1 0 1 2 ).  \nMultiplying the elements of the vector v1  \n by the factor -2 gives:  \n v1mod1 = ( 8 6 4 2 0 -2 -4 ).  \nMultiplying the elements of the vector v1mod  \n by the factor 5 gives:  \n v1mod2 = ( 40 30 20 10 0 -10 -20 ).  \nThe average of the elements of v1 is:  \n Average ( v1mod2 ) = 10.  \n```  \n  \n##  <a name=\"generate\"></a>  generate  \n Assigns the values generated by a function object to each element in a range.  \n  \n```  \ntemplate<class ForwardIterator, class Generator>  \nvoid generate(\n    ForwardIterator first, \n    ForwardIterator last, \n    Generator _Gen);  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to which values are to be assigned.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to which values are to be assigned.  \n  \n `_Gen`  \n A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.  \n  \n### Remarks  \n The function object is invoked for each element in the range and does not need to return the same value each time it is called. It may, for example, read from a file or refer to and modify a local state. The generator's result type must be convertible to the value type of the forward iterators for the range.  \n  \n The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.  \n  \n The complexity is linear, with exactly ( `last` –  `first`) calls to the generator being required.  \n  \n### Example  \n  \n```cpp  \n// alg_generate.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // Assigning random values to vector integer elements  \n   vector <int> v1 ( 5 );  \n   vector <int>::iterator Iter1;  \n   deque <int> deq1 ( 5 );  \n   deque <int>::iterator d1_Iter;  \n  \n   generate ( v1.begin ( ), v1.end ( ) , rand );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Assigning random values to deque integer elements  \n   generate ( deq1.begin ( ), deq1.end ( ) , rand );  \n  \n   cout << \"Deque deq1 is ( \" ;  \n   for ( d1_Iter = deq1.begin( ) ; d1_Iter != deq1.end( ) ; d1_Iter++ )  \n      cout << *d1_Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 is ( 41 18467 6334 26500 19169 ).  \nDeque deq1 is ( 15724 11478 29358 26962 24464 ).  \n```  \n  \n##  <a name=\"generate_n\"></a>  generate_n  \n Assigns the values generated by a function object to a specified number of elements in a range and returns to the position one past the last assigned value.  \n  \n```  \ntemplate<class OutputIterator, class Diff, class Generator>  \nvoid generate_n( \n    OutputIterator First, \n    Diff Count, \n    Generator Gen);  \n```  \n  \n### Parameters  \n `First`  \n An output iterator addressing the position of first element in the range to which values are to be assigned.  \n  \n `Count`  \n A signed or unsigned integer type specifying the number of elements to be assigned a value by the generator function.  \n  \n `Gen`  \n A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.  \n  \n### Remarks  \n The function object is invoked for each element in the range and does not need to return the same value each time it is called. It may, for example, read from a file or refer to and modify a local state. The generator's result type must be convertible to the value type of the forward iterators for the range.  \n  \n The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.  \n  \n The complexity is linear, with exactly `Count` calls to the generator being required.  \n  \n### Example  \n  \n```cpp  \n// cl.exe /EHsc /nologo /W4 /MTd  \n#include <vector>  \n#include <deque>  \n#include <iostream>  \n#include <string>  \n#include <algorithm>  \n#include <random>  \n  \nusing namespace std;  \n  \ntemplate <typename C> void print(const string& s, const C& c) {  \n    cout << s;  \n  \n    for (const auto& e : c) {  \n        cout << e << \" \";  \n    }  \n  \n    cout << endl;  \n}  \n  \nint main()  \n{  \n    const int elemcount = 5;  \n    vector<int> v(elemcount);  \n    deque<int> dq(elemcount);  \n  \n    // Set up random number distribution  \n    random_device rd;  \n    mt19937 engine(rd());  \n    uniform_int_distribution<int> dist(-9, 9);  \n  \n    // Call generate_n, using a lambda for the third parameter  \n    generate_n(v.begin(), elemcount, [&](){ return dist(engine); });  \n    print(\"vector v is: \", v);  \n  \n    generate_n(dq.begin(), elemcount, [&](){ return dist(engine); });  \n    print(\"deque dq is: \", dq);  \n}  \n  \n```  \n  \n##  <a name=\"includes\"></a>  includes  \n Tests whether one sorted range contains all the elements contained in a second sorted range, where the ordering or equivalence criterion between elements may be specified by a binary predicate.  \n  \n```  \ntemplate<class InputIterator1, class InputIterator2>  \nbool includes(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2);  \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate>  \nbool includes(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2,  \n    BinaryPredicate comp );  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n **true** if the first sorted range contains all the elements in the second sorted range; otherwise, **false**.  \n  \n### Remarks  \n Another way to think of this test is that it determined whether the second source range is a subset of the first source range.  \n  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the algorithm includes in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The source ranges are not modified by the algorithm **merge**.  \n  \n The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. More precisely, the algorithm tests whether all the elements in the first sorted range under a specified binary predicate have equivalent ordering to those in the second sorted range.  \n  \n The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( * last2 – first2*) ) – 1 comparisons for nonempty source ranges.  \n  \n### Example  \n  \n```cpp  \n// alg_includes.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser (int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1a, v1b;  \n   vector <int>::iterator Iter1a,  Iter1b;  \n  \n   // Constructing vectors v1a & v1b with default less-than ordering  \n   int i;  \n   for ( i = -2 ; i <= 4 ; i++ )  \n   {  \n      v1a.push_back(  i );  \n   }  \n  \n   int ii;  \n   for ( ii =-2 ; ii <= 3 ; ii++ )  \n   {  \n      v1b.push_back(  ii  );  \n   }  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        << \"binary predicate less than is v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        <<  \"binary predicate less than is v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v2a & v2b with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b );  \n   vector <int>::iterator Iter2a,  Iter2b;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n   v2a.pop_back ( );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        <<  \"binary predicate greater is v2a = ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        <<  \"binary predicate greater is v2b = ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v3a & v3b with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) ;  \n   vector <int>::iterator Iter3a, Iter3b;  \n   reverse (v3a.begin( ), v3a.end( ) );  \n   v3a.pop_back ( );  \n   v3a.pop_back ( );  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is v3a = ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is v3b = ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To test for inclusion under an asscending order  \n   // with the default binary predicate less <int> ( )  \n   bool Result1;  \n   Result1 = includes ( v1a.begin ( ) , v1a.end ( ) ,  \n      v1b.begin ( ) , v1b.end ( ) );  \n   if ( Result1 )  \n      cout << \"All the elements in vector v1b are \"  \n           << \"contained in vector v1a.\" << endl;  \n   else  \n      cout << \"At least one of the elements in vector v1b \"  \n           << \"is not contained in vector v1a.\" << endl;  \n  \n   // To test for inclusion under descending  \n   // order specify binary predicate greater<int>( )  \n   bool Result2;  \n   Result2 = includes ( v2a.begin ( ) , v2a.end ( ) ,  \n      v2b.begin ( ) , v2b.end ( ) , greater <int> ( ) );  \n   if ( Result2 )  \n      cout << \"All the elements in vector v2b are \"  \n           << \"contained in vector v2a.\" << endl;  \n   else  \n      cout << \"At least one of the elements in vector v2b \"  \n           << \"is not contained in vector v2a.\" << endl;  \n  \n   // To test for inclusion under a user  \n   // defined binary predicate mod_lesser  \n   bool Result3;  \n   Result3 = includes ( v3a.begin ( ) , v3a.end ( ) ,  \n      v3b.begin ( ) , v3b.end ( ) , mod_lesser );  \n   if ( Result3 )  \n      cout << \"All the elements in vector v3b are \"  \n           << \"contained under mod_lesser in vector v3a.\"  \n           << endl;  \n   else  \n      cout << \"At least one of the elements in vector v3b is \"  \n           << \" not contained under mod_lesser in vector v3a.\"   \n           << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector v1a with range sorted by the  \n binary predicate less than is v1a = ( -2 -1 0 1 2 3 4 ).  \nOriginal vector v1b with range sorted by the  \n binary predicate less than is v1b = ( -2 -1 0 1 2 3 ).  \nOriginal vector v2a with range sorted by the  \n binary predicate greater is v2a = ( 4 3 2 1 0 -1 ).  \nOriginal vector v2b with range sorted by the  \n binary predicate greater is v2b = ( 3 2 1 0 -1 -2 ).  \nOriginal vector v3a with range sorted by the  \n binary predicate mod_lesser is v3a = ( 0 1 2 3 4 ).  \nOriginal vector v3b with range sorted by the  \n binary predicate mod_lesser is v3b = ( 0 -1 1 -2 2 3 ).  \nAll the elements in vector v1b are contained in vector v1a.  \nAt least one of the elements in vector v2b is not contained in vector v2a.  \nAt least one of the elements in vector v3b is  not contained under mod_lesser in vector v3a.  \n```  \n  \n##  <a name=\"inplace_merge\"></a>  inplace_merge  \n Combines the elements from two consecutive sorted ranges into a single sorted range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class BidirectionalIterator>  \nvoid inplace_merge(      \n    BidirectionalIterator first,   \n    BidirectionalIterator middle,  \n    BidirectionalIterator last);  \n  \ntemplate<class BidirectionalIterator, class Predicate>  \nvoid inplace_merge(  \n    BidirectionalIterator first,   \n    BidirectionalIterator middle,  \n    BidirectionalIterator last,  \n    Predicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator addressing the position of the first element in the first of two consecutive sorted ranges to be combined and sorted into a single range.  \n  \n `middle`  \n A bidirectional iterator addressing the position of the first element in the second of two consecutive sorted ranges to be combined and sorted into a single range.  \n  \n `last`  \n A bidirectional iterator addressing the position one past the last element in the second of two consecutive sorted ranges to be combined and sorted into a single range.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Remarks  \n The sorted consecutive ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.  \n  \n The sorted consecutive ranges must each be arranged as a precondition to the application of the `inplace_merge` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges. The operation is stable as the relative order of elements within each range is preserved. When there are equivalent elements in both source ranges, the element is the first range precedes the element from the second in the combined range.  \n  \n The complexity depends on the available memory as the algorithm allocates memory to a temporary buffer. If sufficient memory is available, the best case is linear with ( * last – first*) – 1 comparisons; if no auxiliary memory is available, the worst case is  *N* log *(N)*, where  *N* = ( * last – first*).  \n  \n### Example  \n  \n```cpp  \n// alg_inplace_merge.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      //For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1, Iter2, Iter3;  \n  \n   // Constructing vector v1 with default less-than ordering  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii =-5 ; ii <= 0 ; ii++ )  \n   {  \n      v1.push_back(  ii  );  \n   }  \n  \n   cout << \"Original vector v1 with subranges sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // Constructing vector v2 with ranges sorted by greater  \n   vector <int> v2 ( v1 );  \n   vector <int>::iterator break2;  \n   break2 = find ( v2.begin ( ) , v2.end ( ) , -5 );  \n   sort ( v2.begin ( ) , break2 , greater<int> ( ) );  \n   sort ( break2 , v2.end ( ) , greater<int> ( ) );  \n   cout << \"Original vector v2 with subranges sorted by the\\n \"  \n        << \"binary predicate greater is v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // Constructing vector v3 with ranges sorted by mod_lesser  \n   vector <int> v3 ( v1 );  \n   vector <int>::iterator break3;  \n   break3 = find ( v3.begin ( ) , v3.end ( ) , -5 );  \n   sort ( v3.begin ( ) , break3 , mod_lesser );  \n   sort ( break3 , v3.end ( ) , mod_lesser );  \n   cout << \"Original vector v3 with subranges sorted by the\\n \"  \n        << \"binary predicate mod_lesser is v3 = ( \" ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \")\" << endl;  \n  \n   vector <int>::iterator break1;  \n   break1 = find (v1.begin ( ) , v1.end ( ) , -5 );  \n   inplace_merge ( v1.begin( ), break1, v1.end( ) );  \n   cout << \"Merged inplace with default order,\\n vector v1mod = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To merge inplace in descending order, specify binary   \n   // predicate greater<int>( )  \n   inplace_merge ( v2.begin( ), break2 , v2.end( ) , greater<int>( ) );  \n   cout << \"Merged inplace with binary predicate greater specified,\\n \"  \n        << \"vector v2mod = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \")\" << endl;  \n  \n   // Applying a user defined (UD) binary predicate mod_lesser  \n   inplace_merge ( v3.begin( ), break3, v3.end( ), mod_lesser );  \n   cout << \"Merged inplace with binary predicate mod_lesser specified,\\n \"  \n        << \"vector v3mod = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector v1 with subranges sorted by the  \n binary predicate less than is  v1 = ( 0 1 2 3 4 5 -5 -4 -3 -2 -1 0 )  \nOriginal vector v2 with subranges sorted by the  \n binary predicate greater is v2 = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )  \nOriginal vector v3 with subranges sorted by the  \n binary predicate mod_lesser is v3 = ( 0 1 2 3 4 5 0 -1 -2 -3 -4 -5 )  \nMerged inplace with default order,  \n vector v1mod = ( -5 -4 -3 -2 -1 0 0 1 2 3 4 5 )  \nMerged inplace with binary predicate greater specified,  \n vector v2mod = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )  \nMerged inplace with binary predicate mod_lesser specified,  \n vector v3mod = ( 0 0 1 -1 2 -2 3 -3 4 -4 5 -5 )  \n```  \n  \n##  <a name=\"is_heap\"></a>  is_heap  \n Returns `true` if the elements in the specified range form a heap.  \n  \n```  \ntemplate<class RandomAccessIterator>  \nbool is_heap(  \n    RandomAccessIterator first,  \n    RandomAccessIterator last);  \n\ntemplate<class RandomAccessIterator, class BinaryPredicate>  \nbool is_heap(  \n    RandomAccessIterator first,  \n    RandomAccessIterator last,  \n    BinaryPredicate comp);   \n```  \n  \n### Parameters  \n  `first`  \n A random access iterator that indicates the start of a range to check for a heap.  \n  \n `last`  \n A random access iterator that indicates the end of a range.  \n  \n `comp`  \n A condition to test to order elements. A binary predicate takes a single argument and returns `true`or `false`.  \n  \n### Return Value  \n Returns `true` if the elements in the specified range form a heap, `false` if they do not.  \n  \n### Remarks  \n The first template function returns [is_heap_until](../standard-library/algorithm-functions.md#is_heap_until)`(` `first``,` `last``) ==` `last`.  \n  \n The second template function returns  \n  \n `is_heap_until` `(`  `first` `,`  `last` `,`  `comp` `) ==`  `last`.  \n  \n##  <a name=\"is_heap_until\"></a>  is_heap_until  \n Returns an iterator positioned at the first element in the range [ `begin`, `end`) that does not satisfy the heap ordering condition, or `end` if the range forms a heap.  \n  \n```  \ntemplate<class RandomAccessIterator>  \nRandomAccessIterator is_heap_until(  \n    RandomAccessIterator begin,   \n    RandomAccessIterator end);  \n    \ntemplate<class RandomAccessIterator, class BinaryPredicate>   \nRandomAccessIterator is_heap_until(  \n    RandomAccessIterator begin,   \n    RandomAccessIterator end,   \n    BinaryPredicate compare);  \n```  \n  \n### Parameters  \n `begin`  \n A random access iterator that specifies the first element of a range to check for a heap.  \n  \n `end`  \n A random access iterator that specifies the end of the range to check for a heap.  \n  \n `compare`  \n A binary predicate that specifies the strict weak ordering condition that defines a heap. The default predicate when `compare` is not specified is `std::less<>`.  \n  \n### Return Value  \n Returns `end` if the specified range forms a heap or contains one or fewer elements. Otherwise, returns an iterator for the first element found that does not satisfy the heap condition.  \n  \n### Remarks  \n The first template function returns the last iterator `next` in `[``begin``,` `end``]` where `[``begin``, next)` is a heap ordered by the function object `std::less<>`. If the distance `end` `-` `begin` `< 2`, the function returns `end`.  \n  \n The second template function behaves the same as the first, except that it uses the predicate `compare` instead of `std::less<>` as the heap ordering condition.  \n  \n##  <a name=\"is_partitioned\"></a>  is_partitioned  \n Returns `true` if all the elements in the given range that test `true` for a condition come before any elements that test `false`.  \n  \n```  \ntemplate<class InputIterator, class BinaryPredicate>  \nbool is_partitioned(  \n    InputIterator first,   \n    InputIterator last,  \n    BinaryPredicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates where a range starts to check for a condition.  \n  \n `last`  \n An input iterator that indicates the end of a range.  \n  \n `comp`  \n The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for. A predicate takes a single argument and returns `true`or `false`.  \n  \n### Return Value  \n Returns true when all of the elements in the given range that test `true` for a condition come before any elements that test `false`, and otherwise returns `false`.  \n  \n### Remarks  \n The template function returns `true` only if all elements in `[` `first``,` `last``)` are partitioned by `comp`; that is, all elements `X` in `[` `first``,` `last``)` for which `comp``(X)` is true occur before all elements `Y` for which `comp``(Y)` is `false`.  \n  \n##  <a name=\"is_permutation\"></a>  is_permutation  \n Returns true if both ranges contain the same elements, whether or not the elements are in the same order. Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nbool is_permutation(\n    ForwardIterator1 First1, \n    ForwardIterator1 Last1, \n    ForwardIterator2 First2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class Predicate>  \nbool is_permutation(\n    ForwardIterator1 First1, \n    ForwardIterator1 Last1, \n    ForwardIterator2 First2, \n    Predicate Pred);\n\n// C++14  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nbool is_permutation(\n    ForwardIterator1 First1, \n    ForwardIterator1 Last1, \n    ForwardIterator2 First2, \n    ForwardIterator2 Last2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class Predicate>  \nbool is_permutation(\n    ForwardIterator1 First1, \n    ForwardIterator1 Last1, \n    ForwardIterator2 First2, \n    ForwardIterator2 Last2, \n    Predicate Pred);  \n```  \n  \n### Parameters  \n `First1`  \n A forward iterator that refers to the first element of the range.  \n  \n `Last1`  \n A forward iterator that refers one past the last element of the range.  \n  \n `First2`  \n A forward iterator that refers to the first element of a second range, used for comparison.  \n  \n `Last2`  \n A forward iterator that refers to one past the last element of a second range, used for comparison.  \n  \n `Pred`  \n A predicate that tests for equivalence and returns a `bool`.  \n  \n### Return Value  \n `true` when the ranges can be rearranged so as to be identical according to the comparator predicate; otherwise, `false`.  \n  \n### Remarks  \n `is_permutation` has quadratic complexity in the worst case.  \n  \n The first template function assumes that there are as many elements in the range beginning at `First2` as there are in the range designated by [ `First1`, `Last1`). If there are more elements in the second range, they are ignored; if there are less, undefined behavior will occur. The third template function (C++14 and later) does not make this assumption.  Both return `true` only if, for each element X in the range designated by [ `First1`, `Last1`) there are as many elements Y in the same range for which X == Y as there are in the range beginning at `First2` or [ `First2, Last2).` Here, `operator==` must perform a pairwise comparison between its operands.  \n  \n The second and fourth template functions behave the same, except that they replace `operator==(X, Y)` with `Pred(X, Y)`. To behave correctly, the predicate must be symmetric, reflexive and transitive.  \n  \n### Example  \n  The following example shows how to use `is_permutation`:  \n  \n```cpp  \n#include <vector>  \n#include <iostream>  \n#include <algorithm>  \n#include <string>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    vector<int> vec_1{ 2, 3, 0, 1, 4, 5 };  \n    vector<int> vec_2{ 5, 4, 0, 3, 1, 2 };  \n  \n    vector<int> vec_3{ 4, 9, 13, 3, 6, 5 };  \n    vector<int> vec_4{ 7, 4, 11, 9, 2, 1 };  \n  \n    cout << \"(1) Compare using built-in == operator: \";  \n    cout << boolalpha << is_permutation(vec_1.begin(), vec_1.end(),  \n        vec_2.begin(), vec_2.end()) << endl; // true  \n  \n    cout << \"(2) Compare after modifying vec_2: \";  \n    vec_2[0] = 6;  \n    cout << is_permutation(vec_1.begin(), vec_1.end(),  \n        vec_2.begin(), vec_2.end()) << endl; // false  \n  \n    // Define equivalence as \"both are odd or both are even\"  \n    cout << \"(3) vec_3 is a permutation of vec_4: \";  \n    cout << is_permutation(vec_3.begin(), vec_3.end(),  \n        vec_4.begin(), vec_4.end(),  \n        [](int lhs, int rhs) { return lhs % 2 == rhs % 2; }) << endl; // true  \n  \n    // Initialize a vector using the 's' string literal to specify a std::string  \n    vector<string> animals_1{ \"dog\"s, \"cat\"s, \"bird\"s, \"monkey\"s };  \n    vector<string> animals_2{ \"donkey\"s, \"bird\"s, \"meerkat\"s, \"cat\"s };  \n  \n    // Define equivalence as \"first letters are equal\":  \n    bool is_perm = is_permutation(animals_1.begin(), animals_1.end(), animals_2.begin(), animals_2.end(),  \n        [](const string& lhs, const string& rhs)  \n    {  \n        return lhs[0] == rhs[0]; //std::string guaranteed to have at least a null terminator  \n    });  \n  \n    cout << \"animals_2 is a permutation of animals_1: \" << is_perm << endl; // true  \n  \n    cout << \"Press a letter\" << endl;  \n    char c;  \n    cin >> c;  \n  \n    return 0;  \n}  \n  \n```  \n  \n##  <a name=\"is_sorted\"></a>  is_sorted  \n Returns `true` if the elements in the specified range are in sorted order.  \n  \n```  \ntemplate<class ForwardIterator>  \nbool is_sorted(  \n    ForwardIterator first,   \n    ForwardIterator last);\n\ntemplate<class ForwardIterator, class BinaryPredicate>  \nbool is_sorted(  \n    ForwardIterator first,   \n    ForwardIterator last,   \n    BinaryPredicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator that indicates where the range to check begins.  \n  \n `last`  \n A forward iterator that indicates the end of a range.  \n  \n `comp`  \n The condition to test to determine an order between two elements. A predicate takes a single argument and returns `true` or `false`. This performs the same task as `operator<`.  \n  \n### Remarks  \n The first template function returns [is_sorted_until](http://msdn.microsoft.com/en-us/bbad99d0-deaa-4fe6-ae58-eb5b3e4dded0)`(` `first``,` `last``) ==` `last`. The operator< function performs the order comparison.  \n  \n The second template function returns `is_sorted_until``(` `first``,` `last``,` `comp``) ==` `last`. The `comp` predicate function performs the order comparison.  \n  \n##  <a name=\"is_sorted_until\"></a>  is_sorted_until  \n Returns a `ForwardIterator` that is set to the last element that is in sorted order from a specified range.  \n  \n The second version lets you provide a `BinaryPredicate` function that returns `true` when two given elements are in sorted order, and `false` otherwise.  \n  \n```  \ntemplate<class ForwardIterator>  \n    ForwardIterator is_sorted_until(  \n        ForwardIterator first,   \n        ForwardIterator last  \n    );  \ntemplate<class ForwardIterator, class BinaryPredicate>  \n    ForwardIterator is_sorted_until(  \n        ForwardIterator first,   \n        ForwardIterator last,   \n        BinaryPredicate comp  \n    );  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator that indicates where the range to check starts.  \n  \n `last`  \n A forward iterator that indicates the end of a range.  \n  \n `comp`  \n The condition to test to determine an order between two elements. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Return Value  \n Returns a `ForwardIterator` set to the last element in sorted order. The sorted sequence starts from  `first`.  \n  \n### Remarks  \n The first template function returns the last iterator `next` in `[` `first``,` `last``]` so that `[` `first``, next)` is a sorted sequence ordered by `operator<`. If `distance()` `< 2` the function returns `last`.  \n  \n The second template function behaves the same, except that it replaces `operator<(X, Y)` with `comp``(X, Y)`.  \n  \n##  <a name=\"iter_swap\"></a>  iter_swap  \n Exchanges two values referred to by a pair of specified iterators.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nvoid iter_swap( ForwardIterator1 left, ForwardIterator2 right );  \n  \n```  \n  \n### Parameters  \n `left`  \n One of the forward iterators whose value is to be exchanged.  \n  \n `right`  \n The second of the forward iterators whose value is to be exchanged.  \n  \n### Remarks  \n `swap` should be used in preference to i **ter_swap**, which was included in the C++ Standard for backward compatibility. If `Fit1` and `Fit2` are forward iterators, then `iter_swap` ( `Fit1`, `Fit2` ), is equivalent to `swap` ( * `Fit1`, \\* `Fit2` ).  \n  \n The value types of the input forward iterators must have the same value.  \n  \n### Example  \n  \n```cpp  \n// alg_iter_swap.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt&   operator=( const CInt& rhs ) { m_nVal =  \n   rhs.m_nVal; return *this; }  \n   bool operator<( const CInt& rhs ) const  \n      { return ( m_nVal < rhs.m_nVal );}  \n   friend ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs )  \n{  \n   osIn << \"CInt(\" << rhs.m_nVal << \")\";  \n   return osIn;  \n}  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )  \n      elem1 = - elem1;  \n   if ( elem2 < 0 )  \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main( )  \n{  \n   CInt c1 = 5, c2 = 1, c3 = 10;  \n   deque<CInt> deq1;  \n   deque<CInt>::iterator d1_Iter;  \n  \n   deq1.push_back ( c1 );  \n   deq1.push_back ( c2 );  \n   deq1.push_back ( c3 );  \n  \n   cout << \"The original deque of CInts is deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl;  \n  \n   // Exchanging first and last elements with iter_swap  \n   iter_swap ( deq1.begin ( ) , --deq1.end ( ) );  \n  \n   cout << \"The deque of CInts with first & last elements swapped is:\\n deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl;  \n  \n   // Swapping back first and last elements with swap  \n   swap ( *deq1.begin ( ) , *(deq1.end ( ) -1 ) );  \n  \n   cout << \"The deque of CInts with first & last elements swapped back is:\\n deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl;  \n  \n   // Swapping a vector element with a deque element  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n   deque <int> deq2;  \n   deque <int>::iterator d2_Iter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 3 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii = 4 ; ii <= 5 ; ii++ )  \n   {  \n      deq2.push_back( ii );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Deque deq2 is ( \" ;  \n   for ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )  \n      cout << *d2_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   iter_swap ( v1.begin ( ) , deq2.begin ( ) );  \n  \n   cout << \"After exchanging first elements,\\n vector v1 is: v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl << \" & deque deq2 is: deq2 = ( \";  \n   for ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )  \n      cout << *d2_Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original deque of CInts is deq1 = ( CInt(5), CInt(1), CInt(10) ).  \nThe deque of CInts with first & last elements swapped is:  \n deq1 = ( CInt(10), CInt(1), CInt(5) ).  \nThe deque of CInts with first & last elements swapped back is:  \n deq1 = ( CInt(5), CInt(1), CInt(10) ).  \nVector v1 is ( 0 1 2 3 ).  \nDeque deq2 is ( 4 5 ).  \nAfter exchanging first elements,  \n vector v1 is: v1 = ( 4 1 2 3 ).  \n & deque deq2 is: deq2 = ( 0 5 ).  \n```  \n  \n##  <a name=\"lexicographical_compare\"></a>  lexicographical_compare  \n Compares element by element between two sequences to determine which is lesser of the two.  \n  \n```  \ntemplate<class InputIterator1, class InputIterator2>  \n bool lexicographical_compare(  \n     InputIterator1  first1,  \n     InputIterator1 Last1,  \n     InputIterator2  first2,  \n     InputIterator2 Last2  );  \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate>  \nbool lexicographical_compare(  \n     InputIterator1  first1,  \n     InputIterator1 Last1,  \n     InputIterator2  first2,  \n     InputIterator2 Last2,  \n     BinaryPredicate  comp  );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first range to be compared.  \n  \n `last1`  \n An input iterator addressing the position one past the final element in the first range to be compared.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in the second range to be compared.  \n  \n `last2`  \n An input iterator addressing the position one past the final element in the second range to be compared.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n **true** if the first range is lexicographically less than the second range; otherwise **false**.  \n  \n### Remarks  \n A lexicographical comparison between sequences compares them element by element until:  \n  \n-   It finds two corresponding elements unequal, and the result of their comparison is taken as the result of the comparison between sequences.  \n  \n-   No inequalities are found, but one sequence has more elements than the other, and the shorter sequence is considered less than the longer sequence.  \n  \n-   No inequalities are found and the sequences have the same number of elements, and so the sequences are equal and the result of the comparison is false.  \n  \n### Example  \n  \n```cpp  \n// alg_lex_comp.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Return whether second element is twice the first  \nbool twice ( int elem1, int elem2 )  \n{  \n   return 2 * elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1, v2;  \n   list <int> L1;  \n   vector <int>::iterator Iter1, Iter2;  \n   list <int>::iterator L1_Iter, L1_inIter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n   int ii;  \n   for ( ii = 0 ; ii <= 6 ; ii++ )  \n   {  \n      L1.push_back( 5 * ii );  \n   }  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 5 ; iii++ )  \n   {  \n      v2.push_back( 10 * iii );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"List L1 = ( \" ;  \n   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )  \n      cout << *L1_Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"Vector v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n      cout << \")\" << endl;  \n  \n   // Self lexicographical_comparison of v1 under identity  \n   bool result1;  \n   result1 = lexicographical_compare (v1.begin( ), v1.end( ),  \n                  v1.begin( ), v1.end( ) );  \n   if ( result1 )  \n      cout << \"Vector v1 is lexicographically_less than v1.\" << endl;  \n   else  \n      cout << \"Vector v1 is not lexicographically_less than v1.\" << endl;  \n  \n   // lexicographical_comparison of v1 and L2 under identity  \n   bool result2;  \n   result2 = lexicographical_compare (v1.begin( ), v1.end( ),  \n                  L1.begin( ), L1.end( ) );  \n   if ( result2 )  \n      cout << \"Vector v1 is lexicographically_less than L1.\" << endl;  \n   else  \n      cout << \"Vector v1 is lexicographically_less than L1.\" << endl;  \n  \n   bool result3;  \n   result3 = lexicographical_compare (v1.begin( ), v1.end( ),  \n                  v2.begin( ), v2.end( ), twice );  \n   if ( result3 )  \n      cout << \"Vector v1 is lexicographically_less than v2 \"  \n           << \"under twice.\" << endl;  \n   else  \n      cout << \"Vector v1 is not lexicographically_less than v2 \"  \n           << \"under twice.\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 )  \nList L1 = ( 0 5 10 15 20 25 30 )  \nVector v2 = ( 0 10 20 30 40 50 )  \nVector v1 is not lexicographically_less than v1.  \nVector v1 is lexicographically_less than L1.  \nVector v1 is not lexicographically_less than v2 under twice.  \n```  \n  \n##  <a name=\"lower_bound\"></a>  lower_bound  \n Finds the position of the first element in an ordered range that has a value greater than or equivalent to a specified value, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \n template<class ForwardIterator, class Type>  \n ForwardIterator lower_bound(  \n     ForwardIterator first,  \n     ForwardIterator last,  \n     const Type& value );  \n  \ntemplate<class ForwardIterator, class Type, class BinaryPredicate>  \nForwardIterator lower_bound(   \n     ForwardIterator first,  \n     ForwardIterator last,  \n     const Type& value,  \n     BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n `first`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n `value`  \n The value whose first position or possible first position is being searched for in the ordered range.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator at the position of the first element in an ordered range with a value that is greater than or equivalent to a specified value, where the equivalence is specified with a binary predicate.  \n  \n### Remarks  \n The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.  \n  \n A sorted range is a precondition of using `lower_bound` and where the ordering is the same as specified by with binary predicate.  \n  \n The range is not modified by the algorithm `lower_bound`.  \n  \n The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements  \n  \n The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last – first`).  \n  \n### Example  \n  \n```cpp  \n// alg_lower_bound.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser( int elem1, int elem2 )  \n{  \n    if ( elem1 < 0 )  \n        elem1 = - elem1;  \n    if ( elem2 < 0 )  \n        elem2 = - elem2;  \n    return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n    using namespace std;  \n  \n    vector<int> v1;  \n    // Constructing vector v1 with default less-than ordering  \n    for ( auto i = -1 ; i <= 4 ; ++i )  \n    {  \n        v1.push_back(  i );  \n    }  \n  \n    for ( auto ii =-3 ; ii <= 0 ; ++ii )  \n    {  \n        v1.push_back(  ii  );  \n    }  \n  \n    cout << \"Starting vector v1 = ( \" ;  \n    for (const auto &Iter : v1)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    sort(v1.begin(), v1.end());  \n    cout << \"Original vector v1 with range sorted by the\\n \"  \n        << \"binary predicate less than is v1 = ( \" ;  \n    for (const auto &Iter : v1)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Constructing vector v2 with range sorted by greater  \n    vector<int> v2(v1);  \n  \n    sort(v2.begin(), v2.end(), greater<int>());  \n  \n    cout << \"Original vector v2 with range sorted by the\\n \"  \n        << \"binary predicate greater is v2 = ( \" ;  \n    for (const auto &Iter : v2)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Constructing vectors v3 with range sorted by mod_lesser  \n    vector<int> v3(v1);  \n    sort(v3.begin(), v3.end(), mod_lesser);  \n  \n    cout << \"Original vector v3 with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is v3 = ( \" ;  \n    for (const auto &Iter : v3)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Demonstrate lower_bound  \n  \n    vector<int>::iterator Result;  \n  \n    // lower_bound of 3 in v1 with default binary predicate less<int>()  \n    Result = lower_bound(v1.begin(), v1.end(), 3);  \n    cout << \"The lower_bound in v1 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n  \n    // lower_bound of 3 in v2 with the binary predicate greater<int>( )  \n    Result = lower_bound(v2.begin(), v2.end(), 3, greater<int>());  \n    cout << \"The lower_bound in v2 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n  \n    // lower_bound of 3 in v3 with the binary predicate  mod_lesser  \n    Result = lower_bound(v3.begin(), v3.end(), 3,  mod_lesser);  \n    cout << \"The lower_bound in v3 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n}  \n  \n```  \n  \n##  <a name=\"make_heap\"></a>  make_heap  \n Converts elements from a specified range into a heap in which the first element is the largest and for which a sorting criterion may be specified with a binary predicate.  \n  \n```  \n template<class RandomAccessIterator>  \n void make_heap(  \n     RandomAccessIterator first,  \n     RandomAccessIterator last );  \n  \ntemplate<class RandomAccessIterator, class BinaryPredicate>   \nvoid make_heap(   \n     RandomAccessIterator first,  \n     RandomAccessIterator last,  \n     BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A random-access iterator addressing the position of the first element in the range to be converted into a heap.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the range to be converted into a heap.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n Heaps have two properties:  \n  \n-   The first element is always the largest.  \n  \n-   Elements may be added or removed in logarithmic time.  \n  \n Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md).  \n  \n The complexity is linear, requiring 3 \\* ( * last – first*) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_make_heap.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   random_shuffle( v1.begin( ), v1.end( ) );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Make v1 a heap with default less than ordering  \n   make_heap ( v1.begin( ), v1.end( ) );  \n   cout << \"The heaped version of vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Make v1 a heap with greater than ordering  \n   make_heap ( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"The greater-than heaped version of v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"max\"></a>  max  \n Compares two objects and returns the larger of the two, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class Type>  \n    const Type& max(  \n        const Type& left,   \n        const Type& right  \n    );  \ntemplate<class Type, class Pr>  \n    const Type& max(  \n        const Type& left,   \n        const Type& right,  \n        BinaryPredicate comp  \n    );  \ntemplate<class Type>   \n    Type& max (  \n        initializer_list<Type> _Ilist  \n    );  \ntemplate<class Type, class Pr>   \n    Type& max(  \n        initializer_list<Type> _Ilist,   \n        BinaryPredicate comp  \n    );  \n```  \n  \n### Parameters  \n `left`  \n The first of the two objects being compared.  \n  \n `right`  \n The second of the two objects being compared.  \n  \n `comp`  \n A binary predicate used to compare the two objects.  \n  \n `_IList`  \n The initializer list that contains the objects to be compared.  \n  \n### Return Value  \n The greater of the two objects, unless neither is greater; in that case, it returns the first of the two objects. In the case of an initializer_list, it returns the greatest of the objects in the list.  \n  \n### Remarks  \n The `max` algorithm is unusual in having objects passed as parameters. Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters. If you need a function that operates on a range of elements, use [max_element](../standard-library/algorithm-functions.md#max_element) instead.  \n  \n### Example  \n  \n```cpp  \n// alg_max.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <set>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt&   operator=( const CInt& rhs ) {m_nVal =   \n   rhs.m_nVal; return *this;}  \n   bool operator<( const CInt& rhs ) const   \n      {return ( m_nVal < rhs.m_nVal );}  \n   friend ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs )  \n{  \n   osIn << \"CInt( \" << rhs.m_nVal << \" )\";   \n   return osIn;  \n}  \n  \n// Return whether absolute value of elem1 is greater than   \n// absolute value of elem2  \nbool abs_greater ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = -elem1;  \n   if ( elem2 < 0 )   \n      elem2 = -elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main( )  \n{  \n   int a = 6, b = -7;  \n   // Return the integer with the larger absolute value  \n   const int& result1 = max(a, b, abs_greater);  \n   // Return the larger integer  \n   const int& result2 = max(a, b);  \n  \n   cout << \"Using integers 6 and -7...\" << endl;  \n   cout << \"The integer with the greater absolute value is: \"   \n        << result1 << \".\" << endl;  \n   cout << \"The integer with the greater value is: \"   \n        << result2 << \".\" << endl;  \n   cout << endl;  \n  \n// Comparing the members of an initializer_list  \nconst int& result3 = max({ a, b });  \nconst int& result4 = max({ a, b }, abs_greater);  \n  \ncout << \"Comparing the members of an initializer_list...\" << endl;  \ncout << \"The member with the greater value is: \" << result3 << endl;  \ncout << \"The integer with the greater absolute value is: \" << result4 << endl;  \n  \n   // Comparing set containers with elements of type CInt   \n   // using the max algorithm  \n   CInt c1 = 1, c2 = 2, c3 = 3;  \n   set<CInt> s1, s2, s3;  \n   set<CInt>::iterator s1_Iter, s2_Iter, s3_Iter;  \n  \n   s1.insert ( c1 );  \n   s1.insert ( c2 );  \n   s2.insert ( c2 );  \n   s2.insert ( c3 );  \n  \n   cout << \"s1 = (\";  \n   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )  \n      cout << \" \" << *s1_Iter << \",\";  \n   s1_Iter = --s1.end( );  \n   cout << \" \" << *s1_Iter << \" ).\" << endl;  \n  \n   cout << \"s2 = (\";  \n   for ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )  \n      cout << \" \" << *s2_Iter << \",\";  \n   s2_Iter = --s2.end( );  \n   cout << \" \" << *s2_Iter << \" ).\" << endl;  \n  \n   s3 = max ( s1, s2 );  \n   cout << \"s3 = max ( s1, s2 ) = (\";  \n   for ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )  \n      cout << \" \" << *s3_Iter << \",\";  \n   s3_Iter = --s3.end( );  \n   cout << \" \" << *s3_Iter << \" ).\" << endl << endl;  \n  \n   // Comparing vectors with integer elements using the max algorithm  \n   vector <int> v1, v2, v3, v4, v5;  \n   vector <int>::iterator Iter1, Iter2, Iter3, Iter4, Iter5;  \n  \n   int i;  \n   for ( i = 0 ; i <= 2 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 2 ; ii++ )  \n   {  \n      v2.push_back( ii );  \n   }  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 2 ; iii++ )  \n   {  \n      v3.push_back( 2 * iii );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v2 is ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v3 is ( \" ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n  \n   v4 = max ( v1, v2 );  \n   v5 = max ( v1, v3 );  \n  \n   cout << \"Vector v4 = max (v1,v2) is ( \" ;  \n   for ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )  \n      cout << *Iter4 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v5 = max (v1,v3) is ( \" ;  \n   for ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )  \n      cout << *Iter5 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nUsing integers 6 and -7...  \nThe integer with the greater absolute value is: -7  \nThe integer with the greater value is: 6.  \nComparing the members of an initializer_list...The member with the greater value is: 6The integer wiht the greater absolute value is: -7  \ns1 = ( CInt( 1 ), CInt( 2 ) ).  \ns2 = ( CInt( 2 ), CInt( 3 ) ).  \ns3 = max ( s1, s2 ) = ( CInt( 2 ), CInt( 3 ) ).  \n  \nVector v1 is ( 0 1 2 ).  \nVector v2 is ( 0 1 2 ).  \nVector v3 is ( 0 2 4 ).  \nVector v4 = max (v1,v2) is ( 0 1 2 ).  \nVector v5 = max (v1,v3) is ( 0 2 4 ).  \n```  \n  \n##  <a name=\"max_element\"></a>  max_element  \n Finds the first occurrence of largest element in a specified range where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class ForwardIterator>  \nForwardIterator max_element(ForwardIterator first, ForwardIterator last );  \n  \ntemplate<class ForwardIterator, class BinaryPredicate>  \nForwardIterator max_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be searched for the largest element.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched for the largest element.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n A forward iterator addressing the position of the first occurrence of the largest element in the range searched.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is linear: ( `last` –  `first`) – 1 comparisons are required for a nonempty range.  \n  \n### Example  \n  \n```cpp  \n// alg_max_element.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <set>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt& operator=( const CInt& rhs ) {m_nVal =   \n   rhs.m_nVal; return *this;}  \n   bool operator<( const CInt& rhs ) const   \n      {return ( m_nVal < rhs.m_nVal );}  \n   friend ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<(ostream& osIn, const CInt& rhs)  \n{  \n   osIn << \"CInt( \" << rhs.m_nVal << \" )\";   \n   return osIn;  \n}  \n  \n// Return whether modulus of elem1 is greater than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main( )  \n{  \n   // Searching a set container with elements of type CInt   \n   // for the maximum element   \n   CInt c1 = 1, c2 = 2, c3 = -3;  \n   set<CInt> s1;  \n   set<CInt>::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;  \n  \n   s1.insert ( c1 );  \n   s1.insert ( c2 );  \n   s1.insert ( c3 );  \n  \n   cout << \"s1 = (\";  \n   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )  \n      cout << \" \" << *s1_Iter << \",\";  \n   s1_Iter = --s1.end( );  \n   cout << \" \" << *s1_Iter << \" ).\" << endl;  \n  \n   s1_R1_Iter = max_element ( s1.begin ( ) , s1.end ( ) );  \n  \n   cout << \"The largest element in s1 is: \" << *s1_R1_Iter << endl;  \n   cout << endl;  \n  \n   // Searching a vector with elements of type int for the maximum  \n   // element under default less than & mod_lesser binary predicates  \n   vector <int> v1;  \n   vector <int>::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 3 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii = 1 ; ii <= 4 ; ii++ )  \n   {  \n      v1.push_back( - 2 * ii );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )  \n      cout << *v1_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   v1_R1_Iter = max_element ( v1.begin ( ) , v1.end ( ) );  \n   v1_R2_Iter = max_element ( v1.begin ( ) , v1.end ( ), mod_lesser);  \n  \n   cout << \"The largest element in v1 is: \" << *v1_R1_Iter << endl;  \n   cout << \"The largest element in v1 under the mod_lesser\"  \n        << \"\\n binary predicate is: \" << *v1_R2_Iter << endl;  \n}  \n```  \n  \n##  <a name=\"merge\"></a>  merge  \n Combines all of the elements from two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator>  \n OutputIterator merge(   \n     InputIterator1 first1,   \n     InputIterator1 last1,   \n     InputIterator2 first2,   \n     InputIterator2 last2,   \n     OutputIterator result );   \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate>  \nOutputIterator merge(   \n     InputIterator1 first1,   \n     InputIterator1 last1,   \n     InputIterator2 first2,   \n     InputIterator2 last2,   \n     OutputIterator result,  \n     BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be combined and sorted into a single range.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be combined and sorted into a single range.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be combined and sorted into a single range.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be combined and sorted into a single range.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range where the two source ranges are to be combined into a single sorted range.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n An output iterator addressing the position one past the last element in the sorted destination range.  \n  \n### Remarks  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm **merge**.  \n  \n The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.  \n  \n The complexity of the algorithm is linear with at most ( * last1 – first1*) – ( * last2 – first2*) – 1 comparisons.  \n  \n The [list class](../standard-library/list-class.md) provides a member function \"merge\" to merge the elements of two lists.  \n  \n### Example  \n  \n```cpp  \n// alg_merge.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>   // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 ) {  \n   if (elem1 < 0)   \n      elem1 = - elem1;  \n   if (elem2 < 0)   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1a, v1b, v1 ( 12 );  \n   vector <int>::iterator Iter1a,  Iter1b, Iter1;  \n  \n   // Constructing vector v1a and v1b with default less than ordering  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n      v1a.push_back(  i );  \n  \n   int ii;  \n   for ( ii =-5 ; ii <= 0 ; ii++ )  \n      v1b.push_back(  ii  );  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        << \"binary predicate less than is  v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        << \"binary predicate less than is  v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vector v2 with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );  \n   vector <int>::iterator Iter2a,  Iter2b, Iter2;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2a =  ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2b =  ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vector v3 with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );  \n   vector <int>::iterator Iter3a,  Iter3b, Iter3;  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        << \"binary predicate mod_lesser is   v3a =  ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n        << \"binary predicate mod_lesser is   v3b =  ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To merge inplace in ascending order with default binary   \n   // predicate less <int> ( )  \n   merge ( v1a.begin ( ) , v1a.end ( ) , v1b.begin ( ) , v1b.end ( ) , v1.begin ( ) );  \n   cout << \"Merged inplace with default order,\\n vector v1mod =  ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To merge inplace in descending order, specify binary   \n   // predicate greater<int>( )  \n   merge ( v2a.begin ( ) , v2a.end ( ) , v2b.begin ( ) , v2b.end ( ) ,  \n       v2.begin ( ) ,  greater <int> ( ) );  \n   cout << \"Merged inplace with binary predicate greater specified,\\n \"  \n        << \"vector v2mod  = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Applying A user-defined (UD) binary predicate mod_lesser  \n   merge ( v3a.begin ( ) , v3a.end ( ) , v3b.begin ( ) , v3b.end ( ) ,  \n       v3.begin ( ) ,  mod_lesser );  \n   cout << \"Merged inplace with binary predicate mod_lesser specified,\\n \"  \n        << \"vector v3mod  = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"min\"></a>  min  \n Compares two objects and returns the lesser of the two, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class Type>  \n    const Type& min(  \n        const Type& left,   \n        const Type& right  \n    );  \ntemplate<class Type, class Pr>  \n    const Type& min(  \n        const Type& left,   \n        const Type& right,  \n        BinaryPredicate comp  \n    );  \ntemplate<class Type>   \n    Type min ( initializer_list<Type> _Ilist  \n    );  \ntemplate<class Type, class Pr>    Type min (  \n        initializer_list<Type> _Ilist,   \n        BinaryPredicate comp  \n    );  \n  \n```  \n  \n### Parameters  \n `left`  \n The first of the two objects being compared.  \n  \n `right`  \n The second of the two objects being compared.  \n  \n `comp`  \n A binary predicate used to compare the two objects.  \n  \n `_IList`  \n The initializer_list that contains the members to be compared.  \n  \n### Return Value  \n The lesser of the two objects, unless neither is lesser; in that case, it returns the first of the two objects. In the case of an initializer_list, it returns the least of the objects in the list.  \n  \n### Remarks  \n The `min` algorithm is unusual in having objects passed as parameters. Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters. If you need a function that uses a range of elements, use [min_element](../standard-library/algorithm-functions.md#min_element).  \n  \n### Example  \n  \n```cpp  \n// alg_min.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <set>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n    CInt( int n = 0 ) : m_nVal( n ){}  \n    CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n    CInt& operator=( const CInt& rhs ) {m_nVal =   \n    rhs.m_nVal; return *this;}  \n    bool operator<( const CInt& rhs ) const   \n        {return ( m_nVal < rhs.m_nVal );}  \n    friend ostream& operator<<(ostream& osIn, const CInt& rhs);  \n  \nprivate:  \n    int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs )  \n{  \n    osIn << \"CInt( \" << rhs.m_nVal << \" )\";   \n       return osIn;  \n}  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n    if ( elem1 < 0 )   \n        elem1 = - elem1;  \n    if ( elem2 < 0 )   \n        elem2 = - elem2;  \n    return elem1 < elem2;  \n};  \n  \nint main( )  \n{  \n    // Comparing integers directly using the min algorithm with  \n    // binary predicate mod_lesser & with default less than  \n    int a = 6, b = -7, c = 7 ;  \n    const int& result1 = min ( a, b, mod_lesser );  \n    const int& result2 = min ( b, c );  \n  \n    cout << \"The mod_lesser of the integers 6 & -7 is: \"   \n        << result1 << \".\" << endl;  \n     cout << \"The lesser of the integers -7 & 7 is: \"   \n        << result2 << \".\" << endl;  \n    cout << endl;  \n  \n// Comparing the members of an initializer_list  \n    const int& result3 = min({ a, c });  \n    const int& result4 = min({ a, b }, mod_lesser);  \n  \n    cout << \"The lesser of the integers 6 & 7 is: \"  \n        << result3 << \".\" << endl;  \n    cout << \"The mod_lesser of the integers 6 & -7 is: \"  \n        << result4 << \".\" << endl;  \n    cout << endl;  \n  \n    // Comparing set containers with elements of type CInt   \n       // using the min algorithm  \n    CInt c1 = 1, c2 = 2, c3 = 3;  \n    set<CInt> s1, s2, s3;  \n    set<CInt>::iterator s1_Iter, s2_Iter, s3_Iter;  \n  \n    s1.insert ( c1 );  \n    s1.insert ( c2 );  \n    s2.insert ( c2 );  \n    s2.insert ( c3 );  \n  \n    cout << \"s1 = (\";  \n    for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )  \n        cout << \" \" << *s1_Iter << \",\";  \n    s1_Iter = --s1.end( );  \n        cout << \" \" << *s1_Iter << \" ).\" << endl;  \n  \n    cout << \"s2 = (\";  \n    for ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )  \n        cout << \" \" << *s2_Iter << \",\";  \n    s2_Iter = --s2.end( );  \n    cout << \" \" << *s2_Iter << \" ).\" << endl;  \n  \n    s3 = min ( s1, s2 );  \n    cout << \"s3 = min ( s1, s2 ) = (\";  \n    for ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )  \n        cout << \" \" << *s3_Iter << \",\";  \n    s3_Iter = --s3.end( );  \n    cout << \" \" << *s3_Iter << \" ).\" << endl << endl;  \n  \n    // Comparing vectors with integer elements using min algorithm  \n    vector <int> v1, v2, v3, v4, v5;  \n    vector <int>::iterator Iter1, Iter2, Iter3, Iter4, Iter5;  \n  \n    int i;  \n    for ( i = 0 ; i <= 2 ; i++ )  \n    {  \n        v1.push_back( i );  \n    }  \n  \n    int ii;  \n    for ( ii = 0 ; ii <= 2 ; ii++ )  \n    {  \n        v2.push_back( ii );  \n    }  \n  \n    int iii;  \n    for ( iii = 0 ; iii <= 2 ; iii++ )  \n    {  \n        v3.push_back( 2 * iii );  \n    }  \n  \n    cout << \"Vector v1 is ( \" ;  \n    for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n        cout << *Iter1 << \" \";  \n    cout << \").\" << endl;  \n  \n    cout << \"Vector v2 is ( \" ;  \n    for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n        cout << *Iter2 << \" \";  \n    cout << \").\" << endl;  \n  \n    cout << \"Vector v3 is ( \" ;  \n    for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n        cout << *Iter3 << \" \";  \n    cout << \").\" << endl;  \n  \n    v4 = min ( v1, v2 );  \n    v5 = min ( v1, v3 );  \n  \n    cout << \"Vector v4 = min ( v1,v2 ) is ( \" ;  \n    for ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )  \n        cout << *Iter4 << \" \";  \n    cout << \").\" << endl;  \n  \n    cout << \"Vector v5 = min ( v1,v3 ) is ( \" ;  \n    for ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )  \n        cout << *Iter5 << \" \";  \n    cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe mod_lesser of the integers 6 & -7 is: 6.  \nThe lesser of the integers -7 & 7 is: -7.  \nThe lesser of the integers 6 & 7 is: 6.The mod_lesser of the integers 6 & -7 is: 6.  \ns1 = ( CInt( 1 ), CInt( 2 ) ).  \ns2 = ( CInt( 2 ), CInt( 3 ) ).  \ns3 = min ( s1, s2 ) = ( CInt( 1 ), CInt( 2 ) ).  \n  \nVector v1 is ( 0 1 2 ).  \nVector v2 is ( 0 1 2 ).  \nVector v3 is ( 0 2 4 ).  \nVector v4 = min ( v1,v2 ) is ( 0 1 2 ).  \nVector v5 = min ( v1,v3 ) is ( 0 1 2 ).  \n```  \n  \n##  <a name=\"min_element\"></a>  min_element  \n Finds the first occurrence of smallest element in a specified range where the ordering criterion may be specified by a binary predicate.  \n  \n```  \n template<class ForwardIterator>  \n ForwardIterator min_element(ForwardIterator first, ForwardIterator last );  \n  \ntemplate<class ForwardIterator, class BinaryPredicate>  \nForwardIterator min_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n `first`  \n A forward iterator addressing the position of the first element in the range to be searched for the smallest element.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be searched for the smallest element.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n A forward iterator addressing the position of the first occurrence of the smallest element in the range searched.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is linear: ( `last` – `first`) – 1 comparisons are required for a nonempty range.  \n  \n### Example  \n  \n```cpp  \n// alg_min_element.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <set>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt& operator=( const CInt& rhs ) {m_nVal =   \n   rhs.m_nVal; return *this;}  \n   bool operator<( const CInt& rhs ) const   \n      {return ( m_nVal < rhs.m_nVal );}  \n   friend ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs )  \n{  \n   osIn << \"CInt( \" << rhs.m_nVal << \" )\";   \n   return osIn;  \n}  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main()  \n{  \n   // Searching a set container with elements of type CInt   \n   // for the minimum element   \n   CInt c1 = 1, c2 = 2, c3 = -3;  \n   set<CInt> s1;  \n   set<CInt>::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;  \n  \n   s1.insert ( c1 );  \n   s1.insert ( c2 );  \n   s1.insert ( c3 );  \n  \n   cout << \"s1 = (\";  \n   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )  \n      cout << \" \" << *s1_Iter << \",\";  \n   s1_Iter = --s1.end( );  \n   cout << \" \" << *s1_Iter << \" ).\" << endl;  \n  \n   s1_R1_Iter = min_element ( s1.begin ( ) , s1.end ( ) );  \n  \n   cout << \"The smallest element in s1 is: \" << *s1_R1_Iter << endl;  \n   cout << endl;  \n  \n   // Searching a vector with elements of type int for the maximum  \n   // element under default less than & mod_lesser binary predicates  \n   vector <int> v1;  \n   vector <int>::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 3 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii = 1 ; ii <= 4 ; ii++ )  \n   {  \n      v1.push_back( - 2 * ii );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )  \n      cout << *v1_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   v1_R1_Iter = min_element ( v1.begin ( ) , v1.end ( ) );  \n   v1_R2_Iter = min_element ( v1.begin ( ) , v1.end ( ), mod_lesser);  \n  \n   cout << \"The smallest element in v1 is: \" << *v1_R1_Iter << endl;  \n   cout << \"The smallest element in v1 under the mod_lesser\"  \n        << \"\\n binary predicate is: \" << *v1_R2_Iter << endl;  \n}  \n```  \n  \n```Output  \ns1 = ( CInt( -3 ), CInt( 1 ), CInt( 2 ) ).  \nThe smallest element in s1 is: CInt( -3 )  \n  \nVector v1 is ( 0 1 2 3 -2 -4 -6 -8 ).  \nThe smallest element in v1 is: -8  \nThe smallest element in v1 under the mod_lesser  \n binary predicate is: 0  \n```  \n  \n##  <a name=\"minmax_element\"></a>  minmax_element  \n Performs the work performed by `min_element` and `max_element` in one call.  \n  \n```  \ntemplate<class ForwardIterator>  \n    pair< ForwardIterator, ForwardIterator >  \n        minmax_element(  \n            ForwardIterator  first,   \n            ForwardIterator Last  \n                 );  \ntemplate<class ForwardIterator, class BinaryPredicate>  \n    pair< ForwardIterator, ForwardIterator >  \n        minmax_element(  \n            ForwardIterator  first,   \n            ForwardIterator Last,   \n            BinaryPredicate  comp  \n                );  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator that indicates the beginning of a range.  \n  \n `last`  \n A forward iterator that indicates the end of a range.  \n  \n `comp`  \n An optional test used to order elements.  \n  \n### Return Value  \n Returns  \n  \n `pair<ForwardIterator, ForwardIterator>`  \n  \n `(` [min_element](../standard-library/algorithm-functions.md#min_element)(  `first`, `last`), [max_element](../standard-library/algorithm-functions.md#max_element)(  `first`, `last`)).  \n  \n### Remarks  \n The first template function returns  \n  \n `pair<ForwardIterator,ForwardIterator>`  \n  \n `(min_element(_First,Last),max_element(_First,Last))`.  \n  \n The second template function behaves the same, except that it replaces `operator<(X, Y)` with `comp``(X, Y)`.  \n  \n If the sequence is non-empty, the function performs at most `3 * (``last` `-`  `first` `- 1) / 2` comparisons.  \n  \n##  <a name=\"minmax\"></a>  minmax  \n Compares two input parameters and returns them as a pair, in order of lesser to greater.  \n  \n```  \ntemplate<class Type>  \n    pair<const Type&, const Type&>  \n        minmax(  \n            const Type& left,   \n            const Type& right  \n        );  \ntemplate<class Type, class BinaryPredicate>  \n    pair<const Type&, const Type&>  \n        minmax(  \n            const Type& left,  \n            const Type& right,  \n            BinaryPredicate comp  \n        );  \ntemplate<class Type>     pair<Type&, Type&>         minmax(  \n            initializer_list<Type> _Ilist  \n        );  \ntemplate<class Type, class BinaryPredicate>   \n    pair<Type&, Type&>         minmax(  \n            initializer_list<Type> _Ilist,   \n            BinaryPredicate comp  \n        );  \n  \n```  \n  \n### Parameters  \n `left`  \n The first of the two objects being compared.  \n  \n `right`  \n The second of the two objects being compared.  \n  \n `comp`  \n A binary predicate used to compare the two objects.  \n  \n `_IList`  \n The initializer_list that contains the members to be compared.  \n  \n### Remarks  \n The first template function returns `pair<const Type&, const Type&>(``right``,` `left``)` if `right` is less than `left`. Otherwise, it returns `pair<const Type&, const Type&>(``left``,` `right``)`.  \n  \n The second member function returns a pair where the first element is the lesser and the second is the greater when compared by the predicate `comp`.  \n  \n The remaining template functions behave the same, except that they replace the `left` and `right` parameters with `_IList`.  \n  \n The function performs exactly one comparison.  \n  \n##  <a name=\"mismatch\"></a>  mismatch  \n Compares two ranges element by element and locates the first position where a difference occurs.  \n  \n Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.  \n  \n```  \n template<class InputIterator1, class InputIterator2> pair<InputIterator1, InputIterator2>>   \n mismatch(  \n     InputIterator1 First1,  \n     InputIterator1 Last1,  \n     InputIterator2 First2 );   \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate> pair<InputIterator1, InputIterator2>>  \nmismatch(  \n     InputIterator1 First1,  \n     InputIterator1 Last1,  \n     InputIterator2 First2,  \n     BinaryPredicate Comp );  \n  \n//C++14  \ntemplate<class InputIterator1, class InputIterator2> pair<InputIterator1, InputIterator2>>  \nmismatch(  \n    InputIterator1 First1,  \n     InputIterator1 Last1,  \n     InputIterator2 First2,  \n     InputIterator2 Last2 );  \n  \ntemplate<class InputIterator1, class InputIterator2, class BinaryPredicate> pair<InputIterator1, InputIterator2>>  \nmismatch(  \n     InputIterator1 First1,  \n     InputIterator1 Last1,  \n     InputIterator2 First2,  \n     InputIterator2 Last2,  \n     BinaryPredicate Comp);  \n```  \n  \n### Parameters  \n `First1`  \n An input iterator addressing the position of the first element in the first range to be tested.  \n  \n `Last1`  \n An input iterator addressing the position one past the last element in the first range to be tested.  \n  \n `First2`  \n An input iterator addressing the position of the first element in the second range to be tested.  \n  \n `Last2`  \n An input iterator addressing the position of one past the last element in the second range to be tested.  \n  \n `Comp`  \n User-defined predicate function object that compares the current elements in each range and determines whether they are equivalent. It returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A pair of iterators addressing the positions of the mismatch in the two ranges, the first component iterator to the position in the first range and the second component iterator to the position in the second range. If there is no difference between the elements in the ranges compared or if the binary predicate in the second version is satisfied by all element pairs from the two ranges, then the first component iterator points to the position one past the final element in the first range and the second component iterator to position one past the final element tested in the second range.  \n  \n### Remarks  \n The first template function assumes that there are as many elements in the range beginning at first2 as there are in the range designated by [first1, last1). If there are more in the second range, they are ignored; if there are less then undefined behavior will result.  \n  \n The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.  \n  \n The time complexity of the algorithm is linear in the number of elements contained in the shorter range.  \n  \n The user-defined predicate is not required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.  \n  \n### Example  \n  The following example demonstrates how to use mismatch. The C++03 overload is shown only in order to demonstrate how it can produce an unexpected result.  \n  \n```cpp  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n#include <string>  \n#include <utility>  \n  \nusing namespace std;  \n  \n// Return whether first element is twice the second  \n// Note that this is not a symmetric, reflexive and transitive equivalence.  \n// mismatch and equal accept such predicates, but is_permutation does not.  \nbool twice(int elem1, int elem2)  \n{  \n    return elem1 == elem2 * 2;  \n}  \n  \nvoid PrintResult(const string& msg, const pair<vector<int>::iterator, vector<int>::iterator>& result,  \n    const vector<int>& left, const vector<int>& right)  \n{  \n    // If either iterator stops before reaching the end of its container,  \n    // it means a mismatch was detected.  \n    if (result.first != left.end() || result.second != right.end())  \n    {  \n        string leftpos(result.first == left.end() ? \"end\" : to_string(*result.first));  \n        string rightpos(result.second == right.end() ? \"end\" : to_string(*result.second));  \n        cout << msg << \"mismatch. Left iterator at \" << leftpos  \n            << \" right iterator at \" << rightpos << endl;  \n    }  \n    else  \n    {  \n        cout << msg << \" match.\" << endl;  \n    }  \n}  \n  \nint main()  \n{  \n  \n    vector<int> vec_1{ 0, 5, 10, 15, 20, 25 };  \n    vector<int> vec_2{ 0, 5, 10, 15, 20, 25, 30 };  \n  \n    // Testing different length vectors for mismatch (C++03)  \n    auto match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin());  \n    bool is_mismatch = match_vecs.first != vec_1.end();  \n    cout << \"C++03: vec_1 and vec_2 are a mismatch: \" << boolalpha << is_mismatch << endl;  \n  \n    // Using dual-range overloads:  \n  \n    // Testing different length vectors for mismatch (C++14)  \n    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());  \n    PrintResult(\"C++14: vec_1 and vec_2: \", match_vecs, vec_1, vec_2);  \n  \n    // Identify point of mismatch between vec_1 and modified vec_2.   \n    vec_2[3] = 42;  \n    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());  \n    PrintResult(\"C++14 vec_1 v. vec_2 modified: \", match_vecs, vec_1, vec_2);  \n  \n    // Test vec_3 and vec_4 for mismatch under the binary predicate twice (C++14)    \n    vector<int> vec_3{ 10, 20, 30, 40, 50, 60 };  \n    vector<int> vec_4{ 5, 10, 15, 20, 25, 30 };  \n    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);  \n    PrintResult(\"vec_3 v. vec_4 with pred: \", match_vecs, vec_3, vec_4);  \n  \n    vec_4[5] = 31;  \n    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);  \n    PrintResult(\"vec_3 v. modified vec_4 with pred: \", match_vecs, vec_3, vec_4);  \n  \n    // Compare a vector<int> to a list<int>  \n    list<int> list_1{ 0, 5, 10, 15, 20, 25 };  \n    auto match_vec_list = mismatch(vec_1.begin(), vec_1.end(), list_1.begin(), list_1.end());  \n    is_mismatch = match_vec_list.first != vec_1.end() || match_vec_list.second != list_1.end();  \n    cout << \"vec_1 and list_1 are a mismatch: \" << boolalpha << is_mismatch << endl;  \n  \n    char c;  \n    cout << \"Press a key\" << endl;  \n    cin >> c;  \n  \n}  \n  \n/*  \nOutput:  \nC++03: vec_1 and vec_2 are a mismatch: false  \nC++14: vec_1 and vec_2: mismatch. Left iterator at end right iterator at 30  \nC++14 vec_1 v. vec_2 modified: mismatch. Left iterator at 15 right iterator at 42  \nC++14 vec_3 v. vec_4 with pred:  match.  \nC++14 vec_3 v. modified vec_4 with pred: mismatch. Left iterator at 60 right iterator at 31  \nC++14: vec_1 and list_1 are a mismatch: false  \nPress a key  \n*/  \n  \n```  \n  \n##  <a name=\"alg_move\"></a>  &lt;alg&gt; move  \n Move elements associated with a specified range.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator>  \n    OutputIterator move(  \n        InputIterator first,   \n        InputIterator last,  \n        OutputIterator dest  \n                  );  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates where to start the range of elements to move.  \n  \n `last`  \n An input iterator that indicates the end of a range of elements to move.  \n  \n `dest`  \n The output iterator that is to contain the moved elements.  \n  \n### Remarks  \n The template function evaluates `*(``dest` `+ N) =`  move `(*(` `first` `+ N)))` once for each `N` in the range `[0,` `last` `-`  `first``)`, for strictly increasing values of `N` starting with the lowest value. It then returns `dest` `+ N`. If `dest`and  `first` designate regions of storage, `dest` must not be in the range `[` `first``,` `last``)`.  \n  \n##  <a name=\"move_backward\"></a>  move_backward  \n Moves the elements of one iterator to another. The move starts with the last element in a specified range, and ends with the first element in that range.  \n  \n```  \ntemplate<class BidirectionalIterator1, class BidirectionalIterator2>  \n   BidirectionalIterator2 move_backward(  \n       BidirectionalIterator1 first,   \n       BidirectionalIterator1 last,  \n       BidirectionalIterator2 destEnd);\n  \n```  \n  \n### Parameters  \n  `first`  \n An iterator that indicates the start of a range to move elements from.  \n  \n `last`  \n An iterator that indicates the end of a range to move elements from. This element is not moved.  \n  \n `destEnd`  \n A bidirectional iterator addressing the position of one past the final element in the destination range.  \n  \n### Remarks  \n The template function evaluates `*(``destEnd` `- N - 1) =` `move``(*(``last` `- N - 1)))` once for each `N` in the range `[0,` `last` `-`  `first``)`, for strictly increasing values of `N` starting with the lowest value. It then returns `destEnd` `- (``last` `-`  `first``)`. If `destEnd` and  `first` designate regions of storage, `destEnd` must not be in the range `[` `first``,` `last``)`.  \n  \n `move` and `move_backward` are functionally equivalent to using `copy` and `copy_backward` with a move iterator.  \n  \n##  <a name=\"next_permutation\"></a>  next_permutation  \n Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.  \n  \n```  \ntemplate<class BidirectionalIterator>  \nbool next_permutation(BidirectionalIterator first, BidirectionalIterator last);  \n  \ntemplate<class BidirectionalIterator, class BinaryPredicate>  \nbool next_permutation(BidirectionalIterator first, BidirectionalIterator last, BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator pointing to the position of the first element in the range to be permuted.  \n  \n `last`  \n A bidirectional iterator pointing to the position one past the final element in the range to be permuted.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n **true** if the lexicographically next permutation exists and has replaced the original ordering of the range; otherwise **false**, in which case the ordering is transformed into the lexicographically smallest permutation.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The default binary predicate is less than and the elements in the range must be less than comparable to insure that the next permutation is well defined.  \n  \n The complexity is linear with at most ( * last – first*)/2 swaps.  \n  \n### Example  \n  \n```cpp  \n// alg_next_perm.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt  \n{  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt&   operator=( const CInt& rhs ) {m_nVal =  \n   rhs.m_nVal; return *this;}  \n   bool operator<( const CInt& rhs ) const  \n      { return ( m_nVal < rhs.m_nVal );}  \n   friend   ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs )  \n{  \n   osIn << \"CInt( \" << rhs.m_nVal << \" )\";  \n   return osIn;  \n}  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )  \n      elem1 = - elem1;  \n   if ( elem2 < 0 )  \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main( )  \n{  \n   // Reordering the elements of type CInt in a deque  \n   // using the prev_permutation algorithm  \n   CInt c1 = 5, c2 = 1, c3 = 10;  \n   bool deq1Result;  \n   deque<CInt> deq1, deq2, deq3;  \n   deque<CInt>::iterator d1_Iter;  \n  \n   deq1.push_back ( c1 );  \n   deq1.push_back ( c2 );  \n   deq1.push_back ( c3 );  \n  \n   cout << \"The original deque of CInts is deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl;  \n  \n   deq1Result = next_permutation ( deq1.begin ( ) , deq1.end ( ) );  \n  \n   if ( deq1Result )  \n      cout << \"The lexicographically next permutation \"  \n           << \"exists and has\\nreplaced the original \"  \n           << \"ordering of the sequence in deq1.\" << endl;  \n   else  \n      cout << \"The lexicographically next permutation doesn't \"  \n           << \"exist\\n and the lexicographically \"  \n           << \"smallest permutation\\n has replaced the \"  \n           << \"original ordering of the sequence in deq1.\" << endl;  \n  \n   cout << \"After one application of next_permutation,\\n deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl << endl;  \n  \n   // Permuting vector elements with binary function mod_lesser  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = -3 ; i <= 3 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   next_permutation ( v1.begin ( ) , v1.end ( ) , mod_lesser );  \n  \n   cout << \"After the first next_permutation, vector v1 is:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   int iii = 1;  \n   while ( iii <= 5 ) {  \n      next_permutation ( v1.begin ( ) , v1.end ( ) , mod_lesser );  \n      cout << \"After another next_permutation of vector v1,\\n v1 =   ( \" ;  \n      for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )  \n         cout << *Iter1  << \" \";  \n      cout << \").\" << endl;  \n      iii++;  \n   }  \n}  \n```  \n  \n```Output  \nThe original deque of CInts is deq1 = ( CInt( 5 ), CInt( 1 ), CInt( 10 ) ).  \nThe lexicographically next permutation exists and has  \nreplaced the original ordering of the sequence in deq1.  \nAfter one application of next_permutation,  \n deq1 = ( CInt( 5 ), CInt( 10 ), CInt( 1 ) ).  \n  \nVector v1 is ( -3 -2 -1 0 1 2 3 ).  \nAfter the first next_permutation, vector v1 is:  \n v1 = ( -3 -2 -1 0 1 3 2 ).  \nAfter another next_permutation of vector v1,  \n v1 =   ( -3 -2 -1 0 2 1 3 ).  \nAfter another next_permutation of vector v1,  \n v1 =   ( -3 -2 -1 0 2 3 1 ).  \nAfter another next_permutation of vector v1,  \n v1 =   ( -3 -2 -1 0 3 1 2 ).  \nAfter another next_permutation of vector v1,  \n v1 =   ( -3 -2 -1 0 3 2 1 ).  \nAfter another next_permutation of vector v1,  \n v1 =   ( -3 -2 -1 1 0 2 3 ).  \n```  \n  \n##  <a name=\"nth_element\"></a>  nth_element  \n Partitions a range of elements, correctly locating the                 *n*th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it.  \n  \n```  \ntemplate<class RandomAccessIterator>  \nvoid nth_element( RandomAccessIterator first, RandomAccessIterator _Nth, RandomAccessIterator last);  \n  \n template<class RandomAccessIterator, class BinaryPredicate>  \n void nth_element( RandomAccessIterator first, RandomAccessIterator _Nth, RandomAccessIterator last, BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A random-access iterator addressing the position of the first element in the range to be partitioned.  \n  \n *_Nth*  \n A random-access iterator addressing the position of element to be correctly ordered on the boundary of the partition.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the range to be partitioned.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The `nth_element` algorithm does not guarantee that elements in the sub-ranges either side of the  *n*th element are sorted. It thus makes fewer guarantees than `partial_sort`, which orders the elements in the range below some chosen element, and may be used as a faster alternative to `partial_sort` when the ordering of the lower range is not required.  \n  \n Elements are equivalent, but not necessarily equal, if neither is less than the other.  \n  \n The average of a sort complexity is linear with respect to  * last – first*.  \n  \n### Example  \n  \n```cpp  \n// alg_nth_elem.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether first element is greater than the second  \nbool UDgreater ( int elem1, int elem2 ) {  \n   return elem1 > elem2;  \n}  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n      v1.push_back( 3 * i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 5 ; ii++ )  \n      v1.push_back( 3 * ii + 1 );  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 5 ; iii++ )  \n      v1.push_back( 3 * iii +2 );  \n  \n   cout << \"Original vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   nth_element(v1.begin( ), v1.begin( ) + 3, v1.end( ) );  \n   cout << \"Position 3 partitioned vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To sort in descending order, specify binary predicate  \n   nth_element( v1.begin( ), v1.begin( ) + 4, v1.end( ),  \n          greater<int>( ) );  \n   cout << \"Position 4 partitioned (greater) vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   random_shuffle( v1.begin( ), v1.end( ) );  \n   cout << \"Shuffled vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // A user-defined (UD) binary predicate can also be used  \n   nth_element( v1.begin( ), v1.begin( ) + 5, v1.end( ), UDgreater );  \n   cout << \"Position 5 partitioned (UDgreater) vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n##  <a name=\"none_of\"></a>  none_of  \n Returns `true` when a condition is never present among elements in the given range.  \n  \n```  \ntemplate<class InputIterator, class BinaryPredicate>  \nbool none_of(InputIterator first, InputIterator last, BinaryPredicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates where to start to check a range of elements for a condition.  \n  \n `last`  \n An input iterator that indicates the end of a range of elements.  \n  \n `comp`  \n The condition to test for. This is provided by a user-defined predicate function object that defines the condition. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Return Value  \n Returns `true` if the condition is not detected at least once in the indicated range, and `false` if the condition is detected.  \n  \n### Remarks  \n The template function returns `true` only if, for some `N` in the range `[0,` `last` `-`  `first``)`, the predicate `comp``(*(` `first` `+ N))` is always `false`.  \n  \n##  <a name=\"partial_sort\"></a>  partial_sort  \n Arranges a specified number of the smaller elements in a range into a nondescending order or according to an ordering criterion specified by a binary predicate.  \n  \n```  \ntemplate<class RandomAccessIterator>  \n   void partial_sort(  \n      RandomAccessIterator first,   \n      RandomAccessIterator sortEnd,  \n      RandomAccessIterator last);\n  \ntemplate<class RandomAccessIterator, class BinaryPredicate>  \n   void partial_sort(  \n      RandomAccessIterator first,   \n      RandomAccessIterator sortEnd,  \n      RandomAccessIterator last  \n      BinaryPredicate comp);\n  \n```  \n  \n### Parameters  \n `first`  \n A random-access iterator addressing the position of the first element in the range to be sorted.  \n  \n `sortEnd`  \n A random-access iterator addressing the position one past the final element in the subrange to be sorted.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the range to be partially sorted.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Elements are equivalent, but not necessarily equal, if neither is less than the other. The **sort** algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm `stable_sort` does preserve this original ordering.  \n  \n The average partial sort complexity is  *O*(( `last`- `first`) log ( `sortEnd`- `first`)).  \n  \n### Example  \n  \n```cpp  \n// alg_partial_sort.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether first element is greater than the second  \nbool UDgreater ( int elem1, int elem2 )  \n{  \n   return elem1 > elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 2 * i );  \n   }  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 5 ; ii++ )  \n   {  \n      v1.push_back( 2 * ii +1 );  \n   }  \n  \n   cout << \"Original vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   partial_sort(v1.begin( ), v1.begin( ) + 6, v1.end( ) );  \n   cout << \"Partially sorted vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To partially sort in descending order, specify binary predicate  \n   partial_sort(v1.begin( ), v1.begin( ) + 4, v1.end( ), greater<int>( ) );  \n   cout << \"Partially resorted (greater) vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // A user-defined (UD) binary predicate can also be used  \n   partial_sort(v1.begin( ), v1.begin( ) + 8, v1.end( ),   \n UDgreater );  \n   cout << \"Partially resorted (UDgreater) vector:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector:  \n v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )  \nPartially sorted vector:  \n v1 = ( 0 1 2 3 4 5 10 8 6 7 9 11 )  \nPartially resorted (greater) vector:  \n v1 = ( 11 10 9 8 0 1 2 3 4 5 6 7 )  \nPartially resorted (UDgreater) vector:  \n v1 = ( 11 10 9 8 7 6 5 4 0 1 2 3 )  \n```  \n  \n##  <a name=\"partial_sort_copy\"></a>  partial_sort_copy  \n Copies elements from a source range into a destination range where the source elements are ordered by either less than or another specified binary predicate.  \n  \n```  \n template<class InputIterator, class RandomAccessIterator>  \n RandomAccessIterator partial_sort_copy(  \n    InputIterator first1,  \n    InputIterator last1,  \n    RandomAccessIterator first2,  \n    RandomAccessIterator last2 );  \n  \ntemplate<class InputIterator, class RandomAccessIterator, class BinaryPredicate>  \n RandomAccessIterator partial_sort_copy(  \n     InputIterator first1,  \n     InputIterator last1,  \n     RandomAccessIterator first2,  \n     RandomAccessIterator last2,  \n     BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the source range.  \n  \n `last1`  \n An input iterator addressing the position one past the final element in the source range.  \n  \n  `first2`  \n A random-access iterator addressing the position of the first element in the sorted destination range.  \n  \n `last2`  \n A random-access iterator addressing the position one past the final element in the sorted destination range.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns `true` when satisfied and `false` when not satisfied.  \n  \n### Return Value  \n A random-access iterator addressing the element in the destination range one position beyond the last element inserted from the source range.  \n  \n### Remarks  \n The source and destination ranges must not overlap and must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The binary predicate must provide a strict weak ordering so that elements that are not equivalent are ordered, but elements that are equivalent are not. Two elements are equivalent under less than, but not necessarily equal, if neither is less than the other.  \n  \n### Example  \n  \n```cpp  \n// alg_partial_sort_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n  \nint main() {  \n    using namespace std;  \n    vector<int> v1, v2;  \n    list<int> list1;  \n    vector<int>::iterator iter1, iter2;  \n    list<int>::iterator list1_Iter, list1_inIter;  \n  \n    int i;  \n    for (i = 0; i <= 9; i++)  \n        v1.push_back(i);  \n  \n    random_shuffle(v1.begin(), v1.end());  \n  \n    list1.push_back(60);  \n    list1.push_back(50);  \n    list1.push_back(20);  \n    list1.push_back(30);  \n    list1.push_back(40);  \n    list1.push_back(10);  \n  \n    cout << \"Vector v1 = ( \" ;  \n    for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)  \n        cout << *iter1 << \" \";  \n    cout << \")\" << endl;  \n  \n    cout << \"List list1 = ( \" ;  \n    for (list1_Iter = list1.begin();  \n         list1_Iter!= list1.end();  \n         list1_Iter++)  \n        cout << *list1_Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    // Copying a partially sorted copy of list1 into v1  \n    vector<int>::iterator result1;  \n    result1 = partial_sort_copy(list1.begin(), list1.end(),  \n             v1.begin(), v1.begin() + 3);  \n  \n    cout << \"List list1 Vector v1 = ( \" ;  \n    for (iter1 = v1.begin() ; iter1 != v1.end() ; iter1++)  \n        cout << *iter1 << \" \";  \n    cout << \")\" << endl;  \n    cout << \"The first v1 element one position beyond\"  \n         << \"\\n the last L 1 element inserted was \" << *result1  \n         << \".\" << endl;  \n  \n    // Copying a partially sorted copy of list1 into v2  \n    int ii;  \n    for (ii = 0; ii <= 9; ii++)  \n        v2.push_back(ii);  \n  \n    random_shuffle(v2.begin(), v2.end());  \n    vector<int>::iterator result2;  \n    result2 = partial_sort_copy(list1.begin(), list1.end(),  \n             v2.begin(), v2.begin() + 6);  \n  \n    cout << \"List list1 into Vector v2 = ( \" ;  \n    for (iter2 = v2.begin() ; iter2 != v2.end(); iter2++)  \n        cout << *iter2 << \" \";  \n    cout << \")\" << endl;  \n    cout << \"The first v2 element one position beyond\"  \n         << \"\\n the last L 1 element inserted was \" << *result2  \n         << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"partition\"></a>  partition  \n Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it.  \n  \n```  \ntemplate<class BidirectionalIterator, class Predicate>  \n   BidirectionalIterator partition(  \n      BidirectionalIterator first,   \n      BidirectionalIterator last,   \n      Predicate comp);\n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator addressing the position of the first element in the range to be partitioned.  \n  \n `last`  \n A bidirectional iterator addressing the position one past the final element in the range to be partitioned.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if an element is to be classified. A predicate takes a single argument and returns **true** or **false**.  \n  \n### Return Value  \n A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Elements  *a* and  *b* are equivalent, but not necessarily equal, if both  *Pr* ( *a*,  *b*) is false and  *Pr* ( *b*,  *a*) if false, where  *Pr* is the parameter-specified predicate. The **partition** algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm **stable_ partition** does preserve this original ordering.  \n  \n The complexity is linear: there are ( `last` –  `first`) applications of `comp` and at most ( `last` –  `first`)/2 swaps.  \n  \n### Example  \n  \n```cpp  \n// alg_partition.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater5 ( int value ) {  \n   return value >5;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 10 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n   random_shuffle( v1.begin( ), v1.end( ) );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Partition the range with predicate greater10  \n   partition ( v1.begin( ), v1.end( ), greater5 );  \n   cout << \"The partitioned set of elements in v1 is: ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"partition_copy\"></a>  partition_copy  \n Copies elements for which a condition is `true` to one destination, and for which the condition is `false` to another. The elements must come from a specified range.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator1, class OutputIterator2, class Predicate>  \n    pair<OutputIterator1, OutputIterator2>  \n        partition_copy(  \n            InputIterator first,   \n            InputIterator last,  \n            OutputIterator1 dest1,   \n            OutputIterator2 dest2,   \n            Predicate pred  \n        );  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator that indicates the beginning of a range to check for a condition.  \n  \n `last`  \n An input iterator that indicates the end of a range.  \n  \n `dest1`  \n An output iterator used to copy elements that return true for a condition tested by using `_Pred`.  \n  \n `dest2`  \n An output iterator used to copy elements that return false for a condition tested by using `_Pred`.  \n  \n `_Pred`  \n The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be tested. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Remarks  \n The template function copies each element `X` in `[` `first``,` `last``)` to `*``dest1``++` if `_Pred``(X)` is true, or to `*``dest2``++ if not`. It returns `pair<OutputIterator1, OutputIterator2>(``dest1``,` `dest2``)`.  \n  \n##  <a name=\"partition_point\"></a>  partition_point  \n Returns the first element in the given range that does not satisfy the condition. The elements are sorted so that those that satisfy the condition come before those that do not.  \n  \n```  \ntemplate<class ForwardIterator, class Predicate>  \n    ForwardIterator partition_point(  \n        ForwardIterator first,   \n        ForwardIterator last,  \n        Predicate comp  \n    );  \n```  \n  \n### Parameters  \n  `first`  \n A `ForwardIterator` that indicates the start of a range to check for a condition.  \n  \n `last`  \n A `ForwardIterator` that indicates the end of a range.  \n  \n `comp`  \n The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for. A predicate takes a single argument and returns `true` or `false`.  \n  \n### Return Value  \n Returns a `ForwardIterator` that refers to the first element that does not fulfill the condition tested for by `comp`, or returns `last` if one is not found.  \n  \n### Remarks  \n The template function finds the first iterator `it` in `[` `first``,``last``)` for which `comp(*it)` is `false`. The sequence must be ordered by `comp`.  \n  \n##  <a name=\"pop_heap\"></a>  pop_heap  \n Removes the largest element from the front of a heap to the next-to-last position in the range and then forms a new heap from the remaining elements.  \n  \n```  \ntemplate<class RandomAccessIterator>  \nvoid pop_heap( RandomAccessIterator first, RandomAccessIterator last);  \n  \ntemplate<class RandomAccessIterator, class BinaryPredicate>  \nvoid pop_heap(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A random-access iterator addressing the position of the first element in the heap.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the heap.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n The `pop_heap` algorithm is the inverse of the operation performed by the push_heap algorithm, in which an element at the next-to-last position of a range is added to a heap consisting of the prior elements in the range, in the case when the element being added to the heap is larger than any of the elements already in the heap.  \n  \n Heaps have two properties:  \n  \n-   The first element is always the largest.  \n  \n-   Elements may be added or removed in logarithmic time.  \n  \n Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md).  \n  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The range excluding the newly added element at the end must be a heap.  \n  \n The complexity is logarithmic, requiring at most log ( * last – first*) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_pop_heap.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n  \nint main( )  {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 1 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   // Make v1 a heap with default less than ordering  \n   random_shuffle( v1.begin( ), v1.end( ) );  \n   make_heap ( v1.begin( ), v1.end( ) );  \n   cout << \"The heaped version of vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Add an element to the back of the heap  \n   v1.push_back( 10 );  \n   push_heap( v1.begin( ), v1.end( ) );  \n   cout << \"The reheaped v1 with 10 added is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove the largest element from the heap  \n   pop_heap( v1.begin( ), v1.end( ) );  \n   cout << \"The heap v1 with 10 removed is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl << endl;  \n  \n   // Make v1 a heap with greater-than ordering with a 0 element  \n   make_heap ( v1.begin( ), v1.end( ), greater<int>( ) );  \n   v1.push_back( 0 );  \n   push_heap( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"The 'greater than' reheaped v1 puts the smallest \"  \n        << \"element first:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Application of pop_heap to remove the smallest element  \n   pop_heap( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"The 'greater than' heaped v1 with the smallest element\\n \"  \n        << \"removed from the heap is: ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"prev_permutation\"></a>  prev_permutation  \n Reorders the elements in a range so that the original ordering is replaced by the lexicographically previous greater permutation if it exists, where the sense of previous may be specified with a binary predicate.  \n  \n```  \ntemplate<class BidirectionalIterator>  \n   bool prev_permutation(  \n      BidirectionalIterator first,   \n      BidirectionalIterator last);\n  \ntemplate<class BidirectionalIterator, class BinaryPredicate>  \n   bool prev_permutation(  \n      BidirectionalIterator first,   \n      BidirectionalIterator last,  \n      BinaryPredicate comp);\n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator pointing to the position of the first element in the range to be permuted.  \n  \n `last`  \n A bidirectional iterator pointing to the position one past the final element in the range to be permuted.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns `true` when satisfied and `false` when not satisfied.  \n  \n### Return Value  \n `true` if the lexicographically previous permutation exists and has replaced the original ordering of the range; otherwise `false`, in which case the ordering is transformed into the lexicographically largest permutation.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The default binary predicate is less than and the elements in the range must be less-than comparable to ensure that the previous permutation is well defined.  \n  \n The complexity is linear, with at most ( `last` –  `first`)/2 swaps.  \n  \n### Example  \n  \n```cpp  \n// alg_prev_perm.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \nclass CInt;  \nostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nclass CInt {  \npublic:  \n   CInt( int n = 0 ) : m_nVal( n ){}  \n   CInt( const CInt& rhs ) : m_nVal( rhs.m_nVal ){}  \n   CInt&   operator=( const CInt& rhs ) {m_nVal =  \n   rhs.m_nVal; return *this;}  \n   bool operator<( const CInt& rhs ) const  \n      {return ( m_nVal < rhs.m_nVal );}  \n   friend ostream& operator<<( ostream& osIn, const CInt& rhs );  \n  \nprivate:  \n   int m_nVal;  \n};  \n  \ninline ostream& operator<<( ostream& osIn, const CInt& rhs ) {  \n   osIn << \"CInt( \" << rhs.m_nVal << \" )\";  \n   return osIn;  \n}  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser (int elem1, int elem2 ) {  \n   if ( elem1 < 0 )  \n      elem1 = - elem1;  \n   if ( elem2 < 0 )  \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n};  \n  \nint main() {  \n   // Reordering the elements of type CInt in a deque  \n   // using the prev_permutation algorithm  \n   CInt c1 = 1, c2 = 5, c3 = 10;  \n   bool deq1Result;  \n   deque<CInt> deq1, deq2, deq3;  \n   deque<CInt>::iterator d1_Iter;  \n  \n   deq1.push_back ( c1 );  \n   deq1.push_back ( c2 );  \n   deq1.push_back ( c3 );  \n  \n   cout << \"The original deque of CInts is deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl;  \n  \n   deq1Result = prev_permutation ( deq1.begin ( ) , deq1.end ( ) );  \n  \n   if ( deq1Result )  \n      cout << \"The lexicographically previous permutation \"  \n           << \"exists and has \\nreplaced the original \"  \n           << \"ordering of the sequence in deq1.\" << endl;  \n   else  \n      cout << \"The lexicographically previous permutation doesn't \"  \n           << \"exist\\n and the lexicographically \"  \n           << \"smallest permutation\\n has replaced the \"  \n           << \"original ordering of the sequence in deq1.\" << endl;  \n  \n   cout << \"After one application of prev_permutation,\\n deq1 = (\";  \n   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )  \n      cout << \" \" << *d1_Iter << \",\";  \n   d1_Iter = --deq1.end( );  \n   cout << \" \" << *d1_Iter << \" ).\" << endl << endl;  \n  \n   // Permutating vector elements with binary function mod_lesser  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = -3 ; i <= 3 ; i++ )  \n      v1.push_back( i );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   prev_permutation ( v1.begin ( ) , v1.end ( ) , mod_lesser );  \n  \n   cout << \"After the first prev_permutation, vector v1 is:\\n v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   int iii = 1;  \n   while ( iii <= 5 ) {  \n      prev_permutation ( v1.begin ( ) , v1.end ( ) , mod_lesser );  \n      cout << \"After another prev_permutation of vector v1,\\n v1 =   ( \" ;  \n      for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )  \n         cout << *Iter1  << \" \";  \n      cout << \").\" << endl;  \n      iii++;  \n   }  \n}  \n```  \n  \n```Output  \nThe original deque of CInts is deq1 = ( CInt( 1 ), CInt( 5 ), CInt( 10 ) ).  \nThe lexicographically previous permutation doesn't exist  \n and the lexicographically smallest permutation  \n has replaced the original ordering of the sequence in deq1.  \nAfter one application of prev_permutation,  \n deq1 = ( CInt( 10 ), CInt( 5 ), CInt( 1 ) ).  \n  \nVector v1 is ( -3 -2 -1 0 1 2 3 ).  \nAfter the first prev_permutation, vector v1 is:  \n v1 = ( -3 -2 0 3 2 1 -1 ).  \nAfter another prev_permutation of vector v1,  \n v1 =   ( -3 -2 0 3 -1 2 1 ).  \nAfter another prev_permutation of vector v1,  \n v1 =   ( -3 -2 0 3 -1 1 2 ).  \nAfter another prev_permutation of vector v1,  \n v1 =   ( -3 -2 0 2 3 1 -1 ).  \nAfter another prev_permutation of vector v1,  \n v1 =   ( -3 -2 0 2 -1 3 1 ).  \nAfter another prev_permutation of vector v1,  \n v1 =   ( -3 -2 0 2 -1 1 3 ).  \n```  \n  \n##  <a name=\"push_heap\"></a>  push_heap  \n Adds an element that is at the end of a range to an existing heap consisting of the prior elements in the range.  \n  \n```  \ntemplate<class RandomAccessIterator>  \nvoid push_heap( RandomAccessIterator first, RandomAccessIterator last );  \n  \ntemplate<class RandomAccessIterator, class BinaryPredicate>  \nvoid push_heap( RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate comp);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A random-access iterator addressing the position of the first element in the heap.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the range to be converted into a heap.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n The element must first be pushed back to the end of an existing heap and then the algorithm is used to add this element to the existing heap.  \n  \n Heaps have two properties:  \n  \n-   The first element is always the largest.  \n  \n-   Elements may be added or removed in logarithmic time.  \n  \n Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md).  \n  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The range excluding the newly added element at the end must be a heap.  \n  \n The complexity is logarithmic, requiring at most log ( *last – first*) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_push_heap.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 1 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   random_shuffle( v1.begin( ), v1.end( ) );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Make v1 a heap with default less than ordering  \n   make_heap ( v1.begin( ), v1.end( ) );  \n   cout << \"The heaped version of vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Add an element to the heap  \n   v1.push_back( 10 );  \n   cout << \"The heap v1 with 10 pushed back is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   push_heap( v1.begin( ), v1.end( ) );  \n   cout << \"The reheaped v1 with 10 added is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl << endl;  \n  \n   // Make v1 a heap with greater than ordering  \n   make_heap ( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"The greater-than heaped version of v1 is\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   v1.push_back(0);  \n   cout << \"The greater-than heap v1 with 11 pushed back is\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   push_heap( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"The greater than reheaped v1 with 11 added is\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"random_shuffle\"></a>  random_shuffle  \n The std::random_shuffle() function is deprecated, replaced by [std::shuffle()](../standard-library/algorithm-functions.md#std__shuffle). For a code example and more information, see [\\<random>](../standard-library/random.md) and the Stackoverflow posting                 [Why are std::random_shuffle methods being deprecated in C++14?](http://go.microsoft.com/fwlink/?LinkId=397954).  \n  \n##  <a name=\"remove\"></a>  remove  \n Eliminates a specified value from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.  \n  \n```  \ntemplate<class ForwardIterator, class Type>  \n ForwardIterator remove(ForwardIterator first, ForwardIterator last, const Type& val);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range from which elements are being removed.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range from which elements are being removed.  \n  \n `val`  \n The value that is to be removed from the range.  \n  \n### Return Value  \n A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The order of the elements not removed remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear; there are ( `last` –  `first`) comparisons for equality.  \n  \n The [list class](../standard-library/list-class.md) has a more efficient member function version of **remove**, which also relinks pointers.  \n  \n### Example  \n  \n```cpp  \n// alg_remove.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1, Iter2, new_end;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove elements with a value of 7  \n   new_end = remove ( v1.begin( ), v1.end( ), 7 );  \n  \n   cout << \"Vector v1 with value 7 removed is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To change the sequence size, use erase  \n   v1.erase (new_end, v1.end( ) );  \n  \n   cout << \"Vector v1 resized with value 7 removed is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"remove_copy\"></a>  remove_copy  \n Copies elements from a source range to a destination range, except that elements of a specified value are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator, class Type>  \n OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const Type& val);  \n  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the range from which elements are being removed.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range from which elements are being removed.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range to which elements are being removed.  \n  \n `val`  \n The value that is to be removed from the range.  \n  \n### Return Value  \n A forward iterator addressing the new end position of the destination range, one past the final element of the copy of the remnant sequence free of the specified value.  \n  \n### Remarks  \n The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.  \n  \n The order of the elements not removed remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments.  \n  \n### Example  \n  \n```cpp  \n// alg_remove_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1, v2(10);  \n   vector <int>::iterator Iter1, Iter2, new_end;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle (v1.begin( ), v1.end( ) );  \n   cout << \"The original vector v1 is:     ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove elements with a value of 7  \n   new_end = remove_copy ( v1.begin( ), v1.end( ), v2.begin( ), 7 );  \n  \n   cout << \"Vector v1 is left unchanged as ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v2 is a copy of v1 with the value 7 removed:\\n ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"remove_copy_if\"></a>  remove_copy_if  \n Copies elements from a source range to a destination range, except that satisfying a predicate are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator, class Predicate>  \nOutputIterator remove_copy_if(InputIterator first, InputIterator Last, OutputIterator result, Predicate pred);  \n  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator addressing the position of the first element in the range from which elements are being removed.  \n  \n `last`  \n An input iterator addressing the position one past the final element in the range from which elements are being removed.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range to which elements are being removed.  \n  \n `_Pred`  \n The unary predicate that must be satisfied is the value of an element is to be replaced.  \n  \n### Return Value  \n A forward iterator addressing the new end position of the destination range, one past the final element of the remnant sequence free of the elements satisfying the predicate.  \n  \n### Remarks  \n The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.  \n  \n The order of the elements not removed remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments.  \n  \n For information on how these functions behave, see [Checked Iterators](../standard-library/checked-iterators.md).  \n  \n### Example  \n  \n```cpp  \n// alg_remove_copy_if.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater6 ( int value ) {  \n   return value >6;  \n}  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1, v2(10);  \n   vector <int>::iterator Iter1, Iter2, new_end;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n   cout << \"The original vector v1 is:      ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove elements with a value greater than 6  \n   new_end = remove_copy_if ( v1.begin( ), v1.end( ),   \n      v2.begin( ), greater6 );  \n  \n   cout << \"After the appliation of remove_copy_if to v1,\\n \"  \n        << \"vector v1 is left unchanged as ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v2 is a copy of v1 with values greater \"  \n        << \"than 6 removed:\\n ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != new_end ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"remove_if\"></a>  remove_if  \n Eliminates elements that satisfy a predicate from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.  \n  \n```  \ntemplate<class ForwardIterator, class Predicate>  \n ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator pointing to the position of the first element in the range from which elements are being removed.  \n  \n `last`  \n A forward iterator pointing to the position one past the final element in the range from which elements are being removed.  \n  \n `_Pred`  \n The unary predicate that must be satisfied is the value of an element is to be replaced.  \n  \n### Return Value  \n A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The order of the elements not removed remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear: there are ( `last` –  `first`) comparisons for equality.  \n  \n List has a more efficient member function version of remove which relinks pointers.  \n  \n### Example  \n  \n```cpp  \n// alg_remove_if.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater6 ( int value ) {  \n   return value >6;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2, new_end;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove elements satisfying predicate greater6  \n   new_end = remove_if (v1.begin( ), v1.end( ), greater6 );  \n  \n   cout << \"Vector v1 with elements satisfying greater6 removed is\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To change the sequence size, use erase  \n   v1.erase (new_end, v1.end( ) );  \n  \n   cout << \"Vector v1 resized elements satisfying greater6 removed is\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"replace\"></a>  replace  \n Examines each element in a range and replaces it if it matches a specified value.  \n  \n```  \ntemplate<class ForwardIterator, class Type>  \nvoid replace(ForwardIterator first, ForwardIterator last, const Type& _OldVal, const Type& _NewVal);  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator pointing to the position of the first element in the range from which elements are being replaced.  \n  \n `last`  \n A forward iterator pointing to the position one past the final element in the range from which elements are being replaced.  \n  \n `_OldVal`  \n The old value of the elements being replaced.  \n  \n `_NewVal`  \n The new value being assigned to the elements with the old value.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The order of the elements not replaced remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values.  \n  \n### Example  \n  \n```cpp  \n// alg_replace.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle (v1.begin( ), v1.end( ) );  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements with a value of 7 with a value of 700  \n   replace (v1.begin( ), v1.end( ), 7 , 700);  \n  \n   cout << \"The vector v1 with a value 700 replacing that of 7 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"replace_copy\"></a>  replace_copy  \n Examines each element in a source range and replaces it if it matches a specified value while copying the result into a new destination range.  \n  \n```  \n template<class InputIterator, class OutputIterator, class Type>  \n OutputIterator replace_copy(   \n     InputIterator first,  \n     InputIterator last,  \n     OutputIterator result,  \n     const Type& _OldVal,  \n     const Type& _NewVal);  \n  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator pointing to the position of the first element in the range from which elements are being replaced.  \n  \n `last`  \n An input iterator pointing to the position one past the final element in the range from which elements are being replaced.  \n  \n `result`  \n An output iterator pointing to the first element in the destination range to where the altered sequence of elements is being copied.  \n  \n `_OldVal`  \n The old value of the elements being replaced.  \n  \n `_NewVal`  \n The new value being assigned to the elements with the old value.  \n  \n### Return Value  \n An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.  \n  \n### Remarks  \n The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.  \n  \n The order of the elements not replaced remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values.  \n  \n### Example  \n  \n```cpp  \n// alg_replace_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   list <int> L1 (15);  \n   vector <int>::iterator Iter1;  \n   list <int>::iterator L_Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 15 ; iii++ )  \n      v1.push_back( 1 );  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements in one part of a vector with a value of 7  \n   // with a value of 70 and copy into another part of the vector  \n   replace_copy ( v1.begin( ), v1.begin( ) + 14,v1.end( ) -15, 7 , 70);  \n  \n   cout << \"The vector v1 with a value 70 replacing that of 7 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements in a vector with a value of 70  \n   // with a value of 1 and copy into a list  \n   replace_copy ( v1.begin( ), v1.begin( ) + 14,L1.begin( ), 7 , 1);  \n  \n   cout << \"The list copy L1 of v1 with the value 0 replacing \"  \n        << \"that of 7 is:\\n ( \" ;  \n   for ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )  \n      cout << *L_Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"replace_copy_if\"></a>  replace_copy_if  \n Examines each element in a source range and replaces it if it satisfies a specified predicate while copying the result into a new destination range.  \n  \n```  \ntemplate<class InputIterator, class OutputIterator, class Predicate, class Type>  \nOutputIterator replace_copy_if(  \n    InputIterator first,  \n    InputIterator last,  \n    OutputIterator result,  \n    Predicate pred,  \n    const Type& val);  \n  \n```  \n  \n### Parameters  \n  `first`  \n An input iterator pointing to the position of the first element in the range from which elements are being replaced.  \n  \n `last`  \n An input iterator pointing to the position one past the final element in the range from which elements are being replaced.  \n  \n `result`  \n An output iterator pointing to the position of the first element in the destination range to which elements are being copied.  \n  \n `_Pred`  \n The unary predicate that must be satisfied is the value of an element is to be replaced.  \n  \n `val`  \n The new value being assigned to the elements whose old value satisfies the predicate.  \n  \n### Return Value  \n An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.  \n  \n### Remarks  \n The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.  \n  \n The order of the elements not replaced remains stable.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear; there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values.  \n  \n### Example  \n  \n```cpp  \n// alg_replace_copy_if.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater6 ( int value ) {  \n   return value >6;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   list <int> L1 (13);  \n   vector <int>::iterator Iter1;  \n   list <int>::iterator L_Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 13 ; iii++ )  \n      v1.push_back( 1 );  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements with a value of 7 in the 1st half of a vector  \n   // with a value of 70 and copy it into the 2nd half of the vector  \n   replace_copy_if ( v1.begin( ), v1.begin( ) + 14,v1.end( ) -14,  \n      greater6 , 70);  \n  \n   cout << \"The vector v1 with values of 70 replacing those greater\"  \n        << \"\\n than 6 in the 1st half & copied into the 2nd half is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements in a vector with a value of 70  \n   // with a value of 1 and copy into a list  \n   replace_copy_if ( v1.begin( ), v1.begin( ) + 13,L1.begin( ),  \n      greater6 , -1 );  \n  \n   cout << \"A list copy of vector v1 with the value -1\\n replacing \"  \n        << \"those greater than 6 is:\\n ( \" ;  \n   for ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )  \n      cout << *L_Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"replace_if\"></a>  replace_if  \n Examines each element in a range and replaces it if it satisfies a specified predicate.  \n  \n```  \ntemplate<class ForwardIterator, class Predicate, class Type>  \nvoid replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const Type& val);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator pointing to the position of the first element in the range from which elements are being replaced.  \n  \n `last`  \n An iterator pointing to the position one past the final element in the range from which elements are being replaced.  \n  \n `_Pred`  \n The unary predicate that must be satisfied is the value of an element is to be replaced.  \n  \n `val`  \n The new value being assigned to the elements whose old value satisfies the predicate.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The order of the elements not replaced remains stable.  \n  \n The algorithm `replace_if` is a generalization of the algorithm **replace**, allowing any predicate to be specified, rather than equality to a specified constant value.  \n  \n The `operator==` used to determine the equality between elements must impose an equivalence relation between its operands.  \n  \n The complexity is linear: there are ( `last` –  `first`) comparisons for equality and at most ( `last` –  `first`) assignments of new values.  \n  \n### Example  \n  \n```cpp  \n// alg_replace_if.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater6 ( int value ) {  \n   return value >6;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n      v1.push_back( 7 );  \n  \n   random_shuffle ( v1.begin( ), v1.end( ) );  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Replace elements satisfying the predicate greater6  \n   // with a value of 70  \n   replace_if ( v1.begin( ), v1.end( ), greater6 , 70);  \n  \n   cout << \"The vector v1 with a value 70 replacing those\\n \"  \n        << \"elements satisfying the greater6 predicate is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"reverse\"></a>  reverse  \n Reverses the order of the elements within a range.  \n  \n```  \ntemplate<class BidirectionalIterator>  \n void reverse(BidirectionalIterator first, BidirectionalIterator last);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator pointing to the position of the first element in the range within which the elements are being permuted.  \n  \n `last`  \n A bidirectional iterator pointing to the position one past the final element in the range within which the elements are being permuted.  \n  \n### Remarks  \n The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n### Example  \n  \n```cpp  \n// alg_reverse.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Reverse the elements in the vector   \n   reverse (v1.begin( ), v1.end( ) );  \n  \n   cout << \"The modified vector v1 with values reversed is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 0 1 2 3 4 5 6 7 8 9 ).  \nThe modified vector v1 with values reversed is:  \n ( 9 8 7 6 5 4 3 2 1 0 ).  \n```  \n  \n##  <a name=\"reverse_copy\"></a>  reverse_copy  \n Reverses the order of the elements within a source range while copying them into a destination range  \n  \n```  \ntemplate<class BidirectionalIterator, class OutputIterator>  \nOutputIterator reverse_copy(   \n    BidirectionalIterator  first,  \n    BidirectionalIterator Last,  \n    OutputIterator  result);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator pointing to the position of the first element in the source range within which the elements are being permuted.  \n  \n `last`  \n A bidirectional iterator pointing to the position one past the final element in the source range within which the elements are being permuted.  \n  \n `result`  \n An output iterator pointing to the position of the first element in the destination range to which elements are being copied.  \n  \n### Return Value  \n An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.  \n  \n### Remarks  \n The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n### Example  \n  \n```cpp  \n// alg_reverse_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2( 10 );  \n   vector <int>::iterator Iter1, Iter2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 9 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Reverse the elements in the vector   \n   reverse_copy (v1.begin( ), v1.end( ), v2.begin( ) );  \n  \n   cout << \"The copy v2 of the reversed vector v1 is:\\n ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The original vector v1 remains unmodified as:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"rotate\"></a>  rotate  \n Exchanges the elements in two adjacent ranges.  \n  \n```  \ntemplate<class ForwardIterator>  \n void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be rotated.  \n  \n `middle`  \n A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.  \n  \n`Last`  \n A forward iterator addressing the position one past the final element in the range to be rotated.  \n  \n### Remarks  \n The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is linear with at most ( `last` –  `first`) swaps.  \n  \n### Example  \n  \n```cpp  \n// alg_rotate.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1;  \n   deque <int> d1;  \n   vector <int>::iterator v1Iter1;  \n   deque<int>::iterator d1Iter1;  \n  \n   int i;  \n   for ( i = -3 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii =0 ; ii <= 5 ; ii++ )  \n   {  \n      d1.push_back( ii );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )  \n      cout << *v1Iter1  << \" \";  \n   cout << \").\" << endl;  \n  \n   rotate ( v1.begin ( ) , v1.begin ( ) + 3 , v1.end ( ) );  \n   cout << \"After rotating, vector v1 is ( \" ;  \n   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )  \n      cout << *v1Iter1  << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The original deque d1 is ( \" ;  \n   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )  \n      cout << *d1Iter1  << \" \";  \n   cout << \").\" << endl;  \n  \n   int iii = 1;  \n   while ( iii <= d1.end ( ) - d1.begin ( ) ) {  \n      rotate ( d1.begin ( ) , d1.begin ( ) + 1 , d1.end ( ) );  \n      cout << \"After the rotation of a single deque element to the back,\\n d1 is   ( \" ;  \n      for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )  \n         cout << *d1Iter1  << \" \";  \n      cout << \").\" << endl;  \n      iii++;  \n   }  \n}  \n```  \n  \n```Output  \nVector v1 is ( -3 -2 -1 0 1 2 3 4 5 ).  \nAfter rotating, vector v1 is ( 0 1 2 3 4 5 -3 -2 -1 ).  \nThe original deque d1 is ( 0 1 2 3 4 5 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 1 2 3 4 5 0 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 2 3 4 5 0 1 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 3 4 5 0 1 2 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 4 5 0 1 2 3 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 5 0 1 2 3 4 ).  \nAfter the rotation of a single deque element to the back,  \n d1 is   ( 0 1 2 3 4 5 ).  \n```  \n  \n##  <a name=\"rotate_copy\"></a>  rotate_copy  \n Exchanges the elements in two adjacent ranges within a source range and copies the result to a destination range.  \n  \n```  \ntemplate<class ForwardIterator, class OutputIterator>  \nOutputIterator rotate_copy(  \n    ForwardIterator first,  \n    ForwardIterator middle,  \n    ForwardIterator last,  \n    OutputIterator result );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be rotated.  \n  \n `middle`  \n A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.  \n  \n _ `Last`  \n A forward iterator addressing the position one past the final element in the range to be rotated.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range.  \n  \n### Return Value  \n An output iterator addressing the position one past the final element in the destination range.  \n  \n### Remarks  \n The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is linear with at most ( `last` –  `first`) swaps.  \n  \n### Example  \n  \n```cpp  \n// alg_rotate_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1 , v2 ( 9 );  \n   deque <int> d1 , d2 ( 6 );  \n   vector <int>::iterator v1Iter , v2Iter;  \n   deque<int>::iterator d1Iter , d2Iter;  \n  \n   int i;  \n   for ( i = -3 ; i <= 5 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii =0 ; ii <= 5 ; ii++ )  \n      d1.push_back( ii );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )  \n      cout << *v1Iter  << \" \";  \n   cout << \").\" << endl;  \n  \n   rotate_copy ( v1.begin ( ) , v1.begin ( ) + 3 , v1.end ( ) , v2.begin ( ) );  \n   cout << \"After rotating, the vector v1 remains unchanged as:\\n v1 = ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )  \n      cout << *v1Iter  << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"After rotating, the copy of vector v1 in v2 is:\\n v2 = ( \" ;  \n   for ( v2Iter = v2.begin( ) ; v2Iter != v2.end( ) ;v2Iter ++ )  \n      cout << *v2Iter  << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The original deque d1 is ( \" ;  \n   for ( d1Iter = d1.begin( ) ; d1Iter != d1.end( ) ;d1Iter ++ )  \n      cout << *d1Iter  << \" \";  \n   cout << \").\" << endl;  \n  \n   int iii = 1;  \n   while ( iii <= d1.end ( ) - d1.begin ( ) )  \n   {  \n      rotate_copy ( d1.begin ( ) , d1.begin ( ) + iii , d1.end ( ) , d2.begin ( ) );  \n      cout << \"After the rotation of a single deque element to the back,\\n d2 is   ( \" ;  \n      for ( d2Iter = d2.begin( ) ; d2Iter != d2.end( ) ;d2Iter ++ )  \n         cout << *d2Iter  << \" \";  \n      cout << \").\" << endl;  \n      iii++;  \n   }  \n}  \n```  \n  \n##  <a name=\"search\"></a>  search  \n Searches for the first occurrence of a sequence within a target range whose elements are equal to those in a given sequence of elements or whose elements are equivalent in a sense specified by a binary predicate to the elements in the given sequence.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \n   ForwardIterator1 search(  \n      ForwardIterator1 first1,   \n      ForwardIterator1 last1,  \n      ForwardIterator2 first2,   \n      ForwardIterator2 last2);\n  \ntemplate<class ForwardIterator1, class ForwardIterator2, class Predicate>  \n   ForwardIterator1 search(  \n      ForwardIterator1 first1,   \n      ForwardIterator1 last1,  \n      ForwardIterator2 first2,   \n      ForwardIterator2 last2  \n      Predicate comp);\n  \n```  \n  \n### Parameters  \n  `first1`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last1`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n  `first2`  \n A forward iterator addressing the position of the first element in the range to be matched.  \n  \n `last2`  \n A forward iterator addressing the position one past the final element in the range to be matched.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.  \n  \n Average complexity is linear with respect to the size of the searched range, and worst case complexity is also linear with respect to the size of the sequence being searched for.  \n  \n### Example  \n  \n```cpp  \n// alg_search.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Return whether second element is twice the first  \nbool twice (int elem1, int elem2 )  \n{  \n   return 2 * elem1 == elem2;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   list <int> L1;  \n   vector <int>::iterator Iter1, Iter2;  \n   list <int>::iterator L1_Iter, L1_inIter;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   int ii;  \n   for ( ii = 4 ; ii <= 5 ; ii++ )  \n   {  \n      L1.push_back( 5 * ii );  \n   }  \n  \n   int iii;  \n   for ( iii = 2 ; iii <= 4 ; iii++ )  \n   {  \n      v2.push_back( 10 * iii );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"List L1 = ( \" ;  \n   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )  \n      cout << *L1_Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   cout << \"Vector v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n      cout << \")\" << endl;  \n  \n   // Searching v1 for first match to L1 under identity  \n   vector <int>::iterator result1;  \n   result1 = search (v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );  \n  \n   if ( result1 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is at least one match of L1 in v1\"  \n           << \"\\n and the first one begins at \"  \n           << \"position \"<< result1 - v1.begin( ) << \".\" << endl;  \n  \n   // Searching v1 for a match to L1 under the binary predicate twice  \n   vector <int>::iterator result2;  \n   result2 = search  (v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );  \n  \n   if ( result2 == v1.end( ) )  \n      cout << \"There is no match of L1 in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is a sequence of elements in v1 that \"  \n           << \"are equivalent\\n to those in v2 under the binary \"  \n           << \"predicate twice\\n and the first one begins at position \"  \n           << result2 - v1.begin( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )  \nList L1 = ( 20 25 )  \nVector v2 = ( 20 30 40 )  \nThere is at least one match of L1 in v1  \n and the first one begins at position 4.  \nThere is a sequence of elements in v1 that are equivalent  \n to those in v2 under the binary predicate twice  \n and the first one begins at position 2.  \n```  \n  \n##  <a name=\"search_n\"></a>  search_n  \n Searches for the first subsequence in a range that of a specified number of elements having a particular value or a relation to that value as specified by a binary predicate.  \n  \n```  \ntemplate<class ForwardIterator1, class Diff2, class Type>  \n   ForwardIterator1 search_n(  \n      ForwardIterator1 first1,   \n      ForwardIterator1 last1,  \n      Diff2 count,   \n      const Type& val);\n  \ntemplate<class ForwardIterator1, class Diff2, class Type, class BinaryPredicate>  \n   ForwardIterator1 search_n(  \n      ForwardIterator1 first1,   \n      ForwardIterator1 last1,  \n      Diff2 count,   \n      const Type& val,  \n      BinaryPredicate comp);\n  \n```  \n  \n### Parameters  \n  `first1`  \n A forward iterator addressing the position of the first element in the range to be searched.  \n  \n `last1`  \n A forward iterator addressing the position one past the final element in the range to be searched.  \n  \n `count`  \n The size of the subsequence being searched for.  \n  \n `val`  \n The value of the elements in the sequence being searched for.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.  \n  \n### Remarks  \n The `operator==` used to determine the match between an element and the specified value must impose an equivalence relation between its operands.  \n  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Complexity is linear with respect to the size of the searched.  \n  \n### Example  \n  \n```cpp  \n// alg_search_n.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \n#include <iostream>  \n  \n// Return whether second element is 1/2 of the first  \nbool one_half ( int elem1, int elem2 )  \n{  \n   return elem1 == 2 * elem2;  \n}  \n  \nint main( )   \n{  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   for ( i = 0 ; i <= 2 ; i++ )  \n   {  \n      v1.push_back( 5  );  \n   }  \n  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 5 * i );  \n   }  \n  \n   for ( i = 0 ; i <= 2 ; i++ )  \n   {  \n      v1.push_back( 10  );  \n   }  \n  \n   cout << \"Vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // Searching v1 for first match to (5 5 5) under identity  \n   vector <int>::iterator result1;  \n   result1 = search_n ( v1.begin( ), v1.end( ), 3, 5 );  \n  \n   if ( result1 == v1.end( ) )  \n      cout << \"There is no match for a sequence ( 5 5 5 ) in v1.\"  \n           << endl;  \n   else  \n      cout << \"There is at least one match of a sequence ( 5 5 5 )\"  \n           << \"\\n in v1 and the first one begins at \"  \n           << \"position \"<< result1 - v1.begin( ) << \".\" << endl;  \n  \n   // Searching v1 for first match to (5 5 5) under one_half  \n   vector <int>::iterator result2;  \n   result2 = search_n (v1.begin( ), v1.end( ), 3, 5, one_half );  \n  \n   if ( result2 == v1.end( ) )  \n      cout << \"There is no match for a sequence ( 5 5 5 ) in v1\"  \n           << \" under the equivalence predicate one_half.\" << endl;  \n   else  \n      cout << \"There is a match of a sequence ( 5 5 5 ) \"  \n           << \"under the equivalence\\n predicate one_half \"  \n           << \"in v1 and the first one begins at \"  \n           << \"position \"<< result2 - v1.begin( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 = ( 0 5 10 15 20 25 5 5 5 0 5 10 15 20 25 10 10 10 )  \nThere is at least one match of a sequence ( 5 5 5 )  \n in v1 and the first one begins at position 6.  \nThere is a match of a sequence ( 5 5 5 ) under the equivalence  \n predicate one_half in v1 and the first one begins at position 15.  \n```  \n  \n##  <a name=\"set_difference\"></a>  set_difference  \n Unites all of the elements that belong to one sorted source range, but not to a second sorted source range, into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \n template<class InputIterator1, class InputIterator2, class OutputIterator>  \n OutputIterator set_difference(  \n     InputIterator1  first1,  \n     InputIterator1  last1,  \n     InputIterator2  first2,  \n     InputIterator2  last2,  \n     OutputIterator  result  );  \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate>  \nOutputIterator set_difference(  \n    InputIterator1  first1,  \n    InputIterator1  last1,  \n    InputIterator2  first2,  \n    InputIterator2  last2,  \n    OutputIterator  result,  \n    BinaryPredicate  comp  );  \n  \n```  \n  \n### Parameters  \n `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.  \n  \n `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the difference of the two source ranges.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n An output iterator addressing the position one past the last element in the sorted destination range representing the difference of the two source ranges.  \n  \n### Remarks  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The destination range should not overlap either of the source ranges and should be large enough to contain the first source range.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the `set_difference` algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm merge.  \n  \n The value types of the input iterators need be less-than-comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element such that there are more in the first source range than in the second, then the destination range will contain the number by which the occurrences of those elements in the first source range exceed the occurrences of those elements in the second source range.  \n  \n The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( *last2 – first2*) ) – 1 comparisons for nonempty source ranges.  \n  \n### Example  \n  \n```cpp  \n// alg_set_diff.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser (int elem1, int elem2 )  \n{  \n   if (elem1 < 0)   \n      elem1 = - elem1;  \n   if (elem2 < 0)   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1a, v1b, v1 ( 12 );  \n   vector <int>::iterator Iter1a,  Iter1b, Iter1, Result1;  \n  \n   // Constructing vectors v1a & v1b with default less-than ordering  \n   int i;  \n   for ( i = -1 ; i <= 4 ; i++ )  \n   {  \n      v1a.push_back(  i );  \n   }  \n  \n   int ii;  \n   for ( ii =-3 ; ii <= 0 ; ii++ )  \n   {  \n      v1b.push_back(  ii  );  \n   }  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v2a & v2b with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );  \n   vector <int>::iterator Iter2a, Iter2b, Iter2, Result2;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2a =  ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2b =  ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v3a & v3b with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );  \n   vector <int>::iterator Iter3a,  Iter3b, Iter3, Result3;  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser  );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3a =  ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3b =  ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a difference in asscending  \n   // order with the default binary predicate less <int> ( )  \n   Result1 = set_difference ( v1a.begin ( ) , v1a.end ( ) ,  \n      v1b.begin ( ) , v1b.end ( ) , v1.begin ( ) );  \n   cout << \"Set_difference of source ranges with default order,\"  \n        << \"\\n vector v1mod =  ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a difference in descending  \n   // order specify binary predicate greater<int>( )  \n   Result2 = set_difference ( v2a.begin ( ) , v2a.end ( ) ,  \n      v2b.begin ( ) , v2b.end ( ) ,v2.begin ( ) , greater <int> ( ) );  \n   cout << \"Set_difference of source ranges with binary\"  \n        << \"predicate greater specified,\\n vector v2mod  = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a difference applying a user  \n   // defined binary predicate mod_lesser  \n   Result3 = set_difference (  v3a.begin ( ) , v3a.end ( ) ,  \n      v3b.begin ( ) , v3b.end ( ) , v3.begin ( ) , mod_lesser );  \n   cout << \"Set_difference of source ranges with binary \"  \n        << \"predicate mod_lesser specified,\\n vector v3mod  = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"set_intersection\"></a>  set_intersection  \n Unites all of the elements that belong to both sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \n template<class InputIterator1, class InputIterator2, class OutputIterator>  \n OutputIterator set_intersection(   \n      InputIterator1 first1,  \n      InputIterator1 last1,  \n      InputIterator2 first2,  \n      InputIterator2 last2,  \n      OutputIterator result );  \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate>  \nOutputIterator set_intersection(  \n      InputIterator1 first1,  \n      InputIterator1 last1,  \n      InputIterator2 first2,  \n      InputIterator2 last2,  \n      OutputIterator result,  \n      BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.  \n  \n **_** *Result*  \n An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the intersection of the two source ranges.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n An output iterator addressing the position one past the last element in the sorted destination range representing the intersection of the two source ranges.  \n  \n### Remarks  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the merge algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm.  \n  \n The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.  \n  \n The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) + ( *last2 – first2*) ) – 1 comparisons for nonempty source ranges.  \n  \n### Example  \n  \n```cpp  \n// alg_set_intersection.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>   // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser (int elem1, int elem2 ) {  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main() {  \n   using namespace std;  \n   vector <int> v1a, v1b, v1 ( 12 );  \n   vector <int>::iterator Iter1a,  Iter1b, Iter1, Result1;  \n  \n   // Constructing vectors v1a & v1b with default less than ordering  \n   int i;  \n   for ( i = -1 ; i <= 3 ; i++ )  \n      v1a.push_back( i );  \n  \n   int ii;  \n   for ( ii =-3 ; ii <= 1 ; ii++ )  \n      v1b.push_back( ii );  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v2a & v2b with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );  \n   vector <int>::iterator Iter2a, Iter2b, Iter2, Result2;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        << \"binary predicate greater is   v2a =  ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        << \"binary predicate greater is   v2b =  ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v3a & v3b with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) , v3 ( v1 );  \n   vector <int>::iterator Iter3a,  Iter3b, Iter3, Result3;  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3a =  ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n           <<  \"binary predicate mod_lesser is   v3b =  ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into an intersection in asscending order with the  \n   // default binary predicate less <int> ( )  \n   Result1 = set_intersection ( v1a.begin ( ) , v1a.end ( ) ,  \n      v1b.begin ( ) , v1b.end ( ) , v1.begin ( ) );  \n   cout << \"Intersection of source ranges with default order,\"  \n        << \"\\n vector v1mod =  ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; ++Iter1 )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into an intersection in descending order, specify  \n   // binary predicate greater<int>( )  \n   Result2 = set_intersection ( v2a.begin ( ) , v2a.end ( ) ,  \n      v2b.begin ( ) , v2b.end ( ) ,v2.begin ( ) , greater <int> ( ) );  \n   cout << \"Intersection of source ranges with binary predicate\"  \n        << \" greater specified,\\n vector v2mod  = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; ++Iter2 )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into an intersection applying a user-defined  \n   // binary predicate mod_lesser  \n   Result3 = set_intersection ( v3a.begin ( ) , v3a.end ( ) ,  \n      v3b.begin ( ) , v3b.end ( ) , v3.begin ( ) , mod_lesser );  \n   cout << \"Intersection of source ranges with binary predicate \"  \n        << \"mod_lesser specified,\\n vector v3mod  = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; ++Iter3 )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"set_symmetric_difference\"></a>  set_symmetric_difference  \n Unites all of the elements that belong to one, but not both, of the sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator>  \n OutputIterator set_symmetric_difference(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2,  \n    OutputIterator result );  \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate>  \nOutputIterator set_symmetric_difference(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2,  \n    OutputIterator result,  \n    BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.  \n  \n **_** *Result*  \n An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the symmetric difference of the two source ranges.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n An output iterator addressing the position one past the last element in the sorted destination range representing the symmetric difference of the two source ranges.  \n  \n### Remarks  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm merge.  \n  \n The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the absolute value of the number by which the occurrences of those elements in the one of the source ranges exceeds the occurrences of those elements in the second source range.  \n  \n The complexity of the algorithm is linear with at most 2 \\* ( (*last1 – first1*) – (*last2 – first2*) ) – 1 comparisons for nonempty source ranges.  \n  \n### Example  \n  \n```cpp  \n// alg_set_sym_diff.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser (int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1a, v1b, v1 ( 12 );  \n   vector <int>::iterator Iter1a,  Iter1b, Iter1, Result1;  \n  \n   // Constructing vectors v1a & v1b with default less-than ordering  \n   int i;  \n   for ( i = -1 ; i <= 4 ; i++ )  \n   {  \n      v1a.push_back(  i );  \n   }  \n  \n   int ii;  \n   for ( ii =-3 ; ii <= 0 ; ii++ )  \n   {  \n      v1b.push_back(  ii  );  \n   }  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v2a & v2b with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );  \n   vector <int>::iterator Iter2a, Iter2b, Iter2, Result2;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2a =  ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2b =  ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v3a & v3b with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );  \n   vector <int>::iterator Iter3a, Iter3b, Iter3, Result3;  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser  );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3a =  ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3b =  ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a symmetric difference in ascending  \n   // order with the default binary predicate less <int> ( )  \n   Result1 = set_symmetric_difference ( v1a.begin ( ) , v1a.end ( ) ,  \n      v1b.begin ( ) , v1b.end ( ) , v1.begin ( ) );  \n   cout << \"Set_symmetric_difference of source ranges with default order,\"  \n        << \"\\n vector v1mod =  ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a symmetric difference in descending  \n   // order, specify binary predicate greater<int>( )  \n   Result2 = set_symmetric_difference ( v2a.begin ( ) , v2a.end ( ) ,  \n      v2b.begin ( ) , v2b.end ( ) ,v2.begin ( ) , greater <int> ( ) );  \n   cout << \"Set_symmetric_difference of source ranges with binary\"  \n        << \"predicate greater specified,\\n vector v2mod  = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a symmetric difference applying a user  \n   // defined binary predicate mod_lesser  \n   Result3 = set_symmetric_difference ( v3a.begin ( ) , v3a.end ( ) ,  \n      v3b.begin ( ) , v3b.end ( ) , v3.begin ( ) , mod_lesser );  \n   cout << \"Set_symmetric_difference of source ranges with binary \"  \n        << \"predicate mod_lesser specified,\\n vector v3mod  = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"set_union\"></a>  set_union  \n Unites all of the elements that belong to at least one of two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \n template<class InputIterator1, class InputIterator2, class OutputIterator>  \n OutputIterator set_union(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2,  \n    OutputIterator result );   \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate>  \nOutputIterator set_union(  \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    InputIterator2 last2,  \n    OutputIterator result,  \n    BinaryPredicate comp );  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.  \n  \n `last1`  \n An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.  \n  \n `last2`  \n An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.  \n  \n **_** *Result*  \n An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the union of the two source ranges.  \n  \n `comp`  \n User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return **true** when the first element is less than the second element and **false** otherwise.  \n  \n### Return Value  \n An output iterator addressing the position one past the last element in the sorted destination range representing the union of the two source ranges.  \n  \n### Remarks  \n The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.  \n  \n The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.  \n  \n The sorted source ranges must each be arranged as a precondition to the application of the **merge** algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.  \n  \n The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm **merge**.  \n  \n The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.  \n  \n The complexity of the algorithm is linear with at most 2 \\* ( ( *last1 – first1*) – ( *last2 – first2*) ) – 1 comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_set_union.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1a, v1b, v1 ( 12 );  \n   vector <int>::iterator Iter1a, Iter1b, Iter1, Result1;  \n  \n   // Constructing vectors v1a & v1b with default less than ordering  \n   int i;  \n   for ( i = -1 ; i <= 3 ; i++ )  \n   {  \n      v1a.push_back(  i );  \n   }  \n  \n   int ii;  \n   for ( ii =-3 ; ii <= 1 ; ii++ )  \n   {  \n      v1b.push_back(  ii  );  \n   }  \n  \n   cout << \"Original vector v1a with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1a = ( \" ;  \n   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )  \n      cout << *Iter1a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v1b with range sorted by the\\n \"  \n        <<  \"binary predicate less than is  v1b = ( \" ;  \n   for ( Iter1b = v1b.begin ( ) ; Iter1b != v1b.end ( ) ; Iter1b++ )  \n      cout << *Iter1b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v2a & v2b with ranges sorted by greater  \n   vector <int> v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );  \n   vector <int>::iterator Iter2a,  Iter2b, Iter2, Result2;  \n   sort ( v2a.begin ( ) , v2a.end ( ) , greater<int> ( ) );  \n   sort ( v2b.begin ( ) , v2b.end ( ) , greater<int> ( ) );  \n  \n   cout << \"Original vector v2a with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2a =  ( \" ;  \n   for ( Iter2a = v2a.begin ( ) ; Iter2a != v2a.end ( ) ; Iter2a++ )  \n      cout << *Iter2a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v2b with range sorted by the\\n \"  \n        <<  \"binary predicate greater is   v2b =  ( \" ;  \n   for ( Iter2b = v2b.begin ( ) ; Iter2b != v2b.end ( ) ; Iter2b++ )  \n      cout << *Iter2b << \" \";  \n   cout << \").\" << endl;  \n  \n   // Constructing vectors v3a & v3b with ranges sorted by mod_lesser  \n   vector <int> v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );  \n   vector <int>::iterator Iter3a, Iter3b, Iter3, Result3;  \n   sort ( v3a.begin ( ) , v3a.end ( ) , mod_lesser );  \n   sort ( v3b.begin ( ) , v3b.end ( ) , mod_lesser  );  \n  \n   cout << \"Original vector v3a with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3a =  ( \" ;  \n   for ( Iter3a = v3a.begin ( ) ; Iter3a != v3a.end ( ) ; Iter3a++ )  \n      cout << *Iter3a << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Original vector v3b with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is   v3b =  ( \" ;  \n   for ( Iter3b = v3b.begin ( ) ; Iter3b != v3b.end ( ) ; Iter3b++ )  \n      cout << *Iter3b << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a union in ascending order with the default   \n    // binary predicate less <int> ( )  \n   Result1 = set_union ( v1a.begin ( ) , v1a.end ( ) ,  \n      v1b.begin ( ) , v1b.end ( ) , v1.begin ( ) );  \n   cout << \"Union of source ranges with default order,\"  \n        << \"\\n vector v1mod =  ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a union in descending order, specify binary   \n   // predicate greater<int>( )  \n   Result2 = set_union (  v2a.begin ( ) , v2a.end ( ) ,  \n      v2b.begin ( ) , v2b.end ( ) ,v2.begin ( ) , greater <int> ( ) );  \n   cout << \"Union of source ranges with binary predicate greater \"  \n        << \"specified,\\n vector v2mod  = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // To combine into a union applying a user-defined  \n   // binary predicate mod_lesser  \n   Result3 = set_union ( v3a.begin ( ) , v3a.end ( ) ,  \n      v3b.begin ( ) , v3b.end ( ) , v3.begin ( ) , mod_lesser );  \n   cout << \"Union of source ranges with binary predicate \"  \n        << \"mod_lesser specified,\\n vector v3mod  = ( \" ; ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"std__shuffle\"></a>  std::shuffle  \n Shuffles (rearranges) elements for a given range by using a random number generator.  \n  \n```  \ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>  \nvoid shuffle(RandomAccessIterator first,  \n    RandomAccessIterator last,  \n    UniformRandomNumberGenerator&& gen);  \n```  \n  \n### Parameters  \n `first`  \n An iterator to the first element in the range to be shuffled, inclusive. Must meet the requirements of `RandomAccessIterator` and `ValueSwappable`.  \n  \n `last`  \n An iterator to the last element in the range to be shuffled, exclusive. Must meet the requirements of `RandomAccessIterator` and `ValueSwappable`.  \n  \n `gen`  \n The random number generator that the `shuffle()` function will use for the operation. Must meet the requirements of a `UniformRandomNumberGenerator`.  \n  \n### Remarks  \n For more information, and a code sample that uses `shuffle()`, see [\\<random>](../standard-library/random.md).  \n  \n##  <a name=\"sort\"></a>  sort  \n Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.  \n  \n```  \ntemplate<class RandomAccessIterator>  \n   void sort(  \n      RandomAccessIterator first,   \n      RandomAccessIterator last);\n  \ntemplate<class RandomAccessIterator, class Predicate>  \n   void sort(  \n      RandomAccessIterator first,   \n      RandomAccessIterator last,   \n      Predicate comp);\n  \n```  \n  \n### Parameters  \n `first`  \n A random-access iterator addressing the position of the first element in the range to be sorted.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the range to be sorted.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. This binary predicate takes two arguments and returns `true` if the two arguments are in order and `false` otherwise. This comparator function must impose a strict weak ordering on pairs of elements from the sequence. For more information, see [Algorithms](../standard-library/algorithms.md).  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Elements are equivalent, but not necessarily equal, if neither is less than the other. The `sort` algorithm is not stable and so does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm `stable_sort` does preserve this original ordering.  \n  \n The average of a sort complexity is  *O*( *N* log  *N*), where  *N* =  *last – first*.  \n  \n### Example  \n  \n```cpp  \n// alg_sort.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether first element is greater than the second  \nbool UDgreater ( int elem1, int elem2 )  \n{  \n   return elem1 > elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 2 * i );  \n   }  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 5 ; ii++ )  \n   {  \n      v1.push_back( 2 * ii + 1 );  \n   }  \n  \n   cout << \"Original vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   sort( v1.begin( ), v1.end( ) );  \n   cout << \"Sorted vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To sort in descending order. specify binary predicate  \n   sort( v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"Resorted (greater) vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // A user-defined (UD) binary predicate can also be used  \n   sort( v1.begin( ), v1.end( ), UDgreater );  \n   cout << \"Resorted (UDgreater) vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )  \nSorted vector v1 = ( 0 1 2 3 4 5 6 7 8 9 10 11 )  \nResorted (greater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )  \nResorted (UDgreater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )  \n```  \n  \n##  <a name=\"sort_heap\"></a>  sort_heap  \n Converts a heap into a sorted range.  \n  \n```  \ntemplate<class RandomAccessIterator>  \n   void sort_heap(  \n      RandomAccessIterator first,   \n      RandomAccessIterator last);\n  \ntemplate<class RandomAccessIterator, class Predicate>  \n   void sort_heap(  \n      RandomAccessIterator first,   \n      RandomAccessIterator last,  \n      Predicate comp);  \n```  \n  \n### Parameters  \n  `first`  \n A random-access iterator addressing the position of the first element in the target heap.  \n  \n `last`  \n A random-access iterator addressing the position one past the final element in the target heap.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n Heaps have two properties:  \n  \n-   The first element is always the largest.  \n  \n-   Elements may be added or removed in logarithmic time.  \n  \n After the application if this algorithm, the range it was applied to is no longer a heap.  \n  \n This is not a stable sort because the relative order of equivalent elements is not necessarily preserved.  \n  \n Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor [priority_queue Class](../standard-library/priority-queue-class.md).  \n  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is at most  *N* log  *N*, where  *N* = ( *last – first*).  \n  \n### Example  \n  \n```cpp  \n// alg_sort_heap.cpp  \n// compile with: /EHsc  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n#include <ostream>  \n#include <string>  \n#include <vector>  \nusing namespace std;  \n  \nvoid print(const string& s, const vector<int>& v) {  \n    cout << s << \": ( \";  \n  \n    for (auto i = v.begin(); i != v.end(); ++i) {  \n        cout << *i << \" \";  \n    }  \n  \n    cout << \")\" << endl;  \n}  \n  \nint main() {  \n    vector<int> v;  \n    for (int i = 1; i <= 9; ++i) {  \n        v.push_back(i);  \n    }  \n    print(\"Initially\", v);  \n  \n    random_shuffle(v.begin(), v.end());  \n    print(\"After random_shuffle\", v);  \n  \n    make_heap(v.begin(), v.end());  \n    print(\"     After make_heap\", v);  \n  \n    sort_heap(v.begin(), v.end());  \n    print(\"     After sort_heap\", v);  \n  \n    random_shuffle(v.begin(), v.end());  \n    print(\"             After random_shuffle\", v);  \n  \n    make_heap(v.begin(), v.end(), greater<int>());  \n    print(\"After make_heap with greater<int>\", v);  \n  \n    sort_heap(v.begin(), v.end(), greater<int>());  \n    print(\"After sort_heap with greater<int>\", v);  \n}  \n```  \n  \n##  <a name=\"stable_partition\"></a>  stable_partition  \n Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it, preserving the relative order of equivalent elements.  \n  \n```  \ntemplate<class BidirectionalIterator, class Predicate>  \nBidirectionalIterator stable_partition(  \n    BidirectionalIterator first,  \n    BidirectionalIterator last,  \n    Predicate pred );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator addressing the position of the first element in the range to be partitioned.  \n  \n `last`  \n A bidirectional iterator addressing the position one past the final element in the range to be partitioned.  \n  \n `_Pred`  \n User-defined predicate function object that defines the condition to be satisfied if an element is to be classified. A predicate takes single argument and returns **true** or **false**.  \n  \n### Return Value  \n A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Elements  *a* and  *b* are equivalent, but not necessarily equal, if both  *Pr* ( *a*,  *b*) is false and  *Pr* ( *b*,  *a*) if false, where  *Pr* is the parameter-specified predicate. The **stable_ partition** algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved. The algorithm **partition** does not necessarily preserve this original ordering.  \n  \n### Example  \n  \n```cpp  \n// alg_stable_partition.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nbool greater5 ( int value ) {  \n   return value >5;  \n}  \n  \nint main( ) {  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2, result;  \n  \n   int i;  \n   for ( i = 0 ; i <= 10 ; i++ )  \n      v1.push_back( i );  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 4 ; ii++ )  \n      v1.push_back( 5 );  \n  \n   random_shuffle(v1.begin( ), v1.end( ) );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Partition the range with predicate greater10  \n   result = stable_partition (v1.begin( ), v1.end( ), greater5 );  \n   cout << \"The partitioned set of elements in v1 is:\\n ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The first element in v1 to fail to satisfy the\"  \n        << \"\\n predicate greater5 is: \" << *result << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"stable_sort\"></a>  stable_sort  \n Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate and preserves the relative ordering of equivalent elements.  \n  \n```  \ntemplate<class BidirectionalIterator>  \n void stable_sort( BidirectionalIterator first, BidirectionalIterator last );  \n  \ntemplate<class BidirectionalIterator, class BinaryPredicate>  \nvoid stable_sort(   \n    BidirectionalIterator first,  \n    BidirectionalIterator last,   \n    BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A bidirectional iterator addressing the position of the first element in the range to be sorted.  \n  \n `last`  \n A bidirectional iterator addressing the position one past the final element in the range to be sorted.  \n  \n `comp`  \n User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Remarks  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.  \n  \n Elements are equivalent, but not necessarily equal, if neither is less than the other. The **sort** algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.  \n  \n The run-time complexity of `stable_sort` depends on the amount of memory available, but the best case (given sufficient memory) is  *O*( *N* log  *N*) and the worst case is  *O*(  *N* ( log  *N* )2 ), where  *N* =  *last – First.* Usually, the **sort** algorithm is significantly faster than `stable_sort`.  \n  \n### Example  \n  \n```cpp  \n// alg_stable_sort.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // For greater<int>( )  \n#include <iostream>  \n  \n// Return whether first element is greater than the second  \nbool UDgreater (int elem1, int elem2 )  \n{  \n   return elem1 > elem2;  \n}  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 2 * i );  \n   }  \n  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( 2 * i  );  \n   }  \n  \n   cout << \"Original vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   stable_sort(v1.begin( ), v1.end( ) );  \n   cout << \"Sorted vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To sort in descending order, specify binary predicate  \n   stable_sort(v1.begin( ), v1.end( ), greater<int>( ) );  \n   cout << \"Resorted (greater) vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // A user-defined (UD) binary predicate can also be used  \n   stable_sort(v1.begin( ), v1.end( ), UDgreater );  \n   cout << \"Resorted (UDgreater) vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector v1 = ( 0 2 4 6 8 10 0 2 4 6 8 10 )  \nSorted vector v1 = ( 0 0 2 2 4 4 6 6 8 8 10 10 )  \nResorted (greater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )  \nResorted (UDgreater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )  \n```  \n  \n##  <a name=\"swap\"></a>  swap  \n The first override exchanges the values of two objects. The second override exchanges the values between two arrays of objects.  \n  \n```  \ntemplate<class Type>  \n   void swap(  \n      Type& left,   \n      Type& right);  \ntemplate<class Type, size_t N>  \n   void swap(  \n      Type (& left)[N],  \n      Type (& right)[N]);\\r\n  \n```  \n  \n### Parameters  \n `left`  \n For the first override, the first object to have its contents exchanged. For the second override, the first array of objects to have its contents exchanged.  \n  \n `right`  \n For the first override, the second object to have its contents exchanged. For the second override, the second array of objects to have its contents exchanged.  \n  \n### Remarks  \n The first overload is designed to operate on individual objects. The second overload swaps the contents of objects between two arrays.  \n  \n### Example  \n  \n```cpp  \n// alg_swap.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   vector <int> v1, v2;  \n   vector <int>::iterator Iter1, Iter2, result;  \n  \n   for ( int i = 0 ; i <= 10 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   for ( int ii = 0 ; ii <= 4 ; ii++ )  \n   {  \n      v2.push_back( 5 );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v2 is ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   swap( v1, v2 );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Vector v2 is ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 is ( 0 1 2 3 4 5 6 7 8 9 10 ).  \nVector v2 is ( 5 5 5 5 5 ).  \nVector v1 is ( 5 5 5 5 5 ).  \nVector v2 is ( 0 1 2 3 4 5 6 7 8 9 10 ).  \n```  \n  \n##  <a name=\"swap_ranges\"></a>  swap_ranges  \n Exchanges the elements of one range with the elements of another, equal sized range.  \n  \n```  \ntemplate<class ForwardIterator1, class ForwardIterator2>  \nForwardIterator2 swap_ranges(   \n   ForwardIterator1 first1,  \n   ForwardIterator1 last1,  \n   ForwardIterator2 first2 );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n A forward iterator pointing to the first position of the first range whose elements are to be exchanged.  \n  \n `last1`  \n A forward iterator pointing to one past the final position of the first range whose elements are to be exchanged.  \n  \n  `first2`  \n A forward iterator pointing to the first position of the second range whose elements are to be exchanged.  \n  \n### Return Value  \n A forward iterator pointing to one past the final position of the second range whose elements are to be exchanged.  \n  \n### Remarks  \n The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation. The second range has to be as large as the first range.  \n  \n The complexity is linear with `last1` –  `first1` swaps performed. If elements from containers of the same type are being swapped, them the `swap` member function from that container should be used, because the member function typically has constant complexity.  \n  \n### Example  \n  \n```cpp  \n// alg_swap_ranges.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <deque>  \n#include <algorithm>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   vector <int> v1;  \n   deque <int> d1;  \n   vector <int>::iterator v1Iter1;  \n   deque<int>::iterator d1Iter1;  \n  \n   int i;  \n   for ( i = 0 ; i <= 5 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   int ii;  \n   for ( ii =4 ; ii <= 9 ; ii++ )  \n   {  \n      d1.push_back( 6 );  \n   }  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )  \n      cout << *v1Iter1  << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"Deque d1 is  ( \" ;  \n   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )  \n      cout << *d1Iter1  << \" \";  \n   cout << \").\" << endl;  \n  \n   swap_ranges ( v1.begin ( ) , v1.end ( ) , d1.begin ( ) );  \n  \n   cout << \"After the swap_range, vector v1 is ( \" ;  \n   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )  \n      cout << *v1Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"After the swap_range deque d1 is   ( \" ;  \n   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )  \n      cout << *d1Iter1 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 is ( 0 1 2 3 4 5 ).  \nDeque d1 is  ( 6 6 6 6 6 6 ).  \nAfter the swap_range, vector v1 is ( 6 6 6 6 6 6 ).  \nAfter the swap_range deque d1 is   ( 0 1 2 3 4 5 ).  \n```  \n  \n##  <a name=\"transform\"></a>  transform  \n Applies a specified function object to each element in a source range or to a pair of elements from two source ranges and copies the return values of the function object into a destination range.  \n  \n```  \n template<class InputIterator, class OutputIterator, class UnaryFunction>  \n OutputIterator transform(  \n    InputIterator first1,  \n    InputIterator last1,  \n    OutputIterator result,  \n    UnaryFunction _Func );  \n  \ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class BinaryFunction>  \nOutputIterator transform(   \n    InputIterator1 first1,  \n    InputIterator1 last1,  \n    InputIterator2 first2,  \n    OutputIterator result,  \n    BinaryFunction _Func );  \n  \n```  \n  \n### Parameters  \n  `first1`  \n An input iterator addressing the position of the first element in the first source range to be operated on.  \n  \n `last1`  \n An input iterator addressing the position one past the final element in the first source range operated on.  \n  \n  `first2`  \n An input iterator addressing the position of the first element in the second source range to be operated on.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range.  \n  \n `_Func`  \n User-defined unary function object used in the first version of the algorithm that is applied to each element in the first source range or A user-defined (UD) binary function object used in the second version of the algorithm that is applied pairwise, in a forward order, to the two source ranges.  \n  \n### Return Value  \n An output iterator addressing the position one past the final element in the destination range that is receiving the output elements transformed by the function object.  \n  \n### Remarks  \n The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation. The destination range must be large enough to contain the transformed source range.  \n  \n If `result` is set equal to  `first1` in the first version of the algorithm *,* then the source and destination ranges will be the same and the sequence will be modified in place. But the `result` may not address a position within the range [  `first1` +1, `last1`).  \n  \n The complexity is linear with at most ( `last1` –  `first1`) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_transform.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n  \n// The function object multiplies an element by a Factor  \ntemplate <class Type>  \nclass MultValue  \n{  \n   private:  \n      Type Factor;   // The value to multiply by  \n   public:  \n      // Constructor initializes the value to multiply by  \n      MultValue ( const Type& val ) : Factor ( val ) {  \n      }  \n  \n      // The function call for the element to be multiplied  \n      Type operator ( ) ( Type& elem ) const   \n      {  \n         return elem * Factor;  \n      }  \n};  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1, v2 ( 7 ), v3 ( 7 );  \n   vector <int>::iterator Iter1, Iter2 , Iter3;  \n  \n   // Constructing vector v1  \n   int i;  \n   for ( i = -4 ; i <= 2 ; i++ )  \n   {  \n      v1.push_back(  i );  \n   }  \n  \n   cout << \"Original vector  v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Modifying the vector v1 in place  \n   transform (v1.begin ( ) , v1.end ( ) , v1.begin ( ) , MultValue<int> ( 2 ) );  \n   cout << \"The elements of the vector v1 multiplied by 2 in place gives:\"  \n        << \"\\n v1mod = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Using transform to multiply each element by a factor of 5  \n   transform ( v1.begin ( ) , v1.end ( ) , v2.begin ( ) , MultValue<int> ( 5 ) );  \n  \n   cout << \"Multiplying the elements of the vector v1mod\\n \"  \n        <<  \"by the factor 5 & copying to v2 gives:\\n v2 = ( \" ;  \n   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )  \n      cout << *Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // The second version of transform used to multiply the   \n   // elements of the vectors v1mod & v2 pairwise  \n   transform ( v1.begin ( ) , v1.end ( ) ,  v2.begin ( ) , v3.begin ( ) ,   \n      multiplies <int> ( ) );  \n  \n   cout << \"Multiplying elements of the vectors v1mod and v2 pairwise \"  \n        <<  \"gives:\\n v3 = ( \" ;  \n   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )  \n      cout << *Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector  v1 = ( -4 -3 -2 -1 0 1 2 ).  \nThe elements of the vector v1 multiplied by 2 in place gives:  \n v1mod = ( -8 -6 -4 -2 0 2 4 ).  \nMultiplying the elements of the vector v1mod  \n by the factor 5 & copying to v2 gives:  \n v2 = ( -40 -30 -20 -10 0 10 20 ).  \nMultiplying elements of the vectors v1mod and v2 pairwise gives:  \n v3 = ( 320 180 80 20 0 20 80 ).  \n```  \n  \n##  <a name=\"unique\"></a>  unique  \n Removes duplicate elements that are adjacent to each other in a specified range.  \n  \n```  \ntemplate<class ForwardIterator>  \n   ForwardIterator unique(  \n      ForwardIterator first,   \n      ForwardIterator last);\n  \ntemplate<class ForwardIterator, class Predicate>  \n   ForwardIterator unique(  \n      ForwardIterator first,   \n      ForwardIterator last,  \n      Predicate comp);\n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the range to be scanned for duplicate removal.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the range to be scanned for duplicate removal.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator to the new end of the modified sequence that contains no consecutive duplicates, addressing the position one past the last element not removed.  \n  \n### Remarks  \n Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.  \n  \n The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.  \n  \n The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation. he number of elements in the sequence is not changed by the algorithm **unique** and the elements beyond the end of the modified sequence are dereferenceable but not specified.  \n  \n The complexity is linear, requiring ( `last` –  `first`) – 1 comparisons.  \n  \n List provides a more efficient member function \"unique\", which may perform better.  \n  \n These algorithms cannot be used on an associative container.  \n  \n### Example  \n  \n```cpp  \n// alg_unique.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \n  \n// Return whether modulus of elem1 is equal to modulus of elem2  \nbool mod_equal ( int elem1, int elem2 )  \n{  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 == elem2;  \n};  \n  \nint main( )  \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1_Iter1, v1_Iter2, v1_Iter3,  \n         v1_NewEnd1, v1_NewEnd2, v1_NewEnd3;  \n  \n   int i;  \n   for ( i = 0 ; i <= 3 ; i++ )  \n   {  \n      v1.push_back( 5 );  \n      v1.push_back( -5 );  \n   }  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 3 ; ii++ )  \n   {  \n      v1.push_back( 4 );  \n   }  \n   v1.push_back( 7 );  \n  \n   cout << \"Vector v1 is ( \" ;  \n   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )  \n      cout << *v1_Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove consecutive duplicates  \n   v1_NewEnd1 = unique ( v1.begin ( ) , v1.end ( ) );  \n  \n   cout << \"Removing adjacent duplicates from vector v1 gives\\n ( \" ;  \n   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )  \n      cout << *v1_Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove consecutive duplicates under the binary prediate mod_equals  \n   v1_NewEnd2 = unique ( v1.begin ( ) , v1_NewEnd1 , mod_equal );  \n  \n   cout << \"Removing adjacent duplicates from vector v1 under the\\n \"  \n        << \" binary predicate mod_equal gives\\n ( \" ;  \n   for ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )  \n      cout << *v1_Iter2 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Remove elements if preceded by an element that was greater  \n   v1_NewEnd3 = unique ( v1.begin ( ) , v1_NewEnd2, greater<int>( ) );  \n  \n   cout << \"Removing adjacent elements satisfying the binary\\n \"  \n        << \" predicate mod_equal from vector v1 gives ( \" ;  \n   for ( v1_Iter3 = v1.begin( ) ; v1_Iter3 != v1_NewEnd3 ; v1_Iter3++ )  \n      cout << *v1_Iter3 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nVector v1 is ( 5 -5 5 -5 5 -5 5 -5 4 4 4 4 7 ).  \nRemoving adjacent duplicates from vector v1 gives  \n ( 5 -5 5 -5 5 -5 5 -5 4 7 ).  \nRemoving adjacent duplicates from vector v1 under the  \n  binary predicate mod_equal gives  \n ( 5 4 7 ).  \nRemoving adjacent elements satisfying the binary  \n  predicate mod_equal from vector v1 gives ( 5 7 ).  \n```  \n  \n##  <a name=\"unique_copy\"></a>  unique_copy  \n Copies elements from a source range into a destination range except for the duplicate elements that are adjacent to each other.  \n  \n```  \n template<class InputIterator, class OutputIterator>  \n OutputIterator unique_copy( InputIterator first,  \n    InputIterator last,  \n    OutputIterator result );  \n  \ntemplate<class InputIterator, class OutputIterator, class BinaryPredicate>  \nOutputIterator unique_copy( InputIterator first,  \n    InputIterator last,  \n    OutputIterator result,  \n    BinaryPredicate comp );  \n  \n```  \n  \n### Parameters  \n  `first`  \n A forward iterator addressing the position of the first element in the source range to be copied.  \n  \n `last`  \n A forward iterator addressing the position one past the final element in the source range to be copied.  \n  \n `result`  \n An output iterator addressing the position of the first element in the destination range that is receiving the copy with consecutive duplicates removed.  \n  \n `comp`  \n User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n An output iterator addressing the position one past the final element in the destination range that is receiving the copy with consecutive duplicates removed.  \n  \n### Remarks  \n Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.  \n  \n The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.  \n  \n The ranges referenced must be valid; all pointers must be dereferenceable and within a sequence the last position is reachable from the first by incrementation.  \n  \n The complexity is linear, requiring ( `last` –  `first`) comparisons.  \n  \n### Example  \n  \n```cpp  \n// alg_unique_copy.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n#include <ostream>  \n  \nusing namespace std;  \n  \n// Return whether modulus of elem1 is equal to modulus of elem2  \nbool mod_equal ( int elem1, int elem2 ) {  \n   if ( elem1 < 0 )   \n      elem1 = - elem1;  \n   if ( elem2 < 0 )   \n      elem2 = - elem2;  \n   return elem1 == elem2;  \n};  \n  \nint main() {  \n   vector <int> v1;  \n   vector <int>::iterator v1_Iter1, v1_Iter2,  \n         v1_NewEnd1, v1_NewEnd2;  \n  \n   int i;  \n   for ( i = 0 ; i <= 1 ; i++ ) {  \n      v1.push_back( 5 );  \n      v1.push_back( -5 );  \n   }  \n  \n   int ii;  \n   for ( ii = 0 ; ii <= 2 ; ii++ )  \n      v1.push_back( 4 );  \n   v1.push_back( 7 );  \n  \n   int iii;  \n   for ( iii = 0 ; iii <= 5 ; iii++ )  \n      v1.push_back( 10 );  \n  \n   cout << \"Vector v1 is\\n ( \" ;  \n   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )  \n      cout << *v1_Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   // Copy first half to second, removing consecutive duplicates  \n   v1_NewEnd1 = unique_copy ( v1.begin ( ) , v1.begin ( ) + 8, v1.begin ( ) + 8 );  \n  \n   cout << \"Copying the first half of the vector to the second half\\n \"  \n        << \"while removing adjacent duplicates gives\\n ( \" ;  \n   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )  \n      cout << *v1_Iter1 << \" \";  \n   cout << \").\" << endl;  \n  \n   int iv;  \n   for ( iv = 0 ; iv <= 7 ; iv++ )  \n      v1.push_back( 10 );  \n  \n   // Remove consecutive duplicates under the binary prediate mod_equals  \n   v1_NewEnd2 = unique_copy ( v1.begin ( ) , v1.begin ( ) + 14,   \n      v1.begin ( ) + 14 , mod_equal );  \n  \n   cout << \"Copying the first half of the vector to the second half\\n \"  \n        << \" removing adjacent duplicates under mod_equals gives\\n ( \" ;  \n   for ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )  \n      cout << *v1_Iter2 << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n##  <a name=\"upper_bound\"></a>  upper_bound  \n Finds the position of the first element in an ordered range that has a value that is greater than a specified value, where the ordering criterion may be specified by a binary predicate.  \n  \n```  \ntemplate<class ForwardIterator, class Type>  \n   ForwardIterator upper_bound(  \n      ForwardIterator first,   \n      ForwardIterator last,  \n      const Type& value);\n  \ntemplate<class ForwardIterator, class Type, class Predicate>  \n   ForwardIterator upper_bound(  \n      ForwardIterator first,   \n      ForwardIterator last,  \n      const Type& value,  \n      Predicate comp);\n  \n```  \n  \n### Parameters  \n `first`  \n The position of the first element in the range to be searched.  \n  \n `last`  \n The position one past the final element in the range to be searched.  \n  \n `value`  \n The value in the ordered range that needs to be exceeded by the value of the element addressed by the iterator returned.  \n  \n `comp`  \n User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns **true** when satisfied and **false** when not satisfied.  \n  \n### Return Value  \n A forward iterator to the position of the first element that has a value greater than a specified value.  \n  \n### Remarks  \n The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.  \n  \n A sorted range is a precondition of the use of `upper_bound` and where the ordering criterion is the same as specified by the binary predicate.  \n  \n The range is not modified by `upper_bound`.  \n  \n The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements  \n  \n The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( `last - first`).  \n  \n### Example  \n  \n```cpp  \n// alg_upper_bound.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>      // greater<int>( )  \n#include <iostream>  \n  \n// Return whether modulus of elem1 is less than modulus of elem2  \nbool mod_lesser( int elem1, int elem2 )  \n{  \n    if ( elem1 < 0 )  \n        elem1 = - elem1;  \n    if ( elem2 < 0 )  \n        elem2 = - elem2;  \n    return elem1 < elem2;  \n}  \n  \nint main( )  \n{  \n    using namespace std;  \n  \n    vector<int> v1;  \n    // Constructing vector v1 with default less-than ordering  \n    for ( auto i = -1 ; i <= 4 ; ++i )  \n    {  \n        v1.push_back(  i );  \n    }  \n  \n    for ( auto ii =-3 ; ii <= 0 ; ++ii )  \n    {  \n        v1.push_back(  ii  );  \n    }  \n  \n    cout << \"Starting vector v1 = ( \" ;  \n    for (const auto &Iter : v1)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    sort(v1.begin(), v1.end());  \n    cout << \"Original vector v1 with range sorted by the\\n \"  \n        << \"binary predicate less than is v1 = ( \" ;  \n    for (const auto &Iter : v1)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Constructing vector v2 with range sorted by greater  \n    vector<int> v2(v1);  \n  \n    sort(v2.begin(), v2.end(), greater<int>());  \n  \n    cout << \"Original vector v2 with range sorted by the\\n \"  \n        << \"binary predicate greater is v2 = ( \" ;  \n    for (const auto &Iter : v2)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Constructing vectors v3 with range sorted by mod_lesser  \n    vector<int> v3(v1);  \n    sort(v3.begin(), v3.end(), mod_lesser);  \n  \n    cout << \"Original vector v3 with range sorted by the\\n \"  \n        <<  \"binary predicate mod_lesser is v3 = ( \" ;  \n    for (const auto &Iter : v3)  \n        cout << Iter << \" \";  \n    cout << \").\" << endl;  \n  \n    // Demonstrate upper_bound  \n  \n    vector<int>::iterator Result;  \n  \n    // upper_bound of 3 in v1 with default binary predicate less<int>()  \n    Result = upper_bound(v1.begin(), v1.end(), 3);  \n    cout << \"The upper_bound in v1 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n  \n    // upper_bound of 3 in v2 with the binary predicate greater<int>( )  \n    Result = upper_bound(v2.begin(), v2.end(), 3, greater<int>());  \n    cout << \"The upper_bound in v2 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n  \n    // upper_bound of 3 in v3 with the binary predicate  mod_lesser  \n    Result = upper_bound(v3.begin(), v3.end(), 3,  mod_lesser);  \n    cout << \"The upper_bound in v3 for the element with a value of 3 is: \"  \n        << *Result << \".\" << endl;  \n}  \n  \n```  \n## See Also   \n [\\<algorithm>](../standard-library/algorithm.md)"}