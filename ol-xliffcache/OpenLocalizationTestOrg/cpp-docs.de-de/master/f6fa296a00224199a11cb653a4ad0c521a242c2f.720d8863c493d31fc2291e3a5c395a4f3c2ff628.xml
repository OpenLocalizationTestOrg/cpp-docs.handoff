{"nodes":[{"pos":[12,47],"content":"CComEnumImpl Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CComEnumImpl Class | Microsoft Docs","pos":[0,35]}]},{"content":"CComEnumImpl Class","pos":[657,675]},{"content":"This class provides the implementation for a COM enumerator interface where the items being enumerated are stored in an array.","pos":[676,802]},{"content":"Syntax","pos":[811,817]},{"content":"Parameters","pos":[955,965]},{"content":"A COM enumerator ( <bpt id=\"p1\">[</bpt>IEnumXXXX<ept id=\"p1\">](https://msdn.microsoft.com/library/ms680089.aspx)</ept>) interface.","pos":[979,1071],"source":" A COM enumerator ( [IEnumXXXX](https://msdn.microsoft.com/library/ms680089.aspx)) interface."},{"content":"A pointer to the interface ID of the enumerator interface.","pos":[1088,1146]},{"content":"The type of item exposed by the enumerator interface.","pos":[1160,1213]},{"content":"A homogeneous <bpt id=\"p1\">[</bpt>copy policy class<ept id=\"p1\">](../../atl/atl-copy-policy-classes.md)</ept>.","pos":[1230,1302],"source":" A homogeneous [copy policy class](../../atl/atl-copy-policy-classes.md)."},{"content":"Members","pos":[1311,1318]},{"content":"Public Constructors","pos":[1328,1347]},{"content":"Name","pos":[1354,1358]},{"content":"Description","pos":[1359,1370]},{"content":"CComEnumImpl::CComEnumImpl","pos":[1409,1435]},{"content":"The constructor.","pos":[1466,1482]},{"content":"CComEnumImpl::~CComEnumImpl","pos":[1488,1515]},{"content":"The destructor.","pos":[1551,1566]},{"content":"Public Methods","pos":[1577,1591]},{"content":"Name","pos":[1598,1602]},{"content":"Description","pos":[1603,1614]},{"content":"CComEnumImpl::Clone","pos":[1653,1672]},{"pos":[1696,1787],"content":"The implementation of <bpt id=\"p1\">[</bpt>IEnumXXXX::Clone<ept id=\"p1\">](https://msdn.microsoft.com/library/ms690336.aspx)</ept>.","source":"The implementation of [IEnumXXXX::Clone](https://msdn.microsoft.com/library/ms690336.aspx)."},{"content":"CComEnumImpl::Init","pos":[1793,1811]},{"content":"Initializes the enumerator.","pos":[1834,1861]},{"content":"CComEnumImpl::Next","pos":[1867,1885]},{"pos":[1908,1998],"content":"The implementation of <bpt id=\"p1\">[</bpt>IEnumXXXX::Next<ept id=\"p1\">](https://msdn.microsoft.com/library/ms695273.aspx)</ept>.","source":"The implementation of [IEnumXXXX::Next](https://msdn.microsoft.com/library/ms695273.aspx)."},{"content":"CComEnumImpl::Reset","pos":[2004,2023]},{"pos":[2047,2138],"content":"The implementation of <bpt id=\"p1\">[</bpt>IEnumXXXX::Reset<ept id=\"p1\">](https://msdn.microsoft.com/library/ms693414.aspx)</ept>.","source":"The implementation of [IEnumXXXX::Reset](https://msdn.microsoft.com/library/ms693414.aspx)."},{"content":"CComEnumImpl::Skip","pos":[2144,2162]},{"pos":[2185,2275],"content":"The implementation of <bpt id=\"p1\">[</bpt>IEnumXXXX::Skip<ept id=\"p1\">](https://msdn.microsoft.com/library/ms690392.aspx)</ept>.","source":"The implementation of [IEnumXXXX::Skip](https://msdn.microsoft.com/library/ms690392.aspx)."},{"content":"Public Data Members","pos":[2286,2305]},{"content":"Name","pos":[2312,2316]},{"content":"Description","pos":[2317,2328]},{"content":"CComEnumImpl::m_begin","pos":[2367,2388]},{"content":"A pointer to the first item in the array.","pos":[2414,2455]},{"content":"CComEnumImpl::m_dwFlags","pos":[2461,2484]},{"pos":[2512,2545],"content":"Copy flags passed through <ph id=\"ph1\">`Init`</ph>.","source":"Copy flags passed through `Init`."},{"content":"CComEnumImpl::m_end","pos":[2551,2570]},{"content":"A pointer to the location just beyond the last item in the array.","pos":[2594,2659]},{"content":"CComEnumImpl::m_iter","pos":[2665,2685]},{"content":"A pointer to the current item in the array.","pos":[2710,2753]},{"content":"CComEnumImpl::m_spUnk","pos":[2759,2780]},{"pos":[2806,2887],"content":"The <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> pointer of the object supplying the collection being enumerated.","source":"The **IUnknown** pointer of the object supplying the collection being enumerated."},{"content":"Remarks","pos":[2897,2904]},{"content":"provides the implementation for a COM enumerator interface where the items being enumerated are stored in an array.","pos":[2923,3038]},{"content":"This class is analogous to the <ph id=\"ph1\">`IEnumOnSTLImpl`</ph> class, which provides an implementation of an enumerator interface based on an STL container.","pos":[3039,3180],"source":" This class is analogous to the `IEnumOnSTLImpl` class, which provides an implementation of an enumerator interface based on an STL container."},{"pos":[3188,3325],"content":"[!NOTE]\n For details on further differences between `CComEnumImpl` and `IEnumOnSTLImpl`, see [CComEnumImpl::Init](#ccomenumimpl__init).","leadings":["","> "],"nodes":[{"content":"For details on further differences between <ph id=\"ph1\">`CComEnumImpl`</ph> and <ph id=\"ph2\">`IEnumOnSTLImpl`</ph>, see <bpt id=\"p1\">[</bpt>CComEnumImpl::Init<ept id=\"p1\">](#ccomenumimpl__init)</ept>.","pos":[9,135],"source":" For details on further differences between `CComEnumImpl` and `IEnumOnSTLImpl`, see [CComEnumImpl::Init](#ccomenumimpl__init)."}]},{"content":"Typically, you will <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> need to create your own enumerator class by deriving from this interface implementation.","pos":[3332,3446],"source":"Typically, you will *not* need to create your own enumerator class by deriving from this interface implementation."},{"content":"If you want to use an ATL-supplied enumerator based on an array, it is more common to create an instance of <bpt id=\"p1\">[</bpt>CComEnum<ept id=\"p1\">](../../atl/reference/ccomenum-class.md)</ept>.","pos":[3447,3605],"source":" If you want to use an ATL-supplied enumerator based on an array, it is more common to create an instance of [CComEnum](../../atl/reference/ccomenum-class.md)."},{"content":"However, if you do need to provide a custom enumerator (for example, one that exposes interfaces in addition to the enumerator interface), you can derive from this class.","pos":[3612,3782]},{"content":"In this situation, it is likely that you'll need to override the <bpt id=\"p1\">[</bpt>CComEnumImpl::Clone<ept id=\"p1\">](#ccomenumimpl__clone)</ept> method to provide your own implementation.","pos":[3783,3934],"source":" In this situation, it is likely that you'll need to override the [CComEnumImpl::Clone](#ccomenumimpl__clone) method to provide your own implementation."},{"pos":[3941,4047],"content":"For more information, see <bpt id=\"p1\">[</bpt>ATL Collections and Enumerators<ept id=\"p1\">](../../atl/atl-collections-and-enumerators.md)</ept>.","source":"For more information, see [ATL Collections and Enumerators](../../atl/atl-collections-and-enumerators.md)."},{"content":"Inheritance Hierarchy","pos":[4056,4077]},{"content":"Requirements","pos":[4117,4129]},{"pos":[4133,4153],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> atlcom.h","source":"**Header:** atlcom.h"},{"pos":[4206,4232],"content":"CComEnumImpl::CComEnumImpl"},{"content":"The constructor.","pos":[4236,4252]},{"pos":[4339,4366],"content":"CComEnumImpl::~CComEnumImpl"},{"content":"The destructor.","pos":[4370,4385]},{"pos":[4460,4478],"content":"CComEnumImpl::Init"},{"content":"You must call this method before passing a pointer to the enumerator interface back to any clients.","pos":[4482,4581]},{"content":"Parameters","pos":[4706,4716]},{"content":"begin","pos":[4721,4726]},{"content":"A pointer to the first element of the array containing the items to be enumerated.","pos":[4731,4813]},{"content":"A pointer to the location just beyond the last element of the array containing the items to be enumerated.","pos":[4829,4935]},{"content":"pUnk","pos":[4943,4947]},{"content":"[in] The <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> pointer of an object that must be kept alive during the lifetime of the enumerator.","pos":[4952,5057],"source":" [in] The **IUnknown** pointer of an object that must be kept alive during the lifetime of the enumerator."},{"content":"Pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if no such object exists.","pos":[5058,5097],"source":" Pass **NULL** if no such object exists."},{"content":"Flags specifying whether or not the enumerator should take ownership of the array or make a copy of it.","pos":[5115,5218]},{"content":"Possible values are described below.","pos":[5219,5255]},{"content":"Return Value","pos":[5265,5277]},{"pos":[5281,5308],"content":"A standard <ph id=\"ph1\">`HRESULT`</ph> value.","source":"A standard `HRESULT` value."},{"content":"Remarks","pos":[5318,5325]},{"content":"Only call this method once â€” initialize the enumerator, use it, then throw it away.","pos":[5329,5412]},{"content":"If you pass pointers to items in an array held in another object (and you don't ask the enumerator to copy the data), you can use the <bpt id=\"p1\">*</bpt>pUnk<ept id=\"p1\">*</ept> parameter to ensure that the object and the array it holds are available for as long as the enumerator needs them.","pos":[5419,5674],"source":"If you pass pointers to items in an array held in another object (and you don't ask the enumerator to copy the data), you can use the *pUnk* parameter to ensure that the object and the array it holds are available for as long as the enumerator needs them."},{"content":"The enumerator simply holds a COM reference on the object to keep it alive.","pos":[5675,5750]},{"content":"The COM reference is automatically released when the enumerator is destroyed.","pos":[5751,5828]},{"content":"The <ph id=\"ph1\">`flags`</ph> parameter allows you to specify how the enumerator should treat the array elements passed to it.","pos":[5835,5943],"source":"The `flags` parameter allows you to specify how the enumerator should treat the array elements passed to it."},{"content":"can take one of the values from the <bpt id=\"p1\">**</bpt>CComEnumFlags<ept id=\"p1\">**</ept> enumeration shown below:","pos":[5952,6030],"source":" can take one of the values from the **CComEnumFlags** enumeration shown below:"},{"content":"<bpt id=\"p1\">**</bpt>AtlFlagNoCopy<ept id=\"p1\">**</ept> means that the array's lifetime is not controlled by the enumerator.","pos":[6210,6296],"source":"**AtlFlagNoCopy** means that the array's lifetime is not controlled by the enumerator."},{"content":"In this case, either the array will be static or the object identified by <bpt id=\"p1\">*</bpt>pUnk<ept id=\"p1\">*</ept> will be responsible for freeing the array when it's no longer needed.","pos":[6297,6447],"source":" In this case, either the array will be static or the object identified by *pUnk* will be responsible for freeing the array when it's no longer needed."},{"content":"<bpt id=\"p1\">**</bpt>AtlFlagTakeOwnership<ept id=\"p1\">**</ept> means that the destruction of the array is to be controlled by the enumerator.","pos":[6454,6557],"source":"**AtlFlagTakeOwnership** means that the destruction of the array is to be controlled by the enumerator."},{"content":"In this case, the array must have been dynamically allocated using <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","pos":[6558,6633],"source":" In this case, the array must have been dynamically allocated using **new**."},{"content":"The enumerator will delete the array in its destructor.","pos":[6634,6689]},{"content":"Typically, you would pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for <bpt id=\"p2\">*</bpt>pUnk<ept id=\"p2\">*</ept>, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason.","pos":[6690,6861],"source":" Typically, you would pass **NULL** for *pUnk*, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason."},{"content":"<bpt id=\"p1\">**</bpt>AtlFlagCopy<ept id=\"p1\">**</ept> means that a new array is to be created by copying the array passed to <ph id=\"ph1\">`Init`</ph>.","pos":[6868,6962],"source":"**AtlFlagCopy** means that a new array is to be created by copying the array passed to `Init`."},{"content":"The new array's lifetime is to be controlled by the enumerator.","pos":[6963,7026]},{"content":"The enumerator will delete the array in its destructor.","pos":[7027,7082]},{"content":"Typically, you would pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for <bpt id=\"p2\">*</bpt>pUnk<ept id=\"p2\">*</ept>, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason.","pos":[7083,7254],"source":" Typically, you would pass **NULL** for *pUnk*, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason."},{"pos":[7262,7819],"content":"[!NOTE]\n The prototype of this method specifies the array elements as being of type **T**, where **T** was defined as a template parameter to the class. This is the same type that is exposed by means of the COM interface method [CComEnumImpl::Next](#ccomenumimpl__next). The implication of this is that, unlike [IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md), this class does not support different storage and exposed data types. The data type of elements in the array must be the same as the data type exposed by means of the COM interface.","leadings":["","> "],"nodes":[{"content":" The prototype of this method specifies the array elements as being of type **T**, where **T** was defined as a template parameter to the class. This is the same type that is exposed by means of the COM interface method [CComEnumImpl::Next](#ccomenumimpl__next). The implication of this is that, unlike [IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md), this class does not support different storage and exposed data types. The data type of elements in the array must be the same as the data type exposed by means of the COM interface.","pos":[8,555],"nodes":[{"content":"The prototype of this method specifies the array elements as being of type <bpt id=\"p1\">**</bpt>T<ept id=\"p1\">**</ept>, where <bpt id=\"p2\">**</bpt>T<ept id=\"p2\">**</ept> was defined as a template parameter to the class.","pos":[1,144],"source":" The prototype of this method specifies the array elements as being of type **T**, where **T** was defined as a template parameter to the class."},{"content":"This is the same type that is exposed by means of the COM interface method <bpt id=\"p1\">[</bpt>CComEnumImpl::Next<ept id=\"p1\">](#ccomenumimpl__next)</ept>.","pos":[145,262],"source":" This is the same type that is exposed by means of the COM interface method [CComEnumImpl::Next](#ccomenumimpl__next)."},{"content":"The implication of this is that, unlike <bpt id=\"p1\">[</bpt>IEnumOnSTLImpl<ept id=\"p1\">](../../atl/reference/ienumonstlimpl-class.md)</ept>, this class does not support different storage and exposed data types.","pos":[263,435],"source":" The implication of this is that, unlike [IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md), this class does not support different storage and exposed data types."},{"content":"The data type of elements in the array must be the same as the data type exposed by means of the COM interface.","pos":[436,547]}]}]},{"pos":[7865,7884],"content":"CComEnumImpl::Clone"},{"pos":[7888,8186],"content":"This method provides the implementation of the <bpt id=\"p1\">[</bpt>IEnumXXXX::Clone<ept id=\"p1\">](https://msdn.microsoft.com/library/ms690336.aspx)</ept> method by creating an object of type <ph id=\"ph1\">`CComEnum`</ph>, initializing it with the same array and iterator used by the current object, and returning the interface on the newly created object.","source":"This method provides the implementation of the [IEnumXXXX::Clone](https://msdn.microsoft.com/library/ms690336.aspx) method by creating an object of type `CComEnum`, initializing it with the same array and iterator used by the current object, and returning the interface on the newly created object."},{"content":"Parameters","pos":[8242,8252]},{"content":"[out] The enumerator interface on a newly created object cloned from the current enumerator.","pos":[8268,8360]},{"content":"Return Value","pos":[8370,8382]},{"pos":[8386,8413],"content":"A standard <ph id=\"ph1\">`HRESULT`</ph> value.","source":"A standard `HRESULT` value."},{"content":"Remarks","pos":[8423,8430]},{"content":"Note that cloned enumerators never make their own copy (or take ownership) of the data used by the original enumerator.","pos":[8434,8553]},{"content":"If necessary, cloned enumerators will keep the original enumerator alive (using a COM reference) to ensure that the data is available for as long as they need it.","pos":[8554,8716]},{"pos":[8764,8785],"content":"CComEnumImpl::m_spUnk"},{"pos":[8789,8966],"content":"This smart pointer maintains a reference on the object passed to <bpt id=\"p1\">[</bpt>CComEnumImpl::Init<ept id=\"p1\">](#ccomenumimpl__init)</ept>, ensuring that it remains alive during the lifetime of the enumerator.","source":"This smart pointer maintains a reference on the object passed to [CComEnumImpl::Init](#ccomenumimpl__init), ensuring that it remains alive during the lifetime of the enumerator."},{"pos":[9054,9075],"content":"CComEnumImpl::m_begin"},{"content":"A pointer to the location just beyond the last element of the array containing the items to be enumerated.","pos":[9079,9185]},{"pos":[9256,9275],"content":"CComEnumImpl::m_end"},{"content":"A pointer to the first element of the array containing the items to be enumerated.","pos":[9279,9361]},{"pos":[9431,9451],"content":"CComEnumImpl::m_iter"},{"content":"A pointer to the current element of the array containing the items to be enumerated.","pos":[9455,9539]},{"pos":[9613,9636],"content":"CComEnumImpl::m_dwFlags"},{"pos":[9640,9702],"content":"The flags passed to <bpt id=\"p1\">[</bpt>CComEnumImpl::Init<ept id=\"p1\">](#ccomenumimpl__init)</ept>.","source":"The flags passed to [CComEnumImpl::Init](#ccomenumimpl__init)."},{"pos":[9777,9795],"content":"CComEnumImpl::Next"},{"pos":[9799,9921],"content":"This method provides the implementation of the <bpt id=\"p1\">[</bpt>IEnumXXXX::Next<ept id=\"p1\">](https://msdn.microsoft.com/library/ms695273.aspx)</ept> method.","source":"This method provides the implementation of the [IEnumXXXX::Next](https://msdn.microsoft.com/library/ms695273.aspx) method."},{"content":"Parameters","pos":[10012,10022]},{"content":"[in] The number of elements requested.","pos":[10036,10074]},{"content":"[out] The array to be filled with the elements.","pos":[10092,10139]},{"content":"[out] The number of elements actually returned in <ph id=\"ph1\">`rgelt`</ph>.","pos":[10164,10222],"source":" [out] The number of elements actually returned in `rgelt`."},{"content":"This can be less than <ph id=\"ph1\">`celt`</ph> if fewer than <ph id=\"ph2\">`celt`</ph> elements remained in the list.","pos":[10223,10303],"source":" This can be less than `celt` if fewer than `celt` elements remained in the list."},{"content":"Return Value","pos":[10313,10325]},{"pos":[10329,10356],"content":"A standard <ph id=\"ph1\">`HRESULT`</ph> value.","source":"A standard `HRESULT` value."},{"pos":[10402,10421],"content":"CComEnumImpl::Reset"},{"pos":[10425,10548],"content":"This method provides the implementation of the <bpt id=\"p1\">[</bpt>IEnumXXXX::Reset<ept id=\"p1\">](https://msdn.microsoft.com/library/ms693414.aspx)</ept> method.","source":"This method provides the implementation of the [IEnumXXXX::Reset](https://msdn.microsoft.com/library/ms693414.aspx) method."},{"content":"Return Value","pos":[10595,10607]},{"pos":[10611,10638],"content":"A standard <ph id=\"ph1\">`HRESULT`</ph> value.","source":"A standard `HRESULT` value."},{"pos":[10683,10701],"content":"CComEnumImpl::Skip"},{"pos":[10705,10827],"content":"This method provides the implementation of the <bpt id=\"p1\">[</bpt>IEnumXXXX::Skip<ept id=\"p1\">](https://msdn.microsoft.com/library/ms690392.aspx)</ept> method.","source":"This method provides the implementation of the [IEnumXXXX::Skip](https://msdn.microsoft.com/library/ms690392.aspx) method."},{"content":"Parameters","pos":[10879,10889]},{"content":"[in] The number of elements to skip.","pos":[10903,10939]},{"content":"Return Value","pos":[10949,10961]},{"pos":[10965,10992],"content":"A standard <ph id=\"ph1\">`HRESULT`</ph> value.","source":"A standard `HRESULT` value."},{"content":"Remarks","pos":[11002,11009]},{"pos":[11013,11135],"content":"Returns E_INVALIDARG if <ph id=\"ph1\">`celt`</ph> is zero, returns S_FALSE if less than <ph id=\"ph2\">`celt`</ph> elements are returned, returns S_OK otherwise.","source":"Returns E_INVALIDARG if `celt` is zero, returns S_FALSE if less than `celt` elements are returned, returns S_OK otherwise."},{"content":"See Also","pos":[11144,11152]},{"content":"IEnumOnSTLImpl Class","pos":[11157,11177]},{"content":"CComEnum Class","pos":[11229,11243]},{"content":"Class Overview","pos":[11289,11303]}],"content":"---\ntitle: \"CComEnumImpl Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"ATL.CComEnumImpl\"\n  - \"ATL::CComEnumImpl\"\n  - \"CComEnumImpl\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CComEnumImpl class\"\nms.assetid: cc0d8e76-e608-46db-87cd-4c7161fe32d2\ncaps.latest.revision: 19\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CComEnumImpl Class\nThis class provides the implementation for a COM enumerator interface where the items being enumerated are stored in an array.  \n  \n## Syntax  \n  \n```\ntemplate <class Base,\n    const IID* piid, class T, class Copy>  class ATL_NO_VTABLE CComEnumImpl :   public Base\n```  \n  \n#### Parameters  \n `Base`  \n A COM enumerator ( [IEnumXXXX](https://msdn.microsoft.com/library/ms680089.aspx)) interface.  \n  \n `piid`  \n A pointer to the interface ID of the enumerator interface.  \n  \n `T`  \n The type of item exposed by the enumerator interface.  \n  \n `Copy`  \n A homogeneous [copy policy class](../../atl/atl-copy-policy-classes.md).  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CComEnumImpl::CComEnumImpl](#ccomenumimpl__ccomenumimpl)|The constructor.|  \n|[CComEnumImpl::~CComEnumImpl](#ccomenumimpl___dtorccomenumimpl)|The destructor.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CComEnumImpl::Clone](#ccomenumimpl__clone)|The implementation of [IEnumXXXX::Clone](https://msdn.microsoft.com/library/ms690336.aspx).|  \n|[CComEnumImpl::Init](#ccomenumimpl__init)|Initializes the enumerator.|  \n|[CComEnumImpl::Next](#ccomenumimpl__next)|The implementation of [IEnumXXXX::Next](https://msdn.microsoft.com/library/ms695273.aspx).|  \n|[CComEnumImpl::Reset](#ccomenumimpl__reset)|The implementation of [IEnumXXXX::Reset](https://msdn.microsoft.com/library/ms693414.aspx).|  \n|[CComEnumImpl::Skip](#ccomenumimpl__skip)|The implementation of [IEnumXXXX::Skip](https://msdn.microsoft.com/library/ms690392.aspx).|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CComEnumImpl::m_begin](#ccomenumimpl__m_begin)|A pointer to the first item in the array.|  \n|[CComEnumImpl::m_dwFlags](#ccomenumimpl__m_dwflags)|Copy flags passed through `Init`.|  \n|[CComEnumImpl::m_end](#ccomenumimpl__m_end)|A pointer to the location just beyond the last item in the array.|  \n|[CComEnumImpl::m_iter](#ccomenumimpl__m_iter)|A pointer to the current item in the array.|  \n|[CComEnumImpl::m_spUnk](#ccomenumimpl__m_spunk)|The **IUnknown** pointer of the object supplying the collection being enumerated.|  \n  \n## Remarks  \n `CComEnumImpl` provides the implementation for a COM enumerator interface where the items being enumerated are stored in an array. This class is analogous to the `IEnumOnSTLImpl` class, which provides an implementation of an enumerator interface based on an STL container.  \n  \n> [!NOTE]\n>  For details on further differences between `CComEnumImpl` and `IEnumOnSTLImpl`, see [CComEnumImpl::Init](#ccomenumimpl__init).  \n  \n Typically, you will *not* need to create your own enumerator class by deriving from this interface implementation. If you want to use an ATL-supplied enumerator based on an array, it is more common to create an instance of [CComEnum](../../atl/reference/ccomenum-class.md).  \n  \n However, if you do need to provide a custom enumerator (for example, one that exposes interfaces in addition to the enumerator interface), you can derive from this class. In this situation, it is likely that you'll need to override the [CComEnumImpl::Clone](#ccomenumimpl__clone) method to provide your own implementation.  \n  \n For more information, see [ATL Collections and Enumerators](../../atl/atl-collections-and-enumerators.md).  \n  \n## Inheritance Hierarchy  \n `Base`  \n  \n `CComEnumImpl`  \n  \n## Requirements  \n **Header:** atlcom.h  \n  \n##  <a name=\"ccomenumimpl__ccomenumimpl\"></a>  CComEnumImpl::CComEnumImpl  \n The constructor.  \n  \n```\nCComEnumImpl();\n```  \n  \n##  <a name=\"ccomenumimpl___dtorccomenumimpl\"></a>  CComEnumImpl::~CComEnumImpl  \n The destructor.  \n  \n```\n~CComEnumImpl();\n```  \n  \n##  <a name=\"ccomenumimpl__init\"></a>  CComEnumImpl::Init  \n You must call this method before passing a pointer to the enumerator interface back to any clients.  \n  \n```\nHRESULT Init(\n    T* begin,\n    T* end,\n    IUnknown* pUnk,\n    CComEnumFlags flags = AtlFlagNoCopy);\n```  \n  \n### Parameters  \n *begin*  \n A pointer to the first element of the array containing the items to be enumerated.  \n  \n `end`  \n A pointer to the location just beyond the last element of the array containing the items to be enumerated.  \n  \n *pUnk*  \n [in] The **IUnknown** pointer of an object that must be kept alive during the lifetime of the enumerator. Pass **NULL** if no such object exists.  \n  \n `flags`  \n Flags specifying whether or not the enumerator should take ownership of the array or make a copy of it. Possible values are described below.  \n  \n### Return Value  \n A standard `HRESULT` value.  \n  \n### Remarks  \n Only call this method once â€” initialize the enumerator, use it, then throw it away.  \n  \n If you pass pointers to items in an array held in another object (and you don't ask the enumerator to copy the data), you can use the *pUnk* parameter to ensure that the object and the array it holds are available for as long as the enumerator needs them. The enumerator simply holds a COM reference on the object to keep it alive. The COM reference is automatically released when the enumerator is destroyed.  \n  \n The `flags` parameter allows you to specify how the enumerator should treat the array elements passed to it. `flags` can take one of the values from the **CComEnumFlags** enumeration shown below:  \n  \n `enum CComEnumFlags`  \n  \n `{`  \n  \n `AtlFlagNoCopy = 0,`  \n  \n `AtlFlagTakeOwnership = 2, // BitOwn`  \n  \n `AtlFlagCopy = 3           // BitOwn | BitCopy`  \n  \n `};`  \n  \n **AtlFlagNoCopy** means that the array's lifetime is not controlled by the enumerator. In this case, either the array will be static or the object identified by *pUnk* will be responsible for freeing the array when it's no longer needed.  \n  \n **AtlFlagTakeOwnership** means that the destruction of the array is to be controlled by the enumerator. In this case, the array must have been dynamically allocated using **new**. The enumerator will delete the array in its destructor. Typically, you would pass **NULL** for *pUnk*, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason.  \n  \n **AtlFlagCopy** means that a new array is to be created by copying the array passed to `Init`. The new array's lifetime is to be controlled by the enumerator. The enumerator will delete the array in its destructor. Typically, you would pass **NULL** for *pUnk*, although you can still pass a valid pointer if you need to be notified of the destruction of the enumerator for some reason.  \n  \n> [!NOTE]\n>  The prototype of this method specifies the array elements as being of type **T**, where **T** was defined as a template parameter to the class. This is the same type that is exposed by means of the COM interface method [CComEnumImpl::Next](#ccomenumimpl__next). The implication of this is that, unlike [IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md), this class does not support different storage and exposed data types. The data type of elements in the array must be the same as the data type exposed by means of the COM interface.  \n  \n##  <a name=\"ccomenumimpl__clone\"></a>  CComEnumImpl::Clone  \n This method provides the implementation of the [IEnumXXXX::Clone](https://msdn.microsoft.com/library/ms690336.aspx) method by creating an object of type `CComEnum`, initializing it with the same array and iterator used by the current object, and returning the interface on the newly created object.  \n  \n```\nSTDMETHOD(Clone)(Base** ppEnum);\n```  \n  \n### Parameters  \n `ppEnum`  \n [out] The enumerator interface on a newly created object cloned from the current enumerator.  \n  \n### Return Value  \n A standard `HRESULT` value.  \n  \n### Remarks  \n Note that cloned enumerators never make their own copy (or take ownership) of the data used by the original enumerator. If necessary, cloned enumerators will keep the original enumerator alive (using a COM reference) to ensure that the data is available for as long as they need it.  \n  \n##  <a name=\"ccomenumimpl__m_spunk\"></a>  CComEnumImpl::m_spUnk  \n This smart pointer maintains a reference on the object passed to [CComEnumImpl::Init](#ccomenumimpl__init), ensuring that it remains alive during the lifetime of the enumerator.  \n  \n```\nCComPtr<IUnknown> m_spUnk;\n```  \n  \n##  <a name=\"ccomenumimpl__m_begin\"></a>  CComEnumImpl::m_begin  \n A pointer to the location just beyond the last element of the array containing the items to be enumerated.  \n  \n```\nT* m_begin;\n```  \n  \n##  <a name=\"ccomenumimpl__m_end\"></a>  CComEnumImpl::m_end  \n A pointer to the first element of the array containing the items to be enumerated.  \n  \n```\nT* m_end;\n```  \n  \n##  <a name=\"ccomenumimpl__m_iter\"></a>  CComEnumImpl::m_iter  \n A pointer to the current element of the array containing the items to be enumerated.  \n  \n```\nT* m_iter;\n```  \n  \n##  <a name=\"ccomenumimpl__m_dwflags\"></a>  CComEnumImpl::m_dwFlags  \n The flags passed to [CComEnumImpl::Init](#ccomenumimpl__init).  \n  \n```\nDWORD m_dwFlags;\n```  \n  \n##  <a name=\"ccomenumimpl__next\"></a>  CComEnumImpl::Next  \n This method provides the implementation of the [IEnumXXXX::Next](https://msdn.microsoft.com/library/ms695273.aspx) method.  \n  \n```\nSTDMETHOD(Next)(ULONG celt,\n    T* rgelt,\n    ULONG* pceltFetched);\n```  \n  \n### Parameters  \n `celt`  \n [in] The number of elements requested.  \n  \n `rgelt`  \n [out] The array to be filled with the elements.  \n  \n `pceltFetched`  \n [out] The number of elements actually returned in `rgelt`. This can be less than `celt` if fewer than `celt` elements remained in the list.  \n  \n### Return Value  \n A standard `HRESULT` value.  \n  \n##  <a name=\"ccomenumimpl__reset\"></a>  CComEnumImpl::Reset  \n This method provides the implementation of the [IEnumXXXX::Reset](https://msdn.microsoft.com/library/ms693414.aspx) method.  \n  \n```\nSTDMETHOD(Reset)(void);\n```  \n  \n### Return Value  \n A standard `HRESULT` value.  \n  \n##  <a name=\"ccomenumimpl__skip\"></a>  CComEnumImpl::Skip  \n This method provides the implementation of the [IEnumXXXX::Skip](https://msdn.microsoft.com/library/ms690392.aspx) method.  \n  \n```\nSTDMETHOD(Skip)(ULONG celt);\n```  \n  \n### Parameters  \n `celt`  \n [in] The number of elements to skip.  \n  \n### Return Value  \n A standard `HRESULT` value.  \n  \n### Remarks  \n Returns E_INVALIDARG if `celt` is zero, returns S_FALSE if less than `celt` elements are returned, returns S_OK otherwise.  \n  \n## See Also  \n [IEnumOnSTLImpl Class](../../atl/reference/ienumonstlimpl-class.md)   \n [CComEnum Class](../../atl/reference/ccomenum-class.md)   \n [Class Overview](../../atl/atl-class-overview.md)\n"}