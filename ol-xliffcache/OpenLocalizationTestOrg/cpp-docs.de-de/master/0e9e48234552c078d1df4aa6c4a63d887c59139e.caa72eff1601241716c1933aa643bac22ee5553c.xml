{"nodes":[{"pos":[12,41],"content":"Right Shifts | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Right Shifts | Microsoft Docs","pos":[0,29]}]},{"content":"Right Shifts","pos":[529,541]},{"content":"The result of a right shift of a negative-value signed integral type","pos":[542,610]},{"content":"Shifting a negative value to the right yields half the absolute value, rounded down.","pos":[617,701]},{"content":"For example, a signed <ph id=\"ph1\">`short`</ph> value of –253 (hex 0xFF03, binary 11111111 00000011) shifted right one bit produces –127 (hex 0xFF81, binary 11111111 10000001).","pos":[702,860],"source":" For example, a signed `short` value of –253 (hex 0xFF03, binary 11111111 00000011) shifted right one bit produces –127 (hex 0xFF81, binary 11111111 10000001)."},{"content":"A positive 253 shifted right produces +126.","pos":[861,904]},{"content":"Right shifts preserve the sign bit of signed integral types.","pos":[911,971]},{"content":"When a signed integer shifts right, the most-significant bit remains set.","pos":[972,1045]},{"content":"For example, if 0xF0000000 is a signed <ph id=\"ph1\">`int`</ph>, a right shift produces 0xF8000000.","pos":[1046,1126],"source":" For example, if 0xF0000000 is a signed `int`, a right shift produces 0xF8000000."},{"content":"Shifting a negative <ph id=\"ph1\">`int`</ph> right 32 times produces 0xFFFFFFFF.","pos":[1127,1188],"source":" Shifting a negative `int` right 32 times produces 0xFFFFFFFF."},{"content":"When an unsigned integer shifts right, the most-significant bit is cleared.","pos":[1195,1270]},{"content":"For example, if 0xF000 is unsigned, the result is 0x7800.","pos":[1271,1328]},{"content":"Shifting an <ph id=\"ph1\">`unsigned`</ph> or positive <ph id=\"ph2\">`int`</ph> right 32 times produces 0x00000000.","pos":[1329,1405],"source":" Shifting an `unsigned` or positive `int` right 32 times produces 0x00000000."},{"content":"See Also","pos":[1414,1422]},{"content":"Integers","pos":[1427,1435]}],"content":"---\ntitle: \"Right Shifts | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nms.assetid: c878e97d-ea3c-4c6b-90a8-b1b24b2d5b19\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Right Shifts\nThe result of a right shift of a negative-value signed integral type  \n  \n Shifting a negative value to the right yields half the absolute value, rounded down. For example, a signed `short` value of –253 (hex 0xFF03, binary 11111111 00000011) shifted right one bit produces –127 (hex 0xFF81, binary 11111111 10000001). A positive 253 shifted right produces +126.  \n  \n Right shifts preserve the sign bit of signed integral types. When a signed integer shifts right, the most-significant bit remains set. For example, if 0xF0000000 is a signed `int`, a right shift produces 0xF8000000. Shifting a negative `int` right 32 times produces 0xFFFFFFFF.  \n  \n When an unsigned integer shifts right, the most-significant bit is cleared. For example, if 0xF000 is unsigned, the result is 0x7800. Shifting an `unsigned` or positive `int` right 32 times produces 0x00000000.  \n  \n## See Also  \n [Integers](../c-language/integers.md)"}