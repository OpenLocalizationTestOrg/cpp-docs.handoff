{"nodes":[{"pos":[12,56],"content":"recursive_timed_mutex Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"recursive_timed_mutex Class | Microsoft Docs","pos":[0,44]}]},{"content":"recursive_timed_mutex Class","pos":[589,616]},{"content":"Represents a <bpt id=\"p1\">*</bpt>timed mutex type<ept id=\"p1\">*</ept>.","pos":[617,649],"source":"Represents a *timed mutex type*."},{"content":"Objects of this type are used to enforce mutual exclusion by using time-limited blocking within a program.","pos":[650,756]},{"content":"Unlike objects of type <bpt id=\"p1\">[</bpt>timed_mutex<ept id=\"p1\">](../standard-library/timed-mutex-class.md)</ept>, the effect of calling locking methods for <ph id=\"ph1\">`recursive_timed_mutex`</ph> objects is well-defined.","pos":[757,927],"source":" Unlike objects of type [timed_mutex](../standard-library/timed-mutex-class.md), the effect of calling locking methods for `recursive_timed_mutex` objects is well-defined."},{"content":"Syntax","pos":[936,942]},{"content":"Members","pos":[993,1000]},{"content":"Public Constructors","pos":[1010,1029]},{"content":"Name","pos":[1036,1040]},{"content":"Description","pos":[1041,1052]},{"content":"recursive_timed_mutex Constructor","pos":[1091,1124]},{"pos":[1185,1247],"content":"Constructs a <ph id=\"ph1\">`recursive_timed_mutex`</ph> object that's not locked.","source":"Constructs a `recursive_timed_mutex` object that's not locked."},{"content":"~recursive_timed_mutex Destructor","pos":[1253,1286]},{"pos":[1351,1426],"content":"Releases any resources that are used by the <ph id=\"ph1\">`recursive_timed_mutex`</ph> object.","source":"Releases any resources that are used by the `recursive_timed_mutex` object."},{"content":"Public Methods","pos":[1437,1451]},{"content":"Name","pos":[1458,1462]},{"content":"Description","pos":[1463,1474]},{"content":"lock","pos":[1513,1517]},{"pos":[1556,1632],"content":"Blocks the calling thread until the thread obtains ownership of the <ph id=\"ph1\">`mutex`</ph>.","source":"Blocks the calling thread until the thread obtains ownership of the `mutex`."},{"content":"try_lock","pos":[1638,1646]},{"pos":[1689,1750],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> without blocking.","source":"Attempts to obtain ownership of the `mutex` without blocking."},{"content":"try_lock_for","pos":[1756,1768]},{"pos":[1815,1889],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> for a specified time interval.","source":"Attempts to obtain ownership of the `mutex` for a specified time interval."},{"content":"try_lock_until","pos":[1895,1909]},{"pos":[1958,2025],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> until a specified time.","source":"Attempts to obtain ownership of the `mutex` until a specified time."},{"content":"unlock","pos":[2031,2037]},{"pos":[2078,2112],"content":"Releases ownership of the <ph id=\"ph1\">`mutex`</ph>.","source":"Releases ownership of the `mutex`."},{"content":"Requirements","pos":[2122,2134]},{"pos":[2138,2155],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> mutex","source":"**Header:** mutex"},{"pos":[2162,2180],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2241,2245],"content":"lock"},{"pos":[2249,2325],"content":"Blocks the calling thread until the thread obtains ownership of the <ph id=\"ph1\">`mutex`</ph>.","source":"Blocks the calling thread until the thread obtains ownership of the `mutex`."},{"content":"Remarks","pos":[2364,2371]},{"pos":[2375,2495],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the method returns immediately, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the method returns immediately, and the previous lock remains in effect."},{"pos":[2578,2611],"content":"recursive_timed_mutex Constructor"},{"pos":[2615,2678],"content":"Constructs a <ph id=\"ph1\">`recursive_timed_mutex`</ph> object that is not locked.","source":"Constructs a `recursive_timed_mutex` object that is not locked."},{"pos":[2806,2839],"content":"~recursive_timed_mutex Destructor"},{"pos":[2843,2918],"content":"Releases any resources that are used by the <ph id=\"ph1\">`recursive_timed_mutex`</ph> object.","source":"Releases any resources that are used by the `recursive_timed_mutex` object."},{"content":"Remarks","pos":[2970,2977]},{"content":"If the object is locked when the destructor runs, the behavior is undefined.","pos":[2981,3057]},{"pos":[3122,3130],"content":"try_lock"},{"pos":[3134,3195],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> without blocking.","source":"Attempts to obtain ownership of the `mutex` without blocking."},{"content":"Return Value","pos":[3247,3259]},{"pos":[3270,3401],"content":"if the method successfully obtained ownership of the <ph id=\"ph1\">`mutex`</ph> or if the calling thread already owns the <ph id=\"ph2\">`mutex`</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":" if the method successfully obtained ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`."},{"content":"Remarks","pos":[3411,3418]},{"pos":[3422,3551],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the function immediately returns <ph id=\"ph2\">`true`</ph>, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the function immediately returns `true`, and the previous lock remains in effect."},{"pos":[3620,3632],"content":"try_lock_for"},{"pos":[3636,3697],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> without blocking.","source":"Attempts to obtain ownership of the `mutex` without blocking."},{"content":"Parameters","pos":[3824,3834]},{"content":"A <bpt id=\"p1\">[</bpt>chrono::duration<ept id=\"p1\">](../standard-library/duration-class.md)</ept> object that specifies the maximum amount of time that the method attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph>.","pos":[3852,4021],"source":" A [chrono::duration](../standard-library/duration-class.md) object that specifies the maximum amount of time that the method attempts to obtain ownership of the `mutex`."},{"content":"Return Value","pos":[4031,4043]},{"pos":[4054,4184],"content":"if the method successfully obtains ownership of the <ph id=\"ph1\">`mutex`</ph> or if the calling thread already owns the <ph id=\"ph2\">`mutex`</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":" if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`."},{"content":"Remarks","pos":[4194,4201]},{"pos":[4205,4332],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the method immediately returns <ph id=\"ph2\">`true`</ph>, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the method immediately returns `true`, and the previous lock remains in effect."},{"pos":[4403,4417],"content":"try_lock_until"},{"pos":[4421,4482],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> without blocking.","source":"Attempts to obtain ownership of the `mutex` without blocking."},{"content":"Parameters","pos":[4664,4674]},{"content":"A point in time that specifies the threshold after which the method no longer attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph>.","pos":[4692,4814],"source":" A point in time that specifies the threshold after which the method no longer attempts to obtain ownership of the `mutex`."},{"content":"Return Value","pos":[4824,4836]},{"pos":[4847,4977],"content":"if the method successfully obtains ownership of the <ph id=\"ph1\">`mutex`</ph> or if the calling thread already owns the <ph id=\"ph2\">`mutex`</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":" if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`."},{"content":"Remarks","pos":[4987,4994]},{"pos":[4998,5125],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the method immediately returns <ph id=\"ph2\">`true`</ph>, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the method immediately returns `true`, and the previous lock remains in effect."},{"pos":[5188,5194],"content":"unlock"},{"pos":[5198,5232],"content":"Releases ownership of the <ph id=\"ph1\">`mutex`</ph>.","source":"Releases ownership of the `mutex`."},{"content":"Remarks","pos":[5273,5280]},{"pos":[5284,5666],"content":"This method releases ownership of the <ph id=\"ph1\">`mutex`</ph> only after it is called as many times as <bpt id=\"p1\">[</bpt>lock<ept id=\"p1\">](#recursive_timed_mutex__lock_method)</ept>, <bpt id=\"p2\">[</bpt>try_lock<ept id=\"p2\">](#recursive_timed_mutex__try_lock_method)</ept>, <bpt id=\"p3\">[</bpt>try_lock_for<ept id=\"p3\">](#recursive_timed_mutex__try_lock_for_method)</ept>, and <bpt id=\"p4\">[</bpt>try_lock_until<ept id=\"p4\">](#recursive_timed_mutex__try_lock_until_method)</ept> have been called successfully on the <ph id=\"ph2\">`recursive_timed_mutex`</ph> object.","source":"This method releases ownership of the `mutex` only after it is called as many times as [lock](#recursive_timed_mutex__lock_method), [try_lock](#recursive_timed_mutex__try_lock_method), [try_lock_for](#recursive_timed_mutex__try_lock_for_method), and [try_lock_until](#recursive_timed_mutex__try_lock_until_method) have been called successfully on the `recursive_timed_mutex` object."},{"pos":[5673,5747],"content":"If the calling thread does not own the <ph id=\"ph1\">`mutex`</ph>, the behavior is undefined.","source":"If the calling thread does not own the `mutex`, the behavior is undefined."},{"content":"See Also","pos":[5756,5764]},{"content":"Header Files Reference","pos":[5769,5791]},{"content":"mutex&gt;","pos":[5858,5864],"source":"mutex>"}],"content":"---\ntitle: \"recursive_timed_mutex Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"mutex/std::recursive_timed_mutex\"\ndev_langs: \n  - \"C++\"\nms.assetid: 59cc2d5c-ed80-45f3-a0a8-05652a8ead7e\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# recursive_timed_mutex Class\nRepresents a *timed mutex type*. Objects of this type are used to enforce mutual exclusion by using time-limited blocking within a program. Unlike objects of type [timed_mutex](../standard-library/timed-mutex-class.md), the effect of calling locking methods for `recursive_timed_mutex` objects is well-defined.  \n  \n## Syntax  \n  \n```\nclass recursive_timed_mutex;\n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[recursive_timed_mutex Constructor](#recursive_timed_mutex__recursive_timed_mutex_constructor)|Constructs a `recursive_timed_mutex` object that's not locked.|  \n|[~recursive_timed_mutex Destructor](#recursive_timed_mutex___dtorrecursive_timed_mutex_destructor)|Releases any resources that are used by the `recursive_timed_mutex` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[lock](#recursive_timed_mutex__lock_method)|Blocks the calling thread until the thread obtains ownership of the `mutex`.|  \n|[try_lock](#recursive_timed_mutex__try_lock_method)|Attempts to obtain ownership of the `mutex` without blocking.|  \n|[try_lock_for](#recursive_timed_mutex__try_lock_for_method)|Attempts to obtain ownership of the `mutex` for a specified time interval.|  \n|[try_lock_until](#recursive_timed_mutex__try_lock_until_method)|Attempts to obtain ownership of the `mutex` until a specified time.|  \n|[unlock](#recursive_timed_mutex__unlock_method)|Releases ownership of the `mutex`.|  \n  \n## Requirements  \n **Header:** mutex  \n  \n **Namespace:** std  \n  \n##  <a name=\"recursive_timed_mutex__lock_method\"></a>  lock  \n Blocks the calling thread until the thread obtains ownership of the `mutex`.  \n  \n```cpp\nvoid lock();\n```  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the method returns immediately, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_timed_mutex__recursive_timed_mutex_constructor\"></a>  recursive_timed_mutex Constructor  \n Constructs a `recursive_timed_mutex` object that is not locked.  \n  \n```cpp\nrecursive_timed_mutex();\n```  \n  \n##  <a name=\"recursive_timed_mutex___dtorrecursive_timed_mutex_destructor\"></a>  ~recursive_timed_mutex Destructor  \n Releases any resources that are used by the `recursive_timed_mutex` object.  \n  \n```cpp\n~recursive_timed_mutex();\n```  \n  \n### Remarks  \n If the object is locked when the destructor runs, the behavior is undefined.  \n  \n##  <a name=\"recursive_timed_mutex__try_lock_method\"></a>  try_lock  \n Attempts to obtain ownership of the `mutex` without blocking.  \n  \n```cpp\nbool try_lock() noexcept;\n```  \n  \n### Return Value  \n `true` if the method successfully obtained ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`.  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the function immediately returns `true`, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_timed_mutex__try_lock_for_method\"></a>  try_lock_for  \n Attempts to obtain ownership of the `mutex` without blocking.  \n  \n```cpp\ntemplate <class Rep, class Period>\nbool try_lock_for(const chrono::duration<Rep, Period>& Rel_time);\n```  \n  \n### Parameters  \n `Rel_time`  \n A [chrono::duration](../standard-library/duration-class.md) object that specifies the maximum amount of time that the method attempts to obtain ownership of the `mutex`.  \n  \n### Return Value  \n `true` if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`.  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the method immediately returns `true`, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_timed_mutex__try_lock_until_method\"></a>  try_lock_until  \n Attempts to obtain ownership of the `mutex` without blocking.  \n  \n```cpp\ntemplate <class Clock, class Duration>\nbool try_lock_for(const chrono::time_point<Clock, Duration>& Abs_time);\n\nbool try_lock_until(const xtime* Abs_time);\n```  \n  \n### Parameters  \n `Abs_time`  \n A point in time that specifies the threshold after which the method no longer attempts to obtain ownership of the `mutex`.  \n  \n### Return Value  \n `true` if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`.  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the method immediately returns `true`, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_timed_mutex__unlock_method\"></a>  unlock  \n Releases ownership of the `mutex`.  \n  \n```cpp\nvoid unlock();\n```  \n  \n### Remarks  \n This method releases ownership of the `mutex` only after it is called as many times as [lock](#recursive_timed_mutex__lock_method), [try_lock](#recursive_timed_mutex__try_lock_method), [try_lock_for](#recursive_timed_mutex__try_lock_for_method), and [try_lock_until](#recursive_timed_mutex__try_lock_until_method) have been called successfully on the `recursive_timed_mutex` object.  \n  \n If the calling thread does not own the `mutex`, the behavior is undefined.  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [\\<mutex>](../standard-library/mutex.md)\n\n\n\n"}