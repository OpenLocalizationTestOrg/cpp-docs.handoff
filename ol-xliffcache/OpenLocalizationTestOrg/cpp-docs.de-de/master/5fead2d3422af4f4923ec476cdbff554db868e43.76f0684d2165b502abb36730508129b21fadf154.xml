{"nodes":[{"pos":[12,71],"content":"Recordset: Fetching Records in Bulk (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recordset: Fetching Records in Bulk (ODBC) | Microsoft Docs","pos":[0,59]}]},{"content":"Recordset: Fetching Records in Bulk (ODBC)","pos":[931,973]},{"content":"This topic applies to the MFC ODBC classes.","pos":[974,1017]},{"content":"Class <ph id=\"ph1\">`CRecordset`</ph> provides support for bulk row fetching, which means that multiple records can be retrieved at once during a single fetch, rather than retrieving one record at a time from the data source.","pos":[1024,1230],"source":"Class `CRecordset` provides support for bulk row fetching, which means that multiple records can be retrieved at once during a single fetch, rather than retrieving one record at a time from the data source."},{"content":"You can implement bulk row fetching only in a derived <ph id=\"ph1\">`CRecordset`</ph> class.","pos":[1231,1304],"source":" You can implement bulk row fetching only in a derived `CRecordset` class."},{"content":"The process of transferring data from the data source to the recordset object is called bulk record field exchange (Bulk RFX).","pos":[1305,1431]},{"content":"Note that if you are not using bulk row fetching in a <ph id=\"ph1\">`CRecordset`</ph>-derived class, data is transferred via record field exchange (RFX).","pos":[1432,1566],"source":" Note that if you are not using bulk row fetching in a `CRecordset`-derived class, data is transferred via record field exchange (RFX)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Record Field Exchange (RFX)<ept id=\"p1\">](../../data/odbc/record-field-exchange-rfx.md)</ept>.","pos":[1567,1669],"source":" For more information, see [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md)."},{"content":"This topic explains:","pos":[1676,1696]},{"pos":[1706,1800],"content":"<bpt id=\"p1\">[</bpt>How CRecordset supports bulk row fetching<ept id=\"p1\">](#_core_how_crecordset_supports_bulk_row_fetching)</ept>.","source":"[How CRecordset supports bulk row fetching](#_core_how_crecordset_supports_bulk_row_fetching)."},{"pos":[1810,1900],"content":"<bpt id=\"p1\">[</bpt>Some special considerations when using bulk row fetching<ept id=\"p1\">](#_core_special_considerations)</ept>.","source":"[Some special considerations when using bulk row fetching](#_core_special_considerations)."},{"pos":[1910,2008],"content":"<bpt id=\"p1\">[</bpt>How to implement bulk record field exchange<ept id=\"p1\">](#_core_how_to_implement_bulk_record_field_exchange)</ept>.","source":"[How to implement bulk record field exchange](#_core_how_to_implement_bulk_record_field_exchange)."},{"pos":[2081,2122],"content":"How CRecordset Supports Bulk Row Fetching"},{"content":"Before opening your recordset object, you can define a rowset size with the <ph id=\"ph1\">`SetRowsetSize`</ph> member function.","pos":[2126,2234],"source":"Before opening your recordset object, you can define a rowset size with the `SetRowsetSize` member function."},{"content":"The rowset size specifies how many records should be retrieved during a single fetch.","pos":[2235,2320]},{"content":"When bulk row fetching is implemented, the default rowset size is 25.","pos":[2321,2390]},{"content":"If bulk row fetching is not implemented, the rowset size remains fixed at 1.","pos":[2391,2467]},{"content":"After you have initialized the rowset size, call the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__open)</ept> member function.","pos":[2474,2608],"source":"After you have initialized the rowset size, call the [Open](../../mfc/reference/crecordset-class.md#crecordset__open) member function."},{"content":"Here you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option of the <bpt id=\"p1\">**</bpt>dwOptions<ept id=\"p1\">**</ept> parameter to implement bulk row fetching.","pos":[2609,2735],"source":" Here you must specify the `CRecordset::useMultiRowFetch` option of the **dwOptions** parameter to implement bulk row fetching."},{"content":"You can additionally set the <bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> option.","pos":[2736,2813],"source":" You can additionally set the **CRecordset::userAllocMultiRowBuffers** option."},{"content":"The bulk record field exchange mechanism uses arrays to store the multiple rows of data retrieved during a fetch.","pos":[2814,2927]},{"content":"These storage buffers can be allocated automatically by the framework or you can allocate them manually.","pos":[2928,3032]},{"content":"Specifying the <bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> option means that you will do the allocation.","pos":[3033,3134],"source":" Specifying the **CRecordset::userAllocMultiRowBuffers** option means that you will do the allocation."},{"pos":[3141,3242],"content":"The following table lists the member functions provided by <ph id=\"ph1\">`CRecordset`</ph> to support bulk row fetching.","source":"The following table lists the member functions provided by `CRecordset` to support bulk row fetching."},{"content":"Member function","pos":[3249,3264]},{"content":"Description","pos":[3265,3276]},{"content":"CheckRowsetError","pos":[3326,3342]},{"content":"Virtual function that handles any errors that occur during fetching.","pos":[3414,3482]},{"content":"DoBulkFieldExchange","pos":[3488,3507]},{"content":"Implements bulk record field exchange.","pos":[3582,3620]},{"content":"Called automatically to transfers multiple rows of data from the data source to the recordset object.","pos":[3621,3722]},{"content":"GetRowsetSize","pos":[3728,3741]},{"content":"Retrieves the current setting for the rowset size.","pos":[3810,3860]},{"content":"GetRowsFetched","pos":[3866,3880]},{"content":"Tells how many rows were actually retrieved after a given fetch.","pos":[3950,4014]},{"content":"In most cases, this is the rowset size, unless an incomplete rowset was fetched.","pos":[4015,4095]},{"content":"GetRowStatus","pos":[4101,4113]},{"content":"Returns a fetch status for a particular row within a rowset.","pos":[4181,4241]},{"content":"RefreshRowset","pos":[4247,4260]},{"content":"Refreshes the data and status of a particular row within a rowset.","pos":[4329,4395]},{"content":"SetRowsetCursorPosition","pos":[4401,4424]},{"content":"Moves the cursor to a particular row within a rowset.","pos":[4503,4556]},{"content":"SetRowsetSize","pos":[4562,4575]},{"content":"Virtual function that changes the setting for the rowset size to the specified value.","pos":[4644,4729]},{"pos":[4784,4806],"content":"Special Considerations"},{"content":"Although bulk row fetching is a performance gain, certain features operate differently.","pos":[4810,4897]},{"content":"Before you decide to implement bulk row fetching, consider the following:","pos":[4898,4971]},{"content":"The framework automatically calls the <ph id=\"ph1\">`DoBulkFieldExchange`</ph> member function to transfer data from the data source to the recordset object.","pos":[4981,5119],"source":"The framework automatically calls the `DoBulkFieldExchange` member function to transfer data from the data source to the recordset object."},{"content":"However, data is not transferred from the recordset back to the data source.","pos":[5120,5196]},{"content":"Calling the <ph id=\"ph1\">`AddNew`</ph>, <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept> member functions results in a failed assertion.","pos":[5197,5302],"source":" Calling the `AddNew`, **Edit**, **Delete**, or **Update** member functions results in a failed assertion."},{"content":"Although <ph id=\"ph1\">`CRecordset`</ph> currently does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[5303,5474],"source":" Although `CRecordset` currently does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"For more information about <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>, see the <bpt id=\"p2\">*</bpt>ODBC SDK Programmer's Reference<ept id=\"p2\">*</ept> in the MSDN documentation.","pos":[5475,5585],"source":" For more information about **SQLSetPos**, see the *ODBC SDK Programmer's Reference* in the MSDN documentation."},{"content":"The member functions <ph id=\"ph1\">`IsDeleted`</ph>, <ph id=\"ph2\">`IsFieldDirty`</ph>, <ph id=\"ph3\">`IsFieldNull`</ph>, <ph id=\"ph4\">`IsFieldNullable`</ph>, <ph id=\"ph5\">`SetFieldDirty`</ph>, and <ph id=\"ph6\">`SetFieldNull`</ph> cannot be used on recordsets that implement bulk row fetching.","pos":[5595,5777],"source":"The member functions `IsDeleted`, `IsFieldDirty`, `IsFieldNull`, `IsFieldNullable`, `SetFieldDirty`, and `SetFieldNull` cannot be used on recordsets that implement bulk row fetching."},{"content":"However, you can call <ph id=\"ph1\">`GetRowStatus`</ph> in place of <ph id=\"ph2\">`IsDeleted`</ph>, and <ph id=\"ph3\">`GetODBCFieldInfo`</ph> in place of <ph id=\"ph4\">`IsFieldNullable`</ph>.","pos":[5778,5893],"source":" However, you can call `GetRowStatus` in place of `IsDeleted`, and `GetODBCFieldInfo` in place of `IsFieldNullable`."},{"content":"The <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> operations repositions your recordset by rowset.","pos":[5903,5964],"source":"The **Move** operations repositions your recordset by rowset."},{"content":"For example, suppose you open a recordset that has 100 records with an initial rowset size of 10.","pos":[5965,6062]},{"content":"<bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> fetches rows 1 through 10, with the current record positioned on row 1.","pos":[6063,6143],"source":"**Open** fetches rows 1 through 10, with the current record positioned on row 1."},{"content":"A call to <ph id=\"ph1\">`MoveNext`</ph> fetches the next rowset, not the next row.","pos":[6144,6207],"source":" A call to `MoveNext` fetches the next rowset, not the next row."},{"content":"This rowset consists of rows 11 through 20, with the current record positioned on row 11.","pos":[6208,6297]},{"content":"Note that <ph id=\"ph1\">`MoveNext`</ph> and <bpt id=\"p1\">**</bpt>Move( 1 )<ept id=\"p1\">**</ept> are not equivalent when bulk row fetching is implemented.","pos":[6298,6394],"source":" Note that `MoveNext` and **Move( 1 )** are not equivalent when bulk row fetching is implemented."},{"content":"<bpt id=\"p1\">**</bpt>Move( 1 )<ept id=\"p1\">**</ept> fetches the rowset that begins 1 row from the current record.","pos":[6395,6470],"source":"**Move( 1 )** fetches the rowset that begins 1 row from the current record."},{"content":"In this example, calling <bpt id=\"p1\">**</bpt>Move( 1 )<ept id=\"p1\">**</ept> after calling <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept> fetches the rowset consisting of rows 2 through 11, with the current record positioned on row 2.","pos":[6471,6629],"source":" In this example, calling **Move( 1 )** after calling **Open** fetches the rowset consisting of rows 2 through 11, with the current record positioned on row 2."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Move<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__move)</ept> member function.","pos":[6630,6741],"source":" For more information, see the [Move](../../mfc/reference/crecordset-class.md#crecordset__move) member function."},{"content":"Unlike record field exchange, the wizards do not support bulk record field exchange.","pos":[6751,6835]},{"content":"This means that you must manually declare your field data members and manually override <ph id=\"ph1\">`DoBulkFieldExchange`</ph> by writing calls to the Bulk RFX functions.","pos":[6836,6989],"source":" This means that you must manually declare your field data members and manually override `DoBulkFieldExchange` by writing calls to the Bulk RFX functions."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Record Field Exchange Functions<ept id=\"p1\">](../../mfc/reference/record-field-exchange-functions.md)</ept> in the <bpt id=\"p2\">*</bpt>Class Library Reference<ept id=\"p2\">*</ept>.","pos":[6990,7139],"source":" For more information, see [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md) in the *Class Library Reference*."},{"pos":[7214,7257],"content":"How to Implement Bulk Record Field Exchange"},{"content":"Bulk record field exchange transfers a rowset of data from the data source to the recordset object.","pos":[7261,7360]},{"content":"The Bulk RFX functions use arrays to store this data, as well as arrays to store the length of each data item in the rowset.","pos":[7361,7485]},{"content":"In your class definition, you must define your field data members as pointers to access the arrays of data.","pos":[7486,7593]},{"content":"In addition, you must define a set of pointers to access the arrays of lengths.","pos":[7594,7673]},{"content":"Any parameter data members should not be declared as pointers; declaring parameter data members when using bulk record field exchange is the same as declaring them when using record field exchange.","pos":[7674,7871]},{"content":"The following code shows a simple example:","pos":[7872,7914]},{"content":"You can either allocate these storage buffers manually or have the framework do the allocation.","pos":[8321,8416]},{"content":"To allocate the buffers yourself, you must specify the <bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> option of the <bpt id=\"p2\">**</bpt>dwOptions<ept id=\"p2\">**</ept> parameter in the <bpt id=\"p3\">**</bpt>Open<ept id=\"p3\">**</ept> member function.","pos":[8417,8583],"source":" To allocate the buffers yourself, you must specify the **CRecordset::userAllocMultiRowBuffers** option of the **dwOptions** parameter in the **Open** member function."},{"content":"Be sure to set the sizes of the arrays at least equal to the rowset size.","pos":[8584,8657]},{"content":"If you want to have the framework do the allocation, you should initialize your pointers to <bpt id=\"p1\">**</bpt>NULL.<ept id=\"p1\">**</ept>","pos":[8658,8759],"source":" If you want to have the framework do the allocation, you should initialize your pointers to **NULL.**"},{"content":"This is typically done in the recordset object's constructor:","pos":[8760,8821]},{"content":"Finally, you must override the <ph id=\"ph1\">`DoBulkFieldExchange`</ph> member function.","pos":[9112,9181],"source":"Finally, you must override the `DoBulkFieldExchange` member function."},{"content":"For the field data members, call the Bulk RFX functions; for any parameter data members, call the RFX functions.","pos":[9182,9294]},{"content":"If you opened the recordset by passing a SQL statement or stored procedure to <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, the order in which you make the Bulk RFX calls must correspond to the order of the columns in the recordset; similarly, the order of the RFX calls for parameters must correspond to the order of parameters in the SQL statement or stored procedure.","pos":[9295,9629],"source":" If you opened the recordset by passing a SQL statement or stored procedure to **Open**, the order in which you make the Bulk RFX calls must correspond to the order of the columns in the recordset; similarly, the order of the RFX calls for parameters must correspond to the order of parameters in the SQL statement or stored procedure."},{"pos":[10215,10525],"content":"[!NOTE]\n You must call the **Close** member function before your derived `CRecordset` class goes out of scope. This ensures that any memory allocated by the framework are freed. It is good programming practice to always explicitly call **Close**, regardless of whether you have implemented bulk row fetching.","leadings":["","> "],"nodes":[{"content":" You must call the **Close** member function before your derived `CRecordset` class goes out of scope. This ensures that any memory allocated by the framework are freed. It is good programming practice to always explicitly call **Close**, regardless of whether you have implemented bulk row fetching.","pos":[8,308],"nodes":[{"content":"You must call the <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> member function before your derived <ph id=\"ph1\">`CRecordset`</ph> class goes out of scope.","pos":[1,102],"source":" You must call the **Close** member function before your derived `CRecordset` class goes out of scope."},{"content":"This ensures that any memory allocated by the framework are freed.","pos":[103,169]},{"content":"It is good programming practice to always explicitly call <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept>, regardless of whether you have implemented bulk row fetching.","pos":[170,300],"source":" It is good programming practice to always explicitly call **Close**, regardless of whether you have implemented bulk row fetching."}]}]},{"content":"For more information about record field exchange (RFX), see <bpt id=\"p1\">[</bpt>Record Field Exchange: How RFX Works<ept id=\"p1\">](../../data/odbc/record-field-exchange-how-rfx-works.md)</ept>.","pos":[10532,10687],"source":"For more information about record field exchange (RFX), see [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md)."},{"content":"For more information about using parameters, see <bpt id=\"p1\">[</bpt>CFieldExchange::SetFieldType<ept id=\"p1\">](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Parameterizing a Recordset (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)</ept>.","pos":[10688,10955],"source":" For more information about using parameters, see [CFieldExchange::SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) and [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)."},{"content":"See Also","pos":[10964,10972]},{"content":"Recordset (ODBC)","pos":[10977,10993]},{"content":"CRecordset::m_nFields","pos":[11035,11056]},{"content":"CRecordset::m_nParams","pos":[11126,11147]}],"content":"---\ntitle: \"Recordset: Fetching Records in Bulk (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"bulk row fetching, implementing\"\n  - \"ODBC recordsets, bulk row fetching\"\n  - \"bulk record field exchange\"\n  - \"bulk row fetching\"\n  - \"bulk RFX functions\"\n  - \"recordsets, bulk row fetching\"\n  - \"DoBulkFieldExchange method\"\n  - \"fetching ODBC records in bulk\"\n  - \"RFX (ODBC), bulk\"\n  - \"rowsets, bulk row fetching\"\n  - \"RFX (ODBC), bulk row fetching\"\nms.assetid: 20d10fe9-c58a-414a-b675-cdf9aa283e4f\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recordset: Fetching Records in Bulk (ODBC)\nThis topic applies to the MFC ODBC classes.  \n  \n Class `CRecordset` provides support for bulk row fetching, which means that multiple records can be retrieved at once during a single fetch, rather than retrieving one record at a time from the data source. You can implement bulk row fetching only in a derived `CRecordset` class. The process of transferring data from the data source to the recordset object is called bulk record field exchange (Bulk RFX). Note that if you are not using bulk row fetching in a `CRecordset`-derived class, data is transferred via record field exchange (RFX). For more information, see [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md).  \n  \n This topic explains:  \n  \n-   [How CRecordset supports bulk row fetching](#_core_how_crecordset_supports_bulk_row_fetching).  \n  \n-   [Some special considerations when using bulk row fetching](#_core_special_considerations).  \n  \n-   [How to implement bulk record field exchange](#_core_how_to_implement_bulk_record_field_exchange).  \n  \n##  <a name=\"_core_how_crecordset_supports_bulk_row_fetching\"></a> How CRecordset Supports Bulk Row Fetching  \n Before opening your recordset object, you can define a rowset size with the `SetRowsetSize` member function. The rowset size specifies how many records should be retrieved during a single fetch. When bulk row fetching is implemented, the default rowset size is 25. If bulk row fetching is not implemented, the rowset size remains fixed at 1.  \n  \n After you have initialized the rowset size, call the [Open](../../mfc/reference/crecordset-class.md#crecordset__open) member function. Here you must specify the `CRecordset::useMultiRowFetch` option of the **dwOptions** parameter to implement bulk row fetching. You can additionally set the **CRecordset::userAllocMultiRowBuffers** option. The bulk record field exchange mechanism uses arrays to store the multiple rows of data retrieved during a fetch. These storage buffers can be allocated automatically by the framework or you can allocate them manually. Specifying the **CRecordset::userAllocMultiRowBuffers** option means that you will do the allocation.  \n  \n The following table lists the member functions provided by `CRecordset` to support bulk row fetching.  \n  \n|Member function|Description|  \n|---------------------|-----------------|  \n|[CheckRowsetError](../../mfc/reference/crecordset-class.md#crecordset__checkrowseterror)|Virtual function that handles any errors that occur during fetching.|  \n|[DoBulkFieldExchange](../../mfc/reference/crecordset-class.md#crecordset__dobulkfieldexchange)|Implements bulk record field exchange. Called automatically to transfers multiple rows of data from the data source to the recordset object.|  \n|[GetRowsetSize](../../mfc/reference/crecordset-class.md#crecordset__getrowsetsize)|Retrieves the current setting for the rowset size.|  \n|[GetRowsFetched](../../mfc/reference/crecordset-class.md#crecordset__getrowsfetched)|Tells how many rows were actually retrieved after a given fetch. In most cases, this is the rowset size, unless an incomplete rowset was fetched.|  \n|[GetRowStatus](../../mfc/reference/crecordset-class.md#crecordset__getrowstatus)|Returns a fetch status for a particular row within a rowset.|  \n|[RefreshRowset](../../mfc/reference/crecordset-class.md#crecordset__refreshrowset)|Refreshes the data and status of a particular row within a rowset.|  \n|[SetRowsetCursorPosition](../../mfc/reference/crecordset-class.md#crecordset__setrowsetcursorposition)|Moves the cursor to a particular row within a rowset.|  \n|[SetRowsetSize](../../mfc/reference/crecordset-class.md#crecordset__setrowsetsize)|Virtual function that changes the setting for the rowset size to the specified value.|  \n  \n##  <a name=\"_core_special_considerations\"></a> Special Considerations  \n Although bulk row fetching is a performance gain, certain features operate differently. Before you decide to implement bulk row fetching, consider the following:  \n  \n-   The framework automatically calls the `DoBulkFieldExchange` member function to transfer data from the data source to the recordset object. However, data is not transferred from the recordset back to the data source. Calling the `AddNew`, **Edit**, **Delete**, or **Update** member functions results in a failed assertion. Although `CRecordset` currently does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about **SQLSetPos**, see the *ODBC SDK Programmer's Reference* in the MSDN documentation.  \n  \n-   The member functions `IsDeleted`, `IsFieldDirty`, `IsFieldNull`, `IsFieldNullable`, `SetFieldDirty`, and `SetFieldNull` cannot be used on recordsets that implement bulk row fetching. However, you can call `GetRowStatus` in place of `IsDeleted`, and `GetODBCFieldInfo` in place of `IsFieldNullable`.  \n  \n-   The **Move** operations repositions your recordset by rowset. For example, suppose you open a recordset that has 100 records with an initial rowset size of 10. **Open** fetches rows 1 through 10, with the current record positioned on row 1. A call to `MoveNext` fetches the next rowset, not the next row. This rowset consists of rows 11 through 20, with the current record positioned on row 11. Note that `MoveNext` and **Move( 1 )** are not equivalent when bulk row fetching is implemented. **Move( 1 )** fetches the rowset that begins 1 row from the current record. In this example, calling **Move( 1 )** after calling **Open** fetches the rowset consisting of rows 2 through 11, with the current record positioned on row 2. For more information, see the [Move](../../mfc/reference/crecordset-class.md#crecordset__move) member function.  \n  \n-   Unlike record field exchange, the wizards do not support bulk record field exchange. This means that you must manually declare your field data members and manually override `DoBulkFieldExchange` by writing calls to the Bulk RFX functions. For more information, see [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md) in the *Class Library Reference*.  \n  \n##  <a name=\"_core_how_to_implement_bulk_record_field_exchange\"></a> How to Implement Bulk Record Field Exchange  \n Bulk record field exchange transfers a rowset of data from the data source to the recordset object. The Bulk RFX functions use arrays to store this data, as well as arrays to store the length of each data item in the rowset. In your class definition, you must define your field data members as pointers to access the arrays of data. In addition, you must define a set of pointers to access the arrays of lengths. Any parameter data members should not be declared as pointers; declaring parameter data members when using bulk record field exchange is the same as declaring them when using record field exchange. The following code shows a simple example:  \n  \n```  \nclass MultiRowSet : public CRecordset  \n{  \npublic:  \n   // Field/Param Data  \n      // field data members  \n      long* m_rgID;  \n      LPSTR m_rgName;  \n  \n      // pointers for the lengths  \n      // of the field data  \n      long* m_rgIDLengths;  \n      long* m_rgNameLengths;  \n  \n      // input parameter data member  \n      CString m_strNameParam;  \n  \n   .  \n   .  \n   .  \n}  \n```  \n  \n You can either allocate these storage buffers manually or have the framework do the allocation. To allocate the buffers yourself, you must specify the **CRecordset::userAllocMultiRowBuffers** option of the **dwOptions** parameter in the **Open** member function. Be sure to set the sizes of the arrays at least equal to the rowset size. If you want to have the framework do the allocation, you should initialize your pointers to **NULL.** This is typically done in the recordset object's constructor:  \n  \n```  \nMultiRowSet::MultiRowSet( CDatabase* pDB )  \n   : CRecordset( pDB )  \n{  \n   m_rgID = NULL;  \n   m_rgName = NULL;  \n   m_rgIDLengths = NULL;  \n   m_rgNameLengths = NULL;  \n   m_strNameParam = \"\";  \n  \n   m_nFields = 2;  \n   m_nParams = 1;  \n  \n   .  \n   .  \n   .  \n}  \n```  \n  \n Finally, you must override the `DoBulkFieldExchange` member function. For the field data members, call the Bulk RFX functions; for any parameter data members, call the RFX functions. If you opened the recordset by passing a SQL statement or stored procedure to **Open**, the order in which you make the Bulk RFX calls must correspond to the order of the columns in the recordset; similarly, the order of the RFX calls for parameters must correspond to the order of parameters in the SQL statement or stored procedure.  \n  \n```  \nvoid MultiRowSet::DoBulkFieldExchange( CFieldExchange* pFX )  \n{  \n   // call the Bulk RFX functions  \n   // for field data members  \n   pFX->SetFieldType( CFieldExchange::outputColumn );  \n   RFX_Long_Bulk( pFX, _T( \"[colRecID]\" ),  \n                  &m_rgID, &m_rgIDLengths );  \n   RFX_Text_Bulk( pFX, _T( \"[colName]\" ),  \n                  &m_rgName, &m_rgNameLengths, 30 );  \n  \n   // call the RFX functions for  \n   // for parameter data members  \n   pFX->SetFieldType( CFieldExchange::inputParam );  \n   RFX_Text( pFX, \"NameParam\", m_strNameParam );  \n}  \n```  \n  \n> [!NOTE]\n>  You must call the **Close** member function before your derived `CRecordset` class goes out of scope. This ensures that any memory allocated by the framework are freed. It is good programming practice to always explicitly call **Close**, regardless of whether you have implemented bulk row fetching.  \n  \n For more information about record field exchange (RFX), see [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md). For more information about using parameters, see [CFieldExchange::SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) and [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md).  \n  \n## See Also  \n [Recordset (ODBC)](../../data/odbc/recordset-odbc.md)   \n [CRecordset::m_nFields](../../mfc/reference/crecordset-class.md#crecordset__m_nfields)   \n [CRecordset::m_nParams](../../mfc/reference/crecordset-class.md#crecordset__m_nparams)\n\n"}