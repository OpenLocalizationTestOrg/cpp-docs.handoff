<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64fd4757a9cdede2410a607d91623b2103297315</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\build\regular-dlls-statically-linked-to-mfc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">80765b037b1411f410edddf783bb743528d2d402</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a91e350d50632c2ba67e812c5ccac52cca986fd</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular DLLs Statically Linked to MFC | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular DLLs Statically Linked to MFC</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A regular DLL statically linked to MFC is a DLL that uses MFC internally, and the exported functions in the DLL can be called by either MFC or non-MFC executables.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>As the name describes, this kind of DLL is built using the static link library version of MFC.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Functions are usually exported from a regular DLL using the standard C interface.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For an example of how to write, build, and use a regular DLL, see the sample <bpt id="p1">[</bpt>DLLScreenCap<ept id="p1">](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Note that the term USRDLL is no longer used in the Visual C++ documentation.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A regular DLL that is statically linked to MFC has the same characteristics as the former USRDLL.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A regular DLL, statically linked to MFC, has the following features:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The client executable can be written in any language that supports the use of DLLs (C, C++, Pascal, Visual Basic, and so on); it does not have to be an MFC application.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The DLL can link to the same MFC static link libraries used by applications.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>There is no longer a separate version of the static link libraries for DLLs.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Before version 4.0 of MFC, USRDLLs provided the same type of functionality as regular DLLs statically linked to MFC.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>As of Visual C++ version 4.0, the term USRDLL is obsolete.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A regular DLL, statically linked to MFC, has the following requirements:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This type of DLL must instantiate a class derived from <ph id="ph1">`CWinApp`</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This type of DLL uses the <ph id="ph1">`DllMain`</ph> provided by MFC.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Place all DLL-specific initialization code in the <ph id="ph1">`InitInstance`</ph> member function and termination code in <ph id="ph2">`ExitInstance`</ph> as in a normal MFC application.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the term USRDLL is obsolete, you must still define "<bpt id="p1">**</bpt>_USRDLL<ept id="p1">**</ept>" on the compiler command line.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This definition determines which declarations is pulled in from the MFC header files.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Regular DLLs must have a <ph id="ph1">`CWinApp`</ph>-derived class and a single object of that application class, as does an MFC application.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`CWinApp`</ph> object of the DLL does not have a main message pump, as does the <ph id="ph2">`CWinApp`</ph> object of an application.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`CWinApp::Run`</ph> mechanism does not apply to a DLL, because the application owns the main message pump.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If the DLL opens modeless dialogs or has a main frame window of its own, the application's main message pump must call a routine exported by the DLL that in turn calls the <ph id="ph1">`CWinApp::PreTranslateMessage`</ph> member function of the DLL's application object.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For an example of this function, see the DLLScreenCap sample.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Symbols are usually exported from a regular DLL using the standard C interface.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The declaration of a function exported from a regular DLL would look something like this:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>All memory allocations within a regular DLL should stay within the DLL; the DLL should not pass to or receive from the calling executable any of the following:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Pointers to MFC objects</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Pointers to memory allocated by MFC</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you need to do any of the above or need to pass MFC-derived objects between the calling executable and the DLL, you must build an extension DLL.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It is safe to pass pointers to memory that were allocated by the C run-time libraries between an application and a DLL only if you make a copy of the data.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You must not delete or resize these pointers or use them without making a copy of the memory.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A DLL that is statically linked to MFC cannot also dynamically link to the shared MFC DLLs.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A DLL that is statically linked to MFC is dynamically bound to an application just like any other DLL; applications link to it just like any other DLL.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The standard MFC static link libraries are named according to the convention described in <bpt id="p1">[</bpt>Naming Conventions for MFC DLLs<ept id="p1">](../build/naming-conventions-for-mfc-dlls.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, with MFC version 3.0 and later, it is no longer necessary to manually specify to the linker the version of the MFC library you want linked in.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Instead, the MFC header files automatically determine the correct version of the MFC library to link in based on preprocessor defines, such as <bpt id="p1">**</bpt>_DEBUG<ept id="p1">**</ept> or <bpt id="p2">**</bpt>_UNICODE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The MFC header files add /DEFAULTLIB directives instructing the linker to link in a specific version of the MFC library.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>What do you want to do?</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Initialize regular DLLs</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>What do you want to know more about?</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Using MFC as Part of a DLL</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Using Database, OLE, and Sockets Extension DLLs in Regular DLLs</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Creating an MFC DLL</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Regular DLLs Dynamically Linked to MFC</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Extension DLLs</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Kinds of DLLs</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>