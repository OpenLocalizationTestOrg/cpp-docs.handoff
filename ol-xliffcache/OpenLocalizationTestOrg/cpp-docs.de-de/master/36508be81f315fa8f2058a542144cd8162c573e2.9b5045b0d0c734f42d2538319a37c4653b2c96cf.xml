{"nodes":[{"pos":[12,61],"content":"Compiler Warning (level 1) C4691 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Warning (level 1) C4691 | Microsoft Docs","pos":[0,49]}]},{"pos":[610,642],"content":"Compiler Warning (level 1) C4691","linkify":"Compiler Warning (level 1) C4691","nodes":[{"content":"Compiler Warning (level 1) C4691","pos":[0,32]}]},{"content":"'type' : type referenced was expected in unreferenced assembly 'file', type defined in current translation unit used instead","pos":[643,767]},{"content":"The metadata file containing the original type definition is not referenced, and the compiler is using a local type definition.","pos":[774,901]},{"content":"In the case where you are rebuilding <bpt id=\"p1\">*</bpt>file<ept id=\"p1\">*</ept>, C4691 can be ignored or turned off with pragma <bpt id=\"p2\">[</bpt>warning<ept id=\"p2\">](../../preprocessor/warning.md)</ept>.","pos":[908,1041],"source":"In the case where you are rebuilding *file*, C4691 can be ignored or turned off with pragma [warning](../../preprocessor/warning.md)."},{"content":"That is, if the file you are building is the same as the file where the compiler expects to find the type definition, you can ignore C4691.","pos":[1043,1182]},{"content":"However, unexpected behavior can occur if the compiler uses a definition that is not from the same assembly that is referenced in metadata; CLR types are typed not only by the name of the type, but also by the assembly.","pos":[1189,1408]},{"content":"That is, a type Z from assembly z.dll is different from a type Z from assembly y.dll.","pos":[1410,1495]},{"pos":[1504,1511],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This sample contains the original type definition.","pos":[1515,1565]},{"pos":[1675,1682],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This sample references C4691_a.dll and declares a field of type Original_Type.","pos":[1686,1764]},{"pos":[1923,1930],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample generates C4691.","pos":[1934,1971]},{"content":"Notice this sample contains a definition for Original_Type and does not reference C4691a.dll.","pos":[1973,2066]},{"content":"To resolve, reference the metadata file that contains the original type definition and remove the local declaration and definition.","pos":[2073,2204]}],"content":"---\ntitle: \"Compiler Warning (level 1) C4691 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C4691\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C4691\"\nms.assetid: 722133d9-87f6-46c1-9e86-9825453d6999\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Warning (level 1) C4691\n'type' : type referenced was expected in unreferenced assembly 'file', type defined in current translation unit used instead  \n  \n The metadata file containing the original type definition is not referenced, and the compiler is using a local type definition.  \n  \n In the case where you are rebuilding *file*, C4691 can be ignored or turned off with pragma [warning](../../preprocessor/warning.md).  That is, if the file you are building is the same as the file where the compiler expects to find the type definition, you can ignore C4691.  \n  \n However, unexpected behavior can occur if the compiler uses a definition that is not from the same assembly that is referenced in metadata; CLR types are typed not only by the name of the type, but also by the assembly.  That is, a type Z from assembly z.dll is different from a type Z from assembly y.dll.  \n  \n## Example  \n This sample contains the original type definition.  \n  \n```  \n// C4691_a.cpp  \n// compile with: /clr /LD /W1  \npublic ref class Original_Type {};  \n```  \n  \n## Example  \n This sample references C4691_a.dll and declares a field of type Original_Type.  \n  \n```  \n// C4691_b.cpp  \n// compile with: /clr /LD  \n#using \"C4691_a.dll\"  \npublic ref class Client {  \npublic:  \n   Original_Type^ ot;  \n};  \n```  \n  \n## Example  \n The following sample generates C4691.  Notice this sample contains a definition for Original_Type and does not reference C4691a.dll.  \n  \n To resolve, reference the metadata file that contains the original type definition and remove the local declaration and definition.  \n  \n```  \n// C4691_c.cpp  \n// compile with: /clr /LD /W1  \n// C4691 expected  \n  \n// Uncomment the following line to resolve.  \n// #using \"C4691_a.dll\"  \n#using \"C4691_b.dll\"  \n  \n// Delete the following line to resolve.  \nref class Original_Type;  \n  \npublic ref class MyClass : Client {};  \n```"}