{"nodes":[{"pos":[12,51],"content":"Template-Based Classes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Template-Based Classes | Microsoft Docs","pos":[0,39]}]},{"content":"Template-Based Classes","pos":[1278,1300]},{"content":"This article explains the type-safe template-based collection classes in MFC version 3.0 and later.","pos":[1301,1400]},{"content":"Using these templates to create type-safe collections is more convenient and helps provide type safety more effectively than using the collection classes not based on templates.","pos":[1401,1578]},{"content":"MFC predefines two categories of template-based collections:","pos":[1585,1645]},{"content":"Simple array, list, and map classes","pos":[1656,1691]},{"pos":[1769,1779],"content":", <ph id=\"ph1\">`CList`</ph>,","source":", `CList`, "},{"content":"Arrays, lists, and maps of typed pointers","pos":[1797,1838]},{"pos":[1918,1936],"content":", <ph id=\"ph1\">`CTypedPtrList`</ph>,","source":", `CTypedPtrList`, "},{"content":"The simple collection classes are all derived from class <ph id=\"ph1\">`CObject`</ph>, so they inherit the serialization, dynamic creation, and other properties of <ph id=\"ph2\">`CObject`</ph>.","pos":[1958,2113],"source":"The simple collection classes are all derived from class `CObject`, so they inherit the serialization, dynamic creation, and other properties of `CObject`."},{"content":"The typed pointer collection classes require you to specify the class you derive from — which must be one of the nontemplate pointer collections predefined by MFC, such as <ph id=\"ph1\">`CPtrList`</ph> or <ph id=\"ph2\">`CPtrArray`</ph>.","pos":[2114,2312],"source":" The typed pointer collection classes require you to specify the class you derive from — which must be one of the nontemplate pointer collections predefined by MFC, such as `CPtrList` or `CPtrArray`."},{"content":"Your new collection class inherits from the specified base class, and the new class's member functions use encapsulated calls to the base class members to enforce type safety.","pos":[2313,2488]},{"pos":[2495,2610],"content":"For more information about C++ templates, see <bpt id=\"p1\">[</bpt>Templates<ept id=\"p1\">](../cpp/templates-cpp.md)</ept> in the <bpt id=\"p2\">*</bpt>C++ Language Reference<ept id=\"p2\">*</ept>.","source":"For more information about C++ templates, see [Templates](../cpp/templates-cpp.md) in the *C++ Language Reference*."},{"pos":[2691,2734],"content":"Using Simple Array, List, and Map Templates"},{"content":"To use the simple collection templates, you need to know what kind of data you can store in these collections and what parameters to use in your collection declarations.","pos":[2738,2907]},{"pos":[2967,2994],"content":"Simple Array and List Usage"},{"content":"The simple array and list classes, <bpt id=\"p1\">[</bpt>CArray<ept id=\"p1\">](../mfc/reference/carray-class.md)</ept> and <bpt id=\"p2\">[</bpt>CList<ept id=\"p2\">](../mfc/reference/clist-class.md)</ept>, take two parameters: <bpt id=\"p3\">*</bpt>TYPE<ept id=\"p3\">*</ept> and <ph id=\"ph1\">`ARG_TYPE`</ph>.","pos":[2998,3165],"source":"The simple array and list classes, [CArray](../mfc/reference/carray-class.md) and [CList](../mfc/reference/clist-class.md), take two parameters: *TYPE* and `ARG_TYPE`."},{"content":"These classes can store any data type, which you specify in the <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept> parameter:","pos":[3166,3247],"source":" These classes can store any data type, which you specify in the *TYPE* parameter:"},{"pos":[3257,3321],"content":"Fundamental C++ data types, such as <ph id=\"ph1\">`int`</ph>, <ph id=\"ph2\">`char`</ph>, and <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>","source":"Fundamental C++ data types, such as `int`, `char`, and **float**"},{"content":"C++ structures and classes","pos":[3331,3357]},{"content":"Other types that you define","pos":[3367,3394]},{"content":"For convenience and efficiency, you can use the <ph id=\"ph1\">`ARG_TYPE`</ph> parameter to specify the type of function arguments.","pos":[3401,3512],"source":"For convenience and efficiency, you can use the `ARG_TYPE` parameter to specify the type of function arguments."},{"content":"Typically, you specify <ph id=\"ph1\">`ARG_TYPE`</ph> as a reference to the type you named in the <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept> parameter.","pos":[3513,3608],"source":" Typically, you specify `ARG_TYPE` as a reference to the type you named in the *TYPE* parameter."},{"content":"For example:","pos":[3609,3621]},{"pos":[3639,3659],"content":"NVC_MFCCollections#1"},{"content":"The first example declares an array collection, <ph id=\"ph1\">`myArray`</ph>, that contains <ph id=\"ph2\">`int`</ph>s.","pos":[3721,3801],"source":"The first example declares an array collection, `myArray`, that contains `int`s."},{"content":"The second example declares a list collection, <ph id=\"ph1\">`myList`</ph>, that stores <ph id=\"ph2\">`CPerson`</ph> objects.","pos":[3802,3889],"source":" The second example declares a list collection, `myList`, that stores `CPerson` objects."},{"content":"Certain member functions of the collection classes take arguments whose type is specified by the <ph id=\"ph1\">`ARG_TYPE`</ph> template parameter.","pos":[3890,4017],"source":" Certain member functions of the collection classes take arguments whose type is specified by the `ARG_TYPE` template parameter."},{"content":"For example, the <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept> member function of class <ph id=\"ph1\">`CArray`</ph> takes an <ph id=\"ph2\">`ARG_TYPE`</ph> argument:","pos":[4018,4106],"source":" For example, the **Add** member function of class `CArray` takes an `ARG_TYPE` argument:"},{"pos":[4124,4144],"content":"NVC_MFCCollections#2"},{"pos":[4248,4264],"content":"Simple Map Usage"},{"content":"The simple map class, <bpt id=\"p1\">[</bpt>CMap<ept id=\"p1\">](../mfc/reference/cmap-class.md)</ept>, takes four parameters: <bpt id=\"p2\">*</bpt>KEY<ept id=\"p2\">*</ept>, <ph id=\"ph1\">`ARG_KEY`</ph>, <bpt id=\"p3\">*</bpt>VALUE<ept id=\"p3\">*</ept>, and <ph id=\"ph2\">`ARG_VALUE`</ph>.","pos":[4268,4396],"source":"The simple map class, [CMap](../mfc/reference/cmap-class.md), takes four parameters: *KEY*, `ARG_KEY`, *VALUE*, and `ARG_VALUE`."},{"content":"Like the array and list classes, the map classes can store any data type.","pos":[4397,4470]},{"content":"Unlike arrays and lists, which index and order the data they store, maps associate keys and values: You access a value stored in a map by specifying the value's associated key.","pos":[4471,4647]},{"content":"The <bpt id=\"p1\">*</bpt>KEY<ept id=\"p1\">*</ept> parameter specifies the data type of the keys used to access data stored in the map.","pos":[4648,4742],"source":" The *KEY* parameter specifies the data type of the keys used to access data stored in the map."},{"content":"If the type of <bpt id=\"p1\">*</bpt>KEY<ept id=\"p1\">*</ept> is a structure or class, the <ph id=\"ph1\">`ARG_KEY`</ph> parameter is typically a reference to the type specified in <bpt id=\"p2\">*</bpt>KEY<ept id=\"p2\">*</ept>.","pos":[4743,4869],"source":" If the type of *KEY* is a structure or class, the `ARG_KEY` parameter is typically a reference to the type specified in *KEY*."},{"content":"The <bpt id=\"p1\">*</bpt>VALUE<ept id=\"p1\">*</ept> parameter specifies the type of the items stored in the map.","pos":[4870,4942],"source":" The *VALUE* parameter specifies the type of the items stored in the map."},{"content":"If the type of <ph id=\"ph1\">`ARG_VALUE`</ph> is a structure or class, the <ph id=\"ph2\">`ARG_VALUE`</ph> parameter is typically a reference to the type specified in <bpt id=\"p1\">*</bpt>VALUE<ept id=\"p1\">*</ept>.","pos":[4943,5079],"source":" If the type of `ARG_VALUE` is a structure or class, the `ARG_VALUE` parameter is typically a reference to the type specified in *VALUE*."},{"content":"For example:","pos":[5080,5092]},{"pos":[5110,5130],"content":"NVC_MFCCollections#3"},{"content":"The first example stores <ph id=\"ph1\">`MY_STRUCT`</ph> values, accesses them by <ph id=\"ph2\">`int`</ph> keys, and returns accessed <ph id=\"ph3\">`MY_STRUCT`</ph> items by reference.","pos":[5192,5318],"source":"The first example stores `MY_STRUCT` values, accesses them by `int` keys, and returns accessed `MY_STRUCT` items by reference."},{"content":"The second example stores <ph id=\"ph1\">`CPerson`</ph> values, accesses them by <ph id=\"ph2\">`CString`</ph> keys, and returns references to accessed items.","pos":[5319,5437],"source":" The second example stores `CPerson` values, accesses them by `CString` keys, and returns references to accessed items."},{"content":"This example might represent a simple address book, in which you look up persons by last name.","pos":[5438,5532]},{"content":"Because the <bpt id=\"p1\">*</bpt>KEY<ept id=\"p1\">*</ept> parameter is of type <ph id=\"ph1\">`CString`</ph> and the <bpt id=\"p2\">*</bpt>KEY_TYPE<ept id=\"p2\">*</ept> parameter is of type <ph id=\"ph2\">`LPCSTR`</ph>, the keys are stored in the map as items of type <ph id=\"ph3\">`CString`</ph> but are referenced in functions such as <ph id=\"ph4\">`SetAt`</ph> through pointers of type <ph id=\"ph5\">`LPCSTR`</ph>.","pos":[5539,5778],"source":"Because the *KEY* parameter is of type `CString` and the *KEY_TYPE* parameter is of type `LPCSTR`, the keys are stored in the map as items of type `CString` but are referenced in functions such as `SetAt` through pointers of type `LPCSTR`."},{"content":"For example:","pos":[5779,5791]},{"pos":[5809,5829],"content":"NVC_MFCCollections#4"},{"pos":[5959,5999],"content":"Using Typed-Pointer Collection Templates"},{"content":"To use the typed-pointer collection templates, you need to know what kinds of data you can store in these collections and what parameters to use in your collection declarations.","pos":[6003,6180]},{"pos":[6250,6284],"content":"Typed-Pointer Array and List Usage"},{"content":"The typed-pointer array and list classes, <bpt id=\"p1\">[</bpt>CTypedPtrArray<ept id=\"p1\">](../mfc/reference/ctypedptrarray-class.md)</ept> and <bpt id=\"p2\">[</bpt>CTypedPtrList<ept id=\"p2\">](../mfc/reference/ctypedptrlist-class.md)</ept>, take two parameters: <ph id=\"ph1\">`BASE_CLASS`</ph> and <bpt id=\"p3\">*</bpt>TYPE<ept id=\"p3\">*</ept>.","pos":[6288,6496],"source":"The typed-pointer array and list classes, [CTypedPtrArray](../mfc/reference/ctypedptrarray-class.md) and [CTypedPtrList](../mfc/reference/ctypedptrlist-class.md), take two parameters: `BASE_CLASS` and *TYPE*."},{"content":"These classes can store any data type, which you specify in the <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept> parameter.","pos":[6497,6578],"source":" These classes can store any data type, which you specify in the *TYPE* parameter."},{"content":"They are derived from one of the nontemplate collection classes that stores pointers; you specify this base class in <ph id=\"ph1\">`BASE_CLASS`</ph>.","pos":[6579,6709],"source":" They are derived from one of the nontemplate collection classes that stores pointers; you specify this base class in `BASE_CLASS`."},{"content":"For arrays, use either <ph id=\"ph1\">`CObArray`</ph> or <ph id=\"ph2\">`CPtrArray`</ph>.","pos":[6710,6759],"source":" For arrays, use either `CObArray` or `CPtrArray`."},{"content":"For lists, use either <ph id=\"ph1\">`CObList`</ph> or <ph id=\"ph2\">`CPtrList`</ph>.","pos":[6760,6806],"source":" For lists, use either `CObList` or `CPtrList`."},{"content":"In effect, when you declare a collection based on, say <ph id=\"ph1\">`CObList`</ph>, the new class not only inherits the members of its base class, but it also declares a number of additional type-safe member functions and operators that help provide type safety by encapsulating calls to the base class members.","pos":[6813,7106],"source":"In effect, when you declare a collection based on, say `CObList`, the new class not only inherits the members of its base class, but it also declares a number of additional type-safe member functions and operators that help provide type safety by encapsulating calls to the base class members."},{"content":"These encapsulations manage all necessary type conversion.","pos":[7107,7165]},{"content":"For example:","pos":[7166,7178]},{"pos":[7196,7216],"content":"NVC_MFCCollections#5"},{"content":"The first example declares a typed-pointer array, <ph id=\"ph1\">`myArray`</ph>, derived from <ph id=\"ph2\">`CObArray`</ph>.","pos":[7278,7363],"source":"The first example declares a typed-pointer array, `myArray`, derived from `CObArray`."},{"content":"The array stores and returns pointers to <ph id=\"ph1\">`CPerson`</ph> objects (where <ph id=\"ph2\">`CPerson`</ph> is a class derived from <ph id=\"ph3\">`CObject`</ph>).","pos":[7364,7475],"source":" The array stores and returns pointers to `CPerson` objects (where `CPerson` is a class derived from `CObject`)."},{"content":"You can call any <ph id=\"ph1\">`CObArray`</ph> member function, or you can call the new type-safe <ph id=\"ph2\">`GetAt`</ph> and <ph id=\"ph3\">`ElementAt`</ph> functions or use the type-safe <bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept> operator.","pos":[7476,7627],"source":" You can call any `CObArray` member function, or you can call the new type-safe `GetAt` and `ElementAt` functions or use the type-safe **[ ]** operator."},{"content":"The second example declares a typed-pointer list, <ph id=\"ph1\">`myList`</ph>, derived from <ph id=\"ph2\">`CPtrList`</ph>.","pos":[7634,7718],"source":"The second example declares a typed-pointer list, `myList`, derived from `CPtrList`."},{"content":"The list stores and returns pointers to <ph id=\"ph1\">`MY_STRUCT`</ph> objects.","pos":[7719,7779],"source":" The list stores and returns pointers to `MY_STRUCT` objects."},{"content":"A class based on <ph id=\"ph1\">`CPtrList`</ph> is used for storing pointers to objects not derived from <ph id=\"ph2\">`CObject`</ph>.","pos":[7780,7875],"source":" A class based on `CPtrList` is used for storing pointers to objects not derived from `CObject`."},{"content":"has a number of type-safe member functions: <ph id=\"ph1\">`GetHead`</ph>, <ph id=\"ph2\">`GetTail`</ph>, <ph id=\"ph3\">`RemoveHead`</ph>, <ph id=\"ph4\">`RemoveTail`</ph>, <ph id=\"ph5\">`GetNext`</ph>, <ph id=\"ph6\">`GetPrev`</ph>, and <ph id=\"ph7\">`GetAt`</ph>.","pos":[7892,8020],"source":" has a number of type-safe member functions: `GetHead`, `GetTail`, `RemoveHead`, `RemoveTail`, `GetNext`, `GetPrev`, and `GetAt`."},{"pos":[8079,8102],"content":"Typed-Pointer Map Usage"},{"content":"The typed-pointer map class, <bpt id=\"p1\">[</bpt>CTypedPtrMap<ept id=\"p1\">](../mfc/reference/ctypedptrmap-class.md)</ept>, takes three parameters: <ph id=\"ph1\">`BASE_CLASS`</ph>, <bpt id=\"p2\">*</bpt>KEY<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>VALUE<ept id=\"p3\">*</ept>.","pos":[8106,8248],"source":"The typed-pointer map class, [CTypedPtrMap](../mfc/reference/ctypedptrmap-class.md), takes three parameters: `BASE_CLASS`, *KEY*, and *VALUE*."},{"content":"The <ph id=\"ph1\">`BASE_CLASS`</ph> parameter specifies the class from which to derive the new class: <ph id=\"ph2\">`CMapPtrToWord`</ph>, <ph id=\"ph3\">`CMapPtrToPtr`</ph>, <ph id=\"ph4\">`CMapStringToPtr`</ph>, <ph id=\"ph5\">`CMapWordToPtr`</ph>, <ph id=\"ph6\">`CMapStringToOb`</ph>, and so on.","pos":[8249,8429],"source":" The `BASE_CLASS` parameter specifies the class from which to derive the new class: `CMapPtrToWord`, `CMapPtrToPtr`, `CMapStringToPtr`, `CMapWordToPtr`, `CMapStringToOb`, and so on."},{"content":"<bpt id=\"p1\">*</bpt>KEY<ept id=\"p1\">*</ept> is analogous to <bpt id=\"p2\">*</bpt>KEY<ept id=\"p2\">*</ept> in <ph id=\"ph1\">`CMap`</ph>: It specifies the type of the key used for lookups.","pos":[8430,8519],"source":"*KEY* is analogous to *KEY* in `CMap`: It specifies the type of the key used for lookups."},{"content":"<bpt id=\"p1\">*</bpt>VALUE<ept id=\"p1\">*</ept> is analogous to <bpt id=\"p2\">*</bpt>VALUE<ept id=\"p2\">*</ept> in <ph id=\"ph1\">`CMap`</ph>: It specifies the type of object stored in the map.","pos":[8520,8613],"source":"*VALUE* is analogous to *VALUE* in `CMap`: It specifies the type of object stored in the map."},{"content":"For example:","pos":[8614,8626]},{"pos":[8644,8664],"content":"NVC_MFCCollections#6"},{"content":"The first example is a map based on <bpt id=\"p1\">**</bpt>CMapPtrToPt<ept id=\"p1\">**</ept>r — it uses <ph id=\"ph1\">`CString`</ph> keys mapped to pointers to <ph id=\"ph2\">`MY_STRUCT`</ph>.","pos":[8726,8838],"source":"The first example is a map based on **CMapPtrToPt**r — it uses `CString` keys mapped to pointers to `MY_STRUCT`."},{"content":"You can look up a stored pointer by calling a type-safe <ph id=\"ph1\">`Lookup`</ph> member function.","pos":[8839,8920],"source":" You can look up a stored pointer by calling a type-safe `Lookup` member function."},{"content":"You can use the <bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept> operator to look up a stored pointer and add it if not found.","pos":[8921,9006],"source":" You can use the **[ ]** operator to look up a stored pointer and add it if not found."},{"content":"And you can iterate the map using the type-safe <ph id=\"ph1\">`GetNextAssoc`</ph> function.","pos":[9007,9079],"source":" And you can iterate the map using the type-safe `GetNextAssoc` function."},{"content":"You can also call other member functions of class <ph id=\"ph1\">`CMapPtrToPtr`</ph>.","pos":[9080,9145],"source":" You can also call other member functions of class `CMapPtrToPtr`."},{"content":"The second example is a map based on <bpt id=\"p1\">**</bpt>CMapStringToO<ept id=\"p1\">**</ept>b — it uses string keys mapped to stored pointers to <ph id=\"ph1\">`CMyObject`</ph> objects.","pos":[9152,9279],"source":"The second example is a map based on **CMapStringToO**b — it uses string keys mapped to stored pointers to `CMyObject` objects."},{"content":"You can use the same type-safe members described in the previous paragraph, or you can call members of class <ph id=\"ph1\">`CMapStringToOb`</ph>.","pos":[9280,9406],"source":" You can use the same type-safe members described in the previous paragraph, or you can call members of class `CMapStringToOb`."},{"pos":[9414,9596],"content":"[!NOTE]\n If you specify a **class** or `struct` type for the *VALUE* parameter, rather than a pointer or reference to the type, the class or structure must have a copy constructor.","leadings":["","> "],"nodes":[{"content":"If you specify a <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`struct`</ph> type for the <bpt id=\"p2\">*</bpt>VALUE<ept id=\"p2\">*</ept> parameter, rather than a pointer or reference to the type, the class or structure must have a copy constructor.","pos":[9,180],"source":" If you specify a **class** or `struct` type for the *VALUE* parameter, rather than a pointer or reference to the type, the class or structure must have a copy constructor."}]},{"pos":[9603,9712],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to Make a Type-Safe Collection<ept id=\"p1\">](../mfc/how-to-make-a-type-safe-collection.md)</ept>.","source":"For more information, see [How to Make a Type-Safe Collection](../mfc/how-to-make-a-type-safe-collection.md)."},{"content":"See Also","pos":[9721,9729]},{"content":"Collections","pos":[9734,9745]}],"content":"---\ntitle: \"Template-Based Classes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"type-safe collections\"\n  - \"CTypedPtrList class, template-based classes\"\n  - \"arrays [C++], classes\"\n  - \"arrays [C++], pointers\"\n  - \"typed pointers, collections of\"\n  - \"arrays [C++], template-based\"\n  - \"CArray class, template-based classes\"\n  - \"simple template-based collections\"\n  - \"simple array collection classes\"\n  - \"typed pointers\"\n  - \"collections, typed-pointer\"\n  - \"CList class, template-based classes\"\n  - \"collection classes, template-based\"\n  - \"CTypedPtrMap class, template-based classes\"\n  - \"pointers, collections of typed\"\n  - \"CTypedPtrArray class, template-based classes\"\n  - \"MFC collection classes, template-based\"\n  - \"template-based collection classes\"\n  - \"simple list collection classes\"\nms.assetid: c69fc95b-c8f6-4a99-abed-517c9898ef0c\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Template-Based Classes\nThis article explains the type-safe template-based collection classes in MFC version 3.0 and later. Using these templates to create type-safe collections is more convenient and helps provide type safety more effectively than using the collection classes not based on templates.  \n  \n MFC predefines two categories of template-based collections:  \n  \n-   [Simple array, list, and map classes](#_core_using_simple_array.2c_.list.2c_.and_map_templates)  \n  \n     `CArray`, `CList`, `CMap`  \n  \n-   [Arrays, lists, and maps of typed pointers](#_core_using_typed.2d.pointer_collection_templates)  \n  \n     `CTypedPtrArray`, `CTypedPtrList`, `CTypedPtrMap`  \n  \n The simple collection classes are all derived from class `CObject`, so they inherit the serialization, dynamic creation, and other properties of `CObject`. The typed pointer collection classes require you to specify the class you derive from — which must be one of the nontemplate pointer collections predefined by MFC, such as `CPtrList` or `CPtrArray`. Your new collection class inherits from the specified base class, and the new class's member functions use encapsulated calls to the base class members to enforce type safety.  \n  \n For more information about C++ templates, see [Templates](../cpp/templates-cpp.md) in the *C++ Language Reference*.  \n  \n##  <a name=\"_core_using_simple_array.2c_.list.2c_.and_map_templates\"></a> Using Simple Array, List, and Map Templates  \n To use the simple collection templates, you need to know what kind of data you can store in these collections and what parameters to use in your collection declarations.  \n  \n###  <a name=\"_core_simple_array_and_list_usage\"></a> Simple Array and List Usage  \n The simple array and list classes, [CArray](../mfc/reference/carray-class.md) and [CList](../mfc/reference/clist-class.md), take two parameters: *TYPE* and `ARG_TYPE`. These classes can store any data type, which you specify in the *TYPE* parameter:  \n  \n-   Fundamental C++ data types, such as `int`, `char`, and **float**  \n  \n-   C++ structures and classes  \n  \n-   Other types that you define  \n  \n For convenience and efficiency, you can use the `ARG_TYPE` parameter to specify the type of function arguments. Typically, you specify `ARG_TYPE` as a reference to the type you named in the *TYPE* parameter. For example:  \n  \n [!code-cpp[NVC_MFCCollections#1](../mfc/codesnippet/cpp/template-based-classes_1.cpp)]  \n  \n The first example declares an array collection, `myArray`, that contains `int`s. The second example declares a list collection, `myList`, that stores `CPerson` objects. Certain member functions of the collection classes take arguments whose type is specified by the `ARG_TYPE` template parameter. For example, the **Add** member function of class `CArray` takes an `ARG_TYPE` argument:  \n  \n [!code-cpp[NVC_MFCCollections#2](../mfc/codesnippet/cpp/template-based-classes_2.cpp)]  \n  \n###  <a name=\"_core_simple_map_usage\"></a> Simple Map Usage  \n The simple map class, [CMap](../mfc/reference/cmap-class.md), takes four parameters: *KEY*, `ARG_KEY`, *VALUE*, and `ARG_VALUE`. Like the array and list classes, the map classes can store any data type. Unlike arrays and lists, which index and order the data they store, maps associate keys and values: You access a value stored in a map by specifying the value's associated key. The *KEY* parameter specifies the data type of the keys used to access data stored in the map. If the type of *KEY* is a structure or class, the `ARG_KEY` parameter is typically a reference to the type specified in *KEY*. The *VALUE* parameter specifies the type of the items stored in the map. If the type of `ARG_VALUE` is a structure or class, the `ARG_VALUE` parameter is typically a reference to the type specified in *VALUE*. For example:  \n  \n [!code-cpp[NVC_MFCCollections#3](../mfc/codesnippet/cpp/template-based-classes_3.cpp)]  \n  \n The first example stores `MY_STRUCT` values, accesses them by `int` keys, and returns accessed `MY_STRUCT` items by reference. The second example stores `CPerson` values, accesses them by `CString` keys, and returns references to accessed items. This example might represent a simple address book, in which you look up persons by last name.  \n  \n Because the *KEY* parameter is of type `CString` and the *KEY_TYPE* parameter is of type `LPCSTR`, the keys are stored in the map as items of type `CString` but are referenced in functions such as `SetAt` through pointers of type `LPCSTR`. For example:  \n  \n [!code-cpp[NVC_MFCCollections#4](../mfc/codesnippet/cpp/template-based-classes_4.cpp)]  \n  \n##  <a name=\"_core_using_typed.2d.pointer_collection_templates\"></a> Using Typed-Pointer Collection Templates  \n To use the typed-pointer collection templates, you need to know what kinds of data you can store in these collections and what parameters to use in your collection declarations.  \n  \n###  <a name=\"_core_typed.2d.pointer_array_and_list_usage\"></a> Typed-Pointer Array and List Usage  \n The typed-pointer array and list classes, [CTypedPtrArray](../mfc/reference/ctypedptrarray-class.md) and [CTypedPtrList](../mfc/reference/ctypedptrlist-class.md), take two parameters: `BASE_CLASS` and *TYPE*. These classes can store any data type, which you specify in the *TYPE* parameter. They are derived from one of the nontemplate collection classes that stores pointers; you specify this base class in `BASE_CLASS`. For arrays, use either `CObArray` or `CPtrArray`. For lists, use either `CObList` or `CPtrList`.  \n  \n In effect, when you declare a collection based on, say `CObList`, the new class not only inherits the members of its base class, but it also declares a number of additional type-safe member functions and operators that help provide type safety by encapsulating calls to the base class members. These encapsulations manage all necessary type conversion. For example:  \n  \n [!code-cpp[NVC_MFCCollections#5](../mfc/codesnippet/cpp/template-based-classes_5.cpp)]  \n  \n The first example declares a typed-pointer array, `myArray`, derived from `CObArray`. The array stores and returns pointers to `CPerson` objects (where `CPerson` is a class derived from `CObject`). You can call any `CObArray` member function, or you can call the new type-safe `GetAt` and `ElementAt` functions or use the type-safe **[ ]** operator.  \n  \n The second example declares a typed-pointer list, `myList`, derived from `CPtrList`. The list stores and returns pointers to `MY_STRUCT` objects. A class based on `CPtrList` is used for storing pointers to objects not derived from `CObject`. `CTypedPtrList` has a number of type-safe member functions: `GetHead`, `GetTail`, `RemoveHead`, `RemoveTail`, `GetNext`, `GetPrev`, and `GetAt`.  \n  \n###  <a name=\"_core_typed.2d.pointer_map_usage\"></a> Typed-Pointer Map Usage  \n The typed-pointer map class, [CTypedPtrMap](../mfc/reference/ctypedptrmap-class.md), takes three parameters: `BASE_CLASS`, *KEY*, and *VALUE*. The `BASE_CLASS` parameter specifies the class from which to derive the new class: `CMapPtrToWord`, `CMapPtrToPtr`, `CMapStringToPtr`, `CMapWordToPtr`, `CMapStringToOb`, and so on. *KEY* is analogous to *KEY* in `CMap`: It specifies the type of the key used for lookups. *VALUE* is analogous to *VALUE* in `CMap`: It specifies the type of object stored in the map. For example:  \n  \n [!code-cpp[NVC_MFCCollections#6](../mfc/codesnippet/cpp/template-based-classes_6.cpp)]  \n  \n The first example is a map based on **CMapPtrToPt**r — it uses `CString` keys mapped to pointers to `MY_STRUCT`. You can look up a stored pointer by calling a type-safe `Lookup` member function. You can use the **[ ]** operator to look up a stored pointer and add it if not found. And you can iterate the map using the type-safe `GetNextAssoc` function. You can also call other member functions of class `CMapPtrToPtr`.  \n  \n The second example is a map based on **CMapStringToO**b — it uses string keys mapped to stored pointers to `CMyObject` objects. You can use the same type-safe members described in the previous paragraph, or you can call members of class `CMapStringToOb`.  \n  \n> [!NOTE]\n>  If you specify a **class** or `struct` type for the *VALUE* parameter, rather than a pointer or reference to the type, the class or structure must have a copy constructor.  \n  \n For more information, see [How to Make a Type-Safe Collection](../mfc/how-to-make-a-type-safe-collection.md).  \n  \n## See Also  \n [Collections](../mfc/collections.md)\n\n"}