{"nodes":[{"pos":[12,65],"content":"Vectorizer and Parallelizer Messages | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Vectorizer and Parallelizer Messages | Microsoft Docs","pos":[0,53]}]},{"pos":[628,664],"content":"Vectorizer and Parallelizer Messages","linkify":"Vectorizer and Parallelizer Messages","nodes":[{"content":"Vectorizer and Parallelizer Messages","pos":[0,36]}]},{"content":"You can use the Visual C++ compiler options <bpt id=\"p1\">[</bpt>/Qpar-report<ept id=\"p1\">](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md)</ept> and <bpt id=\"p2\">[</bpt>/Qvec-report<ept id=\"p2\">](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md)</ept> to set the <bpt id=\"p3\">[</bpt>Auto-Parallelization and Auto-Vectorization<ept id=\"p3\">](../../parallel/auto-parallelization-and-auto-vectorization.md)</ept> to output reason codes and informational messages about its activity.","pos":[665,1074],"source":"You can use the Visual C++ compiler options [/Qpar-report](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md) and [/Qvec-report](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md) to set the [Auto-Parallelization and Auto-Vectorization](../../parallel/auto-parallelization-and-auto-vectorization.md) to output reason codes and informational messages about its activity."},{"content":"This article explains the reason codes and the messages.","pos":[1075,1131]},{"pos":[1141,1194],"content":"<bpt id=\"p1\">[</bpt>Informational Messages<ept id=\"p1\">](#BKMK_InformationalMessages)</ept>","source":"[Informational Messages](#BKMK_InformationalMessages)"},{"pos":[1204,1230],"content":"<bpt id=\"p1\">[</bpt>5xx<ept id=\"p1\">](#BKMK_ReasonCode50x)</ept>","source":"[5xx](#BKMK_ReasonCode50x)"},{"pos":[1240,1268],"content":"<bpt id=\"p1\">[</bpt>10xx<ept id=\"p1\">](#BKMK_ReasonCode100x)</ept>","source":"[10xx](#BKMK_ReasonCode100x)"},{"pos":[1278,1306],"content":"<bpt id=\"p1\">[</bpt>11xx<ept id=\"p1\">](#BKMK_ReasonCode110x)</ept>","source":"[11xx](#BKMK_ReasonCode110x)"},{"pos":[1316,1344],"content":"<bpt id=\"p1\">[</bpt>12xx<ept id=\"p1\">](#BKMK_ReasonCode120x)</ept>","source":"[12xx](#BKMK_ReasonCode120x)"},{"pos":[1354,1382],"content":"<bpt id=\"p1\">[</bpt>13xx<ept id=\"p1\">](#BKMK_ReasonCode130x)</ept>","source":"[13xx](#BKMK_ReasonCode130x)"},{"pos":[1392,1420],"content":"<bpt id=\"p1\">[</bpt>14xx<ept id=\"p1\">](#BKMK_ReasonCode140x)</ept>","source":"[14xx](#BKMK_ReasonCode140x)"},{"pos":[1430,1458],"content":"<bpt id=\"p1\">[</bpt>15xx<ept id=\"p1\">](#BKMK_ReasonCode150x)</ept>","source":"[15xx](#BKMK_ReasonCode150x)"},{"pos":[1468,1532],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_InformationalMessages\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Informational Messages","linkify":"<a name=\"BKMK_InformationalMessages\"></a> Informational Messages","source":"<a name=\"BKMK_InformationalMessages\"></a> Informational Messages"},{"content":"Depending on the reporting level that you specify, one of the following informational messages appears for each loop.","pos":[1536,1653]},{"content":"For information about reason codes, refer to the next part of this article.","pos":[1660,1735]},{"content":"Informational Message","pos":[1742,1763]},{"content":"Description","pos":[1764,1775]},{"content":"5001","pos":[1830,1834]},{"content":"Loop vectorized.","pos":[1835,1851]},{"content":"5002","pos":[1856,1860]},{"content":"Loop not vectorized due to reason 'description'.","pos":[1861,1909]},{"content":"5011","pos":[1914,1918]},{"content":"Loop parallelized.","pos":[1919,1937]},{"content":"5012","pos":[1942,1946]},{"content":"Loop not parallelized due to reason 'description'.","pos":[1947,1997]},{"content":"5021","pos":[2002,2006]},{"content":"Unable to associate loop with pragma.","pos":[2007,2044]},{"pos":[2054,2066],"content":"Reason Codes","linkify":"Reason Codes","nodes":[{"content":"Reason Codes","pos":[0,12]}]},{"content":"The following sections list possible reason codes for the auto-parallelizer and auto-vectorizer.","pos":[2070,2166]},{"pos":[2177,2214],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode50x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 5xx","linkify":"<a name=\"BKMK_ReasonCode50x\"></a> 5xx","source":"<a name=\"BKMK_ReasonCode50x\"></a> 5xx"},{"pos":[2218,2301],"content":"The 5<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to both the auto-parallelizer and the auto-vectorizer.","source":"The 5*xx* reason codes apply to both the auto-parallelizer and the auto-vectorizer."},{"content":"Reason Code","pos":[2308,2319]},{"content":"Explanation","pos":[2320,2331]},{"content":"500","pos":[2376,2379]},{"content":"This is a generic message that covers several cases—for example, the loop includes multiple exits, or the loop header does not end by incrementing the induction variable.","pos":[2380,2550]},{"content":"501","pos":[2555,2558]},{"content":"Induction variable is not local; or upper bound is not loop-invariant.","pos":[2559,2629]},{"content":"502","pos":[2634,2637]},{"content":"Induction variable is stepped in some manner other than a simple +1.","pos":[2638,2706]},{"content":"503","pos":[2711,2714]},{"content":"Loop includes exception-handling or switch statements.","pos":[2715,2769]},{"content":"504","pos":[2774,2777]},{"content":"Loop body may throw an exception that requires destruction of a C++ object.","pos":[2778,2853]},{"pos":[6574,6613],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode100x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 10xx","linkify":"<a name=\"BKMK_ReasonCode100x\"></a> 10xx","source":"<a name=\"BKMK_ReasonCode100x\"></a> 10xx"},{"pos":[6617,6672],"content":"The 10<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to the auto-parallelizer.","source":"The 10*xx* reason codes apply to the auto-parallelizer."},{"content":"Reason Code","pos":[6679,6690]},{"content":"Explanation","pos":[6691,6702]},{"content":"1000","pos":[6747,6751]},{"content":"The compiler detected a data dependency in the loop body.","pos":[6752,6809]},{"content":"1001","pos":[6814,6818]},{"content":"The compiler detected a store to a scalar variable in the loop body, and that scalar has a use beyond the loop.","pos":[6819,6930]},{"content":"1002","pos":[6935,6939]},{"content":"The compiler tried to parallelize a loop that has an inner loop that was already parallelized.","pos":[6940,7034]},{"content":"1003","pos":[7039,7043]},{"content":"The loop body contains an intrinsic call that may read or write to memory.","pos":[7044,7118]},{"content":"1004","pos":[7123,7127]},{"content":"There is a scalar reduction in the loop body.","pos":[7128,7173]},{"content":"Scalar reduction can occur if the loop has been vectorized.","pos":[7174,7233]},{"content":"1005","pos":[7238,7242]},{"pos":[7243,7284],"content":"The <bpt id=\"p1\">**</bpt>no_parallel<ept id=\"p1\">**</ept> pragma was specified.","source":"The **no_parallel** pragma was specified."},{"content":"1006","pos":[7289,7293]},{"content":"This function contains <bpt id=\"p1\">**</bpt>openmp<ept id=\"p1\">**</ept>.","pos":[7294,7328],"source":"This function contains **openmp**."},{"content":"Resolve this by removing any <bpt id=\"p1\">**</bpt>openmp<ept id=\"p1\">**</ept> in this function.","pos":[7329,7386],"source":" Resolve this by removing any **openmp** in this function."},{"content":"1007","pos":[7391,7395]},{"content":"The loop induction variable or the loop bounds are not signed 32-bit numbers (<ph id=\"ph1\">`int`</ph> or <ph id=\"ph2\">`long`</ph>).","pos":[7396,7491],"source":"The loop induction variable or the loop bounds are not signed 32-bit numbers (`int` or `long`)."},{"content":"Resolve this by changing the type of the induction variable.","pos":[7492,7552]},{"content":"1008","pos":[7557,7561]},{"content":"The compiler detected that this loop does not perform enough work to warrant auto-parallelization.","pos":[7562,7660]},{"content":"1009","pos":[7665,7669]},{"content":"The compiler detected an attempt to parallelize a \"do-while\" loop.","pos":[7670,7736]},{"content":"The auto-parallelizer only targets <ph id=\"ph1\">`for`</ph> loops.","pos":[7737,7784],"source":" The auto-parallelizer only targets `for` loops."},{"content":"1010","pos":[7789,7793]},{"content":"The compiler detected that the loop is using \"not-equals\" (!=) for its condition.","pos":[7794,7875]},{"pos":[12826,12865],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode110x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 11xx","linkify":"<a name=\"BKMK_ReasonCode110x\"></a> 11xx","source":"<a name=\"BKMK_ReasonCode110x\"></a> 11xx"},{"pos":[12869,12922],"content":"The 11<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to the auto-vectorizer.","source":"The 11*xx* reason codes apply to the auto-vectorizer."},{"content":"Reason Code","pos":[12929,12940]},{"content":"Explanation","pos":[12941,12952]},{"content":"1100","pos":[12997,13001]},{"content":"Loop contains control flow—for example, \"if\" or \"?\".","pos":[13002,13054]},{"content":"1101","pos":[13059,13063]},{"content":"Loop contains datatype conversion—perhaps implicit—that cannot be vectorized.","pos":[13064,13141]},{"content":"1102","pos":[13146,13150]},{"content":"Loop contains non-arithmetic or other non-vectorizable operations.","pos":[13151,13217]},{"content":"1103","pos":[13222,13226]},{"content":"Loop body includes shift operations whose size might vary within the loop.","pos":[13227,13301]},{"content":"1104","pos":[13306,13310]},{"content":"Loop body includes scalar variables.","pos":[13311,13347]},{"content":"1105","pos":[13352,13356]},{"content":"Loop includes a unrecognized reduction operation.","pos":[13357,13406]},{"content":"1106","pos":[13411,13415]},{"content":"Outer loop not vectorized.","pos":[13416,13442]},{"pos":[17371,17410],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode120x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 12xx","linkify":"<a name=\"BKMK_ReasonCode120x\"></a> 12xx","source":"<a name=\"BKMK_ReasonCode120x\"></a> 12xx"},{"pos":[17414,17467],"content":"The 12<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to the auto-vectorizer.","source":"The 12*xx* reason codes apply to the auto-vectorizer."},{"content":"Reason Code","pos":[17474,17485]},{"content":"Explanation","pos":[17486,17497]},{"content":"1200","pos":[17542,17546]},{"content":"Loop contains loop-carried data dependences that prevent vectorization.","pos":[17547,17618]},{"content":"Different iterations of the loop interfere with each other such that vectorizing the loop would produce wrong answers, and the auto-vectorizer cannot prove to itself that there are no such data dependences.","pos":[17619,17825]},{"content":"1201","pos":[17830,17834]},{"content":"Array base changes during the loop.","pos":[17835,17870]},{"content":"1202","pos":[17875,17879]},{"content":"Field in a struct is not 32 or 64 bits wide.","pos":[17880,17924]},{"content":"1203","pos":[17929,17933]},{"content":"Loop body includes non-contiguous accesses into an array.","pos":[17934,17991]},{"pos":[19789,19828],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode130x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 13xx","linkify":"<a name=\"BKMK_ReasonCode130x\"></a> 13xx","source":"<a name=\"BKMK_ReasonCode130x\"></a> 13xx"},{"pos":[19832,19885],"content":"The 13<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to the auto-vectorizer.","source":"The 13*xx* reason codes apply to the auto-vectorizer."},{"content":"Reason Code","pos":[19892,19903]},{"content":"Explanation","pos":[19904,19915]},{"content":"1300","pos":[19960,19964]},{"content":"Loop body contains no—or very little—computation.","pos":[19965,20014]},{"content":"1301","pos":[20019,20023]},{"content":"Loop stride is not +1.","pos":[20024,20046]},{"content":"1302","pos":[20051,20055]},{"content":"Loop is a “do-while”.","pos":[20056,20077]},{"content":"1303","pos":[20082,20086]},{"content":"Too few loop iterations for vectorization to provide value.","pos":[20087,20146]},{"content":"1304","pos":[20151,20155]},{"content":"Loop includes assignments that are of different sizes.","pos":[20156,20210]},{"content":"1305","pos":[20215,20219]},{"content":"Not enough type information.","pos":[20220,20248]},{"pos":[23188,23227],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode140x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 14xx","linkify":"<a name=\"BKMK_ReasonCode140x\"></a> 14xx","source":"<a name=\"BKMK_ReasonCode140x\"></a> 14xx"},{"pos":[23231,23336],"content":"The 14<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes occur when some option that is incompatible with auto-vectorization is specified.","source":"The 14*xx* reason codes occur when some option that is incompatible with auto-vectorization is specified."},{"content":"Reason Code","pos":[23343,23354]},{"content":"Explanation","pos":[23355,23366]},{"content":"1400","pos":[23411,23415]},{"pos":[23416,23457],"content":"<bpt id=\"p1\">**</bpt>#pragma loop(no_vector)<ept id=\"p1\">**</ept> is specified.","source":"**#pragma loop(no_vector)** is specified."},{"content":"1401","pos":[23462,23466]},{"pos":[23467,23525],"content":"<bpt id=\"p1\">**</bpt>/kernel<ept id=\"p1\">**</ept> switch is specified when targeting x86 or ARM.","source":"**/kernel** switch is specified when targeting x86 or ARM."},{"content":"1402","pos":[23530,23534]},{"pos":[23535,23603],"content":"<bpt id=\"p1\">**</bpt>/arch:SSE2<ept id=\"p1\">**</ept> or higher switch is not specified when targeting x86.","source":"**/arch:SSE2** or higher switch is not specified when targeting x86."},{"content":"1403","pos":[23608,23612]},{"pos":[23613,23692],"content":"<bpt id=\"p1\">**</bpt>/arch:ATOM<ept id=\"p1\">**</ept> switch is specified and the loop includes operations on doubles.","source":"**/arch:ATOM** switch is specified and the loop includes operations on doubles."},{"content":"1404","pos":[23697,23701]},{"pos":[23702,23741],"content":"<bpt id=\"p1\">**</bpt>/O1<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/Os<ept id=\"p2\">**</ept> switch is specified.","source":"**/O1** or **/Os** switch is specified."},{"content":"1405","pos":[23746,23750]},{"content":"Vectorization is disabled to aid in dynamic-initializer-to-static-initializer optimization.","pos":[23751,23842]},{"pos":[24966,25005],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_ReasonCode150x\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> 15xx","linkify":"<a name=\"BKMK_ReasonCode150x\"></a> 15xx","source":"<a name=\"BKMK_ReasonCode150x\"></a> 15xx"},{"content":"The block of 15<bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> reason codes apply to aliasing.","pos":[25009,25060],"source":"The block of 15*xx* reason codes apply to aliasing."},{"content":"Aliasing occurs when a location in memory can be accessed by two different names.","pos":[25061,25142]},{"content":"Reason Code","pos":[25149,25160]},{"content":"Explanation","pos":[25161,25172]},{"content":"1500","pos":[25217,25221]},{"content":"Possible aliasing on multi-dimensional arrays.","pos":[25222,25268]},{"content":"1501","pos":[25273,25277]},{"content":"Possible aliasing on arrays-of-structs.","pos":[25278,25317]},{"content":"1502","pos":[25322,25326]},{"content":"Possible aliasing and array index is other than n + K.","pos":[25327,25381]},{"content":"1503","pos":[25386,25390]},{"content":"Possible aliasing and array index has multiple offsets.","pos":[25391,25446]},{"content":"1504","pos":[25451,25455]},{"content":"Possible aliasing; would require too many runtime checks.","pos":[25456,25513]},{"content":"1505","pos":[25518,25522]},{"content":"Possible aliasing, but runtime checks are too complex.","pos":[25523,25577]},{"pos":[28477,28485],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Auto-Parallelization and Auto-Vectorization<ept id=\"p1\">](../../parallel/auto-parallelization-and-auto-vectorization.md)</ept><ph id=\"ph1\"> </ph>","pos":[28489,28598],"source":"[Auto-Parallelization and Auto-Vectorization](../../parallel/auto-parallelization-and-auto-vectorization.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Parallel Programming in Native Code<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=263662)</ept><ph id=\"ph1\"> </ph>","pos":[28601,28687],"source":" [Parallel Programming in Native Code](http://go.microsoft.com/fwlink/?LinkId=263662) "},{"content":"<bpt id=\"p1\"> [</bpt>#pragma loop()<ept id=\"p1\">](../../preprocessor/loop.md)</ept><ph id=\"ph1\"> </ph>","pos":[28690,28736],"source":" [#pragma loop()](../../preprocessor/loop.md) "},{"content":"<bpt id=\"p1\"> [</bpt>/Q Options (Low-Level Operations)<ept id=\"p1\">](../../build/reference/q-options-low-level-operations.md)</ept><ph id=\"ph1\"> </ph>","pos":[28739,28833],"source":" [/Q Options (Low-Level Operations)](../../build/reference/q-options-low-level-operations.md) "},{"content":"<bpt id=\"p1\"> [</bpt>/Qpar-report (Auto-Parallelizer Reporting Level)<ept id=\"p1\">](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md)</ept><ph id=\"ph1\"> </ph>","pos":[28836,28960],"source":" [/Qpar-report (Auto-Parallelizer Reporting Level)](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md) "},{"content":"<bpt id=\"p1\"> [</bpt>/Qvec-report (Auto-Vectorizer Reporting Level)<ept id=\"p1\">](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md)</ept>","pos":[28963,29082],"source":" [/Qvec-report (Auto-Vectorizer Reporting Level)](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md)"}],"content":"---\ntitle: \"Vectorizer and Parallelizer Messages | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C5011\"\n  - \"C5002\"\n  - \"C5021\"\n  - \"C5001\"\n  - \"C5012\"\ndev_langs: \n  - \"C++\"\nms.assetid: d8f4844a-f414-42ab-b9a5-925a5da9d365\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Vectorizer and Parallelizer Messages\nYou can use the Visual C++ compiler options [/Qpar-report](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md) and [/Qvec-report](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md) to set the [Auto-Parallelization and Auto-Vectorization](../../parallel/auto-parallelization-and-auto-vectorization.md) to output reason codes and informational messages about its activity. This article explains the reason codes and the messages.  \n  \n-   [Informational Messages](#BKMK_InformationalMessages)  \n  \n-   [5xx](#BKMK_ReasonCode50x)  \n  \n-   [10xx](#BKMK_ReasonCode100x)  \n  \n-   [11xx](#BKMK_ReasonCode110x)  \n  \n-   [12xx](#BKMK_ReasonCode120x)  \n  \n-   [13xx](#BKMK_ReasonCode130x)  \n  \n-   [14xx](#BKMK_ReasonCode140x)  \n  \n-   [15xx](#BKMK_ReasonCode150x)  \n  \n##  <a name=\"BKMK_InformationalMessages\"></a> Informational Messages  \n Depending on the reporting level that you specify, one of the following informational messages appears for each loop.  \n  \n For information about reason codes, refer to the next part of this article.  \n  \n|Informational Message|Description|  \n|---------------------------|-----------------|  \n|5001|Loop vectorized.|  \n|5002|Loop not vectorized due to reason 'description'.|  \n|5011|Loop parallelized.|  \n|5012|Loop not parallelized due to reason 'description'.|  \n|5021|Unable to associate loop with pragma.|  \n  \n## Reason Codes  \n The following sections list possible reason codes for the auto-parallelizer and auto-vectorizer.  \n  \n###  <a name=\"BKMK_ReasonCode50x\"></a> 5xx  \n The 5*xx* reason codes apply to both the auto-parallelizer and the auto-vectorizer.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|500|This is a generic message that covers several cases—for example, the loop includes multiple exits, or the loop header does not end by incrementing the induction variable.|  \n|501|Induction variable is not local; or upper bound is not loop-invariant.|  \n|502|Induction variable is stepped in some manner other than a simple +1.|  \n|503|Loop includes exception-handling or switch statements.|  \n|504|Loop body may throw an exception that requires destruction of a C++ object.|  \n  \n```cpp  \nvoid code_500(int *A)  \n{  \n    // Code 500 is emitted if the loop has non-vectorizable flow.  \n    // This can include \"if\", \"break\", \"continue\", the conditional   \n    // operator \"?\", or function calls.  \n    // It also encompasses correct definition and use of the induction  \n    // variable \"i\", in that the increment \"++i\" or \"i++\" must be the last  \n    // statement in the loop.  \n  \n    int i = 0;  \n    while (i<1000)  \n    {  \n        if (i == 4)   \n        {  \n            break;  \n        }  \n  \n        ++i;  \n  \n        A[i] = A[i] + 1;  \n    }  \n    // To resolve code 500, use a 'for' loop with single increment of   \n    // induction variable.  \n  \n    for (int i=0; i<1000; ++i)  \n    {         \n        A[i] = A[i] + 1;  \n    }      \n}  \n  \nint bound();  \nvoid code_501_example1(int *A)  \n{  \n    // Code 501 is emitted if the compiler cannot discern the  \n    // induction variable of this loop. In this case, when it checks  \n    // the upperbound of 'i', the compiler cannot prove that the   \n    // function call \"bound()\" returns the same value each time.  \n    // Also, the compiler cannot prove that the call to \"bound()\"  \n    // does not modify the values of array A.  \n  \n    for (int i=0; i<bound(); ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n  \n    // To resolve code 501, ensure that the induction variable is   \n    // a local variable, and ensure that the upperbound is a  \n    // provably loop invariant value.  \n  \n    for (int i=0, imax = bound(); i<imax; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nint i;  \nvoid code_501_example2(int *A)  \n{  \n    // Code 501 is emitted if the compiler cannot discern the  \n    // induction variable of this loop. In this case, 'i' is  \n    // a global.  \n  \n    for (i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n  \n    // To resolve code 501, ensure that the induction variable is   \n    // a local variable, and ensure that the upperbound is a  \n    // provably loop invariant value.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_502(int *A)  \n{  \n    // Code 502 is emitted if the compiler cannot discern  \n    // the induction variable of the loop. In this case,  \n    // there are three increments to \"i\", one of which  \n    // is conditional.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n        ++i;  \n  \n        if (i < 100)   \n        {  \n            ++i;  \n        }  \n    }  \n  \n    // To resolve code 502, ensure that there is just one   \n    // increment of the induction variable, placed in the usual  \n    // spot in the \"for\" loop.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_503(int *A, int x)  \n{  \n    // Code 503 is emitted if there are inadmissible  \n    // operations in the loop - for example, exception handling and  \n    // switch statements.  \n  \n    for (int i = 0; i<1000; ++i)  \n    {  \n        switch (x)  \n        {  \n        case 1: A[i] = A[i] + 1;  \n        case 2: A[i] = A[i] + 2;  \n        case 3: A[i] = A[i] + 3;  \n            break;  \n        }  \n    }  \n  \n    // To resolve code 503, try to remove as many switch statements  \n    // and exception handling constructs as possible.  \n}  \n  \n// compile with /EHsc  \n  \nint code_504_helper();  \nclass C504  \n{  \npublic:  \n    C504();  \n    ~C504();  \n};  \n  \nvoid code_504(int *A) {  \n    // Code 504 is emitted if a C++ object was created and  \n    // that object requires EH unwind tracking information under  \n    // /EHs or /EHsc.  \n  \n    for(int i = 0; i < 1000; ++i)  \n    {  \n        C504 c;  \n        A[i] = code_504_helper();  \n    }  \n  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode100x\"></a> 10xx  \n The 10*xx* reason codes apply to the auto-parallelizer.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1000|The compiler detected a data dependency in the loop body.|  \n|1001|The compiler detected a store to a scalar variable in the loop body, and that scalar has a use beyond the loop.|  \n|1002|The compiler tried to parallelize a loop that has an inner loop that was already parallelized.|  \n|1003|The loop body contains an intrinsic call that may read or write to memory.|  \n|1004|There is a scalar reduction in the loop body. Scalar reduction can occur if the loop has been vectorized.|  \n|1005|The **no_parallel** pragma was specified.|  \n|1006|This function contains **openmp**. Resolve this by removing any **openmp** in this function.|  \n|1007|The loop induction variable or the loop bounds are not signed 32-bit numbers (`int` or `long`). Resolve this by changing the type of the induction variable.|  \n|1008|The compiler detected that this loop does not perform enough work to warrant auto-parallelization.|  \n|1009|The compiler detected an attempt to parallelize a \"do-while\" loop. The auto-parallelizer only targets `for` loops.|  \n|1010|The compiler detected that the loop is using \"not-equals\" (!=) for its condition.|  \n  \n```cpp  \nint A[1000];  \nvoid func();  \nvoid code_1000()  \n{  \n    // Code 1000 is emitted if the compiler detects a   \n    // data dependence in the loop body.   \n  \n    // You can resolve this by using the ivdep pragma.  \n    // CAUTION -- the compiler will trust your  \n    // assertion that there are no data dependencies  \n    // in the loop body. If there are, you are generating  \n    // code that may have race conditions.  \n  \n#pragma loop(hint_parallel(0))  \n    //#pragma loop(ivdep) // ivdep will force this through.  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i-1] + 1;  // data dependence here  \n        func();             // data dependence here  \n    }  \n}  \n  \nint code_1001()  \n{  \n    // Code 1001 is emitted if the compiler detects  \n    // a store to a scalar variable in the loop  \n    // body, and that scalar has a use beyond the loop.  \n  \n    // Resolve this by rewriting your code so  \n    // that the scalar is not needed.  \n  \n    int s = 0;  \n#pragma loop(hint_parallel(0))  \n    for (int i=0; i<1000; ++i)  \n    {  \n        s = A[i];  \n    }  \n    return s;  \n}  \n  \nvoid code_1002()  \n{  \n    // Code 1002 is emitted when the compiler tries to  \n    // parallelize a loop that has an inner loop that  \n    // has already been parallelized.  \n  \n#pragma loop(hint_parallel(0))  \n    for (int i=0; i<1000; ++i) // emit code 1002 for this loop  \n    {  \n#pragma loop(hint_parallel(0))  \n        for (int j=0; j<1000; ++j) // this loop gets parallelized  \n        {  \n            A[j] = A[j] + 1;  \n        }  \n    }  \n}  \n  \nextern \"C\" void __stosb(unsigned char*, unsigned char, size_t);  \nvoid code_1003(unsigned char *dst)  \n{  \n    // Code 1003 is emitted when the loop body contains an intrinsic  \n    // call that may read or write to memory.  \n  \n    // This can be resolved by using the ivdep pragma.  \n    // CAUTION -- the compiler will trust your  \n    // assertion that there are no data dependencies  \n    // in the loop body. If there are, you are generating  \n    // code that may have race conditions.  \n  \n#pragma loop(hint_parallel(0))  \n    //#pragma loop(ivdep) // ivdep will force this through.  \n    for (int i=0; i<1000; ++i)  \n    {  \n        __stosb(dst, 'c', 10);  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nint code_1004()  \n{  \n    // Code 1004 is emitted when there is a scalar reduction  \n    // in the loop body, which can occur if the loop has been  \n    // vectorized.  \n  \n    // You can resolve this by rewriting your code so that it  \n    // does not have a scalar reduction.  \n  \n    int s = 0;  \n#pragma loop(hint_parallel(0))  \n    for (int i=0; i<1000; ++i)  \n    {  \n        s += A[i];  \n    }  \n    return s;  \n}  \n  \nvoid code_1005()  \n{  \n    // Code 1005 is emitted when the   \n    // no_parallel pragma is specified.  \n  \n#pragma loop(no_parallel)  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n#include <omp.h>  \n  \n// Compile with /openmp  \nvoid code_1006()  \n{  \n    // Code 1006 is emitted when this function contains  \n    // openmp. Resolve this by removing any openmp in this  \n    // function.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n  \n#pragma omp parallel num_threads(4)  \n    {  \n        int i = omp_get_thread_num();  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_1007()  \n{  \n    // Code 1007 is emitted when the loop induction variable  \n    // or the loop bounds are not signed 32-bit numbers (int   \n    // or long). Resolve this by changing the type of the   \n    // induction variable.  \n  \n#pragma loop(hint_parallel(0))  \n    for (unsigned int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_1008()  \n{  \n    // Code 1008 is emitted when the compiler detects that  \n    // this loop does not perform enough work to warrant   \n    // auto-parallelization.  \n  \n    // You can resolve this by specifying the hint_parallel  \n    // pragma. CAUTION -- if the loop does not perform  \n    // enough work, parallelizing might cause a potentially   \n    // large performance penalty.  \n  \n    // #pragma loop(hint_parallel(0)) //  hint_parallel will force this through  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_1009()  \n{  \n    // Code 1009 is emitted when the compiler tries to parallelize a   \n    // \"do-while\" loop. The auto-parallelizer only targets \"for\" loops.  \n  \n    int i = 0;  \n#pragma loop(hint_parallel(0))  \n    do  \n    {  \n        A[i] = A[i] + 1;  \n    }   \n    while (++i < 1000);  \n}  \n  \nvoid code_1010()  \n{  \n    // Code 1010 is emitted when the compiler tries to parallelize a  \n    // loop with a condition code of \"!=\".  \n  \n    // You can resolve this by replacing it with an ordering comparator  \n    // like \"<\".  \n#pragma loop(hint_parallel(0))  \n    for (int i = 0; i != 1000; ++i)  \n    {  \n        A[i]++;  \n    }  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode110x\"></a> 11xx  \n The 11*xx* reason codes apply to the auto-vectorizer.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1100|Loop contains control flow—for example, \"if\" or \"?\".|  \n|1101|Loop contains datatype conversion—perhaps implicit—that cannot be vectorized.|  \n|1102|Loop contains non-arithmetic or other non-vectorizable operations.|  \n|1103|Loop body includes shift operations whose size might vary within the loop.|  \n|1104|Loop body includes scalar variables.|  \n|1105|Loop includes a unrecognized reduction operation.|  \n|1106|Outer loop not vectorized.|  \n  \n```cpp  \nvoid code_1100(int *A, int x)   \n{  \n    // Code 1100 is emitted when the compiler detects control flow  \n    // in the loop - for example, \"if\", the ternary operator \"?\", and  \n    // the like. Resolve this by flattening or removing control  \n    // flow in the loop body.  \n  \n    // Not all control flow causes 1100; some is indeed    \n    // vectorized.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        // straightline code is more amenable to vectorization  \n        if (x)  \n        {  \n            A[i] = A[i] + 1;  \n        }  \n    }  \n}  \n  \nextern \"C\" int __readcr0();  \nvoid code_1102(int *A)  \n{  \n    // Code 1102 is emitted when the compiler is unable to vectorize  \n    // an operation in the loop body. For example, intrinsics and other  \n    // non-arithmetic, non-logical, and non-memory operations are not  \n    // vectorizable.  \n  \n    // Resolve this by removing as many non-vectorizable operations  \n    // as possible from the loop body.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = __readcr0();  \n    }  \n}  \n  \nvoid code_1103(int *A, int *B)  \n{  \n    // Code 1103 is emitted when the compiler is unable to vectorize  \n    // a \"shift\" operation. In this example, there are two shifts  \n    // that cannot be vectorized.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] >> B[i]; // not vectorizable  \n  \n        int x = B[i];  \n        A[i] = A[i] >> x; // not vectorizable  \n    }  \n  \n    // To resolve this, ensure that your shift amounts are loop   \n    // invariant. If the shift amounts cannot be loop invariant,  \n    // it may not be possible to vectorize this loop.  \n  \n    int x = B[0];  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] >> x; // vectorizable  \n    }  \n}  \n  \nint code_1104(int *A, int *B)  \n{  \n    // When it vectorizes a loop, the compiler must 'expand' scalar  \n    // variables to a vector size such that they can fit in  \n    // vector registers. Code 1104 is emitted when the compiler  \n    // cannot 'expand' such scalars.  \n  \n    // In this example, we try to 'expand' x to be used in the   \n    // vectorized loop. However, there is a use of 'x'   \n    // beyond the loop body, which prohibits this expansion.  \n  \n    // To resolve this, try to limit scalars to be used only in  \n    // the loop body and not beyond, and try to keep their types  \n    // consistent with the loop types.  \n  \n    int x;  \n    for (int i=0; i<1000; ++i)  \n    {  \n        x = B[i];  \n        A[i] = A[i] + x;  \n    }  \n  \n    return x;  \n}  \n  \nint code_1105(int *A)  \n{  \n    // The compiler performs an optimization that's known as \"reduction\"  \n    // when it operates on each element of an array and computes  \n    // a resulting scalar value - for example, in this piece of code, which  \n    // computes the sum of each element in the array:  \n  \n    int s = 0;  \n    for (int i=0; i<1000; ++i)  \n    {  \n        s += A[i]; // vectorizable  \n    }  \n  \n    // The reduction pattern must resemble the loop in the example. The  \n    // compiler emits code 1105 if it cannot deduce the reduction  \n    // pattern, as shown in this example:  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        s += A[i] + s;  // code 1105  \n    }  \n  \n    // Similarly, reductions of \"float\" or \"double\" types require  \n    // that the /fp:fast switch is thrown. Strictly speaking,  \n    // the reduction optimization that the compiler performs uses  \n    // \"floating point reassociation\". Reassociation is only  \n    // allowed when /fp:fast is thrown.  \n  \n    return s;      \n}  \n  \nvoid code_1106(int *A)  \n{  \n    // Code 1106 is emitted when the compiler tries to vectorize  \n    // an outer loop.  \n  \n    for (int i=0; i<1000; ++i) // this loop is not vectorized  \n    {  \n        for (int j=0; j<1000; ++j) // this loop is vectorized  \n        {  \n            A[j] = A[j] + 1;  \n        }  \n    }  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode120x\"></a> 12xx  \n The 12*xx* reason codes apply to the auto-vectorizer.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1200|Loop contains loop-carried data dependences that prevent vectorization. Different iterations of the loop interfere with each other such that vectorizing the loop would produce wrong answers, and the auto-vectorizer cannot prove to itself that there are no such data dependences.|  \n|1201|Array base changes during the loop.|  \n|1202|Field in a struct is not 32 or 64 bits wide.|  \n|1203|Loop body includes non-contiguous accesses into an array.|  \n  \n```cpp  \nvoid fn();  \nvoid code_1200(int *A)  \n{  \n    // Code 1200 is emitted when data dependence is prohibiting  \n    // vectorization. This can only be resolved by rewriting the  \n    // loop, and considering the marking of loop function calls as   \n    // __forceinline.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i-1] + 1; // vectorization-prohibiting  \n        fn();               // vectorization-prohibiting  \n    }  \n}  \n  \nvoid code_1201(int *A)  \n{  \n    // Code 1201 is emitted when an array base changes  \n    // in the loop body. Resolve this by rewriting your  \n    // code so that varying the array base is not necessary.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n        A++;  \n    }  \n}  \n  \nstruct S_1202  \n{  \n    short a;  \n    short b;  \n} s[1000];  \n  \nshort sA[1000], sB[1000], sC[1000];  \n  \nvoid code_1202(S_1202 *s)  \n{  \n    // Code 1202 is emitted when non-vectorizable struct accesses  \n    // are present in the loop body. Only struct accesses   \n    // that are 32 or 64 bits are vectorized.  \n  \n    for (int i=0; i<1000; ++i)  \n    {          \n        s[i].a = s[i].b + 1; // this 16 bit struct access is not vectorizable  \n        sA[i] += sB[i] * sC[i]; // this ensures we don't emit reason code '1300'  \n    }  \n}  \n  \nvoid code_1203(int *A)  \n{  \n    // Code 1203 is emitted when non-vectorizable memory references  \n    // are present in the loop body. Vectorization of some non-contiguous   \n    // memory access is supported - for example, the gather/scatter pattern.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] += A[0] + 1;       // constant memory access not vectorized  \n        A[i] += A[i*2+2] + 2;  // non-contiguous memory access not vectorized  \n    }  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode130x\"></a> 13xx  \n The 13*xx* reason codes apply to the auto-vectorizer.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1300|Loop body contains no—or very little—computation.|  \n|1301|Loop stride is not +1.|  \n|1302|Loop is a “do-while”.|  \n|1303|Too few loop iterations for vectorization to provide value.|  \n|1304|Loop includes assignments that are of different sizes.|  \n|1305|Not enough type information.|  \n  \n```cpp  \nvoid code_1300(int *A, int *B)  \n{  \n    // Code 1300 is emitted when the compiler detects that there is  \n    // no computation in the loop body.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = B[i]; // Do not vectorize, instead emit memcpy  \n    }  \n}  \n  \nvoid code_1301(int *A)  \n{  \n    // Code 1301 is emitted when the stride of a loop is not positive 1.  \n    // Only loops that have a stride of positive 1 are vectorized;  \n    // rewriting your loop may be required.  \n  \n    for (int i=0; i<1000; i += 2)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \nvoid code_1302(int *A)  \n{  \n    // Code 1302 is emitted for \"do-while\" loops. Only \"while\"    \n    // and \"for\" loops are vectorized.  \n  \n    int i = 0;  \n    do  \n    {  \n        A[i] = A[i] + 1;  \n    } while (++i < 1000);  \n}  \n  \nint code_1303(int *A, int *B)  \n{  \n    // Code 1303 is emitted when the compiler detects that  \n    // the number of iterations of the loop is too small to  \n    // make vectorization profitable.  \n  \n    // If the loop computation fits perfectly in   \n    // vector registers - for example, the upperbound is 4, or 8 in   \n    // this case - then the loop _may_ be vectorized.  \n  \n    // This loop is not vectorized because there are 5 iterations  \n  \n    for (int i=0; i<5; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n  \n    // This loop is vectorized  \n  \n    for (int i=0; i<4; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n  \n    // This loop is not vectorized because runtime pointer checks  \n    // are required to check that A and B don't overlap. It is not  \n    // worth it to vectorize this loop.  \n  \n    for (int i=0; i<4; ++i)  \n    {  \n        A[i] = B[i] + 1;  \n    }  \n  \n    // This loop is not vectorized because of the scalar reduction.  \n  \n    int s = 0;  \n    for (int i=0; i<4; ++i)  \n    {  \n        s += A[i];  \n    }  \n    return s;  \n}  \n  \nvoid code_1304(int *A, short *B)  \n{  \n    // Code 1304 is emitted when the compiler detects  \n    // different sized statements in the loop body.  \n    // In this case, there is an 32-bit statement and a  \n    // 16-bit statement.  \n  \n    // In cases like this consider splitting the loop into loops to   \n    // maximize vector register utilization.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n        B[i] = B[i] + 1;  \n    }  \n}  \n  \ntypedef struct S_1305  \n{  \n    int a;  \n    int b;  \n} S_1305;  \n  \nvoid code_1305( S_1305 *s, S_1305 x)  \n{  \n    // Code 1305 is emitted when the compiler can't discern  \n    // proper vectorizable type information for this loop.  \n    // This includes non-scalar loop types such as struct   \n    // assignments, as in this example.  \n  \n    // Resolve this by ensuring that your loops have statements  \n    // that operate on integers or floating point types.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        s[i] = x;  \n    }  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode140x\"></a> 14xx  \n The 14*xx* reason codes occur when some option that is incompatible with auto-vectorization is specified.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1400|**#pragma loop(no_vector)** is specified.|  \n|1401|**/kernel** switch is specified when targeting x86 or ARM.|  \n|1402|**/arch:SSE2** or higher switch is not specified when targeting x86.|  \n|1403|**/arch:ATOM** switch is specified and the loop includes operations on doubles.|  \n|1404|**/O1** or **/Os** switch is specified.|  \n|1405|Vectorization is disabled to aid in dynamic-initializer-to-static-initializer optimization.|  \n  \n```cpp  \nvoid code_1400(int *A)  \n{  \n    // Code 1400 is emitted when the no_vector pragma   \n    // is specified.   \n  \n#pragma loop(no_vector)  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n// Compile with /kernel  \nvoid code_1401(int *A)  \n{  \n    // Code 1401 is emitted when /kernel is specified.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n// Compile with /arch:IA32  \nvoid code_1402(int *A)  \n{  \n    // Code 1401 is emitted when /arch:IA32 is specified.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n// Compile with /favor:ATOM  \nvoid code_1403(double *A)  \n{  \n    // Code 1401 is emitted when /favor:ATOM is specified, and  \n    // the loop contains operations on \"double\" arrays.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n// Compile with /O1 or /Os  \nvoid code_1404(int *A)  \n{  \n    // Code 1401 is emitted when compiling for size.  \n  \n    for (int i=0; i<1000; ++i)  \n    {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n```  \n  \n###  <a name=\"BKMK_ReasonCode150x\"></a> 15xx  \n The block of 15*xx* reason codes apply to aliasing. Aliasing occurs when a location in memory can be accessed by two different names.  \n  \n|Reason Code|Explanation|  \n|-----------------|-----------------|  \n|1500|Possible aliasing on multi-dimensional arrays.|  \n|1501|Possible aliasing on arrays-of-structs.|  \n|1502|Possible aliasing and array index is other than n + K.|  \n|1503|Possible aliasing and array index has multiple offsets.|  \n|1504|Possible aliasing; would require too many runtime checks.|  \n|1505|Possible aliasing, but runtime checks are too complex.|  \n  \n```cpp  \nvoid code_1500(int A[100][100], int B[100][100])  \n{  \n    // Code 1500 is emitted when runtime pointer  \n    // disambiguation checks are required, and   \n    // there are multidimensional array references.  \n  \n    for (int i=0; i<100; ++i)  \n    {  \n        for (int j=0; j<100; ++j)  \n        {  \n            A[i][j] = B[i][j] + 1;  \n        }  \n    }  \n}  \n  \ntypedef struct S_1501  \n{  \n    int a;  \n    int b;  \n} S_1501;  \n  \nint iA[1000], iB[1000], iC[1000];  \n  \nvoid code_1501(S_1501 *s1, S_1501 *s2)  \n{  \n    // Code 1501 is emitted when runtime pointer  \n    // disambiguation checks are required, and   \n    // there are array-of-struct accesses in the   \n    // loop body.  \n  \n    for (int i=0; i<100; ++i)  \n    {  \n        s1[i].a = s2[i].b + 1;  \n        iA[i] += iB[i] * iC[i]; // this is to ensure we don't emit reason code '1300'  \n    }  \n}  \n  \nvoid code_1502(int *A, int *B)  \n{  \n    // Code 1502 is emitted when runtime pointer  \n    // disambiguation checks are required, and   \n    // an array reference has an offset that varies   \n    // in the loop.  \n  \n    int x = 0;  \n    for (int i=0; i<100; ++i)  \n    {  \n        A[i] = B[i + x] + 1;  \n        ++x;                   // 'x' varies in the loop  \n    }  \n}  \n  \nvoid code_1503(int *A, int *B, int x, int y)  \n{  \n    // Code 1503 is emitted when runtime pointer  \n    // disambiguation checks are required, and   \n    // an array reference has multiple offsets.  \n  \n    for (int i=0; i<100; ++i)  \n    {  \n        A[i] = B[i+x] + B[i+y] + 1;   // multiple offsets when addressing 'B': {x, y}  \n        A[i] = B[i+x] + B[i] + 1;     // multiple offsets when addressing 'B': {x, 0}  \n        A[i] = B[i+x] + B[i+x] + 1;   // this is vectorized  \n    }  \n}  \n  \nvoid code_1504(int *A1, int *A2, int *A3, int *A4,   \n               int *A5, int *A6, int *A7, int *A8,  \n               int *A9, int *A10, int *A11, int *A12,  \n               int *A13, int *A14, int *A15, int *A16)  \n{  \n    // Code 1504 is emitted when too many runtime   \n    // pointer disambiguation checks are required.  \n  \n    for (int i=0; i<100; ++i)  \n    {  \n        ++A1[i];  \n        ++A2[i];  \n        ++A3[i];  \n        ++A4[i];  \n        ++A5[i];  \n        ++A6[i];  \n        ++A7[i];  \n        ++A8[i];  \n        ++A9[i];  \n        ++A10[i];  \n        ++A11[i];  \n        ++A12[i];  \n        ++A13[i];  \n        ++A14[i];  \n        ++A15[i];  \n        ++A16[i];  \n    }  \n}  \n  \nvoid code_1505(int *A, int *B)  \n{  \n    // Code 1505 is emitted when runtime pointer   \n    // disambiguation checks are required, but are  \n    // too complex for the compiler to discern.  \n  \n    for (int i=0; i<100; ++i)  \n    {  \n        for (int j=0; j<100; ++j)  \n        {  \n            for (int k=0; k<100; ++k)  \n            {  \n                A[i+j-k] = B[i-j+k] * 2;  \n            }  \n        }  \n    }  \n}  \n  \n```  \n  \n## See Also  \n [Auto-Parallelization and Auto-Vectorization](../../parallel/auto-parallelization-and-auto-vectorization.md)   \n [Parallel Programming in Native Code](http://go.microsoft.com/fwlink/?LinkId=263662)   \n [#pragma loop()](../../preprocessor/loop.md)   \n [/Q Options (Low-Level Operations)](../../build/reference/q-options-low-level-operations.md)   \n [/Qpar-report (Auto-Parallelizer Reporting Level)](../../build/reference/qpar-report-auto-parallelizer-reporting-level.md)   \n [/Qvec-report (Auto-Vectorizer Reporting Level)](../../build/reference/qvec-report-auto-vectorizer-reporting-level.md)"}