{"nodes":[{"pos":[12,86],"content":"Using Lambdas, Function Objects, and Restricted Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using Lambdas, Function Objects, and Restricted Functions | Microsoft Docs","pos":[0,74]}]},{"content":"Using Lambdas, Function Objects, and Restricted Functions","pos":[567,624]},{"content":"The C++ AMP code that you want to run on the accelerator is specified as an argument in a call to the <bpt id=\"p1\">[</bpt>parallel_for_each<ept id=\"p1\">](reference/concurrency-namespace-functions-amp.md#parallel_for_each)</ept> method.","pos":[625,822],"source":"The C++ AMP code that you want to run on the accelerator is specified as an argument in a call to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method."},{"content":"You can provide either a lambda expression or a function object (functor) as that argument.","pos":[823,914]},{"content":"Additionally, the lambda expression or function object can call a C++ AMP-restricted function.","pos":[915,1009]},{"content":"This topic uses an array addition algorithm to demonstrate lambdas, function objects, and restricted functions.","pos":[1010,1121]},{"content":"The following example shows the algorithm without C++ AMP code.","pos":[1122,1185]},{"content":"Two 1-dimensional arrays of equal length are created.","pos":[1186,1239]},{"content":"The corresponding integer elements are added and stored in a third 1-dimensional array.","pos":[1240,1327]},{"content":"C++ AMP is not used.","pos":[1328,1348]},{"content":"Lambda Expression","pos":[1683,1700]},{"content":"Using a lambda expression is the most direct way to use C++ AMP to rewrite the code.","pos":[1704,1788]},{"content":"The lambda expression must include one indexing parameter and must include <ph id=\"ph1\">`restrict(amp)`</ph>.","pos":[2291,2382],"source":"The lambda expression must include one indexing parameter and must include `restrict(amp)`."},{"content":"In the example, the <bpt id=\"p1\">[</bpt>array_view<ept id=\"p1\">](../../parallel/amp/reference/array-view-class.md)</ept><ph id=\"ph1\">`sum`</ph> object has a rank of 1.","pos":[2383,2494],"source":" In the example, the [array_view](../../parallel/amp/reference/array-view-class.md)`sum` object has a rank of 1."},{"content":"Therefore, the parameter to the lambda statement is an <bpt id=\"p1\">[</bpt>index<ept id=\"p1\">](../../parallel/amp/reference/index-class.md)</ept> object that has rank 1.","pos":[2495,2626],"source":" Therefore, the parameter to the lambda statement is an [index](../../parallel/amp/reference/index-class.md) object that has rank 1."},{"content":"At runtime, the lambda expression is executed once for each element in the <bpt id=\"p1\">[</bpt>array_view<ept id=\"p1\">](../../parallel/amp/reference/array-view-class.md)</ept> object.","pos":[2627,2772],"source":" At runtime, the lambda expression is executed once for each element in the [array_view](../../parallel/amp/reference/array-view-class.md) object."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Lambda Expression Syntax<ept id=\"p1\">](../../cpp/lambda-expression-syntax.md)</ept>.","pos":[2773,2865],"source":" For more information, see [Lambda Expression Syntax](../../cpp/lambda-expression-syntax.md)."},{"content":"Function Object","pos":[2874,2889]},{"content":"You can factor the accelerator code into a function object.","pos":[2893,2952]},{"content":"The function object must include a constructor and must include an overload of the function call operator.","pos":[3837,3943]},{"content":"The function call operator must include one indexing parameter.","pos":[3944,4007]},{"content":"An instance of the function object is passed as the second argument to the <bpt id=\"p1\">[</bpt>parallel_for_each<ept id=\"p1\">](reference/concurrency-namespace-functions-amp.md#parallel_for_each)</ept> method.","pos":[4008,4178],"source":" An instance of the function object is passed as the second argument to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method."},{"content":"In this example, three <bpt id=\"p1\">[</bpt>array_view<ept id=\"p1\">](../../parallel/amp/reference/array-view-class.md)</ept> objects are passed to the function object constructor.","pos":[4179,4319],"source":" In this example, three [array_view](../../parallel/amp/reference/array-view-class.md) objects are passed to the function object constructor."},{"content":"The <bpt id=\"p1\">[</bpt>array_view<ept id=\"p1\">](../../parallel/amp/reference/array-view-class.md)</ept> object <ph id=\"ph1\">`sum`</ph> has a rank of 1.","pos":[4320,4416],"source":" The [array_view](../../parallel/amp/reference/array-view-class.md) object `sum` has a rank of 1."},{"content":"Therefore, the parameter to the function call operator is an <bpt id=\"p1\">[</bpt>index<ept id=\"p1\">](../../parallel/amp/reference/index-class.md)</ept> object that has rank 1.","pos":[4417,4554],"source":" Therefore, the parameter to the function call operator is an [index](../../parallel/amp/reference/index-class.md) object that has rank 1."},{"content":"At runtime, the function is executed once for each element in the <bpt id=\"p1\">[</bpt>array_view<ept id=\"p1\">](../../parallel/amp/reference/array-view-class.md)</ept> object.","pos":[4555,4691],"source":" At runtime, the function is executed once for each element in the [array_view](../../parallel/amp/reference/array-view-class.md) object."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Function Call<ept id=\"p1\">](../../cpp/function-call-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>Function Objects in the STL<ept id=\"p2\">](../../standard-library/function-objects-in-the-stl.md)</ept>.","pos":[4692,4855],"source":" For more information, see [Function Call](../../cpp/function-call-cpp.md) and [Function Objects in the STL](../../standard-library/function-objects-in-the-stl.md)."},{"content":"C++ AMP-Restricted Function","pos":[4864,4891]},{"content":"You can further factor the accelerator code by creating a restricted function and calling it from a lambda expression or a function object.","pos":[4895,5034]},{"content":"The following code example demonstrates how to call a restricted function from a lambda expression.","pos":[5035,5134]},{"pos":[5832,5991],"content":"The restricted function must include <ph id=\"ph1\">`restrict(amp)`</ph> and conform to the restrictions that are described in <bpt id=\"p1\">[</bpt>restrict (C++ AMP)<ept id=\"p1\">](../../cpp/restrict-cpp-amp.md)</ept>.","source":"The restricted function must include `restrict(amp)` and conform to the restrictions that are described in [restrict (C++ AMP)](../../cpp/restrict-cpp-amp.md)."},{"content":"See Also","pos":[6000,6008]},{"content":"C++ AMP (C++ Accelerated Massive Parallelism)","pos":[6013,6058]},{"content":"Lambda Expression Syntax","pos":[6132,6156]},{"content":"Function Call","pos":[6202,6215]},{"content":"Function Objects in the STL","pos":[6254,6281]},{"content":"restrict (C++ AMP)","pos":[6343,6361]}],"content":"---\ntitle: \"Using Lambdas, Function Objects, and Restricted Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 25346cc9-869d-4ada-aad3-e2228cad3d6c\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using Lambdas, Function Objects, and Restricted Functions\nThe C++ AMP code that you want to run on the accelerator is specified as an argument in a call to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method. You can provide either a lambda expression or a function object (functor) as that argument. Additionally, the lambda expression or function object can call a C++ AMP-restricted function. This topic uses an array addition algorithm to demonstrate lambdas, function objects, and restricted functions. The following example shows the algorithm without C++ AMP code. Two 1-dimensional arrays of equal length are created. The corresponding integer elements are added and stored in a third 1-dimensional array. C++ AMP is not used.  \n  \n```cpp  \n \nvoid CpuMethod() {  \n \n    int aCPP[] = {1, 2, 3, 4, 5};  \n    int bCPP[] = {6, 7, 8, 9, 10};  \n    int sumCPP[5];  \n \n    for (int idx = 0; idx <5; idx++)  \n {  \n    sumCPP[idx] = aCPP[idx] + bCPP[idx];  \n }  \n \n    for (int idx = 0; idx <5; idx++)  \n {  \n    std::cout <<sumCPP[idx] <<\"\\n\";  \n }  \n}  \n \n```  \n  \n## Lambda Expression  \n Using a lambda expression is the most direct way to use C++ AMP to rewrite the code.  \n  \n```cpp  \n \nvoid AddArraysWithLambda() {  \n    int aCPP[] = {1, 2, 3, 4, 5};  \n    int bCPP[] = {6, 7, 8, 9, 10};  \n    int sumCPP[5];  \n \n    array_view<const int, 1> a(5, aCPP);\n\n    array_view<const int, 1> b(5, bCPP);\n\n    array_view<int, 1> sum(5, sumCPP);\n\n    sum.discard_data();\n\n \n    parallel_for_each(\n sum.extent, \n [=](index<1> idx) restrict(amp)  \n {  \n    sum[idx] = a[idx] + b[idx];  \n });\n\n \n    for (int i = 0; i <5; i++) {  \n    std::cout <<sum[i] <<\"\\n\";  \n }  \n}  \n \n```  \n  \n The lambda expression must include one indexing parameter and must include `restrict(amp)`. In the example, the [array_view](../../parallel/amp/reference/array-view-class.md)`sum` object has a rank of 1. Therefore, the parameter to the lambda statement is an [index](../../parallel/amp/reference/index-class.md) object that has rank 1. At runtime, the lambda expression is executed once for each element in the [array_view](../../parallel/amp/reference/array-view-class.md) object. For more information, see [Lambda Expression Syntax](../../cpp/lambda-expression-syntax.md).  \n  \n## Function Object  \n You can factor the accelerator code into a function object.  \n  \n```cpp  \n \nclass AdditionFunctionObject  \n{  \npublic:  \n    AdditionFunctionObject(const array_view<int, 1>& a,  \n    const array_view<int, 1>& b,  \n    const array_view<int, 1>& sum)  \n : a(a), b(b), sum(sum)  \n {  \n }  \n \n    void operator()(index<1> idx) restrict(amp)  \n {  \n    sum[idx] = a[idx] + b[idx];  \n }  \n \nprivate:  \n    array_view<int, 1> a;  \n    array_view<int, 1> b;  \n    array_view<int, 1> sum;  \n};  \n \nvoid AddArraysWithFunctionObject() {  \n \n    int aCPP[] = {1, 2, 3, 4, 5};  \n    int bCPP[] = {6, 7, 8, 9, 10};  \n    int sumCPP[5];  \n \n    array_view<const int, 1> a(5, aCPP);\n\n    array_view<const int, 1> b(5, bCPP);\n\n    array_view<int, 1> sum(5, sumCPP);\n\n    sum.discard_data();\n\n \n    parallel_for_each(\n sum.extent, \n    AdditionFunctionObject(a, b, sum));\n\n \n    for (int i = 0; i <5; i++) {  \n    std::cout <<sum[i] <<\"\\n\";  \n }  \n}  \n \n```  \n\n The function object must include a constructor and must include an overload of the function call operator. The function call operator must include one indexing parameter. An instance of the function object is passed as the second argument to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method. In this example, three [array_view](../../parallel/amp/reference/array-view-class.md) objects are passed to the function object constructor. The [array_view](../../parallel/amp/reference/array-view-class.md) object `sum` has a rank of 1. Therefore, the parameter to the function call operator is an [index](../../parallel/amp/reference/index-class.md) object that has rank 1. At runtime, the function is executed once for each element in the [array_view](../../parallel/amp/reference/array-view-class.md) object. For more information, see [Function Call](../../cpp/function-call-cpp.md) and [Function Objects in the STL](../../standard-library/function-objects-in-the-stl.md).  \n  \n## C++ AMP-Restricted Function  \n You can further factor the accelerator code by creating a restricted function and calling it from a lambda expression or a function object. The following code example demonstrates how to call a restricted function from a lambda expression.  \n  \n```cpp  \n \nvoid AddElementsWithRestrictedFunction(index<1> idx, array_view<int, 1> sum, array_view<int, 1> a, array_view<int, 1> b) restrict(amp)  \n{  \n    sum[idx] = a[idx] + b[idx];  \n}  \n \nvoid AddArraysWithFunction() {  \n \n    int aCPP[] = {1, 2, 3, 4, 5};  \n    int bCPP[] = {6, 7, 8, 9, 10};  \n    int sumCPP[5];  \n \n    array_view<int, 1> a(5, aCPP);\n\n    array_view<int, 1> b(5, bCPP);\n\n    array_view<int, 1> sum(5, sumCPP);\n\n    sum.discard_data();\n\n \n    parallel_for_each(\n sum.extent, \n [=](index<1> idx) restrict(amp)  \n {  \n    AddElementsWithRestrictedFunction(idx, sum, a, b);\n\n });\n\n \n    for (int i = 0; i <5; i++) {  \n    std::cout <<sum[i] <<\"\\n\";  \n }  \n}  \n \n```  \n  \n The restricted function must include `restrict(amp)` and conform to the restrictions that are described in [restrict (C++ AMP)](../../cpp/restrict-cpp-amp.md).  \n  \n## See Also  \n [C++ AMP (C++ Accelerated Massive Parallelism)](../../parallel/amp/cpp-amp-cpp-accelerated-massive-parallelism.md)   \n [Lambda Expression Syntax](../../cpp/lambda-expression-syntax.md)   \n [Function Call](../../cpp/function-call-cpp.md)   \n [Function Objects in the STL](../../standard-library/function-objects-in-the-stl.md)   \n [restrict (C++ AMP)](../../cpp/restrict-cpp-amp.md)\n\n"}