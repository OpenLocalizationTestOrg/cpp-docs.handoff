{"nodes":[{"pos":[12,43],"content":"Extension DLLs | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Extension DLLs | Microsoft Docs","pos":[0,31]}]},{"content":"Extension DLLs","pos":[880,894]},{"content":"An MFC extension DLL is a DLL that typically implements reusable classes derived from the existing Microsoft Foundation Class Library classes.","pos":[895,1037]},{"content":"An MFC extension DLL has the following features and requirements:","pos":[1044,1109]},{"pos":[1119,1202],"content":"The client executable must be an MFC application compiled with <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> defined.","source":"The client executable must be an MFC application compiled with **_AFXDLL** defined."},{"content":"An extension DLL can also be used by a regular DLL that is dynamically linked to MFC.","pos":[1212,1297]},{"content":"Extension DLLs should be compiled with <ph id=\"ph1\">`_AFXEXT`</ph> defined.","pos":[1307,1364],"source":"Extension DLLs should be compiled with `_AFXEXT` defined."},{"content":"This forces <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> to be also defined and ensures that the proper declarations is pulled in from the MFC header files.","pos":[1365,1488],"source":" This forces **_AFXDLL** to be also defined and ensures that the proper declarations is pulled in from the MFC header files."},{"content":"It also ensures that <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is defined as <bpt id=\"p2\">**</bpt>__declspec(dllexport)<ept id=\"p2\">**</ept> while building the DLL, which is necessary if you are using this macro to declare the classes in your extension DLL.","pos":[1489,1684],"source":" It also ensures that **AFX_EXT_CLASS** is defined as **__declspec(dllexport)** while building the DLL, which is necessary if you are using this macro to declare the classes in your extension DLL."},{"pos":[1694,1838],"content":"Extension DLLs should not instantiate a class derived from <ph id=\"ph1\">`CWinApp`</ph>, but should rely on the client application (or DLL) to provide this object.","source":"Extension DLLs should not instantiate a class derived from `CWinApp`, but should rely on the client application (or DLL) to provide this object."},{"pos":[1848,1951],"content":"Extension DLLs should, however, provide a <ph id=\"ph1\">`DllMain`</ph> function and do any necessary initialization there.","source":"Extension DLLs should, however, provide a `DllMain` function and do any necessary initialization there."},{"content":"Extension DLLs are built using the dynamic-link library version of MFC (also known as the shared version of MFC).","pos":[1958,2071]},{"content":"Only MFC executables (either applications or regular DLLs) that are built with the shared version of MFC can use an extension DLL.","pos":[2072,2202]},{"content":"Both the client application and the extension DLL must use the same version of MFCx0.dll.","pos":[2203,2292]},{"content":"With an extension DLL, you can derive new custom classes from MFC and then offer this extended version of MFC to applications that call your DLL.","pos":[2293,2438]},{"content":"Extension DLLs can also be used for passing MFC-derived objects between the application and the DLL.","pos":[2445,2545]},{"content":"The member functions associated with the passed object exist in the module where the object was created.","pos":[2546,2650]},{"content":"Because these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.","pos":[2651,2849]},{"content":"An MFC extension DLL uses a shared version of MFC in the same way an application uses the shared DLL version of MFC, with a few additional considerations:","pos":[2856,3010]},{"content":"It does not have a <ph id=\"ph1\">`CWinApp`</ph>-derived object.","pos":[3020,3064],"source":"It does not have a `CWinApp`-derived object."},{"content":"It must work with the <ph id=\"ph1\">`CWinApp`</ph>-derived object of the client application.","pos":[3065,3138],"source":" It must work with the `CWinApp`-derived object of the client application."},{"content":"This means that the client application owns the main message pump, the idle loop, and so on.","pos":[3139,3231]},{"content":"It calls <ph id=\"ph1\">`AfxInitExtensionModule`</ph> in its <ph id=\"ph2\">`DllMain`</ph> function.","pos":[3241,3301],"source":"It calls `AfxInitExtensionModule` in its `DllMain` function."},{"content":"The return value of this function should be checked.","pos":[3302,3354]},{"content":"If a zero value is returned from <ph id=\"ph1\">`AfxInitExtensionModule`</ph>, return 0 from your <ph id=\"ph2\">`DllMain`</ph> function.","pos":[3355,3452],"source":" If a zero value is returned from `AfxInitExtensionModule`, return 0 from your `DllMain` function."},{"pos":[3462,3617],"content":"It creates a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object during initialization if the extension DLL wants to export <ph id=\"ph1\">`CRuntimeClass`</ph> objects or resources to the application.","source":"It creates a **CDynLinkLibrary** object during initialization if the extension DLL wants to export `CRuntimeClass` objects or resources to the application."},{"content":"Before version 4.0 of MFC, this type of DLL was called an AFXDLL.","pos":[3624,3689]},{"content":"AFXDLL refers to the <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> preprocessor symbol that is defined when building the DLL.","pos":[3690,3781],"source":" AFXDLL refers to the **_AFXDLL** preprocessor symbol that is defined when building the DLL."},{"content":"The import libraries for the shared version of MFC are named according to the convention described in <bpt id=\"p1\">[</bpt>Naming conventions for MFC DLLs<ept id=\"p1\">](../build/naming-conventions-for-mfc-dlls.md)</ept>.","pos":[3788,3969],"source":"The import libraries for the shared version of MFC are named according to the convention described in [Naming conventions for MFC DLLs](../build/naming-conventions-for-mfc-dlls.md)."},{"content":"Visual C++ supplies prebuilt versions of the MFC DLLs, plus a number of non-MFC DLLs that you can use and distribute with your applications.","pos":[3970,4110]},{"content":"These are documented in Redist.txt, which is installed to the Program Files\\Microsoft Visual Studio folder.","pos":[4111,4218]},{"content":"If you are exporting using a .def file, place the following code at the beginning and end of your header file:","pos":[4225,4335]},{"content":"These four lines ensure that your code is compiled correctly for an extension DLL.","pos":[4476,4558]},{"content":"Leaving out these four lines might cause your DLL to either compile or link incorrectly.","pos":[4559,4647]},{"content":"If you need to pass an MFC or MFC-derived object pointer to or from an MFC DLL, the DLL should be an extension DLL.","pos":[4654,4769]},{"content":"The member functions associated with the passed object exist in the module where the object was created.","pos":[4770,4874]},{"content":"Because these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.","pos":[4875,5073]},{"content":"Due to C++ name mangling and export issues, the export list from an extension DLL might be different between the debug and retail versions of the same DLL and DLLs for different platforms.","pos":[5080,5268]},{"content":"The retail MFCx0.dll has about 2,000 exported entry points; the debug MFCx0D.dll has about 3,000 exported entry points.","pos":[5269,5388]},{"content":"Memory Management","pos":[5397,5414]},{"content":"MFCx0.dll and all extension DLLs loaded into a client application's address space use the same memory allocator, resource loading, and other MFC global states as if they were in the same application.","pos":[5418,5617]},{"content":"This is significant because the non-MFC DLL libraries and the regular DLLs do the exact opposite and have each DLL allocating out of its own memory pool.","pos":[5618,5771]},{"content":"If an extension DLL allocates memory, that memory can freely intermix with any other application-allocated object.","pos":[5778,5892]},{"content":"Also, if an application that dynamically links to MFC fails, the protection of the operating system maintains the integrity of any other MFC application sharing the DLL.","pos":[5893,6062]},{"content":"Similarly other global MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCx0.dll itself.","pos":[6069,6263]},{"content":"Sharing Resources and Classes","pos":[6272,6301]},{"content":"Exporting resources is done through a resource list.","pos":[6305,6357]},{"content":"Each application contains a singly linked list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects.","pos":[6358,6436],"source":" Each application contains a singly linked list of **CDynLinkLibrary** objects."},{"content":"When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (<ph id=\"ph1\">`AfxGetResourceHandle`</ph>) and if the resource is not found walk the list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects attempting to load the requested resource.","pos":[6437,6714],"source":" When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (`AfxGetResourceHandle`) and if the resource is not found walk the list of **CDynLinkLibrary** objects attempting to load the requested resource."},{"content":"Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges.","pos":[6721,6828]},{"content":"It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle.","pos":[6829,6997]},{"content":"is an API used for walking the resource list to look for a given match.","pos":[7022,7093]},{"content":"It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).","pos":[7094,7202]},{"content":"If you do not want to walk the list and only load resources from a specific place, use the functions <ph id=\"ph1\">`AfxGetResourceHandle`</ph> and <ph id=\"ph2\">`AfxSetResourceHandle`</ph> to save the old handle and set the new handle.","pos":[7209,7406],"source":"If you do not want to walk the list and only load resources from a specific place, use the functions `AfxGetResourceHandle` and `AfxSetResourceHandle` to save the old handle and set the new handle."},{"content":"Be sure to restore the old resource handle before you return to the client application.","pos":[7407,7494]},{"content":"For an example of using this approach to explicitly load a menu, see Testdll2 .cpp in the MFC sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)</ept>.","pos":[7495,7676],"source":" For an example of using this approach to explicitly load a menu, see Testdll2 .cpp in the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)."},{"content":"Dynamic creation of MFC objects given an MFC name is similar.","pos":[7683,7744]},{"content":"The MFC object deserialization mechanism needs to have all of the <ph id=\"ph1\">`CRuntimeClass`</ph> objects registered so that it can reconstruct by dynamically creating C++ objects of the required type based on what was stored earlier.","pos":[7745,7963],"source":" The MFC object deserialization mechanism needs to have all of the `CRuntimeClass` objects registered so that it can reconstruct by dynamically creating C++ objects of the required type based on what was stored earlier."},{"pos":[7970,8111],"content":"In the case of the MFC sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)</ept>, the list looks something like:","source":"In the case of the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90), the list looks something like:"},{"pos":[8616,8689],"content":"where <bpt id=\"p1\">*</bpt>xx<ept id=\"p1\">*</ept> is the version number; for example, 42 represents version 4.2.","source":"where *xx* is the version number; for example, 42 represents version 4.2."},{"content":"The MFCxx.dll is usually last on the resource and class list.","pos":[8696,8757]},{"content":"MFCxx.dll includes all of the standard MFC resources, including prompt strings for all of the standard command IDs.","pos":[8758,8873]},{"content":"Placing it at the end of the list allows DLLs and the client application itself not to have their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.dll instead.","pos":[8874,9073]},{"content":"Merging the resources and class names of all DLLs into the client application's name space has the disadvantage of requiring you to be careful with what IDs or names you pick.","pos":[9080,9255]},{"pos":[9262,9423],"content":"The <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)</ept> sample manages the shared resource name space by using multiple header files.","source":"The [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90) sample manages the shared resource name space by using multiple header files."},{"content":"If your MFC extension DLL needs to maintain extra data for each application, you can derive a new class from <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> and create it in <ph id=\"ph1\">`DllMain`</ph>.","pos":[9430,9586],"source":"If your MFC extension DLL needs to maintain extra data for each application, you can derive a new class from **CDynLinkLibrary** and create it in `DllMain`."},{"content":"When running, the DLL can check the current application's list of <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> objects to find the one for that particular extension DLL.","pos":[9587,9731],"source":" When running, the DLL can check the current application's list of **CDynLinkLibrary** objects to find the one for that particular extension DLL."},{"content":"What do you want to do?","pos":[9741,9764]},{"content":"Initialize an extension DLL","pos":[9775,9802]},{"content":"What do you want to know more about?","pos":[9854,9890]},{"content":"Tips on using shared resource files","pos":[9901,9936]},{"content":"DLL Version of MFC","pos":[10028,10046]},{"content":"Regular DLLs statically linked to MFC","pos":[10094,10131]},{"content":"Regular DLLs dynamically linked to MFC","pos":[10194,10232]},{"content":"Using Database, OLE, and Sockets Extension DLLs in Regular DLLs","pos":[10296,10359]},{"content":"See Also","pos":[10444,10452]},{"content":"DLLs in Visual C++","pos":[10457,10475]}],"content":"---\ntitle: \"Extension DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"afxdll\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"memory [C++], DLLs\"\n  - \"MFC extension DLLs [C++]\"\n  - \"AFXDLL library\"\n  - \"shared resources [C++]\"\n  - \"MFC DLLs [C++], extension DLLs\"\n  - \"DLLs [C++], extension\"\n  - \"shared DLL versions [C++]\"\n  - \"resource sharing [C++]\"\n  - \"extension DLLs [C++]\"\n  - \"extension DLLs [C++], about extension DLLs\"\nms.assetid: f69ac3d4-e474-4b1c-87a1-6738843a135c\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Extension DLLs\nAn MFC extension DLL is a DLL that typically implements reusable classes derived from the existing Microsoft Foundation Class Library classes.  \n  \n An MFC extension DLL has the following features and requirements:  \n  \n-   The client executable must be an MFC application compiled with **_AFXDLL** defined.  \n  \n-   An extension DLL can also be used by a regular DLL that is dynamically linked to MFC.  \n  \n-   Extension DLLs should be compiled with `_AFXEXT` defined. This forces **_AFXDLL** to be also defined and ensures that the proper declarations is pulled in from the MFC header files. It also ensures that **AFX_EXT_CLASS** is defined as **__declspec(dllexport)** while building the DLL, which is necessary if you are using this macro to declare the classes in your extension DLL.  \n  \n-   Extension DLLs should not instantiate a class derived from `CWinApp`, but should rely on the client application (or DLL) to provide this object.  \n  \n-   Extension DLLs should, however, provide a `DllMain` function and do any necessary initialization there.  \n  \n Extension DLLs are built using the dynamic-link library version of MFC (also known as the shared version of MFC). Only MFC executables (either applications or regular DLLs) that are built with the shared version of MFC can use an extension DLL. Both the client application and the extension DLL must use the same version of MFCx0.dll. With an extension DLL, you can derive new custom classes from MFC and then offer this extended version of MFC to applications that call your DLL.  \n  \n Extension DLLs can also be used for passing MFC-derived objects between the application and the DLL. The member functions associated with the passed object exist in the module where the object was created. Because these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.  \n  \n An MFC extension DLL uses a shared version of MFC in the same way an application uses the shared DLL version of MFC, with a few additional considerations:  \n  \n-   It does not have a `CWinApp`-derived object. It must work with the `CWinApp`-derived object of the client application. This means that the client application owns the main message pump, the idle loop, and so on.  \n  \n-   It calls `AfxInitExtensionModule` in its `DllMain` function. The return value of this function should be checked. If a zero value is returned from `AfxInitExtensionModule`, return 0 from your `DllMain` function.  \n  \n-   It creates a **CDynLinkLibrary** object during initialization if the extension DLL wants to export `CRuntimeClass` objects or resources to the application.  \n  \n Before version 4.0 of MFC, this type of DLL was called an AFXDLL. AFXDLL refers to the **_AFXDLL** preprocessor symbol that is defined when building the DLL.  \n  \n The import libraries for the shared version of MFC are named according to the convention described in [Naming conventions for MFC DLLs](../build/naming-conventions-for-mfc-dlls.md). Visual C++ supplies prebuilt versions of the MFC DLLs, plus a number of non-MFC DLLs that you can use and distribute with your applications. These are documented in Redist.txt, which is installed to the Program Files\\Microsoft Visual Studio folder.  \n  \n If you are exporting using a .def file, place the following code at the beginning and end of your header file:  \n  \n```  \n#undef AFX_DATA  \n#define AFX_DATA AFX_EXT_DATA  \n// <body of your header file>  \n#undef AFX_DATA  \n#define AFX_DATA  \n```  \n  \n These four lines ensure that your code is compiled correctly for an extension DLL. Leaving out these four lines might cause your DLL to either compile or link incorrectly.  \n  \n If you need to pass an MFC or MFC-derived object pointer to or from an MFC DLL, the DLL should be an extension DLL. The member functions associated with the passed object exist in the module where the object was created. Because these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.  \n  \n Due to C++ name mangling and export issues, the export list from an extension DLL might be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCx0.dll has about 2,000 exported entry points; the debug MFCx0D.dll has about 3,000 exported entry points.  \n  \n## Memory Management  \n MFCx0.dll and all extension DLLs loaded into a client application's address space use the same memory allocator, resource loading, and other MFC global states as if they were in the same application. This is significant because the non-MFC DLL libraries and the regular DLLs do the exact opposite and have each DLL allocating out of its own memory pool.  \n  \n If an extension DLL allocates memory, that memory can freely intermix with any other application-allocated object. Also, if an application that dynamically links to MFC fails, the protection of the operating system maintains the integrity of any other MFC application sharing the DLL.  \n  \n Similarly other global MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCx0.dll itself.  \n  \n## Sharing Resources and Classes  \n Exporting resources is done through a resource list. Each application contains a singly linked list of **CDynLinkLibrary** objects. When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (`AfxGetResourceHandle`) and if the resource is not found walk the list of **CDynLinkLibrary** objects attempting to load the requested resource.  \n  \n Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges. It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle. `AfxFindResourceHandle` is an API used for walking the resource list to look for a given match. It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).  \n  \n If you do not want to walk the list and only load resources from a specific place, use the functions `AfxGetResourceHandle` and `AfxSetResourceHandle` to save the old handle and set the new handle. Be sure to restore the old resource handle before you return to the client application. For an example of using this approach to explicitly load a menu, see Testdll2 .cpp in the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90).  \n  \n Dynamic creation of MFC objects given an MFC name is similar. The MFC object deserialization mechanism needs to have all of the `CRuntimeClass` objects registered so that it can reconstruct by dynamically creating C++ objects of the required type based on what was stored earlier.  \n  \n In the case of the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90), the list looks something like:  \n  \n```  \nhead ->   DLLHUSK.EXE   - or -   DLLHUSK.EXE  \n               |                      |  \n          TESTDLL2.DLL           TESTDLL2.DLL  \n               |                      |  \n          TESTDLL1.DLL           TESTDLL1.DLL  \n               |                      |  \n           MFCOxxD.DLL                |  \n               |                      |  \n           MFCDxxD.DLL                |  \n               |                      |  \n            MFCxxD.DLL            MFCxx.DLL  \n```  \n  \n where *xx* is the version number; for example, 42 represents version 4.2.  \n  \n The MFCxx.dll is usually last on the resource and class list. MFCxx.dll includes all of the standard MFC resources, including prompt strings for all of the standard command IDs. Placing it at the end of the list allows DLLs and the client application itself not to have their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.dll instead.  \n  \n Merging the resources and class names of all DLLs into the client application's name space has the disadvantage of requiring you to be careful with what IDs or names you pick.  \n  \n The [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90) sample manages the shared resource name space by using multiple header files.  \n  \n If your MFC extension DLL needs to maintain extra data for each application, you can derive a new class from **CDynLinkLibrary** and create it in `DllMain`. When running, the DLL can check the current application's list of **CDynLinkLibrary** objects to find the one for that particular extension DLL.  \n  \n### What do you want to do?  \n  \n-   [Initialize an extension DLL](../build/initializing-extension-dlls.md)  \n  \n### What do you want to know more about?  \n  \n-   [Tips on using shared resource files](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md)  \n  \n-   [DLL Version of MFC](../mfc/tn033-dll-version-of-mfc.md)  \n  \n-   [Regular DLLs statically linked to MFC](../build/regular-dlls-statically-linked-to-mfc.md)  \n  \n-   [Regular DLLs dynamically linked to MFC](../build/regular-dlls-dynamically-linked-to-mfc.md)  \n  \n-   [Using Database, OLE, and Sockets Extension DLLs in Regular DLLs](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  \n  \n## See Also  \n [DLLs in Visual C++](../build/dlls-in-visual-cpp.md)"}