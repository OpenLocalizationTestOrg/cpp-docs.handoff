{"nodes":[{"pos":[12,54],"content":"Regular Expressions (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Regular Expressions (C++) | Microsoft Docs","pos":[0,42]}]},{"pos":[695,720],"content":"Regular Expressions (C++)","linkify":"Regular Expressions (C++)","nodes":[{"content":"Regular Expressions (C++)","pos":[0,25]}]},{"content":"This topic discusses the grammars of the various regular expression engines.","pos":[721,797]},{"pos":[807,861],"content":"<bpt id=\"p1\">&lt;a name=\"regexgrammar\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Regular Expression Grammar","linkify":"<a name=\"regexgrammar\"></a> Regular Expression Grammar","source":"<a name=\"regexgrammar\"></a> Regular Expression Grammar"},{"pos":[871,878],"content":"Element","linkify":"Element","nodes":[{"content":"Element","pos":[0,7]}]},{"content":"An element can be one of the following things:","pos":[882,928]},{"pos":[938,1017],"content":"An <bpt id=\"p1\">*</bpt>ordinary character<ept id=\"p1\">*</ept> that matches the same character in the target sequence.","source":"An *ordinary character* that matches the same character in the target sequence."},{"pos":[1027,1121],"content":"A <bpt id=\"p1\">*</bpt>wildcard character<ept id=\"p1\">*</ept> '.' that matches any character in the target sequence except a newline.","source":"A *wildcard character* '.' that matches any character in the target sequence except a newline."},{"pos":[1131,1464],"content":"A <bpt id=\"p1\">*</bpt>bracket expression<ept id=\"p1\">*</ept> of the form \"[<ph id=\"ph1\">`expr`</ph>]\", which matches a character or a collation element in the target sequence that is also in the set defined by the expression <ph id=\"ph2\">`expr`</ph>, or of the form \"[^<ph id=\"ph3\">`expr`</ph>]\", which matches a character or a collation element in the target sequence that is not in the set defined by the expression <ph id=\"ph4\">`expr`</ph>.","source":"A *bracket expression* of the form \"[`expr`]\", which matches a character or a collation element in the target sequence that is also in the set defined by the expression `expr`, or of the form \"[^`expr`]\", which matches a character or a collation element in the target sequence that is not in the set defined by the expression `expr`."},{"pos":[1475,1549],"content":"The expression <ph id=\"ph1\">`expr`</ph> can contain any combination of the following things:","source":"The expression `expr` can contain any combination of the following things:"},{"content":"An individual character.","pos":[1563,1587]},{"content":"Adds that character to the set defined by <ph id=\"ph1\">`expr`</ph>.","pos":[1588,1637],"source":" Adds that character to the set defined by `expr`."},{"content":"A <bpt id=\"p1\">*</bpt>character range<ept id=\"p1\">*</ept> of the form \"<ph id=\"ph1\">`ch1`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`ch2`</ph>\".","pos":[1651,1697],"source":"A *character range* of the form \"`ch1`-`ch2`\"."},{"content":"Adds the characters that are represented by values in the closed range [<ph id=\"ph1\">`ch1`</ph>, <ph id=\"ph2\">`ch2`</ph>] to the set defined by <ph id=\"ph3\">`expr`</ph>.","pos":[1698,1813],"source":" Adds the characters that are represented by values in the closed range [`ch1`, `ch2`] to the set defined by `expr`."},{"content":"A <bpt id=\"p1\">*</bpt>character class<ept id=\"p1\">*</ept> of the form \"[:<ph id=\"ph1\">`name`</ph>:]\".","pos":[1827,1872],"source":"A *character class* of the form \"[:`name`:]\"."},{"content":"Adds the characters in the named class to the set defined by <ph id=\"ph1\">`expr`</ph>.","pos":[1873,1941],"source":" Adds the characters in the named class to the set defined by `expr`."},{"content":"An <bpt id=\"p1\">*</bpt>equivalence class<ept id=\"p1\">*</ept> of the form \"[=<ph id=\"ph1\">`elt`</ph>=]\".","pos":[1955,2002],"source":"An *equivalence class* of the form \"[=`elt`=]\"."},{"content":"Adds the collating elements that are equivalent to <ph id=\"ph1\">`elt`</ph> to the set defined by <ph id=\"ph2\">`expr`</ph>.","pos":[2003,2089],"source":" Adds the collating elements that are equivalent to `elt` to the set defined by `expr`."},{"content":"A <bpt id=\"p1\">*</bpt>collating symbol<ept id=\"p1\">*</ept> of the form \"[.<ph id=\"ph1\">`elt`</ph>.]\".","pos":[2103,2148],"source":"A *collating symbol* of the form \"[.`elt`.]\"."},{"content":"Adds the collation element <ph id=\"ph1\">`elt`</ph> to the set defined by <ph id=\"ph2\">`expr`</ph>.","pos":[2149,2211],"source":" Adds the collation element `elt` to the set defined by `expr`."},{"content":"An <bpt id=\"p1\">*</bpt>anchor<ept id=\"p1\">*</ept>.","pos":[2221,2233],"source":"An *anchor*."},{"content":"Anchor '^' matches the beginning of the target sequence; anchor '$' matches the end of the target sequence.","pos":[2234,2341]},{"pos":[2348,2569],"content":"A <bpt id=\"p1\">*</bpt>capture group<ept id=\"p1\">*</ept> of the form \"( <bpt id=\"p2\">*</bpt>subexpression<ept id=\"p2\">*</ept> )\", or \"<ph id=\"ph1\">\\\\</ph>( <bpt id=\"p3\">*</bpt>subexpression<ept id=\"p3\">*</ept> <ph id=\"ph2\">\\\\</ph>)\" in <ph id=\"ph3\">`BRE`</ph> and <ph id=\"ph4\">`grep`</ph>, which matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.","source":"A *capture group* of the form \"( *subexpression* )\", or \"\\\\( *subexpression* \\\\)\" in `BRE` and `grep`, which matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters."},{"pos":[2579,2676],"content":"An <bpt id=\"p1\">*</bpt>identity escape<ept id=\"p1\">*</ept> of the form \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">`k`</ph>\", which matches the character <ph id=\"ph3\">`k`</ph> in the target sequence.","source":"An *identity escape* of the form \"\\\\`k`\", which matches the character `k` in the target sequence."},{"content":"Examples:","pos":[2683,2692]},{"content":"\"a\" matches the target sequence \"a\" but does not match the target sequences \"B\", \"b\", or \"c\".","pos":[2702,2795]},{"content":"\".\" matches all the target sequences \"a\", \"B\", \"b\", and \"c\".","pos":[2805,2865]},{"content":"\"[b-z]\" matches the target sequences \"b\" and \"c\" but does not match the target sequences \"a\" or \"B\".","pos":[2875,2975]},{"content":"\"[:lower:]\" matches the target sequences \"a\", \"b\", and \"c\" but does not match the target sequence \"B\".","pos":[2985,3087]},{"content":"\"(a)\" matches the target sequence \"a\" and associates capture group 1 with the subsequence \"a\", but does not match the target sequences \"B\", \"b\", or \"c\".","pos":[3097,3249]},{"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, <ph id=\"ph2\">`BRE`</ph>, and <ph id=\"ph3\">`grep`</ph>, an element can also be a <bpt id=\"p1\">*</bpt>back reference<ept id=\"p1\">*</ept> of the form \"<ph id=\"ph4\">\\\\</ph><ph id=\"ph5\">`dd`</ph>\", where <ph id=\"ph6\">`dd`</ph> represents a decimal value N that matches a sequence of characters in the target sequence that is the same as the sequence of characters that is matched by the Nth <bpt id=\"p2\">*</bpt>capture group<ept id=\"p2\">*</ept>.","pos":[3256,3547],"source":"In `ECMAScript`, `BRE`, and `grep`, an element can also be a *back reference* of the form \"\\\\`dd`\", where `dd` represents a decimal value N that matches a sequence of characters in the target sequence that is the same as the sequence of characters that is matched by the Nth *capture group*."},{"content":"For example, \"(a)\\1\" matches the target sequence \"aa\" because the first (and only) capture group matches the initial sequence \"a\" and then the \\1 matches the final sequence \"a\".","pos":[3548,3725]},{"pos":[3732,3800],"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, an element can also be one of the following things:","source":"In `ECMAScript`, an element can also be one of the following things:"},{"content":"A <bpt id=\"p1\">*</bpt>non-capture group<ept id=\"p1\">*</ept> of the form \"(: <bpt id=\"p2\">*</bpt>subexpression<ept id=\"p2\">*</ept> )\".","pos":[3810,3867],"source":"A *non-capture group* of the form \"(: *subexpression* )\"."},{"content":"Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.","pos":[3868,3980]},{"content":"A limited <bpt id=\"p1\">*</bpt>file format escape<ept id=\"p1\">*</ept> of the form \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\".","pos":[3990,4065],"source":"A limited *file format escape* of the form \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\"."},{"content":"These match a form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.","pos":[4066,4188]},{"content":"A <bpt id=\"p1\">*</bpt>positive assert<ept id=\"p1\">*</ept> of the form \"(= <bpt id=\"p2\">*</bpt>subexpression<ept id=\"p2\">*</ept> )\".","pos":[4198,4253],"source":"A *positive assert* of the form \"(= *subexpression* )\"."},{"content":"Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters, but does not change the match position in the target sequence.","pos":[4254,4429]},{"content":"A <bpt id=\"p1\">*</bpt>negative assert<ept id=\"p1\">*</ept> of the form \"(!","pos":[4439,4474],"source":"A *negative assert* of the form \"(!"},{"content":"<bpt id=\"p1\">*</bpt>subexpression<ept id=\"p1\">*</ept> )\".","pos":[4475,4494],"source":"*subexpression* )\"."},{"content":"Matches any sequence of characters in the target sequence that does not match the pattern between the delimiters, and does not change the match position in the target sequence.","pos":[4495,4671]},{"content":"A <bpt id=\"p1\">*</bpt>hexadecimal escape sequence<ept id=\"p1\">*</ept> of the form \"\\x<ph id=\"ph1\">`hh`</ph>\".","pos":[4681,4734],"source":"A *hexadecimal escape sequence* of the form \"\\x`hh`\"."},{"content":"Matches a character in the target sequence that is represented by the two hexadecimal digits <ph id=\"ph1\">`hh`</ph>.","pos":[4735,4833],"source":" Matches a character in the target sequence that is represented by the two hexadecimal digits `hh`."},{"content":"A <bpt id=\"p1\">*</bpt>unicode escape sequence<ept id=\"p1\">*</ept> of the form \"\\u<ph id=\"ph1\">`hhhh`</ph>\".","pos":[4843,4894],"source":"A *unicode escape sequence* of the form \"\\u`hhhh`\"."},{"content":"Matches a character in the target sequence that is represented by the four hexadecimal digits <ph id=\"ph1\">`hhhh`</ph>.","pos":[4895,4996],"source":" Matches a character in the target sequence that is represented by the four hexadecimal digits `hhhh`."},{"content":"A <bpt id=\"p1\">*</bpt>control escape sequence<ept id=\"p1\">*</ept> of the form \"\\c<ph id=\"ph1\">`k`</ph>\".","pos":[5006,5054],"source":"A *control escape sequence* of the form \"\\c`k`\"."},{"content":"Matches the control character that is named by the character <ph id=\"ph1\">`k`</ph>.","pos":[5055,5120],"source":" Matches the control character that is named by the character `k`."},{"content":"A <bpt id=\"p1\">*</bpt>word boundary assert<ept id=\"p1\">*</ept> of the form \"\\b\".","pos":[5130,5172],"source":"A *word boundary assert* of the form \"\\b\"."},{"content":"Matches when the current position in the target sequence is immediately after a <bpt id=\"p1\">*</bpt>word boundary<ept id=\"p1\">*</ept>.","pos":[5173,5269],"source":" Matches when the current position in the target sequence is immediately after a *word boundary*."},{"content":"A <bpt id=\"p1\">*</bpt>negative word boundary assert<ept id=\"p1\">*</ept> of the form \"\\B\".","pos":[5279,5330],"source":"A *negative word boundary assert* of the form \"\\B\"."},{"content":"Matches when the current position in the target sequence is not immediately after a <bpt id=\"p1\">*</bpt>word boundary<ept id=\"p1\">*</ept>.","pos":[5331,5431],"source":" Matches when the current position in the target sequence is not immediately after a *word boundary*."},{"content":"A <bpt id=\"p1\">*</bpt>dsw character escape<ept id=\"p1\">*</ept> of the form \"\\d\", \"\\D\", \"\\s\", \"\\S\", \"\\w\", \"\\W\".","pos":[5441,5513],"source":"A *dsw character escape* of the form \"\\d\", \"\\D\", \"\\s\", \"\\S\", \"\\w\", \"\\W\"."},{"content":"Provides a short name for a character class.","pos":[5514,5558]},{"content":"Examples:","pos":[5565,5574]},{"content":"\"(:a)\" matches the target sequence \"a\", but \"(:a)\\1\" is invalid because there is no capture group 1.","pos":[5584,5684]},{"content":"\"(=a)a\" matches the target sequence \"a\".","pos":[5694,5734]},{"content":"The positive assert matches the initial sequence \"a\" in the target sequence and the final \"a\" in the regular expression matches the initial sequence \"a\" in the target sequence.","pos":[5735,5911]},{"content":"\"(!a)a\" does not match the target sequence \"a\".","pos":[5921,5968]},{"content":"\"a\\b.\"","pos":[5978,5984]},{"content":"matches the target sequence \"a~\", but does not match the target sequence \"ab\".","pos":[5985,6063]},{"content":"\"a\\B.\"","pos":[6073,6079]},{"content":"matches the target sequence \"ab\", but does not match the target sequence \"a~\".","pos":[6080,6158]},{"pos":[6165,6226],"content":"In <ph id=\"ph1\">`awk`</ph>, an element can also be one of the following things:","source":"In `awk`, an element can also be one of the following things:"},{"content":"A <bpt id=\"p1\">*</bpt>file format escape<ept id=\"p1\">*</ept> of the form \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">\\\\</ph>\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\".","pos":[6236,6323],"source":"A *file format escape* of the form \"\\\\\\\\\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\"."},{"content":"These match a backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.","pos":[6324,6475]},{"content":"An <bpt id=\"p1\">*</bpt>octal escape sequence<ept id=\"p1\">*</ept> of the form \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">`ooo`</ph>\".","pos":[6485,6534],"source":"An *octal escape sequence* of the form \"\\\\`ooo`\"."},{"content":"Matches a character in the target sequence whose representation is the value represented by the one, two, or three octal digits <ph id=\"ph1\">`ooo`</ph>.","pos":[6535,6669],"source":" Matches a character in the target sequence whose representation is the value represented by the one, two, or three octal digits `ooo`."},{"pos":[6679,6689],"content":"Repetition","linkify":"Repetition","nodes":[{"content":"Repetition","pos":[0,10]}]},{"content":"Any element other than a <bpt id=\"p1\">*</bpt>positive assert<ept id=\"p1\">*</ept>, a <bpt id=\"p2\">*</bpt>negative assert<ept id=\"p2\">*</ept>, or an <bpt id=\"p3\">*</bpt>anchor<ept id=\"p3\">*</ept> can be followed by a repetition count.","pos":[6693,6811],"source":"Any element other than a *positive assert*, a *negative assert*, or an *anchor* can be followed by a repetition count."},{"content":"The most general kind of repetition count takes the form \"{<ph id=\"ph1\">`min`</ph>,<ph id=\"ph2\">`max`</ph>}\", or \"<ph id=\"ph3\">\\\\</ph>{<ph id=\"ph4\">`min`</ph>,<ph id=\"ph5\">`max`</ph><ph id=\"ph6\">\\\\</ph>}\" in <ph id=\"ph7\">`BRE`</ph> and <ph id=\"ph8\">`grep`</ph>.","pos":[6812,6929],"source":" The most general kind of repetition count takes the form \"{`min`,`max`}\", or \"\\\\{`min`,`max`\\\\}\" in `BRE` and `grep`."},{"content":"An element that is followed by this form of repetition count matches at least <ph id=\"ph1\">`min`</ph> successive occurrences and no more than <ph id=\"ph2\">`max`</ph> successive occurrences of a sequence that matches the element.","pos":[6930,7122],"source":" An element that is followed by this form of repetition count matches at least `min` successive occurrences and no more than `max` successive occurrences of a sequence that matches the element."},{"content":"For example, \"a{2,3}\" matches the target sequence \"aa\" and the target sequence \"aaa\", but not the target sequence \"a\" or the target sequence \"aaaa\".","pos":[7123,7271]},{"content":"A repetition count can also take one of the following forms:","pos":[7278,7338]},{"content":"\"{<ph id=\"ph1\">`min`</ph>}\", or \"<ph id=\"ph2\">\\\\</ph>{<ph id=\"ph3\">`min`</ph><ph id=\"ph4\">\\\\</ph>}\" in <ph id=\"ph5\">`BRE`</ph> and <ph id=\"ph6\">`grep`</ph>.","pos":[7348,7396],"source":"\"{`min`}\", or \"\\\\{`min`\\\\}\" in `BRE` and `grep`."},{"content":"Equivalent to \"{<ph id=\"ph1\">`min`</ph>,<ph id=\"ph2\">`min`</ph>}\".","pos":[7397,7427],"source":" Equivalent to \"{`min`,`min`}\"."},{"content":"\"{<ph id=\"ph1\">`min`</ph>,}\", or \"<ph id=\"ph2\">\\\\</ph>{<ph id=\"ph3\">`min`</ph>,<ph id=\"ph4\">\\\\</ph>}\" in <ph id=\"ph5\">`BRE`</ph> and <ph id=\"ph6\">`grep`</ph>.","pos":[7437,7487],"source":"\"{`min`,}\", or \"\\\\{`min`,\\\\}\" in `BRE` and `grep`."},{"content":"Equivalent to \"{<ph id=\"ph1\">`min`</ph>,unbounded}\".","pos":[7488,7522],"source":" Equivalent to \"{`min`,unbounded}\"."},{"content":"\"*\".","pos":[7532,7536]},{"content":"Equivalent to \"{0,unbounded}\".","pos":[7537,7567]},{"content":"Examples:","pos":[7574,7583]},{"content":"\"a{2}\" matches the target sequence \"aa\" but not the target sequence \"a\" or the target sequence \"aaa\".","pos":[7593,7694]},{"content":"\"a{2,}\" matches the target sequence \"aa\", the target sequence \"aaa\", and so on, but does not match the target sequence \"a\".","pos":[7704,7827]},{"content":"\"a*\" matches the target sequence \"\", the target sequence \"a\", the target sequence \"aa\", and so on.","pos":[7837,7935]},{"pos":[7942,8044],"content":"For all grammars except <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, a repetition count can also take one of the following forms:","source":"For all grammars except `BRE` and `grep`, a repetition count can also take one of the following forms:"},{"content":"\"\".","pos":[8054,8057]},{"content":"Equivalent to \"{0,1}\".","pos":[8058,8080]},{"content":"\"+\".","pos":[8090,8094]},{"content":"Equivalent to \"{1,unbounded}\".","pos":[8095,8125]},{"content":"Examples:","pos":[8132,8141]},{"content":"\"a\" matches the target sequence \"\" and the target sequence \"a\", but not the target sequence \"aa\".","pos":[8151,8248]},{"content":"\"a+\" matches the target sequence \"a\", the target sequence \"aa\", and so on, but not the target sequence \"\".","pos":[8258,8364]},{"pos":[8371,8502],"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, all the forms of repetition count can be followed by the character '', which designates a <bpt id=\"p1\">*</bpt>non-greedy repetition<ept id=\"p1\">*</ept>.","source":"In `ECMAScript`, all the forms of repetition count can be followed by the character '', which designates a *non-greedy repetition*."},{"pos":[8512,8525],"content":"Concatenation","linkify":"Concatenation","nodes":[{"content":"Concatenation","pos":[0,13]}]},{"content":"Regular expression elements, with or without <bpt id=\"p1\">*</bpt>repetition counts<ept id=\"p1\">*</ept>, can be concatenated to form longer regular expressions.","pos":[8529,8650],"source":"Regular expression elements, with or without *repetition counts*, can be concatenated to form longer regular expressions."},{"content":"The resulting expression matches a target sequence that is a concatenation of the sequences that are matched by the individual elements.","pos":[8651,8787]},{"content":"For example, \"a{2,3}b\" matches the target sequence \"aab\" and the target sequence \"aaab\", but does not match the target sequence \"ab\" or the target sequence \"aaaab\".","pos":[8788,8952]},{"pos":[8962,8973],"content":"Alternation","linkify":"Alternation","nodes":[{"content":"Alternation","pos":[0,11]}]},{"content":"In all regular expression grammars except <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, a concatenated regular expression can be followed by the character '&amp;#124;' and another concatenated regular expression.","pos":[8977,9157],"source":"In all regular expression grammars except `BRE` and `grep`, a concatenated regular expression can be followed by the character '&#124;' and another concatenated regular expression."},{"content":"Any number of concatenated regular expressions can be combined in this manner.","pos":[9158,9236]},{"content":"The resulting expression matches any target sequence that matches one or more of the concatenated regular expressions.","pos":[9237,9355]},{"content":"When more than one of the concatenated regular expressions matches the target sequence, <ph id=\"ph1\">`ECMAScript`</ph> chooses the first of the concatenated regular expressions that matches the sequence as the match (<bpt id=\"p1\">*</bpt>first match<ept id=\"p1\">*</ept>); the other regular expression grammars choose the one that achieves the <bpt id=\"p2\">*</bpt>longest match<ept id=\"p2\">*</ept>.","pos":[9362,9664],"source":"When more than one of the concatenated regular expressions matches the target sequence, `ECMAScript` chooses the first of the concatenated regular expressions that matches the sequence as the match (*first match*); the other regular expression grammars choose the one that achieves the *longest match*."},{"content":"For example, \"ab&amp;#124;cd\" matches the target sequence \"ab\" and the target sequence \"cd\", but does not match the target sequence \"abd\" or the target sequence \"acd\".","pos":[9665,9828],"source":" For example, \"ab&#124;cd\" matches the target sequence \"ab\" and the target sequence \"cd\", but does not match the target sequence \"abd\" or the target sequence \"acd\"."},{"pos":[9835,9922],"content":"In <ph id=\"ph1\">`grep`</ph> and <ph id=\"ph2\">`egrep`</ph>, a newline character ('\\n') can be used to separate alternations.","source":"In `grep` and `egrep`, a newline character ('\\n') can be used to separate alternations."},{"pos":[9932,9945],"content":"Subexpression","linkify":"Subexpression","nodes":[{"content":"Subexpression","pos":[0,13]}]},{"content":"In <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, a subexpression is a concatenation.","pos":[9949,10005],"source":"In `BRE` and `grep`, a subexpression is a concatenation."},{"content":"In the other regular expression grammars, a subexpression is an alternation.","pos":[10006,10082]},{"pos":[10092,10137],"content":"<bpt id=\"p1\">&lt;a name=\"grammarsummary\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Grammar Summary","linkify":"<a name=\"grammarsummary\"></a> Grammar Summary","source":"<a name=\"grammarsummary\"></a> Grammar Summary"},{"content":"The following table summarizes the features that are available in the various regular expression grammars:","pos":[10141,10247]},{"content":"Element","pos":[10254,10261]},{"content":"BRE","pos":[10262,10265]},{"content":"ERE","pos":[10266,10269]},{"content":"ECMA","pos":[10270,10274]},{"content":"grep","pos":[10275,10279]},{"content":"egrep","pos":[10280,10285]},{"content":"awk","pos":[10286,10289]},{"content":"alternation using '&amp;#124;'","pos":[10376,10402],"source":"alternation using '&#124;'"},{"content":"alternation using '\\n'","pos":[10417,10439]},{"content":"anchor","pos":[10452,10458]},{"content":"back reference","pos":[10475,10489]},{"content":"bracket expression","pos":[10503,10521]},{"content":"capture group using \"()\"","pos":[10538,10562]},{"content":"capture group using \"<ph id=\"ph1\">\\\\</ph>(<ph id=\"ph2\">\\\\</ph>)\"","pos":[10577,10605],"source":"capture group using \"\\\\(\\\\)\""},{"content":"control escape sequence","pos":[10618,10641]},{"content":"dsw character escape","pos":[10653,10673]},{"content":"file format escape","pos":[10685,10703]},{"content":"hexadecimal escape sequence","pos":[10716,10743]},{"content":"identity escape","pos":[10755,10770]},{"content":"negative assert","pos":[10787,10802]},{"content":"negative word boundary assert","pos":[10814,10843]},{"content":"non-capture group","pos":[10855,10872]},{"content":"non-greedy repetition","pos":[10884,10905]},{"content":"octal escape sequence","pos":[10917,10938]},{"content":"ordinary character","pos":[10950,10968]},{"content":"positive assert","pos":[10985,11000]},{"content":"repetition using \"{}\"","pos":[11012,11033]},{"content":"repetition using \"<ph id=\"ph1\">\\\\</ph>{<ph id=\"ph2\">\\\\</ph>}\"","pos":[11048,11073],"source":"repetition using \"\\\\{\\\\}\""},{"content":"repetition using '*'","pos":[11086,11106]},{"content":"repetition using '' and '+'","pos":[11123,11150]},{"content":"unicode escape sequence","pos":[11165,11188]},{"content":"wildcard character","pos":[11200,11218]},{"content":"word boundary assert","pos":[11235,11255]},{"pos":[11273,11320],"content":"<bpt id=\"p1\">&lt;a name=\"semanticdetails\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Semantic Details","linkify":"<a name=\"semanticdetails\"></a> Semantic Details","source":"<a name=\"semanticdetails\"></a> Semantic Details"},{"pos":[11330,11336],"content":"Anchor","linkify":"Anchor","nodes":[{"content":"Anchor","pos":[0,6]}]},{"content":"An anchor matches a position in the target string, not a character.","pos":[11340,11407]},{"content":"A '^' matches the beginning of the target string, and a '$' matches the end of the target string.","pos":[11408,11505]},{"pos":[11515,11529],"content":"Back Reference","linkify":"Back Reference","nodes":[{"content":"Back Reference","pos":[0,14]}]},{"content":"A back reference is a backslash that is followed by a decimal value N. It matches the contents of the Nth <bpt id=\"p1\">*</bpt>capture group<ept id=\"p1\">*</ept>.","pos":[11533,11655],"source":"A back reference is a backslash that is followed by a decimal value N. It matches the contents of the Nth *capture group*."},{"content":"The value of N must not be more than the number of capture groups that precede the back reference.","pos":[11656,11754]},{"content":"In <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, the value of N is determined by the decimal digit that follows the backslash.","pos":[11755,11853],"source":" In `BRE` and `grep`, the value of N is determined by the decimal digit that follows the backslash."},{"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, the value of N is determined by all the decimal digits that immediately follow the backslash.","pos":[11854,11964],"source":" In `ECMAScript`, the value of N is determined by all the decimal digits that immediately follow the backslash."},{"content":"Therefore, in <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, the value of N is never more than 9, even if the regular expression has more than nine capture groups.","pos":[11965,12099],"source":" Therefore, in `BRE` and `grep`, the value of N is never more than 9, even if the regular expression has more than nine capture groups."},{"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, the value of N is unbounded.","pos":[12100,12145],"source":" In `ECMAScript`, the value of N is unbounded."},{"content":"Examples:","pos":[12152,12161]},{"content":"\"((a+)(b+))(c+)\\3\" matches the target sequence \"aabbbcbbb\".","pos":[12171,12230]},{"content":"The back reference \"\\3\" matches the text in the third capture group, that is, the \"(b+)\".","pos":[12231,12320]},{"content":"It does not match the target sequence \"aabbbcbb\".","pos":[12321,12370]},{"content":"\"(a)\\2\" is not valid.","pos":[12380,12401]},{"content":"\"(b(((((((((a))))))))))\\10\" has different meanings in <ph id=\"ph1\">`BRE`</ph> and in <ph id=\"ph2\">`ECMAScript`</ph>.","pos":[12411,12491],"source":"\"(b(((((((((a))))))))))\\10\" has different meanings in `BRE` and in `ECMAScript`."},{"content":"In <ph id=\"ph1\">`BRE`</ph> the back reference is \"\\1\".","pos":[12492,12528],"source":" In `BRE` the back reference is \"\\1\"."},{"content":"The back reference matches the contents of the first capture group (that is, the one that begins with \"(b\" and ends with the final \")\" and comes before the back reference), and the final '0' matches the ordinary character '0'.","pos":[12529,12755]},{"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, the back reference is \"\\10\".","pos":[12756,12801],"source":" In `ECMAScript`, the back reference is \"\\10\"."},{"content":"It matches the tenth capture group, that is, the innermost one.","pos":[12802,12865]},{"pos":[12875,12893],"content":"Bracket Expression","linkify":"Bracket Expression","nodes":[{"content":"Bracket Expression","pos":[0,18]}]},{"content":"A bracket expression defines a set of characters and <bpt id=\"p1\">*</bpt>collating elements<ept id=\"p1\">*</ept>.","pos":[12897,12971],"source":"A bracket expression defines a set of characters and *collating elements*."},{"content":"When the bracket expression begins with the character '^' the match succeeds if no elements in the set match the current character in the target sequence.","pos":[12972,13126]},{"content":"Otherwise, the match succeeds if any one of the elements in the set matches the current character in the target sequence.","pos":[13127,13248]},{"pos":[13255,13435],"content":"The set of characters can be defined by listing any combination of <bpt id=\"p1\">*</bpt>individual characters<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>character ranges<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>character classes<ept id=\"p3\">*</ept>, <bpt id=\"p4\">*</bpt>equivalence classes<ept id=\"p4\">*</ept>, and <bpt id=\"p5\">*</bpt>collating symbols<ept id=\"p5\">*</ept>.","source":"The set of characters can be defined by listing any combination of *individual characters*, *character ranges*, *character classes*, *equivalence classes*, and *collating symbols*."},{"pos":[13445,13458],"content":"Capture Group","linkify":"Capture Group","nodes":[{"content":"Capture Group","pos":[0,13]}]},{"content":"A capture group marks its contents as a single unit in the regular expression grammar and labels the target text that matches its contents.","pos":[13462,13601]},{"content":"The label that is associated with each capture group is a number, which is determined by counting the opening parentheses that mark capture groups up to and including the opening parenthesis that marks the current capture group.","pos":[13602,13830]},{"content":"In this implementation, the maximum number of capture groups is 31.","pos":[13831,13898]},{"content":"Examples:","pos":[13905,13914]},{"content":"\"ab+\" matches the target sequence \"abb\", but does not match the target sequence \"abab\".","pos":[13924,14011]},{"content":"\"(ab)+\" does not match the target sequence \"abb\", but matches the target sequence \"abab\".","pos":[14021,14110]},{"content":"\"((a+)(b+))(c+)\" matches the target sequence \"aabbbc\" and associates capture group 1 with the subsequence \"aabbb\", capture group 2 with the subsequence \"aa\", capture group 3 with \"bbb\", and capture group 4 with the subsequence \"c\".","pos":[14120,14351]},{"pos":[14361,14376],"content":"Character Class","linkify":"Character Class","nodes":[{"content":"Character Class","pos":[0,15]}]},{"content":"A character class in a bracket expression adds all the characters in the named class to the character set that is defined by the bracket expression.","pos":[14380,14528]},{"content":"To create a character class, use \"[:\" followed by the name of the class followed by \":]\".","pos":[14529,14618]},{"content":"Internally, names of character classes are recognized by calling <ph id=\"ph1\">`id = traits.lookup_classname`</ph>.","pos":[14619,14715],"source":" Internally, names of character classes are recognized by calling `id = traits.lookup_classname`."},{"content":"A character <ph id=\"ph1\">`ch`</ph> belongs to such a class if <ph id=\"ph2\">`traits.isctype(ch, id)`</ph> returns true.","pos":[14716,14798],"source":" A character `ch` belongs to such a class if `traits.isctype(ch, id)` returns true."},{"content":"The default <ph id=\"ph1\">`regex_traits`</ph> template supports the class names in the following table.","pos":[14799,14883],"source":" The default `regex_traits` template supports the class names in the following table."},{"content":"Class Name","pos":[14890,14900]},{"content":"Description","pos":[14901,14912]},{"content":"\"alnum\"","pos":[14956,14963]},{"content":"lowercase letters, uppercase letters, and digits","pos":[14964,15012]},{"content":"\"alpha\"","pos":[15017,15024]},{"content":"lowercase letters and uppercase letters","pos":[15025,15064]},{"content":"\"blank\"","pos":[15069,15076]},{"content":"space or tab","pos":[15077,15089]},{"content":"\"cntrl\"","pos":[15094,15101]},{"pos":[15102,15137],"content":"the <bpt id=\"p1\">*</bpt>file format escape<ept id=\"p1\">*</ept> characters","source":"the *file format escape* characters"},{"content":"\"digit\"","pos":[15142,15149]},{"content":"digits","pos":[15150,15156]},{"content":"\"graph\"","pos":[15161,15168]},{"content":"lowercase letters, uppercase letters, digits, and punctuation","pos":[15169,15230]},{"content":"\"lower\"","pos":[15235,15242]},{"content":"lowercase letters","pos":[15243,15260]},{"content":"\"print\"","pos":[15265,15272]},{"content":"lowercase letters, uppercase letters, digits, punctuation, and space","pos":[15273,15341]},{"content":"\"punct\"","pos":[15346,15353]},{"content":"punctuation","pos":[15354,15365]},{"content":"\"space\"","pos":[15370,15377]},{"content":"space","pos":[15378,15383]},{"content":"\"upper","pos":[15388,15394]},{"content":"uppercase characters","pos":[15395,15415]},{"content":"\"xdigit\"","pos":[15420,15428]},{"content":"digits, 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'","pos":[15429,15495]},{"content":"\"d\"","pos":[15500,15503]},{"content":"same as digit","pos":[15504,15517]},{"content":"\"s\"","pos":[15522,15525]},{"content":"same as space","pos":[15526,15539]},{"content":"\"w\"","pos":[15544,15547]},{"content":"same as alnum","pos":[15548,15561]},{"pos":[15572,15587],"content":"Character Range","linkify":"Character Range","nodes":[{"content":"Character Range","pos":[0,15]}]},{"content":"A character range in a bracket expression adds all the characters in the range to the character set that is defined by the bracket expression.","pos":[15591,15733]},{"content":"To create a character range, put the character '-' between the first and last characters in the range.","pos":[15734,15836]},{"content":"Doing this puts into the set all characters that have a numeric value that is more than or equal to the numeric value of the first character, and less than or equal to the numeric value of the last character.","pos":[15837,16045]},{"content":"Notice that this set of added characters depends on the platform-specific representation of characters.","pos":[16046,16149]},{"content":"If the character '-' occurs at the beginning or the end of a bracket expression, or as the first or last character of a character range, it represents itself.","pos":[16150,16308]},{"content":"Examples:","pos":[16315,16324]},{"content":"\"[0-7]\" represents the set of characters { '0', '1', '2', '3', '4', '5', '6', '7' }.","pos":[16334,16418]},{"content":"It matches the target sequences \"0\", \"1\", and so on, but not \"a\".","pos":[16419,16484]},{"content":"On systems that use the ASCII character encoding, \"[h-k]\" represents the set of characters { 'h', 'i', 'j', 'k' }.","pos":[16494,16608]},{"content":"It matches the target sequences \"h\", \"i\", and so on, but not \"\\x8A\" or \"0\".","pos":[16609,16684]},{"content":"On systems that use the EBCDIC character encoding, \"[h-k]\" represents the set of characters { 'h', 'i', '\\x8A', '\\x8B', '\\x8C', '\\x8D', '\\x8E', '\\x8F', '\\x90', 'j', 'k' } ('h' is encoded as 0x88 and 'k' is encoded as 0x92).","pos":[16694,16917]},{"content":"It matches the target sequences \"h\", \"i\", \"\\x8A\", and so on, but not \"0\".","pos":[16918,16991]},{"content":"\"[-0-24]\" represents the set of characters { '-', '0', '1', '2', '4' }.","pos":[17001,17072]},{"content":"\"[0-2-]\" represents the set of characters { '0', '1', '2', '-' }.","pos":[17082,17147]},{"content":"On systems that use the ASCII character encoding, \"[+--]\" represents the set of characters { '+', ',', '-' }.","pos":[17157,17266]},{"content":"However, when locale-sensitive ranges are used, the characters in a range are determined by the collation rules for the locale.","pos":[17273,17400]},{"content":"Characters that collate after the first character in the definition of the range and before the last character in the definition of the range are in the set.","pos":[17401,17558]},{"content":"The two end characters are also in the set.","pos":[17559,17602]},{"pos":[17612,17629],"content":"Collating Element","linkify":"Collating Element","nodes":[{"content":"Collating Element","pos":[0,17]}]},{"content":"A collating element is a multi-character sequence that is treated as a single character.","pos":[17633,17721]},{"pos":[17731,17747],"content":"Collating Symbol","linkify":"Collating Symbol","nodes":[{"content":"Collating Symbol","pos":[0,16]}]},{"content":"A collating symbol in a bracket expression adds a <bpt id=\"p1\">*</bpt>collating element<ept id=\"p1\">*</ept> to the set that is defined by the bracket expression.","pos":[17751,17874],"source":"A collating symbol in a bracket expression adds a *collating element* to the set that is defined by the bracket expression."},{"content":"To create a collating symbol, use \"[.\"","pos":[17875,17913]},{"content":"followed by the collating element followed by \".]\".","pos":[17914,17965]},{"pos":[17975,17998],"content":"Control Escape Sequence","linkify":"Control Escape Sequence","nodes":[{"content":"Control Escape Sequence","pos":[0,23]}]},{"content":"A control escape sequence is a backslash followed by the letter 'c' followed by one of the letters 'a' through 'z' or 'A' through 'Z'.","pos":[18002,18136]},{"content":"It matches the ASCII control character that is named by that letter.","pos":[18137,18205]},{"content":"For example, \"\\ci\" matches the target sequence \"\\x09\", because <ph id=\"ph1\">\\&lt;</ph>ctrl-i&gt; has the value 0x09.","pos":[18206,18298],"source":" For example, \"\\ci\" matches the target sequence \"\\x09\", because \\<ctrl-i> has the value 0x09."},{"pos":[18308,18328],"content":"DSW Character Escape","linkify":"DSW Character Escape","nodes":[{"content":"DSW Character Escape","pos":[0,20]}]},{"content":"A dsw character escape is a short name for a character class, as shown in the following table.","pos":[18332,18426]},{"content":"Escape Sequence","pos":[18433,18448]},{"content":"Equivalent Named Class","pos":[18449,18471]},{"content":"Default Named Class","pos":[18472,18491]},{"content":"\"\\d\"","pos":[18577,18581]},{"content":"\"[[:d:]]\"","pos":[18582,18591]},{"content":"\"[[:digit:]]\"","pos":[18592,18605]},{"content":"\"\\D\"","pos":[18610,18614]},{"content":"\"[^[:d:]]\"","pos":[18615,18625]},{"content":"\"[^[:digit:]]\"","pos":[18626,18640]},{"content":"\"\\s\"","pos":[18645,18649]},{"content":"\"[[:s:]]\"","pos":[18650,18659]},{"content":"\"[[:space:]]\"","pos":[18660,18673]},{"content":"\"\\S\"","pos":[18678,18682]},{"content":"\"[^[:s:]]\"","pos":[18683,18693]},{"content":"\"[^[:space:]]\"","pos":[18694,18708]},{"content":"\"\\w\"","pos":[18713,18717]},{"content":"\"[[:w:]]\"","pos":[18718,18727]},{"content":"\"[a-zA-Z0-9_]\"*","pos":[18728,18743]},{"content":"\"\\W\"","pos":[18748,18752]},{"content":"\"[^[:w:]]\"","pos":[18753,18763]},{"content":"\"[^a-zA-Z0-9_]\"*","pos":[18764,18780]},{"content":"*ASCII character set","pos":[18788,18808]},{"pos":[18818,18835],"content":"Equivalence Class","linkify":"Equivalence Class","nodes":[{"content":"Equivalence Class","pos":[0,17]}]},{"content":"An equivalence class in a bracket expression adds all the characters and <bpt id=\"p1\">*</bpt>collating elements<ept id=\"p1\">*</ept> that are equivalent to the collating element in the equivalence class definition to the set that is defined by the bracket expression.","pos":[18839,19067],"source":"An equivalence class in a bracket expression adds all the characters and *collating elements* that are equivalent to the collating element in the equivalence class definition to the set that is defined by the bracket expression."},{"content":"To create an equivalence class, use \"[=\" followed by a collating element followed by \"=]\".","pos":[19068,19158]},{"content":"Internally, two collating elements <ph id=\"ph1\">`elt1`</ph> and <ph id=\"ph2\">`elt2`</ph> are equivalent if <ph id=\"ph3\">`traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`</ph>.","pos":[19159,19337],"source":" Internally, two collating elements `elt1` and `elt2` are equivalent if `traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`."},{"pos":[19347,19365],"content":"File Format Escape","linkify":"File Format Escape","nodes":[{"content":"File Format Escape","pos":[0,18]}]},{"content":"A file format escape consists of the usual C language character escape sequences, \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">\\\\</ph>\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", \"\\v\".These have the usual meanings, that is, backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively.","pos":[19369,19653],"source":"A file format escape consists of the usual C language character escape sequences, \"\\\\\\\\\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", \"\\v\".These have the usual meanings, that is, backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively."},{"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, \"\\a\" and \"\\b\" are not allowed.","pos":[19654,19701],"source":" In `ECMAScript`, \"\\a\" and \"\\b\" are not allowed."},{"content":"(\"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">\\\\</ph>\" is allowed, but it is an identity escape, not a file format escape).","pos":[19702,19778],"source":" (\"\\\\\\\\\" is allowed, but it is an identity escape, not a file format escape)."},{"pos":[19788,19815],"content":"Hexadecimal Escape Sequence","linkify":"Hexadecimal Escape Sequence","nodes":[{"content":"Hexadecimal Escape Sequence","pos":[0,27]}]},{"content":"A hexadecimal escape sequence is a backslash followed by the letter 'x' followed by two hexadecimal digits (0-9a-fA-F).","pos":[19819,19938]},{"content":"It matches a character in the target sequence that has the value that is specified by the two digits.","pos":[19939,20040]},{"content":"For example, \"\\x41\" matches the target sequence \"A\" when ASCII character encoding is used.","pos":[20041,20131]},{"pos":[20141,20156],"content":"Identity Escape","linkify":"Identity Escape","nodes":[{"content":"Identity Escape","pos":[0,15]}]},{"content":"An identity escape is a backslash followed by a single character.","pos":[20160,20225]},{"content":"It matches that character.","pos":[20226,20252]},{"content":"It is required when the character has a special meaning; by using the identity escape, the special meaning is removed.","pos":[20253,20371]},{"content":"For example:","pos":[20372,20384]},{"content":"\"a*\" matches the target sequence \"aaa\", but does not match the target sequence \"a<ph id=\"ph1\">\\*</ph>\".","pos":[20394,20479],"source":"\"a*\" matches the target sequence \"aaa\", but does not match the target sequence \"a\\*\"."},{"content":"\"a<ph id=\"ph1\">\\\\</ph>*\" does not match the target sequence \"aaa\", but matches the target sequence \"a<ph id=\"ph2\">\\*</ph>\".","pos":[20489,20576],"source":"\"a\\\\*\" does not match the target sequence \"aaa\", but matches the target sequence \"a\\*\"."},{"content":"The set of characters that are allowed in an identity escape depends on the regular expression grammar, as shown in the following table.","pos":[20583,20719]},{"content":"Grammar","pos":[20726,20733]},{"content":"Allowed Identity Escape Characters","pos":[20734,20768]},{"pos":[20832,20845],"content":"<ph id=\"ph1\">`BRE`</ph>, <ph id=\"ph2\">`grep`</ph>","source":"`BRE`, `grep`"},{"content":"{ '(', ')', '{', '}', '.', '[', '<ph id=\"ph1\">\\\\</ph>', '*', '^', '$' }","pos":[20846,20899],"source":"{ '(', ')', '{', '}', '.', '[', '\\\\', '*', '^', '$' }"},{"pos":[20904,20917],"content":"<ph id=\"ph1\">`ERE`</ph>, <ph id=\"ph2\">`egre`</ph>","source":"`ERE`, `egre`"},{"content":"{ '(', ')', '{', '.', '[', '<ph id=\"ph1\">\\\\</ph>', '*', '^', '$', '+', '', '&amp;#124;' }","pos":[20918,20985],"source":"{ '(', ')', '{', '.', '[', '\\\\', '*', '^', '$', '+', '', '&#124;' }"},{"pos":[20996,21019],"content":"<ph id=\"ph1\">`ERE`</ph> plus { '\"', '/' }","source":"`ERE` plus { '\"', '/' }"},{"content":"All characters except those that can be part of an identifier.","pos":[21037,21099]},{"content":"Typically, this includes letters, digits, '$', '_', and unicode escape sequences.","pos":[21100,21181]},{"content":"For more information, see the ECMAScript Language Specification.","pos":[21182,21246]},{"pos":[21257,21277],"content":"Individual Character","linkify":"Individual Character","nodes":[{"content":"Individual Character","pos":[0,20]}]},{"content":"An individual character in a bracket expression adds that character to the character set that is defined by the bracket expression.","pos":[21281,21412]},{"content":"Anywhere in a bracket expression except at the beginning, a '^' represents itself.","pos":[21413,21495]},{"content":"Examples:","pos":[21502,21511]},{"content":"\"[abc]\" matches the target sequences \"a\", \"b\", and \"c\", but not the sequence \"d\".","pos":[21521,21602]},{"content":"\"[^abc]\" matches the target sequence \"d\", but not the target sequences \"a\", \"b\", or \"c\".","pos":[21612,21700]},{"content":"\"[a^bc]\" matches the target sequences \"a\", \"b\", \"c\", and \"^\", but not the target sequence \"d\".","pos":[21710,21804]},{"pos":[21811,22004],"content":"In all regular expression grammars except <ph id=\"ph1\">`ECMAScript`</ph>, if a ']' is the first character that follows the opening '[' or is the first character that follows an initial '^', it represents itself.","source":"In all regular expression grammars except `ECMAScript`, if a ']' is the first character that follows the opening '[' or is the first character that follows an initial '^', it represents itself."},{"content":"Examples:","pos":[22011,22020]},{"content":"\"[]a\" is invalid because there is no ']' to end the bracket expression.","pos":[22030,22101]},{"content":"\"[]abc]\" matches the target sequences \"a\", \"b\", \"c\", and \"]\", but not the target sequence \"d\".","pos":[22111,22205]},{"content":"\"[^]abc]\" matches the target sequence \"d\", but not the target sequences \"a\", \"b\", \"c\", or \"]\".","pos":[22215,22309]},{"pos":[22316,22398],"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, use '<ph id=\"ph2\">\\\\</ph>]' to represent the character ']' in a bracket expression.","source":"In `ECMAScript`, use '\\\\]' to represent the character ']' in a bracket expression."},{"content":"Examples:","pos":[22405,22414]},{"content":"\"[]a\" matches the target sequence \"a\" because the bracket expression is empty.","pos":[22424,22502]},{"content":"\"[<ph id=\"ph1\">\\\\</ph>]abc]\" matches the target sequences \"a\", \"b\", \"c\", and \"]\" but not the target sequence \"d\".","pos":[22512,22607],"source":"\"[\\\\]abc]\" matches the target sequences \"a\", \"b\", \"c\", and \"]\" but not the target sequence \"d\"."},{"pos":[22617,22632],"content":"Negative Assert","linkify":"Negative Assert","nodes":[{"content":"Negative Assert","pos":[0,15]}]},{"content":"A negative assert matches anything but its contents.","pos":[22636,22688]},{"content":"It does not consume any characters in the target sequence.","pos":[22689,22747]},{"content":"For example, \"(!aa)(a*)\" matches the target sequence \"a\" and associates capture group 1 with the subsequence \"a\".","pos":[22748,22861]},{"content":"It does not match the target sequence \"aa\" or the target sequence \"aaa\".","pos":[22862,22934]},{"pos":[22944,22973],"content":"Negative Word Boundary Assert","linkify":"Negative Word Boundary Assert","nodes":[{"content":"Negative Word Boundary Assert","pos":[0,29]}]},{"pos":[22977,23105],"content":"A negative word boundary assert matches if the current position in the target string is not immediately after a <bpt id=\"p1\">*</bpt>word boundary<ept id=\"p1\">*</ept>.","source":"A negative word boundary assert matches if the current position in the target string is not immediately after a *word boundary*."},{"pos":[23115,23132],"content":"Non-capture Group","linkify":"Non-capture Group","nodes":[{"content":"Non-capture Group","pos":[0,17]}]},{"content":"A non-capture group marks its contents as a single unit in the regular expression grammar, but does not label the target text.","pos":[23136,23262]},{"content":"For example, \"(a)(:b)*(c) matches the target text \"abbc\" and associates capture group 1 with the subsequence \"a\" and capture group 2 with the subsequence \"c\".","pos":[23263,23421]},{"pos":[23431,23452],"content":"Non-greedy Repetition","linkify":"Non-greedy Repetition","nodes":[{"content":"Non-greedy Repetition","pos":[0,21]}]},{"content":"A non-greedy repetition consumes the shortest subsequence of the target sequence that matches the pattern.","pos":[23456,23562]},{"content":"A greedy repetition consumes the longest.","pos":[23563,23604]},{"content":"For example, \"(a+)(a*b)\" matches the target sequence \"aaab\".","pos":[23605,23665]},{"content":"When a non-greedy repetition is used, it associates capture group 1 with the subsequence \"a\" at the beginning of the target sequence and capture group 2 with the subsequence \"aab\" at the end of the target sequence.","pos":[23666,23880]},{"content":"When a greedy match is used, it associates capture group 1 with the subsequence \"aaa\" and capture group 2 with the subsequence \"b\".","pos":[23881,24012]},{"pos":[24022,24043],"content":"Octal Escape Sequence","linkify":"Octal Escape Sequence","nodes":[{"content":"Octal Escape Sequence","pos":[0,21]}]},{"content":"An octal escape sequence is a backslash followed by one, two, or three octal digits (0-7).","pos":[24047,24137]},{"content":"It matches a character in the target sequence that has the value that is specified by those digits.","pos":[24138,24237]},{"content":"If all the digits are '0', the sequence is invalid.","pos":[24238,24289]},{"content":"For example, \"\\101\" matches the target sequence \"A\" when ASCII character encoding is used.","pos":[24290,24380]},{"pos":[24390,24408],"content":"Ordinary Character","linkify":"Ordinary Character","nodes":[{"content":"Ordinary Character","pos":[0,18]}]},{"content":"An ordinary character is any valid character that does not have a special meaning in the current grammar.","pos":[24412,24517]},{"pos":[24524,24588],"content":"In <ph id=\"ph1\">`ECMAScript`</ph>, the following characters have special meanings:","source":"In `ECMAScript`, the following characters have special meanings:"},{"content":"^  $  \\  .","pos":[24598,24608]},{"content":"*  +    (  )  [  ]  {  }  &amp;#124;","pos":[24610,24642],"source":"  *  +    (  )  [  ]  {  }  &#124;"},{"pos":[24649,24717],"content":"In <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, the following characters have special meanings:","source":"In `BRE` and `grep`, the following characters have special meanings:"},{"content":".","pos":[24727,24728]},{"content":"[   \\","pos":[24731,24736]},{"pos":[24743,24859],"content":"Also in <ph id=\"ph1\">`BRE`</ph> and <ph id=\"ph2\">`grep`</ph>, the following characters have special meanings when they are used in a particular context:","source":"Also in `BRE` and `grep`, the following characters have special meanings when they are used in a particular context:"},{"content":"'*' has a special meaning in all cases except when it is the first character in a regular expression or the first character that follows an initial '^' in a regular expression, or when it is the first character of a capture group or the first character that follows an initial '^' in a capture group.","pos":[24869,25169]},{"content":"'^' has a special meaning when it is the first character of a regular expression.","pos":[25179,25260]},{"content":"'$' has a special meaning when it is the last character of a regular expression.","pos":[25270,25350]},{"pos":[25357,25434],"content":"In <ph id=\"ph1\">`ERE`</ph>, <ph id=\"ph2\">`egrep`</ph>, and <ph id=\"ph3\">`awk`</ph>, the following characters have special meanings:","source":"In `ERE`, `egrep`, and `awk`, the following characters have special meanings:"},{"content":".","pos":[25444,25445]},{"content":"[   \\   (   *   +      {   &amp;#124;","pos":[25448,25481],"source":"   [   \\   (   *   +      {   &#124;"},{"pos":[25488,25613],"content":"Also in <ph id=\"ph1\">`ERE`</ph>, <ph id=\"ph2\">`egrep`</ph>, and <ph id=\"ph3\">`awk`</ph>, the following characters have special meanings when they are used in a particular context.","source":"Also in `ERE`, `egrep`, and `awk`, the following characters have special meanings when they are used in a particular context."},{"content":"')' has a special meaning when it matches a preceding '('.","pos":[25623,25681]},{"content":"'^' has a special meaning when it is the first character of a regular expression.","pos":[25691,25772]},{"content":"'$' has a special meaning when it is the last character of a regular expression.","pos":[25782,25862]},{"content":"An ordinary character matches the same character in the target sequence.","pos":[25869,25941]},{"content":"By default, this means that the match succeeds if the two characters are represented by the same value.","pos":[25942,26045]},{"content":"In a case-insensitive match, two characters <ph id=\"ph1\">`ch0`</ph> and <ph id=\"ph2\">`ch1`</ph> match if <ph id=\"ph3\">`traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`</ph>.","pos":[26046,26178],"source":" In a case-insensitive match, two characters `ch0` and `ch1` match if `traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`."},{"content":"In a locale-sensitive match, two characters <ph id=\"ph1\">`ch0`</ph> and <ph id=\"ph2\">`ch1`</ph> match if <ph id=\"ph3\">`traits.translate(ch0) == traits.translate(ch1)`</ph>.","pos":[26179,26297],"source":" In a locale-sensitive match, two characters `ch0` and `ch1` match if `traits.translate(ch0) == traits.translate(ch1)`."},{"pos":[26307,26322],"content":"Positive Assert","linkify":"Positive Assert","nodes":[{"content":"Positive Assert","pos":[0,15]}]},{"content":"A positive assert matches its contents, but does not consume any characters in the target sequence.","pos":[26326,26425]},{"content":"Examples:","pos":[26432,26441]},{"content":"\"(=aa)(a*)\" matches the target sequence \"aaaa\" and associates capture group 1 with the subsequence \"aaaa\".","pos":[26451,26557]},{"content":"\"(aa)(a*)\" matches the target sequence \"aaaa\" and associates capture group 1 with the subsequence \"aa\" at the beginning of the target sequence and capture group 2 with the subsequence \"aa\" at the end of the target sequence.","pos":[26567,26790]},{"content":"\"(=aa)(a)&amp;#124;(a)\" matches the target sequence \"a\" and associates capture group 1 with an empty sequence (because the positive assert failed) and capture group 2 with the subsequence \"a\".","pos":[26800,26988],"source":"\"(=aa)(a)&#124;(a)\" matches the target sequence \"a\" and associates capture group 1 with an empty sequence (because the positive assert failed) and capture group 2 with the subsequence \"a\"."},{"content":"It also matches the target sequence \"aa\" and associates capture group 1 with the subsequence \"aa\" and capture group 2 with an empty sequence.","pos":[26989,27130]},{"pos":[27140,27163],"content":"Unicode Escape Sequence","linkify":"Unicode Escape Sequence","nodes":[{"content":"Unicode Escape Sequence","pos":[0,23]}]},{"content":"A unicode escape sequence is a backslash followed by the letter 'u' followed by four hexadecimal digits (0-9a-fA-F).","pos":[27167,27283]},{"content":"It matches a character in the target sequence that has the value that is specified by the four digits.","pos":[27284,27386]},{"content":"For example, \"\\u0041\" matches the target sequence \"A\" when ASCII character encoding is used.","pos":[27387,27479]},{"pos":[27489,27507],"content":"Wildcard Character","linkify":"Wildcard Character","nodes":[{"content":"Wildcard Character","pos":[0,18]}]},{"content":"A wildcard character matches any character in the target expression except a newline.","pos":[27511,27596]},{"pos":[27606,27619],"content":"Word Boundary","linkify":"Word Boundary","nodes":[{"content":"Word Boundary","pos":[0,13]}]},{"content":"A word boundary occurs in the following situations:","pos":[27623,27674]},{"pos":[27684,27796],"content":"The current character is at the beginning of the target sequence and is one of the word characters <ph id=\"ph1\">`A-Za-z0-9_.`</ph>","source":"The current character is at the beginning of the target sequence and is one of the word characters `A-Za-z0-9_.`"},{"content":"The current character position is past the end of the target sequence and the last character in the target sequence is one of the word characters.","pos":[27806,27952]},{"content":"The current character is one of the word characters and the preceding character is not.","pos":[27962,28049]},{"content":"The current character is not one of the word characters and the preceding character is.","pos":[28059,28146]},{"pos":[28156,28176],"content":"Word Boundary Assert","linkify":"Word Boundary Assert","nodes":[{"content":"Word Boundary Assert","pos":[0,20]}]},{"pos":[28180,28297],"content":"A word boundary assert matches when the current position in the target string is immediately after a <bpt id=\"p1\">*</bpt>word boundary<ept id=\"p1\">*</ept>.","source":"A word boundary assert matches when the current position in the target string is immediately after a *word boundary*."},{"pos":[28307,28365],"content":"<bpt id=\"p1\">&lt;a name=\"matchingandsearching\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Matching and Searching","linkify":"<a name=\"matchingandsearching\"></a> Matching and Searching","source":"<a name=\"matchingandsearching\"></a> Matching and Searching"},{"content":"For a regular expression to match a target sequence, the entire regular expression must match the entire target sequence.","pos":[28369,28490]},{"content":"For example, the regular expression \"bcd\" matches the target sequence \"bcd\" but does not match the target sequence \"abcd\" nor the target sequence \"bcde\".","pos":[28491,28644]},{"content":"For a regular expression search to succeed, there must be a subsequence somewhere in the target sequence that matches the regular expression.","pos":[28651,28792]},{"content":"The search typically finds the left-most matching subsequence.","pos":[28793,28855]},{"content":"Examples:","pos":[28862,28871]},{"content":"A search for the regular expression \"bcd\" in the target sequence \"bcd\" succeeds and matches the entire sequence.","pos":[28881,28993]},{"content":"The same search in the target sequence \"abcd\" also succeeds and matches the last three characters.","pos":[28994,29092]},{"content":"The same search in the target sequence \"bcde\" also succeeds and matches the first three characters.","pos":[29093,29192]},{"content":"A search for the regular expression \"bcd\" in the target sequence \"bcdbcd\" succeeds and matches the first three characters.","pos":[29202,29324]},{"content":"If there is more than one subsequence that matches at some location in the target sequence, there are two ways to choose the matching pattern.","pos":[29331,29473]},{"content":"<bpt id=\"p1\">*</bpt>First match<ept id=\"p1\">*</ept> chooses the subsequence that was found first when the regular expression is matched.","pos":[29474,29572],"source":"*First match* chooses the subsequence that was found first when the regular expression is matched."},{"content":"<bpt id=\"p1\">*</bpt>Longest match<ept id=\"p1\">*</ept> chooses the longest subsequence from the ones that match at that location.","pos":[29573,29663],"source":"*Longest match* chooses the longest subsequence from the ones that match at that location."},{"content":"If there is more than one subsequence that has the maximal length, longest match chooses the one that was found first.","pos":[29664,29782]},{"content":"For example, when first match is used, a search for the regular expression \"b&amp;#124;bc\" in the target sequence \"abcd\" matches the subsequence \"b\" because the left-hand term of the alternation matches that subsequence; therefore, first match does not try the right-hand term of the alternation.","pos":[29783,30075],"source":" For example, when first match is used, a search for the regular expression \"b&#124;bc\" in the target sequence \"abcd\" matches the subsequence \"b\" because the left-hand term of the alternation matches that subsequence; therefore, first match does not try the right-hand term of the alternation."},{"content":"When longest match is used, the same search matches \"bc\" because \"bc\" is longer than \"b\".","pos":[30076,30165]},{"content":"A partial match succeeds if the match reaches the end of the target sequence without failing, even if it has not reached the end of the regular expression.","pos":[30172,30327]},{"content":"Therefore, after a partial match succeeds, appending characters to the target sequence could cause a later partial match to fail.","pos":[30328,30457]},{"content":"However, after a partial match fails, appending characters to the target sequence cannot cause a later partial match to succeed.","pos":[30458,30586]},{"content":"For example, with a partial match, \"ab\" matches the target sequence \"a\" but not \"ac\".","pos":[30587,30672]},{"pos":[30682,30721],"content":"<bpt id=\"p1\">&lt;a name=\"formatflags\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Format Flags","linkify":"<a name=\"formatflags\"></a> Format Flags","source":"<a name=\"formatflags\"></a> Format Flags"},{"content":"ECMAScript Format Rules","pos":[30728,30751]},{"content":"sed Format Rules","pos":[30752,30768]},{"content":"Replacement Text","pos":[30769,30785]},{"content":"\"$&amp;\"","pos":[30870,30874],"source":"\"$&\""},{"content":"\"&amp;\"","pos":[30875,30878],"source":"\"&\""},{"pos":[30879,30982],"content":"The character sequence that matches the entire regular expression (<ph id=\"ph1\">`[match[0].first, match[0].second)`</ph>)","source":"The character sequence that matches the entire regular expression (`[match[0].first, match[0].second)`)"},{"content":"\"$$\"","pos":[30987,30991]},{"content":"\"$\"","pos":[30993,30996]},{"content":"\"<ph id=\"ph1\">\\\\</ph>&amp;\"","pos":[31002,31007],"source":"\"\\\\&\""},{"content":"\"&amp;\"","pos":[31008,31011],"source":"\"&\""},{"content":"\"$`\" (dollar sign followed by back quote)","pos":[31016,31057]},{"pos":[31059,31197],"content":"The character sequence that precedes the subsequence that matches the regular expression (<ph id=\"ph1\">`[match.prefix().first, match.prefix().second)`</ph>)","source":"The character sequence that precedes the subsequence that matches the regular expression (`[match.prefix().first, match.prefix().second)`)"},{"content":"\"$'\" (dollar sign followed by forward quote)","pos":[31202,31246]},{"pos":[31248,31385],"content":"The character sequence that follows the subsequence that matches the regular expression (<ph id=\"ph1\">`[match.suffix().first, match.suffix().second)`</ph>)","source":"The character sequence that follows the subsequence that matches the regular expression (`[match.suffix().first, match.suffix().second)`)"},{"content":"\"$n\"","pos":[31390,31394]},{"content":"\"\\n\"","pos":[31395,31399]},{"pos":[31400,31545],"content":"The character sequence that matches the capture group at position <ph id=\"ph1\">`n`</ph>, where <ph id=\"ph2\">`n`</ph> is a number between 0 and 9 (<ph id=\"ph3\">`[match[n].first, match[n].second)`</ph>","source":"The character sequence that matches the capture group at position `n`, where `n` is a number between 0 and 9 (`[match[n].first, match[n].second)`"},{"content":"\"<ph id=\"ph1\">\\\\</ph>\\n\"","pos":[31551,31557],"source":"\"\\\\\\n\""},{"content":"\"\\n\"","pos":[31558,31562]},{"content":"\"$nn\"","pos":[31567,31572]},{"pos":[31574,31725],"content":"The character sequence that matches the capture group at position <ph id=\"ph1\">`nn`</ph>, where <ph id=\"ph2\">`nn`</ph> is a number between 10 and 99 (<ph id=\"ph3\">`[match[nn].first, match[nn].second)`</ph>","source":"The character sequence that matches the capture group at position `nn`, where `nn` is a number between 10 and 99 (`[match[nn].first, match[nn].second)`"},{"pos":[31735,31743],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[31747,31815],"content":"<bpt id=\"p1\">[</bpt>STL Overview<ept id=\"p1\">](../standard-library/cpp-standard-library-overview.md)</ept>","source":"[STL Overview](../standard-library/cpp-standard-library-overview.md)"}],"content":"---\ntitle: \"Regular Expressions (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Visual C++, regular expressions\"\n  - \"regular expressions, Visual C++\"\n  - \"regular expressions [TR1]\"\n  - \"TR1 regular expressions\"\nms.assetid: aafe202a-1d96-4b36-a270-d676dfd3c51c\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Regular Expressions (C++)\nThis topic discusses the grammars of the various regular expression engines.  \n  \n##  <a name=\"regexgrammar\"></a> Regular Expression Grammar  \n  \n### Element  \n An element can be one of the following things:  \n  \n-   An *ordinary character* that matches the same character in the target sequence.  \n  \n-   A *wildcard character* '.' that matches any character in the target sequence except a newline.  \n  \n-   A *bracket expression* of the form \"[`expr`]\", which matches a character or a collation element in the target sequence that is also in the set defined by the expression `expr`, or of the form \"[^`expr`]\", which matches a character or a collation element in the target sequence that is not in the set defined by the expression `expr`.  \n  \n     The expression `expr` can contain any combination of the following things:  \n  \n    -   An individual character. Adds that character to the set defined by `expr`.  \n  \n    -   A *character range* of the form \"`ch1`-`ch2`\". Adds the characters that are represented by values in the closed range [`ch1`, `ch2`] to the set defined by `expr`.  \n  \n    -   A *character class* of the form \"[:`name`:]\". Adds the characters in the named class to the set defined by `expr`.  \n  \n    -   An *equivalence class* of the form \"[=`elt`=]\". Adds the collating elements that are equivalent to `elt` to the set defined by `expr`.  \n  \n    -   A *collating symbol* of the form \"[.`elt`.]\". Adds the collation element `elt` to the set defined by `expr`.  \n  \n-   An *anchor*. Anchor '^' matches the beginning of the target sequence; anchor '$' matches the end of the target sequence.  \n  \n A *capture group* of the form \"( *subexpression* )\", or \"\\\\( *subexpression* \\\\)\" in `BRE` and `grep`, which matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.  \n  \n-   An *identity escape* of the form \"\\\\`k`\", which matches the character `k` in the target sequence.  \n  \n Examples:  \n  \n-   \"a\" matches the target sequence \"a\" but does not match the target sequences \"B\", \"b\", or \"c\".  \n  \n-   \".\" matches all the target sequences \"a\", \"B\", \"b\", and \"c\".  \n  \n-   \"[b-z]\" matches the target sequences \"b\" and \"c\" but does not match the target sequences \"a\" or \"B\".  \n  \n-   \"[:lower:]\" matches the target sequences \"a\", \"b\", and \"c\" but does not match the target sequence \"B\".  \n  \n-   \"(a)\" matches the target sequence \"a\" and associates capture group 1 with the subsequence \"a\", but does not match the target sequences \"B\", \"b\", or \"c\".  \n  \n In `ECMAScript`, `BRE`, and `grep`, an element can also be a *back reference* of the form \"\\\\`dd`\", where `dd` represents a decimal value N that matches a sequence of characters in the target sequence that is the same as the sequence of characters that is matched by the Nth *capture group*. For example, \"(a)\\1\" matches the target sequence \"aa\" because the first (and only) capture group matches the initial sequence \"a\" and then the \\1 matches the final sequence \"a\".  \n  \n In `ECMAScript`, an element can also be one of the following things:  \n  \n-   A *non-capture group* of the form \"(: *subexpression* )\". Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.  \n  \n-   A limited *file format escape* of the form \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\". These match a form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.  \n  \n-   A *positive assert* of the form \"(= *subexpression* )\". Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters, but does not change the match position in the target sequence.  \n  \n-   A *negative assert* of the form \"(! *subexpression* )\". Matches any sequence of characters in the target sequence that does not match the pattern between the delimiters, and does not change the match position in the target sequence.  \n  \n-   A *hexadecimal escape sequence* of the form \"\\x`hh`\". Matches a character in the target sequence that is represented by the two hexadecimal digits `hh`.  \n  \n-   A *unicode escape sequence* of the form \"\\u`hhhh`\". Matches a character in the target sequence that is represented by the four hexadecimal digits `hhhh`.  \n  \n-   A *control escape sequence* of the form \"\\c`k`\". Matches the control character that is named by the character `k`.  \n  \n-   A *word boundary assert* of the form \"\\b\". Matches when the current position in the target sequence is immediately after a *word boundary*.  \n  \n-   A *negative word boundary assert* of the form \"\\B\". Matches when the current position in the target sequence is not immediately after a *word boundary*.  \n  \n-   A *dsw character escape* of the form \"\\d\", \"\\D\", \"\\s\", \"\\S\", \"\\w\", \"\\W\". Provides a short name for a character class.  \n  \n Examples:  \n  \n-   \"(:a)\" matches the target sequence \"a\", but \"(:a)\\1\" is invalid because there is no capture group 1.  \n  \n-   \"(=a)a\" matches the target sequence \"a\". The positive assert matches the initial sequence \"a\" in the target sequence and the final \"a\" in the regular expression matches the initial sequence \"a\" in the target sequence.  \n  \n-   \"(!a)a\" does not match the target sequence \"a\".  \n  \n-   \"a\\b.\" matches the target sequence \"a~\", but does not match the target sequence \"ab\".  \n  \n-   \"a\\B.\" matches the target sequence \"ab\", but does not match the target sequence \"a~\".  \n  \n In `awk`, an element can also be one of the following things:  \n  \n-   A *file format escape* of the form \"\\\\\\\\\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", or \"\\v\". These match a backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.  \n  \n-   An *octal escape sequence* of the form \"\\\\`ooo`\". Matches a character in the target sequence whose representation is the value represented by the one, two, or three octal digits `ooo`.  \n  \n### Repetition  \n Any element other than a *positive assert*, a *negative assert*, or an *anchor* can be followed by a repetition count. The most general kind of repetition count takes the form \"{`min`,`max`}\", or \"\\\\{`min`,`max`\\\\}\" in `BRE` and `grep`. An element that is followed by this form of repetition count matches at least `min` successive occurrences and no more than `max` successive occurrences of a sequence that matches the element. For example, \"a{2,3}\" matches the target sequence \"aa\" and the target sequence \"aaa\", but not the target sequence \"a\" or the target sequence \"aaaa\".  \n  \n A repetition count can also take one of the following forms:  \n  \n-   \"{`min`}\", or \"\\\\{`min`\\\\}\" in `BRE` and `grep`. Equivalent to \"{`min`,`min`}\".  \n  \n-   \"{`min`,}\", or \"\\\\{`min`,\\\\}\" in `BRE` and `grep`. Equivalent to \"{`min`,unbounded}\".  \n  \n-   \"*\". Equivalent to \"{0,unbounded}\".  \n  \n Examples:  \n  \n-   \"a{2}\" matches the target sequence \"aa\" but not the target sequence \"a\" or the target sequence \"aaa\".  \n  \n-   \"a{2,}\" matches the target sequence \"aa\", the target sequence \"aaa\", and so on, but does not match the target sequence \"a\".  \n  \n-   \"a*\" matches the target sequence \"\", the target sequence \"a\", the target sequence \"aa\", and so on.  \n  \n For all grammars except `BRE` and `grep`, a repetition count can also take one of the following forms:  \n  \n-   \"\". Equivalent to \"{0,1}\".  \n  \n-   \"+\". Equivalent to \"{1,unbounded}\".  \n  \n Examples:  \n  \n-   \"a\" matches the target sequence \"\" and the target sequence \"a\", but not the target sequence \"aa\".  \n  \n-   \"a+\" matches the target sequence \"a\", the target sequence \"aa\", and so on, but not the target sequence \"\".  \n  \n In `ECMAScript`, all the forms of repetition count can be followed by the character '', which designates a *non-greedy repetition*.  \n  \n### Concatenation  \n Regular expression elements, with or without *repetition counts*, can be concatenated to form longer regular expressions. The resulting expression matches a target sequence that is a concatenation of the sequences that are matched by the individual elements. For example, \"a{2,3}b\" matches the target sequence \"aab\" and the target sequence \"aaab\", but does not match the target sequence \"ab\" or the target sequence \"aaaab\".  \n  \n### Alternation  \n In all regular expression grammars except `BRE` and `grep`, a concatenated regular expression can be followed by the character '&#124;' and another concatenated regular expression. Any number of concatenated regular expressions can be combined in this manner. The resulting expression matches any target sequence that matches one or more of the concatenated regular expressions.  \n  \n When more than one of the concatenated regular expressions matches the target sequence, `ECMAScript` chooses the first of the concatenated regular expressions that matches the sequence as the match (*first match*); the other regular expression grammars choose the one that achieves the *longest match*. For example, \"ab&#124;cd\" matches the target sequence \"ab\" and the target sequence \"cd\", but does not match the target sequence \"abd\" or the target sequence \"acd\".  \n  \n In `grep` and `egrep`, a newline character ('\\n') can be used to separate alternations.  \n  \n### Subexpression  \n In `BRE` and `grep`, a subexpression is a concatenation. In the other regular expression grammars, a subexpression is an alternation.  \n  \n##  <a name=\"grammarsummary\"></a> Grammar Summary  \n The following table summarizes the features that are available in the various regular expression grammars:  \n  \n|Element|BRE|ERE|ECMA|grep|egrep|awk|  \n|-------------|---------|---------|----------|----------|-----------|---------|  \n|alternation using '&#124;'||+|+||+|+|  \n|alternation using '\\n'||||+|+||  \n|anchor|+|+|+|+|+|+|  \n|back reference|+||+|+|||  \n|bracket expression|+|+|+|+|+|+|  \n|capture group using \"()\"||+|+||+|+|  \n|capture group using \"\\\\(\\\\)\"|+|||+|||  \n|control escape sequence|||+||||  \n|dsw character escape|||+||||  \n|file format escape|||+|||+|  \n|hexadecimal escape sequence|||+||||  \n|identity escape|+|+|+|+|+|+|  \n|negative assert|||+||||  \n|negative word boundary assert|||+||||  \n|non-capture group|||+||||  \n|non-greedy repetition|||+||||  \n|octal escape sequence||||||+|  \n|ordinary character|+|+|+|+|+|+|  \n|positive assert|||+||||  \n|repetition using \"{}\"||+|+||+|+|  \n|repetition using \"\\\\{\\\\}\"|+|||+|||  \n|repetition using '*'|+|+|+|+|+|+|  \n|repetition using '' and '+'||+|+||+|+|  \n|unicode escape sequence|||+||||  \n|wildcard character|+|+|+|+|+|+|  \n|word boundary assert|||+||||  \n  \n##  <a name=\"semanticdetails\"></a> Semantic Details  \n  \n### Anchor  \n An anchor matches a position in the target string, not a character. A '^' matches the beginning of the target string, and a '$' matches the end of the target string.  \n  \n### Back Reference  \n A back reference is a backslash that is followed by a decimal value N. It matches the contents of the Nth *capture group*. The value of N must not be more than the number of capture groups that precede the back reference. In `BRE` and `grep`, the value of N is determined by the decimal digit that follows the backslash. In `ECMAScript`, the value of N is determined by all the decimal digits that immediately follow the backslash. Therefore, in `BRE` and `grep`, the value of N is never more than 9, even if the regular expression has more than nine capture groups. In `ECMAScript`, the value of N is unbounded.  \n  \n Examples:  \n  \n-   \"((a+)(b+))(c+)\\3\" matches the target sequence \"aabbbcbbb\". The back reference \"\\3\" matches the text in the third capture group, that is, the \"(b+)\". It does not match the target sequence \"aabbbcbb\".  \n  \n-   \"(a)\\2\" is not valid.  \n  \n-   \"(b(((((((((a))))))))))\\10\" has different meanings in `BRE` and in `ECMAScript`. In `BRE` the back reference is \"\\1\". The back reference matches the contents of the first capture group (that is, the one that begins with \"(b\" and ends with the final \")\" and comes before the back reference), and the final '0' matches the ordinary character '0'. In `ECMAScript`, the back reference is \"\\10\". It matches the tenth capture group, that is, the innermost one.  \n  \n### Bracket Expression  \n A bracket expression defines a set of characters and *collating elements*. When the bracket expression begins with the character '^' the match succeeds if no elements in the set match the current character in the target sequence. Otherwise, the match succeeds if any one of the elements in the set matches the current character in the target sequence.  \n  \n The set of characters can be defined by listing any combination of *individual characters*, *character ranges*, *character classes*, *equivalence classes*, and *collating symbols*.  \n  \n### Capture Group  \n A capture group marks its contents as a single unit in the regular expression grammar and labels the target text that matches its contents. The label that is associated with each capture group is a number, which is determined by counting the opening parentheses that mark capture groups up to and including the opening parenthesis that marks the current capture group. In this implementation, the maximum number of capture groups is 31.  \n  \n Examples:  \n  \n-   \"ab+\" matches the target sequence \"abb\", but does not match the target sequence \"abab\".  \n  \n-   \"(ab)+\" does not match the target sequence \"abb\", but matches the target sequence \"abab\".  \n  \n-   \"((a+)(b+))(c+)\" matches the target sequence \"aabbbc\" and associates capture group 1 with the subsequence \"aabbb\", capture group 2 with the subsequence \"aa\", capture group 3 with \"bbb\", and capture group 4 with the subsequence \"c\".  \n  \n### Character Class  \n A character class in a bracket expression adds all the characters in the named class to the character set that is defined by the bracket expression. To create a character class, use \"[:\" followed by the name of the class followed by \":]\". Internally, names of character classes are recognized by calling `id = traits.lookup_classname`. A character `ch` belongs to such a class if `traits.isctype(ch, id)` returns true. The default `regex_traits` template supports the class names in the following table.  \n  \n|Class Name|Description|  \n|----------------|-----------------|  \n|\"alnum\"|lowercase letters, uppercase letters, and digits|  \n|\"alpha\"|lowercase letters and uppercase letters|  \n|\"blank\"|space or tab|  \n|\"cntrl\"|the *file format escape* characters|  \n|\"digit\"|digits|  \n|\"graph\"|lowercase letters, uppercase letters, digits, and punctuation|  \n|\"lower\"|lowercase letters|  \n|\"print\"|lowercase letters, uppercase letters, digits, punctuation, and space|  \n|\"punct\"|punctuation|  \n|\"space\"|space|  \n|\"upper|uppercase characters|  \n|\"xdigit\"|digits, 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'|  \n|\"d\"|same as digit|  \n|\"s\"|same as space|  \n|\"w\"|same as alnum|  \n  \n### Character Range  \n A character range in a bracket expression adds all the characters in the range to the character set that is defined by the bracket expression. To create a character range, put the character '-' between the first and last characters in the range. Doing this puts into the set all characters that have a numeric value that is more than or equal to the numeric value of the first character, and less than or equal to the numeric value of the last character. Notice that this set of added characters depends on the platform-specific representation of characters. If the character '-' occurs at the beginning or the end of a bracket expression, or as the first or last character of a character range, it represents itself.  \n  \n Examples:  \n  \n-   \"[0-7]\" represents the set of characters { '0', '1', '2', '3', '4', '5', '6', '7' }. It matches the target sequences \"0\", \"1\", and so on, but not \"a\".  \n  \n-   On systems that use the ASCII character encoding, \"[h-k]\" represents the set of characters { 'h', 'i', 'j', 'k' }. It matches the target sequences \"h\", \"i\", and so on, but not \"\\x8A\" or \"0\".  \n  \n-   On systems that use the EBCDIC character encoding, \"[h-k]\" represents the set of characters { 'h', 'i', '\\x8A', '\\x8B', '\\x8C', '\\x8D', '\\x8E', '\\x8F', '\\x90', 'j', 'k' } ('h' is encoded as 0x88 and 'k' is encoded as 0x92). It matches the target sequences \"h\", \"i\", \"\\x8A\", and so on, but not \"0\".  \n  \n-   \"[-0-24]\" represents the set of characters { '-', '0', '1', '2', '4' }.  \n  \n-   \"[0-2-]\" represents the set of characters { '0', '1', '2', '-' }.  \n  \n-   On systems that use the ASCII character encoding, \"[+--]\" represents the set of characters { '+', ',', '-' }.  \n  \n However, when locale-sensitive ranges are used, the characters in a range are determined by the collation rules for the locale. Characters that collate after the first character in the definition of the range and before the last character in the definition of the range are in the set. The two end characters are also in the set.  \n  \n### Collating Element  \n A collating element is a multi-character sequence that is treated as a single character.  \n  \n### Collating Symbol  \n A collating symbol in a bracket expression adds a *collating element* to the set that is defined by the bracket expression. To create a collating symbol, use \"[.\" followed by the collating element followed by \".]\".  \n  \n### Control Escape Sequence  \n A control escape sequence is a backslash followed by the letter 'c' followed by one of the letters 'a' through 'z' or 'A' through 'Z'. It matches the ASCII control character that is named by that letter. For example, \"\\ci\" matches the target sequence \"\\x09\", because \\<ctrl-i> has the value 0x09.  \n  \n### DSW Character Escape  \n A dsw character escape is a short name for a character class, as shown in the following table.  \n  \n|Escape Sequence|Equivalent Named Class|Default Named Class|  \n|---------------------|----------------------------|-------------------------|  \n|\"\\d\"|\"[[:d:]]\"|\"[[:digit:]]\"|  \n|\"\\D\"|\"[^[:d:]]\"|\"[^[:digit:]]\"|  \n|\"\\s\"|\"[[:s:]]\"|\"[[:space:]]\"|  \n|\"\\S\"|\"[^[:s:]]\"|\"[^[:space:]]\"|  \n|\"\\w\"|\"[[:w:]]\"|\"[a-zA-Z0-9_]\"*|  \n|\"\\W\"|\"[^[:w:]]\"|\"[^a-zA-Z0-9_]\"*|  \n  \n *ASCII character set  \n  \n### Equivalence Class  \n An equivalence class in a bracket expression adds all the characters and *collating elements* that are equivalent to the collating element in the equivalence class definition to the set that is defined by the bracket expression. To create an equivalence class, use \"[=\" followed by a collating element followed by \"=]\". Internally, two collating elements `elt1` and `elt2` are equivalent if `traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`.  \n  \n### File Format Escape  \n A file format escape consists of the usual C language character escape sequences, \"\\\\\\\\\", \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", \"\\v\".These have the usual meanings, that is, backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively. In `ECMAScript`, \"\\a\" and \"\\b\" are not allowed. (\"\\\\\\\\\" is allowed, but it is an identity escape, not a file format escape).  \n  \n### Hexadecimal Escape Sequence  \n A hexadecimal escape sequence is a backslash followed by the letter 'x' followed by two hexadecimal digits (0-9a-fA-F). It matches a character in the target sequence that has the value that is specified by the two digits. For example, \"\\x41\" matches the target sequence \"A\" when ASCII character encoding is used.  \n  \n### Identity Escape  \n An identity escape is a backslash followed by a single character. It matches that character. It is required when the character has a special meaning; by using the identity escape, the special meaning is removed. For example:  \n  \n-   \"a*\" matches the target sequence \"aaa\", but does not match the target sequence \"a\\*\".  \n  \n-   \"a\\\\*\" does not match the target sequence \"aaa\", but matches the target sequence \"a\\*\".  \n  \n The set of characters that are allowed in an identity escape depends on the regular expression grammar, as shown in the following table.  \n  \n|Grammar|Allowed Identity Escape Characters|  \n|-------------|----------------------------------------|  \n|`BRE`, `grep`|{ '(', ')', '{', '}', '.', '[', '\\\\', '*', '^', '$' }|  \n|`ERE`, `egre`|{ '(', ')', '{', '.', '[', '\\\\', '*', '^', '$', '+', '', '&#124;' }|  \n|`awk`|`ERE` plus { '\"', '/' }|  \n|`ECMAScript`|All characters except those that can be part of an identifier. Typically, this includes letters, digits, '$', '_', and unicode escape sequences. For more information, see the ECMAScript Language Specification.|  \n  \n### Individual Character  \n An individual character in a bracket expression adds that character to the character set that is defined by the bracket expression. Anywhere in a bracket expression except at the beginning, a '^' represents itself.  \n  \n Examples:  \n  \n-   \"[abc]\" matches the target sequences \"a\", \"b\", and \"c\", but not the sequence \"d\".  \n  \n-   \"[^abc]\" matches the target sequence \"d\", but not the target sequences \"a\", \"b\", or \"c\".  \n  \n-   \"[a^bc]\" matches the target sequences \"a\", \"b\", \"c\", and \"^\", but not the target sequence \"d\".  \n  \n In all regular expression grammars except `ECMAScript`, if a ']' is the first character that follows the opening '[' or is the first character that follows an initial '^', it represents itself.  \n  \n Examples:  \n  \n-   \"[]a\" is invalid because there is no ']' to end the bracket expression.  \n  \n-   \"[]abc]\" matches the target sequences \"a\", \"b\", \"c\", and \"]\", but not the target sequence \"d\".  \n  \n-   \"[^]abc]\" matches the target sequence \"d\", but not the target sequences \"a\", \"b\", \"c\", or \"]\".  \n  \n In `ECMAScript`, use '\\\\]' to represent the character ']' in a bracket expression.  \n  \n Examples:  \n  \n-   \"[]a\" matches the target sequence \"a\" because the bracket expression is empty.  \n  \n-   \"[\\\\]abc]\" matches the target sequences \"a\", \"b\", \"c\", and \"]\" but not the target sequence \"d\".  \n  \n### Negative Assert  \n A negative assert matches anything but its contents. It does not consume any characters in the target sequence. For example, \"(!aa)(a*)\" matches the target sequence \"a\" and associates capture group 1 with the subsequence \"a\". It does not match the target sequence \"aa\" or the target sequence \"aaa\".  \n  \n### Negative Word Boundary Assert  \n A negative word boundary assert matches if the current position in the target string is not immediately after a *word boundary*.  \n  \n### Non-capture Group  \n A non-capture group marks its contents as a single unit in the regular expression grammar, but does not label the target text. For example, \"(a)(:b)*(c) matches the target text \"abbc\" and associates capture group 1 with the subsequence \"a\" and capture group 2 with the subsequence \"c\".  \n  \n### Non-greedy Repetition  \n A non-greedy repetition consumes the shortest subsequence of the target sequence that matches the pattern. A greedy repetition consumes the longest. For example, \"(a+)(a*b)\" matches the target sequence \"aaab\". When a non-greedy repetition is used, it associates capture group 1 with the subsequence \"a\" at the beginning of the target sequence and capture group 2 with the subsequence \"aab\" at the end of the target sequence. When a greedy match is used, it associates capture group 1 with the subsequence \"aaa\" and capture group 2 with the subsequence \"b\".  \n  \n### Octal Escape Sequence  \n An octal escape sequence is a backslash followed by one, two, or three octal digits (0-7). It matches a character in the target sequence that has the value that is specified by those digits. If all the digits are '0', the sequence is invalid. For example, \"\\101\" matches the target sequence \"A\" when ASCII character encoding is used.  \n  \n### Ordinary Character  \n An ordinary character is any valid character that does not have a special meaning in the current grammar.  \n  \n In `ECMAScript`, the following characters have special meanings:  \n  \n-   ^  $  \\  .  *  +    (  )  [  ]  {  }  &#124;  \n  \n In `BRE` and `grep`, the following characters have special meanings:  \n  \n-   .   [   \\  \n  \n Also in `BRE` and `grep`, the following characters have special meanings when they are used in a particular context:  \n  \n-   '*' has a special meaning in all cases except when it is the first character in a regular expression or the first character that follows an initial '^' in a regular expression, or when it is the first character of a capture group or the first character that follows an initial '^' in a capture group.  \n  \n-   '^' has a special meaning when it is the first character of a regular expression.  \n  \n-   '$' has a special meaning when it is the last character of a regular expression.  \n  \n In `ERE`, `egrep`, and `awk`, the following characters have special meanings:  \n  \n-   .   [   \\   (   *   +      {   &#124;  \n  \n Also in `ERE`, `egrep`, and `awk`, the following characters have special meanings when they are used in a particular context.  \n  \n-   ')' has a special meaning when it matches a preceding '('.  \n  \n-   '^' has a special meaning when it is the first character of a regular expression.  \n  \n-   '$' has a special meaning when it is the last character of a regular expression.  \n  \n An ordinary character matches the same character in the target sequence. By default, this means that the match succeeds if the two characters are represented by the same value. In a case-insensitive match, two characters `ch0` and `ch1` match if `traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`. In a locale-sensitive match, two characters `ch0` and `ch1` match if `traits.translate(ch0) == traits.translate(ch1)`.  \n  \n### Positive Assert  \n A positive assert matches its contents, but does not consume any characters in the target sequence.  \n  \n Examples:  \n  \n-   \"(=aa)(a*)\" matches the target sequence \"aaaa\" and associates capture group 1 with the subsequence \"aaaa\".  \n  \n-   \"(aa)(a*)\" matches the target sequence \"aaaa\" and associates capture group 1 with the subsequence \"aa\" at the beginning of the target sequence and capture group 2 with the subsequence \"aa\" at the end of the target sequence.  \n  \n-   \"(=aa)(a)&#124;(a)\" matches the target sequence \"a\" and associates capture group 1 with an empty sequence (because the positive assert failed) and capture group 2 with the subsequence \"a\". It also matches the target sequence \"aa\" and associates capture group 1 with the subsequence \"aa\" and capture group 2 with an empty sequence.  \n  \n### Unicode Escape Sequence  \n A unicode escape sequence is a backslash followed by the letter 'u' followed by four hexadecimal digits (0-9a-fA-F). It matches a character in the target sequence that has the value that is specified by the four digits. For example, \"\\u0041\" matches the target sequence \"A\" when ASCII character encoding is used.  \n  \n### Wildcard Character  \n A wildcard character matches any character in the target expression except a newline.  \n  \n### Word Boundary  \n A word boundary occurs in the following situations:  \n  \n-   The current character is at the beginning of the target sequence and is one of the word characters `A-Za-z0-9_.`  \n  \n-   The current character position is past the end of the target sequence and the last character in the target sequence is one of the word characters.  \n  \n-   The current character is one of the word characters and the preceding character is not.  \n  \n-   The current character is not one of the word characters and the preceding character is.  \n  \n### Word Boundary Assert  \n A word boundary assert matches when the current position in the target string is immediately after a *word boundary*.  \n  \n##  <a name=\"matchingandsearching\"></a> Matching and Searching  \n For a regular expression to match a target sequence, the entire regular expression must match the entire target sequence. For example, the regular expression \"bcd\" matches the target sequence \"bcd\" but does not match the target sequence \"abcd\" nor the target sequence \"bcde\".  \n  \n For a regular expression search to succeed, there must be a subsequence somewhere in the target sequence that matches the regular expression. The search typically finds the left-most matching subsequence.  \n  \n Examples:  \n  \n-   A search for the regular expression \"bcd\" in the target sequence \"bcd\" succeeds and matches the entire sequence. The same search in the target sequence \"abcd\" also succeeds and matches the last three characters. The same search in the target sequence \"bcde\" also succeeds and matches the first three characters.  \n  \n-   A search for the regular expression \"bcd\" in the target sequence \"bcdbcd\" succeeds and matches the first three characters.  \n  \n If there is more than one subsequence that matches at some location in the target sequence, there are two ways to choose the matching pattern. *First match* chooses the subsequence that was found first when the regular expression is matched. *Longest match* chooses the longest subsequence from the ones that match at that location. If there is more than one subsequence that has the maximal length, longest match chooses the one that was found first. For example, when first match is used, a search for the regular expression \"b&#124;bc\" in the target sequence \"abcd\" matches the subsequence \"b\" because the left-hand term of the alternation matches that subsequence; therefore, first match does not try the right-hand term of the alternation. When longest match is used, the same search matches \"bc\" because \"bc\" is longer than \"b\".  \n  \n A partial match succeeds if the match reaches the end of the target sequence without failing, even if it has not reached the end of the regular expression. Therefore, after a partial match succeeds, appending characters to the target sequence could cause a later partial match to fail. However, after a partial match fails, appending characters to the target sequence cannot cause a later partial match to succeed. For example, with a partial match, \"ab\" matches the target sequence \"a\" but not \"ac\".  \n  \n##  <a name=\"formatflags\"></a> Format Flags  \n  \n|ECMAScript Format Rules|sed Format Rules|Replacement Text|  \n|-----------------------------|----------------------|----------------------|  \n|\"$&\"|\"&\"|The character sequence that matches the entire regular expression (`[match[0].first, match[0].second)`)|  \n|\"$$\"||\"$\"|  \n||\"\\\\&\"|\"&\"|  \n|\"$`\" (dollar sign followed by back quote)||The character sequence that precedes the subsequence that matches the regular expression (`[match.prefix().first, match.prefix().second)`)|  \n|\"$'\" (dollar sign followed by forward quote)||The character sequence that follows the subsequence that matches the regular expression (`[match.suffix().first, match.suffix().second)`)|  \n|\"$n\"|\"\\n\"|The character sequence that matches the capture group at position `n`, where `n` is a number between 0 and 9 (`[match[n].first, match[n].second)`|  \n||\"\\\\\\n\"|\"\\n\"|  \n|\"$nn\"||The character sequence that matches the capture group at position `nn`, where `nn` is a number between 10 and 99 (`[match[nn].first, match[nn].second)`|  \n  \n## See Also  \n [STL Overview](../standard-library/cpp-standard-library-overview.md)\n\n"}