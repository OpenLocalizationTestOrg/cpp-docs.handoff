{"nodes":[{"pos":[12,65],"content":"String and Character Literals  (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"String and Character Literals  (C++) | Microsoft Docs","pos":[0,53]}]},{"content":"String and Character Literals  (C++)","pos":[930,966]},{"content":"C++ supports various string and character types, and provides ways to express literal values of each of these types.","pos":[967,1083]},{"content":"In your source code, you express the content of your character and string literals using a character set.","pos":[1084,1189]},{"content":"Universal character names and escape characters allow you to express any string using only the basic source character set.","pos":[1190,1312]},{"content":"A raw string literal enables you to avoid using escape characters, and can be used to express all types of string literals.","pos":[1313,1436]},{"content":"You can also create std::string literals without having to perform extra construction or conversion steps.","pos":[1437,1543]},{"content":"String literals can have no prefix, or <ph id=\"ph1\">`u8`</ph>, <ph id=\"ph2\">`L`</ph>, <ph id=\"ph3\">`u`</ph>, and  <ph id=\"ph4\">`U`</ph> prefixes to denote narrow character (single-byte or multi-byte), UTF-8, wide character (UCS-2 or UTF-16), UTF-16 and UTF-32 encodings, respectively.","pos":[3416,3628],"source":"String literals can have no prefix, or `u8`, `L`, `u`, and  `U` prefixes to denote narrow character (single-byte or multi-byte), UTF-8, wide character (UCS-2 or UTF-16), UTF-16 and UTF-32 encodings, respectively."},{"content":"A raw string literal can have <ph id=\"ph1\">`R`</ph>, <ph id=\"ph2\">`u8R`</ph>, <ph id=\"ph3\">`LR`</ph>, <ph id=\"ph4\">`uR`</ph> and <ph id=\"ph5\">`UR`</ph> prefixes for the raw version equivalents of these encodings.","pos":[3629,3751],"source":" A raw string literal can have `R`, `u8R`, `LR`, `uR` and `UR` prefixes for the raw version equivalents of these encodings."},{"content":"To create temporary or static std::string values, you can use string literals or raw string literals with an <ph id=\"ph1\">`s`</ph> suffix.","pos":[3753,3873],"source":"  To create temporary or static std::string values, you can use string literals or raw string literals with an `s` suffix."},{"content":"For more information, see the String literals section below.","pos":[3874,3934]},{"content":"For more information on the basic source character set, universal character names, and using characters from extended codepages in your source code, see <bpt id=\"p1\">[</bpt>Character Sets<ept id=\"p1\">](../cpp/character-sets2.md)</ept>.","pos":[3935,4132],"source":" For more information on the basic source character set, universal character names, and using characters from extended codepages in your source code, see [Character Sets](../cpp/character-sets2.md)."},{"content":"Character literals","pos":[4141,4159]},{"content":"A <bpt id=\"p1\">*</bpt>character literal<ept id=\"p1\">*</ept> is composed of a constant character.","pos":[4163,4221],"source":"A *character literal* is composed of a constant character."},{"content":"It is represented by the character surrounded by single quotation marks.","pos":[4222,4294]},{"content":"There are five kinds of character literals:","pos":[4295,4338]},{"pos":[4348,4403],"content":"Ordinary character literals of type <ph id=\"ph1\">`char`</ph>, for example","source":"Ordinary character literals of type `char`, for example "},{"pos":[4419,4471],"content":"UTF-8 character literals of type <ph id=\"ph1\">`char`</ph>, for example","source":"UTF-8 character literals of type `char`, for example "},{"pos":[4489,4543],"content":"Wide-character literals of type <ph id=\"ph1\">`wchar_t`</ph>, for example","source":"Wide-character literals of type `wchar_t`, for example "},{"pos":[4560,4617],"content":"UTF-16 character literals of type <ph id=\"ph1\">`char16_t`</ph>, for example","source":"UTF-16 character literals of type `char16_t`, for example "},{"pos":[4634,4691],"content":"UTF-32 character literals of type <ph id=\"ph1\">`char32_t`</ph>, for example","source":"UTF-32 character literals of type `char32_t`, for example "},{"content":"The character used for a character literal may be any character, except for the reserved characters backslash ('<ph id=\"ph1\">\\\\</ph>'), single quotation mark ('), or new line.","pos":[4705,4862],"source":"The character used for a character literal may be any character, except for the reserved characters backslash ('\\\\'), single quotation mark ('), or new line."},{"content":"Reserved characters can be specified by using an escape sequence.","pos":[4863,4928]},{"content":"Characters may be specified by using universal character names, as long as the type is large enough to hold the character.","pos":[4929,5051]},{"content":"Encoding","pos":[5061,5069]},{"content":"Character literals are encoded differently based their prefix.","pos":[5073,5135]},{"content":"A character literal without a prefix is an ordinary character literal.","pos":[5145,5215]},{"content":"The value of an ordinary character literal containing a single character, escape sequence, or universal character name that can be represented in the execution character set has a value equal to the numerical value of its encoding in the execution character set.","pos":[5216,5478]},{"content":"An ordinary character literal that contains more than one character, escape sequence, or universal character name is a <bpt id=\"p1\">*</bpt>multicharacter literal<ept id=\"p1\">*</ept>.","pos":[5479,5623],"source":" An ordinary character literal that contains more than one character, escape sequence, or universal character name is a *multicharacter literal*."},{"content":"A multicharacter literal or an ordinary character literal  that can't be represented in the execution character set is conditionally-supported, has type int, and its value is implementation-defined.","pos":[5624,5822]},{"content":"A character literal that begins with the L prefix is a wide-character literal.","pos":[5832,5910]},{"content":"The value of a wide-character literal containing a single character, escape sequence, or universal character name has a value equal to the numerical value of its encoding in the execution wide-character set unless the character literal has no representation in the execution wide-character set, in which case the value is implementation-defined.","pos":[5911,6256]},{"content":"The value of a wide-character literal containing multiple characters, escape sequences, or universal character names is implementation-defined.","pos":[6257,6400]},{"content":"A character literal that begins with the u8 prefix is a UTF-8 character literal.","pos":[6410,6490]},{"content":"The value of a UTF-8 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-8 code unit (corresponding to the C0 Controls and Basic Latin Unicode block).","pos":[6491,6776]},{"content":"If the value can't be represented by a single UTF-8 code unit, the program is ill-formed.","pos":[6777,6866]},{"content":"A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.","pos":[6867,6988]},{"content":"A character literal that begins with the u prefix is a UTF-16 character literal.","pos":[6998,7078]},{"content":"The value of a UTF-16 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-16 code unit (corresponding to the basic multi-lingual plane).","pos":[7079,7350]},{"content":"If the value can't be represented by a single UTF-16 code unit, the program is ill-formed.","pos":[7351,7441]},{"content":"A UTF-16 character literal containing more than one character, escape sequence, or universal character name is ill-formed.","pos":[7442,7564]},{"content":"A character literal that begins with the U prefix is a UTF-32 character literal.","pos":[7574,7654]},{"content":"The value of a UTF-32 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value.","pos":[7655,7823]},{"content":"A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.","pos":[7824,7945]},{"pos":[7983,7999],"content":"Escape Sequences"},{"content":"There are three kinds of escape sequences: simple, octal, and hexadecimal.","pos":[8003,8077]},{"content":"Escape sequences may be any of the following:","pos":[8078,8123]},{"content":"Value","pos":[8130,8135]},{"content":"Escape sequence","pos":[8136,8151]},{"content":"Value","pos":[8152,8157]},{"content":"Escape sequence","pos":[8158,8173]},{"content":"newline","pos":[8250,8257]},{"content":"\\n","pos":[8258,8260]},{"content":"backslash","pos":[8261,8270]},{"content":"horizontal tab","pos":[8279,8293]},{"content":"\\t","pos":[8294,8296]},{"content":"question mark","pos":[8297,8310]},{"content":"?","pos":[8311,8312]},{"content":"or <ph id=\"ph1\">\\\\</ph>?","pos":[8313,8319],"source":" or \\\\?"},{"content":"vertical tab","pos":[8324,8336]},{"content":"\\v","pos":[8337,8339]},{"content":"single quote","pos":[8340,8352]},{"content":"'","pos":[8355,8356]},{"content":"backspace","pos":[8361,8370]},{"content":"\\b","pos":[8371,8373]},{"content":"double quote","pos":[8374,8386]},{"content":"\"","pos":[8389,8390]},{"content":"carriage return","pos":[8395,8410]},{"content":"\\r","pos":[8411,8413]},{"content":"the null character","pos":[8414,8432]},{"content":"\\0","pos":[8433,8435]},{"content":"form feed","pos":[8440,8449]},{"content":"\\f","pos":[8450,8452]},{"content":"octal","pos":[8453,8458]},{"content":"\\ooo","pos":[8459,8463]},{"content":"alert (bell)","pos":[8468,8480]},{"content":"\\a","pos":[8481,8483]},{"content":"hexadecimal","pos":[8484,8495]},{"content":"\\xhhh","pos":[8496,8501]},{"content":"The following code shows some examples of escaped characters using ordinary character literals.","pos":[8509,8604]},{"content":"The same escape sequence syntax is valid for the other character literal types.","pos":[8605,8684]},{"content":"Microsoft Specific","pos":[9473,9491]},{"content":"To create a value from an ordinary character literal (those without a prefix), the compiler converts the character  or character sequence between single quotes into 8-bit values within a 32-bit integer.","pos":[9500,9702]},{"content":"Multiple characters in the literal fill corresponding bytes as needed from high-order to low-order.","pos":[9703,9802]},{"content":"To create a <ph id=\"ph1\">`char`</ph> value, the compiler takes the low-order byte.","pos":[9803,9867],"source":" To create a `char` value, the compiler takes the low-order byte."},{"content":"To create a <ph id=\"ph1\">`wchar_t`</ph> or <ph id=\"ph2\">`char16_t`</ph> value, the compiler takes the low-order word.","pos":[9868,9949],"source":" To create a `wchar_t` or `char16_t` value, the compiler takes the low-order word."},{"content":"The compiler warns that the result is truncated if any bits are set above the assigned byte or word.","pos":[9950,10050]},{"content":"An octal escape sequence is a backslash followed by a sequence of up to 3 octal digits.","pos":[10200,10287]},{"content":"The behavior of an octal escape sequence that appears to contain more than three digits is treated as a 3-digit octal sequence followed by the subsequent digits as characters; this can give surprising results.","pos":[10288,10497]},{"content":"For example:","pos":[10498,10510]},{"content":"Escape sequences that appear to contain non-octal characters are evaluated as an octal sequence up to the last octal character, followed by the remaining characters.","pos":[10621,10786]},{"content":"For example:","pos":[10787,10799]},{"content":"A hexadecimal escape sequence is a backslash followed by the character <ph id=\"ph1\">`x`</ph>, followed by a sequence of hexadecimal digits.","pos":[10972,11093],"source":"A hexadecimal escape sequence is a backslash followed by the character `x`, followed by a sequence of hexadecimal digits."},{"content":"An escape sequence that contains no hexadecimal digits causes compiler error C2153: \"hex literals must have at least one hex digit\".","pos":[11094,11226]},{"content":"Leading zeroes are ignored.","pos":[11227,11254]},{"content":"An escape sequence that appears to have hexadecimal and non-hexadecimal characters is evaluated as a hexadecimal escape sequence up to  the last hexadecimal character, followed by the non-hexadecimal characters.","pos":[11255,11466]},{"content":"In an ordinary or u8-prefixed character literal, the highest hexadecimal value is 0xFF.","pos":[11469,11556]},{"content":"In an L-prefixed or u-prefixed wide character literal, the highest hexadecimal value is 0xFFFF.","pos":[11557,11652]},{"content":"In a U-prefixed wide character literal, the highest hexadecimal value is 0xFFFFFFFF.","pos":[11653,11737]},{"content":"If a wide character literal prefixed with <ph id=\"ph1\">`L`</ph> contains more than one character, the value is taken from the first character.","pos":[11847,11971],"source":"If a wide character literal prefixed with `L` contains more than one character, the value is taken from the first character."},{"content":"Subsequent characters are ignored, unlike the behavior of the equivalent ordinary character literal.","pos":[11972,12072]},{"content":"END Microsoft Specific","pos":[12444,12466]},{"content":"The backslash character (<ph id=\"ph1\">\\\\</ph>) is a line-continuation character when it is placed at the end of a line.","pos":[12475,12576],"source":"The backslash character (\\\\) is a line-continuation character when it is placed at the end of a line."},{"content":"If you want a backslash character to appear as a character literal, you must type two backslashes in a row (<ph id=\"ph1\">`\\\\`</ph>).","pos":[12577,12691],"source":" If you want a backslash character to appear as a character literal, you must type two backslashes in a row (`\\\\`)."},{"content":"For more information about the line continuation character, see <bpt id=\"p1\">[</bpt>Phases of Translation<ept id=\"p1\">](../preprocessor/phases-of-translation.md)</ept>.","pos":[12692,12822],"source":" For more information about the line continuation character, see [Phases of Translation](../preprocessor/phases-of-translation.md)."},{"pos":[12857,12882],"content":"Universal character names"},{"content":"In character literals and native (non-raw) string literals, any character may be represented by a universal character name.","pos":[12886,13009]},{"content":"Universal character names are formed by a prefix \\U followed by an eight-digit Unicode code point, or by a prefix \\u followed by a four digit Unicode code point.","pos":[13011,13172]},{"content":"All eight or four digits, respectively, must be present to make a well-formed universal character name.","pos":[13173,13276]},{"content":"Surrogate Pairs","pos":[13503,13518]},{"content":"Universal character names cannot encode values in the surrogate code point range D800-DFFF.","pos":[13527,13618]},{"content":"For Unicode surrogate pairs, specify the universal character name by using <ph id=\"ph1\">`\\UNNNNNNNN`</ph>, where NNNNNNNN is the eight-digit code point for the character.","pos":[13619,13771],"source":" For Unicode surrogate pairs, specify the universal character name by using `\\UNNNNNNNN`, where NNNNNNNN is the eight-digit code point for the character."},{"content":"The compiler generates a surrogate pair if required.","pos":[13772,13824]},{"content":"In C++03, the language only allowed a subset of characters to be represented by their universal character names, and allowed some universal character names that didn’t actually represent any valid Unicode characters.","pos":[13831,14047]},{"content":"This was fixed in the C++11 standard.","pos":[14048,14085]},{"content":"In C++11, both character and string literals and identifiers can use universal character names.","pos":[14086,14181]},{"content":"For more information on universal character names, see <bpt id=\"p1\">[</bpt>Character Sets<ept id=\"p1\">](../cpp/character-sets2.md)</ept>.","pos":[14183,14282],"source":"  For more information on universal character names, see [Character Sets](../cpp/character-sets2.md)."},{"content":"For more information about Unicode, see <bpt id=\"p1\">[</bpt>Unicode<ept id=\"p1\">](http://msdn.microsoft.com/library/dd374081\\(v=vs.85\\).aspx)</ept>.","pos":[14283,14393],"source":" For more information about Unicode, see [Unicode](http://msdn.microsoft.com/library/dd374081\\(v=vs.85\\).aspx)."},{"content":"For more information about surrogate pairs, see <bpt id=\"p1\">[</bpt>Surrogate Pairs and Supplementary Characters<ept id=\"p1\">](http://msdn.microsoft.com/library/dd374069\\(v=vs.85\\).aspx)</ept>.","pos":[14394,14549],"source":" For more information about surrogate pairs, see [Surrogate Pairs and Supplementary Characters](http://msdn.microsoft.com/library/dd374069\\(v=vs.85\\).aspx)."},{"content":"String literals","pos":[14558,14573]},{"content":"A string literal represents a sequence of characters that together form a null-terminated string.","pos":[14577,14674]},{"content":"The characters must be enclosed between double quotation marks.","pos":[14675,14738]},{"content":"There are the following kinds of string literals:","pos":[14739,14788]},{"content":"Narrow String Literals","pos":[14798,14820]},{"content":"A narrow string literal is a non-prefixed, double-quote delimited, null-terminated array of type <ph id=\"ph1\">`const`</ph> <ph id=\"ph2\">`char`</ph>[<ph id=\"ph3\">`n`</ph>], where n is the length of the array in bytes.","pos":[14824,14986],"source":"A narrow string literal is a non-prefixed, double-quote delimited, null-terminated array of type `const` `char`[`n`], where n is the length of the array in bytes."},{"content":"A narrow string literal may contain any graphic character except the double quotation mark (<ph id=\"ph1\">`\"`</ph>), backslash (<ph id=\"ph2\">`\\`</ph>), or newline character.","pos":[14987,15123],"source":" A narrow string literal may contain any graphic character except the double quotation mark (`\"`), backslash (`\\`), or newline character."},{"content":"A narrow string literal may also contain the escape sequences listed above, and universal character names that fit in a byte.","pos":[15124,15249]},{"content":"UTF-8 encoded strings","pos":[15380,15401]},{"content":"A UTF-8 encoded string is a u8-prefixed, double-quote delimited, null-terminated array of type  <ph id=\"ph1\">`const``char`</ph>[<ph id=\"ph2\">`n`</ph>], where n is the length of the encoded array in bytes.","pos":[15410,15578],"source":"A UTF-8 encoded string is a u8-prefixed, double-quote delimited, null-terminated array of type  `const``char`[`n`], where n is the length of the encoded array in bytes."},{"content":"A u8-prefixed string literal may contain any graphic character except the double quotation mark (<ph id=\"ph1\">`\"`</ph>), backslash (<ph id=\"ph2\">`\\`</ph>), or newline character.","pos":[15579,15720],"source":" A u8-prefixed string literal may contain any graphic character except the double quotation mark (`\"`), backslash (`\\`), or newline character."},{"content":"A u8-prefixed string literal may also contain the escape sequences listed above, and any universal character name.","pos":[15721,15835]},{"content":"Wide String Literals","pos":[15946,15966]},{"content":"A wide string literal is a null-terminated array of constant <ph id=\"ph1\">`wchar_t`</ph> that is prefixed by '<ph id=\"ph2\">`L`</ph>' and contains any graphic character except the double quotation mark (\"), backslash (<ph id=\"ph3\">\\\\</ph>), or newline character.","pos":[15970,16177],"source":"A wide string literal is a null-terminated array of constant `wchar_t` that is prefixed by '`L`' and contains any graphic character except the double quotation mark (\"), backslash (\\\\), or newline character."},{"content":"A wide string literal may contain the escape sequences listed above and any universal character name.","pos":[16178,16279]},{"content":"char16_t and char32_t (C++11)","pos":[16385,16414]},{"pos":[16423,16529],"content":"C++11 introduces the portable <ph id=\"ph1\">`char16_t`</ph> (16-bit Unicode) and <ph id=\"ph2\">`char32_t`</ph> (32-bit Unicode) character types:","source":"C++11 introduces the portable `char16_t` (16-bit Unicode) and `char32_t` (32-bit Unicode) character types:"},{"content":"Raw String Literals (C++11)","pos":[16639,16666]},{"content":"A raw string literal is a null-terminated array—of any character type—that contains any graphic character, including the double quotation mark (\"), backslash (<ph id=\"ph1\">\\\\</ph>), or newline character.","pos":[16670,16855],"source":"A raw string literal is a null-terminated array—of any character type—that contains any graphic character, including the double quotation mark (\"), backslash (\\\\), or newline character."},{"content":"Raw string literals are often used in regular expressions that use character classes, and in HTML strings and XML strings.","pos":[16856,16978]},{"content":"For examples, see the following article: <bpt id=\"p1\">[</bpt>Bjarne Stroustrup's FAQ on C++11<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=401172)</ept>.","pos":[16979,17102],"source":" For examples, see the following article: [Bjarne Stroustrup's FAQ on C++11](http://go.microsoft.com/fwlink/?LinkId=401172)."},{"content":"A delimiter is a user-defined sequence of up to 16 characters that immediately precedes the opening parenthesis of a raw string literal and immediately follows its closing parenthesis.","pos":[17487,17671]},{"content":"For example, in <ph id=\"ph1\">`R\"abc(Hello\"\\()abc\"`</ph> the delimiter sequence is <ph id=\"ph2\">`abc`</ph> and the string content is <ph id=\"ph3\">`Hello\"\\(`</ph>.","pos":[17673,17780],"source":"  For example, in `R\"abc(Hello\"\\()abc\"` the delimiter sequence is `abc` and the string content is `Hello\"\\(`."},{"content":"You can use a delimiter to disambiguate raw strings that contain both double quotation marks and parentheses.","pos":[17781,17890]},{"content":"This causes a compiler error:","pos":[17891,17920]},{"content":"But a delimiter resolves it:","pos":[18036,18064]},{"content":"You can construct a raw string literal in which there is a newline (not the escaped character) in the source:","pos":[18132,18241]},{"content":"std::string Literals (C++14)","pos":[18365,18393]},{"content":"std::string literals are Standard Library implementations of user-defined literals (see below) that are represented as \"xyx\"s (with a <ph id=\"ph1\">`s`</ph> suffix).","pos":[18397,18543],"source":"std::string literals are Standard Library implementations of user-defined literals (see below) that are represented as \"xyx\"s (with a `s` suffix)."},{"content":"This kind of string literal produces a temporary object of type std::string, std::wstring, std::u32string or std::u16string depending on the prefix that is specified.","pos":[18544,18710]},{"content":"When no prefix is used, as above, a std::string is produced.","pos":[18711,18771]},{"content":"L\"xyz\"s produces a std::wstring.","pos":[18772,18804]},{"content":"u\"xyz\"s produces a <bpt id=\"p1\">[</bpt>std::u16string<ept id=\"p1\">](http://msdn.microsoft.com/Library/5e1dcd3a-b1e4-4ee0-8389-629f7c2061c1)</ept>, and U\"xyz\"s produces a <bpt id=\"p2\">[</bpt>std::u32string<ept id=\"p2\">](http://msdn.microsoft.com/Library/fd3970a3-a8b2-42ff-aadd-1cc99045f88a)</ept>.","pos":[18805,19026],"source":" u\"xyz\"s produces a [std::u16string](http://msdn.microsoft.com/Library/5e1dcd3a-b1e4-4ee0-8389-629f7c2061c1), and U\"xyz\"s produces a [std::u32string](http://msdn.microsoft.com/Library/fd3970a3-a8b2-42ff-aadd-1cc99045f88a)."},{"content":"The s suffix may also be used on raw string literals:","pos":[19266,19319]},{"content":"std::string literals are defined in the namespace <ph id=\"ph1\">`std::literals::string_literals`</ph> in the <ph id=\"ph2\">\\&lt;</ph>string&gt; header file.","pos":[19390,19502],"source":"std::string literals are defined in the namespace `std::literals::string_literals` in the \\<string> header file."},{"content":"Because <ph id=\"ph1\">`std::literals::string_literals`</ph>, and <ph id=\"ph2\">`std::literals`</ph> are both declared as <bpt id=\"p1\">[</bpt>inline namespaces<ept id=\"p1\">](../cpp/namespaces-cpp.md)</ept>, <ph id=\"ph3\">`std::literals::string_literals`</ph> is automatically treated as if it belonged directly in namespace <ph id=\"ph4\">`std`</ph>.","pos":[19503,19737],"source":" Because `std::literals::string_literals`, and `std::literals` are both declared as [inline namespaces](../cpp/namespaces-cpp.md), `std::literals::string_literals` is automatically treated as if it belonged directly in namespace `std`."},{"content":"Size of String Literals","pos":[19747,19770]},{"content":"For ANSI char<ph id=\"ph1\">\\*</ph> strings and other single-byte encodings (not UTF-8), the size (in bytes) of a string literal is the number of characters plus 1 for the terminating null character.","pos":[19774,19953],"source":"For ANSI char\\* strings and other single-byte encodings (not UTF-8), the size (in bytes) of a string literal is the number of characters plus 1 for the terminating null character."},{"content":"For all other string types, the size is not strictly related to the number of characters.","pos":[19954,20043]},{"content":"UTF-8 uses up to four char elements to encode some <bpt id=\"p1\">*</bpt>code units<ept id=\"p1\">*</ept>, and char16_t or wchar_t encoded as UTF-16 may use two elements (for a total of four bytes) to encode a single <bpt id=\"p2\">*</bpt>code unit<ept id=\"p2\">*</ept>.","pos":[20044,20231],"source":" UTF-8 uses up to four char elements to encode some *code units*, and char16_t or wchar_t encoded as UTF-16 may use two elements (for a total of four bytes) to encode a single *code unit*."},{"content":"This example shows the size of a wide string literal in bytes:","pos":[20234,20296]},{"pos":[20418,20686],"content":"Notice that <ph id=\"ph1\">`strlen()`</ph> and <ph id=\"ph2\">`wcslen()`</ph> do not include the size of the terminating null character, whose size is equal to the element size of the string type: one byte on a char* string, two bytes on wchar_t<ph id=\"ph3\">\\*</ph> or char16_t<ph id=\"ph4\">\\*</ph> strings, and four bytes on char32_t<ph id=\"ph5\">\\*</ph> strings.","source":"Notice that `strlen()` and `wcslen()` do not include the size of the terminating null character, whose size is equal to the element size of the string type: one byte on a char* string, two bytes on wchar_t\\* or char16_t\\* strings, and four bytes on char32_t\\* strings."},{"content":"The maximum length of a string literal is 65535 bytes.","pos":[20693,20747]},{"content":"This limit applies to both narrow string literals and wide string literals.","pos":[20748,20823]},{"content":"Modifying String Literals","pos":[20833,20858]},{"content":"Because string literals (not including std:string literals) are constants, trying to modify them—for example, str[2] = 'A'—causes a compiler error.","pos":[20862,21009]},{"content":"Microsoft Specific","pos":[21018,21036]},{"content":"In Visual C++ you can use a string literal to initialize a pointer to non-const <ph id=\"ph1\">`char`</ph> or <ph id=\"ph2\">`wchar_t`</ph>.","pos":[21045,21145],"source":"In Visual C++ you can use a string literal to initialize a pointer to non-const `char` or `wchar_t`."},{"content":"This is allowed in C99 code, but is deprecated in C++98 and removed in C++11.","pos":[21146,21223]},{"content":"An attempt to modify the string causes an access violation, as in this example:","pos":[21224,21303]},{"content":"You can cause the compiler to emit an error when a string literal is converted to a non_const character pointer when you set the <bpt id=\"p1\">[</bpt>/Zc:strictStrings (Disable string literal type conversion)<ept id=\"p1\">](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md)</ept> compiler option.","pos":[21408,21693],"source":"You can cause the compiler to emit an error when a string literal is converted to a non_const character pointer when you set the [/Zc:strictStrings (Disable string literal type conversion)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) compiler option."},{"content":"We recommend it for standards-compliant portable code.","pos":[21694,21748]},{"content":"It is also a good practice to use the <ph id=\"ph1\">`auto`</ph> keyword to declare string literal-initialized pointers, because it resolves to the correct (const) type.","pos":[21749,21898],"source":" It is also a good practice to use the `auto` keyword to declare string literal-initialized pointers, because it resolves to the correct (const) type."},{"content":"For example, this code example catches an attempt to write to a string literal at compile time:","pos":[21899,21994]},{"content":"In some cases, identical string literals may be pooled to save space in the executable file.","pos":[22116,22208]},{"content":"In string-literal pooling, the compiler causes all references to a particular string literal to point to the same location in memory, instead of having each reference point to a separate instance of the string literal.","pos":[22209,22427]},{"content":"To enable string pooling, use the <bpt id=\"p1\">[</bpt>/GF<ept id=\"p1\">](../build/reference/gf-eliminate-duplicate-strings.md)</ept> compiler option.","pos":[22428,22538],"source":" To enable string pooling, use the [/GF](../build/reference/gf-eliminate-duplicate-strings.md) compiler option."},{"content":"End Microsoft Specific","pos":[22547,22569]},{"content":"Concatenating adjacent string literals","pos":[22581,22619]},{"content":"Adjacent wide or narrow string literals are concatenated.","pos":[22623,22680]},{"content":"This declaration:","pos":[22681,22698]},{"content":"is identical to this declaration:","pos":[22749,22782]},{"content":"and to this declaration:","pos":[22830,22854]},{"content":"Using embedded hexadecimal escape codes to specify string literals can cause unexpected results.","pos":[22907,23003]},{"content":"The following example seeks to create a string literal that contains the ASCII 5 character, followed by the characters f, i, v, and e:","pos":[23004,23138]},{"content":"The actual result is a hexadecimal 5F, which is the ASCII code for an underscore, followed by the characters i, v, and e.","pos":[23176,23297]},{"content":"To get the correct result, you can use one of these:","pos":[23298,23350]},{"content":"std::string literals, because they are std::string types, can be concatenated with the + operator that is defined for <bpt id=\"p1\">[</bpt>basic_string<ept id=\"p1\">](../standard-library/basic-string-class.md)</ept> types.","pos":[23455,23637],"source":"std::string literals, because they are std::string types, can be concatenated with the + operator that is defined for [basic_string](../standard-library/basic-string-class.md) types."},{"content":"They can also be concatenated in the same way as adjacent string literals.","pos":[23638,23712]},{"content":"In both cases, the string encoding and the suffix must match:","pos":[23713,23774]},{"content":"String literals with universal character names","pos":[24053,24099]},{"content":"Native (non-raw) string literals may use universal character names to represent any character, as long as the universal character name can be encoded as one or more characters in the string type.","pos":[24103,24298]},{"content":"For example, a universal character name representing an extended character cannot be encoded in a narrow string using the ANSI code page, but it can be encoded in narrow strings in some multi-byte code pages, or in UTF-8 strings, or in a wide string.","pos":[24300,24550]},{"content":"In C++11, Unicode support is extended by the char16_t* and char32_t<ph id=\"ph1\">\\*</ph> string types:","pos":[24551,24634],"source":" In C++11, Unicode support is extended by the char16_t* and char32_t\\* string types:"},{"content":"See Also","pos":[25160,25168]},{"content":"Character Sets","pos":[25173,25187]},{"content":"Numeric, Boolean and Pointer Literals","pos":[25221,25258]},{"content":"User-Defined Literals","pos":[25317,25338]}],"content":"---\ntitle: \"String and Character Literals  (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"R\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"L constant\"\n  - \"escape sequences\"\n  - \"Null strings, null-terminated strings\"\n  - \"literal strings, C++\"\n  - \"Null strings\"\n  - \"string literals, syntax\"\n  - \"string literals\"\n  - \"literal strings\"\n  - \"strings [C++], string literals\"\n  - \"NULL, character constant\"\n  - \"wide characters, strings\"\nms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df\ncaps.latest.revision: 36\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# String and Character Literals  (C++)\nC++ supports various string and character types, and provides ways to express literal values of each of these types. In your source code, you express the content of your character and string literals using a character set. Universal character names and escape characters allow you to express any string using only the basic source character set. A raw string literal enables you to avoid using escape characters, and can be used to express all types of string literals. You can also create std::string literals without having to perform extra construction or conversion steps.  \n  \n```cpp  \n#include <string>  \nusing namespace std::string_literals; // enables s-suffix for std::string literals  \n  \nint main()  \n{  \n    // Character literals  \n    auto c0 =   'A'; // char  \n    auto c1 = u8'A'; // char  \n    auto c2 =  L'A'; // wchar_t  \n    auto c3 =  u'A'; // char16_t  \n    auto c4 =  U'A'; // char32_t  \n  \n    // String literals  \n    auto s0 =   \"hello\"; // const char*  \n    auto s1 = u8\"hello\"; // const char*, encoded as UTF-8  \n    auto s2 =  L\"hello\"; // const wchar_t*  \n    auto s3 =  u\"hello\"; // const char16_t*, encoded as UTF-16  \n    auto s4 =  U\"hello\"; // const char32_t*, encoded as UTF-32  \n  \n    // Raw string literals containing unescaped \\ and \"  \n    auto R0 =   R\"(\"Hello \\ world\")\"; // const char*  \n    auto R1 = u8R\"(\"Hello \\ world\")\"; // const char*, encoded as UTF-8  \n    auto R2 =  LR\"(\"Hello \\ world\")\"; // const wchar_t*  \n    auto R3 =  uR\"(\"Hello \\ world\")\"; // const char16_t*, encoded as UTF-16  \n    auto R4 =  UR\"(\"Hello \\ world\")\"; // const char32_t*, encoded as UTF-32  \n  \n    // Combining string literals with standard s-suffix  \n    auto S0 =   \"hello\"s; // std::string  \n    auto S1 = u8\"hello\"s; // std::string  \n    auto S2 =  L\"hello\"s; // std::wstring  \n    auto S3 =  u\"hello\"s; // std::u16string  \n    auto S4 =  U\"hello\"s; // std::u32string  \n  \n    // Combining raw string literals with standard s-suffix  \n    auto S5 =   R\"(\"Hello \\ world\")\"s; // std::string from a raw const char*  \n    auto S6 = u8R\"(\"Hello \\ world\")\"s; // std::string from a raw const char*, encoded as UTF-8  \n    auto S7 =  LR\"(\"Hello \\ world\")\"s; // std::wstring from a raw const wchar_t*  \n    auto S8 =  uR\"(\"Hello \\ world\")\"s; // std::u16string from a raw const char16_t*, encoded as UTF-16  \n    auto S9 =  UR\"(\"Hello \\ world\")\"s; // std::u32string from a raw const char32_t*, encoded as UTF-32  \n}  \n```  \n  \n String literals can have no prefix, or `u8`, `L`, `u`, and  `U` prefixes to denote narrow character (single-byte or multi-byte), UTF-8, wide character (UCS-2 or UTF-16), UTF-16 and UTF-32 encodings, respectively. A raw string literal can have `R`, `u8R`, `LR`, `uR` and `UR` prefixes for the raw version equivalents of these encodings.  To create temporary or static std::string values, you can use string literals or raw string literals with an `s` suffix. For more information, see the String literals section below. For more information on the basic source character set, universal character names, and using characters from extended codepages in your source code, see [Character Sets](../cpp/character-sets2.md).  \n  \n## Character literals  \n A *character literal* is composed of a constant character. It is represented by the character surrounded by single quotation marks. There are five kinds of character literals:  \n  \n-   Ordinary character literals of type `char`, for example `'a'`  \n  \n-   UTF-8 character literals of type `char`, for example `u8'a'`  \n  \n-   Wide-character literals of type `wchar_t`, for example `L'a'`  \n  \n-   UTF-16 character literals of type `char16_t`, for example `u'a'`  \n  \n-   UTF-32 character literals of type `char32_t`, for example `U'a'`  \n  \n The character used for a character literal may be any character, except for the reserved characters backslash ('\\\\'), single quotation mark ('), or new line. Reserved characters can be specified by using an escape sequence. Characters may be specified by using universal character names, as long as the type is large enough to hold the character.  \n  \n### Encoding  \n Character literals are encoded differently based their prefix.  \n  \n-   A character literal without a prefix is an ordinary character literal. The value of an ordinary character literal containing a single character, escape sequence, or universal character name that can be represented in the execution character set has a value equal to the numerical value of its encoding in the execution character set. An ordinary character literal that contains more than one character, escape sequence, or universal character name is a *multicharacter literal*. A multicharacter literal or an ordinary character literal  that can't be represented in the execution character set is conditionally-supported, has type int, and its value is implementation-defined.  \n  \n-   A character literal that begins with the L prefix is a wide-character literal. The value of a wide-character literal containing a single character, escape sequence, or universal character name has a value equal to the numerical value of its encoding in the execution wide-character set unless the character literal has no representation in the execution wide-character set, in which case the value is implementation-defined. The value of a wide-character literal containing multiple characters, escape sequences, or universal character names is implementation-defined.  \n  \n-   A character literal that begins with the u8 prefix is a UTF-8 character literal. The value of a UTF-8 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-8 code unit (corresponding to the C0 Controls and Basic Latin Unicode block). If the value can't be represented by a single UTF-8 code unit, the program is ill-formed. A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.  \n  \n-   A character literal that begins with the u prefix is a UTF-16 character literal. The value of a UTF-16 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-16 code unit (corresponding to the basic multi-lingual plane). If the value can't be represented by a single UTF-16 code unit, the program is ill-formed. A UTF-16 character literal containing more than one character, escape sequence, or universal character name is ill-formed.  \n  \n-   A character literal that begins with the U prefix is a UTF-32 character literal. The value of a UTF-32 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value. A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.  \n  \n###  <a name=\"bkmk_Escape\"></a> Escape Sequences  \n There are three kinds of escape sequences: simple, octal, and hexadecimal. Escape sequences may be any of the following:  \n  \n|Value|Escape sequence|Value|Escape sequence|  \n|-----------|---------------------|-----------|---------------------|  \n|newline|\\n|backslash|\\\\\\|  \n|horizontal tab|\\t|question mark|? or \\\\?|  \n|vertical tab|\\v|single quote|\\\\'|  \n|backspace|\\b|double quote|\\\\\"|  \n|carriage return|\\r|the null character|\\0|  \n|form feed|\\f|octal|\\ooo|  \n|alert (bell)|\\a|hexadecimal|\\xhhh|  \n  \n The following code shows some examples of escaped characters using ordinary character literals. The same escape sequence syntax is valid for the other character literal types.  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nint main() {  \n    char newline = '\\n';  \n    char tab = '\\t';  \n    char backspace = '\\b';  \n    char backslash = '\\\\';  \n    char nullChar = '\\0';  \n  \n    cout << \"Newline character: \" << newline << \"ending\" << endl; // Newline character:  \n                                                                  //  ending  \n    cout << \"Tab character: \" << tab << \"ending\" << endl; // Tab character : ending  \n    cout << \"Backspace character: \" << backspace << \"ending\" << endl; // Backspace character : ending  \n    cout << \"Backslash character: \" << backslash << \"ending\" << endl; // Backslash character : \\ending  \n    cout << \"Null character: \" << nullChar << \"ending\" << endl; //Null character:  ending  \n}  \n```  \n  \n **Microsoft Specific**  \n  \n To create a value from an ordinary character literal (those without a prefix), the compiler converts the character  or character sequence between single quotes into 8-bit values within a 32-bit integer. Multiple characters in the literal fill corresponding bytes as needed from high-order to low-order. To create a `char` value, the compiler takes the low-order byte. To create a `wchar_t` or `char16_t` value, the compiler takes the low-order word. The compiler warns that the result is truncated if any bits are set above the assigned byte or word.  \n  \n```cpp  \nchar c0    = 'abcd';    // C4305, C4309, truncates to 'd'  \nwchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\\x6364'  \n```  \n  \n An octal escape sequence is a backslash followed by a sequence of up to 3 octal digits. The behavior of an octal escape sequence that appears to contain more than three digits is treated as a 3-digit octal sequence followed by the subsequent digits as characters; this can give surprising results. For example:  \n  \n```cpp  \nchar c1 = '\\100';   // '@'  \nchar c2 = '\\1000';  // C4305, C4309, truncates to '0'   \n```  \n  \n Escape sequences that appear to contain non-octal characters are evaluated as an octal sequence up to the last octal character, followed by the remaining characters. For example:  \n  \n```cpp  \nchar c3 = '\\009';   // '9'  \nchar c4 = '\\089';   // C4305, C4309, truncates to '9'  \nchar c5 = '\\qrs';   // C4129, C4305, C4309, truncates to 's'  \n```  \n  \n A hexadecimal escape sequence is a backslash followed by the character `x`, followed by a sequence of hexadecimal digits. An escape sequence that contains no hexadecimal digits causes compiler error C2153: \"hex literals must have at least one hex digit\". Leading zeroes are ignored. An escape sequence that appears to have hexadecimal and non-hexadecimal characters is evaluated as a hexadecimal escape sequence up to  the last hexadecimal character, followed by the non-hexadecimal characters.   In an ordinary or u8-prefixed character literal, the highest hexadecimal value is 0xFF. In an L-prefixed or u-prefixed wide character literal, the highest hexadecimal value is 0xFFFF. In a U-prefixed wide character literal, the highest hexadecimal value is 0xFFFFFFFF.  \n  \n```cpp  \nchar c6 = '\\x0050'; // 'P'  \nchar c7 = '\\x0pqr'; // C4305, C4309, truncates to 'r'  \n```  \n  \n If a wide character literal prefixed with `L` contains more than one character, the value is taken from the first character. Subsequent characters are ignored, unlike the behavior of the equivalent ordinary character literal.  \n  \n```cpp  \nwchar_t w1 = L'\\100';   // L'@'  \nwchar_t w2 = L'\\1000';  // C4066 L'@', 0 ignored   \nwchar_t w3 = L'\\009';   // C4066 L'\\0', 9 ignored  \nwchar_t w4 = L'\\089';   // C4066 L'\\0', 89 ignored  \nwchar_t w5 = L'\\qrs';   // C4129, C4066 L'q' escape, rs ignored  \nwchar_t w6 = L'\\x0050'; // L'P'  \nwchar_t w7 = L'\\x0pqr'; // C4066 L'\\0', pqr ignored  \n```  \n  \n **END Microsoft Specific**  \n  \n The backslash character (\\\\) is a line-continuation character when it is placed at the end of a line. If you want a backslash character to appear as a character literal, you must type two backslashes in a row (`\\\\`). For more information about the line continuation character, see [Phases of Translation](../preprocessor/phases-of-translation.md).  \n  \n###  <a name=\"bkmk_UCN\"></a> Universal character names  \n In character literals and native (non-raw) string literals, any character may be represented by a universal character name.  Universal character names are formed by a prefix \\U followed by an eight-digit Unicode code point, or by a prefix \\u followed by a four digit Unicode code point. All eight or four digits, respectively, must be present to make a well-formed universal character name.  \n  \n```cpp  \nchar u1 = 'A';          // 'A'  \nchar u2 = '\\101';       // octal, 'A'   \nchar u3 = '\\x41';       // hexadecimal, 'A'  \nchar u4 = '\\u0041';     // \\u UCN 'A'  \nchar u5 = '\\U00000041'; // \\U UCN 'A'  \n```  \n  \n **Surrogate Pairs**  \n  \n Universal character names cannot encode values in the surrogate code point range D800-DFFF. For Unicode surrogate pairs, specify the universal character name by using `\\UNNNNNNNN`, where NNNNNNNN is the eight-digit code point for the character. The compiler generates a surrogate pair if required.  \n  \n In C++03, the language only allowed a subset of characters to be represented by their universal character names, and allowed some universal character names that didn’t actually represent any valid Unicode characters. This was fixed in the C++11 standard. In C++11, both character and string literals and identifiers can use universal character names.  For more information on universal character names, see [Character Sets](../cpp/character-sets2.md). For more information about Unicode, see [Unicode](http://msdn.microsoft.com/library/dd374081\\(v=vs.85\\).aspx). For more information about surrogate pairs, see [Surrogate Pairs and Supplementary Characters](http://msdn.microsoft.com/library/dd374069\\(v=vs.85\\).aspx).  \n  \n## String literals  \n A string literal represents a sequence of characters that together form a null-terminated string. The characters must be enclosed between double quotation marks. There are the following kinds of string literals:  \n  \n### Narrow String Literals  \n A narrow string literal is a non-prefixed, double-quote delimited, null-terminated array of type `const` `char`[`n`], where n is the length of the array in bytes. A narrow string literal may contain any graphic character except the double quotation mark (`\"`), backslash (`\\`), or newline character. A narrow string literal may also contain the escape sequences listed above, and universal character names that fit in a byte.  \n  \n```cpp  \nconst char *narrow = \"abcd\";  \n  \n// represents the string: yes\\no  \nconst char *escaped = \"yes\\\\no\";  \n```  \n  \n **UTF-8 encoded strings**  \n  \n A UTF-8 encoded string is a u8-prefixed, double-quote delimited, null-terminated array of type  `const``char`[`n`], where n is the length of the encoded array in bytes. A u8-prefixed string literal may contain any graphic character except the double quotation mark (`\"`), backslash (`\\`), or newline character. A u8-prefixed string literal may also contain the escape sequences listed above, and any universal character name.  \n  \n```cpp  \nconst char* str1 = u8\"Hello World\";  \nconst char* str2 = u8\"\\U0001F607 is O:-)\";  \n```  \n  \n### Wide String Literals  \n A wide string literal is a null-terminated array of constant `wchar_t` that is prefixed by '`L`' and contains any graphic character except the double quotation mark (\"), backslash (\\\\), or newline character. A wide string literal may contain the escape sequences listed above and any universal character name.  \n  \n```cpp  \nconst wchar_t* wide = L\"zyxw\";  \nconst wchar_t* newline = L\"hello\\ngoodbye\";  \n```  \n  \n **char16_t and char32_t (C++11)**  \n  \n C++11 introduces the portable `char16_t` (16-bit Unicode) and `char32_t` (32-bit Unicode) character types:  \n  \n```cpp  \nauto s3 = u\"hello\"; // const char16_t*  \nauto s4 = U\"hello\"; // const char32_t*  \n```  \n  \n### Raw String Literals (C++11)  \n A raw string literal is a null-terminated array—of any character type—that contains any graphic character, including the double quotation mark (\"), backslash (\\\\), or newline character. Raw string literals are often used in regular expressions that use character classes, and in HTML strings and XML strings. For examples, see the following article: [Bjarne Stroustrup's FAQ on C++11](http://go.microsoft.com/fwlink/?LinkId=401172).  \n  \n```cpp  \n// represents the string: An unescaped \\ character  \nconst char* raw_narrow = R\"(An unescaped \\ character)\";  \nconst wchar_t* raw_wide = LR\"(An unescaped \\ character)\";  \nconst char*       raw_utf8  = u8R\"(An unescaped \\ character)\";  \nconst char16_t* raw_utf16 = uR\"(An unescaped \\ character)\";  \nconst char32_t* raw_utf32 = UR\"(An unescaped \\ character)\";  \n```  \n  \n A delimiter is a user-defined sequence of up to 16 characters that immediately precedes the opening parenthesis of a raw string literal and immediately follows its closing parenthesis.  For example, in `R\"abc(Hello\"\\()abc\"` the delimiter sequence is `abc` and the string content is `Hello\"\\(`. You can use a delimiter to disambiguate raw strings that contain both double quotation marks and parentheses. This causes a compiler error:  \n  \n```cpp  \n// meant to represent the string: )”  \nconst char* bad_parens = R\"()\")\";  // error C2059  \n```  \n  \n But a delimiter resolves it:  \n  \n```cpp  \nconst char* good_parens = R\"xyz()\")xyz\";  \n```  \n  \n You can construct a raw string literal in which there is a newline (not the escaped character) in the source:  \n  \n```cpp  \n// represents the string: hello  \n//goodbye  \nconst wchar_t* newline = LR\"(hello  \ngoodbye)\";  \n```  \n  \n### std::string Literals (C++14)  \n std::string literals are Standard Library implementations of user-defined literals (see below) that are represented as \"xyx\"s (with a `s` suffix). This kind of string literal produces a temporary object of type std::string, std::wstring, std::u32string or std::u16string depending on the prefix that is specified. When no prefix is used, as above, a std::string is produced. L\"xyz\"s produces a std::wstring. u\"xyz\"s produces a [std::u16string](http://msdn.microsoft.com/Library/5e1dcd3a-b1e4-4ee0-8389-629f7c2061c1), and U\"xyz\"s produces a [std::u32string](http://msdn.microsoft.com/Library/fd3970a3-a8b2-42ff-aadd-1cc99045f88a).  \n  \n```cpp  \n//#include <string>  \n//using namespace std::string_literals;  \nstring str{ \"hello\"s };  \nstring str2{ u8\"Hello World\" };  \nwstring str3{ L\"hello\"s };  \nu16string str4{ u\"hello\"s };  \nu32string str5{ U\"hello\"s };  \n```  \n  \n The s suffix may also be used on raw string literals:  \n  \n```cpp  \nu32string str6{ UR\"(She said \"hello.\")\"s };  \n```  \n  \n std::string literals are defined in the namespace `std::literals::string_literals` in the \\<string> header file. Because `std::literals::string_literals`, and `std::literals` are both declared as [inline namespaces](../cpp/namespaces-cpp.md), `std::literals::string_literals` is automatically treated as if it belonged directly in namespace `std`.  \n  \n### Size of String Literals  \n For ANSI char\\* strings and other single-byte encodings (not UTF-8), the size (in bytes) of a string literal is the number of characters plus 1 for the terminating null character. For all other string types, the size is not strictly related to the number of characters. UTF-8 uses up to four char elements to encode some *code units*, and char16_t or wchar_t encoded as UTF-16 may use two elements (for a total of four bytes) to encode a single *code unit*.   This example shows the size of a wide string literal in bytes:  \n  \n```cpp  \nconst wchar_t* str = L\"Hello!\";  \nconst size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);  \n```  \n  \n Notice that `strlen()` and `wcslen()` do not include the size of the terminating null character, whose size is equal to the element size of the string type: one byte on a char* string, two bytes on wchar_t\\* or char16_t\\* strings, and four bytes on char32_t\\* strings.  \n  \n The maximum length of a string literal is 65535 bytes. This limit applies to both narrow string literals and wide string literals.  \n  \n### Modifying String Literals  \n Because string literals (not including std:string literals) are constants, trying to modify them—for example, str[2] = 'A'—causes a compiler error.  \n  \n **Microsoft Specific**  \n  \n In Visual C++ you can use a string literal to initialize a pointer to non-const `char` or `wchar_t`. This is allowed in C99 code, but is deprecated in C++98 and removed in C++11. An attempt to modify the string causes an access violation, as in this example:  \n  \n```cpp  \nwchar_t* str = L\"hello\";  \nstr[2] = L'a'; // run-time error: access violation  \n```  \n  \n You can cause the compiler to emit an error when a string literal is converted to a non_const character pointer when you set the [/Zc:strictStrings (Disable string literal type conversion)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) compiler option. We recommend it for standards-compliant portable code. It is also a good practice to use the `auto` keyword to declare string literal-initialized pointers, because it resolves to the correct (const) type. For example, this code example catches an attempt to write to a string literal at compile time:  \n  \n```cpp  \nauto str = L\"hello\";  \nstr[2] = L'a'; // C3892: you cannot assign to a variable that is const.  \n```  \n  \n In some cases, identical string literals may be pooled to save space in the executable file. In string-literal pooling, the compiler causes all references to a particular string literal to point to the same location in memory, instead of having each reference point to a separate instance of the string literal. To enable string pooling, use the [/GF](../build/reference/gf-eliminate-duplicate-strings.md) compiler option.  \n  \n **End Microsoft Specific**  \n  \n### Concatenating adjacent string literals  \n Adjacent wide or narrow string literals are concatenated. This declaration:  \n  \n```cpp  \nchar str[] = \"12\" \"34\";  \n```  \n  \n is identical to this declaration:  \n  \n```cpp  \nchar atr[] = \"1234\";  \n```  \n  \n and to this declaration:  \n  \n```cpp  \nchar atr[] =  \"12\\  \n34\";  \n```  \n  \n Using embedded hexadecimal escape codes to specify string literals can cause unexpected results. The following example seeks to create a string literal that contains the ASCII 5 character, followed by the characters f, i, v, and e:  \n  \n```cpp  \n\"\\x05five\"  \n```  \n  \n The actual result is a hexadecimal 5F, which is the ASCII code for an underscore, followed by the characters i, v, and e. To get the correct result, you can use one of these:  \n  \n```cpp  \n\"\\005five\"     // Use octal literal.  \n\"\\x05\" \"five\"  // Use string splicing.  \n```  \n  \n std::string literals, because they are std::string types, can be concatenated with the + operator that is defined for [basic_string](../standard-library/basic-string-class.md) types. They can also be concatenated in the same way as adjacent string literals. In both cases, the string encoding and the suffix must match:  \n  \n```cpp  \nauto x1 = \"hello\" \" \" \" world\"; // OK  \nauto x2 = U\"hello\" \" \" L\"world\"; // C2308: disagree on prefix  \nauto x3 = u8\"hello\" \" \"s u8\"world\"s; // OK, agree on prefixes and suffixes  \nauto x4 = u8\"hello\" \" \"s u8\"world\"z; // C3688, disagree on suffixes  \n```  \n  \n### String literals with universal character names  \n Native (non-raw) string literals may use universal character names to represent any character, as long as the universal character name can be encoded as one or more characters in the string type.  For example, a universal character name representing an extended character cannot be encoded in a narrow string using the ANSI code page, but it can be encoded in narrow strings in some multi-byte code pages, or in UTF-8 strings, or in a wide string. In C++11, Unicode support is extended by the char16_t* and char32_t\\* string types:  \n  \n```cpp  \n// ASCII smiling face  \nconst char*     s1 = \":-)\";    \n  \n// UTF-16 (on Windows) encoded WINKING FACE (U+1F609)  \nconst wchar_t*  s2 = L\"😉 = \\U0001F609 is ;-)\";    \n  \n// UTF-8  encoded SMILING FACE WITH HALO (U+1F607)  \nconst char*     s3 = u8\"😇 = \\U0001F607 is O:-)\";  \n  \n// UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603)  \nconst char16_t* s4 = u\"😃 = \\U0001F603 is :-D\";  \n  \n// UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E)  \nconst char32_t* s5 = U\"😎 = \\U0001F60E is B-)\";  \n```  \n  \n## See Also  \n [Character Sets](../cpp/character-sets2.md)   \n [Numeric, Boolean and Pointer Literals](../cpp/numeric-boolean-and-pointer-literals-cpp.md)   \n [User-Defined Literals](../cpp/user-defined-literals-cpp.md)"}