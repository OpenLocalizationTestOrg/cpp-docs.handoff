{"nodes":[{"pos":[12,74],"content":"Support For C++11-14-17 Features (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Support For C++11-14-17 Features (Modern C++) | Microsoft Docs","pos":[0,62]}]},{"content":"Support For C++11/14/17 Features (Modern C++)","pos":[581,626]},{"content":"This article describes C++11/14/17 features in Visual C++.","pos":[627,685]},{"pos":[722,739],"content":"C++11Feature List"},{"content":"Visual C++ implements the vast majority of features in the <bpt id=\"p1\">[</bpt>C++11 core language specification<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235092)</ept>, as well as many C++14 Library features and some features proposed for C++17.","pos":[743,964],"source":"Visual C++ implements the vast majority of features in the [C++11 core language specification](http://go.microsoft.com/fwlink/p/?LinkID=235092), as well as many C++14 Library features and some features proposed for C++17."},{"content":"The following table lists C++11/14/17 core language features and their implementation status in Visual C++ in Visual Studio 2010, <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph>, and <ph id=\"ph2\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>, and Visual Studio 2015.","pos":[965,1268],"source":" The following table lists C++11/14/17 core language features and their implementation status in Visual C++ in Visual Studio 2010, [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)], and [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)], and Visual Studio 2015."},{"pos":[1312,1346],"content":"C++11 Core Language Features Table"},{"content":"C++11 Core Language Features","pos":[1354,1382]},{"content":"Visual Studio 2010","pos":[1452,1470]},{"content":"Visual Studio 2012","pos":[1471,1489]},{"content":"Visual Studio 2015","pos":[1554,1572]},{"pos":[1826,2216],"content":"Rvalue references <bpt id=\"p1\">[</bpt>v0.1<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1610.html)</ept>, <bpt id=\"p2\">[</bpt>v1.0<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html)</ept>, <bpt id=\"p3\">[</bpt>v2.0<ept id=\"p3\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html)</ept>, <bpt id=\"p4\">[</bpt>v2.1<ept id=\"p4\">](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html)</ept>, <bpt id=\"p5\">[</bpt>v3.0<ept id=\"p5\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html)</ept>","source":"Rvalue references [v0.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1610.html), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html), [v2.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html), [v2.1](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html), [v3.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html)"},{"content":"v2.0","pos":[2217,2221]},{"content":"v2.1*","pos":[2222,2227]},{"content":"v2.1*","pos":[2228,2233]},{"content":"v3.0","pos":[2234,2238]},{"content":"ref-qualifiers","pos":[2244,2258]},{"content":"No","pos":[2327,2329]},{"content":"No","pos":[2330,2332]},{"content":"No","pos":[2333,2335]},{"content":"Yes","pos":[2336,2339]},{"content":"Non-static data member initializers","pos":[2345,2380]},{"content":"No","pos":[2449,2451]},{"content":"No","pos":[2452,2454]},{"content":"Yes","pos":[2456,2459]},{"content":"Yes","pos":[2523,2526]},{"pos":[2531,2698],"content":"Variadic templates <bpt id=\"p1\">[</bpt>v0.9<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf)</ept>, <bpt id=\"p2\">[</bpt>v1.0<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf)</ept>","source":"Variadic templates [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf)"},{"content":"No","pos":[2699,2701]},{"content":"No","pos":[2702,2704]},{"content":"Yes","pos":[2706,2709]},{"content":"Yes","pos":[2754,2757]},{"content":"Initializer lists","pos":[2763,2780]},{"content":"No","pos":[2849,2851]},{"content":"No","pos":[2852,2854]},{"content":"Yes","pos":[2856,2859]},{"content":"Yes","pos":[2923,2926]},{"content":"static_assert","pos":[2932,2945]},{"content":"Yes","pos":[3015,3018]},{"content":"Yes","pos":[3019,3022]},{"content":"Yes","pos":[3023,3026]},{"content":"Yes","pos":[3027,3030]},{"pos":[3035,3188],"content":"auto <bpt id=\"p1\">[</bpt>v0.9<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf)</ept>, <bpt id=\"p2\">[</bpt>v1.0<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.htm)</ept>","source":"auto [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.htm)"},{"content":"v1.0","pos":[3189,3193]},{"content":"v1.0","pos":[3194,3198]},{"content":"v1.0","pos":[3199,3203]},{"content":"Yes","pos":[3204,3207]},{"content":"Trailing return types","pos":[3213,3234]},{"content":"Yes","pos":[3303,3306]},{"content":"Yes","pos":[3307,3310]},{"content":"Yes","pos":[3311,3314]},{"content":"Yes","pos":[3315,3318]},{"pos":[3323,3554],"content":"Lambdas <bpt id=\"p1\">[</bpt>v0.9<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf)</ept>, <bpt id=\"p2\">[</bpt>v1.0<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf)</ept>, <bpt id=\"p3\">[</bpt>v1.1<ept id=\"p3\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf)</ept>","source":"Lambdas [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf), [v1.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf)"},{"content":"v1.0","pos":[3555,3559]},{"content":"v1.1","pos":[3560,3564]},{"content":"v1.1","pos":[3565,3569]},{"content":"Yes","pos":[3570,3573]},{"pos":[3578,3735],"content":"decltype <bpt id=\"p1\">[</bpt>v1.0<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf)</ept>, <bpt id=\"p2\">[</bpt>v1.1<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf)</ept>","source":"decltype [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf), [v1.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf)"},{"content":"v1.0","pos":[3736,3740]},{"content":"v1.1**","pos":[3741,3747]},{"content":"v1.1","pos":[3748,3752]},{"content":"Yes","pos":[3753,3756]},{"content":"Right angle brackets","pos":[3762,3782]},{"content":"Yes","pos":[3852,3855]},{"content":"Yes","pos":[3856,3859]},{"content":"Yes","pos":[3860,3863]},{"content":"Yes","pos":[3864,3867]},{"content":"Default template arguments for function templates","pos":[3873,3922]},{"content":"No","pos":[3986,3988]},{"content":"No","pos":[3989,3991]},{"content":"Yes","pos":[3992,3995]},{"content":"Yes","pos":[3996,3999]},{"content":"Expression SFINAE","pos":[4005,4022]},{"content":"No","pos":[4092,4094]},{"content":"No","pos":[4095,4097]},{"content":"No","pos":[4098,4100]},{"content":"No","pos":[4101,4103]},{"content":"Alias templates","pos":[4109,4124]},{"content":"No","pos":[4193,4195]},{"content":"No","pos":[4196,4198]},{"content":"Yes","pos":[4200,4203]},{"content":"Yes","pos":[4241,4244]},{"content":"Extern templates","pos":[4250,4266]},{"content":"Yes","pos":[4335,4338]},{"content":"Yes","pos":[4339,4342]},{"content":"Yes","pos":[4343,4346]},{"content":"Yes","pos":[4347,4350]},{"content":"nullptr","pos":[4356,4363]},{"content":"Yes","pos":[4432,4435]},{"content":"Yes","pos":[4436,4439]},{"content":"Yes","pos":[4440,4443]},{"content":"Yes","pos":[4444,4447]},{"content":"Strongly typed enums","pos":[4453,4473]},{"content":"Partial","pos":[4542,4549]},{"content":"Yes","pos":[4550,4553]},{"content":"Yes","pos":[4554,4557]},{"content":"Yes","pos":[4558,4561]},{"content":"Forward declared enums","pos":[4567,4589]},{"content":"No","pos":[4658,4660]},{"content":"Yes","pos":[4661,4664]},{"content":"Yes","pos":[4665,4668]},{"content":"Yes","pos":[4669,4672]},{"content":"Attributes","pos":[4678,4688]},{"content":"No","pos":[4757,4759]},{"content":"No","pos":[4760,4762]},{"content":"No","pos":[4763,4765]},{"content":"Yes","pos":[4766,4769]},{"content":"constexpr","pos":[4775,4784]},{"content":"No","pos":[4853,4855]},{"content":"No","pos":[4856,4858]},{"content":"No","pos":[4859,4861]},{"content":"Yes","pos":[4862,4865]},{"content":"Alignment","pos":[4871,4880]},{"content":"TR1","pos":[4949,4952]},{"content":"Partial","pos":[4953,4960]},{"content":"Partial","pos":[4961,4968]},{"content":"Yes","pos":[4969,4972]},{"content":"Delegating constructors","pos":[4978,5001]},{"content":"No","pos":[5070,5072]},{"content":"No","pos":[5073,5075]},{"content":"Yes","pos":[5077,5080]},{"content":"Yes","pos":[5144,5147]},{"content":"Inheriting constructors","pos":[5153,5176]},{"content":"No","pos":[5245,5247]},{"content":"No","pos":[5248,5250]},{"content":"No","pos":[5251,5253]},{"content":"Yes","pos":[5254,5257]},{"content":"Explicit conversion operators","pos":[5263,5292]},{"content":"No","pos":[5361,5363]},{"content":"No","pos":[5364,5366]},{"content":"Yes","pos":[5367,5370]},{"content":"Yes","pos":[5371,5374]},{"content":"char16_t/char32_t","pos":[5380,5397]},{"content":"No","pos":[5467,5469]},{"content":"No","pos":[5470,5472]},{"content":"No","pos":[5473,5475]},{"content":"Yes","pos":[5476,5479]},{"content":"Unicode string literals","pos":[5485,5508]},{"content":"No","pos":[5577,5579]},{"content":"No","pos":[5580,5582]},{"content":"No","pos":[5583,5585]},{"content":"Yes","pos":[5586,5589]},{"content":"Raw string literals","pos":[5595,5614]},{"content":"No","pos":[5683,5685]},{"content":"No","pos":[5686,5688]},{"content":"Yes","pos":[5690,5693]},{"content":"Yes","pos":[5740,5743]},{"content":"Universal character names in literals","pos":[5749,5786]},{"content":"No","pos":[5856,5858]},{"content":"No","pos":[5859,5861]},{"content":"No","pos":[5862,5864]},{"content":"Yes","pos":[5865,5868]},{"content":"User-defined literals","pos":[5874,5895]},{"content":"No","pos":[5964,5966]},{"content":"No","pos":[5967,5969]},{"content":"No","pos":[5970,5972]},{"content":"Yes","pos":[5973,5976]},{"content":"Standard-layout and trivial types","pos":[5982,6015]},{"content":"No","pos":[6084,6086]},{"content":"Yes","pos":[6087,6090]},{"content":"Yes","pos":[6091,6094]},{"content":"Yes","pos":[6095,6098]},{"content":"Defaulted and deleted functions","pos":[6104,6135]},{"content":"No","pos":[6204,6206]},{"content":"No","pos":[6207,6209]},{"content":"Yes*","pos":[6211,6215]},{"content":"Yes","pos":[6271,6274]},{"content":"Extended friend declarations","pos":[6280,6308]},{"content":"Yes","pos":[6377,6380]},{"content":"Yes","pos":[6381,6384]},{"content":"Yes","pos":[6385,6388]},{"content":"Yes","pos":[6389,6392]},{"content":"Extended sizeof","pos":[6398,6413]},{"content":"No","pos":[6483,6485]},{"content":"No","pos":[6486,6488]},{"content":"No","pos":[6489,6491]},{"content":"Yes","pos":[6492,6495]},{"content":"Inline namespaces","pos":[6501,6518]},{"content":"No","pos":[6587,6589]},{"content":"No","pos":[6590,6592]},{"content":"No","pos":[6593,6595]},{"content":"Yes","pos":[6596,6599]},{"content":"Unrestricted unions","pos":[6605,6624]},{"content":"No","pos":[6693,6695]},{"content":"No","pos":[6696,6698]},{"content":"No","pos":[6699,6701]},{"content":"Yes","pos":[6702,6705]},{"content":"Local and unnamed types as template arguments","pos":[6711,6756]},{"content":"Yes","pos":[6825,6828]},{"content":"Yes","pos":[6829,6832]},{"content":"Yes","pos":[6833,6836]},{"content":"Yes","pos":[6837,6840]},{"content":"Range-based for-loop","pos":[6846,6866]},{"content":"No","pos":[6936,6938]},{"content":"Yes","pos":[6939,6942]},{"content":"Yes","pos":[6943,6946]},{"content":"Yes","pos":[6947,6950]},{"pos":[6955,7197],"content":"override and final <bpt id=\"p1\">[</bpt>v0.8<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm)</ept>, <bpt id=\"p2\">[</bpt>v0.9<ept id=\"p2\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm)</ept>, <bpt id=\"p3\">[</bpt>v1.0<ept id=\"p3\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm)</ept>","source":"override and final [v0.8](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm), [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm)"},{"content":"Partial","pos":[7198,7205]},{"content":"Yes","pos":[7206,7209]},{"content":"Yes","pos":[7210,7213]},{"content":"Yes","pos":[7214,7217]},{"content":"Minimal GC support","pos":[7223,7241]},{"content":"Yes","pos":[7310,7313]},{"content":"Yes","pos":[7314,7317]},{"content":"Yes","pos":[7318,7321]},{"content":"Yes","pos":[7322,7325]},{"content":"noexcept","pos":[7331,7339]},{"content":"No","pos":[7409,7411]},{"content":"No","pos":[7412,7414]},{"content":"No","pos":[7415,7417]},{"content":"Yes","pos":[7418,7421]},{"pos":[7429,7454],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[7497,7544],"content":"C++11 Core Language Features Table: Concurrency"},{"content":"C++11 Core Language Features: Concurrency","pos":[7551,7592]},{"content":"Visual Studio 2010","pos":[7593,7611]},{"content":"Visual Studio 2012","pos":[7612,7630]},{"content":"Visual Studio 2015","pos":[7695,7713]},{"content":"Reworded sequence points","pos":[7911,7935]},{"content":"N/A","pos":[8005,8008]},{"content":"N/A","pos":[8009,8012]},{"content":"N/A","pos":[8013,8016]},{"content":"Yes","pos":[8017,8020]},{"content":"Atomics","pos":[8026,8033]},{"content":"No","pos":[8103,8105]},{"content":"Yes","pos":[8106,8109]},{"content":"Yes","pos":[8110,8113]},{"content":"Yes","pos":[8114,8117]},{"content":"Strong compare and exchange","pos":[8123,8150]},{"content":"No","pos":[8220,8222]},{"content":"Yes","pos":[8223,8226]},{"content":"Yes","pos":[8227,8230]},{"content":"Yes","pos":[8231,8234]},{"content":"Bidirectional fences","pos":[8240,8260]},{"content":"No","pos":[8329,8331]},{"content":"Yes","pos":[8332,8335]},{"content":"Yes","pos":[8336,8339]},{"content":"Yes","pos":[8340,8343]},{"content":"Memory model","pos":[8349,8361]},{"content":"N/A","pos":[8430,8433]},{"content":"N/A","pos":[8434,8437]},{"content":"N/A","pos":[8438,8441]},{"content":"Yes","pos":[8442,8445]},{"content":"Data-dependency ordering","pos":[8451,8475]},{"content":"No","pos":[8544,8546]},{"content":"Yes","pos":[8547,8550]},{"content":"Yes","pos":[8551,8554]},{"content":"Yes","pos":[8555,8558]},{"content":"Data-dependency ordering: function annotation","pos":[8564,8609]},{"content":"No","pos":[8678,8680]},{"content":"No","pos":[8681,8683]},{"content":"No","pos":[8684,8686]},{"content":"Yes","pos":[8687,8690]},{"content":"exception_ptr","pos":[8696,8709]},{"content":"Yes","pos":[8779,8782]},{"content":"Yes","pos":[8783,8786]},{"content":"Yes","pos":[8787,8790]},{"content":"Yes","pos":[8791,8794]},{"content":"quick_exit","pos":[8800,8810]},{"content":"No","pos":[8879,8881]},{"content":"No","pos":[8882,8884]},{"content":"No","pos":[8885,8887]},{"content":"Yes","pos":[8888,8891]},{"content":"Atomics in signal handlers","pos":[8897,8923]},{"content":"No","pos":[8992,8994]},{"content":"Yes","pos":[8995,8998]},{"content":"Yes","pos":[8999,9002]},{"content":"Yes","pos":[9003,9006]},{"content":"Thread-local storage","pos":[9012,9032]},{"content":"Partial","pos":[9101,9108]},{"content":"Partial","pos":[9109,9116]},{"content":"Partial","pos":[9117,9124]},{"content":"Yes","pos":[9125,9128]},{"content":"Magic statics","pos":[9134,9147]},{"content":"No","pos":[9216,9218]},{"content":"No","pos":[9219,9221]},{"content":"No","pos":[9222,9224]},{"content":"Yes","pos":[9225,9228]},{"pos":[9236,9261],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[9296,9329],"content":"C++11 Core Language Features: C99"},{"content":"C++11 Core Language Features: C99","pos":[9336,9369]},{"content":"Visual Studio 2010","pos":[9370,9388]},{"content":"Visual Studio 2012","pos":[9389,9407]},{"content":"Visual Studio 2015","pos":[9472,9490]},{"content":"__func","pos":[9680,9686]},{"content":"Partial","pos":[9759,9766]},{"content":"Partial","pos":[9767,9774]},{"content":"Partial","pos":[9775,9782]},{"content":"Yes","pos":[9783,9786]},{"content":"C99 preprocessor","pos":[9792,9808]},{"content":"Partial","pos":[9877,9884]},{"content":"Partial","pos":[9885,9892]},{"content":"Partial","pos":[9893,9900]},{"content":"Partial","pos":[9901,9908]},{"content":"long long","pos":[9914,9923]},{"content":"Yes","pos":[9992,9995]},{"content":"Yes","pos":[9996,9999]},{"content":"Yes","pos":[10000,10003]},{"content":"Yes","pos":[10004,10007]},{"content":"Extended integer types","pos":[10013,10035]},{"content":"N/A","pos":[10104,10107]},{"content":"N/A","pos":[10108,10111]},{"content":"N/A","pos":[10112,10115]},{"content":"N/A","pos":[10116,10119]},{"pos":[10127,10152],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[10189,10218],"content":"C++ 14 Core Language Features"},{"content":"Feature","pos":[10242,10249]},{"content":"Visual Studio 2013","pos":[10250,10268]},{"content":"Visual Studio 2015","pos":[10269,10287]},{"content":"Tweaked wording for contextual conversions","pos":[10292,10334]},{"content":"Yes","pos":[10335,10338]},{"content":"Yes","pos":[10339,10342]},{"content":"Binary literals","pos":[10347,10362]},{"content":"No","pos":[10363,10365]},{"content":"Yes","pos":[10366,10369]},{"content":"auto and decltype(auto) return types","pos":[10374,10410]},{"content":"No","pos":[10411,10413]},{"content":"Yes","pos":[10414,10417]},{"content":"init-captures","pos":[10422,10435]},{"content":"No","pos":[10436,10438]},{"content":"Yes","pos":[10439,10442]},{"content":"Generic lambdas","pos":[10447,10462]},{"content":"No","pos":[10463,10465]},{"content":"Yes","pos":[10466,10469]},{"content":"Variable templates","pos":[10474,10492]},{"content":"No","pos":[10493,10495]},{"content":"No","pos":[10496,10498]},{"content":"Extended constexpr","pos":[10503,10521]},{"content":"No","pos":[10522,10524]},{"content":"No","pos":[10525,10527]},{"content":"NSDMIs for aggregates","pos":[10532,10553]},{"content":"No","pos":[10554,10556]},{"content":"No","pos":[10557,10559]},{"content":"Avoiding/fusing allocations","pos":[10564,10591]},{"content":"No","pos":[10592,10594]},{"content":"No","pos":[10595,10597]},{"content":"[[deprecated]] attributes","pos":[10602,10627]},{"content":"No","pos":[10628,10630]},{"content":"No","pos":[10631,10633]},{"content":"Sized allocation","pos":[10638,10654]},{"content":"No","pos":[10655,10657]},{"content":"Yes","pos":[10658,10661]},{"content":"Digit separators","pos":[10666,10682]},{"content":"No","pos":[10683,10685]},{"content":"Yes","pos":[10686,10689]},{"pos":[10727,10764],"content":"C++17 Proposed Core Language Features"},{"content":"Feature","pos":[10788,10795]},{"content":"Visual Studio 2013","pos":[10796,10814]},{"content":"Visual Studio 2015","pos":[10815,10833]},{"content":"New rules for auto with braced-init-lists","pos":[10838,10879]},{"content":"No","pos":[10880,10882]},{"content":"No","pos":[10883,10885]},{"content":"Terse static assert","pos":[10890,10909]},{"content":"No","pos":[10910,10912]},{"content":"No","pos":[10913,10915]},{"content":"typename in template template-parameters","pos":[10920,10960]},{"content":"No","pos":[10961,10963]},{"content":"No","pos":[10964,10966]},{"content":"Removing trigraphs","pos":[10971,10989]},{"content":"Yes","pos":[10990,10993]},{"content":"Yes","pos":[10994,10997]},{"content":"Nested namespace definitions","pos":[11002,11030]},{"content":"No","pos":[11031,11033]},{"content":"No","pos":[11034,11036]},{"content":"N4259 std::uncaught_exceptions()","pos":[11041,11073]},{"content":"No","pos":[11074,11076]},{"content":"No","pos":[11077,11079]},{"content":"N4261 Fixing qualification conversions","pos":[11084,11122]},{"content":"No","pos":[11123,11125]},{"content":"No","pos":[11126,11128]},{"content":"N4266 Attributes for namespaces and enumerators","pos":[11133,11180]},{"content":"No","pos":[11181,11183]},{"content":"No","pos":[11184,11186]},{"content":"N4267 u8 character literals","pos":[11191,11218]},{"content":"No","pos":[11219,11221]},{"content":"No","pos":[11222,11224]},{"content":"N4268 Allowing more non-type template args","pos":[11229,11271]},{"content":"No","pos":[11272,11274]},{"content":"No","pos":[11275,11277]},{"content":"N4295 Fold expressions","pos":[11282,11304]},{"content":"No","pos":[11305,11307]},{"content":"No","pos":[11308,11310]},{"content":"await/resume","pos":[11315,11327]},{"content":"No","pos":[11328,11330]},{"content":"Yes","pos":[11331,11334]},{"pos":[11371,11398],"content":"Guide to the Feature Tables"},{"pos":[11430,11447],"content":"Rvalue References"},{"pos":[11455,11640],"content":"[!NOTE]\n The version designations (v0.1, v1.0, v2.0, v2.1, v3.0) in the following descriptions are invented just to show the evolution of C++11. The standard itself does not use them.","leadings":["","> "],"nodes":[{"content":" The version designations (v0.1, v1.0, v2.0, v2.1, v3.0) in the following descriptions are invented just to show the evolution of C++11. The standard itself does not use them.","pos":[8,183],"nodes":[{"content":"The version designations (v0.1, v1.0, v2.0, v2.1, v3.0) in the following descriptions are invented just to show the evolution of C++11.","pos":[1,136]},{"content":"The standard itself does not use them.","pos":[137,175]}]}]},{"content":"<bpt id=\"p1\">[</bpt>N1610 \"Clarification of Initialization of Class Objects by rvalues\"<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235093)</ept> was an early attempt to enable move semantics without rvalue references.","pos":[11647,11838],"source":"[N1610 \"Clarification of Initialization of Class Objects by rvalues\"](http://go.microsoft.com/fwlink/p/?LinkID=235093) was an early attempt to enable move semantics without rvalue references."},{"content":"For the sake of this discussion, let’s call it \"rvalue references v0.1\".","pos":[11840,11912]},{"content":"It was superseded by \"rvalue references <bpt id=\"p1\">[</bpt>v1.0<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235094)</ept>.\"","pos":[11913,12010],"source":" It was superseded by \"rvalue references [v1.0](http://go.microsoft.com/fwlink/p/?LinkID=235094).\""},{"content":"\"Rvalue references <bpt id=\"p1\">[</bpt>v2.0<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235095)</ept>\", which is what the work in Visual C++ in Visual Studio 2010 was based on, prohibits rvalue references from binding to lvalues and thereby fixes a major safety problem.","pos":[12011,12254],"source":" \"Rvalue references [v2.0](http://go.microsoft.com/fwlink/p/?LinkID=235095)\", which is what the work in Visual C++ in Visual Studio 2010 was based on, prohibits rvalue references from binding to lvalues and thereby fixes a major safety problem."},{"content":"\"Rvalue references <bpt id=\"p1\">[</bpt>v2.1<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235096)</ept>\" refines this rule.","pos":[12256,12350],"source":"  \"Rvalue references [v2.1](http://go.microsoft.com/fwlink/p/?LinkID=235096)\" refines this rule."},{"content":"Consider <ph id=\"ph1\">`vector&lt;string&gt;::push_back()`</ph>, which has the overloads <ph id=\"ph2\">`push_back(const string&amp;)`</ph> and <ph id=\"ph3\">`push_back(string&amp;&amp;)`</ph>, and the call <ph id=\"ph4\">`v.push_back(\"strval\")`</ph>.","pos":[12352,12507],"source":"  Consider `vector<string>::push_back()`, which has the overloads `push_back(const string&)` and `push_back(string&&)`, and the call `v.push_back(\"strval\")`."},{"content":"The expression <ph id=\"ph1\">`\"strval\"`</ph> is a string literal, and is an lvalue.","pos":[12509,12573],"source":"  The expression `\"strval\"` is a string literal, and is an lvalue."},{"content":"(Other literals—for example, the integer 1729—are rvalues, but string literals are special because they are arrays.)  The \"rvalue references v2.0\" rules said that <ph id=\"ph1\">`string&amp;&amp;`</ph> cannot bind to <ph id=\"ph2\">`\"strval\"`</ph> because <ph id=\"ph3\">`\"strval\"`</ph> is an lvalue and therefore, <ph id=\"ph4\">`push_back(const string&amp;)`</ph> is the only viable overload.","pos":[12575,12877],"source":"  (Other literals—for example, the integer 1729—are rvalues, but string literals are special because they are arrays.)  The \"rvalue references v2.0\" rules said that `string&&` cannot bind to `\"strval\"` because `\"strval\"` is an lvalue and therefore, `push_back(const string&)` is the only viable overload."},{"content":"This would create a temporary <ph id=\"ph1\">`std::string`</ph>, copy it into the vector, and then destroy the temporary <ph id=\"ph2\">`std::string`</ph>, which wasn’t very efficient.","pos":[12879,13023],"source":"  This would create a temporary `std::string`, copy it into the vector, and then destroy the temporary `std::string`, which wasn’t very efficient."},{"content":"The \"rvalue references v2.1\" rules recognize that binding <ph id=\"ph1\">`string&amp;&amp;`</ph> to <ph id=\"ph2\">`\"strval\"`</ph> would create a temporary <ph id=\"ph3\">`std::string`</ph>, and that temporary is an rvalue.","pos":[13024,13179],"source":" The \"rvalue references v2.1\" rules recognize that binding `string&&` to `\"strval\"` would create a temporary `std::string`, and that temporary is an rvalue."},{"content":"Therefore, both <ph id=\"ph1\">`push_back(const string&amp;)`</ph> and <ph id=\"ph2\">`push_back(string&amp;&amp;)`</ph> are viable, and <ph id=\"ph3\">`push_back(string&amp;&amp;)`</ph> is preferred.","pos":[13181,13301],"source":"  Therefore, both `push_back(const string&)` and `push_back(string&&)` are viable, and `push_back(string&&)` is preferred."},{"content":"A temporary <ph id=\"ph1\">`std::string`</ph> is constructed, and then moved into the vector.","pos":[13303,13376],"source":"  A temporary `std::string` is constructed, and then moved into the vector."},{"content":"This is more efficient.","pos":[13378,13401]},{"content":"\"Rvalue references <bpt id=\"p1\">[</bpt>v3.0<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235097)</ept>\" adds new rules to automatically generate move constructors and move assignment operators under certain conditions.","pos":[13408,13598],"source":"\"Rvalue references [v3.0](http://go.microsoft.com/fwlink/p/?LinkID=235097)\" adds new rules to automatically generate move constructors and move assignment operators under certain conditions."},{"content":"This is implemented in Visual Studio 2015.","pos":[13599,13641]},{"pos":[13648,13673],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[13707,13714],"content":"Lambdas"},{"content":"After <bpt id=\"p1\">[</bpt>lambda functions<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept> were voted into the Working Paper (<bpt id=\"p2\">[</bpt>version \"0.9\"<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=235098)</ept>) and mutable lambdas were added (<bpt id=\"p3\">[</bpt>version \"1.0\"<ept id=\"p3\">](http://go.microsoft.com/fwlink/p/?LinkID=235099)</ept>), the Standardization Committee overhauled the wording.","pos":[13718,14033],"source":"After [lambda functions](../cpp/lambda-expressions-in-cpp.md) were voted into the Working Paper ([version \"0.9\"](http://go.microsoft.com/fwlink/p/?LinkID=235098)) and mutable lambdas were added ([version \"1.0\"](http://go.microsoft.com/fwlink/p/?LinkID=235099)), the Standardization Committee overhauled the wording."},{"content":"This produced lambdas  <bpt id=\"p1\">[</bpt>version \"1.1\"<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235100)</ept>, which is now fully supported.","pos":[14034,14152],"source":" This produced lambdas  [version \"1.1\"](http://go.microsoft.com/fwlink/p/?LinkID=235100), which is now fully supported."},{"content":"The lambdas v1.1 wording clarifies what should occur in corner cases like referring to static members or nested lambdas.","pos":[14154,14274]},{"content":"This fixes problems that are triggered by complex lambdas.","pos":[14276,14334]},{"content":"Additionally, stateless lambdas are now convertible to function pointers.","pos":[14336,14409]},{"content":"This is not in the N2927 wording, but it is counted as part of lambdas v1.1 anyway.","pos":[14411,14494]},{"content":"<bpt id=\"p1\">[</bpt>C++11<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235092)</ept><bpt id=\"p2\">**</bpt>5.1.2 [expr.prim.lambda]/6<ept id=\"p2\">**</ept> has this description: \"The closure type for a <ph id=\"ph1\">`lambda-expression`</ph> with no <ph id=\"ph2\">`lambda-capture`</ph> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator.","pos":[14496,14849],"source":"[C++11](http://go.microsoft.com/fwlink/p/?LinkID=235092)**5.1.2 [expr.prim.lambda]/6** has this description: \"The closure type for a `lambda-expression` with no `lambda-capture` has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator."},{"content":"The value returned by this conversion function shall be the address of a function that, when invoked, has the same eﬀect as invoking the closure type’s function call operator.\"","pos":[14850,15026]},{"content":"(The <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph> implementation is even better than that, because it makes stateless lambdas convertible to function pointers that have arbitrary calling conventions.","pos":[15028,15249],"source":"  (The [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] implementation is even better than that, because it makes stateless lambdas convertible to function pointers that have arbitrary calling conventions."},{"content":"This is important when you are using APIs that expect things like <ph id=\"ph1\">`__stdcall`</ph> function pointers.)","pos":[15251,15348],"source":"  This is important when you are using APIs that expect things like `__stdcall` function pointers.)"},{"pos":[15355,15380],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[15415,15423],"content":"decltype"},{"content":"After decltype was voted into the Working Paper (<bpt id=\"p1\">[</bpt>version 1.0<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235101)</ept>), it received a small but important fix at the last minute (<bpt id=\"p2\">[</bpt>version 1.1<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=235102)</ept>).","pos":[15427,15663],"source":"After decltype was voted into the Working Paper ([version 1.0](http://go.microsoft.com/fwlink/p/?LinkID=235101)), it received a small but important fix at the last minute ([version 1.1](http://go.microsoft.com/fwlink/p/?LinkID=235102))."},{"content":"This is of great interest to programmers who work on the STL and Boost.","pos":[15665,15736]},{"pos":[15743,15768],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[15808,15845],"content":"Strongly Typed/Forward Declared enums"},{"content":"<bpt id=\"p1\">[</bpt>Strongly typed enums<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235103)</ept> were partially supported in Visual C++ in Visual Studio 2010 (specifically, the part about explicitly specified underlying types).","pos":[15849,16051],"source":"[Strongly typed enums](http://go.microsoft.com/fwlink/p/?LinkID=235103) were partially supported in Visual C++ in Visual Studio 2010 (specifically, the part about explicitly specified underlying types)."},{"content":"These are now fully implemented in Visual Studio, and the C++11 semantics for <bpt id=\"p1\">[</bpt>forward declared enums<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235104)</ept> are also fully implemented.","pos":[16052,16231],"source":" These are now fully implemented in Visual Studio, and the C++11 semantics for [forward declared enums](http://go.microsoft.com/fwlink/p/?LinkID=235104) are also fully implemented."},{"pos":[16238,16263],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[16299,16308],"content":"Alignment"},{"content":"The Core Language keywords <ph id=\"ph1\">`alignas`/`alignof`</ph> from the <bpt id=\"p1\">[</bpt>alignment proposal<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235105)</ept> that was voted into the Working Paper are implemented in Visual Studio 2015.","pos":[16312,16514],"source":"The Core Language keywords `alignas`/`alignof` from the [alignment proposal](http://go.microsoft.com/fwlink/p/?LinkID=235105) that was voted into the Working Paper are implemented in Visual Studio 2015."},{"content":"Visual C++ in Visual Studio 2010 had <ph id=\"ph1\">`aligned_storage`</ph> from TR1.","pos":[16516,16580],"source":"  Visual C++ in Visual Studio 2010 had `aligned_storage` from TR1."},{"content":"added <ph id=\"ph1\">`aligned_union`</ph> and <ph id=\"ph2\">`std::align()`</ph> to the Standard Library and significant issues were fixed in <ph id=\"ph3\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>.","pos":[16648,16827],"source":" added `aligned_union` and `std::align()` to the Standard Library and significant issues were fixed in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]."},{"pos":[16834,16859],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[16900,16933],"content":"Standard-Layout and Trivial Types"},{"content":"The exposed changes from <bpt id=\"p1\">[</bpt>N2342 \"POD's Revisited; Resolving Core Issue 568 (Revision 5)\"<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235106)</ept> are the additions of <ph id=\"ph1\">`is_trivial`</ph> and <ph id=\"ph2\">`is_standard_layout`</ph> to the Standard Template Library's <ph id=\"ph3\">`&lt;type_traits&gt;`</ph>.","pos":[16937,17186],"source":"The exposed changes from [N2342 \"POD's Revisited; Resolving Core Issue 568 (Revision 5)\"](http://go.microsoft.com/fwlink/p/?LinkID=235106) are the additions of `is_trivial` and `is_standard_layout` to the Standard Template Library's `<type_traits>`."},{"content":"(N2342 reworked a lot of the Core Language wording, but no compiler changes were required.)  These type traits were available in Visual C++ in Visual Studio 2010, but they just duplicated <ph id=\"ph1\">`is_pod`</ph>.","pos":[17188,17385],"source":"  (N2342 reworked a lot of the Core Language wording, but no compiler changes were required.)  These type traits were available in Visual C++ in Visual Studio 2010, but they just duplicated `is_pod`."},{"content":"Therefore, the table earlier in this document said \"No\" support.","pos":[17386,17450]},{"content":"They are now powered by compiler hooks that are designed to give accurate answers.","pos":[17452,17534]},{"content":"The STL's <bpt id=\"p1\">[</bpt>common_type&lt;&gt;<ept id=\"p1\">](../standard-library/common-type-class.md)</ept> received a much-needed fix in <ph id=\"ph1\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>.","pos":[17541,17716],"source":"The STL's [common_type<>](../standard-library/common-type-class.md) received a much-needed fix in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]."},{"content":"The C++11 specification for <ph id=\"ph1\">`common_type&lt;&gt;`</ph> had unexpected and undesired consequences; in particular, it makes <ph id=\"ph2\">`common_type&lt;int, int&gt;::type`</ph> return <ph id=\"ph3\">`int&amp;&amp;`</ph>.","pos":[17718,17874],"source":"  The C++11 specification for `common_type<>` had unexpected and undesired consequences; in particular, it makes `common_type<int, int>::type` return `int&&`."},{"content":"Therefore, <ph id=\"ph1\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph> implements the <bpt id=\"p1\">[</bpt>Proposed Resolution for Library Working Group issue 2141<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=320075)</ept>, which makes <ph id=\"ph2\">`common_type&lt;int, int&gt;::type`</ph> return <ph id=\"ph3\">`int`</ph>.","pos":[17875,18142],"source":" Therefore, [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] implements the [Proposed Resolution for Library Working Group issue 2141](http://go.microsoft.com/fwlink/p/?LinkId=320075), which makes `common_type<int, int>::type` return `int`."},{"content":"As a side-effect of this change, the identity case no longer works (<ph id=\"ph1\">`common_type&lt;T&gt;`</ph> does not always result in type <ph id=\"ph2\">`T`</ph>).","pos":[18149,18270],"source":"As a side-effect of this change, the identity case no longer works (`common_type<T>` does not always result in type `T`)."},{"content":"This complies with the Proposed Resolution, but it breaks any code that relied on the previous behavior.","pos":[18271,18375]},{"content":"If you require an identity type trait, don't use the non-standard <ph id=\"ph1\">`std::identity`</ph> that's defined in <ph id=\"ph2\">`&lt;type_traits&gt;`</ph> because it won't work for <ph id=\"ph3\">`&lt;void&gt;`</ph>.","pos":[18382,18533],"source":"If you require an identity type trait, don't use the non-standard `std::identity` that's defined in `<type_traits>` because it won't work for `<void>`."},{"content":"Instead, implement your own identity type trait to suit your needs.","pos":[18534,18601]},{"content":"Here's an example:","pos":[18602,18620]},{"pos":[18718,18852],"content":"[!NOTE]\n For other breaking changes, see [Visual C++ change history 2003 - 2015](../porting/visual-cpp-change-history-2003-2015.md).","leadings":["","> "],"nodes":[{"content":"For other breaking changes, see <bpt id=\"p1\">[</bpt>Visual C++ change history 2003 - 2015<ept id=\"p1\">](../porting/visual-cpp-change-history-2003-2015.md)</ept>.","pos":[9,132],"source":" For other breaking changes, see [Visual C++ change history 2003 - 2015](../porting/visual-cpp-change-history-2003-2015.md)."}]},{"pos":[18859,18884],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[18930,18961],"content":"Defaulted and Deleted Functions"},{"content":"These are now supported, but with this exception: For defaulted functions, the use of <ph id=\"ph1\">`=default`</ph> to request member-wise move constructors and move assignment operators is not supported.","pos":[18965,19150],"source":"These are now supported, but with this exception: For defaulted functions, the use of `=default` to request member-wise move constructors and move assignment operators is not supported."},{"content":"The copies and moves don't interact precisely like the Standard says they should—for example, deletion of moves is specified to also suppress copies, but <ph id=\"ph1\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph> does not.","pos":[19151,19391],"source":" The copies and moves don't interact precisely like the Standard says they should—for example, deletion of moves is specified to also suppress copies, but [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] does not."},{"pos":[19398,19505],"content":"For information about how to use defaulted and deleted functions, see <bpt id=\"p1\">[</bpt>Functions<ept id=\"p1\">](../cpp/functions-cpp.md)</ept>.","source":"For information about how to use defaulted and deleted functions, see [Functions](../cpp/functions-cpp.md)."},{"pos":[19512,19537],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[19580,19598],"content":"override and final"},{"content":"This went through a short but complicated evolution.","pos":[19602,19654]},{"content":"Originally, in <bpt id=\"p1\">[</bpt>version 0.8<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235108)</ept>, there were [[<ph id=\"ph1\">`override`</ph>]], [[<ph id=\"ph2\">`hiding`</ph>]], and [[<ph id=\"ph3\">`base_check`</ph>]] attributes.","pos":[19655,19807],"source":" Originally, in [version 0.8](http://go.microsoft.com/fwlink/p/?LinkID=235108), there were [[`override`]], [[`hiding`]], and [[`base_check`]] attributes."},{"content":"Then in <bpt id=\"p1\">[</bpt>version 0.9<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235109)</ept>, the attributes were eliminated and replaced with contextual keywords.","pos":[19809,19950],"source":"  Then in [version 0.9](http://go.microsoft.com/fwlink/p/?LinkID=235109), the attributes were eliminated and replaced with contextual keywords."},{"content":"Finally, in <bpt id=\"p1\">[</bpt>version 1.0<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235110)</ept>, they were reduced to \"<ph id=\"ph1\">`final`</ph>\" on classes, and \"<ph id=\"ph2\">`override`</ph>\" and \"<ph id=\"ph3\">`final`</ph>\" on functions.","pos":[19952,20115],"source":"  Finally, in [version 1.0](http://go.microsoft.com/fwlink/p/?LinkID=235110), they were reduced to \"`final`\" on classes, and \"`override`\" and \"`final`\" on functions."},{"content":"This makes it an Ascended Extension because Visual C++ in Visual Studio 2010 already supported this \"<ph id=\"ph1\">`override`</ph>\" syntax on functions, and had semantics reasonably close to those in C++11.","pos":[20117,20304],"source":"  This makes it an Ascended Extension because Visual C++ in Visual Studio 2010 already supported this \"`override`\" syntax on functions, and had semantics reasonably close to those in C++11."},{"content":"\"<ph id=\"ph1\">`final`</ph>\" was also supported, but under the different spelling \"sealed\".","pos":[20306,20378],"source":"  \"`final`\" was also supported, but under the different spelling \"sealed\"."},{"content":"The Standard spelling and semantics of \"<ph id=\"ph1\">`override`</ph>\" and \"<ph id=\"ph2\">`final`</ph>\" are now completely supported.","pos":[20380,20475],"source":"  The Standard spelling and semantics of \"`override`\" and \"`final`\" are now completely supported."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>override Specifier<ept id=\"p1\">](../cpp/override-specifier.md)</ept> and <bpt id=\"p2\">[</bpt>final Specifier<ept id=\"p2\">](../cpp/final-specifier.md)</ept>.","pos":[20476,20602],"source":" For more information, see [override Specifier](../cpp/override-specifier.md) and [final Specifier](../cpp/final-specifier.md)."},{"pos":[20609,20634],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[20668,20685],"content":"Atomics, and More"},{"pos":[20689,21044],"content":"<bpt id=\"p1\">[</bpt>Atomics<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235111)</ept>, <bpt id=\"p2\">[</bpt>strong compare and exchange<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=235112)</ept>, <bpt id=\"p3\">[</bpt>bidirectional fences<ept id=\"p3\">](http://go.microsoft.com/fwlink/p/?LinkID=235113)</ept>, and <bpt id=\"p4\">[</bpt>data-dependency ordering<ept id=\"p4\">](http://go.microsoft.com/fwlink/p/?LinkID=235114)</ept> specify Standard Library machinery, which are now implemented.","source":"[Atomics](http://go.microsoft.com/fwlink/p/?LinkID=235111), [strong compare and exchange](http://go.microsoft.com/fwlink/p/?LinkID=235112), [bidirectional fences](http://go.microsoft.com/fwlink/p/?LinkID=235113), and [data-dependency ordering](http://go.microsoft.com/fwlink/p/?LinkID=235114) specify Standard Library machinery, which are now implemented."},{"pos":[21051,21469],"content":"<bpt id=\"p1\">**</bpt>Related STL headers:<ept id=\"p1\">**</ept> <bpt id=\"p2\">[</bpt><ph id=\"ph1\">\\&lt;</ph>atomic&gt;<ept id=\"p2\">](../standard-library/atomic.md)</ept>, <bpt id=\"p3\">[</bpt><ph id=\"ph2\">\\&lt;</ph>chrono&gt;<ept id=\"p3\">](../standard-library/chrono.md)</ept>, <bpt id=\"p4\">[</bpt>&lt;condition_variable&gt;<ept id=\"p4\">](../standard-library/condition-variable.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph3\">\\&lt;</ph>future&gt;<ept id=\"p5\">](../standard-library/future.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph4\">\\&lt;</ph>mutex&gt;<ept id=\"p6\">](../standard-library/mutex.md)</ept>, <bpt id=\"p7\">[</bpt><ph id=\"ph5\">\\&lt;</ph>ratio&gt;<ept id=\"p7\">](../standard-library/ratio.md)</ept>, <bpt id=\"p8\">[</bpt>&lt;scoped_allocator&gt;<ept id=\"p8\">](../standard-library/scoped-allocator.md)</ept>, and <bpt id=\"p9\">[</bpt><ph id=\"ph6\">\\&lt;</ph>thread&gt;<ept id=\"p9\">](../standard-library/thread.md)</ept>.","source":"**Related STL headers:** [\\<atomic>](../standard-library/atomic.md), [\\<chrono>](../standard-library/chrono.md), [<condition_variable>](../standard-library/condition-variable.md), [\\<future>](../standard-library/future.md), [\\<mutex>](../standard-library/mutex.md), [\\<ratio>](../standard-library/ratio.md), [<scoped_allocator>](../standard-library/scoped-allocator.md), and [\\<thread>](../standard-library/thread.md)."},{"pos":[21476,21501],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[21531,21568],"content":"C99 __func<ph id=\"ph1\">\\_\\_</ph> and Preprocessor Rules","source":" C99 __func\\_\\_ and Preprocessor Rules"},{"content":"The table <bpt id=\"p1\">[</bpt>C++11 Core Language Features: C99<ept id=\"p1\">](#c99table)</ept> lists \"Partial\" implementation for two items.","pos":[21572,21674],"source":"The table [C++11 Core Language Features: C99](#c99table) lists \"Partial\" implementation for two items."},{"content":"For the pre-defined identifier <ph id=\"ph1\">`__func__`</ph>, \"Partial\" is listed because support is provided for the non-Standard extensions <ph id=\"ph2\">`__FUNCDNAME__`</ph>, <ph id=\"ph3\">`__FUNCSIG__`</ph>, and <ph id=\"ph4\">`__FUNCTION__`</ph>.","pos":[21675,21849],"source":" For the pre-defined identifier `__func__`, \"Partial\" is listed because support is provided for the non-Standard extensions `__FUNCDNAME__`, `__FUNCSIG__`, and `__FUNCTION__`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Predefined Macros<ept id=\"p1\">](../preprocessor/predefined-macros.md)</ept>.","pos":[21850,21934],"source":" For more information, see [Predefined Macros](../preprocessor/predefined-macros.md)."},{"content":"For C99 preprocessor rules, \"Partial\" is listed because <bpt id=\"p1\">*</bpt>variadic macros<ept id=\"p1\">*</ept> are supported.","pos":[21935,22023],"source":" For C99 preprocessor rules, \"Partial\" is listed because *variadic macros* are supported."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Variadic Macros<ept id=\"p1\">](../preprocessor/variadic-macros.md)</ept>.","pos":[22024,22104],"source":" For more information, see [Variadic Macros](../preprocessor/variadic-macros.md)."},{"pos":[22111,22136],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"pos":[22166,22191],"content":"Standard Library Features"},{"content":"That covers the Core Language.","pos":[22195,22225]},{"content":"As for the C++11 Standard Library, we don't have a pretty comparison table of features, but <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph> implemented it, with two exceptions.","pos":[22226,22421],"source":" As for the C++11 Standard Library, we don't have a pretty comparison table of features, but [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] implemented it, with two exceptions."},{"content":"First, when a library feature depended on functionality that was missing in the compiler, it was either simulated—for example, simulated variadic templates for <ph id=\"ph1\">`make_shared&lt;T&gt;()`</ph>—or it wasn't implemented.","pos":[22423,22627],"source":"  First, when a library feature depended on functionality that was missing in the compiler, it was either simulated—for example, simulated variadic templates for `make_shared<T>()`—or it wasn't implemented."},{"content":"(There were only a few cases—most notably, <ph id=\"ph1\">`&lt;initializer_list&gt;`</ph>—which were fully implemented in <ph id=\"ph2\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>.)  With very few exceptions, C99 was implemented in <ph id=\"ph3\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph> and C++ wrapper headers provided.","pos":[22628,22963],"source":" (There were only a few cases—most notably, `<initializer_list>`—which were fully implemented in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)].)  With very few exceptions, C99 was implemented in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] and C++ wrapper headers provided."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>C99 library support in Visual Studio 2013<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=321308)</ept>.","pos":[22964,23083],"source":" For more information, see [C99 library support in Visual Studio 2013](http://go.microsoft.com/fwlink/p/?LinkId=321308)."},{"pos":[23090,23278],"content":"Here's a partial list of the changes in <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>:","source":"Here's a partial list of the changes in [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] and [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]:"},{"content":"<bpt id=\"p1\">**</bpt>Emplacement:<ept id=\"p1\">**</ept> As required by C++11, <ph id=\"ph1\">`emplace()`/`emplace_front()`/`emplace_back()`/`emplace_hint()`/`emplace_after()`</ph> are implemented in all containers for \"arbitrary\" numbers of arguments (see the \"Simulated variadics\" section).","pos":[23285,23517],"source":"**Emplacement:** As required by C++11, `emplace()`/`emplace_front()`/`emplace_back()`/`emplace_hint()`/`emplace_after()` are implemented in all containers for \"arbitrary\" numbers of arguments (see the \"Simulated variadics\" section)."},{"content":"For example, <ph id=\"ph1\">`vector&lt;T&gt;`</ph> has \"<ph id=\"ph2\">`template &lt;typename... Args&gt; void emplace_back(Args&amp;&amp;... args)`</ph>\", which directly constructs an element of type T at the back of the vector from an arbitrary number of arbitrary arguments, perfectly forwarded.","pos":[23519,23757],"source":"  For example, `vector<T>` has \"`template <typename... Args> void emplace_back(Args&&... args)`\", which directly constructs an element of type T at the back of the vector from an arbitrary number of arbitrary arguments, perfectly forwarded."},{"content":"This can be more efficient than <ph id=\"ph1\">`push_back(T&amp;&amp;)`</ph>, which would involve an extra move construction and destruction.","pos":[23759,23872],"source":"  This can be more efficient than `push_back(T&&)`, which would involve an extra move construction and destruction."},{"content":"<bpt id=\"p1\">**</bpt>Variadics:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph> had a scheme for simulating variadic templates.","pos":[23879,24008],"source":"**Variadics:** [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] had a scheme for simulating variadic templates."},{"content":"In <ph id=\"ph1\">[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]</ph>, the simulations are gone and <bpt id=\"p1\">**</bpt>variadics are fully implemented<ept id=\"p1\">**</ept>.","pos":[24009,24155],"source":" In [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)], the simulations are gone and **variadics are fully implemented**."},{"content":"If your code relies on the old simulated variadics behavior, you have to fix it.","pos":[24156,24236]},{"content":"However, the switch to real variadic templates has <bpt id=\"p1\">**</bpt>improved compile times<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>reduced compiler memory consumption<ept id=\"p2\">**</ept>.","pos":[24237,24359],"source":" However, the switch to real variadic templates has **improved compile times** and **reduced compiler memory consumption**."},{"content":"<bpt id=\"p1\">**</bpt>Explicit conversion operators:<ept id=\"p1\">**</ept> In the Core Language, explicit conversion operators are a general feature—for example, you can have <ph id=\"ph1\">`explicit operator MyClass()`</ph>.","pos":[24366,24531],"source":"**Explicit conversion operators:** In the Core Language, explicit conversion operators are a general feature—for example, you can have `explicit operator MyClass()`."},{"content":"However, the Standard Library currently uses only one form: <ph id=\"ph1\">`explicit operator bool()`</ph>, which makes classes safely Boolean-testable.","pos":[24532,24664],"source":" However, the Standard Library currently uses only one form: `explicit operator bool()`, which makes classes safely Boolean-testable."},{"content":"(Plain \"<ph id=\"ph1\">`operator bool()`</ph>\" is notoriously dangerous.) Previously, Visual C++ simulated <ph id=\"ph2\">`explicit operator bool()`</ph> with <ph id=\"ph3\">`operator pointer-to-member()`</ph>, which led to various headaches and slight inefficiencies.","pos":[24665,24873],"source":" (Plain \"`operator bool()`\" is notoriously dangerous.) Previously, Visual C++ simulated `explicit operator bool()` with `operator pointer-to-member()`, which led to various headaches and slight inefficiencies."},{"content":"Now, this \"fake bool\" workaround is completely removed.","pos":[24874,24929]},{"pos":[24936,25135],"content":"<bpt id=\"p1\">**</bpt>Randomness:<ept id=\"p1\">**</ept> <ph id=\"ph1\">`uniform_int_distribution`</ph> is now perfectly unbiased, and <ph id=\"ph2\">`shuffle()`</ph> is implemented in <ph id=\"ph3\">`&lt;algorithm&gt;`</ph>, which directly accepts Uniform Random Number Generators like <ph id=\"ph4\">`mersenne_twister`</ph>.","source":"**Randomness:** `uniform_int_distribution` is now perfectly unbiased, and `shuffle()` is implemented in `<algorithm>`, which directly accepts Uniform Random Number Generators like `mersenne_twister`."},{"content":"<bpt id=\"p1\">**</bpt>Resistance to overloaded address-of operators:<ept id=\"p1\">**</ept> C++98/03 prohibited an element of an STL container from overloading its address-of operator.","pos":[25142,25285],"source":"**Resistance to overloaded address-of operators:** C++98/03 prohibited an element of an STL container from overloading its address-of operator."},{"content":"This is what classes like <ph id=\"ph1\">`CComPtr`</ph> do, so that helper classes like <ph id=\"ph2\">`CAdapt`</ph> were required to shield the STL from such overloads.","pos":[25287,25416],"source":"  This is what classes like `CComPtr` do, so that helper classes like `CAdapt` were required to shield the STL from such overloads."},{"content":"During the development of Visual C++ in Visual Studio 2010, STL changes made it reject overloaded address-of operators in even more situations.","pos":[25418,25561]},{"content":"C++11 changed the requirements to make overloaded address-of operators acceptable.","pos":[25562,25644]},{"content":"C++11, and Visual C++ in Visual Studio 2010, provide the helper function <ph id=\"ph1\">`std::addressof()`</ph>, which can get the true address of an object regardless of operator overloading.","pos":[25645,25817],"source":" C++11, and Visual C++ in Visual Studio 2010, provide the helper function `std::addressof()`, which can get the true address of an object regardless of operator overloading."},{"content":"Before Visual C++ in Visual Studio 2010 was released, we attempted to replace occurrences of \"<ph id=\"ph1\">`&amp;elem`</ph>\" with \"<ph id=\"ph2\">`std::addressof(elem)`</ph>\", which is appropriately resistant.","pos":[25819,25986],"source":"  Before Visual C++ in Visual Studio 2010 was released, we attempted to replace occurrences of \"`&elem`\" with \"`std::addressof(elem)`\", which is appropriately resistant."},{"content":"went further, so that classes that overload their address-of operator should be usable throughout the STL.","pos":[26055,26161]},{"pos":[26237,26271],"content":"went beyond C++11 in several ways:"},{"pos":[26280,26667],"content":"<bpt id=\"p1\">**</bpt>SCARY iterators:<ept id=\"p1\">**</ept> As permitted but not required by the C++11 Standard, SCARY iterators have been implemented, as described by <bpt id=\"p2\">[</bpt>N2911 \"Minimizing Dependencies within Generic Classes for Faster and Smaller Programs\"<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=235115)</ept> and <bpt id=\"p3\">[</bpt>N2980 \"SCARY Iterator Assignment and Initialization, Revision 1\"<ept id=\"p3\">](http://go.microsoft.com/fwlink/p/?LinkID=235116)</ept>.","source":"**SCARY iterators:** As permitted but not required by the C++11 Standard, SCARY iterators have been implemented, as described by [N2911 \"Minimizing Dependencies within Generic Classes for Faster and Smaller Programs\"](http://go.microsoft.com/fwlink/p/?LinkID=235115) and [N2980 \"SCARY Iterator Assignment and Initialization, Revision 1\"](http://go.microsoft.com/fwlink/p/?LinkID=235116)."},{"content":"<bpt id=\"p1\">**</bpt>Filesystem:<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`&lt;filesystem&gt;`</ph> header from <bpt id=\"p2\">[</bpt>the TR2 proposal<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkID=235117)</ept> has been added.","pos":[26674,26804],"source":"**Filesystem:** The `<filesystem>` header from [the TR2 proposal](http://go.microsoft.com/fwlink/p/?LinkID=235117) has been added."},{"content":"It offers <ph id=\"ph1\">`recursive_directory_iterator`</ph> and other interesting features.","pos":[26805,26877],"source":" It offers `recursive_directory_iterator` and other interesting features."},{"content":"Before work on TR2 was frozen because C++0x was running very late and was changing to C++11, the 2006 proposal was derived from <bpt id=\"p1\">[</bpt>Boost.Filesystem V2<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=235118)</ept>.","pos":[26879,27078],"source":"  Before work on TR2 was frozen because C++0x was running very late and was changing to C++11, the 2006 proposal was derived from [Boost.Filesystem V2](http://go.microsoft.com/fwlink/p/?LinkID=235118)."},{"content":"It later evolved into Boost.Filesystem V3, which is implemented in Visual Studio 2015.","pos":[27079,27165]},{"content":"And a major optimization!","pos":[27172,27197]},{"content":"All of our containers are now optimally small given their current representations.","pos":[27199,27281]},{"content":"This refers to the container objects themselves, not to their pointed-to contents.","pos":[27283,27365]},{"content":"For example, <ph id=\"ph1\">`std::vector`</ph> contains three raw pointers.","pos":[27367,27422],"source":"  For example, `std::vector` contains three raw pointers."},{"content":"In Visual C++ in Visual Studio 2010, x86 release mode, <ph id=\"ph1\">`std::vector`</ph> was 16 bytes.","pos":[27424,27506],"source":"  In Visual C++ in Visual Studio 2010, x86 release mode, `std::vector` was 16 bytes."},{"content":"In <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph>, it is 12 bytes, which is optimally small.","pos":[27508,27620],"source":"  In [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)], it is 12 bytes, which is optimally small."},{"content":"This is a big deal—if you have 100,000 vectors in your program, <ph id=\"ph1\">[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)]</ph> saves you 400,000 bytes.","pos":[27622,27777],"source":"  This is a big deal—if you have 100,000 vectors in your program, [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] saves you 400,000 bytes."},{"content":"Decreased memory usage saves both space and time.","pos":[27779,27828]},{"content":"This was achieved by avoiding the storage of empty allocators and comparators, because <ph id=\"ph1\">`std::allocator`</ph> and <ph id=\"ph2\">`std::less`</ph> are stateless.","pos":[27835,27969],"source":"This was achieved by avoiding the storage of empty allocators and comparators, because `std::allocator` and `std::less` are stateless."},{"content":"(These optimizations are enabled for custom allocators/comparators too, as long as they are stateless.","pos":[27971,28073]},{"content":"Obviously, storage of stateful allocators/comparators cannot be avoided, but those are very rare.)","pos":[28075,28173]},{"pos":[28259,28303],"content":"implemented some key C++14 library features:"},{"pos":[28315,28406],"content":"\"Transparent operator functors\" <ph id=\"ph1\">`less&lt;&gt;`</ph>, <ph id=\"ph2\">`greater&lt;&gt;`</ph>, <ph id=\"ph3\">`plus&lt;&gt;`</ph>, <ph id=\"ph4\">`multiplies&lt;&gt;`</ph>, and so on.","source":"\"Transparent operator functors\" `less<>`, `greater<>`, `plus<>`, `multiplies<>`, and so on."},{"pos":[28442,28445],"content":"and"},{"pos":[28496,28566],"content":", <ph id=\"ph1\">`rbegin()`/`rend()`</ph>, and <ph id=\"ph2\">`crbegin()`/`crend()`</ph> non-member functions.","source":", `rbegin()`/`rend()`, and `crbegin()`/`crend()` non-member functions."},{"pos":[28573,28598],"content":"[<bpt id=\"p1\">[</bpt>In This Article<ept id=\"p1\">](#top)</ept>]","source":"[[In This Article](#top)]"},{"content":"See Also","pos":[28607,28615]},{"content":"Welcome Back to C++","pos":[28620,28639]},{"content":"C++ Language Reference","pos":[28688,28710]},{"content":"Lambda Expressions","pos":[28751,28769]},{"content":"Range-based for Statement (C++)","pos":[28813,28844]},{"content":"C++ Standard Library","pos":[28892,28912]},{"content":"Visual C++ Team Blog","pos":[28974,28994]},{"content":"What's New for Visual C++","pos":[29034,29059]},{"content":"Visual C++ change history 2003 - 2015","pos":[29116,29153]}],"content":"---\ntitle: \"Support For C++11-14-17 Features (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: dd2d5cbc-caf5-4a11-a057-8c365decba4e\ncaps.latest.revision: 59\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Support For C++11/14/17 Features (Modern C++)\nThis article describes C++11/14/17 features in Visual C++.  \n  \n##  <a name=\"featurelist\"></a> C++11Feature List  \n Visual C++ implements the vast majority of features in the [C++11 core language specification](http://go.microsoft.com/fwlink/p/?LinkID=235092), as well as many C++14 Library features and some features proposed for C++17. The following table lists C++11/14/17 core language features and their implementation status in Visual C++ in Visual Studio 2010, [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)], and [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)], and Visual Studio 2015.  \n  \n###  <a name=\"corelanguagetable\"></a> C++11 Core Language Features Table  \n  \n|[C++11 Core Language Features](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2869.html)|Visual Studio 2010|Visual Studio 2012|[!INCLUDE[vs_dev12](../atl-mfc-shared/includes/vs_dev12_md.md)]|Visual Studio 2015|  \n|----------------------------------------------------------------------------------------------------------|------------------------|------------------------|--------------------------------------------------------------|------------------------|  \n|Rvalue references [v0.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1610.html), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html), [v2.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html), [v2.1](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html), [v3.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html)|v2.0|v2.1*|v2.1*|v3.0|  \n|[ref-qualifiers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm)|No|No|No|Yes|  \n|[Non-static data member initializers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm)|No|No|[Yes](../cpp/uniform-initialization-and-delegating-constructors.md)|Yes|  \n|Variadic templates [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf)|No|No|[Yes](../cpp/ellipses-and-variadic-templates.md)|Yes|  \n|[Initializer lists](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm)|No|No|[Yes](../cpp/uniform-initialization-and-delegating-constructors.md)|Yes|  \n|[static_assert](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html)|Yes|Yes|Yes|Yes|  \n|auto [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.htm)|v1.0|v1.0|v1.0|Yes|  \n|[Trailing return types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm)|Yes|Yes|Yes|Yes|  \n|Lambdas [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf), [v1.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf)|v1.0|v1.1|v1.1|Yes|  \n|decltype [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf), [v1.1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf)|v1.0|v1.1**|v1.1|Yes|  \n|[Right angle brackets](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html)|Yes|Yes|Yes|Yes|  \n|[Default template arguments for function templates](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html)|No|No|Yes|Yes|  \n|[Expression SFINAE](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html)|No|No|No|No|  \n|[Alias templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf)|No|No|[Yes](../cpp/aliases-and-typedefs-cpp.md)|Yes|  \n|[Extern templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm)|Yes|Yes|Yes|Yes|  \n|[nullptr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf)|Yes|Yes|Yes|Yes|  \n|[Strongly typed enums](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf)|Partial|Yes|Yes|Yes|  \n|[Forward declared enums](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf)|No|Yes|Yes|Yes|  \n|[Attributes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf)|No|No|No|Yes|  \n|[constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf)|No|No|No|Yes|  \n|[Alignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf)|TR1|Partial|Partial|Yes|  \n|[Delegating constructors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf)|No|No|[Yes](../cpp/uniform-initialization-and-delegating-constructors.md)|Yes|  \n|[Inheriting constructors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm)|No|No|No|Yes|  \n|[Explicit conversion operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf)|No|No|Yes|Yes|  \n|[char16_t/char32_t](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html)|No|No|No|Yes|  \n|[Unicode string literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm)|No|No|No|Yes|  \n|[Raw string literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm)|No|No|[Yes](../cpp/string-and-character-literals-cpp.md)|Yes|  \n|[Universal character names in literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2170.html)|No|No|No|Yes|  \n|[User-defined literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf)|No|No|No|Yes|  \n|[Standard-layout and trivial types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm)|No|Yes|Yes|Yes|  \n|[Defaulted and deleted functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm)|No|No|[Yes*](../cpp/explicitly-defaulted-and-deleted-functions.md)|Yes|  \n|[Extended friend declarations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1791.pdf)|Yes|Yes|Yes|Yes|  \n|[Extended sizeof](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html)|No|No|No|Yes|  \n|[Inline namespaces](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm)|No|No|No|Yes|  \n|[Unrestricted unions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf)|No|No|No|Yes|  \n|[Local and unnamed types as template arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm)|Yes|Yes|Yes|Yes|  \n|[Range-based for-loop](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html)|No|Yes|Yes|Yes|  \n|override and final [v0.8](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm), [v0.9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm), [v1.0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm)|Partial|Yes|Yes|Yes|  \n|[Minimal GC support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm)|Yes|Yes|Yes|Yes|  \n|[noexcept](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)|No|No|No|Yes|  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"concurrencytable\"></a> C++11 Core Language Features Table: Concurrency  \n  \n|C++11 Core Language Features: Concurrency|Visual Studio 2010|Visual Studio 2012|[!INCLUDE[vs_dev12](../atl-mfc-shared/includes/vs_dev12_md.md)]|Visual Studio 2015|  \n|-------------------------------------------------|------------------------|------------------------|--------------------------------------------------------------|------------------------|  \n|[Reworded sequence points](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html)|N/A|N/A|N/A|Yes|  \n|[Atomics](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html)|No|Yes|Yes|Yes|  \n|[Strong compare and exchange](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html)|No|Yes|Yes|Yes|  \n|[Bidirectional fences](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2752.htm)|No|Yes|Yes|Yes|  \n|[Memory model](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm)|N/A|N/A|N/A|Yes|  \n|[Data-dependency ordering](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2664.htm)|No|Yes|Yes|Yes|  \n|[Data-dependency ordering: function annotation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2782.htm)|No|No|No|Yes|  \n|[exception_ptr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html)|Yes|Yes|Yes|Yes|  \n|[quick_exit](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2440.htm)|No|No|No|Yes|  \n|[Atomics in signal handlers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2547.htm)|No|Yes|Yes|Yes|  \n|[Thread-local storage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm)|Partial|Partial|Partial|Yes|  \n|[Magic statics](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm)|No|No|No|Yes|  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"c99table\"></a> C++11 Core Language Features: C99  \n  \n|C++11 Core Language Features: C99|Visual Studio 2010|Visual Studio 2012|[!INCLUDE[vs_dev12](../atl-mfc-shared/includes/vs_dev12_md.md)]|Visual Studio 2015|  \n|-----------------------------------------|------------------------|------------------------|--------------------------------------------------------------|------------------------|  \n|[__func\\_\\_](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm)|Partial|Partial|Partial|Yes|  \n|[C99 preprocessor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1653.htm)|Partial|Partial|Partial|Partial|  \n|[long long](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf)|Yes|Yes|Yes|Yes|  \n|[Extended integer types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1988.pdf)|N/A|N/A|N/A|N/A|  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"cpp14table\"></a> C++ 14 Core Language Features  \n  \n||||  \n|-|-|-|  \n|Feature|Visual Studio 2013|Visual Studio 2015|  \n|Tweaked wording for contextual conversions|Yes|Yes|  \n|Binary literals|No|Yes|  \n|auto and decltype(auto) return types|No|Yes|  \n|init-captures|No|Yes|  \n|Generic lambdas|No|Yes|  \n|Variable templates|No|No|  \n|Extended constexpr|No|No|  \n|NSDMIs for aggregates|No|No|  \n|Avoiding/fusing allocations|No|No|  \n|[[deprecated]] attributes|No|No|  \n|Sized allocation|No|Yes|  \n|Digit separators|No|Yes|  \n  \n###  <a name=\"cpp17table\"></a> C++17 Proposed Core Language Features  \n  \n||||  \n|-|-|-|  \n|Feature|Visual Studio 2013|Visual Studio 2015|  \n|New rules for auto with braced-init-lists|No|No|  \n|Terse static assert|No|No|  \n|typename in template template-parameters|No|No|  \n|Removing trigraphs|Yes|Yes|  \n|Nested namespace definitions|No|No|  \n|N4259 std::uncaught_exceptions()|No|No|  \n|N4261 Fixing qualification conversions|No|No|  \n|N4266 Attributes for namespaces and enumerators|No|No|  \n|N4267 u8 character literals|No|No|  \n|N4268 Allowing more non-type template args|No|No|  \n|N4295 Fold expressions|No|No|  \n|await/resume|No|Yes|  \n  \n##  <a name=\"tableguide\"></a> Guide to the Feature Tables  \n  \n###  <a name=\"rvref\"></a> Rvalue References  \n  \n> [!NOTE]\n>  The version designations (v0.1, v1.0, v2.0, v2.1, v3.0) in the following descriptions are invented just to show the evolution of C++11. The standard itself does not use them.  \n  \n [N1610 \"Clarification of Initialization of Class Objects by rvalues\"](http://go.microsoft.com/fwlink/p/?LinkID=235093) was an early attempt to enable move semantics without rvalue references.  For the sake of this discussion, let’s call it \"rvalue references v0.1\". It was superseded by \"rvalue references [v1.0](http://go.microsoft.com/fwlink/p/?LinkID=235094).\" \"Rvalue references [v2.0](http://go.microsoft.com/fwlink/p/?LinkID=235095)\", which is what the work in Visual C++ in Visual Studio 2010 was based on, prohibits rvalue references from binding to lvalues and thereby fixes a major safety problem.  \"Rvalue references [v2.1](http://go.microsoft.com/fwlink/p/?LinkID=235096)\" refines this rule.  Consider `vector<string>::push_back()`, which has the overloads `push_back(const string&)` and `push_back(string&&)`, and the call `v.push_back(\"strval\")`.  The expression `\"strval\"` is a string literal, and is an lvalue.  (Other literals—for example, the integer 1729—are rvalues, but string literals are special because they are arrays.)  The \"rvalue references v2.0\" rules said that `string&&` cannot bind to `\"strval\"` because `\"strval\"` is an lvalue and therefore, `push_back(const string&)` is the only viable overload.  This would create a temporary `std::string`, copy it into the vector, and then destroy the temporary `std::string`, which wasn’t very efficient. The \"rvalue references v2.1\" rules recognize that binding `string&&` to `\"strval\"` would create a temporary `std::string`, and that temporary is an rvalue.  Therefore, both `push_back(const string&)` and `push_back(string&&)` are viable, and `push_back(string&&)` is preferred.  A temporary `std::string` is constructed, and then moved into the vector.  This is more efficient.  \n  \n \"Rvalue references [v3.0](http://go.microsoft.com/fwlink/p/?LinkID=235097)\" adds new rules to automatically generate move constructors and move assignment operators under certain conditions. This is implemented in Visual Studio 2015.  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"lambdas\"></a> Lambdas  \n After [lambda functions](../cpp/lambda-expressions-in-cpp.md) were voted into the Working Paper ([version \"0.9\"](http://go.microsoft.com/fwlink/p/?LinkID=235098)) and mutable lambdas were added ([version \"1.0\"](http://go.microsoft.com/fwlink/p/?LinkID=235099)), the Standardization Committee overhauled the wording. This produced lambdas  [version \"1.1\"](http://go.microsoft.com/fwlink/p/?LinkID=235100), which is now fully supported.  The lambdas v1.1 wording clarifies what should occur in corner cases like referring to static members or nested lambdas.  This fixes problems that are triggered by complex lambdas.  Additionally, stateless lambdas are now convertible to function pointers.  This is not in the N2927 wording, but it is counted as part of lambdas v1.1 anyway.  [C++11](http://go.microsoft.com/fwlink/p/?LinkID=235092)**5.1.2 [expr.prim.lambda]/6** has this description: \"The closure type for a `lambda-expression` with no `lambda-capture` has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same eﬀect as invoking the closure type’s function call operator.\"  (The [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] implementation is even better than that, because it makes stateless lambdas convertible to function pointers that have arbitrary calling conventions.  This is important when you are using APIs that expect things like `__stdcall` function pointers.)  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"decltype\"></a> decltype  \n After decltype was voted into the Working Paper ([version 1.0](http://go.microsoft.com/fwlink/p/?LinkID=235101)), it received a small but important fix at the last minute ([version 1.1](http://go.microsoft.com/fwlink/p/?LinkID=235102)).  This is of great interest to programmers who work on the STL and Boost.  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"stronglytyped\"></a> Strongly Typed/Forward Declared enums  \n [Strongly typed enums](http://go.microsoft.com/fwlink/p/?LinkID=235103) were partially supported in Visual C++ in Visual Studio 2010 (specifically, the part about explicitly specified underlying types). These are now fully implemented in Visual Studio, and the C++11 semantics for [forward declared enums](http://go.microsoft.com/fwlink/p/?LinkID=235104) are also fully implemented.  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"alignment\"></a> Alignment  \n The Core Language keywords `alignas`/`alignof` from the [alignment proposal](http://go.microsoft.com/fwlink/p/?LinkID=235105) that was voted into the Working Paper are implemented in Visual Studio 2015.  Visual C++ in Visual Studio 2010 had `aligned_storage` from TR1. [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] added `aligned_union` and `std::align()` to the Standard Library and significant issues were fixed in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)].  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"standardlayout\"></a> Standard-Layout and Trivial Types  \n The exposed changes from [N2342 \"POD's Revisited; Resolving Core Issue 568 (Revision 5)\"](http://go.microsoft.com/fwlink/p/?LinkID=235106) are the additions of `is_trivial` and `is_standard_layout` to the Standard Template Library's `<type_traits>`.  (N2342 reworked a lot of the Core Language wording, but no compiler changes were required.)  These type traits were available in Visual C++ in Visual Studio 2010, but they just duplicated `is_pod`. Therefore, the table earlier in this document said \"No\" support.  They are now powered by compiler hooks that are designed to give accurate answers.  \n  \n The STL's [common_type<>](../standard-library/common-type-class.md) received a much-needed fix in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)].  The C++11 specification for `common_type<>` had unexpected and undesired consequences; in particular, it makes `common_type<int, int>::type` return `int&&`. Therefore, [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] implements the [Proposed Resolution for Library Working Group issue 2141](http://go.microsoft.com/fwlink/p/?LinkId=320075), which makes `common_type<int, int>::type` return `int`.  \n  \n As a side-effect of this change, the identity case no longer works (`common_type<T>` does not always result in type `T`). This complies with the Proposed Resolution, but it breaks any code that relied on the previous behavior.  \n  \n If you require an identity type trait, don't use the non-standard `std::identity` that's defined in `<type_traits>` because it won't work for `<void>`. Instead, implement your own identity type trait to suit your needs. Here's an example:  \n  \n```cpp  \ntemplate <typename T> struct Identity {  \n    typedef T type;  \n};  \n  \n```  \n  \n> [!NOTE]\n>  For other breaking changes, see [Visual C++ change history 2003 - 2015](../porting/visual-cpp-change-history-2003-2015.md).  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"defaultedanddeleted\"></a> Defaulted and Deleted Functions  \n These are now supported, but with this exception: For defaulted functions, the use of `=default` to request member-wise move constructors and move assignment operators is not supported. The copies and moves don't interact precisely like the Standard says they should—for example, deletion of moves is specified to also suppress copies, but [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] does not.  \n  \n For information about how to use defaulted and deleted functions, see [Functions](../cpp/functions-cpp.md).  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"overrideandfinal\"></a> override and final  \n This went through a short but complicated evolution. Originally, in [version 0.8](http://go.microsoft.com/fwlink/p/?LinkID=235108), there were [[`override`]], [[`hiding`]], and [[`base_check`]] attributes.  Then in [version 0.9](http://go.microsoft.com/fwlink/p/?LinkID=235109), the attributes were eliminated and replaced with contextual keywords.  Finally, in [version 1.0](http://go.microsoft.com/fwlink/p/?LinkID=235110), they were reduced to \"`final`\" on classes, and \"`override`\" and \"`final`\" on functions.  This makes it an Ascended Extension because Visual C++ in Visual Studio 2010 already supported this \"`override`\" syntax on functions, and had semantics reasonably close to those in C++11.  \"`final`\" was also supported, but under the different spelling \"sealed\".  The Standard spelling and semantics of \"`override`\" and \"`final`\" are now completely supported. For more information, see [override Specifier](../cpp/override-specifier.md) and [final Specifier](../cpp/final-specifier.md).  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"atomics\"></a> Atomics, and More  \n [Atomics](http://go.microsoft.com/fwlink/p/?LinkID=235111), [strong compare and exchange](http://go.microsoft.com/fwlink/p/?LinkID=235112), [bidirectional fences](http://go.microsoft.com/fwlink/p/?LinkID=235113), and [data-dependency ordering](http://go.microsoft.com/fwlink/p/?LinkID=235114) specify Standard Library machinery, which are now implemented.  \n  \n **Related STL headers:** [\\<atomic>](../standard-library/atomic.md), [\\<chrono>](../standard-library/chrono.md), [<condition_variable>](../standard-library/condition-variable.md), [\\<future>](../standard-library/future.md), [\\<mutex>](../standard-library/mutex.md), [\\<ratio>](../standard-library/ratio.md), [<scoped_allocator>](../standard-library/scoped-allocator.md), and [\\<thread>](../standard-library/thread.md).  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"c99\"></a> C99 __func\\_\\_ and Preprocessor Rules  \n The table [C++11 Core Language Features: C99](#c99table) lists \"Partial\" implementation for two items. For the pre-defined identifier `__func__`, \"Partial\" is listed because support is provided for the non-Standard extensions `__FUNCDNAME__`, `__FUNCSIG__`, and `__FUNCTION__`. For more information, see [Predefined Macros](../preprocessor/predefined-macros.md). For C99 preprocessor rules, \"Partial\" is listed because *variadic macros* are supported. For more information, see [Variadic Macros](../preprocessor/variadic-macros.md).  \n  \n [[In This Article](#top)]  \n  \n###  <a name=\"stl\"></a> Standard Library Features  \n That covers the Core Language. As for the C++11 Standard Library, we don't have a pretty comparison table of features, but [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] implemented it, with two exceptions.  First, when a library feature depended on functionality that was missing in the compiler, it was either simulated—for example, simulated variadic templates for `make_shared<T>()`—or it wasn't implemented. (There were only a few cases—most notably, `<initializer_list>`—which were fully implemented in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)].)  With very few exceptions, C99 was implemented in [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] and C++ wrapper headers provided. For more information, see [C99 library support in Visual Studio 2013](http://go.microsoft.com/fwlink/p/?LinkId=321308).  \n  \n Here's a partial list of the changes in [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] and [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)]:  \n  \n **Emplacement:** As required by C++11, `emplace()`/`emplace_front()`/`emplace_back()`/`emplace_hint()`/`emplace_after()` are implemented in all containers for \"arbitrary\" numbers of arguments (see the \"Simulated variadics\" section).  For example, `vector<T>` has \"`template <typename... Args> void emplace_back(Args&&... args)`\", which directly constructs an element of type T at the back of the vector from an arbitrary number of arbitrary arguments, perfectly forwarded.  This can be more efficient than `push_back(T&&)`, which would involve an extra move construction and destruction.  \n  \n **Variadics:** [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] had a scheme for simulating variadic templates. In [!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)], the simulations are gone and **variadics are fully implemented**. If your code relies on the old simulated variadics behavior, you have to fix it. However, the switch to real variadic templates has **improved compile times** and **reduced compiler memory consumption**.  \n  \n **Explicit conversion operators:** In the Core Language, explicit conversion operators are a general feature—for example, you can have `explicit operator MyClass()`. However, the Standard Library currently uses only one form: `explicit operator bool()`, which makes classes safely Boolean-testable. (Plain \"`operator bool()`\" is notoriously dangerous.) Previously, Visual C++ simulated `explicit operator bool()` with `operator pointer-to-member()`, which led to various headaches and slight inefficiencies. Now, this \"fake bool\" workaround is completely removed.  \n  \n **Randomness:** `uniform_int_distribution` is now perfectly unbiased, and `shuffle()` is implemented in `<algorithm>`, which directly accepts Uniform Random Number Generators like `mersenne_twister`.  \n  \n **Resistance to overloaded address-of operators:** C++98/03 prohibited an element of an STL container from overloading its address-of operator.  This is what classes like `CComPtr` do, so that helper classes like `CAdapt` were required to shield the STL from such overloads.  During the development of Visual C++ in Visual Studio 2010, STL changes made it reject overloaded address-of operators in even more situations. C++11 changed the requirements to make overloaded address-of operators acceptable. C++11, and Visual C++ in Visual Studio 2010, provide the helper function `std::addressof()`, which can get the true address of an object regardless of operator overloading.  Before Visual C++ in Visual Studio 2010 was released, we attempted to replace occurrences of \"`&elem`\" with \"`std::addressof(elem)`\", which is appropriately resistant.  [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] went further, so that classes that overload their address-of operator should be usable throughout the STL.  \n  \n **[!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] went beyond C++11 in several ways:**  \n  \n **SCARY iterators:** As permitted but not required by the C++11 Standard, SCARY iterators have been implemented, as described by [N2911 \"Minimizing Dependencies within Generic Classes for Faster and Smaller Programs\"](http://go.microsoft.com/fwlink/p/?LinkID=235115) and [N2980 \"SCARY Iterator Assignment and Initialization, Revision 1\"](http://go.microsoft.com/fwlink/p/?LinkID=235116).  \n  \n **Filesystem:** The `<filesystem>` header from [the TR2 proposal](http://go.microsoft.com/fwlink/p/?LinkID=235117) has been added. It offers `recursive_directory_iterator` and other interesting features.  Before work on TR2 was frozen because C++0x was running very late and was changing to C++11, the 2006 proposal was derived from [Boost.Filesystem V2](http://go.microsoft.com/fwlink/p/?LinkID=235118). It later evolved into Boost.Filesystem V3, which is implemented in Visual Studio 2015.  \n  \n And a major optimization!  All of our containers are now optimally small given their current representations.  This refers to the container objects themselves, not to their pointed-to contents.  For example, `std::vector` contains three raw pointers.  In Visual C++ in Visual Studio 2010, x86 release mode, `std::vector` was 16 bytes.  In [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)], it is 12 bytes, which is optimally small.  This is a big deal—if you have 100,000 vectors in your program, [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] saves you 400,000 bytes.  Decreased memory usage saves both space and time.  \n  \n This was achieved by avoiding the storage of empty allocators and comparators, because `std::allocator` and `std::less` are stateless.  (These optimizations are enabled for custom allocators/comparators too, as long as they are stateless.  Obviously, storage of stateful allocators/comparators cannot be avoided, but those are very rare.)  \n  \n **[!INCLUDE[cpp_dev12_long](../build/reference/includes/cpp_dev12_long_md.md)] implemented some key C++14 library features:**  \n  \n-   \"Transparent operator functors\" `less<>`, `greater<>`, `plus<>`, `multiplies<>`, and so on.  \n  \n-   `make_unique<T>(args...)` and `make_unique<T[]>(n)`  \n  \n-   `cbegin()`/`cend()`, `rbegin()`/`rend()`, and `crbegin()`/`crend()` non-member functions.  \n  \n [[In This Article](#top)]  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md)   \n [Range-based for Statement (C++)](../cpp/range-based-for-statement-cpp.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)   \n [Visual C++ Team Blog](http://blogs.msdn.com/b/vcblog/)   \n [What's New for Visual C++](../what-s-new-for-visual-cpp-in-visual-studio.md)   \n [Visual C++ change history 2003 - 2015](../porting/visual-cpp-change-history-2003-2015.md)"}