{"nodes":[{"pos":[12,43],"content":"oexcept (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"oexcept (C++) | Microsoft Docs","pos":[0,30]}]},{"content":"noexcept (C++)","pos":[567,581]},{"pos":[582,645],"content":"<bpt id=\"p1\">**</bpt>C++11:<ept id=\"p1\">**</ept> Specifies whether a function might throw exceptions.","source":"**C++11:** Specifies whether a function might throw exceptions."},{"content":"Syntax","pos":[654,660]},{"content":"Parameters","pos":[798,808]},{"content":"expression","pos":[812,822]},{"content":"A constant expression that evaluates to true or false.","pos":[826,880]},{"content":"The unconditional version is equivalent to noexcept(true).","pos":[881,939]},{"content":"Remarks","pos":[948,955]},{"content":"( and its synonym <ph id=\"ph1\">`noecept(true)`</ph>) specify that the function will never throw an exception or allow an exception to be propagated from any other function that it invokes either directly or indirectly.","pos":[970,1170],"source":" ( and its synonym `noecept(true)`) specify that the function will never throw an exception or allow an exception to be propagated from any other function that it invokes either directly or indirectly."},{"content":"More specifically, <ph id=\"ph1\">`noexcept`</ph> means the function is <ph id=\"ph2\">`noexcept`</ph> only if all the functions that it calls are also noexcept or const, and there are no potentially evaluated dynamic casts that require a run-time check, typeid expressions applied to a glvalue expression whose type is a polymorphic class type, or throw expressions.","pos":[1171,1498],"source":" More specifically, `noexcept` means the function is `noexcept` only if all the functions that it calls are also noexcept or const, and there are no potentially evaluated dynamic casts that require a run-time check, typeid expressions applied to a glvalue expression whose type is a polymorphic class type, or throw expressions."},{"content":"However, the compiler does not necessarily check every code path for exceptions that might bubble up to a <ph id=\"ph1\">`noexcept`</ph> function.","pos":[1499,1625],"source":" However, the compiler does not necessarily check every code path for exceptions that might bubble up to a `noexcept` function."},{"content":"If an exception does reach a function marked <ph id=\"ph1\">`noexcept`</ph>, <bpt id=\"p1\">[</bpt>std::terminate<ept id=\"p1\">](../standard-library/exception-functions.md#terminate)</ept> is invoked immediately and there is no guarantee that destructors of any in-scope objects will be invoked.","pos":[1626,1860],"source":" If an exception does reach a function marked `noexcept`, [std::terminate](../standard-library/exception-functions.md#terminate) is invoked immediately and there is no guarantee that destructors of any in-scope objects will be invoked."},{"content":"A function declared with a conditional noexcept that evaluates to noexcept(false) specifies that it does permit exceptions to propagate.","pos":[1867,2003]},{"content":"For example, a function that copies its argument might be declared noexcept on the condition that the object being copied is a plain old data type (POD).","pos":[2004,2157]},{"content":"Such a function could be declared like this:","pos":[2158,2202]},{"content":"Use <ph id=\"ph1\">`noexcept`</ph> instead of the exception specifier <ph id=\"ph2\">`throw`</ph>, which is deprecated in C++11 and later.","pos":[2348,2446],"source":"Use `noexcept` instead of the exception specifier `throw`, which is deprecated in C++11 and later."},{"content":"We recommended you apply <ph id=\"ph1\">`noexcept`</ph> to a function when you are sure it will never allow an exception to propagate up the call stack.","pos":[2447,2579],"source":" We recommended you apply `noexcept` to a function when you are sure it will never allow an exception to propagate up the call stack."},{"content":"A function that is declared with <ph id=\"ph1\">`noexcept`</ph> enables compilers to generate more efficient code in several different contexts.","pos":[2580,2704],"source":" A function that is declared with `noexcept` enables compilers to generate more efficient code in several different contexts."},{"content":"See Also","pos":[2713,2721]},{"content":"C++ Exception Handling","pos":[2726,2748]}],"content":"---\ntitle: \"noexcept (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"noexcept_cpp\"\ndev_langs: \n  - \"C++\"\nms.assetid: df24edb9-c6a6-4e37-9914-fd5c0c3716a8\ncaps.latest.revision: 5\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# noexcept (C++)\n**C++11:** Specifies whether a function might throw exceptions.  \n  \n## Syntax  \n  \n```cpp  \nReturnType FunctionName(params) noexcept;  \nReturnType FunctionName(params) noexcept(noexcept(expression);  \n```  \n  \n#### Parameters  \n expression  \n A constant expression that evaluates to true or false. The unconditional version is equivalent to noexcept(true).  \n  \n## Remarks  \n `noexcept` ( and its synonym `noecept(true)`) specify that the function will never throw an exception or allow an exception to be propagated from any other function that it invokes either directly or indirectly. More specifically, `noexcept` means the function is `noexcept` only if all the functions that it calls are also noexcept or const, and there are no potentially evaluated dynamic casts that require a run-time check, typeid expressions applied to a glvalue expression whose type is a polymorphic class type, or throw expressions. However, the compiler does not necessarily check every code path for exceptions that might bubble up to a `noexcept` function. If an exception does reach a function marked `noexcept`, [std::terminate](../standard-library/exception-functions.md#terminate) is invoked immediately and there is no guarantee that destructors of any in-scope objects will be invoked.  \n  \n A function declared with a conditional noexcept that evaluates to noexcept(false) specifies that it does permit exceptions to propagate. For example, a function that copies its argument might be declared noexcept on the condition that the object being copied is a plain old data type (POD). Such a function could be declared like this:  \n  \n```  \n#include <type_traits>  \n  \ntemplate <typename T>  \nT copy_object(T& obj) noexcept(std::is_pod<T>)  \n{  \n //. . .   \n}  \n  \n```  \n  \n Use `noexcept` instead of the exception specifier `throw`, which is deprecated in C++11 and later. We recommended you apply `noexcept` to a function when you are sure it will never allow an exception to propagate up the call stack. A function that is declared with `noexcept` enables compilers to generate more efficient code in several different contexts.  \n  \n## See Also  \n [C++ Exception Handling](../cpp/cpp-exception-handling.md)"}