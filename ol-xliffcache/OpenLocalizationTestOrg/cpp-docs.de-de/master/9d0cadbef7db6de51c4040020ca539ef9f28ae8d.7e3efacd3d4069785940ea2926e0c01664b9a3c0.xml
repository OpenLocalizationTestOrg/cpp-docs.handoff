{"nodes":[{"pos":[12,43],"content":"__segmentlimit | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__segmentlimit | Microsoft Docs","pos":[0,31]}]},{"content":"__segmentlimit","pos":[660,674]},{"content":"Microsoft Specific","pos":[677,695]},{"pos":[704,757],"content":"Generates the <ph id=\"ph1\">`lsl`</ph> (Load Segment Limit) instruction.","source":"Generates the `lsl` (Load Segment Limit) instruction."},{"content":"Syntax","pos":[766,772]},{"content":"Parameters","pos":[858,868]},{"content":"[in]","pos":[872,876]},{"content":"A constant that specifies the segment selector.","pos":[884,931]},{"content":"Return Value","pos":[940,952]},{"pos":[956,1096],"content":"The segment limit of the segment selector specified by <ph id=\"ph1\">`a,`</ph> provided that the selector is valid and visible at the current permission level.","source":"The segment limit of the segment selector specified by `a,` provided that the selector is valid and visible at the current permission level."},{"content":"Requirements","pos":[1105,1117]},{"content":"Intrinsic","pos":[1124,1133]},{"content":"Architecture","pos":[1134,1146]},{"pos":[1207,1211],"content":"x86,"},{"pos":[1283,1310],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1319,1326]},{"content":"If the segment limit cannot be retrieved, this instruction fails.","pos":[1330,1395]},{"content":"On failure, this instruction clears the ZF flag and the return value is undefined.","pos":[1396,1478]},{"content":"This routine is only available as an intrinsic.","pos":[1485,1532]},{"content":"Example","pos":[1541,1548]},{"content":"END Microsoft Specific","pos":[2882,2904]},{"content":"See Also","pos":[2913,2921]},{"content":"Compiler Intrinsics","pos":[2926,2945]}],"content":"---\ntitle: \"__segmentlimit | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__segmentlimit\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__segmentlimit intrinsic\"\n  - \"lsl instruction\"\nms.assetid: d0bc3630-90cb-4185-8667-686fd41e23d4\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# __segmentlimit\n**Microsoft Specific**  \n  \n Generates the `lsl` (Load Segment Limit) instruction.  \n  \n## Syntax  \n  \n```  \nunsigned long __segmentlimit(   \n   unsigned long a   \n);  \n```  \n  \n#### Parameters  \n [in] `a`  \n A constant that specifies the segment selector.  \n  \n## Return Value  \n The segment limit of the segment selector specified by `a,` provided that the selector is valid and visible at the current permission level.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`__segmentlimit`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n If the segment limit cannot be retrieved, this instruction fails. On failure, this instruction clears the ZF flag and the return value is undefined.  \n  \n This routine is only available as an intrinsic.  \n  \n## Example  \n  \n```  \n#include <stdio.h>  \n  \n#ifdef _M_IX86  \ntypedef unsigned int READETYPE;  \n#else  \ntypedef unsigned __int64 READETYPE;  \n#endif  \n  \n#define EFLAGS_ZF      0x00000040  \n#define KGDT_R3_DATA    0x0020  \n#define RPL_MASK        0x3  \n  \nextern \"C\"  \n{  \nunsigned long __segmentlimit (unsigned long);  \nREADETYPE __readeflags();  \n}  \n  \n#pragma intrinsic(__readeflags)  \n#pragma intrinsic(__segmentlimit)  \n  \nint main(void)  \n{  \n   const unsigned long initsl = 0xbaadbabe;  \n   READETYPE eflags = 0;  \n   unsigned long sl = initsl;  \n  \n   printf(\"Before: segment limit =0x%x eflags =0x%x\\n\", sl, eflags);  \n   sl = __segmentlimit(KGDT_R3_DATA + RPL_MASK);  \n  \n   eflags = __readeflags();  \n  \n   printf(\"After: segment limit =0x%x eflags =0x%x eflags.zf = %s\\n\", sl, eflags, (eflags & EFLAGS_ZF) ? \"set\" : \"clear\");  \n  \n   // If ZF is set, the call to lsl succeeded; if ZF is clear, the call failed.  \n   printf(\"%s\\n\", eflags & EFLAGS_ZF ? \"Success!\": \"Fail!\");  \n  \n   // You can verify the value of sl to make sure that the instruction wrote to it  \n   printf(\"sl was %s\\n\", (sl == initsl) ? \"unchanged\" : \"changed\");  \n  \n   return 0;  \n}  \n```  \n  \n```Output  \nBefore: segment limit =0xbaadbabe eflags =0x0  \nAfter: segment limit =0xffffffff eflags =0x256 eflags.zf = set  \nSuccess!  \nsl was changed  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}