{"nodes":[{"pos":[12,35],"content":"signal | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"signal | Microsoft Docs","pos":[0,23]}]},{"pos":[903,909],"content":"signal","linkify":"signal","nodes":[{"content":"signal","pos":[0,6]}]},{"content":"Sets interrupt signal handling.","pos":[910,941]},{"pos":[949,1500],"content":"[!IMPORTANT]\n Do not use this method to shut down a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, except in testing or debugging scenarios. Programmatic or UI ways to close a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app are not permitted according to Section 3.6 of the [Windows 8 app certification requirements](http://go.microsoft.com/fwlink/?LinkId=262889). For more information, see [Application lifecycle (Windows Store apps)](http://go.microsoft.com/fwlink/?LinkId=262853).","leadings":["","> "],"nodes":[{"content":" Do not use this method to shut down a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, except in testing or debugging scenarios. Programmatic or UI ways to close a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app are not permitted according to Section 3.6 of the [Windows 8 app certification requirements](http://go.microsoft.com/fwlink/?LinkId=262889). For more information, see [Application lifecycle (Windows Store apps)](http://go.microsoft.com/fwlink/?LinkId=262853).","pos":[13,549],"nodes":[{"content":"Do not use this method to shut down a <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, except in testing or debugging scenarios.","pos":[1,161],"source":" Do not use this method to shut down a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, except in testing or debugging scenarios."},{"content":"Programmatic or UI ways to close a <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app are not permitted according to Section 3.6 of the <bpt id=\"p1\">[</bpt>Windows 8 app certification requirements<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=262889)</ept>.","pos":[162,417],"source":" Programmatic or UI ways to close a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app are not permitted according to Section 3.6 of the [Windows 8 app certification requirements](http://go.microsoft.com/fwlink/?LinkId=262889)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Application lifecycle (Windows Store apps)<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=262853)</ept>.","pos":[418,536],"source":" For more information, see [Application lifecycle (Windows Store apps)](http://go.microsoft.com/fwlink/?LinkId=262853)."}]}]},{"pos":[1509,1515],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1639,1649],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Signal value.","pos":[1662,1675]},{"content":"Function to be executed.","pos":[1692,1716]},{"content":"The first parameter is a signal value and the second parameter is a sub-code that can be used when the first parameter is SIGFPE.","pos":[1717,1846]},{"pos":[1855,1867],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`signal`</ph> returns the previous value of <ph id=\"ph2\">`func`</ph> that's associated with the given signal.","pos":[1871,1957],"source":"`signal` returns the previous value of `func` that's associated with the given signal."},{"content":"For example, if the previous value of <ph id=\"ph1\">`func`</ph> was <ph id=\"ph2\">`SIG_IGN`</ph>, the return value is also <ph id=\"ph3\">`SIG_IGN`</ph>.","pos":[1958,2053],"source":" For example, if the previous value of `func` was `SIG_IGN`, the return value is also `SIG_IGN`."},{"content":"A return value of <ph id=\"ph1\">`SIG_ERR`</ph> indicates an error; in that case, <ph id=\"ph2\">`errno`</ph> is set to <ph id=\"ph3\">`EINVAL`</ph>.","pos":[2054,2143],"source":" A return value of `SIG_ERR` indicates an error; in that case, `errno` is set to `EINVAL`."},{"pos":[2150,2310],"content":"See <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept> for more information about return codes.","source":"See [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md) for more information about return codes."},{"pos":[2319,2326],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`signal`</ph> function enables a process to choose one of several ways to handle an interrupt signal from the operating system.","pos":[2330,2456],"source":"The `signal` function enables a process to choose one of several ways to handle an interrupt signal from the operating system."},{"content":"The <ph id=\"ph1\">`sig`</ph> argument is the interrupt to which <ph id=\"ph2\">`signal`</ph> responds; it must be one of the following manifest constants, which are defined in SIGNAL.H.","pos":[2457,2603],"source":" The `sig` argument is the interrupt to which `signal` responds; it must be one of the following manifest constants, which are defined in SIGNAL.H."},{"pos":[2610,2621],"content":"<ph id=\"ph1\">`sig`</ph> value","source":"`sig` value"},{"content":"Description","pos":[2622,2633]},{"content":"Abnormal termination","pos":[2688,2708]},{"content":"Floating-point error","pos":[2722,2742]},{"content":"Illegal instruction","pos":[2756,2775]},{"content":"CTRL+C signal","pos":[2789,2802]},{"content":"Illegal storage access","pos":[2817,2839]},{"content":"Termination request","pos":[2854,2873]},{"content":"If <ph id=\"ph1\">`sig`</ph> is not one of the above values, the invalid parameter handler is invoked, as defined in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept> .","pos":[2881,3051],"source":"If `sig` is not one of the above values, the invalid parameter handler is invoked, as defined in [Parameter Validation](../../c-runtime-library/parameter-validation.md) ."},{"content":"If execution is allowed to continue, this function sets <ph id=\"ph1\">`errno`</ph> to <ph id=\"ph2\">`EINVAL`</ph> and returns <ph id=\"ph3\">`SIG_ERR`</ph>.","pos":[3052,3150],"source":" If execution is allowed to continue, this function sets `errno` to `EINVAL` and returns `SIG_ERR`."},{"pos":[3157,3260],"content":"By default, <ph id=\"ph1\">`signal`</ph> terminates the calling program with exit code 3, regardless of the value of <ph id=\"ph2\">`sig`</ph>.","source":"By default, `signal` terminates the calling program with exit code 3, regardless of the value of `sig`."},{"pos":[3268,3568],"content":"[!NOTE]\n `SIGINT` is not supported for any Win32 application. When a CTRL+C interrupt occurs, Win32 operating systems generate a new thread to specifically handle that interrupt. This can cause a single-thread application, such as one in UNIX, to become multithreaded and cause unexpected behavior.","leadings":["","> "],"nodes":[{"content":" `SIGINT` is not supported for any Win32 application. When a CTRL+C interrupt occurs, Win32 operating systems generate a new thread to specifically handle that interrupt. This can cause a single-thread application, such as one in UNIX, to become multithreaded and cause unexpected behavior.","pos":[8,298],"nodes":[{"content":"<ph id=\"ph1\"> `SIGINT`</ph> is not supported for any Win32 application.","pos":[0,53],"source":" `SIGINT` is not supported for any Win32 application."},{"content":"When a CTRL+C interrupt occurs, Win32 operating systems generate a new thread to specifically handle that interrupt.","pos":[54,170]},{"content":"This can cause a single-thread application, such as one in UNIX, to become multithreaded and cause unexpected behavior.","pos":[171,290]}]}]},{"content":"The <ph id=\"ph1\">`func`</ph> argument is an address to a signal handler that you write, or to one of the predefined constants <ph id=\"ph2\">`SIG_DFL`</ph> or <ph id=\"ph3\">`SIG_IGN`</ph>, which are also defined in SIGNAL.H.","pos":[3575,3742],"source":"The `func` argument is an address to a signal handler that you write, or to one of the predefined constants `SIG_DFL` or `SIG_IGN`, which are also defined in SIGNAL.H."},{"content":"If <ph id=\"ph1\">`func`</ph> is a function, it is installed as the signal handler for the given signal.","pos":[3743,3827],"source":" If `func` is a function, it is installed as the signal handler for the given signal."},{"content":"The signal handler's prototype requires one formal argument, <ph id=\"ph1\">`sig`</ph>, of type <ph id=\"ph2\">`int`</ph>.","pos":[3828,3910],"source":" The signal handler's prototype requires one formal argument, `sig`, of type `int`."},{"content":"The operating system provides the actual argument through <ph id=\"ph1\">`sig`</ph> when an interrupt occurs; the argument is the signal that generated the interrupt.","pos":[3911,4057],"source":" The operating system provides the actual argument through `sig` when an interrupt occurs; the argument is the signal that generated the interrupt."},{"content":"Therefore, you can use the six manifest constants (listed in the preceding table) in your signal handler to determine which interrupt occurred and take appropriate action.","pos":[4058,4229]},{"content":"For example, you can call <ph id=\"ph1\">`signal`</ph> twice to assign the same handler to two different signals, and then test the <ph id=\"ph2\">`sig`</ph> argument in the handler to take different actions based on the signal received.","pos":[4230,4427],"source":" For example, you can call `signal` twice to assign the same handler to two different signals, and then test the `sig` argument in the handler to take different actions based on the signal received."},{"content":"If you are testing for floating-point exceptions (<ph id=\"ph1\">`SIGFPE`</ph>), <ph id=\"ph2\">`func`</ph> points to a function that takes an optional second argument that is one of several manifest constants—defined in FLOAT.H—of the form <ph id=\"ph3\">`FPE_xxx`</ph>.","pos":[4434,4645],"source":"If you are testing for floating-point exceptions (`SIGFPE`), `func` points to a function that takes an optional second argument that is one of several manifest constants—defined in FLOAT.H—of the form `FPE_xxx`."},{"content":"When a <ph id=\"ph1\">`SIGFPE`</ph> signal occurs, you can test the value of the second argument to determine the kind of floating-point exception and then take appropriate action.","pos":[4646,4806],"source":" When a `SIGFPE` signal occurs, you can test the value of the second argument to determine the kind of floating-point exception and then take appropriate action."},{"content":"This argument and its possible values are Microsoft extensions.","pos":[4807,4870]},{"content":"For floating-point exceptions, the value of <ph id=\"ph1\">`func`</ph> is not reset when the signal is received.","pos":[4877,4969],"source":"For floating-point exceptions, the value of `func` is not reset when the signal is received."},{"content":"To recover from floating-point exceptions, use try/except clauses to surround the floating point operations.","pos":[4970,5078]},{"content":"It's also possible to recover by using <bpt id=\"p1\">[</bpt>setjmp<ept id=\"p1\">](../../c-runtime-library/reference/setjmp.md)</ept> with <bpt id=\"p2\">[</bpt>longjmp<ept id=\"p2\">](../../c-runtime-library/reference/longjmp.md)</ept>.","pos":[5079,5233],"source":" It's also possible to recover by using [setjmp](../../c-runtime-library/reference/setjmp.md) with [longjmp](../../c-runtime-library/reference/longjmp.md)."},{"content":"In either case, the calling process resumes execution and leaves the floating-point state of the process undefined.","pos":[5234,5349]},{"content":"If the signal handler returns, the calling process resumes execution immediately following the point at which it received the interrupt signal.","pos":[5356,5499]},{"content":"This is true regardless of the kind of signal or operating mode.","pos":[5500,5564]},{"content":"Before the specified function is executed, the value of <ph id=\"ph1\">`func`</ph> is set to <ph id=\"ph2\">`SIG_DFL`</ph>.","pos":[5571,5654],"source":"Before the specified function is executed, the value of `func` is set to `SIG_DFL`."},{"content":"The next interrupt signal is treated as described for <ph id=\"ph1\">`SIG_DFL`</ph>, unless an intervening call to <ph id=\"ph2\">`signal`</ph> specifies otherwise.","pos":[5655,5779],"source":" The next interrupt signal is treated as described for `SIG_DFL`, unless an intervening call to `signal` specifies otherwise."},{"content":"You can use this feature to reset signals in the called function.","pos":[5780,5845]},{"content":"Because signal-handler routines are usually called asynchronously when an interrupt occurs, your signal-handler function may get control when a run-time operation is incomplete and in an unknown state.","pos":[5852,6053]},{"content":"The following list summarizes the restrictions that determine which functions you can use in your signal-handler routine.","pos":[6054,6175]},{"pos":[6185,6267],"content":"Do not issue low-level or STDIO.H I/O routines (for example, <ph id=\"ph1\">`printf`</ph> or <ph id=\"ph2\">`fread`</ph>).","source":"Do not issue low-level or STDIO.H I/O routines (for example, `printf` or `fread`)."},{"content":"Do not call heap routines or any routine that uses the heap routines (for example, <ph id=\"ph1\">`malloc`</ph>, <ph id=\"ph2\">`_strdup`</ph>, or <ph id=\"ph3\">`_putenv`</ph>).","pos":[6277,6395],"source":"Do not call heap routines or any routine that uses the heap routines (for example, `malloc`, `_strdup`, or `_putenv`)."},{"content":"See <bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept> for more information.","pos":[6396,6475],"source":" See [malloc](../../c-runtime-library/reference/malloc.md) for more information."},{"pos":[6485,6573],"content":"Do not use any function that generates a system call (for example, <ph id=\"ph1\">`_getcwd`</ph> or <ph id=\"ph2\">`time`</ph>).","source":"Do not use any function that generates a system call (for example, `_getcwd` or `time`)."},{"content":"Do not use <ph id=\"ph1\">`longjmp`</ph> unless the interrupt is caused by a floating-point exception (that is, <ph id=\"ph2\">`sig`</ph> is <ph id=\"ph3\">`SIGFPE`</ph>).","pos":[6583,6694],"source":"Do not use `longjmp` unless the interrupt is caused by a floating-point exception (that is, `sig` is `SIGFPE`)."},{"content":"In this case, first reinitialize the floating-point package by using a call to <ph id=\"ph1\">`_fpreset`</ph>.","pos":[6695,6785],"source":" In this case, first reinitialize the floating-point package by using a call to `_fpreset`."},{"content":"Do not use any overlay routines.","pos":[6795,6827]},{"content":"A program must contain floating-point code if it is to trap the <ph id=\"ph1\">`SIGFPE`</ph> exception by using the function.","pos":[6834,6939],"source":"A program must contain floating-point code if it is to trap the `SIGFPE` exception by using the function."},{"content":"If your program does not have floating-point code and requires the run-time library's signal-handling code, just declare a volatile double and initialize it to zero:","pos":[6940,7105]},{"content":"The <ph id=\"ph1\">`SIGILL`</ph> and <ph id=\"ph2\">`SIGTERM`</ph> signals are not generated under Windows.","pos":[7156,7223],"source":"The `SIGILL` and `SIGTERM` signals are not generated under Windows."},{"content":"They are included for ANSI compatibility.","pos":[7224,7265]},{"content":"Therefore, you can set signal handlers for these signals by using <ph id=\"ph1\">`signal`</ph>, and you can also explicitly generate these signals by calling <bpt id=\"p1\">[</bpt>raise<ept id=\"p1\">](../../c-runtime-library/reference/raise.md)</ept>.","pos":[7266,7456],"source":" Therefore, you can set signal handlers for these signals by using `signal`, and you can also explicitly generate these signals by calling [raise](../../c-runtime-library/reference/raise.md)."},{"content":"Signal settings are not preserved in spawned processes that are created by calls to <ph id=\"ph1\">`_exec`</ph> or <ph id=\"ph2\">`_spawn`</ph> functions.","pos":[7463,7577],"source":"Signal settings are not preserved in spawned processes that are created by calls to `_exec` or `_spawn` functions."},{"content":"The signal settings are reset to the default values in the new process.","pos":[7578,7649]},{"pos":[7658,7670],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[7677,7684]},{"content":"Required header","pos":[7685,7700]},{"content":"<ph id=\"ph1\">\\&lt;</ph>signal.h&gt;","pos":[7754,7765],"source":"\\<signal.h>"},{"pos":[7773,7877],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"pos":[7886,7893],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows how to use <ph id=\"ph1\">`signal`</ph> to add some custom behavior to the <ph id=\"ph2\">`SIGABRT`</ph> signal.","pos":[7897,7997],"source":"The following example shows how to use `signal` to add some custom behavior to the `SIGABRT` signal."},{"content":"For additional information about abort behavior, see <bpt id=\"p1\">[</bpt>_set_abort_behavior<ept id=\"p1\">](../../c-runtime-library/reference/set-abort-behavior.md)</ept>.","pos":[7998,8130],"source":" For additional information about abort behavior, see [_set_abort_behavior](../../c-runtime-library/reference/set-abort-behavior.md)."},{"pos":[8864,8889],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[8893,8908]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[8909,8956],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[8957,9082],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[9091,9099],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Process and Environment Control<ept id=\"p1\">](../../c-runtime-library/process-and-environment-control.md)</ept><ph id=\"ph1\"> </ph>","pos":[9103,9197],"source":"[Process and Environment Control](../../c-runtime-library/process-and-environment-control.md) "},{"content":"<bpt id=\"p1\"> [</bpt>abort<ept id=\"p1\">](../../c-runtime-library/reference/abort.md)</ept><ph id=\"ph1\"> </ph>","pos":[9200,9253],"source":" [abort](../../c-runtime-library/reference/abort.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_exec, _wexec Functions<ept id=\"p1\">](../../c-runtime-library/exec-wexec-functions.md)</ept><ph id=\"ph1\"> </ph>","pos":[9256,9332],"source":" [_exec, _wexec Functions](../../c-runtime-library/exec-wexec-functions.md) "},{"content":"<bpt id=\"p1\"> [</bpt>exit, _Exit, _exit<ept id=\"p1\">](../../c-runtime-library/reference/exit-exit-exit.md)</ept><ph id=\"ph1\"> </ph>","pos":[9335,9410],"source":" [exit, _Exit, _exit](../../c-runtime-library/reference/exit-exit-exit.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_fpreset<ept id=\"p1\">](../../c-runtime-library/reference/fpreset.md)</ept><ph id=\"ph1\"> </ph>","pos":[9413,9471],"source":" [_fpreset](../../c-runtime-library/reference/fpreset.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_spawn, _wspawn Functions<ept id=\"p1\">](../../c-runtime-library/spawn-wspawn-functions.md)</ept>","pos":[9474,9553],"source":" [_spawn, _wspawn Functions](../../c-runtime-library/spawn-wspawn-functions.md)"}],"content":"---\ntitle: \"signal | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"signal\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-runtime-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"signal\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"signal function\"\nms.assetid: 094118de-d789-4063-b4f4-cffcc80bf29d\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# signal\nSets interrupt signal handling.  \n  \n> [!IMPORTANT]\n>  Do not use this method to shut down a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app, except in testing or debugging scenarios. Programmatic or UI ways to close a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app are not permitted according to Section 3.6 of the [Windows 8 app certification requirements](http://go.microsoft.com/fwlink/?LinkId=262889). For more information, see [Application lifecycle (Windows Store apps)](http://go.microsoft.com/fwlink/?LinkId=262853).  \n  \n## Syntax  \n  \n```  \nvoid (__cdecl *signal(  \n   int sig,   \n   void (__cdecl *func ) (int [, int ] )))   \n   (int);  \n```  \n  \n#### Parameters  \n `sig`  \n Signal value.  \n  \n `func`  \n Function to be executed. The first parameter is a signal value and the second parameter is a sub-code that can be used when the first parameter is SIGFPE.  \n  \n## Return Value  \n `signal` returns the previous value of `func` that's associated with the given signal. For example, if the previous value of `func` was `SIG_IGN`, the return value is also `SIG_IGN`. A return value of `SIG_ERR` indicates an error; in that case, `errno` is set to `EINVAL`.  \n  \n See [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md) for more information about return codes.  \n  \n## Remarks  \n The `signal` function enables a process to choose one of several ways to handle an interrupt signal from the operating system. The `sig` argument is the interrupt to which `signal` responds; it must be one of the following manifest constants, which are defined in SIGNAL.H.  \n  \n|`sig` value|Description|  \n|-----------------|-----------------|  \n|`SIGABRT`|Abnormal termination|  \n|`SIGFPE`|Floating-point error|  \n|`SIGILL`|Illegal instruction|  \n|`SIGINT`|CTRL+C signal|  \n|`SIGSEGV`|Illegal storage access|  \n|`SIGTERM`|Termination request|  \n  \n If `sig` is not one of the above values, the invalid parameter handler is invoked, as defined in [Parameter Validation](../../c-runtime-library/parameter-validation.md) . If execution is allowed to continue, this function sets `errno` to `EINVAL` and returns `SIG_ERR`.  \n  \n By default, `signal` terminates the calling program with exit code 3, regardless of the value of `sig`.  \n  \n> [!NOTE]\n>  `SIGINT` is not supported for any Win32 application. When a CTRL+C interrupt occurs, Win32 operating systems generate a new thread to specifically handle that interrupt. This can cause a single-thread application, such as one in UNIX, to become multithreaded and cause unexpected behavior.  \n  \n The `func` argument is an address to a signal handler that you write, or to one of the predefined constants `SIG_DFL` or `SIG_IGN`, which are also defined in SIGNAL.H. If `func` is a function, it is installed as the signal handler for the given signal. The signal handler's prototype requires one formal argument, `sig`, of type `int`. The operating system provides the actual argument through `sig` when an interrupt occurs; the argument is the signal that generated the interrupt. Therefore, you can use the six manifest constants (listed in the preceding table) in your signal handler to determine which interrupt occurred and take appropriate action. For example, you can call `signal` twice to assign the same handler to two different signals, and then test the `sig` argument in the handler to take different actions based on the signal received.  \n  \n If you are testing for floating-point exceptions (`SIGFPE`), `func` points to a function that takes an optional second argument that is one of several manifest constants—defined in FLOAT.H—of the form `FPE_xxx`. When a `SIGFPE` signal occurs, you can test the value of the second argument to determine the kind of floating-point exception and then take appropriate action. This argument and its possible values are Microsoft extensions.  \n  \n For floating-point exceptions, the value of `func` is not reset when the signal is received. To recover from floating-point exceptions, use try/except clauses to surround the floating point operations. It's also possible to recover by using [setjmp](../../c-runtime-library/reference/setjmp.md) with [longjmp](../../c-runtime-library/reference/longjmp.md). In either case, the calling process resumes execution and leaves the floating-point state of the process undefined.  \n  \n If the signal handler returns, the calling process resumes execution immediately following the point at which it received the interrupt signal. This is true regardless of the kind of signal or operating mode.  \n  \n Before the specified function is executed, the value of `func` is set to `SIG_DFL`. The next interrupt signal is treated as described for `SIG_DFL`, unless an intervening call to `signal` specifies otherwise. You can use this feature to reset signals in the called function.  \n  \n Because signal-handler routines are usually called asynchronously when an interrupt occurs, your signal-handler function may get control when a run-time operation is incomplete and in an unknown state. The following list summarizes the restrictions that determine which functions you can use in your signal-handler routine.  \n  \n-   Do not issue low-level or STDIO.H I/O routines (for example, `printf` or `fread`).  \n  \n-   Do not call heap routines or any routine that uses the heap routines (for example, `malloc`, `_strdup`, or `_putenv`). See [malloc](../../c-runtime-library/reference/malloc.md) for more information.  \n  \n-   Do not use any function that generates a system call (for example, `_getcwd` or `time`).  \n  \n-   Do not use `longjmp` unless the interrupt is caused by a floating-point exception (that is, `sig` is `SIGFPE`). In this case, first reinitialize the floating-point package by using a call to `_fpreset`.  \n  \n-   Do not use any overlay routines.  \n  \n A program must contain floating-point code if it is to trap the `SIGFPE` exception by using the function. If your program does not have floating-point code and requires the run-time library's signal-handling code, just declare a volatile double and initialize it to zero:  \n  \n```  \nvolatile double d = 0.0f;   \n```  \n  \n The `SIGILL` and `SIGTERM` signals are not generated under Windows. They are included for ANSI compatibility. Therefore, you can set signal handlers for these signals by using `signal`, and you can also explicitly generate these signals by calling [raise](../../c-runtime-library/reference/raise.md).  \n  \n Signal settings are not preserved in spawned processes that are created by calls to `_exec` or `_spawn` functions. The signal settings are reset to the default values in the new process.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`signal`|\\<signal.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Example  \n The following example shows how to use `signal` to add some custom behavior to the `SIGABRT` signal. For additional information about abort behavior, see [_set_abort_behavior](../../c-runtime-library/reference/set-abort-behavior.md).  \n  \n```cpp  \n  \n      // crt_signal.c  \n// compile with: /EHsc /W4  \n// Use signal to attach a signal handler to the abort routine  \n#include <stdlib.h>  \n#include <signal.h>  \n#include <tchar.h>  \n  \nvoid SignalHandler(int signal)  \n{  \n    if (signal == SIGABRT) {  \n        // abort signal handler code  \n    } else {  \n        // ...  \n    }  \n}  \n  \nint main()  \n{  \n    typedef void (*SignalHandlerPointer)(int);  \n  \n    SignalHandlerPointer previousHandler;  \n    previousHandler = signal(SIGABRT, SignalHandler);  \n  \n    abort();  \n}  \n```  \n  \n```Output  \nThis application has requested the Runtime to terminate it in an unusual way.  \nPlease contact the application's support team for more information.  \n  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Process and Environment Control](../../c-runtime-library/process-and-environment-control.md)   \n [abort](../../c-runtime-library/reference/abort.md)   \n [_exec, _wexec Functions](../../c-runtime-library/exec-wexec-functions.md)   \n [exit, _Exit, _exit](../../c-runtime-library/reference/exit-exit-exit.md)   \n [_fpreset](../../c-runtime-library/reference/fpreset.md)   \n [_spawn, _wspawn Functions](../../c-runtime-library/spawn-wspawn-functions.md)"}