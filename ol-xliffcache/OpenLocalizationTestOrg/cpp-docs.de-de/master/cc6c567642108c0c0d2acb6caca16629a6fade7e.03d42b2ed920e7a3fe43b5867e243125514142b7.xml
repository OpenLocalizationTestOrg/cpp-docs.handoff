{"nodes":[{"pos":[12,75],"content":"Using accelerator and accelerator_view Objects | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using accelerator and accelerator_view Objects | Microsoft Docs","pos":[0,63]}]},{"content":"Using accelerator and accelerator_view Objects","pos":[556,602]},{"content":"You can use the <bpt id=\"p1\">[</bpt>accelerator<ept id=\"p1\">](../../parallel/amp/reference/accelerator-class.md)</ept> and <bpt id=\"p2\">[</bpt>accelerator_view<ept id=\"p2\">](../../parallel/amp/reference/accelerator-view-class.md)</ept> classes to specify the device or emulator to run your C++ AMP code on.","pos":[603,833],"source":"You can use the [accelerator](../../parallel/amp/reference/accelerator-class.md) and [accelerator_view](../../parallel/amp/reference/accelerator-view-class.md) classes to specify the device or emulator to run your C++ AMP code on."},{"content":"A system might have several devices or emulators that differ by amount of memory, shared memory support, debugging support, or double-precision support.","pos":[834,986]},{"content":"C++ Accelerated Massive Parallelism (C++ AMP) provides APIs that you can use to examine the available accelerators, set one as the default, specify multiple accelerator_views for multiple calls to parallel_for_each, and perform special debugging tasks.","pos":[987,1239]},{"content":"Using the Default Accelerator","pos":[1248,1277]},{"content":"The C++ AMP runtime picks a default accelerator, unless you write code to pick a specific one.","pos":[1281,1375]},{"content":"The runtime chooses the default accelerator as follows:","pos":[1376,1431]},{"content":"If the app is running in debug mode, an accelerator that supports debugging.","pos":[1441,1517]},{"content":"Otherwise, the accelerator that's specified by the CPPAMP_DEFAULT_ACCELERATOR environment variable, if it's set.","pos":[1527,1639]},{"content":"Otherwise, a non-emulated device.","pos":[1649,1682]},{"content":"Otherwise, the device that has the greatest amount of available memory.","pos":[1692,1763]},{"content":"Otherwise, a device that's not attached to the display.","pos":[1773,1828]},{"content":"Additionally, the runtime specifies an <ph id=\"ph1\">`access_type`</ph> of <ph id=\"ph2\">`access_type_auto`</ph> for the default accelerator.","pos":[1835,1938],"source":"Additionally, the runtime specifies an `access_type` of `access_type_auto` for the default accelerator."},{"content":"This means that the default accelerator uses shared memory if it’s supported and if its performance characteristics (bandwidth and latency) are known to be the same as dedicated (non-shared) memory.","pos":[1939,2137]},{"content":"You can determine the properties of the default accelerator by constructing the default accelerator and examining its properties.","pos":[2144,2273]},{"content":"The following code example prints the path, amount of accelerator memory, shared memory support, double-precision support, and limited double-precision support of the default accelerator.","pos":[2274,2461]},{"content":"CPPAMP_DEFAULT_ACCELERATOR Environment Variable","pos":[3055,3102]},{"content":"You can set the CPPAMP_DEFAULT_ACCELERATOR environment variable to specify the <ph id=\"ph1\">`accelerator::device_path`</ph> of the default accelerator.","pos":[3106,3239],"source":"You can set the CPPAMP_DEFAULT_ACCELERATOR environment variable to specify the `accelerator::device_path` of the default accelerator."},{"content":"The path is hardware-dependent.","pos":[3240,3271]},{"content":"The following code uses the <ph id=\"ph1\">`accelerator::get_all`</ph> function to retrieve a list of the available accelerators and then displays the path and characteristics of each accelerator.","pos":[3272,3448],"source":" The following code uses the `accelerator::get_all` function to retrieve a list of the available accelerators and then displays the path and characteristics of each accelerator."},{"content":"Selecting an Accelerator","pos":[4114,4138]},{"content":"To select an accelerator, use the <ph id=\"ph1\">`accelerator::get_all`</ph> method to retrieve a list of the available accelerators and then select one based on its properties.","pos":[4142,4299],"source":"To select an accelerator, use the `accelerator::get_all` method to retrieve a list of the available accelerators and then select one based on its properties."},{"content":"This example shows how to pick the accelerator that has the most memory:","pos":[4300,4372]},{"pos":[4831,5349],"content":"[!NOTE]\n One of the accelerators that are returned by `accelerator::get_all` is the CPU accelerator. You cannot execute code on the CPU accelerator. To filter out the CPU accelerator, compare the value of the [device_path](reference/accelerator-class.md#device_path) property of the accelerator that's returned by `accelerator::get_all` with the value of the [accelerator::cpu_accelerator](reference/accelerator-class.md#cpu_accelerator). For more information, see the \"Special Accelerators\" section in this article.","leadings":["","> "],"nodes":[{"content":" One of the accelerators that are returned by `accelerator::get_all` is the CPU accelerator. You cannot execute code on the CPU accelerator. To filter out the CPU accelerator, compare the value of the [device_path](reference/accelerator-class.md#device_path) property of the accelerator that's returned by `accelerator::get_all` with the value of the [accelerator::cpu_accelerator](reference/accelerator-class.md#cpu_accelerator). For more information, see the \"Special Accelerators\" section in this article.","pos":[8,516],"nodes":[{"content":"One of the accelerators that are returned by <ph id=\"ph1\">`accelerator::get_all`</ph> is the CPU accelerator.","pos":[1,92],"source":" One of the accelerators that are returned by `accelerator::get_all` is the CPU accelerator."},{"content":"You cannot execute code on the CPU accelerator.","pos":[93,140]},{"content":"To filter out the CPU accelerator, compare the value of the <bpt id=\"p1\">[</bpt>device_path<ept id=\"p1\">](reference/accelerator-class.md#device_path)</ept> property of the accelerator that's returned by <ph id=\"ph1\">`accelerator::get_all`</ph> with the value of the <bpt id=\"p2\">[</bpt>accelerator::cpu_accelerator<ept id=\"p2\">](reference/accelerator-class.md#cpu_accelerator)</ept>.","pos":[141,430],"source":" To filter out the CPU accelerator, compare the value of the [device_path](reference/accelerator-class.md#device_path) property of the accelerator that's returned by `accelerator::get_all` with the value of the [accelerator::cpu_accelerator](reference/accelerator-class.md#cpu_accelerator)."},{"content":"For more information, see the \"Special Accelerators\" section in this article.","pos":[431,508]}]}]},{"content":"Shared Memory","pos":[5358,5371]},{"content":"Shared memory is memory that can be accessed by both the CPU and the accelerator.","pos":[5375,5456]},{"content":"The use of shared memory eliminates or significantly reduces the overhead of copying data between the CPU and the accelerator.","pos":[5457,5583]},{"content":"Although the memory is shared, it cannot be accessed concurrently by both the CPU and the accelerator, and doing so causes undefined behavior.","pos":[5584,5726]},{"content":"The accelerator property <bpt id=\"p1\">[</bpt>supports_cpu_shared_memory<ept id=\"p1\">](reference/accelerator-class.md#supports_cpu_shared_memory)</ept> returns <ph id=\"ph1\">`true`</ph> if the accelerator supports shared memory, and the <bpt id=\"p2\">[</bpt>default_cpu_access_type<ept id=\"p2\">](reference/accelerator-class.md#default_cpu_access_type)</ept> property gets the default <bpt id=\"p3\">[</bpt>access_type<ept id=\"p3\">](reference/concurrency-namespace-enums-amp.md#access_type)</ept> for memory allocated on the <ph id=\"ph2\">`accelerator`</ph>—for example, <ph id=\"ph3\">`array`</ph>s associated with the <ph id=\"ph4\">`accelerator`</ph>, or <ph id=\"ph5\">`array_view`</ph> objects accessed on the <ph id=\"ph6\">`accelerator`</ph>.","pos":[5727,6239],"source":" The accelerator property [supports_cpu_shared_memory](reference/accelerator-class.md#supports_cpu_shared_memory) returns `true` if the accelerator supports shared memory, and the [default_cpu_access_type](reference/accelerator-class.md#default_cpu_access_type) property gets the default [access_type](reference/concurrency-namespace-enums-amp.md#access_type) for memory allocated on the `accelerator`—for example, `array`s associated with the `accelerator`, or `array_view` objects accessed on the `accelerator`."},{"content":"The C++ AMP runtime automatically chooses the best default <ph id=\"ph1\">`access_type`</ph> for each <ph id=\"ph2\">`accelerator`</ph>, but the performance characteristics (bandwidth and latency) of shared memory can be worse than those of dedicated (non-shared) accelerator memory when reading from the CPU, writing from the CPU, or both.","pos":[6245,6545],"source":"The C++ AMP runtime automatically chooses the best default `access_type` for each `accelerator`, but the performance characteristics (bandwidth and latency) of shared memory can be worse than those of dedicated (non-shared) accelerator memory when reading from the CPU, writing from the CPU, or both."},{"content":"If shared memory performs as well as dedicated memory for reading and writing from the CPU, the runtime defaults to <ph id=\"ph1\">`access_type_read_write`</ph>; otherwise, the runtime chooses a more conservative default <ph id=\"ph2\">`access_type`</ph>, and allows the app to override it if the memory access patterns of its computation kernels benefit from a different <ph id=\"ph3\">`access_type`</ph>.","pos":[6546,6892],"source":" If shared memory performs as well as dedicated memory for reading and writing from the CPU, the runtime defaults to `access_type_read_write`; otherwise, the runtime chooses a more conservative default `access_type`, and allows the app to override it if the memory access patterns of its computation kernels benefit from a different `access_type`."},{"pos":[6899,7090],"content":"The following code example shows how to determine whether the default accelerator supports shared memory, and then overrides its default access type and creates an <ph id=\"ph1\">`accelerator_view`</ph> from it.","source":"The following code example shows how to determine whether the default accelerator supports shared memory, and then overrides its default access type and creates an `accelerator_view` from it."},{"pos":[7858,8038],"content":"An <ph id=\"ph1\">`accelerator_view`</ph> always reflects the <ph id=\"ph2\">`default_cpu_access_type`</ph> of the <ph id=\"ph3\">`accelerator`</ph> it’s associated with, and it provides no interface to override or change its <ph id=\"ph4\">`access_type`</ph>.","source":"An `accelerator_view` always reflects the `default_cpu_access_type` of the `accelerator` it’s associated with, and it provides no interface to override or change its `access_type`."},{"content":"Changing the Default Accelerator","pos":[8047,8079]},{"content":"You can change the default accelerator by calling the <ph id=\"ph1\">`accelerator::set_default`</ph> method.","pos":[8083,8171],"source":"You can change the default accelerator by calling the `accelerator::set_default` method."},{"content":"You can change the default accelerator only once per app execution and you must change it before any code is executed on the GPU.","pos":[8172,8301]},{"content":"Any subsequent function calls to change the accelerator return <ph id=\"ph1\">`false`</ph>.","pos":[8302,8373],"source":" Any subsequent function calls to change the accelerator return `false`."},{"content":"If you want to use a different accelerator in a call to <ph id=\"ph1\">`parallel_for_each`</ph>, read the \"Using Multiple Accelerators\" section in this article.","pos":[8374,8514],"source":" If you want to use a different accelerator in a call to `parallel_for_each`, read the \"Using Multiple Accelerators\" section in this article."},{"content":"The following code example sets the default accelerator to one that is not emulated, is not connected to a display, and supports double-precision.","pos":[8515,8661]},{"content":"Using Multiple Accelerators","pos":[9224,9251]},{"content":"There are two ways to use multiple accelerators in your app:","pos":[9255,9315]},{"pos":[9323,9478],"content":"You can pass <ph id=\"ph1\">`accelerator_view`</ph> objects to the calls to the <bpt id=\"p1\">[</bpt>parallel_for_each<ept id=\"p1\">](reference/concurrency-namespace-functions-amp.md#parallel_for_each)</ept> method.","source":"You can pass `accelerator_view` objects to the calls to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method."},{"content":"You can construct an <ph id=\"ph1\">`array`</ph> object using a specific <ph id=\"ph2\">`accelerator_view`</ph> object.","pos":[9488,9567],"source":"You can construct an `array` object using a specific `accelerator_view` object."},{"content":"The C+AMP runtime will pick up the <ph id=\"ph1\">`accelerator_view`</ph> object from the captured <ph id=\"ph2\">`array`</ph> object in the lambda expression.","pos":[9568,9687],"source":" The C+AMP runtime will pick up the `accelerator_view` object from the captured `array` object in the lambda expression."},{"content":"Special Accelerators","pos":[9696,9716]},{"pos":[9720,9822],"content":"The device paths of three special accelerators are available as properties of the <ph id=\"ph1\">`accelerator`</ph> class:","source":"The device paths of three special accelerators are available as properties of the `accelerator` class:"},{"content":"<bpt id=\"p1\">[</bpt>accelerator::direct3d_ref Data Member<ept id=\"p1\">](reference/accelerator-class.md#direct3d_ref)</ept>: This single-threaded accelerator uses software on the CPU to emulate a generic graphics card.","pos":[9830,10009],"source":"[accelerator::direct3d_ref Data Member](reference/accelerator-class.md#direct3d_ref): This single-threaded accelerator uses software on the CPU to emulate a generic graphics card."},{"content":"It's used by default for debugging, but it's not useful in production because it's slower than the hardware accelerators.","pos":[10010,10131]},{"content":"Additionally, it's available only in the DirectX SDK and the Windows SDK, and it's unlikely to be installed on your customers' computers.","pos":[10132,10269]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Debugging GPU Code<ept id=\"p1\">](/visualstudio/debugger/debugging-gpu-code)</ept>.","pos":[10270,10360],"source":" For more information, see [Debugging GPU Code](/visualstudio/debugger/debugging-gpu-code)."},{"pos":[10368,10589],"content":"<bpt id=\"p1\">[</bpt>accelerator::direct3d_warp Data Member<ept id=\"p1\">](reference/accelerator-class.md#direct3d_warp)</ept>: This accelerator provides a fallback solution for executing C++ AMP code on multi-core CPUs that use Streaming SIMD Extensions (SSE).","source":"[accelerator::direct3d_warp Data Member](reference/accelerator-class.md#direct3d_warp): This accelerator provides a fallback solution for executing C++ AMP code on multi-core CPUs that use Streaming SIMD Extensions (SSE)."},{"content":"<bpt id=\"p1\">[</bpt>accelerator::cpu_accelerator Data Member<ept id=\"p1\">](reference/accelerator-class.md#cpu_accelerator)</ept>: You can use this accelerator for setting up staging arrays.","pos":[10597,10748],"source":"[accelerator::cpu_accelerator Data Member](reference/accelerator-class.md#cpu_accelerator): You can use this accelerator for setting up staging arrays."},{"content":"It cannot execute C++ AMP code.","pos":[10749,10780]},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Staging Arrays in C++ AMP<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/LinkId=248485)</ept> post on the Parallel Programming in Native Code blog.","pos":[10781,10940],"source":" For more information, see the [Staging Arrays in C++ AMP](http://go.microsoft.com/fwlink/p/LinkId=248485) post on the Parallel Programming in Native Code blog."},{"content":"Interoperability","pos":[10949,10965]},{"content":"The C++ AMP runtime supports interoperability between the <ph id=\"ph1\">`accelerator_view`</ph> class and the Direct3D <bpt id=\"p1\">[</bpt>ID3D11Device interface<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/LinkId=248488)</ept>.","pos":[10969,11142],"source":"The C++ AMP runtime supports interoperability between the `accelerator_view` class and the Direct3D [ID3D11Device interface](http://go.microsoft.com/fwlink/p/LinkId=248488)."},{"content":"The <bpt id=\"p1\">[</bpt>create_accelerator_view<ept id=\"p1\">](reference/concurrency-direct3d-namespace-functions-amp.md#create_accelerator_view)</ept> method takes an <ph id=\"ph1\">`IUnknown`</ph> interface and returns an <ph id=\"ph2\">`accelerator_view`</ph> object.","pos":[11143,11334],"source":" The [create_accelerator_view](reference/concurrency-direct3d-namespace-functions-amp.md#create_accelerator_view) method takes an `IUnknown` interface and returns an `accelerator_view` object."},{"content":"The <bpt id=\"p1\">[</bpt>get_device<ept id=\"p1\">](http://msdn.microsoft.com/en-us/8194125e-8396-4d62-aa8a-65831dea8439)</ept> method takes an <ph id=\"ph1\">`accelerator_view`</ph> object and returns an <ph id=\"ph2\">`IUknown`</ph> interface.","pos":[11335,11499],"source":" The [get_device](http://msdn.microsoft.com/en-us/8194125e-8396-4d62-aa8a-65831dea8439) method takes an `accelerator_view` object and returns an `IUknown` interface."},{"content":"See Also","pos":[11508,11516]},{"content":"C++ AMP (C++ Accelerated Massive Parallelism)","pos":[11521,11566]},{"content":"Debugging GPU Code","pos":[11640,11658]},{"content":"accelerator_view Class","pos":[11708,11730]}],"content":"---\ntitle: \"Using accelerator and accelerator_view Objects | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 18f0dc66-8236-4420-9f46-1a14f2c3fba1\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using accelerator and accelerator_view Objects\nYou can use the [accelerator](../../parallel/amp/reference/accelerator-class.md) and [accelerator_view](../../parallel/amp/reference/accelerator-view-class.md) classes to specify the device or emulator to run your C++ AMP code on. A system might have several devices or emulators that differ by amount of memory, shared memory support, debugging support, or double-precision support. C++ Accelerated Massive Parallelism (C++ AMP) provides APIs that you can use to examine the available accelerators, set one as the default, specify multiple accelerator_views for multiple calls to parallel_for_each, and perform special debugging tasks.  \n  \n## Using the Default Accelerator  \n The C++ AMP runtime picks a default accelerator, unless you write code to pick a specific one. The runtime chooses the default accelerator as follows:  \n  \n1.  If the app is running in debug mode, an accelerator that supports debugging.  \n  \n2.  Otherwise, the accelerator that's specified by the CPPAMP_DEFAULT_ACCELERATOR environment variable, if it's set.  \n  \n3.  Otherwise, a non-emulated device.  \n  \n4.  Otherwise, the device that has the greatest amount of available memory.  \n  \n5.  Otherwise, a device that's not attached to the display.  \n  \n Additionally, the runtime specifies an `access_type` of `access_type_auto` for the default accelerator. This means that the default accelerator uses shared memory if it’s supported and if its performance characteristics (bandwidth and latency) are known to be the same as dedicated (non-shared) memory.  \n  \n You can determine the properties of the default accelerator by constructing the default accelerator and examining its properties. The following code example prints the path, amount of accelerator memory, shared memory support, double-precision support, and limited double-precision support of the default accelerator.  \n  \n```cpp  \n \nvoid default_properties() {  \n    accelerator default_acc;  \n    std::wcout <<default_acc.device_path <<\"\\n\";  \n    std::wcout <<default_acc.dedicated_memory <<\"\\n\";  \n    std::wcout <<(accs[i].supports_cpu_shared_memory    \n \"CPU shared memory: true\" : \"CPU shared memory: false\") <<\"\\n\";  \n    std::wcout <<(accs[i].supports_double_precision    \n \"double precision: true\" : \"double precision: false\") <<\"\\n\";  \n    std::wcout <<(accs[i].supports_limited_double_precision    \n \"limited double precision: true\" : \"limited double precision: false\") <<\"\\n\";  \n}  \n \n```  \n  \n### CPPAMP_DEFAULT_ACCELERATOR Environment Variable  \n You can set the CPPAMP_DEFAULT_ACCELERATOR environment variable to specify the `accelerator::device_path` of the default accelerator. The path is hardware-dependent. The following code uses the `accelerator::get_all` function to retrieve a list of the available accelerators and then displays the path and characteristics of each accelerator.  \n  \n```cpp  \n \nvoid list_all_accelerators()  \n{  \n    std::vector<accelerator> accs = accelerator::get_all();\nfor (int i = 0; i <accs.size();\n\ni++) {  \n    std::wcout <<accs[i].device_path <<\"\\n\";  \n    std::wcout <<accs[i].dedicated_memory <<\"\\n\";  \n    std::wcout <<(accs[i].supports_cpu_shared_memory    \n \"CPU shared memory: true\" : \"CPU shared memory: false\") <<\"\\n\";  \n    std::wcout <<(accs[i].supports_double_precision    \n \"double precision: true\" : \"double precision: false\") <<\"\\n\";  \n    std::wcout <<(accs[i].supports_limited_double_precision    \n \"limited double precision: true\" : \"limited double precision: false\") <<\"\\n\";  \n }  \n}  \n \n```  \n  \n## Selecting an Accelerator  \n To select an accelerator, use the `accelerator::get_all` method to retrieve a list of the available accelerators and then select one based on its properties. This example shows how to pick the accelerator that has the most memory:  \n  \n```cpp  \n \nvoid pick_with_most_memory()  \n{  \n    std::vector<accelerator> accs = accelerator::get_all();\naccelerator acc_chosen = accs[0];  \n    for (int i = 0; i <accs.size();\n\ni++) {  \n    if (accs[i].dedicated_memory> acc_chosen.dedicated_memory) {  \n    acc_chosen = accs[i];  \n }  \n }  \n \n    std::wcout <<\"The accelerator with the most memory is \"    \n <<acc_chosen.device_path <<\"\\n\"  \n <<acc_chosen.dedicated_memory <<\".\\n\";  \n}  \n \n```  \n  \n> [!NOTE]\n>  One of the accelerators that are returned by `accelerator::get_all` is the CPU accelerator. You cannot execute code on the CPU accelerator. To filter out the CPU accelerator, compare the value of the [device_path](reference/accelerator-class.md#device_path) property of the accelerator that's returned by `accelerator::get_all` with the value of the [accelerator::cpu_accelerator](reference/accelerator-class.md#cpu_accelerator). For more information, see the \"Special Accelerators\" section in this article.  \n  \n## Shared Memory  \n Shared memory is memory that can be accessed by both the CPU and the accelerator. The use of shared memory eliminates or significantly reduces the overhead of copying data between the CPU and the accelerator. Although the memory is shared, it cannot be accessed concurrently by both the CPU and the accelerator, and doing so causes undefined behavior. The accelerator property [supports_cpu_shared_memory](reference/accelerator-class.md#supports_cpu_shared_memory) returns `true` if the accelerator supports shared memory, and the [default_cpu_access_type](reference/accelerator-class.md#default_cpu_access_type) property gets the default [access_type](reference/concurrency-namespace-enums-amp.md#access_type) for memory allocated on the `accelerator`—for example, `array`s associated with the `accelerator`, or `array_view` objects accessed on the `accelerator`. \n  \n The C++ AMP runtime automatically chooses the best default `access_type` for each `accelerator`, but the performance characteristics (bandwidth and latency) of shared memory can be worse than those of dedicated (non-shared) accelerator memory when reading from the CPU, writing from the CPU, or both. If shared memory performs as well as dedicated memory for reading and writing from the CPU, the runtime defaults to `access_type_read_write`; otherwise, the runtime chooses a more conservative default `access_type`, and allows the app to override it if the memory access patterns of its computation kernels benefit from a different `access_type`.  \n  \n The following code example shows how to determine whether the default accelerator supports shared memory, and then overrides its default access type and creates an `accelerator_view` from it.  \n  \n```cpp  \n#include <amp.h>  \n#include <iostream>  \n  \nusing namespace Concurrency;  \n  \nint main()  \n{  \n  accelerator acc = accelerator(accelerator::default_accelerator);  \n  \n  // Early out if the default accelerator doesn’t support shared memory.  \n  if(!acc.supports_cpu_shared_memory)  \n  {  \n    std::cout << \"The default accelerator does not support shared memory\" << std::endl;  \n    return 1;  \n  }  \n  \n  // Override the default CPU access type.  \n  acc.set_default_cpu_access_type(access_type_read_write);  \n  \n  // Create an accelerator_view from the default accelerator. The  \n  // accelerator_view reflects the default_cpu_access_type of the  \n  // accelerator it’s associated with.  \n  accelerator_view acc_v = acc.default_view;  \n}  \n  \n```  \n  \n An `accelerator_view` always reflects the `default_cpu_access_type` of the `accelerator` it’s associated with, and it provides no interface to override or change its `access_type`.  \n  \n## Changing the Default Accelerator  \n You can change the default accelerator by calling the `accelerator::set_default` method. You can change the default accelerator only once per app execution and you must change it before any code is executed on the GPU. Any subsequent function calls to change the accelerator return `false`. If you want to use a different accelerator in a call to `parallel_for_each`, read the \"Using Multiple Accelerators\" section in this article. The following code example sets the default accelerator to one that is not emulated, is not connected to a display, and supports double-precision.  \n  \n```cpp  \n \n    bool pick_accelerator()  \n{  \n    std::vector<accelerator> accs = accelerator::get_all();\naccelerator chosen_one;  \n \n    auto result = \n    std::find_if(accs.begin(), accs.end(), [] (const accelerator& acc)  \n {  \n    return !acc.is_emulated&& \n    acc.supports_double_precision&& \n !acc.has_display;  \n });\n\n \n    if (result != accs.end())  \n    chosen_one = *(result);\n\n \n    std::wcout <<chosen_one.description <<std::endl;  \n \n    bool success = accelerator::set_default(chosen_one.device_path);\n\n    return success;  \n}  \n \n```  \n  \n## Using Multiple Accelerators  \n There are two ways to use multiple accelerators in your app:  \n\n-   You can pass `accelerator_view` objects to the calls to the [parallel_for_each](reference/concurrency-namespace-functions-amp.md#parallel_for_each) method.  \n  \n-   You can construct an `array` object using a specific `accelerator_view` object. The C+AMP runtime will pick up the `accelerator_view` object from the captured `array` object in the lambda expression.  \n  \n## Special Accelerators  \n The device paths of three special accelerators are available as properties of the `accelerator` class:  \n  \n- [accelerator::direct3d_ref Data Member](reference/accelerator-class.md#direct3d_ref): This single-threaded accelerator uses software on the CPU to emulate a generic graphics card. It's used by default for debugging, but it's not useful in production because it's slower than the hardware accelerators. Additionally, it's available only in the DirectX SDK and the Windows SDK, and it's unlikely to be installed on your customers' computers. For more information, see [Debugging GPU Code](/visualstudio/debugger/debugging-gpu-code).  \n  \n- [accelerator::direct3d_warp Data Member](reference/accelerator-class.md#direct3d_warp): This accelerator provides a fallback solution for executing C++ AMP code on multi-core CPUs that use Streaming SIMD Extensions (SSE).  \n  \n- [accelerator::cpu_accelerator Data Member](reference/accelerator-class.md#cpu_accelerator): You can use this accelerator for setting up staging arrays. It cannot execute C++ AMP code. For more information, see the [Staging Arrays in C++ AMP](http://go.microsoft.com/fwlink/p/LinkId=248485) post on the Parallel Programming in Native Code blog.  \n  \n## Interoperability  \n The C++ AMP runtime supports interoperability between the `accelerator_view` class and the Direct3D [ID3D11Device interface](http://go.microsoft.com/fwlink/p/LinkId=248488). The [create_accelerator_view](reference/concurrency-direct3d-namespace-functions-amp.md#create_accelerator_view) method takes an `IUnknown` interface and returns an `accelerator_view` object. The [get_device](http://msdn.microsoft.com/en-us/8194125e-8396-4d62-aa8a-65831dea8439) method takes an `accelerator_view` object and returns an `IUknown` interface.  \n  \n## See Also  \n [C++ AMP (C++ Accelerated Massive Parallelism)](../../parallel/amp/cpp-amp-cpp-accelerated-massive-parallelism.md)   \n [Debugging GPU Code](/visualstudio/debugger/debugging-gpu-code)   \n [accelerator_view Class](../../parallel/amp/reference/accelerator-view-class.md)\n"}