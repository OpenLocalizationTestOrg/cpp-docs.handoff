{"nodes":[{"pos":[12,56],"content":"Initializing Extension DLLs | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Initializing Extension DLLs | Microsoft Docs","pos":[0,44]}]},{"content":"Initializing Extension DLLs","pos":[652,679]},{"pos":[680,880],"content":"Because extension DLLs do not have a <ph id=\"ph1\">`CWinApp`</ph>-derived object (as do regular DLLs), you should add your initialization and termination code to the <ph id=\"ph2\">`DllMain`</ph> function that the MFC DLL Wizard generates.","source":"Because extension DLLs do not have a `CWinApp`-derived object (as do regular DLLs), you should add your initialization and termination code to the `DllMain` function that the MFC DLL Wizard generates."},{"content":"The wizard provides the following code for extension DLLs.","pos":[887,945]},{"content":"In the code, <ph id=\"ph1\">`PROJNAME`</ph> is a placeholder for the name of your project.","pos":[946,1016],"source":" In the code, `PROJNAME` is a placeholder for the name of your project."},{"pos":[1824,1986],"content":"Creating a new <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object during initialization allows the extension DLL to export <ph id=\"ph1\">`CRuntimeClass`</ph> objects or resources to the client application.","source":"Creating a new **CDynLinkLibrary** object during initialization allows the extension DLL to export `CRuntimeClass` objects or resources to the client application."},{"content":"If you are going to use your extension DLL from one or more regular DLLs, you must export an initialization function that creates a <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object.","pos":[1993,2152],"source":"If you are going to use your extension DLL from one or more regular DLLs, you must export an initialization function that creates a **CDynLinkLibrary** object."},{"content":"That function must be called from each of the regular DLLs that use the extension DLL.","pos":[2153,2239]},{"content":"An appropriate place to call this initialization function is in the <ph id=\"ph1\">`InitInstance`</ph> member function of the regular DLL's <ph id=\"ph2\">`CWinApp`</ph>-derived object before using any of the extension DLL's exported classes or functions.","pos":[2240,2455],"source":" An appropriate place to call this initialization function is in the `InitInstance` member function of the regular DLL's `CWinApp`-derived object before using any of the extension DLL's exported classes or functions."},{"content":"In the <ph id=\"ph1\">`DllMain`</ph> that the MFC DLL Wizard generates, the call to <ph id=\"ph2\">`AfxInitExtensionModule`</ph> captures the module's run-time classes (<ph id=\"ph3\">`CRuntimeClass`</ph> structures) as well as its object factories (<ph id=\"ph4\">`COleObjectFactory`</ph> objects) for use when the <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept> object is created.","pos":[2462,2736],"source":"In the `DllMain` that the MFC DLL Wizard generates, the call to `AfxInitExtensionModule` captures the module's run-time classes (`CRuntimeClass` structures) as well as its object factories (`COleObjectFactory` objects) for use when the **CDynLinkLibrary** object is created."},{"content":"You should check the return value of <ph id=\"ph1\">`AfxInitExtensionModule`</ph>; if a zero value is returned from <ph id=\"ph2\">`AfxInitExtensionModule`</ph>, return zero from your <ph id=\"ph3\">`DllMain`</ph> function.","pos":[2737,2900],"source":" You should check the return value of `AfxInitExtensionModule`; if a zero value is returned from `AfxInitExtensionModule`, return zero from your `DllMain` function."},{"content":"If your extension DLL will be explicitly linked to an executable (meaning the executable calls <ph id=\"ph1\">`AfxLoadLibrary`</ph> to link to the DLL), you should add a call to <ph id=\"ph2\">`AfxTermExtensionModule`</ph> on <bpt id=\"p1\">**</bpt>DLL_PROCESS_DETACH<ept id=\"p1\">**</ept>.","pos":[2907,3116],"source":"If your extension DLL will be explicitly linked to an executable (meaning the executable calls `AfxLoadLibrary` to link to the DLL), you should add a call to `AfxTermExtensionModule` on **DLL_PROCESS_DETACH**."},{"content":"This function allows MFC to clean up the extension DLL when each process detaches from the extension DLL (which happens when the process exits or when the DLL is unloaded as a result of a <ph id=\"ph1\">`AfxFreeLibrary`</ph> call).","pos":[3117,3328],"source":" This function allows MFC to clean up the extension DLL when each process detaches from the extension DLL (which happens when the process exits or when the DLL is unloaded as a result of a `AfxFreeLibrary` call)."},{"content":"If your extension DLL will be linked implicitly to the application, the call to <ph id=\"ph1\">`AfxTermExtensionModule`</ph> is not necessary.","pos":[3329,3451],"source":" If your extension DLL will be linked implicitly to the application, the call to `AfxTermExtensionModule` is not necessary."},{"content":"Applications that explicitly link to extension DLLs must call <bpt id=\"p1\">**</bpt>AfxTermExtensionModule<ept id=\"p1\">**</ept> when freeing the DLL.","pos":[3458,3568],"source":"Applications that explicitly link to extension DLLs must call **AfxTermExtensionModule** when freeing the DLL."},{"content":"They should also use <ph id=\"ph1\">`AfxLoadLibrary`</ph> and <ph id=\"ph2\">`AfxFreeLibrary`</ph> (instead of the Win32 functions <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>FreeLibrary<ept id=\"p2\">**</ept>) if the application uses multiple threads.","pos":[3569,3738],"source":" They should also use `AfxLoadLibrary` and `AfxFreeLibrary` (instead of the Win32 functions **LoadLibrary** and **FreeLibrary**) if the application uses multiple threads."},{"content":"Using <ph id=\"ph1\">`AfxLoadLibrary`</ph> and <ph id=\"ph2\">`AfxFreeLibrary`</ph> ensures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state.","pos":[3739,3924],"source":" Using `AfxLoadLibrary` and `AfxFreeLibrary` ensures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state."},{"pos":[3931,4106],"content":"Because the MFCx0.dll is fully initialized by the time <ph id=\"ph1\">`DllMain`</ph> is called, you can allocate memory and call MFC functions within <ph id=\"ph2\">`DllMain`</ph> (unlike the 16-bit version of MFC).","source":"Because the MFCx0.dll is fully initialized by the time `DllMain` is called, you can allocate memory and call MFC functions within `DllMain` (unlike the 16-bit version of MFC)."},{"content":"Extension DLLs can take care of multithreading by handling the <bpt id=\"p1\">**</bpt>DLL_THREAD_ATTACH<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>DLL_THREAD_DETACH<ept id=\"p2\">**</ept> cases in the <ph id=\"ph1\">`DllMain`</ph> function.","pos":[4113,4256],"source":"Extension DLLs can take care of multithreading by handling the **DLL_THREAD_ATTACH** and **DLL_THREAD_DETACH** cases in the `DllMain` function."},{"content":"These cases are passed to <ph id=\"ph1\">`DllMain`</ph> when threads attach and detach from the DLL.","pos":[4257,4337],"source":" These cases are passed to `DllMain` when threads attach and detach from the DLL."},{"content":"Calling <bpt id=\"p1\">[</bpt>TlsAlloc<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686801)</ept> when a DLL is attaching allows the DLL to maintain thread local storage (TLS) indexes for every thread attached to the DLL.","pos":[4338,4540],"source":" Calling [TlsAlloc](http://msdn.microsoft.com/library/windows/desktop/ms686801) when a DLL is attaching allows the DLL to maintain thread local storage (TLS) indexes for every thread attached to the DLL."},{"content":"Note that the header file Afxdllx.h contains special definitions for structures used in extension DLLs, such as the definition for <ph id=\"ph1\">`AFX_EXTENSION_MODULE`</ph> and <bpt id=\"p1\">**</bpt>CDynLinkLibrary<ept id=\"p1\">**</ept>.","pos":[4547,4725],"source":"Note that the header file Afxdllx.h contains special definitions for structures used in extension DLLs, such as the definition for `AFX_EXTENSION_MODULE` and **CDynLinkLibrary**."},{"content":"You should include this header file in your extension DLL.","pos":[4726,4784]},{"pos":[4792,5151],"content":"[!NOTE]\n It is important that you neither define nor undefine any of the _AFX_NO_XXX macros in Stdafx.h. For more information, see the Knowledge Base article \"PRB: Problems Occur When Defining _AFX_NO_XXX\" (Q140751). You can find Knowledge Base articles in the MSDN Library or at [http://search.support.microsoft.com/](http://search.support.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" It is important that you neither define nor undefine any of the _AFX_NO_XXX macros in Stdafx.h. For more information, see the Knowledge Base article \"PRB: Problems Occur When Defining _AFX_NO_XXX\" (Q140751). You can find Knowledge Base articles in the MSDN Library or at [http://search.support.microsoft.com/](http://search.support.microsoft.com/).","pos":[8,357],"nodes":[{"content":"It is important that you neither define nor undefine any of the _AFX_NO_XXX macros in Stdafx.h.","pos":[1,96]},{"content":"For more information, see the Knowledge Base article \"PRB: Problems Occur When Defining _AFX_NO_XXX\" (Q140751).","pos":[97,208]},{"content":"You can find Knowledge Base articles in the MSDN Library or at <bpt id=\"p1\">[</bpt>http://search.support.microsoft.com/<ept id=\"p1\">](http://search.support.microsoft.com/)</ept>.","pos":[209,349],"source":" You can find Knowledge Base articles in the MSDN Library or at [http://search.support.microsoft.com/](http://search.support.microsoft.com/)."}]}]},{"content":"A sample initialization function that handles multithreading is included in <bpt id=\"p1\">[</bpt>Using Thread Local Storage in a Dynamic-Link Library<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686997)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[5158,5436],"source":"A sample initialization function that handles multithreading is included in [Using Thread Local Storage in a Dynamic-Link Library](http://msdn.microsoft.com/library/windows/desktop/ms686997) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"Note that the sample contains an entry-point function called <bpt id=\"p1\">**</bpt>LibMain<ept id=\"p1\">**</ept>, but you should name this function <ph id=\"ph1\">`DllMain`</ph> so that it works with the MFC and C run-time libraries.","pos":[5437,5610],"source":" Note that the sample contains an entry-point function called **LibMain**, but you should name this function `DllMain` so that it works with the MFC and C run-time libraries."},{"pos":[5617,5761],"content":"The MFC sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)</ept> demonstrates the use of initialization functions.","source":"The MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90) demonstrates the use of initialization functions."},{"content":"What do you want to do?","pos":[5770,5793]},{"content":"Initialize regular DLLs","pos":[5804,5827]},{"content":"Initialize non-MFC DLLs","pos":[5878,5901]},{"content":"What do you want to know more about?","pos":[5950,5986]},{"content":"The C run-time library behavior and _DllMainCRTStartup","pos":[5997,6051]},{"content":"Using Database, OLE, and Sockets Extension DLLs in Regular DLLs","pos":[6102,6165]},{"content":"The function specification for DllMain (Windows SDK)","pos":[6252,6304]},{"content":"Dynamic-link library entry-point function (Windows SDK)","pos":[6376,6431]},{"content":"See Also","pos":[6501,6509]},{"content":"Initializing a DLL","pos":[6514,6532]}],"content":"---\ntitle: \"Initializing Extension DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"DLLs [C++], extension\"\n  - \"initializing DLLs\"\n  - \"extension DLLs [C++], initializing\"\nms.assetid: 08ad0381-3808-4bea-a93c-c9ba62496543\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Initializing Extension DLLs\nBecause extension DLLs do not have a `CWinApp`-derived object (as do regular DLLs), you should add your initialization and termination code to the `DllMain` function that the MFC DLL Wizard generates.  \n  \n The wizard provides the following code for extension DLLs. In the code, `PROJNAME` is a placeholder for the name of your project.  \n  \n```  \n#include \"stdafx.h\"  \n#include <afxdllx.h>  \n  \n#ifdef _DEBUG  \n#define new DEBUG_NEW  \n#undef THIS_FILE  \nstatic char THIS_FILE[] = __FILE__;  \n#endif  \nstatic AFX_EXTENSION_MODULE PROJNAMEDLL = { NULL, NULL };  \n  \nextern \"C\" int APIENTRY  \nDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)  \n{  \n   if (dwReason == DLL_PROCESS_ATTACH)  \n   {  \n      TRACE0(\"PROJNAME.DLL Initializing!\\n\");  \n  \n      // Extension DLL one-time initialization  \n      AfxInitExtensionModule(PROJNAMEDLL,   \n                                 hInstance);  \n  \n      // Insert this DLL into the resource chain  \n      new CDynLinkLibrary(Dll3DLL);  \n   }  \n   else if (dwReason == DLL_PROCESS_DETACH)  \n   {  \n      TRACE0(\"PROJNAME.DLL Terminating!\\n\");  \n   }  \n   return 1;   // ok  \n}  \n```  \n  \n Creating a new **CDynLinkLibrary** object during initialization allows the extension DLL to export `CRuntimeClass` objects or resources to the client application.  \n  \n If you are going to use your extension DLL from one or more regular DLLs, you must export an initialization function that creates a **CDynLinkLibrary** object. That function must be called from each of the regular DLLs that use the extension DLL. An appropriate place to call this initialization function is in the `InitInstance` member function of the regular DLL's `CWinApp`-derived object before using any of the extension DLL's exported classes or functions.  \n  \n In the `DllMain` that the MFC DLL Wizard generates, the call to `AfxInitExtensionModule` captures the module's run-time classes (`CRuntimeClass` structures) as well as its object factories (`COleObjectFactory` objects) for use when the **CDynLinkLibrary** object is created. You should check the return value of `AfxInitExtensionModule`; if a zero value is returned from `AfxInitExtensionModule`, return zero from your `DllMain` function.  \n  \n If your extension DLL will be explicitly linked to an executable (meaning the executable calls `AfxLoadLibrary` to link to the DLL), you should add a call to `AfxTermExtensionModule` on **DLL_PROCESS_DETACH**. This function allows MFC to clean up the extension DLL when each process detaches from the extension DLL (which happens when the process exits or when the DLL is unloaded as a result of a `AfxFreeLibrary` call). If your extension DLL will be linked implicitly to the application, the call to `AfxTermExtensionModule` is not necessary.  \n  \n Applications that explicitly link to extension DLLs must call **AfxTermExtensionModule** when freeing the DLL. They should also use `AfxLoadLibrary` and `AfxFreeLibrary` (instead of the Win32 functions **LoadLibrary** and **FreeLibrary**) if the application uses multiple threads. Using `AfxLoadLibrary` and `AfxFreeLibrary` ensures that the startup and shutdown code that executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state.  \n  \n Because the MFCx0.dll is fully initialized by the time `DllMain` is called, you can allocate memory and call MFC functions within `DllMain` (unlike the 16-bit version of MFC).  \n  \n Extension DLLs can take care of multithreading by handling the **DLL_THREAD_ATTACH** and **DLL_THREAD_DETACH** cases in the `DllMain` function. These cases are passed to `DllMain` when threads attach and detach from the DLL. Calling [TlsAlloc](http://msdn.microsoft.com/library/windows/desktop/ms686801) when a DLL is attaching allows the DLL to maintain thread local storage (TLS) indexes for every thread attached to the DLL.  \n  \n Note that the header file Afxdllx.h contains special definitions for structures used in extension DLLs, such as the definition for `AFX_EXTENSION_MODULE` and **CDynLinkLibrary**. You should include this header file in your extension DLL.  \n  \n> [!NOTE]\n>  It is important that you neither define nor undefine any of the _AFX_NO_XXX macros in Stdafx.h. For more information, see the Knowledge Base article \"PRB: Problems Occur When Defining _AFX_NO_XXX\" (Q140751). You can find Knowledge Base articles in the MSDN Library or at [http://search.support.microsoft.com/](http://search.support.microsoft.com/).  \n  \n A sample initialization function that handles multithreading is included in [Using Thread Local Storage in a Dynamic-Link Library](http://msdn.microsoft.com/library/windows/desktop/ms686997) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]. Note that the sample contains an entry-point function called **LibMain**, but you should name this function `DllMain` so that it works with the MFC and C run-time libraries.  \n  \n The MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90) demonstrates the use of initialization functions.  \n  \n## What do you want to do?  \n  \n-   [Initialize regular DLLs](../build/initializing-regular-dlls.md)  \n  \n-   [Initialize non-MFC DLLs](../build/initializing-non-mfc-dlls.md)  \n  \n## What do you want to know more about?  \n  \n-   [The C run-time library behavior and _DllMainCRTStartup](../build/run-time-library-behavior.md)  \n  \n-   [Using Database, OLE, and Sockets Extension DLLs in Regular DLLs](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  \n  \n-   [The function specification for DllMain (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms682583)  \n  \n-   [Dynamic-link library entry-point function (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms682596)  \n  \n## See Also  \n [Initializing a DLL](../build/initializing-a-dll.md)"}