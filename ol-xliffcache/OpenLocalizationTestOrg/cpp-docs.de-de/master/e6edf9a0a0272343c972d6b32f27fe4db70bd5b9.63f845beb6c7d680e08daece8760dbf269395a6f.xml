{"nodes":[{"pos":[12,51],"content":"TN014: Custom Controls | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN014: Custom Controls | Microsoft Docs","pos":[0,39]}]},{"content":"TN014: Custom Controls","pos":[626,648]},{"content":"This note describes the MFC Support for custom and self-drawing controls.","pos":[649,722]},{"content":"It also describes dynamic subclassing, and describes the relationship between <bpt id=\"p1\">[</bpt>CWnd<ept id=\"p1\">](../mfc/reference/cwnd-class.md)</ept> objects and <ph id=\"ph1\">`HWND`</ph>s.","pos":[723,860],"source":" It also describes dynamic subclassing, and describes the relationship between [CWnd](../mfc/reference/cwnd-class.md) objects and `HWND`s."},{"content":"The MFC sample application CTRLTEST illustrates how to use many custom controls.","pos":[867,947]},{"content":"See the source code for the MFC General sample <bpt id=\"p1\">[</bpt>CTRLTEST<ept id=\"p1\">](../visual-cpp-samples.md)</ept> and online help.","pos":[948,1048],"source":" See the source code for the MFC General sample [CTRLTEST](../visual-cpp-samples.md) and online help."},{"content":"Owner-Draw Controls/Menus","pos":[1057,1082]},{"content":"Windows provides support for owner-draw controls and menus by using Windows messages.","pos":[1086,1171]},{"content":"The parent window of any control or menu receives these messages and calls functions in response.","pos":[1172,1269]},{"content":"You can override these functions to customize the visual appearance and behavior of your owner-draw control or menu.","pos":[1270,1386]},{"content":"MFC directly supports owner-draw with the following functions:","pos":[1393,1455]},{"content":"CWnd::OnDrawItem","pos":[1464,1480]},{"content":"CWnd::OnMeasureItem","pos":[1539,1558]},{"content":"CWnd::OnCompareItem","pos":[1620,1639]},{"content":"CWnd::OnDeleteItem","pos":[1701,1719]},{"pos":[1778,1874],"content":"You can override these functions in your <ph id=\"ph1\">`CWnd`</ph> derived class to implement custom draw behavior.","source":"You can override these functions in your `CWnd` derived class to implement custom draw behavior."},{"content":"This approach does not lead to reusable code.","pos":[1881,1926]},{"content":"If you have two similar controls in two different <ph id=\"ph1\">`CWnd`</ph> classes, you must implement the custom control behavior in two locations.","pos":[1927,2057],"source":" If you have two similar controls in two different `CWnd` classes, you must implement the custom control behavior in two locations."},{"content":"The MFC-supported self-drawing control architecture solves this problem.","pos":[2058,2130]},{"content":"Self-Draw Controls and Menus","pos":[2139,2167]},{"content":"MFC provides a default implementation (in the <ph id=\"ph1\">`CWnd`</ph> and <bpt id=\"p1\">[</bpt>CMenu<ept id=\"p1\">](../mfc/reference/cmenu-class.md)</ept> classes) for the standard owner-draw messages.","pos":[2171,2315],"source":"MFC provides a default implementation (in the `CWnd` and [CMenu](../mfc/reference/cmenu-class.md) classes) for the standard owner-draw messages."},{"content":"This default implementation will decode the owner-draw parameters and delegate the owner-draw messages to the controls or menu.","pos":[2316,2443]},{"content":"This is called self-draw because the drawing code is in the class of the control or menu, not in the owner window.","pos":[2444,2558]},{"content":"By using self-draw controls you can build reusable control classes that use owner-draw semantics to display the control.","pos":[2565,2685]},{"content":"The code for drawing the control is in the control class, not its parent.","pos":[2686,2759]},{"content":"This is an object-oriented approach to custom control programming.","pos":[2760,2826]},{"content":"Add the following list of functions to your self-draw classes:","pos":[2827,2889]},{"content":"For self-draw buttons:","pos":[2899,2921]},{"content":"For self-draw menus:","pos":[3026,3046]},{"content":"For self-draw list boxes:","pos":[3264,3289]},{"content":"For self-draw combo boxes:","pos":[3738,3764]},{"pos":[4218,4670],"content":"For details on the owner-draw structures (<bpt id=\"p1\">[</bpt>DRAWITEMSTRUCT<ept id=\"p1\">](../mfc/reference/drawitemstruct-structure.md)</ept>, <bpt id=\"p2\">[</bpt>MEASUREITEMSTRUCT<ept id=\"p2\">](../mfc/reference/measureitemstruct-structure.md)</ept>, <bpt id=\"p3\">[</bpt>COMPAREITEMSTRUCT<ept id=\"p3\">](../mfc/reference/compareitemstruct-structure.md)</ept>, and <bpt id=\"p4\">[</bpt>DELETEITEMSTRUCT<ept id=\"p4\">](../mfc/reference/deleteitemstruct-structure.md)</ept>) see the MFC documentation for <ph id=\"ph1\">`CWnd::OnDrawItem`</ph>, <ph id=\"ph2\">`CWnd::OnMeasureItem`</ph>, <ph id=\"ph3\">`CWnd::OnCompareItem`</ph>, and <ph id=\"ph4\">`CWnd::OnDeleteItem`</ph> respectively.","source":"For details on the owner-draw structures ([DRAWITEMSTRUCT](../mfc/reference/drawitemstruct-structure.md), [MEASUREITEMSTRUCT](../mfc/reference/measureitemstruct-structure.md), [COMPAREITEMSTRUCT](../mfc/reference/compareitemstruct-structure.md), and [DELETEITEMSTRUCT](../mfc/reference/deleteitemstruct-structure.md)) see the MFC documentation for `CWnd::OnDrawItem`, `CWnd::OnMeasureItem`, `CWnd::OnCompareItem`, and `CWnd::OnDeleteItem` respectively."},{"content":"Using self-draw controls and menus","pos":[4679,4713]},{"pos":[4717,4806],"content":"For self-draw menus, you must override both the <ph id=\"ph1\">`OnMeasureItem`</ph> and <ph id=\"ph2\">`OnDrawItem`</ph> methods.","source":"For self-draw menus, you must override both the `OnMeasureItem` and `OnDrawItem` methods."},{"content":"For self-draw list boxes and combo boxes, you must override <ph id=\"ph1\">`OnMeasureItem`</ph> and <ph id=\"ph2\">`OnDrawItem`</ph>.","pos":[4813,4906],"source":"For self-draw list boxes and combo boxes, you must override `OnMeasureItem` and `OnDrawItem`."},{"content":"You must specify the <ph id=\"ph1\">`LBS_OWNERDRAWVARIABLE`</ph> style for list boxes or <ph id=\"ph2\">`CBS_OWNERDRAWVARIABLE`</ph> style for combo boxes in the dialog template.","pos":[4907,5045],"source":" You must specify the `LBS_OWNERDRAWVARIABLE` style for list boxes or `CBS_OWNERDRAWVARIABLE` style for combo boxes in the dialog template."},{"content":"The <ph id=\"ph1\">`OWNERDRAWFIXED`</ph> style will not work with self-draw items because the fixed item height is determined before self-draw controls are attached to the list box.","pos":[5046,5207],"source":" The `OWNERDRAWFIXED` style will not work with self-draw items because the fixed item height is determined before self-draw controls are attached to the list box."},{"content":"(You can use the methods <bpt id=\"p1\">[</bpt>CListBox::SetItemHeight<ept id=\"p1\">](../mfc/reference/clistbox-class.md#clistbox__setitemheight)</ept> and <bpt id=\"p2\">[</bpt>CComboBox::SetItemHeight<ept id=\"p2\">](../mfc/reference/ccombobox-class.md#ccombobox__setitemheight)</ept> to overcome this limitation.)","pos":[5208,5441],"source":" (You can use the methods [CListBox::SetItemHeight](../mfc/reference/clistbox-class.md#clistbox__setitemheight) and [CComboBox::SetItemHeight](../mfc/reference/ccombobox-class.md#ccombobox__setitemheight) to overcome this limitation.)"},{"content":"Switching to an <ph id=\"ph1\">`OWNERDRAWVARIABLE`</ph> style will force the system to apply the <ph id=\"ph2\">`NOINTEGRALHEIGHT`</ph> style to the control.","pos":[5448,5565],"source":"Switching to an `OWNERDRAWVARIABLE` style will force the system to apply the `NOINTEGRALHEIGHT` style to the control."},{"content":"Because the control cannot calculate an integral height with variable sized items, the default style of <ph id=\"ph1\">`INTEGRALHEIGHT`</ph> is ignored and the control is always <ph id=\"ph2\">`NOINTEGRALHEIGHT`</ph>.","pos":[5566,5743],"source":" Because the control cannot calculate an integral height with variable sized items, the default style of `INTEGRALHEIGHT` is ignored and the control is always `NOINTEGRALHEIGHT`."},{"content":"If your items are fixed height, you can prevent partial items from being drawn by specifying the control size to be an integer multiplier of the item size.","pos":[5744,5899]},{"pos":[5906,6036],"content":"For self-drawing list boxes and combo boxes with the <ph id=\"ph1\">`LBS_SORT`</ph> or <ph id=\"ph2\">`CBS_SORT`</ph> style, you must override the <ph id=\"ph3\">`OnCompareItem`</ph> method.","source":"For self-drawing list boxes and combo boxes with the `LBS_SORT` or `CBS_SORT` style, you must override the `OnCompareItem` method."},{"content":"For self-drawing list boxes and combo boxes, <ph id=\"ph1\">`OnDeleteItem`</ph> is not usually overridden.","pos":[6043,6129],"source":"For self-drawing list boxes and combo boxes, `OnDeleteItem` is not usually overridden."},{"content":"You can override <ph id=\"ph1\">`OnDeleteItem`</ph> if you want to perform any special processing.","pos":[6130,6208],"source":" You can override `OnDeleteItem` if you want to perform any special processing."},{"content":"One case where this would be applicable is when additional memory or other resources are stored with each list box or combo box item.","pos":[6209,6342]},{"content":"Examples of Self-Drawing Controls and Menus","pos":[6351,6394]},{"pos":[6398,6520],"content":"The MFC General sample <bpt id=\"p1\">[</bpt>CTRLTEST<ept id=\"p1\">](../visual-cpp-samples.md)</ept> provides samples of a self-draw menu and a self-draw list box.","source":"The MFC General sample [CTRLTEST](../visual-cpp-samples.md) provides samples of a self-draw menu and a self-draw list box."},{"content":"The most typical example of a self-drawing button is a bitmap button.","pos":[6527,6596]},{"content":"A bitmap button is a button that shows one, two, or three bitmap images for the different states.","pos":[6597,6694]},{"content":"An example of this is provided in the MFC class <bpt id=\"p1\">[</bpt>CBitmapButton<ept id=\"p1\">](../mfc/reference/cbitmapbutton-class.md)</ept>.","pos":[6695,6800],"source":" An example of this is provided in the MFC class [CBitmapButton](../mfc/reference/cbitmapbutton-class.md)."},{"content":"Dynamic Subclassing","pos":[6809,6828]},{"content":"Occasionally you will want to change the functionality of an object that already exists.","pos":[6832,6920]},{"content":"The previous examples required you to customize the controls before they were created.","pos":[6921,7007]},{"content":"Dynamic subclassing enables you to customize a control that has already been created.","pos":[7008,7093]},{"pos":[7100,7326],"content":"Subclassing is the Windows term for replacing the <bpt id=\"p1\">[</bpt>WndProc<ept id=\"p1\">](http://msdn.microsoft.com/en-us/94ba8ffa-3c36-46d4-ac74-9bd10b1ffd26)</ept> of a window with a customized <ph id=\"ph1\">`WndProc`</ph> and calling the old <ph id=\"ph2\">`WndProc`</ph> for default functionality.","source":"Subclassing is the Windows term for replacing the [WndProc](http://msdn.microsoft.com/en-us/94ba8ffa-3c36-46d4-ac74-9bd10b1ffd26) of a window with a customized `WndProc` and calling the old `WndProc` for default functionality."},{"content":"This should not be confused with C++ class derivation.","pos":[7333,7387]},{"content":"For clarification, the C++ terms <bpt id=\"p1\">*</bpt>base class<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>derived class<ept id=\"p2\">*</ept> are analogous to <bpt id=\"p3\">*</bpt>superclass<ept id=\"p3\">*</ept> and <bpt id=\"p4\">*</bpt>subclass<ept id=\"p4\">*</ept> in the Windows object model.","pos":[7388,7527],"source":" For clarification, the C++ terms *base class* and *derived class* are analogous to *superclass* and *subclass* in the Windows object model."},{"content":"C++ derivation with MFC and Windows subclassing are functionally similar, except C++ does not support dynamic subclassing.","pos":[7528,7650]},{"pos":[7657,7790],"content":"The <ph id=\"ph1\">`CWnd`</ph> class provides the connection between a C++ object (derived from <ph id=\"ph2\">`CWnd`</ph>) and a Windows window object (known as an <ph id=\"ph3\">`HWND`</ph>).","source":"The `CWnd` class provides the connection between a C++ object (derived from `CWnd`) and a Windows window object (known as an `HWND`)."},{"content":"There are three common ways these are related:","pos":[7797,7843]},{"content":"creates the <ph id=\"ph1\">`HWND`</ph>.","pos":[7858,7877],"source":" creates the `HWND`."},{"content":"You can modify the behavior in a derived class by creating a class derived from <ph id=\"ph1\">`CWnd`</ph>.","pos":[7878,7965],"source":" You can modify the behavior in a derived class by creating a class derived from `CWnd`."},{"content":"The <ph id=\"ph1\">`HWND`</ph> is created when your application calls <bpt id=\"p1\">[</bpt>CWnd::Create<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__create)</ept>.","pos":[7966,8076],"source":" The `HWND` is created when your application calls [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create)."},{"content":"The application attaches a <ph id=\"ph1\">`CWnd`</ph> to an existing <ph id=\"ph2\">`HWND`</ph>.","pos":[8086,8142],"source":"The application attaches a `CWnd` to an existing `HWND`."},{"content":"The behavior of the existing window is not modified.","pos":[8143,8195]},{"content":"This is a case of delegation and is made possible by calling <bpt id=\"p1\">[</bpt>CWnd::Attach<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__attach)</ept> to alias an existing <ph id=\"ph1\">`HWND`</ph> to a <ph id=\"ph2\">`CWnd`</ph> object.","pos":[8196,8364],"source":" This is a case of delegation and is made possible by calling [CWnd::Attach](../mfc/reference/cwnd-class.md#cwnd__attach) to alias an existing `HWND` to a `CWnd` object."},{"content":"is attached to an existing <ph id=\"ph1\">`HWND`</ph> and you can modify the behavior in a derived class.","pos":[8379,8464],"source":" is attached to an existing `HWND` and you can modify the behavior in a derived class."},{"content":"This is called dynamic subclassing because we are changing the behavior, and therefore the class, of a Windows object at run time.","pos":[8465,8595]},{"pos":[8602,8816],"content":"You can achieve dynamic subclassing by using the methods <bpt id=\"p1\">[</bpt>CWnd::SubclassWindow<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__subclasswindow)</ept> and<bpt id=\"p2\">[</bpt>CWnd::SubclassDlgItem<ept id=\"p2\">](../mfc/reference/cwnd-class.md#cwnd__subclassdlgitem)</ept>.","source":"You can achieve dynamic subclassing by using the methods [CWnd::SubclassWindow](../mfc/reference/cwnd-class.md#cwnd__subclasswindow) and[CWnd::SubclassDlgItem](../mfc/reference/cwnd-class.md#cwnd__subclassdlgitem)."},{"content":"Both routines attach a <ph id=\"ph1\">`CWnd`</ph> object to an existing <ph id=\"ph2\">`HWND`</ph>.","pos":[8823,8882],"source":"Both routines attach a `CWnd` object to an existing `HWND`."},{"content":"takes the <ph id=\"ph1\">`HWND`</ph> directly.","pos":[8900,8926],"source":" takes the `HWND` directly."},{"content":"is a helper function that takes a control ID and the parent window.","pos":[8945,9012]},{"content":"is designed for attaching C++ objects to dialog controls created from a dialog template.","pos":[9031,9119]},{"pos":[9126,9254],"content":"See the <bpt id=\"p1\">[</bpt>CTRLTEST<ept id=\"p1\">](../visual-cpp-samples.md)</ept> example for several examples of when to use <ph id=\"ph1\">`SubclassWindow`</ph> and <ph id=\"ph2\">`SubclassDlgItem`</ph>.","source":"See the [CTRLTEST](../visual-cpp-samples.md) example for several examples of when to use `SubclassWindow` and `SubclassDlgItem`."},{"content":"See Also","pos":[9263,9271]},{"content":"Technical Notes by Number","pos":[9276,9301]},{"content":"Technical Notes by Category","pos":[9345,9372]}],"content":"---\ntitle: \"TN014: Custom Controls | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.controls\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"TN014\"\n  - \"custom controls [MFC]\"\nms.assetid: 1917a498-f643-457c-b570-9a0af7dbf7bb\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN014: Custom Controls\nThis note describes the MFC Support for custom and self-drawing controls. It also describes dynamic subclassing, and describes the relationship between [CWnd](../mfc/reference/cwnd-class.md) objects and `HWND`s.  \n  \n The MFC sample application CTRLTEST illustrates how to use many custom controls. See the source code for the MFC General sample [CTRLTEST](../visual-cpp-samples.md) and online help.  \n  \n## Owner-Draw Controls/Menus  \n Windows provides support for owner-draw controls and menus by using Windows messages. The parent window of any control or menu receives these messages and calls functions in response. You can override these functions to customize the visual appearance and behavior of your owner-draw control or menu.  \n  \n MFC directly supports owner-draw with the following functions:  \n  \n- [CWnd::OnDrawItem](../mfc/reference/cwnd-class.md#cwnd__ondrawitem)  \n  \n- [CWnd::OnMeasureItem](../mfc/reference/cwnd-class.md#cwnd__onmeasureitem)  \n  \n- [CWnd::OnCompareItem](../mfc/reference/cwnd-class.md#cwnd__oncompareitem)  \n  \n- [CWnd::OnDeleteItem](../mfc/reference/cwnd-class.md#cwnd__ondeleteitem)  \n  \n You can override these functions in your `CWnd` derived class to implement custom draw behavior.  \n  \n This approach does not lead to reusable code. If you have two similar controls in two different `CWnd` classes, you must implement the custom control behavior in two locations. The MFC-supported self-drawing control architecture solves this problem.  \n  \n## Self-Draw Controls and Menus  \n MFC provides a default implementation (in the `CWnd` and [CMenu](../mfc/reference/cmenu-class.md) classes) for the standard owner-draw messages. This default implementation will decode the owner-draw parameters and delegate the owner-draw messages to the controls or menu. This is called self-draw because the drawing code is in the class of the control or menu, not in the owner window.  \n  \n By using self-draw controls you can build reusable control classes that use owner-draw semantics to display the control. The code for drawing the control is in the control class, not its parent. This is an object-oriented approach to custom control programming. Add the following list of functions to your self-draw classes:  \n  \n-   For self-draw buttons:  \n  \n ```  \n    CButton:DrawItem(LPDRAWITEMSTRUCT);\n*// insert code to draw this button  \n ```  \n  \n-   For self-draw menus:  \n  \n ```  \n    CMenu:MeasureItem(LPMEASUREITEMSTRUCT);\n*// insert code to measure the size of an item in this menu  \n    CMenu:DrawItem(LPDRAWITEMSTRUCT);\n*// insert code to draw an item in this menu  \n ```  \n  \n-   For self-draw list boxes:  \n  \n ```  \n    CListBox:MeasureItem(LPMEASUREITEMSTRUCT);\n*// insert code to measure the size of an item in this list box  \n    CListBox:DrawItem(LPDRAWITEMSTRUCT);\n*// insert code to draw an item in this list box  \n \n    CListBox:CompareItem(LPCOMPAREITEMSTRUCT);\n*// insert code to compare two items in this list box if LBS_SORT  \n    CListBox:DeleteItem(LPDELETEITEMSTRUCT);\n*// insert code to delete an item from this list box  \n ```  \n  \n-   For self-draw combo boxes:  \n  \n ```  \n    CComboBox:MeasureItem(LPMEASUREITEMSTRUCT);\n*// insert code to measure the size of an item in this combo box  \n    CComboBox:DrawItem(LPDRAWITEMSTRUCT);\n*// insert code to draw an item in this combo box  \n \n    CComboBox:CompareItem(LPCOMPAREITEMSTRUCT);\n*// insert code to compare two items in this combo box if CBS_SORT  \n    CComboBox:DeleteItem(LPDELETEITEMSTRUCT);\n*// insert code to delete an item from this combo box  \n ```  \n  \n For details on the owner-draw structures ([DRAWITEMSTRUCT](../mfc/reference/drawitemstruct-structure.md), [MEASUREITEMSTRUCT](../mfc/reference/measureitemstruct-structure.md), [COMPAREITEMSTRUCT](../mfc/reference/compareitemstruct-structure.md), and [DELETEITEMSTRUCT](../mfc/reference/deleteitemstruct-structure.md)) see the MFC documentation for `CWnd::OnDrawItem`, `CWnd::OnMeasureItem`, `CWnd::OnCompareItem`, and `CWnd::OnDeleteItem` respectively.  \n  \n## Using self-draw controls and menus  \n For self-draw menus, you must override both the `OnMeasureItem` and `OnDrawItem` methods.  \n  \n For self-draw list boxes and combo boxes, you must override `OnMeasureItem` and `OnDrawItem`. You must specify the `LBS_OWNERDRAWVARIABLE` style for list boxes or `CBS_OWNERDRAWVARIABLE` style for combo boxes in the dialog template. The `OWNERDRAWFIXED` style will not work with self-draw items because the fixed item height is determined before self-draw controls are attached to the list box. (You can use the methods [CListBox::SetItemHeight](../mfc/reference/clistbox-class.md#clistbox__setitemheight) and [CComboBox::SetItemHeight](../mfc/reference/ccombobox-class.md#ccombobox__setitemheight) to overcome this limitation.)  \n  \n Switching to an `OWNERDRAWVARIABLE` style will force the system to apply the `NOINTEGRALHEIGHT` style to the control. Because the control cannot calculate an integral height with variable sized items, the default style of `INTEGRALHEIGHT` is ignored and the control is always `NOINTEGRALHEIGHT`. If your items are fixed height, you can prevent partial items from being drawn by specifying the control size to be an integer multiplier of the item size.  \n  \n For self-drawing list boxes and combo boxes with the `LBS_SORT` or `CBS_SORT` style, you must override the `OnCompareItem` method.  \n  \n For self-drawing list boxes and combo boxes, `OnDeleteItem` is not usually overridden. You can override `OnDeleteItem` if you want to perform any special processing. One case where this would be applicable is when additional memory or other resources are stored with each list box or combo box item.  \n  \n## Examples of Self-Drawing Controls and Menus  \n The MFC General sample [CTRLTEST](../visual-cpp-samples.md) provides samples of a self-draw menu and a self-draw list box.  \n  \n The most typical example of a self-drawing button is a bitmap button. A bitmap button is a button that shows one, two, or three bitmap images for the different states. An example of this is provided in the MFC class [CBitmapButton](../mfc/reference/cbitmapbutton-class.md).  \n  \n## Dynamic Subclassing  \n Occasionally you will want to change the functionality of an object that already exists. The previous examples required you to customize the controls before they were created. Dynamic subclassing enables you to customize a control that has already been created.  \n  \n Subclassing is the Windows term for replacing the [WndProc](http://msdn.microsoft.com/en-us/94ba8ffa-3c36-46d4-ac74-9bd10b1ffd26) of a window with a customized `WndProc` and calling the old `WndProc` for default functionality.  \n  \n This should not be confused with C++ class derivation. For clarification, the C++ terms *base class* and *derived class* are analogous to *superclass* and *subclass* in the Windows object model. C++ derivation with MFC and Windows subclassing are functionally similar, except C++ does not support dynamic subclassing.  \n  \n The `CWnd` class provides the connection between a C++ object (derived from `CWnd`) and a Windows window object (known as an `HWND`).  \n  \n There are three common ways these are related:  \n  \n- `CWnd` creates the `HWND`. You can modify the behavior in a derived class by creating a class derived from `CWnd`. The `HWND` is created when your application calls [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create).  \n  \n-   The application attaches a `CWnd` to an existing `HWND`. The behavior of the existing window is not modified. This is a case of delegation and is made possible by calling [CWnd::Attach](../mfc/reference/cwnd-class.md#cwnd__attach) to alias an existing `HWND` to a `CWnd` object.  \n  \n- `CWnd` is attached to an existing `HWND` and you can modify the behavior in a derived class. This is called dynamic subclassing because we are changing the behavior, and therefore the class, of a Windows object at run time.  \n  \n You can achieve dynamic subclassing by using the methods [CWnd::SubclassWindow](../mfc/reference/cwnd-class.md#cwnd__subclasswindow) and[CWnd::SubclassDlgItem](../mfc/reference/cwnd-class.md#cwnd__subclassdlgitem).  \n  \n Both routines attach a `CWnd` object to an existing `HWND`. `SubclassWindow` takes the `HWND` directly. `SubclassDlgItem` is a helper function that takes a control ID and the parent window. `SubclassDlgItem` is designed for attaching C++ objects to dialog controls created from a dialog template.  \n  \n See the [CTRLTEST](../visual-cpp-samples.md) example for several examples of when to use `SubclassWindow` and `SubclassDlgItem`.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}