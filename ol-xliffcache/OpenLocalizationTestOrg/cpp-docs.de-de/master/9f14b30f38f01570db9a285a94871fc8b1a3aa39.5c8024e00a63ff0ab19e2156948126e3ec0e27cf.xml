{"nodes":[{"pos":[12,54],"content":"&lt;complex&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>complex<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,42],"source":"&lt;complex&gt; functions | Microsoft Docs"}]},{"pos":[257,282],"content":"&lt;complex&gt; functions","linkify":"&lt;complex&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>complex<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,25],"source":"&lt;complex&gt; functions"}]},{"pos":[301,312],"content":"<bpt id=\"p1\">[</bpt>abs<ept id=\"p1\">](#abs)</ept>","source":"[abs](#abs)"},{"pos":[313,324],"content":"<bpt id=\"p1\">[</bpt>arg<ept id=\"p1\">](#arg)</ept>","source":"[arg](#arg)"},{"pos":[325,338],"content":"<bpt id=\"p1\">[</bpt>conj<ept id=\"p1\">](#conj)</ept>","source":"[conj](#conj)"},{"pos":[341,352],"content":"<bpt id=\"p1\">[</bpt>cos<ept id=\"p1\">](#cos)</ept>","source":"[cos](#cos)"},{"pos":[353,366],"content":"<bpt id=\"p1\">[</bpt>cosh<ept id=\"p1\">](#cosh)</ept>","source":"[cosh](#cosh)"},{"pos":[367,378],"content":"<bpt id=\"p1\">[</bpt>exp<ept id=\"p1\">](#exp)</ept>","source":"[exp](#exp)"},{"pos":[381,394],"content":"<bpt id=\"p1\">[</bpt>imag<ept id=\"p1\">](#imag)</ept>","source":"[imag](#imag)"},{"pos":[395,406],"content":"<bpt id=\"p1\">[</bpt>log<ept id=\"p1\">](#log)</ept>","source":"[log](#log)"},{"pos":[407,422],"content":"<bpt id=\"p1\">[</bpt>log10<ept id=\"p1\">](#log10)</ept>","source":"[log10](#log10)"},{"pos":[425,438],"content":"<bpt id=\"p1\">[</bpt>norm<ept id=\"p1\">](#norm)</ept>","source":"[norm](#norm)"},{"pos":[439,454],"content":"<bpt id=\"p1\">[</bpt>polar<ept id=\"p1\">](#polar)</ept>","source":"[polar](#polar)"},{"pos":[455,466],"content":"<bpt id=\"p1\">[</bpt>pow<ept id=\"p1\">](#pow)</ept>","source":"[pow](#pow)"},{"pos":[469,482],"content":"<bpt id=\"p1\">[</bpt>real<ept id=\"p1\">](#real)</ept>","source":"[real](#real)"},{"pos":[483,494],"content":"<bpt id=\"p1\">[</bpt>sin<ept id=\"p1\">](#sin)</ept>","source":"[sin](#sin)"},{"pos":[495,508],"content":"<bpt id=\"p1\">[</bpt>sinh<ept id=\"p1\">](#sinh)</ept>","source":"[sinh](#sinh)"},{"pos":[511,524],"content":"<bpt id=\"p1\">[</bpt>sqrt<ept id=\"p1\">](#sqrt)</ept>","source":"[sqrt](#sqrt)"},{"pos":[525,536],"content":"<bpt id=\"p1\">[</bpt>tan<ept id=\"p1\">](#tan)</ept>","source":"[tan](#tan)"},{"pos":[537,550],"content":"<bpt id=\"p1\">[</bpt>tanh<ept id=\"p1\">](#tanh)</ept>","source":"[tanh](#tanh)"},{"pos":[561,584],"content":"<bpt id=\"p1\">&lt;a name=\"abs\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  abs","linkify":"<a name=\"abs\"></a>  abs","source":"<a name=\"abs\"></a>  abs"},{"content":"Calculates the modulus of a complex number.","pos":[588,631]},{"pos":[723,733],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose modulus is to be determined.","pos":[754,807]},{"pos":[817,829],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The modulus of a complex number.","pos":[833,865]},{"pos":[875,882],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">*</bpt>modulus<ept id=\"p1\">*</ept> of a complex number is a measure of the length of the vector representing the complex number.","pos":[886,993],"source":"The *modulus* of a complex number is a measure of the length of the vector representing the complex number."},{"content":"The modulus of a complex number                         a + bi is                         sqrt (a<bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept> + b<bpt id=\"p2\">&lt;sup&gt;</bpt>2<ept id=\"p2\">&lt;/sup&gt;</ept>),  written                         &amp;#124;a + bi&amp;#124;.","pos":[994,1174],"source":" The modulus of a complex number                         a + bi is                         sqrt (a<sup>2</sup> + b<sup>2</sup>),  written                         &#124;a + bi&#124;."},{"content":"The <bpt id=\"p1\">*</bpt>norm<ept id=\"p1\">*</ept> of a complex number                         a + bi is (a<bpt id=\"p2\">&lt;sup&gt;</bpt>2<ept id=\"p2\">&lt;/sup&gt;</ept> + b<bpt id=\"p3\">&lt;sup&gt;</bpt>2<ept id=\"p3\">&lt;/sup&gt;</ept>), so the modulus of a complex number is the square root of its norm.","pos":[1175,1339],"source":" The *norm* of a complex number                         a + bi is (a<sup>2</sup> + b<sup>2</sup>), so the modulus of a complex number is the square root of its norm."},{"pos":[1349,1356],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3830,3853],"content":"<bpt id=\"p1\">&lt;a name=\"arg\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  arg","linkify":"<a name=\"arg\"></a>  arg","source":"<a name=\"arg\"></a>  arg"},{"content":"Extracts the argument from a complex number.","pos":[3857,3901]},{"pos":[3993,4003],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose argument is to be determined.","pos":[4024,4078]},{"pos":[4088,4100],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The argument of the complex number.","pos":[4104,4139]},{"pos":[4149,4156],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The argument is the angle that the complex vector makes with the positive real axis in the complex plane.","pos":[4160,4265]},{"content":"For a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept>, the argument is equal to arctan( <bpt id=\"p2\">*</bpt>b/a<ept id=\"p2\">*</ept>) <bpt id=\"p3\">*</bpt>.<ept id=\"p3\">*</ept>","pos":[4266,4340],"source":" For a complex number *a + bi*, the argument is equal to arctan( *b/a*) *.*"},{"content":"The angle has a positive sense when measured in a counterclockwise direction from the positive real axis and a negative sense when measured in a clockwise direction.","pos":[4341,4506]},{"content":"The principal values are greater than –pi and less than or equal to +pi.","pos":[4507,4579]},{"pos":[4589,4596],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7069,7094],"content":"<bpt id=\"p1\">&lt;a name=\"conj\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  conj","linkify":"<a name=\"conj\"></a>  conj","source":"<a name=\"conj\"></a>  conj"},{"content":"Returns the complex conjugate of a complex number.","pos":[7098,7148]},{"pos":[7250,7260],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose complex conjugate is being returned.","pos":[7281,7342]},{"pos":[7352,7364],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex conjugate of the input complex number.","pos":[7368,7418]},{"pos":[7428,7435],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The complex conjugate of a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept> is <bpt id=\"p2\">*</bpt>a – bi<ept id=\"p2\">*</ept>.","pos":[7439,7502],"source":"The complex conjugate of a complex number *a + bi* is *a – bi*."},{"content":"The product of a complex number and its conjugate is the norm of the number <bpt id=\"p1\">*</bpt>a<ept id=\"p1\">*</ept>2 + <bpt id=\"p2\">*</bpt>b<ept id=\"p2\">*</ept>2.","pos":[7503,7591],"source":" The product of a complex number and its conjugate is the norm of the number *a*2 + *b*2."},{"pos":[7601,7608],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9076,9099],"content":"<bpt id=\"p1\">&lt;a name=\"cos\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  cos","linkify":"<a name=\"cos\"></a>  cos","source":"<a name=\"cos\"></a>  cos"},{"content":"Returns the cosine of a complex number.","pos":[9103,9142]},{"pos":[9243,9253],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose cosine is being determined.","pos":[9274,9326]},{"pos":[9336,9348],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the cosine of the input complex number.","pos":[9352,9418]},{"pos":[9428,9435],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex cosines:","pos":[9439,9479]},{"pos":[9486,9536],"content":"cos ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = (1/2)<ph id=\"ph1\">\\*</ph>( exp ( <bpt id=\"p2\">*</bpt>iz<ept id=\"p2\">*</ept>) + exp (- <bpt id=\"p3\">*</bpt>iz<ept id=\"p3\">*</ept>) )","source":"cos ( *z*) = (1/2)\\*( exp ( *iz*) + exp (- *iz*) )"},{"pos":[9543,9624],"content":"cos ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = cos ( <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept><ph id=\"ph1\"> + </ph><bpt id=\"p3\">*</bpt>bi<ept id=\"p3\">*</ept>) = cos ( <bpt id=\"p4\">*</bpt>a<ept id=\"p4\">*</ept>) cosh ( <bpt id=\"p5\">*</bpt>b<ept id=\"p5\">*</ept>) - isin ( <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>) sinh ( <bpt id=\"p7\">*</bpt>b<ept id=\"p7\">*</ept>)","source":"cos ( *z*) = cos ( *a* + *bi*) = cos ( *a*) cosh ( *b*) - isin ( *a*) sinh ( *b*)"},{"pos":[9634,9641],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11755,11780],"content":"<bpt id=\"p1\">&lt;a name=\"cosh\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  cosh","linkify":"<a name=\"cosh\"></a>  cosh","source":"<a name=\"cosh\"></a>  cosh"},{"content":"Returns the hyperbolic cosine of a complex number.","pos":[11784,11834]},{"pos":[11936,11946],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose hyperbolic cosine is being determined.","pos":[11967,12030]},{"pos":[12040,12052],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the hyperbolic cosine of the input complex number.","pos":[12056,12133]},{"pos":[12143,12150],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex hyperbolic cosines:","pos":[12154,12205]},{"pos":[12212,12260],"content":"cos ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = (1/2)<ph id=\"ph1\">\\*</ph>( exp ( <bpt id=\"p2\">*</bpt>z<ept id=\"p2\">*</ept>) + exp (- <bpt id=\"p3\">*</bpt>z<ept id=\"p3\">*</ept>) )","source":"cos ( *z*) = (1/2)\\*( exp ( *z*) + exp (- *z*) )"},{"pos":[12267,12347],"content":"cos ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = cosh ( <bpt id=\"p2\">*</bpt>a + bi<ept id=\"p2\">*</ept>) = cosh ( <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>) cos ( <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>) + isinh ( <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>) sin ( <bpt id=\"p6\">*</bpt>b<ept id=\"p6\">*</ept>)","source":"cos ( *z*) = cosh ( *a + bi*) = cosh ( *a*) cos ( *b*) + isinh ( *a*) sin ( *b*)"},{"pos":[12357,12364],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14501,14524],"content":"<bpt id=\"p1\">&lt;a name=\"exp\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  exp","linkify":"<a name=\"exp\"></a>  exp","source":"<a name=\"exp\"></a>  exp"},{"content":"Returns the exponential function of a complex number.","pos":[14528,14581]},{"pos":[14682,14692],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose exponential is being determined.","pos":[14713,14770]},{"pos":[14780,14792],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the exponential of the input complex number.","pos":[14796,14867]},{"pos":[14877,14884],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16768,16793],"content":"<bpt id=\"p1\">&lt;a name=\"imag\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  imag","linkify":"<a name=\"imag\"></a>  imag","source":"<a name=\"imag\"></a>  imag"},{"content":"Extracts the imaginary component of a complex number.","pos":[16797,16850]},{"pos":[16943,16953],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose real part is to be extracted.","pos":[16974,17028]},{"pos":[17038,17050],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The imaginary part of the complex number as a global function.","pos":[17054,17116]},{"pos":[17126,17133],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This template function cannot be used to modify the real part of the complex number.","pos":[17137,17221]},{"content":"To change the real part, a new complex number must be assigned the component value.","pos":[17222,17305]},{"pos":[17315,17322],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17974,17997],"content":"<bpt id=\"p1\">&lt;a name=\"log\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  log","linkify":"<a name=\"log\"></a>  log","source":"<a name=\"log\"></a>  log"},{"content":"Returns the natural logarithm of a complex number.","pos":[18001,18051]},{"pos":[18152,18162],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose natural logarithm is being determined.","pos":[18183,18246]},{"pos":[18256,18268],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the natural logarithm of the input complex number.","pos":[18272,18349]},{"pos":[18359,18366],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The branch cuts are along the negative real axis.","pos":[18370,18419]},{"pos":[18429,18436],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20095,20122],"content":"<bpt id=\"p1\">&lt;a name=\"log10\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  log10","linkify":"<a name=\"log10\"></a>  log10","source":"<a name=\"log10\"></a>  log10"},{"content":"Returns the base 10 logarithm of a complex number.","pos":[20126,20176]},{"pos":[20279,20289],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose base 10 logarithm is being determined.","pos":[20310,20373]},{"pos":[20383,20395],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the base 10 logarithm of the input complex number.","pos":[20399,20476]},{"pos":[20486,20493],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The branch cuts are along the negative real axis.","pos":[20497,20546]},{"pos":[20556,20563],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22240,22265],"content":"<bpt id=\"p1\">&lt;a name=\"norm\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  norm","linkify":"<a name=\"norm\"></a>  norm","source":"<a name=\"norm\"></a>  norm"},{"content":"Extracts the norm of a complex number.","pos":[22269,22307]},{"pos":[22400,22410],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose norm is to be determined.","pos":[22431,22481]},{"pos":[22491,22503],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The norm of a complex number.","pos":[22507,22536]},{"pos":[22546,22553],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The norm of a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept> is <bpt id=\"p2\">*</bpt>(a<ept id=\"p2\">*</ept><bpt id=\"p3\">&lt;sup&gt;</bpt>2<ept id=\"p3\">&lt;/sup&gt;</ept> <bpt id=\"p4\">*</bpt>+ b<ept id=\"p4\">*</ept><bpt id=\"p5\">&lt;sup&gt;</bpt>2<ept id=\"p5\">&lt;/sup&gt;</ept><bpt id=\"p6\">*</bpt>).<ept id=\"p6\">*</ept>","pos":[22557,22636],"source":"The norm of a complex number *a + bi* is *(a*<sup>2</sup> *+ b*<sup>2</sup>*).*"},{"content":"The norm of a complex number is the square of its modulus.","pos":[22637,22695]},{"content":"The modulus of a complex number is a measure of the length of the vector representing the complex number.","pos":[22696,22801]},{"content":"The modulus of a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`sqrt`</ph><bpt id=\"p2\">*</bpt>(a<ept id=\"p2\">*</ept><bpt id=\"p3\">&lt;sup&gt;</bpt>2<ept id=\"p3\">&lt;/sup&gt;</ept> <bpt id=\"p4\">*</bpt>+ b<ept id=\"p4\">*</ept><bpt id=\"p5\">&lt;sup&gt;</bpt>2<ept id=\"p5\">&lt;/sup&gt;</ept><bpt id=\"p6\">*</bpt>),<ept id=\"p6\">*</ept> written <bpt id=\"p7\">*</bpt>&amp;#124;a + bi&amp;#124;.<ept id=\"p7\">*</ept>","pos":[22802,22920],"source":" The modulus of a complex number *a + bi* is `sqrt`*(a*<sup>2</sup> *+ b*<sup>2</sup>*),* written *&#124;a + bi&#124;.*"},{"pos":[22930,22937],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25267,25294],"content":"<bpt id=\"p1\">&lt;a name=\"polar\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  polar","linkify":"<a name=\"polar\"></a>  polar","source":"<a name=\"polar\"></a>  polar"},{"content":"Returns the complex number, which corresponds to a specified modulus and argument, in Cartesian form.","pos":[25298,25399]},{"pos":[25518,25528],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>_Modulus<ept id=\"p1\">*</ept>","pos":[25532,25542],"source":"*_Modulus*"},{"content":"The modulus of the complex number being input.","pos":[25546,25592]},{"content":"<bpt id=\"p1\">*</bpt>_Argument<ept id=\"p1\">*</ept>","pos":[25599,25610],"source":"*_Argument*"},{"content":"The argument of the complex number being input.","pos":[25614,25661]},{"pos":[25671,25683],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Cartesian form of the complex number specified in polar form.","pos":[25687,25748]},{"pos":[25758,25765],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25769,26004],"content":"The polar form of a complex number provides the modulus <bpt id=\"p1\">*</bpt>r<ept id=\"p1\">*</ept> and the argument , where these parameters are related to the real and imaginary Cartesian components <bpt id=\"p2\">*</bpt>a<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>b<ept id=\"p3\">*</ept> by the equations <bpt id=\"p4\">*</bpt>a<ept id=\"p4\">*</ept> = r <ph id=\"ph1\">\\*</ph> cos (  ) and b = <bpt id=\"p5\">*</bpt>r<ept id=\"p5\">*</ept> <ph id=\"ph2\">\\*</ph> sin () <bpt id=\"p6\">*</bpt>.<ept id=\"p6\">*</ept>","source":"The polar form of a complex number provides the modulus *r* and the argument , where these parameters are related to the real and imaginary Cartesian components *a* and *b* by the equations *a* = r \\* cos (  ) and b = *r* \\* sin () *.*"},{"pos":[26014,26021],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27893,27916],"content":"<bpt id=\"p1\">&lt;a name=\"pow\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  pow","linkify":"<a name=\"pow\"></a>  pow","source":"<a name=\"pow\"></a>  pow"},{"content":"Evaluates the complex number obtained by raising a base that is a complex number to the power of another complex number.","pos":[27920,28040]},{"pos":[28433,28443],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number or number that is of the parameter type for the complex number that is the base to be raised to a power by the member function.","pos":[28458,28604]},{"content":"<bpt id=\"p1\">*</bpt>_Power<ept id=\"p1\">*</ept>","pos":[28611,28619],"source":"*_Power*"},{"content":"The integer or complex number or number that is of the parameter type for the complex number that is the power that the base is to be raised to by the member function.","pos":[28623,28790]},{"pos":[28800,28812],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number obtained by raising the specified base to the specified power.","pos":[28816,28897]},{"pos":[28907,28914],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[28918,29053],"content":"The functions each effectively convert both operands to the return type, and then return the converted <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept> to the power <bpt id=\"p2\">**</bpt>right<ept id=\"p2\">**</ept>.","source":"The functions each effectively convert both operands to the return type, and then return the converted **left** to the power **right**."},{"content":"The branch cut is along the negative real axis.","pos":[29060,29107]},{"pos":[29117,29124],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[33337,33362],"content":"<bpt id=\"p1\">&lt;a name=\"real\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  real","linkify":"<a name=\"real\"></a>  real","source":"<a name=\"real\"></a>  real"},{"content":"Extracts the real component of a complex number.","pos":[33366,33414]},{"pos":[33507,33517],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose real part is to be extracted.","pos":[33538,33592]},{"pos":[33602,33614],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The real part of the complex number as a global function.","pos":[33618,33675]},{"pos":[33685,33692],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This template function cannot be used to modify the real part of the complex number.","pos":[33696,33780]},{"content":"To change the real part, a new complex number must be assigned the component value.","pos":[33781,33864]},{"pos":[33874,33881],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[34532,34555],"content":"<bpt id=\"p1\">&lt;a name=\"sin\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  sin","linkify":"<a name=\"sin\"></a>  sin","source":"<a name=\"sin\"></a>  sin"},{"content":"Returns the sine of a complex number.","pos":[34559,34596]},{"pos":[34697,34707],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose sine is being determined.","pos":[34728,34778]},{"pos":[34788,34800],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the sine of the input complex number.","pos":[34804,34868]},{"pos":[34878,34885],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex sines:","pos":[34889,34927]},{"pos":[34934,34988],"content":"sin ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = (1/2 <bpt id=\"p2\">*</bpt>i<ept id=\"p2\">*</ept>)<ph id=\"ph1\">\\*</ph>( exp ( <bpt id=\"p3\">*</bpt>iz<ept id=\"p3\">*</ept>) – exp (- <bpt id=\"p4\">*</bpt>iz<ept id=\"p4\">*</ept>) )","source":"sin ( *z*) = (1/2 *i*)\\*( exp ( *iz*) – exp (- *iz*) )"},{"pos":[34995,35074],"content":"sin ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = sin ( <bpt id=\"p2\">*</bpt>a + bi<ept id=\"p2\">*</ept>) = sin ( <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>) cosh ( <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>) + icos ( <bpt id=\"p5\">*</bpt>a<ept id=\"p5\">*</ept>) sinh ( <bpt id=\"p6\">*</bpt>b<ept id=\"p6\">*</ept>)","source":"sin ( *z*) = sin ( *a + bi*) = sin ( *a*) cosh ( *b*) + icos ( *a*) sinh ( *b*)"},{"pos":[35084,35091],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[37213,37238],"content":"<bpt id=\"p1\">&lt;a name=\"sinh\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  sinh","linkify":"<a name=\"sinh\"></a>  sinh","source":"<a name=\"sinh\"></a>  sinh"},{"content":"Returns the hyperbolic sine of a complex number.","pos":[37242,37290]},{"pos":[37392,37402],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose hyperbolic sine is being determined.","pos":[37423,37484]},{"pos":[37494,37506],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the hyperbolic sine of the input complex number.","pos":[37510,37585]},{"pos":[37595,37602],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex hyperbolic sines:","pos":[37606,37655]},{"pos":[37662,37711],"content":"sinh ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = (1/2)<ph id=\"ph1\">\\*</ph>( exp ( <bpt id=\"p2\">*</bpt>z<ept id=\"p2\">*</ept>) – exp (- <bpt id=\"p3\">*</bpt>z<ept id=\"p3\">*</ept>) )","source":"sinh ( *z*) = (1/2)\\*( exp ( *z*) – exp (- *z*) )"},{"pos":[37718,37801],"content":"sinh ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = sinh ( <bpt id=\"p2\">*</bpt>a + bi<ept id=\"p2\">*</ept>) = sinh ( <bpt id=\"p3\">*</bpt>a<ept id=\"p3\">*</ept>) cos ( <bpt id=\"p4\">*</bpt>b<ept id=\"p4\">*</ept>) + <bpt id=\"p5\">*</bpt>i<ept id=\"p5\">*</ept>cosh ( <bpt id=\"p6\">*</bpt>a<ept id=\"p6\">*</ept>) sin ( <bpt id=\"p7\">*</bpt>b<ept id=\"p7\">*</ept>)","source":"sinh ( *z*) = sinh ( *a + bi*) = sinh ( *a*) cos ( *b*) + *i*cosh ( *a*) sin ( *b*)"},{"pos":[37811,37818],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[39964,39989],"content":"<bpt id=\"p1\">&lt;a name=\"sqrt\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  sqrt","linkify":"<a name=\"sqrt\"></a>  sqrt","source":"<a name=\"sqrt\"></a>  sqrt"},{"content":"Calculates the square root of a complex number.","pos":[39993,40040]},{"pos":[40142,40152],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose square root is to be found.","pos":[40173,40225]},{"pos":[40235,40247],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The square root of a complex number.","pos":[40251,40287]},{"pos":[40297,40304],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The square root will have a phase angle in the half-open interval (-pi/2, pi/2].","pos":[40308,40388]},{"content":"The branch cuts in the complex plane are along the negative real axis.","pos":[40395,40465]},{"content":"The square root of a complex number will have a modulus that is the square root of the input number and an argument that is one-half that of the input number.","pos":[40472,40630]},{"pos":[40640,40647],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[42397,42419],"content":"<bpt id=\"p1\">&lt;a name=\"tan\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> tan","linkify":"<a name=\"tan\"></a> tan","source":"<a name=\"tan\"></a> tan"},{"content":"Returns the tangent of a complex number.","pos":[42423,42463]},{"pos":[42564,42574],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose tangent is being determined.","pos":[42595,42648]},{"pos":[42658,42670],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the tangent of the input complex number.","pos":[42674,42741]},{"pos":[42751,42758],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex cotangent:","pos":[42762,42804]},{"pos":[42811,42916],"content":"tan ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = sin ( <bpt id=\"p2\">*</bpt>z<ept id=\"p2\">*</ept>) / cos ( <bpt id=\"p3\">*</bpt>z<ept id=\"p3\">*</ept>) = ( exp ( <bpt id=\"p4\">*</bpt>iz<ept id=\"p4\">*</ept>) – exp (- <bpt id=\"p5\">*</bpt>iz<ept id=\"p5\">*</ept>) ) / <bpt id=\"p6\">*</bpt>i<ept id=\"p6\">*</ept>( exp ( <bpt id=\"p7\">*</bpt>iz<ept id=\"p7\">*</ept>) + exp (- <bpt id=\"p8\">*</bpt>iz<ept id=\"p8\">*</ept>) )","source":"tan ( *z*) = sin ( *z*) / cos ( *z*) = ( exp ( *iz*) – exp (- *iz*) ) / *i*( exp ( *iz*) + exp (- *iz*) )"},{"pos":[42926,42933],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[45072,45097],"content":"<bpt id=\"p1\">&lt;a name=\"tanh\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  tanh","linkify":"<a name=\"tanh\"></a>  tanh","source":"<a name=\"tanh\"></a>  tanh"},{"content":"Returns the hyperbolic tangent of a complex number.","pos":[45101,45152]},{"pos":[45254,45264],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The complex number whose hyperbolic tangent is being determined.","pos":[45285,45349]},{"pos":[45359,45371],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The complex number that is the hyperbolic tangent of the input complex number.","pos":[45375,45453]},{"pos":[45463,45470],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Identities defining the complex hyperbolic cotangent:","pos":[45474,45527]},{"pos":[45534,45635],"content":"tanh ( <bpt id=\"p1\">*</bpt>z<ept id=\"p1\">*</ept>) = sinh ( <bpt id=\"p2\">*</bpt>z<ept id=\"p2\">*</ept>) / cosh ( <bpt id=\"p3\">*</bpt>z<ept id=\"p3\">*</ept>) = ( exp ( <bpt id=\"p4\">*</bpt>z<ept id=\"p4\">*</ept>) – exp (- <bpt id=\"p5\">*</bpt>z<ept id=\"p5\">*</ept>) ) / ( exp ( <bpt id=\"p6\">*</bpt>z<ept id=\"p6\">*</ept>) + exp (- <bpt id=\"p7\">*</bpt>z<ept id=\"p7\">*</ept>) )","source":"tanh ( *z*) = sinh ( *z*) / cosh ( *z*) = ( exp ( *z*) – exp (- *z*) ) / ( exp ( *z*) + exp (- *z*) )"},{"pos":[45645,45652],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[47805,47813],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[47817,47861],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>complex&gt;<ept id=\"p1\">](../standard-library/complex.md)</ept>","source":"[\\<complex>](../standard-library/complex.md)"}],"content":"---\ntitle: \"&lt;complex&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 58b14e94-0e0c-493e-8237-8b4d685904a2\ncaps.latest.revision: 14\nmanager: \"ghogen\"\n---\n# &lt;complex&gt; functions\n||||  \n|-|-|-|  \n|[abs](#abs)|[arg](#arg)|[conj](#conj)|\n|[cos](#cos)|[cosh](#cosh)|[exp](#exp)|\n|[imag](#imag)|[log](#log)|[log10](#log10)|\n|[norm](#norm)|[polar](#polar)|[pow](#pow)|\n|[real](#real)|[sin](#sin)|[sinh](#sinh)|\n|[sqrt](#sqrt)|[tan](#tan)|[tanh](#tanh)|  \n  \n##  <a name=\"abs\"></a>  abs  \n Calculates the modulus of a complex number.  \n  \n```  \ntemplate <class Type>  \nType abs(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose modulus is to be determined.  \n  \n### Return Value  \n The modulus of a complex number.  \n  \n### Remarks  \n The *modulus* of a complex number is a measure of the length of the vector representing the complex number. The modulus of a complex number                         a + bi is                         sqrt (a<sup>2</sup> + b<sup>2</sup>),  written                         &#124;a + bi&#124;. The *norm* of a complex number                         a + bi is (a<sup>2</sup> + b<sup>2</sup>), so the modulus of a complex number is the square root of its norm.  \n  \n### Example  \n  \n```cpp  \n// complex_abs.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Complex numbers can be entered in polar form with  \n   // modulus and argument parameter inputs but are  \n   // stored in Cartesian form as real & imag coordinates  \n   complex <double> c1 ( polar ( 5.0 ) );   // Default argument = 0  \n   complex <double> c2 ( polar ( 5.0 , pi / 6 ) );  \n   complex <double> c3 ( polar ( 5.0 , 13 * pi / 6 ) );  \n   cout << \"c1 = polar ( 5.0 ) = \" << c1 << endl;  \n   cout << \"c2 = polar ( 5.0 , pi / 6 ) = \" << c2 << endl;  \n   cout << \"c3 = polar ( 5.0 , 13 * pi / 6 ) = \" << c3 << endl;  \n  \n   // The modulus and argument of a complex number can be recovered  \n   // using abs & arg member functions  \n   double absc1 = abs ( c1 );  \n   double argc1 = arg ( c1 );  \n   cout << \"The modulus of c1 is recovered from c1 using: abs ( c1 ) = \"  \n        << absc1 << endl;  \n   cout << \"Argument of c1 is recovered from c1 using:\\n arg ( c1 ) = \"  \n        << argc1 << \" radians, which is \" << argc1 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is recovered from c2 using: abs ( c2 ) = \"  \n        << absc2 << endl;  \n   cout << \"Argument of c2 is recovered from c2 using:\\n arg ( c2 ) = \"  \n        << argc2 << \" radians, which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   // Testing if the principal angles of c2 and c3 are the same  \n   if ( (arg ( c2 ) <= ( arg ( c3 ) + .00000001) ) ||   \n        (arg ( c2 ) >= ( arg ( c3 ) - .00000001) ) )  \n      cout << \"The complex numbers c2 & c3 have the \"  \n           << \"same principal arguments.\"<< endl;  \n   else  \n      cout << \"The complex numbers c2 & c3 don't have the \"  \n           << \"same principal arguments.\" << endl;  \n}  \n```  \n  \n```Output  \nc1 = polar ( 5.0 ) = (5,0)  \nc2 = polar ( 5.0 , pi / 6 ) = (4.33013,2.5)  \nc3 = polar ( 5.0 , 13 * pi / 6 ) = (4.33013,2.5)  \nThe modulus of c1 is recovered from c1 using: abs ( c1 ) = 5  \nArgument of c1 is recovered from c1 using:  \n arg ( c1 ) = 0 radians, which is 0 degrees.  \nThe modulus of c2 is recovered from c2 using: abs ( c2 ) = 5  \nArgument of c2 is recovered from c2 using:  \n arg ( c2 ) = 0.523599 radians, which is 30 degrees.  \nThe complex numbers c2 & c3 have the same principal arguments.  \n```  \n  \n##  <a name=\"arg\"></a>  arg  \n Extracts the argument from a complex number.  \n  \n```  \ntemplate <class Type>  \nType arg(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose argument is to be determined.  \n  \n### Return Value  \n The argument of the complex number.  \n  \n### Remarks  \n The argument is the angle that the complex vector makes with the positive real axis in the complex plane. For a complex number *a + bi*, the argument is equal to arctan( *b/a*) *.* The angle has a positive sense when measured in a counterclockwise direction from the positive real axis and a negative sense when measured in a clockwise direction. The principal values are greater than –pi and less than or equal to +pi.  \n  \n### Example  \n  \n```cpp  \n// complex_arg.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Complex numbers can be entered in polar form with  \n   // modulus and argument parameter inputs but are  \n   // stored in Cartesian form as real & imag coordinates  \n   complex <double> c1 ( polar ( 5.0 ) );   // Default argument = 0  \n   complex <double> c2 ( polar ( 5.0 , pi / 6 ) );  \n   complex <double> c3 ( polar ( 5.0 , 13 * pi / 6 ) );  \n   cout << \"c1 = polar ( 5.0 ) = \" << c1 << endl;  \n   cout << \"c2 = polar ( 5.0 , pi / 6 ) = \" << c2 << endl;  \n   cout << \"c3 = polar ( 5.0 , 13 * pi / 6 ) = \" << c3 << endl;  \n  \n   // The modulus and argument of a complex number can be rcovered  \n   // using abs & arg member functions  \n   double absc1 = abs ( c1 );  \n   double argc1 = arg ( c1 );  \n   cout << \"The modulus of c1 is recovered from c1 using: abs ( c1 ) = \"  \n        << absc1 << endl;  \n   cout << \"Argument of c1 is recovered from c1 using:\\n arg ( c1 ) = \"  \n        << argc1 << \" radians, which is \" << argc1 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is recovered from c2 using: abs ( c2 ) = \"  \n        << absc2 << endl;  \n   cout << \"Argument of c2 is recovered from c2 using:\\n arg ( c2 ) = \"  \n        << argc2 << \" radians, which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   // Testing if the principal angles of c2 and c3 are the same  \n   if ( (arg ( c2 ) <= ( arg ( c3 ) + .00000001) ) ||   \n        (arg ( c2 ) >= ( arg ( c3 ) - .00000001) ) )  \n      cout << \"The complex numbers c2 & c3 have the \"  \n           << \"same principal arguments.\"<< endl;  \n   else  \n      cout << \"The complex numbers c2 & c3 don't have the \"  \n           << \"same principal arguments.\" << endl;  \n}  \n```  \n  \n```Output  \nc1 = polar ( 5.0 ) = (5,0)  \nc2 = polar ( 5.0 , pi / 6 ) = (4.33013,2.5)  \nc3 = polar ( 5.0 , 13 * pi / 6 ) = (4.33013,2.5)  \nThe modulus of c1 is recovered from c1 using: abs ( c1 ) = 5  \nArgument of c1 is recovered from c1 using:  \n arg ( c1 ) = 0 radians, which is 0 degrees.  \nThe modulus of c2 is recovered from c2 using: abs ( c2 ) = 5  \nArgument of c2 is recovered from c2 using:  \n arg ( c2 ) = 0.523599 radians, which is 30 degrees.  \nThe complex numbers c2 & c3 have the same principal arguments.  \n```  \n  \n##  <a name=\"conj\"></a>  conj  \n Returns the complex conjugate of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> conj(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose complex conjugate is being returned.  \n  \n### Return Value  \n The complex conjugate of the input complex number.  \n  \n### Remarks  \n The complex conjugate of a complex number *a + bi* is *a – bi*. The product of a complex number and its conjugate is the norm of the number *a*2 + *b*2.  \n  \n### Example  \n  \n```cpp  \n// complex_conj.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   complex <double> c1 ( 4.0 , 3.0 );  \n   cout << \"The complex number c1 = \" << c1 << endl;  \n  \n   double dr1 = real ( c1 );  \n   cout << \"The real part of c1 is real ( c1 ) = \"  \n        << dr1 << \".\" << endl;  \n  \n   double di1 = imag ( c1 );  \n   cout << \"The imaginary part of c1 is imag ( c1 ) = \"  \n        << di1 << \".\" << endl;  \n  \n   complex <double> c2 = conj ( c1 );  \n   cout << \"The complex conjugate of c1 is c2 = conj ( c1 )= \"  \n        << c2 << endl;  \n  \n   double dr2 = real ( c2 );  \n   cout << \"The real part of c2 is real ( c2 ) = \"  \n        << dr2 << \".\" << endl;  \n  \n   double di2 = imag ( c2 );  \n   cout << \"The imaginary part of c2 is imag ( c2 ) = \"  \n        << di2 << \".\" << endl;  \n  \n   // The real part of the product of a complex number  \n   // and its conjugate is the norm of the number  \n   complex <double> c3 = c1 * c2;  \n   cout << \"The norm of (c1 * conj (c1) ) is c1 * c2 = \"  \n        << real( c3 ) << endl;  \n}  \n```  \n  \n```Output  \nThe complex number c1 = (4,3)  \nThe real part of c1 is real ( c1 ) = 4.  \nThe imaginary part of c1 is imag ( c1 ) = 3.  \nThe complex conjugate of c1 is c2 = conj ( c1 )= (4,-3)  \nThe real part of c2 is real ( c2 ) = 4.  \nThe imaginary part of c2 is imag ( c2 ) = -3.  \nThe norm of (c1 * conj (c1) ) is c1 * c2 = 25  \n```  \n  \n##  <a name=\"cos\"></a>  cos  \n Returns the cosine of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> cos(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose cosine is being determined.  \n  \n### Return Value  \n The complex number that is the cosine of the input complex number.  \n  \n### Remarks  \n Identities defining the complex cosines:  \n  \n cos ( *z*) = (1/2)\\*( exp ( *iz*) + exp (- *iz*) )  \n  \n cos ( *z*) = cos ( *a* + *bi*) = cos ( *a*) cosh ( *b*) - isin ( *a*) sinh ( *b*)  \n  \n### Example  \n  \n```cpp  \n// complex_cos.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of cosine of a complex number c1  \n   complex <double> c2 = cos ( c1 );  \n   cout << \"Complex number c2 = cos ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Cosines of the standard angles in the first   \n   // two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar (1.0, pi / 6) );  \n   v1.push_back( cos ( vc1 ) );  \n   complex <double> vc2  ( polar (1.0, pi / 3) );  \n   v1.push_back( cos ( vc2 ) );  \n   complex <double> vc3  ( polar (1.0, pi / 2) );  \n   v1.push_back( cos ( vc3) );  \n   complex <double> vc4  ( polar (1.0, 2 * pi / 3) );  \n   v1.push_back( cos ( vc4 ) );  \n   complex <double> vc5  ( polar (1.0, 5 * pi / 6) );  \n   v1.push_back( cos ( vc5 ) );  \n   complex <double> vc6  ( polar (1.0,  pi ) );  \n   v1.push_back( cos ( vc6 ) );  \n  \n   cout << \"The complex components cos (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = cos ( c1 ) = (-27.0349,-3.85115)  \nThe modulus of c2 is: 27.3079  \nThe argument of c2 is: -3.00009 radians, which is -171.893 degrees.  \n  \nThe complex components cos (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(0.730543,-0.39695)  \n(1.22777,-0.469075)  \n(1.54308,1.21529e-013)  \n(1.22777,0.469075)  \n(0.730543,0.39695)  \n(0.540302,-1.74036e-013)  \n```  \n  \n##  <a name=\"cosh\"></a>  cosh  \n Returns the hyperbolic cosine of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> cosh(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose hyperbolic cosine is being determined.  \n  \n### Return Value  \n The complex number that is the hyperbolic cosine of the input complex number.  \n  \n### Remarks  \n Identities defining the complex hyperbolic cosines:  \n  \n cos ( *z*) = (1/2)\\*( exp ( *z*) + exp (- *z*) )  \n  \n cos ( *z*) = cosh ( *a + bi*) = cosh ( *a*) cos ( *b*) + isinh ( *a*) sin ( *b*)  \n  \n### Example  \n  \n```cpp  \n// complex_cosh.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of cosine of a complex number c1  \n   complex <double> c2 = cosh ( c1 );  \n   cout << \"Complex number c2 = cosh ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Hyperbolic cosines of the standard angles   \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar (1.0, pi / 6) );  \n   v1.push_back( cosh ( vc1 ) );  \n   complex <double> vc2  ( polar (1.0, pi / 3) );  \n   v1.push_back( cosh ( vc2 ) );  \n   complex <double> vc3  ( polar (1.0, pi / 2) );  \n   v1.push_back( cosh ( vc3) );  \n   complex <double> vc4  ( polar (1.0, 2 * pi / 3) );  \n   v1.push_back( cosh ( vc4 ) );  \n   complex <double> vc5  ( polar (1.0, 5 * pi / 6) );  \n   v1.push_back( cosh ( vc5 ) );  \n   complex <double> vc6  ( polar (1.0,  pi ) );  \n   v1.push_back( cosh ( vc6 ) );  \n  \n   cout << \"The complex components cosh (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = cosh ( c1 ) = (-6.58066,-7.58155)  \nThe modulus of c2 is: 10.0392  \nThe argument of c2 is: -2.28564 radians, which is -130.957 degrees.  \n  \nThe complex components cosh (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(1.22777,0.469075)  \n(0.730543,0.39695)  \n(0.540302,-8.70178e-014)  \n(0.730543,-0.39695)  \n(1.22777,-0.469075)  \n(1.54308,2.43059e-013)  \n```  \n  \n##  <a name=\"exp\"></a>  exp  \n Returns the exponential function of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> exp(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose exponential is being determined.  \n  \n### Return Value  \n The complex number that is the exponential of the input complex number.  \n  \n### Example  \n  \n```cpp  \n// complex_exp.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 1 , pi/6 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Value of exponential of a complex number c1:  \n   // note the argument of c2 is determined by the  \n   // imaginary part of c1 & the modulus by the real part  \n   complex <double> c2 = exp ( c1 );  \n   cout << \"Complex number c2 = exp ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Exponentials of the standard angles   \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( 0.0 , -pi );  \n   v1.push_back( exp ( vc1 ) );  \n   complex <double> vc2  ( 0.0, -2 * pi / 3 );  \n   v1.push_back( exp ( vc2 ) );  \n   complex <double> vc3  ( 0.0, 0.0 );  \n   v1.push_back( exp ( vc3 ) );  \n   complex <double> vc4  ( 0.0, pi / 3 );  \n   v1.push_back( exp ( vc4 ) );  \n   complex <double> vc5  ( 0.0 , 2 * pi / 3 );  \n   v1.push_back( exp ( vc5 ) );  \n   complex <double> vc6  ( 0.0, pi );  \n   v1.push_back( exp ( vc6 ) );  \n  \n   cout << \"The complex components exp (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 3 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin() ; Iter1 != v1.end() ; Iter1++ )  \n      cout <<  ( * Iter1 ) << \"\\n     with argument = \"   \n           << ( 180/pi ) * arg ( *Iter1 )   \n           << \" degrees\\n     modulus = \"  \n           << abs ( * Iter1 ) << endl;  \n}  \n```  \n  \n##  <a name=\"imag\"></a>  imag  \n Extracts the imaginary component of a complex number.  \n  \n```  \ntemplate <class Type>  \nType imag(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose real part is to be extracted.  \n  \n### Return Value  \n The imaginary part of the complex number as a global function.  \n  \n### Remarks  \n This template function cannot be used to modify the real part of the complex number. To change the real part, a new complex number must be assigned the component value.  \n  \n### Example  \n  \n```cpp  \n// complexc_imag.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   complex <double> c1 ( 4.0 , 3.0 );  \n   cout << \"The complex number c1 = \" << c1 << endl;  \n  \n   double dr1 = real ( c1 );  \n   cout << \"The real part of c1 is real ( c1 ) = \"  \n        << dr1 << \".\" << endl;  \n  \n   double di1 = imag ( c1 );  \n   cout << \"The imaginary part of c1 is imag ( c1 ) = \"  \n        << di1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe complex number c1 = (4,3)  \nThe real part of c1 is real ( c1 ) = 4.  \nThe imaginary part of c1 is imag ( c1 ) = 3.  \n```  \n  \n##  <a name=\"log\"></a>  log  \n Returns the natural logarithm of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> log(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose natural logarithm is being determined.  \n  \n### Return Value  \n The complex number that is the natural logarithm of the input complex number.  \n  \n### Remarks  \n The branch cuts are along the negative real axis.  \n  \n### Example  \n  \n```cpp  \n// complex_log.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of log of a complex number c1  \n   complex <double> c2 = log ( c1 );  \n   cout << \"Complex number c2 = log ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // log of the standard angles    \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar (1.0, pi / 6) );  \n   v1.push_back( log ( vc1 ) );  \n   complex <double> vc2  ( polar (1.0, pi / 3) );  \n   v1.push_back( log ( vc2 ) );  \n   complex <double> vc3  ( polar (1.0, pi / 2) );  \n   v1.push_back( log ( vc3) );  \n   complex <double> vc4  ( polar (1.0, 2 * pi / 3) );  \n   v1.push_back( log ( vc4 ) );  \n   complex <double> vc5  ( polar (1.0, 5 * pi / 6) );  \n   v1.push_back( log ( vc5 ) );  \n   complex <double> vc6  ( polar (1.0,  pi ) );  \n   v1.push_back( log ( vc6 ) );  \n  \n   cout << \"The complex components log (vci), where abs (vci) = 1 \"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin() ; Iter1 != v1.end() ; Iter1++ )  \n      cout << *Iter1 << \" \" << endl;  \n}  \n```  \n  \n##  <a name=\"log10\"></a>  log10  \n Returns the base 10 logarithm of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> log10(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose base 10 logarithm is being determined.  \n  \n### Return Value  \n The complex number that is the base 10 logarithm of the input complex number.  \n  \n### Remarks  \n The branch cuts are along the negative real axis.  \n  \n### Example  \n  \n```cpp  \n// complex_log10.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of log10 of a complex number c1  \n   complex <double> c2 = log10 ( c1 );  \n   cout << \"Complex number c2 = log10 ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // log10 of the standard angles    \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar (1.0, pi / 6) );  \n   v1.push_back( log10 ( vc1 ) );  \n   complex <double> vc2  ( polar (1.0, pi / 3) );  \n   v1.push_back( log10 ( vc2 ) );  \n   complex <double> vc3  ( polar (1.0, pi / 2) );  \n   v1.push_back( log10 ( vc3) );  \n   complex <double> vc4  ( polar (1.0, 2 * pi / 3) );  \n   v1.push_back( log10 ( vc4 ) );  \n   complex <double> vc5  ( polar (1.0, 5 * pi / 6) );  \n   v1.push_back( log10 ( vc5 ) );  \n   complex <double> vc6  ( polar (1.0,  pi ) );  \n   v1.push_back( log10 ( vc6 ) );  \n  \n   cout << \"The complex components log10 (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n##  <a name=\"norm\"></a>  norm  \n Extracts the norm of a complex number.  \n  \n```  \ntemplate <class Type>  \nType norm(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose norm is to be determined.  \n  \n### Return Value  \n The norm of a complex number.  \n  \n### Remarks  \n The norm of a complex number *a + bi* is *(a*<sup>2</sup> *+ b*<sup>2</sup>*).* The norm of a complex number is the square of its modulus. The modulus of a complex number is a measure of the length of the vector representing the complex number. The modulus of a complex number *a + bi* is `sqrt`*(a*<sup>2</sup> *+ b*<sup>2</sup>*),* written *&#124;a + bi&#124;.*  \n  \n### Example  \n  \n```cpp  \n// complex_norm.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Complex numbers can be entered in polar form with  \n   // modulus and argument parameter inputs but are  \n   // stored in Cartesian form as real & imag coordinates  \n   complex <double> c1 ( polar ( 5.0 ) );   // Default argument = 0  \n   complex <double> c2 ( polar ( 5.0 , pi / 6 ) );  \n   complex <double> c3 ( polar ( 5.0 , 13 * pi / 6 ) );  \n   cout << \"c1 = polar ( 5.0 ) = \" << c1 << endl;  \n   cout << \"c2 = polar ( 5.0 , pi / 6 ) = \" << c2 << endl;  \n   cout << \"c3 = polar ( 5.0 , 13 * pi / 6 ) = \" << c3 << endl;  \n  \n   if ( (arg ( c2 ) <= ( arg ( c3 ) + .00000001) ) ||   \n        (arg ( c2 ) >= ( arg ( c3 ) - .00000001) ) )  \n      cout << \"The complex numbers c2 & c3 have the \"  \n           << \"same principal arguments.\"<< endl;  \n   else  \n      cout << \"The complex numbers c2 & c3 don't have the \"  \n           << \"same principal arguments.\" << endl;  \n  \n   // The modulus and argument of a complex number can be recovered  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is recovered from c2 using: abs ( c2 ) = \"  \n        << absc2 << endl;  \n   cout << \"Argument of c2 is recovered from c2 using:\\n arg ( c2 ) = \"  \n        << argc2 << \" radians, which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   // The norm of a complex number is the square of its modulus  \n   double normc2 = norm ( c2 );  \n   double sqrtnormc2 = sqrt ( normc2 );  \n   cout << \"The norm of c2 given by: norm ( c2 ) = \" << normc2 << endl;  \n   cout << \"The modulus of c2 is the square root of the norm: \"  \n        << \"sqrt ( normc2 ) = \" << sqrtnormc2 << \".\";   \n}  \n```  \n  \n```Output  \nc1 = polar ( 5.0 ) = (5,0)  \nc2 = polar ( 5.0 , pi / 6 ) = (4.33013,2.5)  \nc3 = polar ( 5.0 , 13 * pi / 6 ) = (4.33013,2.5)  \nThe complex numbers c2 & c3 have the same principal arguments.  \nThe modulus of c2 is recovered from c2 using: abs ( c2 ) = 5  \nArgument of c2 is recovered from c2 using:  \n arg ( c2 ) = 0.523599 radians, which is 30 degrees.  \nThe norm of c2 given by: norm ( c2 ) = 25  \nThe modulus of c2 is the square root of the norm: sqrt ( normc2 ) = 5.  \n```  \n  \n##  <a name=\"polar\"></a>  polar  \n Returns the complex number, which corresponds to a specified modulus and argument, in Cartesian form.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> polar(const Type& _Modulus, const Type& _Argument = 0);\n```  \n  \n### Parameters  \n *_Modulus*  \n The modulus of the complex number being input.  \n  \n *_Argument*  \n The argument of the complex number being input.  \n  \n### Return Value  \n Cartesian form of the complex number specified in polar form.  \n  \n### Remarks  \n The polar form of a complex number provides the modulus *r* and the argument , where these parameters are related to the real and imaginary Cartesian components *a* and *b* by the equations *a* = r \\* cos (  ) and b = *r* \\* sin () *.*  \n  \n### Example  \n  \n```cpp  \n// complex_polar.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Complex numbers can be entered in polar form with  \n   // modulus and argument parameter inputs but are  \n   // stored in Cartesian form as real & imag coordinates  \n   complex <double> c1 ( polar ( 5.0 ) );   // Default argument = 0  \n   complex <double> c2 ( polar ( 5.0 , pi / 6 ) );  \n   complex <double> c3 ( polar ( 5.0 , 13 * pi / 6 ) );  \n   cout << \"c1 = polar ( 5.0 ) = \" << c1 << endl;  \n   cout << \"c2 = polar ( 5.0 , pi / 6 ) = \" << c2 << endl;  \n   cout << \"c3 = polar ( 5.0 , 13 * pi / 6 ) = \" << c3 << endl;  \n  \n   if ( (arg ( c2 ) <= ( arg ( c3 ) + .00000001) ) ||   \n        (arg ( c2 ) >= ( arg ( c3 ) - .00000001) ) )  \n      cout << \"The complex numbers c2 & c3 have the \"  \n           << \"same principal arguments.\"<< endl;  \n   else  \n      cout << \"The complex numbers c2 & c3 don't have the \"  \n           << \"same principal arguments.\" << endl;  \n  \n   // the modulus and argument of a complex number can be rcovered  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is recovered from c2 using: abs ( c2 ) = \"  \n        << absc2 << endl;  \n   cout << \"Argument of c2 is recovered from c2 using:\\n arg ( c2 ) = \"  \n        << argc2 << \" radians, which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;   \n}  \n```  \n  \n```Output  \nc1 = polar ( 5.0 ) = (5,0)  \nc2 = polar ( 5.0 , pi / 6 ) = (4.33013,2.5)  \nc3 = polar ( 5.0 , 13 * pi / 6 ) = (4.33013,2.5)  \nThe complex numbers c2 & c3 have the same principal arguments.  \nThe modulus of c2 is recovered from c2 using: abs ( c2 ) = 5  \nArgument of c2 is recovered from c2 using:  \n arg ( c2 ) = 0.523599 radians, which is 30 degrees.  \n```  \n  \n##  <a name=\"pow\"></a>  pow  \n Evaluates the complex number obtained by raising a base that is a complex number to the power of another complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> pow(const complex<Type>& _Base, int _Power);\n\ntemplate <class Type>  \ncomplex<Type> pow(const complex<Type>& _Base, const Type& _Power);\n\ntemplate <class Type>  \ncomplex<Type> pow(const complex<Type>& _Base, const complex<Type>& _Power);\n\ntemplate <class Type>  \ncomplex<Type> pow(const Type& _Base, const complex<Type>& _Power);\n```  \n  \n### Parameters  \n `_Base`  \n The complex number or number that is of the parameter type for the complex number that is the base to be raised to a power by the member function.  \n  \n *_Power*  \n The integer or complex number or number that is of the parameter type for the complex number that is the power that the base is to be raised to by the member function.  \n  \n### Return Value  \n The complex number obtained by raising the specified base to the specified power.  \n  \n### Remarks  \n The functions each effectively convert both operands to the return type, and then return the converted **left** to the power **right**.  \n  \n The branch cut is along the negative real axis.  \n  \n### Example  \n  \n```cpp  \n// complex_pow.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // First member function  \n   // type complex<double> base & type integer power  \n   complex <double> cb1 ( 3 , 4);  \n   int cp1 = 2;  \n   complex <double> ce1 = pow ( cb1 ,cp1 );  \n  \n   cout << \"Complex number for base cb1 = \" << cb1 << endl;  \n   cout << \"Integer for power = \" << cp1 << endl;  \n   cout << \"Complex number returned from complex base and integer power:\"  \n        << \"\\n ce1 = cb1 ^ cp1 = \" << ce1 << endl;  \n   double absce1 = abs ( ce1 );  \n   double argce1 = arg ( ce1 );  \n   cout << \"The modulus of ce1 is: \" << absce1 << endl;  \n   cout << \"The argument of ce1 is: \"<< argce1 << \" radians, which is \"   \n        << argce1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Second member function  \n   // type complex<double> base & type double power  \n   complex <double> cb2 ( 3 , 4 );  \n   double cp2 = pi;  \n   complex <double> ce2 = pow ( cb2 ,cp2 );  \n  \n   cout << \"Complex number for base cb2 = \" << cb2 << endl;  \n   cout << \"Type double for power cp2 = pi = \" << cp2 << endl;  \n   cout << \"Complex number returned from complex base and double power:\"  \n        << \"\\n ce2 = cb2 ^ cp2 = \" << ce2 << endl;  \n   double absce2 = abs ( ce2 );  \n   double argce2 = arg ( ce2 );  \n   cout << \"The modulus of ce2 is: \" << absce2 << endl;  \n   cout << \"The argument of ce2 is: \"<< argce2 << \" radians, which is \"   \n        << argce2 * 180 / pi << \" degrees.\" << endl << endl;  \n  \n   // Third member function  \n   // type complex<double> base & type complex<double> power  \n   complex <double> cb3 ( 3 , 4 );  \n   complex <double> cp3 ( -2 , 1 );  \n   complex <double> ce3 = pow ( cb3 ,cp3 );  \n  \n   cout << \"Complex number for base cb3 = \" << cb3 << endl;  \n   cout << \"Complex number for power cp3= \" << cp3 << endl;  \n   cout << \"Complex number returned from complex base and complex power:\"  \n        << \"\\n ce3 = cb3 ^ cp3 = \" << ce3 << endl;  \n   double absce3 = abs ( ce3 );  \n   double argce3 = arg ( ce3 );  \n   cout << \"The modulus of ce3 is: \" << absce3 << endl;  \n   cout << \"The argument of ce3 is: \"<< argce3 << \" radians, which is \"   \n        << argce3 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Fourth member function  \n   // type double base & type complex<double> power  \n   double cb4 = pi;  \n   complex <double> cp4 ( 2 , -1 );  \n   complex <double> ce4 = pow ( cb4 ,cp4 );  \n  \n   cout << \"Type double for base cb4 = pi = \" << cb4 << endl;  \n   cout << \"Complex number for power cp4 = \" << cp4 << endl;  \n   cout << \"Complex number returned from double base and complex power:\"  \n        << \"\\n ce4 = cb4 ^ cp4 = \" << ce4 << endl;  \n   double absce4 = abs ( ce4 );  \n   double argce4 = arg ( ce4 );  \n   cout << \"The modulus of ce4 is: \" << absce4 << endl;  \n   cout << \"The argument of ce4 is: \"<< argce4 << \" radians, which is \"   \n        << argce4 * 180 / pi << \" degrees.\" << endl << endl;   \n}  \n```  \n  \n```Output  \nComplex number for base cb1 = (3,4)  \nInteger for power = 2  \nComplex number returned from complex base and integer power:  \n ce1 = cb1 ^ cp1 = (-7,24)  \nThe modulus of ce1 is: 25  \nThe argument of ce1 is: 1.85459 radians, which is 106.26 degrees.  \n  \nComplex number for base cb2 = (3,4)  \nType double for power cp2 = pi = 3.14159  \nComplex number returned from complex base and double power:  \n ce2 = cb2 ^ cp2 = (-152.915,35.5475)  \nThe modulus of ce2 is: 156.993  \nThe argument of ce2 is: 2.91318 radians, which is 166.913 degrees.  \n  \nComplex number for base cb3 = (3,4)  \nComplex number for power cp3= (-2,1)  \nComplex number returned from complex base and complex power:  \n ce3 = cb3 ^ cp3 = (0.0153517,-0.00384077)  \nThe modulus of ce3 is: 0.0158249  \nThe argument of ce3 is: -0.245153 radians, which is -14.0462 degrees.  \n  \nType double for base cb4 = pi = 3.14159  \nComplex number for power cp4 = (2,-1)  \nComplex number returned from double base and complex power:  \n ce4 = cb4 ^ cp4 = (4.07903,-8.98725)  \nThe modulus of ce4 is: 9.8696  \nThe argument of ce4 is: -1.14473 radians, which is -65.5882 degrees.  \n```  \n  \n##  <a name=\"real\"></a>  real  \n Extracts the real component of a complex number.  \n  \n```  \ntemplate <class Type>  \nType real(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose real part is to be extracted.  \n  \n### Return Value  \n The real part of the complex number as a global function.  \n  \n### Remarks  \n This template function cannot be used to modify the real part of the complex number. To change the real part, a new complex number must be assigned the component value.  \n  \n### Example  \n  \n```cpp  \n// complex_real.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   complex <double> c1 ( 4.0 , 3.0 );  \n   cout << \"The complex number c1 = \" << c1 << endl;  \n  \n   double dr1 = real ( c1 );  \n   cout << \"The real part of c1 is real ( c1 ) = \"  \n        << dr1 << \".\" << endl;  \n  \n   double di1 = imag ( c1 );  \n   cout << \"The imaginary part of c1 is imag ( c1 ) = \"  \n        << di1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe complex number c1 = (4,3)  \nThe real part of c1 is real ( c1 ) = 4.  \nThe imaginary part of c1 is imag ( c1 ) = 3.  \n```  \n  \n##  <a name=\"sin\"></a>  sin  \n Returns the sine of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> sin(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose sine is being determined.  \n  \n### Return Value  \n The complex number that is the sine of the input complex number.  \n  \n### Remarks  \n Identities defining the complex sines:  \n  \n sin ( *z*) = (1/2 *i*)\\*( exp ( *iz*) – exp (- *iz*) )  \n  \n sin ( *z*) = sin ( *a + bi*) = sin ( *a*) cosh ( *b*) + icos ( *a*) sinh ( *b*)  \n  \n### Example  \n  \n```cpp  \n// complex_sin.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of sine of a complex number c1  \n   complex <double> c2 = sin ( c1 );  \n   cout << \"Complex number c2 = sin ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // sines of the standard angles in the first   \n   // two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar ( 1.0, pi / 6 ) );  \n   v1.push_back( sin ( vc1 ) );  \n   complex <double> vc2  ( polar ( 1.0, pi / 3 ) );  \n   v1.push_back( sin ( vc2 ) );  \n   complex <double> vc3  ( polar ( 1.0, pi / 2 ) );  \n   v1.push_back( sin ( vc3 ) );  \n   complex <double> vc4  ( polar ( 1.0, 2 * pi / 3 ) );  \n   v1.push_back( sin ( vc4 ) );  \n   complex <double> vc5  ( polar ( 1.0, 5 * pi / 6 ) );  \n   v1.push_back( sin ( vc5 ) );  \n   complex <double> vc6  ( polar ( 1.0, pi ) );  \n   v1.push_back( sin ( vc6 ) );  \n  \n   cout << \"The complex components sin (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = sin ( c1 ) = (3.85374,-27.0168)  \nThe modulus of c2 is: 27.2903  \nThe argument of c2 is: -1.42911 radians, which is -81.882 degrees.  \n  \nThe complex components sin (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(0.85898,0.337596)  \n(0.670731,0.858637)  \n(-1.59572e-013,1.1752)  \n(-0.670731,0.858637)  \n(-0.85898,0.337596)  \n(-0.841471,-1.11747e-013)  \n```  \n  \n##  <a name=\"sinh\"></a>  sinh  \n Returns the hyperbolic sine of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> sinh(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose hyperbolic sine is being determined.  \n  \n### Return Value  \n The complex number that is the hyperbolic sine of the input complex number.  \n  \n### Remarks  \n Identities defining the complex hyperbolic sines:  \n  \n sinh ( *z*) = (1/2)\\*( exp ( *z*) – exp (- *z*) )  \n  \n sinh ( *z*) = sinh ( *a + bi*) = sinh ( *a*) cos ( *b*) + *i*cosh ( *a*) sin ( *b*)  \n  \n### Example  \n  \n```cpp  \n// complex_sinh.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of sine of a complex number c1  \n   complex <double> c2 = sinh ( c1 );  \n   cout << \"Complex number c2 = sinh ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Hyperbolic sines of the standard angles in   \n   // the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar ( 1.0, pi / 6 ) );  \n   v1.push_back( sinh ( vc1 ) );  \n   complex <double> vc2  ( polar ( 1.0, pi / 3 ) );  \n   v1.push_back( sinh ( vc2 ) );  \n   complex <double> vc3  ( polar ( 1.0, pi / 2 ) );  \n   v1.push_back( sinh ( vc3) );  \n   complex <double> vc4  ( polar ( 1.0, 2 * pi / 3 ) );  \n   v1.push_back( sinh ( vc4 ) );  \n   complex <double> vc5  ( polar ( 1.0, 5 * pi / 6 ) );  \n   v1.push_back( sinh ( vc5 ) );  \n   complex <double> vc6  ( polar ( 1.0, pi ) );  \n   v1.push_back( sinh ( vc6 ) );  \n  \n   cout << \"The complex components sinh (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = sinh ( c1 ) = (-6.54812,-7.61923)  \nThe modulus of c2 is: 10.0464  \nThe argument of c2 is: -2.28073 radians, which is -130.676 degrees.  \n  \nThe complex components sinh (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(0.858637,0.670731)  \n(0.337596,0.85898)  \n(-5.58735e-014,0.841471)  \n(-0.337596,0.85898)  \n(-0.858637,0.670731)  \n(-1.1752,-3.19145e-013)  \n```  \n  \n##  <a name=\"sqrt\"></a>  sqrt  \n Calculates the square root of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> sqrt(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose square root is to be found.  \n  \n### Return Value  \n The square root of a complex number.  \n  \n### Remarks  \n The square root will have a phase angle in the half-open interval (-pi/2, pi/2].  \n  \n The branch cuts in the complex plane are along the negative real axis.  \n  \n The square root of a complex number will have a modulus that is the square root of the input number and an argument that is one-half that of the input number.  \n  \n### Example  \n  \n```cpp  \n// complex_sqrt.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Complex numbers can be entered in polar form with  \n   // modulus and argument parameter inputs but are  \n   // stored in Cartesian form as real & imag coordinates  \n   complex <double> c1 ( polar ( 25.0 , pi / 2 ) );  \n   complex <double> c2 = sqrt ( c1 );  \n   cout << \"c1 = polar ( 5.0 ) = \" << c1 << endl;  \n   cout << \"c2 = sqrt ( c1 ) = \" << c2 << endl;  \n  \n   // The modulus and argument of a complex number can be recovered  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is recovered from c2 using: abs ( c2 ) = \"  \n        << absc2 << endl;  \n   cout << \"Argument of c2 is recovered from c2 using:\\n arg ( c2 ) = \"  \n        << argc2 << \" radians, which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;  \n  \n   // The modulus and argument of c2 can be directly calculated  \n   absc2 = sqrt( abs ( c1 ) );  \n   argc2 = 0.5 * arg ( c1 );  \n   cout << \"The modulus of c2 = sqrt( abs ( c1 ) ) =\" << absc2 << endl;  \n   cout << \"The argument of c2 = ( 1 / 2 ) * arg ( c1 ) =\"  \n        << argc2 << \" radians,\\n which is \" << argc2 * 180 / pi  \n        << \" degrees.\" << endl;  \n}  \n```  \n  \n```Output  \nc1 = polar ( 5.0 ) = (-2.58529e-012,25)  \nc2 = sqrt ( c1 ) = (3.53553,3.53553)  \nThe modulus of c2 is recovered from c2 using: abs ( c2 ) = 5  \nArgument of c2 is recovered from c2 using:  \n arg ( c2 ) = 0.785398 radians, which is 45 degrees.  \nThe modulus of c2 = sqrt( abs ( c1 ) ) =5  \nThe argument of c2 = ( 1 / 2 ) * arg ( c1 ) =0.785398 radians,  \n which is 45 degrees.  \n```  \n  \n##  <a name=\"tan\"></a> tan  \n Returns the tangent of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> tan(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose tangent is being determined.  \n  \n### Return Value  \n The complex number that is the tangent of the input complex number.  \n  \n### Remarks  \n Identities defining the complex cotangent:  \n  \n tan ( *z*) = sin ( *z*) / cos ( *z*) = ( exp ( *iz*) – exp (- *iz*) ) / *i*( exp ( *iz*) + exp (- *iz*) )  \n  \n### Example  \n  \n```cpp  \n// complex_tan.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of cosine of a complex number c1  \n   complex <double> c2 = tan ( c1 );  \n   cout << \"Complex number c2 = tan ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Hyperbolic tangent of the standard angles   \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar ( 1.0, pi / 6 ) );  \n   v1.push_back( tan ( vc1 ) );  \n   complex <double> vc2  ( polar ( 1.0, pi / 3 ) );  \n   v1.push_back( tan ( vc2 ) );  \n   complex <double> vc3  ( polar ( 1.0, pi / 2 ) );  \n   v1.push_back( tan ( vc3) );  \n   complex <double> vc4  ( polar ( 1.0, 2 * pi / 3 ) );  \n   v1.push_back( tan ( vc4 ) );  \n   complex <double> vc5  ( polar ( 1.0, 5 * pi / 6 ) );  \n   v1.push_back( tan ( vc5 ) );  \n   complex <double> vc6  ( polar ( 1.0,  pi ) );  \n   v1.push_back( tan ( vc6 ) );  \n  \n   cout << \"The complex components tan (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin() ; Iter1 != v1.end() ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = tan ( c1 ) = (-0.000187346,0.999356)  \nThe modulus of c2 is: 0.999356  \nThe argument of c2 is: 1.57098 radians, which is 90.0107 degrees.  \n  \nThe complex components tan (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(0.713931,0.85004)  \n(0.24356,0.792403)  \n(-4.34302e-014,0.761594)  \n(-0.24356,0.792403)  \n(-0.713931,0.85004)  \n(-1.55741,-7.08476e-013)  \n```  \n  \n##  <a name=\"tanh\"></a>  tanh  \n Returns the hyperbolic tangent of a complex number.  \n  \n```  \ntemplate <class Type>  \ncomplex<Type> tanh(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n The complex number whose hyperbolic tangent is being determined.  \n  \n### Return Value  \n The complex number that is the hyperbolic tangent of the input complex number.  \n  \n### Remarks  \n Identities defining the complex hyperbolic cotangent:  \n  \n tanh ( *z*) = sinh ( *z*) / cosh ( *z*) = ( exp ( *z*) – exp (- *z*) ) / ( exp ( *z*) + exp (- *z*) )  \n  \n### Example  \n  \n```cpp  \n// complex_tanh.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n   complex <double> c1 ( 3.0 , 4.0 );  \n   cout << \"Complex number c1 = \" << c1 << endl;  \n  \n   // Values of cosine of a complex number c1  \n   complex <double> c2 = tanh ( c1 );  \n   cout << \"Complex number c2 = tanh ( c1 ) = \" << c2 << endl;  \n   double absc2 = abs ( c2 );  \n   double argc2 = arg ( c2 );  \n   cout << \"The modulus of c2 is: \" << absc2 << endl;  \n   cout << \"The argument of c2 is: \"<< argc2 << \" radians, which is \"   \n        << argc2 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Hyperbolic tangents of the standard angles   \n   // in the first two quadrants of the complex plane  \n   vector <complex <double> > v1;  \n   vector <complex <double> >::iterator Iter1;  \n   complex <double> vc1  ( polar ( 1.0, pi / 6 ) );  \n   v1.push_back( tanh ( vc1 ) );  \n   complex <double> vc2  ( polar ( 1.0, pi / 3 ) );  \n   v1.push_back( tanh ( vc2 ) );  \n   complex <double> vc3  ( polar ( 1.0, pi / 2 ) );  \n   v1.push_back( tanh ( vc3 ) );  \n   complex <double> vc4  ( polar ( 1.0, 2 * pi / 3 ) );  \n   v1.push_back( tanh ( vc4 ) );  \n   complex <double> vc5  ( polar ( 1.0, 5 * pi / 6 ) );  \n   v1.push_back( tanh ( vc5 ) );  \n   complex <double> vc6  ( polar ( 1.0, pi ) );  \n   v1.push_back( tanh ( vc6 ) );  \n  \n   cout << \"The complex components tanh (vci), where abs (vci) = 1\"  \n        << \"\\n& arg (vci) = i * pi / 6 of the vector v1 are:\\n\" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << endl;  \n}  \n```  \n  \n```Output  \nComplex number c1 = (3,4)  \nComplex number c2 = tanh ( c1 ) = (1.00071,0.00490826)  \nThe modulus of c2 is: 1.00072  \nThe argument of c2 is: 0.00490474 radians, which is 0.281021 degrees.  \n  \nThe complex components tanh (vci), where abs (vci) = 1  \n& arg (vci) = i * pi / 6 of the vector v1 are:  \n(0.792403,0.24356)  \n(0.85004,0.713931)  \n(-3.54238e-013,1.55741)  \n(-0.85004,0.713931)  \n(-0.792403,0.24356)  \n(-0.761594,-8.68604e-014)  \n```  \n  \n## See Also  \n [\\<complex>](../standard-library/complex.md)\n\n"}