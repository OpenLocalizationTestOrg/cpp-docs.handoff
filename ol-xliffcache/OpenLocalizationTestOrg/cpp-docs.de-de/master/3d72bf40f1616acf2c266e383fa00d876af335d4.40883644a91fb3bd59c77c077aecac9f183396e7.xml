{"nodes":[{"pos":[12,58],"content":"&lt;type_traits&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>type_traits<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,46],"source":"&lt;type_traits&gt; functions | Microsoft Docs"}]},{"pos":[261,290],"content":"&lt;type_traits&gt; functions","linkify":"&lt;type_traits&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>type_traits<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,29],"source":"&lt;type_traits&gt; functions"}]},{"pos":[309,340],"content":"<bpt id=\"p1\">[</bpt>is_assignable<ept id=\"p1\">](#is_assignable)</ept>","source":"[is_assignable](#is_assignable)"},{"pos":[341,382],"content":"<bpt id=\"p1\">[</bpt>is_copy_assignable<ept id=\"p1\">](#is_copy_assignable)</ept>","source":"[is_copy_assignable](#is_copy_assignable)"},{"pos":[383,430],"content":"<bpt id=\"p1\">[</bpt>is_copy_constructible<ept id=\"p1\">](#is_copy_constructible)</ept>","source":"[is_copy_constructible](#is_copy_constructible)"},{"pos":[435,488],"content":"<bpt id=\"p1\">[</bpt>is_default_constructible<ept id=\"p1\">](#is_default_constructible)</ept>","source":"[is_default_constructible](#is_default_constructible)"},{"pos":[489,530],"content":"<bpt id=\"p1\">[</bpt>is_move_assignable<ept id=\"p1\">](#is_move_assignable)</ept>","source":"[is_move_assignable](#is_move_assignable)"},{"pos":[531,578],"content":"<bpt id=\"p1\">[</bpt>is_move_constructible<ept id=\"p1\">](#is_move_constructible)</ept>","source":"[is_move_constructible](#is_move_constructible)"},{"pos":[583,640],"content":"<bpt id=\"p1\">[</bpt>is_nothrow_move_assignable<ept id=\"p1\">](#is_nothrow_move_assignable)</ept>","source":"[is_nothrow_move_assignable](#is_nothrow_move_assignable)"},{"pos":[641,702],"content":"<bpt id=\"p1\">[</bpt>is_trivially_copy_assignable<ept id=\"p1\">](#is_trivially_copy_assignable)</ept>","source":"[is_trivially_copy_assignable](#is_trivially_copy_assignable)"},{"pos":[703,764],"content":"<bpt id=\"p1\">[</bpt>is_trivially_move_assignable<ept id=\"p1\">](#is_trivially_move_assignable)</ept>","source":"[is_trivially_move_assignable](#is_trivially_move_assignable)"},{"pos":[769,836],"content":"<bpt id=\"p1\">[</bpt>is_trivially_move_constructible<ept id=\"p1\">](#is_trivially_move_constructible)</ept>","source":"[is_trivially_move_constructible](#is_trivially_move_constructible)"},{"pos":[847,890],"content":"<bpt id=\"p1\">&lt;a name=\"is_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_assignable","linkify":"<a name=\"is_assignable\"></a>  is_assignable","source":"<a name=\"is_assignable\"></a>  is_assignable"},{"pos":[894,962],"content":"Tests whether a value of <ph id=\"ph1\">`From`</ph> type can be assigned to a <ph id=\"ph2\">`To`</ph> type.","source":"Tests whether a value of `From` type can be assigned to a `To` type."},{"pos":[1045,1055],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"To","pos":[1059,1061]},{"content":"The type of the object that receives the assignment.","pos":[1065,1117]},{"content":"From","pos":[1124,1128]},{"content":"The type of the object that provides the value.","pos":[1132,1179]},{"pos":[1189,1196],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The unevaluated expression <ph id=\"ph1\">`declval&lt;To&gt;() = declval&lt;From&gt;()`</ph> must be well-formed.","pos":[1200,1281],"source":"The unevaluated expression `declval<To>() = declval<From>()` must be well-formed."},{"content":"Both <ph id=\"ph1\">`From`</ph> and <ph id=\"ph2\">`To`</ph> must be complete types, <ph id=\"ph3\">`void`</ph>, or arrays of unknown bound.","pos":[1282,1362],"source":" Both `From` and `To` must be complete types, `void`, or arrays of unknown bound."},{"pos":[1372,1425],"content":"<bpt id=\"p1\">&lt;a name=\"is_copy_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_copy_assignable","linkify":"<a name=\"is_copy_assignable\"></a>  is_copy_assignable","source":"<a name=\"is_copy_assignable\"></a>  is_copy_assignable"},{"content":"Tests whether type has can be copied on assignment.","pos":[1429,1480]},{"pos":[1556,1566],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[1578,1596]},{"pos":[1606,1613],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a copy assignment operator, otherwise it holds false.","pos":[1617,1752],"source":"An instance of the type predicate holds true if the type `Ty` is a class that has a copy assignment operator, otherwise it holds false."},{"content":"Equivalent to is_assignable<ph id=\"ph1\">\\&lt;</ph>Ty&amp;, const Ty&amp;&gt;.","pos":[1753,1798],"source":" Equivalent to is_assignable\\<Ty&, const Ty&>."},{"pos":[1808,1867],"content":"<bpt id=\"p1\">&lt;a name=\"is_copy_constructible\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_copy_constructible","linkify":"<a name=\"is_copy_constructible\"></a>  is_copy_constructible","source":"<a name=\"is_copy_constructible\"></a>  is_copy_constructible"},{"content":"Tests if type has a copy constructor.","pos":[1871,1908]},{"pos":[1987,1997],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[2009,2027]},{"pos":[2037,2044],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2048,2175],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a copy constructor, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a copy constructor, otherwise it holds false."},{"pos":[2185,2192],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2867,2932],"content":"<bpt id=\"p1\">&lt;a name=\"is_default_constructible\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_default_constructible","linkify":"<a name=\"is_default_constructible\"></a>  is_default_constructible","source":"<a name=\"is_default_constructible\"></a>  is_default_constructible"},{"content":"Tests if a type has a default constructor.","pos":[2936,2978]},{"pos":[3060,3070],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[3081,3099]},{"pos":[3109,3116],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`T`</ph> is a class type that has a default constructor, otherwise it holds false.","pos":[3120,3254],"source":"An instance of the type predicate holds true if the type `T` is a class type that has a default constructor, otherwise it holds false."},{"content":"This is equivalent to the predicate <ph id=\"ph1\">`is_constructible&lt;T&gt;`</ph>.","pos":[3255,3313],"source":" This is equivalent to the predicate `is_constructible<T>`."},{"content":"Type <ph id=\"ph1\">`T`</ph> must be a complete type, <ph id=\"ph2\">`void`</ph>, or an array of unknown bound.","pos":[3314,3385],"source":" Type `T` must be a complete type, `void`, or an array of unknown bound."},{"pos":[3395,3402],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4084,4137],"content":"<bpt id=\"p1\">&lt;a name=\"is_move_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_move_assignable","linkify":"<a name=\"is_move_assignable\"></a>  is_move_assignable","source":"<a name=\"is_move_assignable\"></a>  is_move_assignable"},{"content":"Tests if the type can be move assigned.","pos":[4141,4180]},{"pos":[4255,4265],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[4276,4294]},{"pos":[4304,4311],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A type is move assignable if an rvalue reference to the type can be assigned to a reference to the type.","pos":[4315,4419]},{"content":"The type predicate is equivalent to <ph id=\"ph1\">`is_assignable&lt;T&amp;, T&amp;&amp;&gt;`</ph>.","pos":[4420,4481],"source":" The type predicate is equivalent to `is_assignable<T&, T&&>`."},{"content":"Move assignable types include referenceable scalar types and class types that have either compiler-generated or user-defined move assignment operators.","pos":[4482,4633]},{"pos":[4643,4702],"content":"<bpt id=\"p1\">&lt;a name=\"is_move_constructible\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_move_constructible","linkify":"<a name=\"is_move_constructible\"></a>  is_move_constructible","source":"<a name=\"is_move_constructible\"></a>  is_move_constructible"},{"content":"Tests whether the type has a move constructor.","pos":[4706,4752]},{"pos":[4830,4840],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"T","pos":[4844,4845]},{"content":"The type to be evaluated","pos":[4849,4873]},{"pos":[4883,4890],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A type predicate that evaluates to true if the type <ph id=\"ph1\">`T`</ph> can be constructed by using a move operation.","pos":[4894,4995],"source":"A type predicate that evaluates to true if the type `T` can be constructed by using a move operation."},{"content":"This predicate is equivalent to <ph id=\"ph1\">`is_constructible&lt;T, T&amp;&amp;&gt;`</ph>.","pos":[4996,5055],"source":" This predicate is equivalent to `is_constructible<T, T&&>`."},{"pos":[5065,5134],"content":"<bpt id=\"p1\">&lt;a name=\"is_nothrow_move_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_nothrow_move_assignable","linkify":"<a name=\"is_nothrow_move_assignable\"></a>  is_nothrow_move_assignable","source":"<a name=\"is_nothrow_move_assignable\"></a>  is_nothrow_move_assignable"},{"pos":[5138,5200],"content":"Tests whether type has a <bpt id=\"p1\">**</bpt>nothrow<ept id=\"p1\">**</ept> move assignment operator.","source":"Tests whether type has a **nothrow** move assignment operator."},{"pos":[5284,5294],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[5306,5324]},{"pos":[5334,5341],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5345,5472],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> has a nothrow move assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` has a nothrow move assignment operator, otherwise it holds false."},{"pos":[5482,5555],"content":"<bpt id=\"p1\">&lt;a name=\"is_trivially_copy_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_trivially_copy_assignable","linkify":"<a name=\"is_trivially_copy_assignable\"></a>  is_trivially_copy_assignable","source":"<a name=\"is_trivially_copy_assignable\"></a>  is_trivially_copy_assignable"},{"content":"Tests whether the type has a trivial copy assignment operator.","pos":[5559,5621]},{"pos":[5707,5717],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[5728,5746]},{"pos":[5756,5763],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5767,5909],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`T`</ph> is a class that has a trivial copy assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `T` is a class that has a trivial copy assignment operator, otherwise it holds false."},{"pos":[5916,6279],"content":"An assignment constructor for a class <ph id=\"ph1\">`T`</ph> is trivial if it is implicitly provided, the class <ph id=\"ph2\">`T`</ph> has no virtual functions, the class <ph id=\"ph3\">`T`</ph> has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators.","source":"An assignment constructor for a class `T` is trivial if it is implicitly provided, the class `T` has no virtual functions, the class `T` has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators."},{"pos":[6289,6362],"content":"<bpt id=\"p1\">&lt;a name=\"is_trivially_move_assignable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_trivially_move_assignable","linkify":"<a name=\"is_trivially_move_assignable\"></a>  is_trivially_move_assignable","source":"<a name=\"is_trivially_move_assignable\"></a>  is_trivially_move_assignable"},{"content":"Tests whether the type has a trivial move assignment operator.","pos":[6366,6428]},{"pos":[6514,6524],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[6536,6554]},{"pos":[6564,6571],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6575,6718],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a trivial move assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move assignment operator, otherwise it holds false."},{"pos":[6725,6783],"content":"A move assignment operator for a class <ph id=\"ph1\">`Ty`</ph> is trivial if:","source":"A move assignment operator for a class `Ty` is trivial if:"},{"content":"it is implicitly provided","pos":[6790,6815]},{"pos":[6822,6861],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual functions","source":"the class `Ty` has no virtual functions"},{"pos":[6868,6903],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual bases","source":"the class `Ty` has no virtual bases"},{"content":"the classes of all the non-static data members of class type have trivial move assignment operators","pos":[6910,7009]},{"content":"the classes of all the non-static data members of type array of class have trivial move assignment operators","pos":[7016,7124]},{"pos":[7134,7213],"content":"<bpt id=\"p1\">&lt;a name=\"is_trivially_move_constructible\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  is_trivially_move_constructible","linkify":"<a name=\"is_trivially_move_constructible\"></a>  is_trivially_move_constructible","source":"<a name=\"is_trivially_move_constructible\"></a>  is_trivially_move_constructible"},{"content":"Tests if type has trivial move constructor.","pos":[7217,7260]},{"pos":[7349,7359],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type to query.","pos":[7371,7389]},{"pos":[7399,7406],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7410,7545],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a trivial move constructor, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move constructor, otherwise it holds false."},{"pos":[7552,7602],"content":"A move constructor for a class <ph id=\"ph1\">`Ty`</ph> is trivial if:","source":"A move constructor for a class `Ty` is trivial if:"},{"content":"it is implicitly declared","pos":[7609,7634]},{"content":"its parameter types are equivalent to those of an implicit declaration","pos":[7641,7711]},{"pos":[7718,7757],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual functions","source":"the class `Ty` has no virtual functions"},{"pos":[7764,7799],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual bases","source":"the class `Ty` has no virtual bases"},{"content":"the class has no volatile non-static data members","pos":[7806,7855]},{"pos":[7862,7931],"content":"all the direct bases of the class <ph id=\"ph1\">`Ty`</ph> have trivial move constructors","source":"all the direct bases of the class `Ty` have trivial move constructors"},{"content":"the classes of all the non-static data members of class type have trivial move constructors","pos":[7938,8029]},{"content":"the classes of all the non-static data members of type array of class have trivial move constructors","pos":[8036,8136]},{"pos":[8145,8153],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[8157,8208],"content":"<bpt id=\"p1\">[</bpt>&lt;type_traits&gt;<ept id=\"p1\">](../standard-library/type-traits.md)</ept>","source":"[<type_traits>](../standard-library/type-traits.md)"}],"content":"---\ntitle: \"&lt;type_traits&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: dce4492f-f3e4-4d5e-bdb4-5875321254ec\ncaps.latest.revision: 13\nmanager: \"ghogen\"\n---\n# &lt;type_traits&gt; functions\n||||  \n|-|-|-|  \n|[is_assignable](#is_assignable)|[is_copy_assignable](#is_copy_assignable)|[is_copy_constructible](#is_copy_constructible)|  \n|[is_default_constructible](#is_default_constructible)|[is_move_assignable](#is_move_assignable)|[is_move_constructible](#is_move_constructible)|  \n|[is_nothrow_move_assignable](#is_nothrow_move_assignable)|[is_trivially_copy_assignable](#is_trivially_copy_assignable)|[is_trivially_move_assignable](#is_trivially_move_assignable)|  \n|[is_trivially_move_constructible](#is_trivially_move_constructible)|  \n  \n##  <a name=\"is_assignable\"></a>  is_assignable  \n Tests whether a value of `From` type can be assigned to a `To` type.  \n  \n```  \ntemplate <class To, class From>  \nstruct is_assignable;  \n```  \n  \n### Parameters  \n To  \n The type of the object that receives the assignment.  \n  \n From  \n The type of the object that provides the value.  \n  \n### Remarks  \n The unevaluated expression `declval<To>() = declval<From>()` must be well-formed. Both `From` and `To` must be complete types, `void`, or arrays of unknown bound.  \n  \n##  <a name=\"is_copy_assignable\"></a>  is_copy_assignable  \n Tests whether type has can be copied on assignment.  \n  \n```  \ntemplate <class Ty>  \nstruct is_copy_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a copy assignment operator, otherwise it holds false. Equivalent to is_assignable\\<Ty&, const Ty&>.  \n  \n##  <a name=\"is_copy_constructible\"></a>  is_copy_constructible  \n Tests if type has a copy constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_copy_constructible;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a copy constructor, otherwise it holds false.  \n  \n### Example  \n  \n```cpp  \n#include <type_traits>   \n#include <iostream>   \n  \nstruct Copyable  \n{  \n    int val;  \n};  \n  \nstruct NotCopyable  \n{  \n   NotCopyable(const NotCopyable&) = delete;  \n   int val;  \n  \n};  \n  \nint main()  \n{  \n    std::cout << \"is_copy_constructible<Copyable> == \" << std::boolalpha  \n        << std::is_copy_constructible<Copyable>::value << std::endl;  \n    std::cout << \"is_copy_constructible<NotCopyable> == \" << std::boolalpha  \n        << std::is_copy_constructible<NotCopyable>::value << std::endl;  \n  \n    return (0);  \n}  \n  \n```  \n  \n```Output  \nis_copy_constructible<Copyable> == true  \nis_copy_constructible<NotCopyable > == false  \n```  \n  \n##  <a name=\"is_default_constructible\"></a>  is_default_constructible  \n Tests if a type has a default constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_default_constructible;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `T` is a class type that has a default constructor, otherwise it holds false. This is equivalent to the predicate `is_constructible<T>`. Type `T` must be a complete type, `void`, or an array of unknown bound.  \n  \n### Example  \n  \n```cpp  \n  \n#include <type_traits>   \n#include <iostream>   \n  \nstruct Simple  \n{  \n    Simple() : val(0) {}  \n    int val;  \n};  \n  \nstruct Simple2  \n{  \n    Simple2(int v) : val(v) {}  \n    int val;  \n};  \n  \nint main()  \n{  \n    std::cout << \"is_default_constructible<Simple> == \" << std::boolalpha  \n        << std::is_default_constructible<Simple>::value << std::endl;  \n    std::cout << \"is_default_constructible<Simple2> == \" << std::boolalpha  \n        << std::is_default_constructible<Simple2>::value << std::endl;  \n  \n    return (0);  \n}  \n  \n```  \n  \n```Output  \nis_default_constructible<Simple> == true  \nis_default_constructible<Simple2> == false  \n```  \n  \n##  <a name=\"is_move_assignable\"></a>  is_move_assignable  \n Tests if the type can be move assigned.  \n  \n```  \ntemplate <class T>  \nstruct is_move_assignable;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n A type is move assignable if an rvalue reference to the type can be assigned to a reference to the type. The type predicate is equivalent to `is_assignable<T&, T&&>`. Move assignable types include referenceable scalar types and class types that have either compiler-generated or user-defined move assignment operators.  \n  \n##  <a name=\"is_move_constructible\"></a>  is_move_constructible  \n Tests whether the type has a move constructor.  \n  \n```  \ntemplate <class T>  \nstruct is_move_constructible;  \n```  \n  \n### Parameters  \n T  \n The type to be evaluated  \n  \n### Remarks  \n A type predicate that evaluates to true if the type `T` can be constructed by using a move operation. This predicate is equivalent to `is_constructible<T, T&&>`.  \n  \n##  <a name=\"is_nothrow_move_assignable\"></a>  is_nothrow_move_assignable  \n Tests whether type has a **nothrow** move assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_nothrow_move_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` has a nothrow move assignment operator, otherwise it holds false.  \n  \n##  <a name=\"is_trivially_copy_assignable\"></a>  is_trivially_copy_assignable  \n Tests whether the type has a trivial copy assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_copy_assignable;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `T` is a class that has a trivial copy assignment operator, otherwise it holds false.  \n  \n An assignment constructor for a class `T` is trivial if it is implicitly provided, the class `T` has no virtual functions, the class `T` has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators.  \n  \n##  <a name=\"is_trivially_move_assignable\"></a>  is_trivially_move_assignable  \n Tests whether the type has a trivial move assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_move_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move assignment operator, otherwise it holds false.  \n  \n A move assignment operator for a class `Ty` is trivial if:  \n  \n it is implicitly provided  \n  \n the class `Ty` has no virtual functions  \n  \n the class `Ty` has no virtual bases  \n  \n the classes of all the non-static data members of class type have trivial move assignment operators  \n  \n the classes of all the non-static data members of type array of class have trivial move assignment operators  \n  \n##  <a name=\"is_trivially_move_constructible\"></a>  is_trivially_move_constructible  \n Tests if type has trivial move constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_move_constructible;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move constructor, otherwise it holds false.  \n  \n A move constructor for a class `Ty` is trivial if:  \n  \n it is implicitly declared  \n  \n its parameter types are equivalent to those of an implicit declaration  \n  \n the class `Ty` has no virtual functions  \n  \n the class `Ty` has no virtual bases  \n  \n the class has no volatile non-static data members  \n  \n all the direct bases of the class `Ty` have trivial move constructors  \n  \n the classes of all the non-static data members of class type have trivial move constructors  \n  \n the classes of all the non-static data members of type array of class have trivial move constructors  \n  \n## See Also  \n [<type_traits>](../standard-library/type-traits.md)\n\n"}