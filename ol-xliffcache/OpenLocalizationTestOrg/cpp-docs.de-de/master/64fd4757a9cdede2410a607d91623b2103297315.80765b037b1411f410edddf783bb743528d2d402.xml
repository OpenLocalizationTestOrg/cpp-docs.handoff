{"nodes":[{"pos":[12,66],"content":"Regular DLLs Statically Linked to MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Regular DLLs Statically Linked to MFC | Microsoft Docs","pos":[0,54]}]},{"content":"Regular DLLs Statically Linked to MFC","pos":[759,796]},{"content":"A regular DLL statically linked to MFC is a DLL that uses MFC internally, and the exported functions in the DLL can be called by either MFC or non-MFC executables.","pos":[797,960]},{"content":"As the name describes, this kind of DLL is built using the static link library version of MFC.","pos":[961,1055]},{"content":"Functions are usually exported from a regular DLL using the standard C interface.","pos":[1056,1137]},{"content":"For an example of how to write, build, and use a regular DLL, see the sample <bpt id=\"p1\">[</bpt>DLLScreenCap<ept id=\"p1\">](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a)</ept>.","pos":[1138,1300],"source":" For an example of how to write, build, and use a regular DLL, see the sample [DLLScreenCap](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a)."},{"content":"Note that the term USRDLL is no longer used in the Visual C++ documentation.","pos":[1307,1383]},{"content":"A regular DLL that is statically linked to MFC has the same characteristics as the former USRDLL.","pos":[1384,1481]},{"content":"A regular DLL, statically linked to MFC, has the following features:","pos":[1488,1556]},{"content":"The client executable can be written in any language that supports the use of DLLs (C, C++, Pascal, Visual Basic, and so on); it does not have to be an MFC application.","pos":[1566,1734]},{"content":"The DLL can link to the same MFC static link libraries used by applications.","pos":[1744,1820]},{"content":"There is no longer a separate version of the static link libraries for DLLs.","pos":[1821,1897]},{"content":"Before version 4.0 of MFC, USRDLLs provided the same type of functionality as regular DLLs statically linked to MFC.","pos":[1907,2023]},{"content":"As of Visual C++ version 4.0, the term USRDLL is obsolete.","pos":[2024,2082]},{"content":"A regular DLL, statically linked to MFC, has the following requirements:","pos":[2089,2161]},{"pos":[2171,2236],"content":"This type of DLL must instantiate a class derived from <ph id=\"ph1\">`CWinApp`</ph>.","source":"This type of DLL must instantiate a class derived from `CWinApp`."},{"content":"This type of DLL uses the <ph id=\"ph1\">`DllMain`</ph> provided by MFC.","pos":[2246,2298],"source":"This type of DLL uses the `DllMain` provided by MFC."},{"content":"Place all DLL-specific initialization code in the <ph id=\"ph1\">`InitInstance`</ph> member function and termination code in <ph id=\"ph2\">`ExitInstance`</ph> as in a normal MFC application.","pos":[2299,2450],"source":" Place all DLL-specific initialization code in the `InitInstance` member function and termination code in `ExitInstance` as in a normal MFC application."},{"content":"Even though the term USRDLL is obsolete, you must still define \"<bpt id=\"p1\">**</bpt>_USRDLL<ept id=\"p1\">**</ept>\" on the compiler command line.","pos":[2460,2566],"source":"Even though the term USRDLL is obsolete, you must still define \"**_USRDLL**\" on the compiler command line."},{"content":"This definition determines which declarations is pulled in from the MFC header files.","pos":[2567,2652]},{"content":"Regular DLLs must have a <ph id=\"ph1\">`CWinApp`</ph>-derived class and a single object of that application class, as does an MFC application.","pos":[2659,2782],"source":"Regular DLLs must have a `CWinApp`-derived class and a single object of that application class, as does an MFC application."},{"content":"However, the <ph id=\"ph1\">`CWinApp`</ph> object of the DLL does not have a main message pump, as does the <ph id=\"ph2\">`CWinApp`</ph> object of an application.","pos":[2783,2906],"source":" However, the `CWinApp` object of the DLL does not have a main message pump, as does the `CWinApp` object of an application."},{"content":"Note that the <ph id=\"ph1\">`CWinApp::Run`</ph> mechanism does not apply to a DLL, because the application owns the main message pump.","pos":[2913,3028],"source":"Note that the `CWinApp::Run` mechanism does not apply to a DLL, because the application owns the main message pump."},{"content":"If the DLL opens modeless dialogs or has a main frame window of its own, the application's main message pump must call a routine exported by the DLL that in turn calls the <ph id=\"ph1\">`CWinApp::PreTranslateMessage`</ph> member function of the DLL's application object.","pos":[3029,3280],"source":" If the DLL opens modeless dialogs or has a main frame window of its own, the application's main message pump must call a routine exported by the DLL that in turn calls the `CWinApp::PreTranslateMessage` member function of the DLL's application object."},{"content":"For an example of this function, see the DLLScreenCap sample.","pos":[3287,3348]},{"content":"Symbols are usually exported from a regular DLL using the standard C interface.","pos":[3355,3434]},{"content":"The declaration of a function exported from a regular DLL would look something like this:","pos":[3435,3524]},{"content":"All memory allocations within a regular DLL should stay within the DLL; the DLL should not pass to or receive from the calling executable any of the following:","pos":[3604,3763]},{"content":"Pointers to MFC objects","pos":[3773,3796]},{"content":"Pointers to memory allocated by MFC","pos":[3806,3841]},{"content":"If you need to do any of the above or need to pass MFC-derived objects between the calling executable and the DLL, you must build an extension DLL.","pos":[3848,3995]},{"content":"It is safe to pass pointers to memory that were allocated by the C run-time libraries between an application and a DLL only if you make a copy of the data.","pos":[4002,4157]},{"content":"You must not delete or resize these pointers or use them without making a copy of the memory.","pos":[4158,4251]},{"content":"A DLL that is statically linked to MFC cannot also dynamically link to the shared MFC DLLs.","pos":[4258,4349]},{"content":"A DLL that is statically linked to MFC is dynamically bound to an application just like any other DLL; applications link to it just like any other DLL.","pos":[4350,4501]},{"content":"The standard MFC static link libraries are named according to the convention described in <bpt id=\"p1\">[</bpt>Naming Conventions for MFC DLLs<ept id=\"p1\">](../build/naming-conventions-for-mfc-dlls.md)</ept>.","pos":[4508,4677],"source":"The standard MFC static link libraries are named according to the convention described in [Naming Conventions for MFC DLLs](../build/naming-conventions-for-mfc-dlls.md)."},{"content":"However, with MFC version 3.0 and later, it is no longer necessary to manually specify to the linker the version of the MFC library you want linked in.","pos":[4678,4829]},{"content":"Instead, the MFC header files automatically determine the correct version of the MFC library to link in based on preprocessor defines, such as <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>_UNICODE<ept id=\"p2\">**</ept>.","pos":[4830,5000],"source":" Instead, the MFC header files automatically determine the correct version of the MFC library to link in based on preprocessor defines, such as **_DEBUG** or **_UNICODE**."},{"content":"The MFC header files add /DEFAULTLIB directives instructing the linker to link in a specific version of the MFC library.","pos":[5001,5121]},{"content":"What do you want to do?","pos":[5130,5153]},{"content":"Initialize regular DLLs","pos":[5164,5187]},{"content":"What do you want to know more about?","pos":[5236,5272]},{"content":"Using MFC as Part of a DLL","pos":[5283,5309]},{"content":"Using Database, OLE, and Sockets Extension DLLs in Regular DLLs","pos":[5365,5428]},{"content":"Creating an MFC DLL","pos":[5515,5534]},{"content":"Regular DLLs Dynamically Linked to MFC","pos":[5582,5620]},{"content":"Extension DLLs","pos":[5684,5698]},{"content":"See Also","pos":[5745,5753]},{"content":"Kinds of DLLs","pos":[5758,5771]}],"content":"---\ntitle: \"Regular DLLs Statically Linked to MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regular DLLs [C++]\"\n  - \"DLLs [C++], regular\"\n  - \"USRDLLs\"\n  - \"USRDLLs, statically linked to MFC\"\n  - \"statically linked DLLs [C++]\"\n  - \"regular DLLs [C++], statically linked to MFC\"\nms.assetid: 2eed531c-726a-4b8a-b936-f721dc00a7fa\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Regular DLLs Statically Linked to MFC\nA regular DLL statically linked to MFC is a DLL that uses MFC internally, and the exported functions in the DLL can be called by either MFC or non-MFC executables. As the name describes, this kind of DLL is built using the static link library version of MFC. Functions are usually exported from a regular DLL using the standard C interface. For an example of how to write, build, and use a regular DLL, see the sample [DLLScreenCap](http://msdn.microsoft.com/en-us/2171291d-3a50-403b-90a1-d93c2acb4f4a).  \n  \n Note that the term USRDLL is no longer used in the Visual C++ documentation. A regular DLL that is statically linked to MFC has the same characteristics as the former USRDLL.  \n  \n A regular DLL, statically linked to MFC, has the following features:  \n  \n-   The client executable can be written in any language that supports the use of DLLs (C, C++, Pascal, Visual Basic, and so on); it does not have to be an MFC application.  \n  \n-   The DLL can link to the same MFC static link libraries used by applications. There is no longer a separate version of the static link libraries for DLLs.  \n  \n-   Before version 4.0 of MFC, USRDLLs provided the same type of functionality as regular DLLs statically linked to MFC. As of Visual C++ version 4.0, the term USRDLL is obsolete.  \n  \n A regular DLL, statically linked to MFC, has the following requirements:  \n  \n-   This type of DLL must instantiate a class derived from `CWinApp`.  \n  \n-   This type of DLL uses the `DllMain` provided by MFC. Place all DLL-specific initialization code in the `InitInstance` member function and termination code in `ExitInstance` as in a normal MFC application.  \n  \n-   Even though the term USRDLL is obsolete, you must still define \"**_USRDLL**\" on the compiler command line. This definition determines which declarations is pulled in from the MFC header files.  \n  \n Regular DLLs must have a `CWinApp`-derived class and a single object of that application class, as does an MFC application. However, the `CWinApp` object of the DLL does not have a main message pump, as does the `CWinApp` object of an application.  \n  \n Note that the `CWinApp::Run` mechanism does not apply to a DLL, because the application owns the main message pump. If the DLL opens modeless dialogs or has a main frame window of its own, the application's main message pump must call a routine exported by the DLL that in turn calls the `CWinApp::PreTranslateMessage` member function of the DLL's application object.  \n  \n For an example of this function, see the DLLScreenCap sample.  \n  \n Symbols are usually exported from a regular DLL using the standard C interface. The declaration of a function exported from a regular DLL would look something like this:  \n  \n```  \nextern \"C\" __declspec(dllexport) MyExportedFunction( );  \n```  \n  \n All memory allocations within a regular DLL should stay within the DLL; the DLL should not pass to or receive from the calling executable any of the following:  \n  \n-   Pointers to MFC objects  \n  \n-   Pointers to memory allocated by MFC  \n  \n If you need to do any of the above or need to pass MFC-derived objects between the calling executable and the DLL, you must build an extension DLL.  \n  \n It is safe to pass pointers to memory that were allocated by the C run-time libraries between an application and a DLL only if you make a copy of the data. You must not delete or resize these pointers or use them without making a copy of the memory.  \n  \n A DLL that is statically linked to MFC cannot also dynamically link to the shared MFC DLLs. A DLL that is statically linked to MFC is dynamically bound to an application just like any other DLL; applications link to it just like any other DLL.  \n  \n The standard MFC static link libraries are named according to the convention described in [Naming Conventions for MFC DLLs](../build/naming-conventions-for-mfc-dlls.md). However, with MFC version 3.0 and later, it is no longer necessary to manually specify to the linker the version of the MFC library you want linked in. Instead, the MFC header files automatically determine the correct version of the MFC library to link in based on preprocessor defines, such as **_DEBUG** or **_UNICODE**. The MFC header files add /DEFAULTLIB directives instructing the linker to link in a specific version of the MFC library.  \n  \n## What do you want to do?  \n  \n-   [Initialize regular DLLs](../build/initializing-regular-dlls.md)  \n  \n## What do you want to know more about?  \n  \n-   [Using MFC as Part of a DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md)  \n  \n-   [Using Database, OLE, and Sockets Extension DLLs in Regular DLLs](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  \n  \n-   [Creating an MFC DLL](../mfc/reference/mfc-dll-wizard.md)  \n  \n-   [Regular DLLs Dynamically Linked to MFC](../build/regular-dlls-dynamically-linked-to-mfc.md)  \n  \n-   [Extension DLLs](../build/extension-dlls-overview.md)  \n  \n## See Also  \n [Kinds of DLLs](../build/kinds-of-dlls.md)"}