{"nodes":[{"pos":[12,49],"content":"Serialization in MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Serialization in MFC | Microsoft Docs","pos":[0,37]}]},{"content":"Serialization in MFC","pos":[715,735]},{"content":"This article explains the serialization mechanism provided in the Microsoft Foundation Class Library (MFC) to allow objects to persist between runs of your program.","pos":[736,900]},{"content":"Serialization is the process of writing or reading an object to or from a persistent storage medium such as a disk file.","pos":[907,1027]},{"content":"Serialization is ideal for situations where it is desired to maintain the state of structured data (such as C++ classes or structures) during or after execution of a program.","pos":[1028,1202]},{"content":"Using the serialization objects provided by MFC allows this to occur in a standard and consistent manner, relieving the user from the need to perform file operations by hand.","pos":[1203,1377]},{"content":"MFC supplies built-in support for serialization in the class <ph id=\"ph1\">`CObject`</ph>.","pos":[1384,1455],"source":"MFC supplies built-in support for serialization in the class `CObject`."},{"content":"Thus, all classes derived from <ph id=\"ph1\">`CObject`</ph> can take advantage of <ph id=\"ph2\">`CObject`</ph>'s serialization protocol.","pos":[1456,1554],"source":" Thus, all classes derived from `CObject` can take advantage of `CObject`'s serialization protocol."},{"content":"The basic idea of serialization is that an object should be able to write its current state, usually indicated by the value of its member variables, to persistent storage.","pos":[1561,1732]},{"content":"Later, the object can be re-created by reading, or deserializing, the object's state from the storage.","pos":[1733,1835]},{"content":"Serialization handles all the details of object pointers and circular references to objects that are used when you serialize an object.","pos":[1836,1971]},{"content":"A key point is that the object itself is responsible for reading and writing its own state.","pos":[1972,2063]},{"content":"Thus, for a class to be serializable, it must implement the basic serialization operations.","pos":[2064,2155]},{"content":"As shown in the Serialization group of articles, it is easy to add this functionality to a class.","pos":[2156,2253]},{"content":"MFC uses an object of the <ph id=\"ph1\">`CArchive`</ph> class as an intermediary between the object to be serialized and the storage medium.","pos":[2260,2381],"source":"MFC uses an object of the `CArchive` class as an intermediary between the object to be serialized and the storage medium."},{"content":"This object is always associated with a <ph id=\"ph1\">`CFile`</ph> object, from which it obtains the necessary information for serialization, including the file name and whether the requested operation is a read or write.","pos":[2382,2584],"source":" This object is always associated with a `CFile` object, from which it obtains the necessary information for serialization, including the file name and whether the requested operation is a read or write."},{"content":"The object that performs a serialization operation can use the <ph id=\"ph1\">`CArchive`</ph> object without regard to the nature of the storage medium.","pos":[2585,2717],"source":" The object that performs a serialization operation can use the `CArchive` object without regard to the nature of the storage medium."},{"content":"A <ph id=\"ph1\">`CArchive`</ph> object uses overloaded insertion (<bpt id=\"p1\">**</bpt><ph id=\"ph2\">&lt;\\&lt;</ph><ept id=\"p1\">**</ept>) and extraction (<bpt id=\"p2\">**</bpt><ph id=\"ph3\">&gt;&gt;</ph><ept id=\"p2\">**</ept>) operators to perform writing and reading operations.","pos":[2724,2856],"source":"A `CArchive` object uses overloaded insertion (**<\\<**) and extraction (**>>**) operators to perform writing and reading operations."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Storing and Loading CObjects via an Archive<ept id=\"p1\">](../mfc/storing-and-loading-cobjects-via-an-archive.md)</ept> in the article Serialization: Serializing an Object.","pos":[2857,3036],"source":" For more information, see [Storing and Loading CObjects via an Archive](../mfc/storing-and-loading-cobjects-via-an-archive.md) in the article Serialization: Serializing an Object."},{"pos":[3044,3226],"content":"[!NOTE]\n Do not confuse the `CArchive` class with general-purpose iostream classes, which are for formatted text only. The `CArchive` class is for binary-format serialized objects.","leadings":["","> "],"nodes":[{"content":" Do not confuse the `CArchive` class with general-purpose iostream classes, which are for formatted text only. The `CArchive` class is for binary-format serialized objects.","pos":[8,180],"nodes":[{"content":"Do not confuse the <ph id=\"ph1\">`CArchive`</ph> class with general-purpose iostream classes, which are for formatted text only.","pos":[1,110],"source":" Do not confuse the `CArchive` class with general-purpose iostream classes, which are for formatted text only."},{"content":"The <ph id=\"ph1\">`CArchive`</ph> class is for binary-format serialized objects.","pos":[111,172],"source":" The `CArchive` class is for binary-format serialized objects."}]}]},{"content":"If you want, you can bypass MFC serialization to create your own mechanism for persistent data storage.","pos":[3233,3336]},{"content":"You will need to override the class member functions that initiate serialization at the user's command.","pos":[3337,3440]},{"content":"See the discussion in <bpt id=\"p1\">[</bpt>Technical Note 22<ept id=\"p1\">](../mfc/tn022-standard-commands-implementation.md)</ept> of the <ph id=\"ph1\">`ID_FILE_OPEN`</ph>, <bpt id=\"p2\">**</bpt>ID_FILE_SAVE<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>ID_FILE_SAVE_AS<ept id=\"p3\">**</ept> standard commands.","pos":[3441,3616],"source":" See the discussion in [Technical Note 22](../mfc/tn022-standard-commands-implementation.md) of the `ID_FILE_OPEN`, **ID_FILE_SAVE**, and **ID_FILE_SAVE_AS** standard commands."},{"content":"The following articles cover the two main tasks required for serialization:","pos":[3623,3698]},{"content":"Serialization: Making a Serializable Class","pos":[3709,3751]},{"content":"Serialization: Serializing an Object","pos":[3816,3852]},{"pos":[3907,4135],"content":"The article <bpt id=\"p1\">[</bpt>Serialization: Serialization vs. Database Input/Output<ept id=\"p1\">](../mfc/serialization-serialization-vs-database-input-output.md)</ept> describes when serialization is an appropriate input/output technique in database applications.","source":"The article [Serialization: Serialization vs. Database Input/Output](../mfc/serialization-serialization-vs-database-input-output.md) describes when serialization is an appropriate input/output technique in database applications."},{"content":"See Also","pos":[4144,4152]},{"content":"Concepts","pos":[4157,4165]},{"content":"General MFC Topics","pos":[4196,4214]},{"content":"CArchive Class","pos":[4251,4265]},{"content":"CObject Class","pos":[4308,4321]},{"content":"CDocument Class","pos":[4363,4378]},{"content":"CFile Class","pos":[4422,4433]}],"content":"---\ntitle: \"Serialization in MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"collection classes, serialization\"\n  - \"bypassing serialization\"\n  - \"MFC, serialization\"\n  - \"serialization [C++], MFC\"\n  - \"serialization [C++], bypassing\"\nms.assetid: fb596a18-4522-47e0-96e0-192732d24c12\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Serialization in MFC\nThis article explains the serialization mechanism provided in the Microsoft Foundation Class Library (MFC) to allow objects to persist between runs of your program.  \n  \n Serialization is the process of writing or reading an object to or from a persistent storage medium such as a disk file. Serialization is ideal for situations where it is desired to maintain the state of structured data (such as C++ classes or structures) during or after execution of a program. Using the serialization objects provided by MFC allows this to occur in a standard and consistent manner, relieving the user from the need to perform file operations by hand.  \n  \n MFC supplies built-in support for serialization in the class `CObject`. Thus, all classes derived from `CObject` can take advantage of `CObject`'s serialization protocol.  \n  \n The basic idea of serialization is that an object should be able to write its current state, usually indicated by the value of its member variables, to persistent storage. Later, the object can be re-created by reading, or deserializing, the object's state from the storage. Serialization handles all the details of object pointers and circular references to objects that are used when you serialize an object. A key point is that the object itself is responsible for reading and writing its own state. Thus, for a class to be serializable, it must implement the basic serialization operations. As shown in the Serialization group of articles, it is easy to add this functionality to a class.  \n  \n MFC uses an object of the `CArchive` class as an intermediary between the object to be serialized and the storage medium. This object is always associated with a `CFile` object, from which it obtains the necessary information for serialization, including the file name and whether the requested operation is a read or write. The object that performs a serialization operation can use the `CArchive` object without regard to the nature of the storage medium.  \n  \n A `CArchive` object uses overloaded insertion (**<\\<**) and extraction (**>>**) operators to perform writing and reading operations. For more information, see [Storing and Loading CObjects via an Archive](../mfc/storing-and-loading-cobjects-via-an-archive.md) in the article Serialization: Serializing an Object.  \n  \n> [!NOTE]\n>  Do not confuse the `CArchive` class with general-purpose iostream classes, which are for formatted text only. The `CArchive` class is for binary-format serialized objects.  \n  \n If you want, you can bypass MFC serialization to create your own mechanism for persistent data storage. You will need to override the class member functions that initiate serialization at the user's command. See the discussion in [Technical Note 22](../mfc/tn022-standard-commands-implementation.md) of the `ID_FILE_OPEN`, **ID_FILE_SAVE**, and **ID_FILE_SAVE_AS** standard commands.  \n  \n The following articles cover the two main tasks required for serialization:  \n  \n-   [Serialization: Making a Serializable Class](../mfc/serialization-making-a-serializable-class.md)  \n  \n-   [Serialization: Serializing an Object](../mfc/serialization-serializing-an-object.md)  \n  \n The article [Serialization: Serialization vs. Database Input/Output](../mfc/serialization-serialization-vs-database-input-output.md) describes when serialization is an appropriate input/output technique in database applications.  \n  \n## See Also  \n [Concepts](../mfc/mfc-concepts.md)   \n [General MFC Topics](../mfc/general-mfc-topics.md)   \n [CArchive Class](../mfc/reference/carchive-class.md)   \n [CObject Class](../mfc/reference/cobject-class.md)   \n [CDocument Class](../mfc/reference/cdocument-class.md)   \n [CFile Class](../mfc/reference/cfile-class.md)\n"}