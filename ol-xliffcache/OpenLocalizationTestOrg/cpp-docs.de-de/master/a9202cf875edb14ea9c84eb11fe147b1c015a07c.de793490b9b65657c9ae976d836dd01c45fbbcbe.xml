{"nodes":[{"pos":[12,41],"content":"Initializers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Initializers | Microsoft Docs","pos":[0,29]}]},{"content":"Initializers","pos":[743,755]},{"content":"An initializer specifies the initial value of a variable.","pos":[756,813]},{"content":"You can initialize variables in these contexts:","pos":[814,861]},{"content":"In the definition of a variable:","pos":[871,903]},{"content":"As one of the parameters of a function:","pos":[980,1019]},{"content":"As the return value of a function:","pos":[1087,1121]},{"content":"Initializers may take these forms:","pos":[1284,1318]},{"content":"An expression (or a comma-separated list of expressions) in parentheses:","pos":[1328,1400]},{"content":"An equals sign followed by an expression:","pos":[1458,1499]},{"content":"A braced initializer list.","pos":[1561,1587]},{"content":"The list may be empty or may consist of a set of lists, as in the following example:","pos":[1588,1672]},{"content":"Kinds of initialization","pos":[2087,2110]},{"content":"There are several kinds of initialization, which may occur at different points in program execution.","pos":[2114,2214]},{"content":"Different kinds of initialization are not mutually exclusive—for example, list initialization can trigger value initialization and in other circumstances, it can trigger aggregate initialization.","pos":[2215,2410]},{"content":"Zero initialization","pos":[2420,2439]},{"content":"Zero initialization is the setting of a variable to a zero value implicitly converted to the type:","pos":[2443,2541]},{"content":"Numeric variables are initialized to 0 (or 0.0, or 0.0000000000, etc.).","pos":[2551,2622]},{"content":"Char variables are initialized to ‘\\0’.","pos":[2632,2671]},{"pos":[2681,2719],"content":"Pointers are initialized to <ph id=\"ph1\">`nullptr`</ph>.","source":"Pointers are initialized to `nullptr`."},{"pos":[2729,2856],"content":"Arrays, <bpt id=\"p1\">[</bpt>POD<ept id=\"p1\">](../standard-library/is-pod-class.md)</ept> classes, structs, and unions have their members initialized to a zero value.","source":"Arrays, [POD](../standard-library/is-pod-class.md) classes, structs, and unions have their members initialized to a zero value."},{"content":"Zero initialization is performed at different times:","pos":[2863,2915]},{"content":"At program startup, for all named variables that have static duration.","pos":[2925,2995]},{"content":"These variables may later be initialized again.","pos":[2996,3043]},{"content":"During value initialization, for scalar types and POD class types that are initialized by using empty braces.","pos":[3053,3162]},{"content":"For arrays that have only a subset of their members initialized.","pos":[3172,3236]},{"content":"Here are some examples of zero initialization:","pos":[3243,3289]},{"content":"Default initialization","pos":[3825,3847]},{"content":"Default initialization for classes, structs, and unions is initialization with a default constructor.","pos":[3851,3952]},{"content":"The default constructor can be called with no initialization expression or with the <ph id=\"ph1\">`new`</ph> keyword:","pos":[3953,4051],"source":" The default constructor can be called with no initialization expression or with the `new` keyword:"},{"content":"If the class, struct, or union does not have a default constructor, the compiler emits an error.","pos":[4121,4217]},{"content":"Scalar variables are default initialized when they are defined with no initialization expression.","pos":[4224,4321]},{"content":"They have indeterminate values.","pos":[4322,4353]},{"content":"Arrays are default initialized when they are defined with no initialization expression.","pos":[4409,4496]},{"content":"When an array is default-initialized, its members are default initialized and have indeterminate values, as in the following example:","pos":[4497,4630]},{"content":"If the array members do not have a default constructor, the compiler emits an error.","pos":[4673,4757]},{"content":"Default initialization of constant variables","pos":[4768,4812]},{"content":"Constant variables must be declared together with an initializer.","pos":[4816,4881]},{"content":"If they are scalar types they cause a compiler error, and if they are class types that have a default constructor they cause a warning:","pos":[4882,5017]},{"content":"Default initialization of static variables","pos":[5374,5416]},{"content":"Static variables that are declared with no initializer are initialized to 0 (implicitly converted to the type).","pos":[5420,5531]},{"pos":[5801,5954],"content":"For more information about initialization of global static objects, see <bpt id=\"p1\">[</bpt>Additional Startup Considerations<ept id=\"p1\">](../cpp/additional-startup-considerations.md)</ept>.","source":"For more information about initialization of global static objects, see [Additional Startup Considerations](../cpp/additional-startup-considerations.md)."},{"content":"Value initialization","pos":[5964,5984]},{"content":"Value initialization occurs in the following cases:","pos":[5988,6039]},{"content":"a named value is initialized using empty brace initialization","pos":[6049,6110]},{"content":"an anonymous temporary object is initialized using empty parentheses or braces","pos":[6120,6198]},{"pos":[6208,6288],"content":"an object is initialized with the <ph id=\"ph1\">`new`</ph> keyword plus empty parentheses or braces","source":"an object is initialized with the `new` keyword plus empty parentheses or braces"},{"content":"Value initialization does the following:","pos":[6295,6335]},{"content":"for classes with at least one public constructor, the default constructor is called","pos":[6345,6428]},{"content":"for non-union classes with no declared constructors, the object is zero-initialized and the default constructor is called","pos":[6438,6559]},{"content":"for arrays, every element is value-initialized","pos":[6569,6615]},{"content":"in all other cases, the variable is zero initialized","pos":[6625,6677]},{"content":"Copy initialization","pos":[7067,7086]},{"content":"Copy initialization is the initialization of one object using a different object.","pos":[7090,7171]},{"content":"It occurs in the following cases:","pos":[7172,7205]},{"content":"a variable is initialized using an equals sign","pos":[7215,7261]},{"content":"an argument is passed to a function","pos":[7271,7306]},{"content":"an object is returned from a function","pos":[7316,7353]},{"content":"an exception is thrown or caught","pos":[7363,7395]},{"content":"a non-static data member is initialized using an equals sign","pos":[7405,7465]},{"content":"class, struct, and union members are initialized by copy initialization during aggregate initialization.","pos":[7475,7579]},{"content":"See <bpt id=\"p1\">[</bpt>Aggregate initialization<ept id=\"p1\">](#agginit)</ept> for examples.","pos":[7580,7634],"source":" See [Aggregate initialization](#agginit) for examples."},{"content":"The following code shows several examples of copy initialization:","pos":[7641,7706]},{"content":"Copy initialization cannot invoke explicit constructors.","pos":[8532,8588]},{"content":"In some cases, if the copy constructor of the class is deleted or inaccessible, copy initialization causes a compiler error.","pos":[8901,9025]},{"content":"Direct initialization","pos":[9034,9055]},{"content":"Direct initialization is initialization using (non-empty) braces or parentheses.","pos":[9059,9139]},{"content":"Unlike copy initialization, it can invoke explicit constructors.","pos":[9140,9204]},{"content":"It occurs in the following cases:","pos":[9205,9238]},{"content":"a variable is initialized with non-empty braces or parentheses","pos":[9248,9310]},{"pos":[9320,9405],"content":"a variable is initialized with the <ph id=\"ph1\">`new`</ph> keyword plus non-empty braces or parentheses","source":"a variable is initialized with the `new` keyword plus non-empty braces or parentheses"},{"pos":[9415,9445],"content":"a variable is initialized with"},{"content":"in a constructor, base classes and non-static members are initialized with an initializer list","pos":[9469,9563]},{"content":"in the copy of a captured variable inside a lambda expression","pos":[9573,9634]},{"content":"The following code shows some examples of direct initialization:","pos":[9641,9705]},{"content":"List initialization","pos":[10357,10376]},{"content":"List initialization occurs when a variable is initialized using a braced initializer list.","pos":[10380,10470]},{"content":"Braced initializer lists can be used in the following cases:","pos":[10471,10531]},{"content":"a variable is initialized","pos":[10541,10566]},{"pos":[10576,10621],"content":"a class is initialized with the <ph id=\"ph1\">`new`</ph> keyword","source":"a class is initialized with the `new` keyword"},{"content":"an object is returned from a function","pos":[10631,10668]},{"content":"an argument passed to a function","pos":[10678,10710]},{"content":"one of the arguments in a direct initialization","pos":[10720,10767]},{"content":"in a non-static data member initializer","pos":[10777,10816]},{"content":"in a constructor initializer list","pos":[10826,10859]},{"content":"The following code shows some examples of list initialization:","pos":[10866,10928]},{"pos":[11599,11623],"content":"Aggregate initialization"},{"content":"Aggregate initialization is a form of list initialization for arrays or class types (often structs or unions) that have:","pos":[11627,11747]},{"content":"no private or protected members","pos":[11757,11788]},{"content":"no user-provided constructors, except for explicitly defaulted or deleted constructors","pos":[11798,11884]},{"content":"no base classes","pos":[11894,11909]},{"content":"no virtual member functions","pos":[11919,11946]},{"content":"no brace-or-equal initializers for non-static members","pos":[11956,12009]},{"content":"Aggregate initializers consist of a braced initialization list, with or without an equals sign, as in the following example:","pos":[12016,12140]},{"content":"You should see the following output:","pos":[12816,12852]},{"pos":[12940,13090],"content":"[!IMPORTANT]\n Array members that declared but not explicitly initialized during aggregate initialization are zero-initialized, as in `myArr3` above.","leadings":["","> "],"nodes":[{"content":"Array members that declared but not explicitly initialized during aggregate initialization are zero-initialized, as in <ph id=\"ph1\">`myArr3`</ph> above.","pos":[14,148],"source":" Array members that declared but not explicitly initialized during aggregate initialization are zero-initialized, as in `myArr3` above."}]},{"content":"Initializing unions and structs","pos":[13101,13132]},{"content":"If a union does not have a constructor, you can initialize it with a single value (or with another instance of a union).","pos":[13136,13256]},{"content":"The value is used to initialize the first non-static field.","pos":[13257,13316]},{"content":"This is different from struct initialization, in which the first value in the initializer is used to initialize the first field, the second to initialize the second field, and so on.","pos":[13317,13499]},{"content":"Compare the initialization of unions and structs in the following example:","pos":[13500,13574]},{"content":"Initializing aggregates that contain aggregates","pos":[14824,14871]},{"content":"Aggregate types can contain other aggregate types, for example arrays of arrays, arrays of structs, and so on.","pos":[14875,14985]},{"content":"These types are initialized by using nested sets of braces, for example:","pos":[14986,15058]},{"content":"Reference initialization","pos":[15317,15341]},{"content":"Variables of reference type must be initialized with an object of the type from which the reference type is derived, or with an object of a type that can be converted to the type from which the reference type is derived.","pos":[15345,15565]},{"content":"For example:","pos":[15566,15578]},{"content":"The only way to initialize a reference with a temporary object is to initialize a constant temporary object.","pos":[15966,16074]},{"content":"Once initialized, a reference-type variable always points to the same object; it cannot be modified to point to another object.","pos":[16075,16202]},{"content":"Although the syntax can be the same, initialization of reference-type variables and assignment to reference-type variables are semantically different.","pos":[16209,16359]},{"content":"In the preceding example, the assignments that change <ph id=\"ph1\">`iVar`</ph> and <ph id=\"ph2\">`lVar`</ph> look similar to the initializations, but have different effects.","pos":[16360,16496],"source":" In the preceding example, the assignments that change `iVar` and `lVar` look similar to the initializations, but have different effects."},{"content":"The initialization specifies the object to which the reference-type variable points; the assignment assigns to the referred-to object through the reference.","pos":[16497,16653]},{"content":"Because both passing an argument of reference type to a function and returning a value of reference type from a function are initializations, the formal arguments to a function are initialized correctly, as are the references returned.","pos":[16660,16895]},{"content":"Reference-type variables can be declared without initializers only in the following:","pos":[16902,16986]},{"content":"Function declarations (prototypes).","pos":[16996,17031]},{"content":"For example:","pos":[17032,17044]},{"content":"Function-return type declarations.","pos":[17101,17135]},{"content":"For example:","pos":[17136,17148]},{"content":"Declaration of a reference-type class member.","pos":[17206,17251]},{"content":"For example:","pos":[17252,17264]},{"content":"Declaration of a variable explicitly specified as <ph id=\"ph1\">`extern`</ph>.","pos":[17332,17391],"source":"Declaration of a variable explicitly specified as `extern`."},{"content":"For example:","pos":[17392,17404]},{"content":"When initializing a reference-type variable, the compiler uses the decision graph shown in the following figure to select between creating a reference to an object or creating a temporary object to which the reference points.","pos":[17458,17683]},{"content":"Decision graph for initialization of ref types","pos":[17692,17738]},{"content":"Decision Graph for Initialization of Reference Types","pos":[17778,17830]},{"content":"References to <ph id=\"ph1\">`volatile`</ph> types (declared as <ph id=\"ph2\">`volatile`</ph> <bpt id=\"p1\">*</bpt>typename<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt><ph id=\"ph3\">&amp;</ph><ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept>) can be initialized with <ph id=\"ph4\">`volatile`</ph> objects of the same type or with objects that have not been declared as <ph id=\"ph5\">`volatile`</ph>.","pos":[17837,18040],"source":"References to `volatile` types (declared as `volatile` *typename***&** *identifier*) can be initialized with `volatile` objects of the same type or with objects that have not been declared as `volatile`."},{"content":"They cannot, however, be initialized with <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> objects of that type.","pos":[18041,18114],"source":" They cannot, however, be initialized with **const** objects of that type."},{"content":"Similarly, references to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> types (declared as <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>typename<ept id=\"p3\">*</ept><bpt id=\"p4\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p4\">**</ept> <bpt id=\"p5\">*</bpt>identifier<ept id=\"p5\">*</ept>) can be initialized with <bpt id=\"p6\">**</bpt>const<ept id=\"p6\">**</ept> objects of the same type (or anything that has a conversion to that type or with objects that have not been declared as <bpt id=\"p7\">**</bpt>const<ept id=\"p7\">**</ept>).","pos":[18115,18374],"source":" Similarly, references to **const** types (declared as **const** *typename***&** *identifier*) can be initialized with **const** objects of the same type (or anything that has a conversion to that type or with objects that have not been declared as **const**)."},{"content":"They cannot, however, be initialized with <ph id=\"ph1\">`volatile`</ph> objects of that type.","pos":[18375,18449],"source":" They cannot, however, be initialized with `volatile` objects of that type."},{"pos":[18456,18620],"content":"References that are not qualified with either the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> keyword can be initialized only with objects declared as neither <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> nor <ph id=\"ph2\">`volatile`</ph>.","source":"References that are not qualified with either the **const** or `volatile` keyword can be initialized only with objects declared as neither **const** nor `volatile`."},{"content":"Initialization of external variables","pos":[18630,18666]},{"content":"Declarations of automatic, register, static, and external variables can contain initializers.","pos":[18670,18763]},{"content":"However, declarations of external variables can contain initializers only if the variables are not declared as <ph id=\"ph1\">`extern`</ph>.","pos":[18764,18884],"source":" However, declarations of external variables can contain initializers only if the variables are not declared as `extern`."}],"content":"---\ntitle: \"Initializers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"array-element initializers\"\n  - \"initializing arrays, initializers\"\n  - \"arrays [C++], array-element initializers\"\n  - \"declarators, as initializers\"\n  - \"initializers, array element\"\nms.assetid: ce301ed8-aa1c-47b2-bb39-9f0541b4af85\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Initializers\nAn initializer specifies the initial value of a variable. You can initialize variables in these contexts:  \n  \n-   In the definition of a variable:  \n  \n    ```cpp  \n    int i = 3;  \n    Point p1{ 1, 2 };  \n    ```  \n  \n-   As one of the parameters of a function:  \n  \n    ```cpp  \n    set_point(Point{ 5, 6 });  \n    ```  \n  \n-   As the return value of a function:  \n  \n    ```cpp  \n    Point get_new_point(int x, int y) { return { x, y }; }  \n    Point get_new_point(int x, int y) { return Point{ x, y }; }  \n  \n    ```  \n  \n Initializers may take these forms:  \n  \n-   An expression (or a comma-separated list of expressions) in parentheses:  \n  \n    ```cpp  \n    Point p1(1, 2);  \n    ```  \n  \n-   An equals sign followed by an expression:  \n  \n    ```cpp  \n    string s = \"hello\";  \n    ```  \n  \n-   A braced initializer list. The list may be empty or may consist of a set of lists, as in the following example:  \n  \n    ```cpp  \n    struct Point{  \n        int x;  \n        int y;  \n    };  \n    class PointConsumer{  \n    public:  \n        void set_point(Point p){};  \n        void set_points(initializer_list<Point> my_list){};  \n    };  \n    int main() {  \n        PointConsumer pc{};  \n        pc.set_point({});  \n        pc.set_point({ 3, 4 });  \n        pc.set_points({ { 3, 4 }, { 5, 6 } });  \n    }  \n    ```  \n  \n## Kinds of initialization  \n There are several kinds of initialization, which may occur at different points in program execution. Different kinds of initialization are not mutually exclusive—for example, list initialization can trigger value initialization and in other circumstances, it can trigger aggregate initialization.  \n  \n### Zero initialization  \n Zero initialization is the setting of a variable to a zero value implicitly converted to the type:  \n  \n-   Numeric variables are initialized to 0 (or 0.0, or 0.0000000000, etc.).  \n  \n-   Char variables are initialized to ‘\\0’.  \n  \n-   Pointers are initialized to `nullptr`.  \n  \n-   Arrays, [POD](../standard-library/is-pod-class.md) classes, structs, and unions have their members initialized to a zero value.  \n  \n Zero initialization is performed at different times:  \n  \n-   At program startup, for all named variables that have static duration. These variables may later be initialized again.  \n  \n-   During value initialization, for scalar types and POD class types that are initialized by using empty braces.  \n  \n-   For arrays that have only a subset of their members initialized.  \n  \n Here are some examples of zero initialization:  \n  \n```cpp  \nstruct my_struct{  \n    int i;  \n    char c;  \n};  \n  \nint i0;              // zero-initialized to 0  \nint main() {  \n    static float f1;  // zero-initialized to 0.000000000  \n    double d{};     // zero-initialized to 0.00000000000000000  \n    int* ptr{};     // initialized to nullptr  \n    char s_array[3]{'a', 'b'};  // the third char is initialized to '\\0'  \n    int int_array[5] = { 8, 9, 10 };  // the fourth and fifth ints are initialized to 0  \n    my_struct a_struct{};   // i = 0, c = '\\0'  \n}  \n```  \n  \n### Default initialization  \n Default initialization for classes, structs, and unions is initialization with a default constructor. The default constructor can be called with no initialization expression or with the `new` keyword:  \n  \n```cpp  \nMyClass mc1;  \nMyClass* mc3 = new MyClass;  \n```  \n  \n If the class, struct, or union does not have a default constructor, the compiler emits an error.  \n  \n Scalar variables are default initialized when they are defined with no initialization expression. They have indeterminate values.  \n  \n```cpp  \nint i1;  \nfloat f;  \nchar c;  \n```  \n  \n Arrays are default initialized when they are defined with no initialization expression. When an array is default-initialized, its members are default initialized and have indeterminate values, as in the following example:  \n  \n```cpp  \nint int_arr[3];  \n```  \n  \n If the array members do not have a default constructor, the compiler emits an error.  \n  \n#### Default initialization of constant variables  \n Constant variables must be declared together with an initializer. If they are scalar types they cause a compiler error, and if they are class types that have a default constructor they cause a warning:  \n  \n```cpp  \nclass MyClass{};  \nint main() {  \n    //const int i2;   // compiler error C2734: const object must be initialized if not extern  \n    //const char c2;  // same error  \n    const MyClass mc1; // compiler error C4269: 'const automatic data initialized with compiler generated default constructor produces unreliable results  \n}  \n```  \n  \n#### Default initialization of static variables  \n Static variables that are declared with no initializer are initialized to 0 (implicitly converted to the type).  \n  \n```cpp  \nclass MyClass {     \nprivate:  \n    int m_int;  \n    char m_char;  \n};  \n  \nint main() {  \n    static int int1;       // 0  \n    static char char1;     // '\\0'  \n    static bool bool1;   // false  \n    static MyClass mc1;     // {0, '\\0'}  \n}  \n```  \n  \n For more information about initialization of global static objects, see [Additional Startup Considerations](../cpp/additional-startup-considerations.md).  \n  \n### Value initialization  \n Value initialization occurs in the following cases:  \n  \n-   a named value is initialized using empty brace initialization  \n  \n-   an anonymous temporary object is initialized using empty parentheses or braces  \n  \n-   an object is initialized with the `new` keyword plus empty parentheses or braces  \n  \n Value initialization does the following:  \n  \n-   for classes with at least one public constructor, the default constructor is called  \n  \n-   for non-union classes with no declared constructors, the object is zero-initialized and the default constructor is called  \n  \n-   for arrays, every element is value-initialized  \n  \n-   in all other cases, the variable is zero initialized  \n  \n```cpp  \nclass BaseClass {    \nprivate:  \n    int m_int;  \n};  \n  \nint main() {  \n    BaseClass bc{};     // class is initialized  \n    BaseClass*  bc2 = new BaseClass();  // class is initialized, m_int value is 0  \n    int int_arr[3]{};  // value of all members is 0  \n    int a{};     // value of a is 0  \n    double b{};  // value of b is 0.00000000000000000  \n}  \n  \n```  \n  \n### Copy initialization  \n Copy initialization is the initialization of one object using a different object. It occurs in the following cases:  \n  \n-   a variable is initialized using an equals sign  \n  \n-   an argument is passed to a function  \n  \n-   an object is returned from a function  \n  \n-   an exception is thrown or caught  \n  \n-   a non-static data member is initialized using an equals sign  \n  \n-   class, struct, and union members are initialized by copy initialization during aggregate initialization. See [Aggregate initialization](#agginit) for examples.  \n  \n The following code shows several examples of copy initialization:  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nclass MyClass{  \npublic:  \n    MyClass(int myInt) {}  \n    void set_int(int myInt) { m_int = myInt; }  \n    int get_int() const { return m_int; }  \nprivate:  \n    int m_int = 7; // copy initialization of m_int  \n  \n};  \nclass MyException : public exception{};  \nint main() {  \n    int i = 5;              // copy initialization of i  \n    MyClass mc1{ i };  \n    MyClass mc2 = mc1;      // copy initialization of mc2 from mc1  \n    MyClass mc1.set_int(i);    // copy initialization of parameter from i  \n    int i2 = mc2.get_int(); // copy initialization of i2 from return value of get_int()  \n  \n    try{  \n        throw MyException();      \n    }  \n    catch (MyException ex){ // copy initialization of ex  \n        cout << ex.what();    \n    }  \n}  \n```  \n  \n Copy initialization cannot invoke explicit constructors.  \n  \n```cpp  \nvector<int> v = 10; // the constructor is explicit; compiler error C2440: cannot convert from 'int' to 'std::vector<int,std::allocator<_Ty>>'  \nregex r = \"a.*b\"; // the constructor is explicit; same error  \nshared_ptr<int> sp = new int(1729); // the constructor is explicit; same error  \n```  \n  \n In some cases, if the copy constructor of the class is deleted or inaccessible, copy initialization causes a compiler error. \n  \n### Direct initialization  \n Direct initialization is initialization using (non-empty) braces or parentheses. Unlike copy initialization, it can invoke explicit constructors. It occurs in the following cases:  \n  \n-   a variable is initialized with non-empty braces or parentheses  \n  \n-   a variable is initialized with the `new` keyword plus non-empty braces or parentheses  \n  \n-   a variable is initialized with `static_cast`  \n  \n-   in a constructor, base classes and non-static members are initialized with an initializer list  \n  \n-   in the copy of a captured variable inside a lambda expression  \n  \n The following code shows some examples of direct initialization:  \n  \n```cpp  \nclass BaseClass{  \npublic:  \n    BaseClass(int n) :m_int(n){} // m_int is direct initialized  \nprivate:  \n    int m_int;  \n};  \n  \nclass DerivedClass : public BaseClass{  \npublic:  \n    // BaseClass and m_char are direct initialized  \n    DerivedClass(int n, char c) : BaseClass(n), m_char(c) {}  \nprivate:  \n    char m_char;  \n};  \nint main(){  \n    BaseClass bc1(5);  \n    DerivedClass dc1{ 1, 'c' };  \n    BaseClass* bc2 = new BaseClass(7);  \n    BaseClass bc3 = static_cast<BaseClass>(dc1);  \n  \n    int a = 1;  \n    function<int()> func = [a](){  return a + 1; }; // a is direct initialized  \n    int n = func();  \n}  \n```  \n  \n### List initialization  \n List initialization occurs when a variable is initialized using a braced initializer list. Braced initializer lists can be used in the following cases:  \n  \n-   a variable is initialized  \n  \n-   a class is initialized with the `new` keyword  \n  \n-   an object is returned from a function  \n  \n-   an argument passed to a function  \n  \n-   one of the arguments in a direct initialization  \n  \n-   in a non-static data member initializer  \n  \n-   in a constructor initializer list  \n  \n The following code shows some examples of list initialization:  \n  \n```cpp  \nclass MyClass {  \npublic:  \n    MyClass(int myInt, char myChar) {}    \nprivate:  \n    int m_int[]{ 3 };  \n    char m_char;  \n};  \nclass MyClassConsumer{  \npublic:  \n    void set_class(MyClass c) {}  \n    MyClass get_class() { return MyClass{ 0, '\\0' }; }  \n};  \nstruct MyStruct{  \n    int my_int;  \n    char my_char;  \n    MyClass my_class;  \n};  \nint main() {  \n    MyClass mc1{ 1, 'a' };  \n    MyClass* mc2 = new MyClass{ 2, 'b' };  \n    MyClass mc3 = { 3, 'c' };  \n  \n    MyClassConsumer mcc;  \n    mcc.set_class(MyClass{ 3, 'c' });  \n    mcc.set_class({ 4, 'd' });  \n  \n    MyStruct ms1{ 1, 'a', { 2, 'b' } };  \n}  \n```  \n  \n### <a name=\"agginit\"></a> Aggregate initialization  \n Aggregate initialization is a form of list initialization for arrays or class types (often structs or unions) that have:  \n  \n-   no private or protected members  \n  \n-   no user-provided constructors, except for explicitly defaulted or deleted constructors  \n  \n-   no base classes  \n  \n-   no virtual member functions  \n  \n-   no brace-or-equal initializers for non-static members  \n  \n Aggregate initializers consist of a braced initialization list, with or without an equals sign, as in the following example:  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nstruct MyAggregate{  \n    int myInt;  \n    char myChar;  \n};  \n  \nint main() {  \n    MyAggregate agg1{ 1, 'c' };  \n  \n    cout << \"agg1: \" << agg1.myChar << \": \" << agg1.myInt << endl;  \n    cout << \"agg2: \" << agg2.myChar << \": \" << agg2.myInt << endl;  \n  \n    int myArr1[]{ 1, 2, 3, 4 };  \n    int myArr2[3] = { 5, 6, 7 };  \n    int myArr3[5] = { 8, 9, 10 };  \n  \n    cout << \"myArr1: \";  \n    for (int i : myArr1){  \n        cout << i << \" \";  \n    }  \n    cout << endl;  \n  \n    cout << \"myArr3: \";  \n    for (auto const &i : myArr3) {  \n        cout << i << \" \";  \n    }  \n    cout << endl;  \n}  \n```  \n  \n You should see the following output:  \n  \n```  \nagg1: c: 1  \nagg2: d: 2  \nmyArr1: 1 2 3 4  \nmyArr3: 8 9 10 0 0  \n```  \n  \n> [!IMPORTANT]\n>  Array members that declared but not explicitly initialized during aggregate initialization are zero-initialized, as in `myArr3` above.  \n  \n#### Initializing unions and structs  \n If a union does not have a constructor, you can initialize it with a single value (or with another instance of a union). The value is used to initialize the first non-static field. This is different from struct initialization, in which the first value in the initializer is used to initialize the first field, the second to initialize the second field, and so on. Compare the initialization of unions and structs in the following example:  \n  \n```cpp  \nstruct MyStruct {  \n    int myInt;  \n    char myChar;  \n};  \nunion MyUnion {  \n    int my_int;  \n    char my_char;  \n    bool my_bool;  \n    MyStruct my_struct;  \n};  \n  \nint main() {    \n    MyUnion mu1{ 'a' };  // my_int = 97, my_char = 'a', my_bool = true, {myInt = 97, myChar = '\\0'}  \n    MyUnion mu2{ 1 };   // my_int = 1, my_char = 'x1', my_bool = true, {myInt = 1, myChar = '\\0'}  \n    MyUnion mu3{};      // my_int = 0, my_char = '\\0', my_bool = false, {myInt = 0, myChar = '\\0'}  \n    MyUnion mu4 = mu3;  // my_int = 0, my_char = '\\0', my_bool = false, {myInt = 0, myChar = '\\0'}  \n    //MyUnion mu5{ 1, 'a', true };  // compiler error: C2078: too many initializers  \n    //MyUnion mu6 = 'a';            // compiler error: C2440: cannot convert from 'char' to 'MyUnion'  \n    //MyUnion mu7 = 1;              // compiler error: C2440: cannot convert from 'int' to 'MyUnion'  \n  \n    MyStruct ms1{ 'a' };            // myInt = 97, myChar = '\\0'  \n    MyStruct ms2{ 1 };              // myInt = 1, myChar = '\\0'  \n    MyStruct ms3{};                 // myInt = 0, myChar = '\\0'  \n    MyStruct ms4{1, 'a'};           // myInt = 1, myChar = 'a'  \n    MyStruct ms5 = { 2, 'b' };      // myInt = 2, myChar = 'b'  \n}  \n```  \n  \n#### Initializing aggregates that contain aggregates  \n Aggregate types can contain other aggregate types, for example arrays of arrays, arrays of structs, and so on. These types are initialized by using nested sets of braces, for example:  \n  \n```cpp  \nstruct MyStruct {  \n    int myInt;  \n    char myChar;  \n};  \nint main() {  \n    int intArr1[2][2]{{ 1, 2 }, { 3, 4 }};  \n    int intArr3[2][2] = {1, 2, 3, 4};    \n    MyStruct structArr[]{ { 1, 'a' }, { 2, 'b' }, {3, 'c'} };  \n}  \n```  \n  \n### Reference initialization  \n Variables of reference type must be initialized with an object of the type from which the reference type is derived, or with an object of a type that can be converted to the type from which the reference type is derived. For example:  \n  \n```  \n// initializing_references.cppint   \nint iVar;  \nlong lVar;  \nint main()   \n{   long& LongRef1 = lVar;   // No conversion required.  \n   long& LongRef2 = iVar;   // C2440  \n   const long& LongRef3 = iVar;   // OK  \n   LongRef1 = 23L;   // Change lVar through a reference.  \n   LongRef2 = 11L;   // Change iVar through a reference.  \n   LongRef3 = 11L;   // C3892}  \n```  \n  \n The only way to initialize a reference with a temporary object is to initialize a constant temporary object. Once initialized, a reference-type variable always points to the same object; it cannot be modified to point to another object.  \n  \n Although the syntax can be the same, initialization of reference-type variables and assignment to reference-type variables are semantically different. In the preceding example, the assignments that change `iVar` and `lVar` look similar to the initializations, but have different effects. The initialization specifies the object to which the reference-type variable points; the assignment assigns to the referred-to object through the reference.  \n  \n Because both passing an argument of reference type to a function and returning a value of reference type from a function are initializations, the formal arguments to a function are initialized correctly, as are the references returned.  \n  \n Reference-type variables can be declared without initializers only in the following:  \n  \n-   Function declarations (prototypes). For example:  \n  \n    ```  \n    int func( int& );  \n    ```  \n  \n-   Function-return type declarations. For example:  \n  \n    ```  \n    int& func( int& );  \n    ```  \n  \n-   Declaration of a reference-type class member. For example:  \n  \n    ```  \n    class c {public:   int& i;};  \n    ```  \n  \n-   Declaration of a variable explicitly specified as `extern`. For example:  \n  \n    ```  \n    extern int& iVal;  \n    ```  \n  \n When initializing a reference-type variable, the compiler uses the decision graph shown in the following figure to select between creating a reference to an object or creating a temporary object to which the reference points.  \n  \n ![Decision graph for initialization of ref types](../cpp/media/vc38s71.gif \"vc38S71\")  \nDecision Graph for Initialization of Reference Types  \n  \n References to `volatile` types (declared as `volatile` *typename***&** *identifier*) can be initialized with `volatile` objects of the same type or with objects that have not been declared as `volatile`. They cannot, however, be initialized with **const** objects of that type. Similarly, references to **const** types (declared as **const** *typename***&** *identifier*) can be initialized with **const** objects of the same type (or anything that has a conversion to that type or with objects that have not been declared as **const**). They cannot, however, be initialized with `volatile` objects of that type.  \n  \n References that are not qualified with either the **const** or `volatile` keyword can be initialized only with objects declared as neither **const** nor `volatile`.  \n  \n### Initialization of external variables  \n Declarations of automatic, register, static, and external variables can contain initializers. However, declarations of external variables can contain initializers only if the variables are not declared as `extern`.\n  \n"}