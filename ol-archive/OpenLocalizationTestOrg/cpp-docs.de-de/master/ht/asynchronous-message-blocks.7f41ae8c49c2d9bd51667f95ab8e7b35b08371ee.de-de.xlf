<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0994919adb958640b3e409e3b04b20f91820d8d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\asynchronous-message-blocks.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bd98b0a83d004b810afdc5e81c8afa0dc62db327</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fe295bc9607d90a6d0c1a12ec97442f695683d87</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Asynchronous Message Blocks | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Asynchronous Message Blocks</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Agents Library provides several message-block types that enable you to propagate messages among application components in a thread-safe manner.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These message-block types are often used with the various message-passing routines, such as <bpt id="p1">[</bpt>concurrency::send<ept id="p1">](reference/concurrency-namespace-functions.md#send)</ept>, <bpt id="p2">[</bpt>concurrency::asend<ept id="p2">](reference/concurrency-namespace-functions.md#asend)</ept>, <bpt id="p3">[</bpt>concurrency::receive<ept id="p3">](reference/concurrency-namespace-functions.md#receive)</ept>, and <bpt id="p4">[</bpt>concurrency::try_receive<ept id="p4">](reference/concurrency-namespace-functions.md#try_receive)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For more information about the message passing routines that are defined by the Agents Library, see <bpt id="p1">[</bpt>Message Passing Functions<ept id="p1">](../../parallel/concrt/message-passing-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Sections</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Sources and Targets</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Message Propagation</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Overview of Message Block Types</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>unbounded_buffer Class</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>overwrite_buffer Class</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>single_assignment Class</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>call Class</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>transformer Class</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>choice Class</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>join and multitype_join Classes</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>timer Class</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Message Filtering</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Message Reservation</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Sources and Targets</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Sources and targets are two important participants in message passing.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>source<ept id="p1">*</ept> refers to an endpoint of communication that sends messages.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>target<ept id="p1">*</ept> refers to an endpoint of communication that receives messages.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can think of a source as an endpoint that you read from and a target as an endpoint that you write to.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Applications connect sources and targets together to form <bpt id="p1">*</bpt>messaging networks<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The Agents Library uses two abstract classes to represent sources and targets: <bpt id="p1">[</bpt>concurrency::ISource<ept id="p1">](../../parallel/concrt/reference/isource-class.md)</ept> and <bpt id="p2">[</bpt>concurrency::ITarget<ept id="p2">](../../parallel/concrt/reference/itarget-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Message block types that act as sources derive from <ph id="ph1">`ISource`</ph>; message block types that act as targets derive from <ph id="ph2">`ITarget`</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Message block types that act as sources and targets derive from both <ph id="ph1">`ISource`</ph> and <ph id="ph2">`ITarget`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Message Propagation</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Message propagation<ept id="p1">*</ept> is the act of sending a message from one component to another.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>When a message block is offered a message, it can accept, decline, or postpone that message.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Every message block type stores and transmits messages in different ways.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`unbounded_buffer`</ph> class stores an unlimited number of messages, the <ph id="ph2">`overwrite_buffer`</ph> class stores a single message at a time, and the transformer class stores an altered version of each message.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>These message block types are described in more detail later in this document.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>When a message block accepts a message, it can optionally perform work and, if the message block is a source, pass the resulting message to another member of the network.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A message block can use a filter function to decline messages that it does not want to receive.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Filters are described in more detail later in this topic, in the section <bpt id="p1">[</bpt>Message Filtering<ept id="p1">](#filtering)</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A message block that postpones a message can reserve that message and consume it later.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Message reservation is described in more detail later in this topic, in the section <bpt id="p1">[</bpt>Message Reservation<ept id="p1">](#reservation)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The Agents Library enables message blocks to asynchronously or synchronously pass messages.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you pass a message to a message block synchronously, for example, by using the <ph id="ph1">`send`</ph> function, the runtime blocks the current context until the target block either accepts or rejects the message.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When you pass a message to a message block asynchronously, for example, by using the <ph id="ph1">`asend`</ph> function, the runtime offers the message to the target, and if the target accepts the message, the runtime schedules an asynchronous task that propagates the message to the receiver.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The runtime uses lightweight tasks to propagate messages in a cooperative manner.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information about lightweight tasks, see <bpt id="p1">[</bpt>Task Scheduler<ept id="p1">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Applications connect sources and targets together to form messaging networks.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Typically, you link the network and call <ph id="ph1">`send`</ph> or <ph id="ph2">`asend`</ph> to pass data to the network.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To connect a source message block to a target, call the <bpt id="p1">[</bpt>concurrency::ISource::link_target<ept id="p1">](reference/isource-class.md#link_target)</ept> method.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To disconnect a source block from a target, call the <bpt id="p1">[</bpt>concurrency::ISource::unlink_target<ept id="p1">](reference/isource-class.md#unlink_target)</ept> method.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To disconnect a source block from all of its targets, call the <bpt id="p1">[</bpt>concurrency::ISource::unlink_targets<ept id="p1">](reference/isource-class.md#unlink_targets)</ept> method.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When one of the predefined message block types leaves scope or is destroyed, it automatically disconnects itself from any target blocks.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Some message block types restrict the maximum number of targets that they can write to.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following section describes the restrictions that apply to the predefined message block types.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Overview of Message Block Types</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following table briefly describes the role of the important message-block types.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>unbounded_buffer</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Stores a queue of messages.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>overwrite_buffer</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Stores one message that can be written to and read from multiple times.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>single_assignment</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Stores one message that can be written to one time and read from multiple times.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>call</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Performs work when it receives a message.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>transformer</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Performs work when it receives data and sends the result of that work to another target block.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`transformer`</ph> class can act on different input and output types.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>choice</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Selects the first available message from a set of sources.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>join and multitype join</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Wait for all messages to be received from a set of sources and then combine the messages into one message for another message block.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>timer</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Sends a message to a target block on a regular interval.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>These message-block types have different characteristics that make them useful for different situations.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>These are some of the characteristics:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Propagation type<ept id="p1">*</ept>: Whether the message block acts as a source of data, a receiver of data, or both.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Message ordering<ept id="p1">*</ept>: Whether the message block maintains the original order in which messages are sent or received.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Each predefined message block type maintains the original order in which it sends or receives messages.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Source count<ept id="p1">*</ept>: The maximum number of sources that the message block can read from.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Target count<ept id="p1">*</ept>: The maximum number of targets that the message block can write to.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following table shows how these characteristics relate to the various message-block types.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Message block type</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Propagation type (Source, Target, or Both)</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Message ordering (Ordered or Unordered)</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Source count</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Target count</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Target</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Not Applicable</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>10</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Unbounded</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Ordered</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>10</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Source</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Not Applicable</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Not Applicable</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The following sections describe the message-block types in more detail.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>unbounded_buffer Class</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::unbounded_buffer<ept id="p1">](reference/unbounded-buffer-class.md)</ept> class represents a general-purpose asynchronous messaging structure.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When a target receives a message from an <ph id="ph1">`unbounded_buffer`</ph> object, that message is removed from the message queue.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Therefore, although an <ph id="ph1">`unbounded_buffer`</ph> object can have multiple targets, only one target will receive each message.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`unbounded_buffer`</ph> class is useful when you want to pass multiple messages to another component, and that component must receive each message.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`unbounded_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This example sends three values to an <ph id="ph1">`unbounded_buffer`</ph> object and then reads those values back from the same object.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>concrt-unbounded_buffer-structure#1</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`unbounded_buffer`</ph> class, see <bpt id="p1">[</bpt>How to: Implement Various Producer-Consumer Patterns<ept id="p1">](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>overwrite_buffer Class</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::overwrite_buffer<ept id="p1">](../../parallel/concrt/reference/overwrite-buffer-class.md)</ept> class resembles the <ph id="ph1">`unbounded_buffer`</ph> class, except that an <ph id="ph2">`overwrite_buffer`</ph> object stores just one message.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In addition, when a target receives a message from an <ph id="ph1">`overwrite_buffer`</ph> object, that message is not removed from the buffer.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Therefore, multiple targets receive a copy of the message.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`overwrite_buffer`</ph> class is useful when you want to pass multiple messages to another component, but that component needs only the most recent value.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This class is also useful when you want to broadcast a message to multiple components.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`overwrite_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>This example sends three values to an <ph id="ph1">`overwrite _buffer`</ph> object and then reads the current value from the same object three times.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This example is similar to the example for the <ph id="ph1">`unbounded_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`overwrite_buffer`</ph> class stores just one message.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In addition, the runtime does not remove the message from an <ph id="ph1">`overwrite_buffer`</ph> object after it is read.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>concrt-overwrite_buffer-structure#1</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`overwrite_buffer`</ph> class, see <bpt id="p1">[</bpt>How to: Implement Various Producer-Consumer Patterns<ept id="p1">](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>single_assignment Class</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::single_assignment<ept id="p1">](../../parallel/concrt/reference/single-assignment-class.md)</ept> class resembles the <ph id="ph1">`overwrite_buffer`</ph> class, except that a <ph id="ph2">`single_assignment`</ph> object can be written to one time only.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`overwrite_buffer`</ph> class, when a target receives a message from a <ph id="ph2">`single_assignment`</ph> object, that message is not removed from that object.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Therefore, multiple targets receive a copy of the message.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`single_assignment`</ph> class is useful when you want to broadcast one message to multiple components.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`single_assignment`</ph> class.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This example sends three values to a <ph id="ph1">`single_assignment`</ph> object and then reads the current value from the same object three times.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This example is similar to the example for the <ph id="ph1">`overwrite_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Although both the <ph id="ph1">`overwrite_buffer`</ph> and <ph id="ph2">`single_assignment`</ph> classes store a single message, the <ph id="ph3">`single_assignment`</ph> class can be written to one time only.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>concrt-single_assignment-structure#1</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`single_assignment`</ph> class, see <bpt id="p1">[</bpt>Walkthrough: Implementing Futures<ept id="p1">](../../parallel/concrt/walkthrough-implementing-futures.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>call Class</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::call<ept id="p1">](../../parallel/concrt/reference/call-class.md)</ept> class acts as a message receiver that performs a work function when it receives data.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This work function can be a lambda expression, a function object, or a function pointer.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`call`</ph> object behaves differently than an ordinary function call because it acts in parallel to other components that send messages to it.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">`call`</ph> object is performing work when it receives a message, it adds that message to a queue.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Every <ph id="ph1">`call`</ph> object processes queued messages in the order in which they are received.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`call`</ph> class.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This example creates a <ph id="ph1">`call`</ph> object that prints each value that it receives to the console.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The example then sends three values to the <ph id="ph1">`call`</ph> object.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`call`</ph> object processes messages on a separate thread, this example also uses a counter variable and an <bpt id="p1">[</bpt>event<ept id="p1">](../../parallel/concrt/reference/event-class.md)</ept> object to ensure that the <ph id="ph2">`call`</ph> object processes all messages before the <ph id="ph3">`wmain`</ph> function returns.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>concrt-call-structure#1</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`call`</ph> class, see <bpt id="p1">[</bpt>How to: Provide Work Functions to the call and transformer Classes<ept id="p1">](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>transformer Class</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::transformer<ept id="p1">](../../parallel/concrt/reference/transformer-class.md)</ept> class acts as both a message receiver and as a message sender.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`transformer`</ph> class resembles the <ph id="ph2">`call`</ph> class because it performs a user-defined work function when it receives data.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`transformer`</ph> class also sends the result of the work function to receiver objects.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Like a <ph id="ph1">`call`</ph> object, a <ph id="ph2">`transformer`</ph> object acts in parallel to other components that send messages to it.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">`transformer`</ph> object is performing work when it receives a message, it adds that message to a queue.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Every <ph id="ph1">`transformer`</ph> object processes its queued messages in the order in which they are received.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`transformer`</ph> class sends its message to one target.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you set the <ph id="ph1">`_PTarget`</ph> parameter in the constructor to <ph id="ph2">`NULL`</ph>, you can later specify the target by calling the <bpt id="p1">[</bpt>concurrency::link_target<ept id="p1">](reference/source-block-class.md#link_target)</ept> method.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Unlike all other asynchronous message block types that are provided by the Agents Library, the <ph id="ph1">`transformer`</ph> class can act on different input and output types.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This ability to transform data from one type to another makes the <ph id="ph1">`transformer`</ph> class a key component in many concurrent networks.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In addition, you can add more fine-grained parallel functionality in the work function of a <ph id="ph1">`transformer`</ph> object.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`transformer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This example creates a <ph id="ph1">`transformer`</ph> object that multiples each input <ph id="ph2">`int`</ph> value by 0.33 in order to produce a <ph id="ph3">`double`</ph> value as output.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The example then receives the transformed values from the same <ph id="ph1">`transformer`</ph> object and prints them to the console.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>concrt-transformer-structure#1</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`transformer`</ph> class, see <bpt id="p1">[</bpt>How to: Use transformer in a Data Pipeline<ept id="p1">](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>choice Class</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::choice<ept id="p1">](../../parallel/concrt/reference/choice-class.md)</ept> class selects the first available message from a set of sources.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`choice`</ph> class represents a control-flow mechanism instead of a dataflow mechanism (the topic <bpt id="p1">[</bpt>Asynchronous Agents Library<ept id="p1">](../../parallel/concrt/asynchronous-agents-library.md)</ept> describes the differences between dataflow and control-flow).</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Reading from a choice object resembles calling the Windows API function <ph id="ph1">`WaitForMultipleObjects`</ph> when it has the <ph id="ph2">`bWaitAll`</ph> parameter set to <ph id="ph3">`FALSE`</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`choice`</ph> class binds data to the event itself instead of to an external synchronization object.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Typically, you use the <ph id="ph1">`choice`</ph> class together with the <bpt id="p1">[</bpt>concurrency::receive<ept id="p1">](reference/concurrency-namespace-functions.md#receive)</ept> function to drive control-flow in your application.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`choice`</ph> class when you have to select among message buffers that have different types.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`single_assignment`</ph> class when you have to select among message buffers that have the same type.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The order in which you link sources to a <ph id="ph1">`choice`</ph> object is important because it can determine which message is selected.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For example, consider the case where you link multiple message buffers that already contain a message to a <ph id="ph1">`choice`</ph> object.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`choice`</ph> object selects the message from the first source that it is linked to.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>After you link all sources, the <ph id="ph1">`choice`</ph> object preserves the order in which each source receives a message.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`choice`</ph> class.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>This example uses the <bpt id="p1">[</bpt>concurrency::make_choice<ept id="p1">](reference/concurrency-namespace-functions.md#make_choice)</ept> function to create a <ph id="ph1">`choice`</ph> object that selects among three message blocks.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The example then computes various Fibonacci numbers and stores each result in a different message block.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The example then prints to the console a message that is based on the operation that finished first.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>concrt-choice-structure#1</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>This example produces the following sample output:</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Because the task that computes the 35<ph id="ph1">&lt;sup&gt;</ph>th<ph id="ph2">&lt;/sup&gt;</ph> Fibonacci number is not guaranteed to finish first, the output of this example can vary.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This example uses the <bpt id="p1">[</bpt>concurrency::parallel_invoke<ept id="p1">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm to compute the Fibonacci numbers in parallel.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`parallel_invoke`</ph>, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`choice`</ph> class, see <bpt id="p1">[</bpt>How to: Select Among Completed Tasks<ept id="p1">](../../parallel/concrt/how-to-select-among-completed-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>join and multitype_join Classes</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::join<ept id="p1">](../../parallel/concrt/reference/join-class.md)</ept> and <bpt id="p2">[</bpt>concurrency::multitype_join<ept id="p2">](../../parallel/concrt/reference/multitype-join-class.md)</ept> classes let you wait for each member of a set of sources to receive a message.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`join`</ph> class acts on source objects that have a common message type.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`multitype_join`</ph> class acts on source objects that can have different message types.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Reading from a <ph id="ph1">`join`</ph> or <ph id="ph2">`multitype_join`</ph> object resembles calling the Windows API function <ph id="ph3">`WaitForMultipleObjects`</ph> when it has the <ph id="ph4">`bWaitAll`</ph> parameter set to <ph id="ph5">`TRUE`</ph>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>However, just like a <ph id="ph1">`choice`</ph> object, <ph id="ph2">`join`</ph> and <ph id="ph3">`multitype_join`</ph> objects use an event mechanism that binds data to the event itself instead of to an external synchronization object.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Reading from a <ph id="ph1">`join`</ph> object produces a std::<bpt id="p1">[</bpt>vector<ept id="p1">](../../standard-library/vector-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Reading from a <ph id="ph1">`multitype_join`</ph> object produces a std::<bpt id="p1">[</bpt>tuple<ept id="p1">](../../standard-library/tuple-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Elements appear in these objects in the same order as their corresponding source buffers are linked to the <ph id="ph1">`join`</ph> or <ph id="ph2">`multitype_join`</ph> object.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Because the order in which you link source buffers to a <ph id="ph1">`join`</ph> or <ph id="ph2">`multitype_join`</ph> object is associated with the order of elements in the resulting <ph id="ph3">`vector`</ph> or <ph id="ph4">`tuple`</ph> object, we recommend that you do not unlink an existing source buffer from a join.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Doing so can result in unspecified behavior.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Greedy Versus Non-Greedy Joins</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`join`</ph> and <ph id="ph2">`multitype_join`</ph> classes support the concept of greedy and non-greedy joins.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>greedy join<ept id="p1">*</ept> accepts a message from each of its sources as messages become available until all message are available.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>non-greedy join<ept id="p1">*</ept> receives messages in two phases.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>First, a non-greedy join waits until it is offered a message from each of its sources.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Second, after all source messages are available, a non-greedy join attempts to reserve each of those messages.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If it can reserve each message, it consumes all messages and propagates them to its target.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Greedy joins perform better than non-greedy joins because they accept messages immediately.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>However, in rare cases, greedy joins can lead to deadlocks.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Use a non-greedy join when you have multiple joins that contain one or more shared source objects.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`join`</ph> class.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>This example uses the <bpt id="p1">[</bpt>concurrency::make_join<ept id="p1">](reference/concurrency-namespace-functions.md#make_join)</ept> function to create a <ph id="ph1">`join`</ph> object that receives from three <ph id="ph2">`single_assignment`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>This example computes various Fibonacci numbers, stores each result in a different <ph id="ph1">`single_assignment`</ph> object, and then prints to the console each result that the <ph id="ph2">`join`</ph> object holds.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>This example is similar to the example for the <ph id="ph1">`choice`</ph> class, except that the <ph id="ph2">`join`</ph> class waits for all source message blocks to receive a message.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>concrt-join-structure#1</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>This example uses the <bpt id="p1">[</bpt>concurrency::parallel_invoke<ept id="p1">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm to compute the Fibonacci numbers in parallel.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`parallel_invoke`</ph>, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>For complete examples that show how to use the <ph id="ph1">`join`</ph> class, see <bpt id="p1">[</bpt>How to: Select Among Completed Tasks<ept id="p1">](../../parallel/concrt/how-to-select-among-completed-tasks.md)</ept> and <bpt id="p2">[</bpt>Walkthrough: Using join to Prevent Deadlock<ept id="p2">](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>timer Class</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The concurrency::<bpt id="p1">[</bpt>timer class<ept id="p1">](../../parallel/concrt/reference/timer-class.md)</ept> acts as a message source.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`timer`</ph> object sends a message to a target after a specified period of time has elapsed.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`timer`</ph> class is useful when you must delay sending a message or you want to send a message at a regular interval.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`timer`</ph> class sends its message to just one target.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>If you set the <ph id="ph1">`_PTarget`</ph> parameter in the constructor to <ph id="ph2">`NULL`</ph>, you can later specify the target by calling the <bpt id="p1">[</bpt>concurrency::ISource::link_target<ept id="p1">](reference/source-block-class.md#link_target)</ept> method.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`timer`</ph> object can be repeating or non-repeating.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>To create a repeating timer, pass <ph id="ph1">`true`</ph> for the <ph id="ph2">`_Repeating`</ph> parameter when you call the constructor.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Otherwise, pass <ph id="ph1">`false`</ph> for the <ph id="ph2">`_Repeating`</ph> parameter to create a non-repeating timer.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>If the timer is repeating, it sends the same message to its target after each interval.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The Agents Library creates <ph id="ph1">`timer`</ph> objects in the non-started state.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>To start a timer object, call the <bpt id="p1">[</bpt>concurrency::timer::start<ept id="p1">](reference/timer-class.md#start)</ept> method.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>To stop a <ph id="ph1">`timer`</ph> object, destroy the object or call the <bpt id="p1">[</bpt>concurrency::timer::stop<ept id="p1">](reference/timer-class.md#stop)</ept> method.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>To pause a repeating timer, call the <bpt id="p1">[</bpt>concurrency::timer::pause<ept id="p1">](reference/timer-class.md#pause)</ept> method.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The following example shows the basic structure of how to work with the <ph id="ph1">`timer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The example uses <ph id="ph1">`timer`</ph> and <ph id="ph2">`call`</ph> objects to report the progress of a lengthy operation.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>concrt-timer-structure#1</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>This example produces the following sample output:</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>For a complete example that shows how to use the <ph id="ph1">`timer`</ph> class, see <bpt id="p1">[</bpt>How to: Send a Message at a Regular Interval<ept id="p1">](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Message Filtering</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>When you create a message block object, you can supply a <bpt id="p1">*</bpt>filter function<ept id="p1">*</ept> that determines whether the message block accepts or rejects a message.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>A filter function is a useful way to guarantee that a message block receives only certain values.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The following example shows how to create an <ph id="ph1">`unbounded_buffer`</ph> object that uses a filter function to accept only even numbers.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`unbounded_buffer`</ph> object rejects odd numbers, and therefore does not propagate odd numbers to its target blocks.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>concrt-filter-function#1</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>A filter function can be a lambda function, a function pointer, or a function object.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Every filter function takes one of the following forms.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>To eliminate the unnecessary copying of data, use the second form when you have an aggregate type that is propagated by value.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Message filtering supports the <bpt id="p1">*</bpt>dataflow<ept id="p1">*</ept> programming model, in which components perform computations when they receive data.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>For examples that use filter functions to control the flow of data in a message passing network, see <bpt id="p1">[</bpt>How to: Use a Message Block Filter<ept id="p1">](../../parallel/concrt/how-to-use-a-message-block-filter.md)</ept>, <bpt id="p2">[</bpt>Walkthrough: Creating a Dataflow Agent<ept id="p2">](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)</ept>, and <bpt id="p3">[</bpt>Walkthrough: Creating an Image-Processing Network<ept id="p3">](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Message Reservation</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Message reservation<ept id="p1">*</ept> enables a message block to reserve a message for later use.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Typically, message reservation is not used directly.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>However, understanding message reservation can help you better understand the behavior of some of the predefined message block types.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Consider non-greedy and greedy joins.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Both of these use message reservation to reserve messages for later use.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>A described earlier, a non-greedy join receives messages in two phases.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>During the first phase, a non-greedy <ph id="ph1">`join`</ph> object waits for each of its sources to receive a message.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>A non-greedy join then attempts to reserve each of those messages.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>If it can reserve each message, it consumes all messages and propagates them to its target.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>A greedy join, which also reads input messages from a number of sources, uses message reservation to read additional messages while it waits to receive a message from each source.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>For example, consider a greedy join that receives messages from message blocks <ph id="ph1">`A`</ph> and <ph id="ph2">`B`</ph>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>If the greedy join receives two messages from B but has not yet received a message from <ph id="ph1">`A`</ph>, the greedy join saves the unique message identifier for the second message from <ph id="ph2">`B`</ph>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>After the greedy join receives a message from <ph id="ph1">`A`</ph> and propagates out these messages, it uses the saved message identifier to see if the second message from <ph id="ph2">`B`</ph> is still available.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>You can use message reservation when you implement your own custom message block types.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For an example about how to create a custom message block type, see <bpt id="p1">[</bpt>Walkthrough: Creating a Custom Message Block<ept id="p1">](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Asynchronous Agents Library</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>