<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2478d26d307ab6b572bb5eeb02d09e2c6492c9ae</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\nested-class-declarations.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b23fa976de9aafa26b4426d2f0a03588d0db2778</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">524a218cf1de29dda4044a45dfeb1749db724481</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>ested Class Declarations | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Nested Class Declarations</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A class can be declared within the scope of another class.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Such a class is called a "nested class."</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Nested classes are considered to be within the scope of the enclosing class and are available for use within that scope.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To refer to a nested class from a scope other than its immediate enclosing scope, you must use a fully qualified name.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following example shows how to declare nested classes:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>and <ph id="ph1">`BufferedIO::BufferedOutput`</ph> are declared within <ph id="ph2">`BufferedIO`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>These class names are not visible outside the scope of class <ph id="ph1">`BufferedIO`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>However, an object of type <ph id="ph1">`BufferedIO`</ph> does not contain any objects of types <ph id="ph2">`BufferedInput`</ph> or <ph id="ph3">`BufferedOutput`</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Nested classes can directly use names, type names, names of static members, and enumerators only from the enclosing class.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To use names of other class members, you must use pointers, references, or object names.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In the preceding <ph id="ph1">`BufferedIO`</ph> example, the enumeration <ph id="ph2">`IOError`</ph> can be accessed directly by member functions in the nested classes, <ph id="ph3">`BufferedIO::BufferedInput`</ph> or <ph id="ph4">`BufferedIO::BufferedOutput`</ph>, as shown in function <ph id="ph5">`good`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Nested classes declare only types within class scope.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>They do not cause contained objects of the nested class to be created.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The preceding example declares two nested classes but does not declare any objects of these class types.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>An exception to the scope visibility of a nested class declaration is when a type name is declared together with a forward declaration.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this case, the class name declared by the forward declaration is visible outside the enclosing class, with its scope defined to be the smallest enclosing non-class scope.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Access privilege in nested classes</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Nesting a class within another class does not give special access privileges to member functions of the nested class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Similarly, member functions of the enclosing class have no special access to members of the nested class.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Member functions in nested classes</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Member functions declared in nested classes can be defined in file scope.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The preceding example could have been written:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In the preceding example, the <bpt id="p1">*</bpt>qualified-type-name<ept id="p1">*</ept> syntax is used to declare the function name.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The declaration:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>means "the <ph id="ph1">`read`</ph> function that is a member of the <ph id="ph2">`BufferedInput`</ph> class that is in the scope of the <ph id="ph3">`BufferedIO`</ph> class."</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because this declaration uses the <bpt id="p1">*</bpt>qualified-type-name<ept id="p1">*</ept> syntax, constructs of the following form are possible:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The preceding declaration is equivalent to the previous one, but it uses a <ph id="ph1">`typedef`</ph> name in place of the class names.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Friend functions in nested classes</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Friend functions declared in a nested class are considered to be in the scope of the nested class, not the enclosing class.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Therefore, the friend functions gain no special access privileges to members or member functions of the enclosing class.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you want to use a name that is declared in a nested class in a friend function and the friend function is defined in file scope, use qualified type names as follows:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following code shows the function <ph id="ph1">`GetExtendedErrorStatus`</ph> declared as a friend function.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In the function, which is defined in file scope, a message is copied from a static array into a class member.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that a better implementation of <ph id="ph1">`GetExtendedErrorStatus`</ph> is to declare it as:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>With the preceding interface, several classes can use the services of this function by passing a memory location where they want the error message copied.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Classes and Structs</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>