<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2d60566582f8d2eea72745d574183b4e8a9e91cc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\align-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ab3c43b9f9bb15b8a86e9cf23a42372ddad3555a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c7680b2c18db8837dbb070ee8d01fc1912dc6591</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>align (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>align (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015 and later, use the C++11 standard <ph id="ph1">`alignas`</ph> specifier to control alignment.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Alignment<ept id="p1">](../cpp/alignment-cpp-declarations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`__declspec(align(#))`</ph> to precisely control the alignment of user-defined data (for example, static allocations or automatic data in a function).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Writing applications that use the latest processor instructions introduces some new constraints and issues.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In particular, many new instructions require that data must be aligned to 16-byte boundaries.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Additionally, by aligning frequently used data to the cache line size of a specific processor, you improve cache performance.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, if you define a structure whose size is less than 32 bytes, you may want to align it to 32 bytes to make sure that objects of that structure type are efficiently cached.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>is the alignment value.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Valid entries are integer powers of two from 1 to 8192 (bytes), such as 2, 4, 8, 16, 32, or 64.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>is the data that you are declaring as aligned.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For information about how to return a value of type <ph id="ph1">`size_t`</ph> that is the alignment requirement of the type, see <bpt id="p1">[</bpt>__alignof<ept id="p1">](../cpp/alignof-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For information about how to declare unaligned pointers when targeting 64-bit processors, see <bpt id="p1">[</bpt>__unaligned<ept id="p1">](../cpp/unaligned.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`__declspec(align(#))`</ph> when you define a <ph id="ph2">`struct`</ph>, <ph id="ph3">`union`</ph>, or <ph id="ph4">`class`</ph>, or when you declare a variable.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The compiler does not guarantee or attempt to preserve the alignment attribute of data during a copy or data transform operation.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">[</bpt>memcpy<ept id="p1">](../c-runtime-library/reference/memcpy-wmemcpy.md)</ept> can copy a struct declared with <ph id="ph1">`__declspec(align(#))`</ph> to any location.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Note that ordinary allocators—for example, <bpt id="p1">[</bpt>malloc<ept id="p1">](../c-runtime-library/reference/malloc.md)</ept>, C++ <bpt id="p2">[</bpt>operator new<ept id="p2">](new-operator-cpp.md)</ept>, and the Win32 allocators—return memory that is usually not sufficiently aligned for <ph id="ph1">`__declspec(align(#))`</ph> structures or arrays of structures.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To guarantee that the destination of a copy or data transformation operation is correctly aligned, use <bpt id="p1">[</bpt>_aligned_malloc<ept id="p1">](../c-runtime-library/reference/aligned-malloc.md)</ept>, or write your own allocator.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You cannot specify alignment for function parameters.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When data that has an alignment attribute is passed by value on the stack, its alignment is controlled by the calling convention.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If data alignment is important in the called function, copy the parameter into correctly aligned memory before use.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Without <ph id="ph1">`__declspec(align(#))`</ph>, Visual C++ generally aligns data on natural boundaries based on the target processor and the size of the data, up to 4-byte boundaries on 32-bit processors, and 8-byte boundaries on 64-bit processors.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Data in classes or structures is aligned in the class or structure at the minimum of its natural alignment and the current packing setting (from #pragma <ph id="ph1">`pack`</ph> or the <bpt id="p1">**</bpt>/Zp<ept id="p1">**</ept> compiler option).</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of <ph id="ph1">`__declspec(align(#))`</ph>:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This type now has a 32-byte alignment attribute.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This means that all static and automatic instances start on a 32-byte boundary.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Additional structure types declared with this type as a member preserve this type's alignment attribute, that is, any structure with <ph id="ph1">`Str1`</ph> as an element will have an alignment attribute of at least 32.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`sizeof(struct Str1)`</ph> is equal to 32.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This implies that if an array of Str1 objects is created, and the base of the array is 32-byte aligned, each member of the array is also 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To create an array whose base is correctly aligned in dynamic memory, use <bpt id="p1">[</bpt>_aligned_malloc<ept id="p1">](../c-runtime-library/reference/aligned-malloc.md)</ept>, or write your own allocator.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`sizeof`</ph> value for any structure is the offset of the final member, plus that member's size, rounded up to the nearest multiple of the largest member alignment value or the whole structure alignment value, whichever is larger.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The compiler uses these rules for structure alignment:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Unless overridden with <ph id="ph1">`__declspec(align(#))`</ph>, the alignment of a scalar structure member is the minimum of its size and the current packing.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Unless overridden with <ph id="ph1">`__declspec(align(#))`</ph>, the alignment of a structure is the maximum of the individual alignments of its member(s).</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A structure member is placed at an offset from the start of its parent structure which is the smallest multiple of its alignment greater than or equal to the offset of the end of the previous member.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The size of a structure is the smallest multiple of its alignment greater than or equal to the offset of the end of its last member.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>can only increase alignment restrictions.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>align Examples</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Defining New Types with __declspec(align(#))</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Aligning Data in Thread Local Storage</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>How align Works with Data Packing</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Examples of Structure Alignment<ept id="p1">](../build/examples-of-structure-alignment.md)</ept> (x64 specific)</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>align Examples</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following examples show how <ph id="ph1">`__declspec(align(#))`</ph> affects the size and alignment of data structures.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The examples assume the following definitions:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In this example, the <ph id="ph1">`S1`</ph> structure is defined by using <ph id="ph2">`__declspec(align(32))`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>All uses of <ph id="ph1">`S1`</ph> for a variable definition or in other type declarations are 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>returns 32, and <ph id="ph1">`S1`</ph> has 16 padding bytes following the 16 bytes required to hold the four integers.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">`int`</ph> member requires 4-byte alignment, but the alignment of the structure itself is declared to be 32.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Therefore, the overall alignment is 32.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`sizeof(struct S2)`</ph> returns 16, which is exactly the sum of the member sizes, because that is a multiple of the largest alignment requirement (a multiple of 8).</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`sizeof(struct S3)`</ph> returns 64.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, notice that <ph id="ph1">`a`</ph> has the alignment of its natural type, in this case, 4 bytes.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`S1`</ph> must be 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Twenty-eight bytes of padding follow <ph id="ph1">`a`</ph>, so that <ph id="ph2">`s1`</ph> starts at offset 32.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>then inherits the alignment requirement of <ph id="ph1">`S1`</ph>, because it is the largest alignment requirement in the structure.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>returns 64.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The following three variable declarations also use <ph id="ph1">`__declspec(align(#))`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In each case, the variable must be 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In the case of the array, the base address of the array, not each array member, is 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`sizeof`</ph> value for each array member is not affected when you use <ph id="ph2">`__declspec(align(#))`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To align each member of an array, code such as this should be used:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this example, notice that aligning the structure itself and aligning the first element have the same effect:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>and <ph id="ph1">`S7`</ph> have identical alignment, allocation, and size characteristics.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this example, the alignment of the starting addresses of a, b, c, and d are 4, 1, 4, and 1, respectively.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The alignment when memory is allocated on the heap depends on which allocation function is called.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, if you use <ph id="ph1">`malloc`</ph>, the result depends on the operand size.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>arg<ept id="p1">*</ept> &gt;= 8, the memory returned is 8 byte aligned.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>arg<ept id="p1">*</ept> &lt; 8, the alignment of the memory returned is the first power of 2 less than <bpt id="p2">*</bpt>arg<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, if you use malloc(7), the alignment is 4 bytes.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Defining New Types with __declspec(align(#))</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can define a type with an alignment characteristic.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, you can define a <ph id="ph1">`struct`</ph> with an alignment value this way:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Now, <ph id="ph1">`aType`</ph> and <ph id="ph2">`bType`</ph> are the same size (8 bytes) but variables of type <ph id="ph3">`bType`</ph> will be 32-byte aligned.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Aligning Data in Thread Local Storage</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Static thread-local storage (TLS) created with the <ph id="ph1">`__declspec(thread)`</ph> attribute and put in the TLS section in the image works for alignment exactly like normal static data.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>To create TLS data, the operating system allocates memory the size of the TLS section and respects the TLS section alignment attribute.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This example shows various ways to place aligned data into thread local storage.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>How align Works with Data Packing</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/Zp<ept id="p1">**</ept> compiler option and the <ph id="ph1">`pack`</ph> pragma have the effect of packing data for structure and union members.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This example shows how <bpt id="p1">**</bpt>/Zp<ept id="p1">**</ept> and <ph id="ph1">`__declspec(align(#))`</ph> work together:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following table lists the offset of each member under a variety of <bpt id="p1">**</bpt>/Zp<ept id="p1">**</ept> (or #pragma <ph id="ph1">`pack`</ph>) values, showing how the two interact.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Variable</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>/Zp1</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>/Zp2</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>/Zp4</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>/Zp8</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>a</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>b</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>c</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>3</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>4</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>4</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>8</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>d</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>40</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>40</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>40</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>40</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>f</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>41</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>42</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>44</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>48</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>sizeof(S)</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>64</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>64</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>64</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>64</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/Zp (Struct Member Alignment)<ept id="p1">](../build/reference/zp-struct-member-alignment.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The offset of an object is based on the offset of the previous object and the current packing setting, unless the object has a <ph id="ph1">`__declspec(align(#))`</ph> attribute, in which case the alignment is based on the offset of the previous object and the <ph id="ph2">`__declspec(align(#))`</ph> value for the object.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>__declspec</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Overview of ARM ABI Conventions</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Overview of x64 Calling Conventions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>