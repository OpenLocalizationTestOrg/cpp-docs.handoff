<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5f9f544c0d44c975c487d692f49671a8309743bf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\preprocessor\hash-import-directive-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e2b6b5f24694cec099e0fb0fd3a5e454a61694d2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef37cefe42db49e6b7a7a67663c51af8a1b87b28</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>import Directive (C++) | Microsoft Doc</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>import Directive (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ Specific</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Used to incorporate information from a type library.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The content of the type library is converted into C++ classes, mostly describing the COM interfaces.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>filename</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Specifies the type library to import.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>can be one of the following:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The name of a file that contains a type library, such as an .olb, .tlb, or .dll file.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The keyword, <bpt id="p1">**</bpt>file:<ept id="p1">**</ept>, can precede each filename.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The progid of a control in the type library.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The keyword, <bpt id="p1">**</bpt>progid:<ept id="p1">**</ept>, can precede each progid.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more on progids, see <bpt id="p1">[</bpt>Specifying the Localization ID and Version Number<ept id="p1">](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Note that when compiling with a cross compiler on a 64-bit operating system, the compiler will be able to read only the 32-bit registry hive.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You might want to use the native 64-bit compiler to build and register a 64-bit type library.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The library ID of the type library.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The keyword, <bpt id="p1">**</bpt>libid:<ept id="p1">**</ept>, can precede each library ID.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If you do not specify version or lcid, the <bpt id="p1">[</bpt>rules<ept id="p1">](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)</ept> that are applied to <bpt id="p2">**</bpt>progid:<ept id="p2">**</ept> are also applied to <bpt id="p3">**</bpt>libid:<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>An executable (.exe) file.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A library (.dll) file containing a type library resource (such as .ocx).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A compound document holding a type library.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Any other file format that can be understood by the <bpt id="p1">**</bpt>LoadTypeLib<ept id="p1">**</ept> API.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>One or more <bpt id="p1">[</bpt>#import attributes<ept id="p1">](#_predir_the_23import_directive_import_attributes)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Separate attributes with either a space or comma.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Search Order for filename</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>filename<ept id="p1">*</ept> is optionally preceded by a directory specification.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The file name must name an existing file.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The difference between the two syntax forms is the order in which the preprocessor searches for the type library files when the path is incompletely specified.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Syntax form</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Action</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Quoted form</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Instructs the preprocessor to look for type library files first in the directory of the file that contains the <ph id="ph1">`#import`</ph> statement, and then in the directories of whatever files that include (<ph id="ph2">`#include`</ph>) that file.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The preprocessor then searches along the paths shown below.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Angle-bracket form</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Instructs the preprocessor to search for type library files along the following paths:</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>1.  The <bpt id="p1">**</bpt>PATH<ept id="p1">**</ept> environment variable path list</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>2.  The <bpt id="p1">**</bpt>LIB<ept id="p1">**</ept> environment variable path list</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>3.  The path specified by the /I (additional include directories) compiler option, except it the compiler is searching for a type library that was referenced from another type library with the <bpt id="p1">[</bpt>no_registry<ept id="p1">](../preprocessor/no-registry.md)</ept> attribute.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Specifying the Localization ID and Version Number</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>When you specify a progid, you can also specify the localization ID and version number of the progid.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If you do not specify a localization ID, a progid is chosen according to the following rules:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If there is only one localization ID, that one is used.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If there is more than one localization ID, the first one with version number 0, 9, or 409 is used.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If there is more than one localization ID and none of them are 0, 9, or 409, the last one is used.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If you do not specify a version number, the most recent version is used.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Header Files Created by Import</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>creates two header files that reconstruct the type library contents in C++ source code.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The primary header file is similar to that produced by the Microsoft Interface Definition Language (MIDL) compiler, but with additional compiler-generated code and data.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>primary header file<ept id="p1">](#_predir_the_primary_type_library_header_file)</ept> has the same base name as the type library, plus a .TLH extension.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The secondary header file has the same base name as the type library, with a .TLI extension.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It contains the implementations for compiler-generated member functions, and is included (<ph id="ph1">`#include`</ph>) in the primary header file.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If importing a dispinterface property that uses byref parameters, #import will not generate __declspec(<bpt id="p1">[</bpt>property<ept id="p1">](../cpp/property-cpp.md)</ept>) statement for the function.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Both header files are placed in the output directory specified by the /Fo (name object file) option.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>They are then read and compiled by the compiler as if the primary header file was named by a <ph id="ph1">`#include`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The following compiler optimizations come with the <ph id="ph1">`#import`</ph> directive:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The header file, when created, is given the same timestamp as the type library.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`#import`</ph> is processed, the compiler first checks if the header exists and is up to date.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If yes, then it does not need to be re-created.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`#import`</ph> directive also participates in minimal rebuild and can be placed in a precompiled header file.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Creating Precompiled Header Files<ept id="p1">](../build/reference/creating-precompiled-header-files.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Primary Type Library Header File</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The primary type library header file consists of seven sections:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Heading boilerplate: Consists of comments, <ph id="ph1">`#include`</ph> statement for COMDEF.H (which defines some standard macros used in the header), and other miscellaneous setup information.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Forward references and typedefs: Consists of structure declarations such as <ph id="ph1">`struct IMyInterface`</ph> and typedefs.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Smart pointer declarations: The template class <ph id="ph1">`_com_ptr_t`</ph> is a smart-pointer implementation that encapsulates interface pointers and eliminates the need to call <ph id="ph2">`AddRef`</ph>, <bpt id="p1">**</bpt>Release<ept id="p1">**</ept>, <ph id="ph3">`QueryInterface`</ph> functions.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In addition, it hides the <ph id="ph1">`CoCreateInstance`</ph> call in creating a new COM object.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This section uses macro statement <bpt id="p1">**</bpt>_COM_SMARTPTR_TYPEDEF<ept id="p1">**</ept> to establish typedefs of COM interfaces to be template specializations of the <bpt id="p2">[</bpt>_com_ptr_t<ept id="p2">](../cpp/com-ptr-t-class.md)</ept> template class.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For example, for interface <bpt id="p1">**</bpt>IMyInterface<ept id="p1">**</ept>, the .TLH file will contain:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>which the compiler will expand to:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`IMyInterfacePtr`</ph> can then be used in place of the raw interface pointer <ph id="ph2">`IMyInterface*`</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Consequently, there is no need to call the various <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> member functions</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Typeinfo declarations: Primarily consists of class definitions and other items exposing the individual typeinfo items returned by <bpt id="p1">**</bpt>ITypeLib:GetTypeInfo<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In this section, each typeinfo from the type library is reflected in the header in a form dependent on the <ph id="ph1">`TYPEKIND`</ph> information.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Optional old-style GUID definition: Contains initializations of the named GUID constants.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>These are names of the form <bpt id="p1">**</bpt>CLSID_CoClass<ept id="p1">**</ept> and <bpt id="p2">**</bpt>IID_Interface<ept id="p2">**</ept>, similar to those generated by the MIDL compiler.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>statement for the secondary type library header.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Footer boilerplate: Currently includes <ph id="ph1">`#pragma pack(pop)`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>All sections, except the heading boilerplate and footer boilerplate section, are enclosed in a namespace with its name specified by the <bpt id="p1">**</bpt>library<ept id="p1">**</ept> statement in the original IDL file.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You can use the names from the type library header either by an explicit qualification with the namespace name or by including the following statement:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>immediately after the <ph id="ph1">`#import`</ph> statement in the source code.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The namespace can be suppressed by using the <bpt id="p1">[</bpt>no_namespace<ept id="p1">](#_predir_no_namespace)</ept> attribute of the <ph id="ph1">`#import`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, suppressing the namespace may lead to name collisions.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The namespace can also be renamed by the <bpt id="p1">[</bpt>rename_namespace<ept id="p1">](#_predir_rename_namespace)</ept> attribute.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The compiler provides the full path to any type library dependency required by the type library it is currently processing.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The path is written, in the form of comments, into the type library header (.TLH) that the compiler generates for each processed type library.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If a type library includes references to types defined in other type libraries, then the .TLH file will include comments of the following sort:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The actual filename in the <ph id="ph1">`#import`</ph> comment is the full path of the cross-referenced type library, as stored in the registry.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If you encounter errors that are due to missing type definitions, check the comments at the head of the .TLH to see which dependent type libraries may need to be imported first.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Likely errors are syntax errors (for example, C2143, C2146, C2321), C2501 (missing decl-specifiers), or C2433 ('inline' not permitted on data declaration) while compiling the .TLI file.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You must determine which of the dependency comments are not otherwise provided for by system headers and then provide an <ph id="ph1">`#import`</ph> directive at some point before the <ph id="ph2">`#import`</ph> directive of the dependent type library to resolve the errors.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information, see the Knowledge Base article "#import Wrapper Methods May Cause Access Violation" (Q242527) or "Compiler Errors When You Use #import with XML" (Q269194).</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can find Knowledge Base articles on the MSDN Library media or at <bpt id="p1">[</bpt>http://support.microsoft.com/support/<ept id="p1">](http://support.microsoft.com/support/)</ept>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>import Attributes</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>can optionally include one or more attributes.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These attributes tell the compiler to modify the contents of the type-library headers.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A backslash (<bpt id="p1">**</bpt><ph id="ph1">\\</ph><ept id="p1">**</ept>) symbol can be used to include additional lines in a single <ph id="ph2">`#import`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>#import Attributes<ept id="p1">](../preprocessor/hash-import-attributes-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>END C++ Specific</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Preprocessor Directives</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Compiler COM Support</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>