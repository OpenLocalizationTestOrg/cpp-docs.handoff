<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4d53ed37aba46d4dbdfc9b5df1689aae4f7650ac</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\casyncsocket-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f104c4fba930c2f505d10ba820f1aed754519fae</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd0e1f564157d504bf0f1b72acabd5e0ace05f22</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CAsyncSocket Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CAsyncSocket Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Represents a Windows Socket â€” an endpoint of network communication.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::CAsyncSocket</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Accept</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the socket.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::AsyncSelect</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Requests event notification for the socket.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Attach</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Attaches a socket handle to a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Bind</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Associates a local address with the socket.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Close</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Closes the socket.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Connect</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a peer socket.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Create</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Creates a socket.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Detach</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Detaches a socket handle from a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::FromHandle</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a <ph id="ph1">`CAsyncSocket`</ph> object, given a socket handle.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetLastError</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Gets the error status for the last operation that failed.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetPeerName</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Gets the address of the peer socket to which the socket is connected.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetPeerNameEx</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Gets the address of the peer socket to which the socket is connected (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockName</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Gets the local name for a socket.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockNameEx</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Gets the local name for a socket (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockOpt</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Retrieves a socket option.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::IOCtl</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Controls the mode of the socket.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Listen</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Establishes a socket to listen for incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Receive</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Receives data from the socket.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ReceiveFrom</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Receives a datagram and stores the source address.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ReceiveFromEx</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Receives a datagram and stores the source address (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Send</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Sends data to a connected socket.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SendTo</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Sends data to a specific destination.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SendToEx</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Sends data to a specific destination (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SetSockOpt</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Sets a socket option.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ShutDown</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Disables <bpt id="p1">**</bpt>Send<ept id="p1">**</ept> and/or <bpt id="p2">**</bpt>Receive<ept id="p2">**</ept> calls on the socket.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>CASyncSocket::Socket</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Allocates a socket handle.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Protected Methods</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnAccept</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Notifies a listening socket that it can accept pending connection requests by calling <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnClose</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Notifies a socket that the socket connected to it has closed.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnConnect</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Notifies a connecting socket that the connection attempt is complete, whether successfully or in error.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnOutOfBandData</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Notifies a receiving socket that there is out-of-band data to be read on the socket, usually an urgent message.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnReceive</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Notifies a listening socket that there is data to be retrieved by calling <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnSend</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Notifies a socket that it can send data by calling <bpt id="p1">**</bpt>Send<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Public Operators</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::operator =</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::operator SOCKET</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Use this operator to retrieve the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle of the <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Public Data Members</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::m_hSocket</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Indicates the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle attached to this <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Class <ph id="ph1">`CAsyncSocket`</ph> encapsulates the Windows Socket Functions API, providing an object-oriented abstraction for programmers who want to use Windows Sockets in conjunction with MFC.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This class is based on the assumption that you understand network communications.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You are responsible for handling blocking, byte-order differences, and conversions between Unicode and multibyte character set (MBCS) strings.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you want a more convenient interface that manages these issues for you, see class <bpt id="p1">[</bpt>CSocket<ept id="p1">](../../mfc/reference/csocket-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To use a <ph id="ph1">`CAsyncSocket`</ph> object, call its constructor, then call the <bpt id="p1">[</bpt>Create<ept id="p1">](#casyncsocket__create)</ept> function to create the underlying socket handle (type <ph id="ph2">`SOCKET`</ph>), except on accepted sockets.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For a server socket call the <bpt id="p1">[</bpt>Listen<ept id="p1">](#casyncsocket__listen)</ept> member function, and for a client socket call the <bpt id="p2">[</bpt>Connect<ept id="p2">](#casyncsocket__connect)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The server socket should call the <bpt id="p1">[</bpt>Accept<ept id="p1">](#casyncsocket__accept)</ept> function upon receiving a connection request.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Use the remaining <ph id="ph1">`CAsyncSocket`</ph> functions to carry out communications between sockets.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Upon completion, destroy the <ph id="ph1">`CAsyncSocket`</ph> object if it was created on the heap; the destructor automatically calls the <bpt id="p1">[</bpt>Close<ept id="p1">](#casyncsocket__close)</ept> function.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SOCKET`</ph> data type is described in the article <bpt id="p1">[</bpt>Windows Sockets: Background<ept id="p1">](../../mfc/windows-sockets-background.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>When using MFC sockets in secondary threads in a statically linked MFC application, you must call <ph id="ph1">`AfxSocketInit`</ph> in each thread that uses sockets to initialize the socket libraries.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`AfxSocketInit`</ph> is called only in the primary thread.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Class CAsyncSocket<ept id="p1">](../../mfc/windows-sockets-using-class-casyncsocket.md)</ept> and related articles., as well as <bpt id="p2">[</bpt>Windows Sockets 2 API<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>CObject</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> afxsock.h</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Accept</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Call this member function to accept a connection on a socket.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A reference identifying a new socket that is available for connection.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the address of the connecting socket, as known on the network.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The exact format of the <ph id="ph1">`lpSockAddr`</ph> argument is determined by the address family established when the socket was created.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`lpSockAddr`</ph> and/or <ph id="ph2">`lpSockAddrLen`</ph> are equal to <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, then no information about the remote address of the accepted socket is returned.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A pointer to the length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`lpSockAddrLen`</ph> is a value-result parameter: it should initially contain the amount of space pointed to by <ph id="ph2">`lpSockAddr`</ph>; on return it will contain the actual length (in bytes) of the address returned.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is too small (less than the size of a <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure).</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets call is in progress.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> <ph id="ph1">`Listen`</ph> was not invoked prior to accept.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMFILE<ept id="p1">**</ept> The queue is empty upon entry to accept and there are no descriptors available.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>No buffer space is available.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP<ept id="p1">**</ept> The referenced socket is not a type that supports connection-oriented service.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and no connections are present to be accepted.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This routine extracts the first connection in the queue of pending connections, creates a new socket with the same properties as this socket, and attaches it to <ph id="ph1">`rConnectedSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If no pending connections are present on the queue, <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> returns zero and <ph id="ph1">`GetLastError`</ph> returns an error.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The accepted socket ( <bpt id="p1">*</bpt>rConnectedSocket)<ept id="p1">*</ept> cannot be used to accept more connections.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The original socket remains open and listening.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The argument <ph id="ph1">`lpSockAddr`</ph> is a result parameter that is filled in with the address of the connecting socket, as known to the communications layer.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> is used with connection-based socket types such as <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::AsyncSelect</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Call this member function to request event notification for a socket.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A bitmask which specifies a combination of network events in which the application is interested.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_READ<ept id="p1">**</ept> Want to receive notification of readiness for reading.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_WRITE<ept id="p1">**</ept> Want to receive notification when data is available to be read.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_OOB<ept id="p1">**</ept> Want to receive notification of the arrival of out-of-band data.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_ACCEPT<ept id="p1">**</ept> Want to receive notification of incoming connections.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CONNECT<ept id="p1">**</ept> Want to receive notification of connection results.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CLOSE<ept id="p1">**</ept> Want to receive notification when a socket has been closed by a peer.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> Indicates that one of the specified parameters was invalid.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>This function is used to specify which MFC callback notification functions will be called for the socket.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>automatically sets this socket to nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Attach</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Call this member function to attach the <ph id="ph1">`hSocket`</ph> handle to an <ph id="ph2">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Contains a handle to a socket.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A bitmask which specifies a combination of network events in which the application is interested.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_READ<ept id="p1">**</ept> Want to receive notification of readiness for reading.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_WRITE<ept id="p1">**</ept> Want to receive notification when data is available to be read.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_OOB<ept id="p1">**</ept> Want to receive notification of the arrival of out-of-band data.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_ACCEPT<ept id="p1">**</ept> Want to receive notification of incoming connections.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CONNECT<ept id="p1">**</ept> Want to receive notification of connection results.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CLOSE<ept id="p1">**</ept> Want to receive notification when a socket has been closed by a peer.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle is stored in the object's <bpt id="p2">[</bpt>m_hSocket<ept id="p2">](#casyncsocket__m_hsocket)</ept> data member.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Bind</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Call this member function to associate a local address with the socket.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The port identifying the socket application.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The network address, a dotted number such as "128.56.22.8".</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Passing the <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> string for this parameter indicates the <bpt id="p2">**</bpt>CAsyncSocket<ept id="p2">**</ept> instance should listen for client activity on all network interfaces.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address to assign to this socket.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRINUSE<ept id="p1">**</ept> The specified address is already in use.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>(See the <bpt id="p1">**</bpt>SO_REUSEADDR<ept id="p1">**</ept> socket option under <bpt id="p2">[</bpt>SetSockOpt<ept id="p2">](#casyncsocket__setsockopt)</ept>.)</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`nSockAddrLen`</ph> argument is too small (less than the size of a <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure).</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets call is in progress.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> The specified address family is not supported by this port.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket is already bound to an address.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Not enough buffers available, too many connections.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This routine is used on an unconnected datagram or stream socket, before subsequent <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> or <ph id="ph1">`Listen`</ph> calls.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Before it can accept connection requests, a listening server socket must select a port number and make it known to Windows Sockets by calling <bpt id="p1">**</bpt>Bind<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Bind<ept id="p1">**</ept> establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::CAsyncSocket</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Constructs a blank socket object.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>After constructing the object, you must call its <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> member function to create the <bpt id="p2">**</bpt>SOCKET<ept id="p2">**</ept> data structure and bind its address.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>(On the server side of a Windows Sockets communication, when the listening socket creates a socket to use in the <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> call, you do not call <bpt id="p2">**</bpt>Create<ept id="p2">**</ept> for that socket.)</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Close</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Closes the socket.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>This function releases the socket descriptor so that further references to it will fail with the error <bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>If this is the last reference to the underlying socket, the associated naming information and queued data are discarded.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The socket object's destructor calls <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> for you.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`CAsyncSocket`</ph>, but not for <ph id="ph2">`CSocket`</ph>, the semantics of <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> are affected by the socket options <bpt id="p2">**</bpt>SO_LINGER<ept id="p2">**</ept> and <bpt id="p3">**</bpt>SO_DONTLINGER<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For further information, see member function <ph id="ph1">`GetSockOpt`</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Connect</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Call this member function to establish a connection to an unconnected stream or datagram socket.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The network address of the socket to which this object is connected: a machine name such as "ftp.microsoft.com", or a dotted number such as "128.56.22.8".</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The port identifying the socket application.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address of the connected socket.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If this indicates an error code of <bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept>, and your application is using the overridable callbacks, your application will receive an <ph id="ph1">`OnConnect`</ph> message when the connect operation is complete.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRINUSE<ept id="p1">**</ept> The specified address is already in use.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets call is in progress.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRNOTAVAIL<ept id="p1">**</ept> The specified address is not available from the local machine.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> Addresses in the specified family cannot be used with this socket.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNREFUSED<ept id="p1">**</ept> The attempt to connect was rejected.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEDESTADDRREQ<ept id="p1">**</ept> A destination address is required.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`nSockAddrLen`</ph> argument is incorrect.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> Invalid host address.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEISCONN<ept id="p1">**</ept> The socket is already connected.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMFILE<ept id="p1">**</ept> No more file descriptors are available.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETUNREACH<ept id="p1">**</ept> The network cannot be reached from this host at this time.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>No buffer space is available.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The socket cannot be connected.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAETIMEDOUT<ept id="p1">**</ept> Attempt to connect timed out without establishing a connection.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the connection cannot be completed immediately.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Note that if the address field of the name structure is all zeroes, <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> will return zero.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>To get extended error information, call the <ph id="ph1">`GetLastError`</ph> member function.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>For stream sockets (type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>), an active connection is initiated to the foreign host.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>When the socket call completes successfully, the socket is ready to send/receive data.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>For a datagram socket (type <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept>), a default destination is set, which will be used on subsequent <bpt id="p2">**</bpt>Send<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Receive<ept id="p3">**</ept> calls.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Create</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> member function after constructing a socket object to create the Windows socket and attach it.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>A well-known port to be used with the socket, or 0 if you want Windows Sockets to select a port.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> **</bpt>SOCK_STREAM<ept id="p1">**</ept> or <bpt id="p2">**</bpt>SOCK_DGRAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A bitmask which specifies a combination of network events in which the application is interested.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_READ<ept id="p1">**</ept> Want to receive notification of readiness for reading.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_WRITE<ept id="p1">**</ept> Want to receive notification of readiness for writing.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_OOB<ept id="p1">**</ept> Want to receive notification of the arrival of out-of-band data.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_ACCEPT<ept id="p1">**</ept> Want to receive notification of incoming connections.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CONNECT<ept id="p1">**</ept> Want to receive notification of completed connection.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FD_CLOSE<ept id="p1">**</ept> Want to receive notification of socket closure.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>lpszSockAddress</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>A pointer to a string containing the network address of the connected socket, a dotted number such as "128.56.22.8".Passing the <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> string for this parameter indicates the <bpt id="p2">**</bpt>CAsyncSocket<ept id="p2">**</ept> instance should listen for client activity on all network interfaces.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> The specified address family is not supported.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMFILE<ept id="p1">**</ept> No more file descriptors are available.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>No buffer space is available.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The socket cannot be created.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEPROTONOSUPPORT<ept id="p1">**</ept> The specified port is not supported.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEPROTOTYPE<ept id="p1">**</ept> The specified port is the wrong type for this socket.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESOCKTNOSUPPORT<ept id="p1">**</ept> The specified socket type is not supported in this address family.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Create<ept id="p1">**</ept> calls <bpt id="p2">[</bpt>Socket<ept id="p2">](#casyncsocket__socket)</ept> and if successful, it calls <bpt id="p3">[</bpt>Bind<ept id="p3">](#casyncsocket__bind)</ept> to bind the socket to the specified address.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The following socket types are supported:</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> Provides sequenced, reliable, full-duplex, connection-based byte streams.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Uses the Transmission Control Protocol (TCP) for the Internet address family.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> Supports datagrams, which are connectionless, unreliable packets of a fixed (typically small) maximum length.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Uses the User Datagram Protocol (UDP) for the Internet address family.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> member function takes a reference to a new, empty <ph id="ph1">`CSocket`</ph> object as its parameter.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>You must construct this object before you call <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Keep in mind that if this socket object goes out of scope, the connection closes.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Do not call <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> for this new socket object.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Create<ept id="p1">**</ept> is <bpt id="p2">**</bpt>not<ept id="p2">**</ept> thread-safe.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>If you are calling it in a multi-threaded environment where it could be invoked simultaneously by different threads, be sure to protect each call with a mutex or other synchronization lock.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>For more information about stream and datagram sockets, see the articles <bpt id="p1">[</bpt>Windows Sockets: Background<ept id="p1">](../../mfc/windows-sockets-background.md)</ept> and <bpt id="p2">[</bpt>Windows Sockets: Ports and Socket Addresses<ept id="p2">](../../mfc/windows-sockets-ports-and-socket-addresses.md)</ept> and <bpt id="p3">[</bpt>Windows Sockets 2 API<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Detach</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Call this member function to detach the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle in the <ph id="ph1">`m_hSocket`</ph> data member from the <ph id="ph2">`CAsyncSocket`</ph> object and set <ph id="ph3">`m_hSocket`</ph> to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::FromHandle</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Contains a handle to a socket.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>A pointer to an <ph id="ph1">`CAsyncSocket`</ph> object, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> if there is no <ph id="ph2">`CAsyncSocket`</ph> object attached to <ph id="ph3">`hSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>When given a <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle, if a <ph id="ph1">`CAsyncSocket`</ph> object is not attached to the handle, the member function returns <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetLastError</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Call this member function to get the error status for the last operation that failed.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The return value indicates the error code for the last Windows Sockets API routine performed by this thread.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>When a particular member function indicates that an error has occurred, <ph id="ph1">`GetLastError`</ph> should be called to retrieve the appropriate error code.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>See the individual member function descriptions for a list of applicable error codes.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>For more information about the error codes, see <bpt id="p1">[</bpt>Windows Sockets 2 API<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetPeerName</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Call this member function to get the address of the peer socket to which this socket is connected.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>A pointer to the <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the name of the peer socket.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>A pointer to the length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>On return, the <ph id="ph1">`lpSockAddrLen`</ph> argument contains the actual size of <ph id="ph2">`lpSockAddr`</ph> returned in bytes.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is not large enough.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets call is in progress.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>To handle IPv6 addresses, use <bpt id="p1">[</bpt>CAsyncSocket::GetPeerNameEx<ept id="p1">](#casyncsocket__getpeernameex)</ept>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetPeerNameEx</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Call this member function to get the address of the peer socket to which this socket is connected (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is not large enough.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets call is in progress.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>This function is the same as <bpt id="p1">[</bpt>CAsyncSocket::GetPeerName<ept id="p1">](#casyncsocket__getpeername)</ept> except that it handles IPv6 addresses as well as older protocols.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockName</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Call this member function to get the local name for a socket.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the address of the socket.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A pointer to the length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is not large enough.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound to an address with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>This call is especially useful when a <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> call has been made without doing a <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept> first; this call provides the only means by which you can determine the local association which has been set by the system.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>To handle IPv6 addresses, use <bpt id="p1">[</bpt>CAsyncSocket::GetSockNameEx<ept id="p1">](#casyncsocket__getsocknameex)</ept></source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockNameEx</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Call this member function to get the local name for a socket (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is not large enough.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound to an address with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>This call is the same as <bpt id="p1">[</bpt>CAsyncSocket::GetSockName<ept id="p1">](#casyncsocket__getsockname)</ept> except that it handles IPv6 addresses as well as older protocols.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>This call is especially useful when a <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> call has been made without doing a <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept> first; this call provides the only means by which you can determine the local association which has been set by the system.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::GetSockOpt</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Call this member function to retrieve a socket option.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The socket option for which the value is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>A pointer to the buffer in which the value for the requested option is to be returned.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The value associated with the selected option is returned in the buffer <ph id="ph1">`lpOptionValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The integer pointed to by <ph id="ph1">`lpOptionLen`</ph> should originally contain the size of this buffer in bytes; and on return, it will be set to the size of the value returned.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">**</bpt>SO_LINGER<ept id="p1">**</ept>, this will be the size of a <ph id="ph1">`LINGER`</ph> structure; for all other options it will be the size of a <bpt id="p2">**</bpt>BOOL<ept id="p2">**</ept> or an <ph id="ph2">`int`</ph>, depending on the option.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>See the list of options and their sizes in the Remarks section.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>A pointer to the size of the <ph id="ph1">`lpOptionValue`</ph> buffer in bytes.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The level at which the option is defined; the only supported levels are <bpt id="p1">**</bpt>SOL_SOCKET<ept id="p1">**</ept> and <bpt id="p2">**</bpt>IPPROTO_TCP<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>If an option was never set with <ph id="ph1">`SetSockOpt`</ph>, then <ph id="ph2">`GetSockOpt`</ph> returns the default value for the option.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpOptionLen`</ph> argument was invalid.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOPROTOOPT<ept id="p1">**</ept> The option is unknown or unsupported.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>In particular, <bpt id="p1">**</bpt>SO_BROADCAST<ept id="p1">**</ept> is not supported on sockets of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>, while <bpt id="p3">**</bpt>SO_ACCEPTCONN<ept id="p3">**</ept>, <bpt id="p4">**</bpt>SO_DONTLINGER<ept id="p4">**</ept>, <bpt id="p5">**</bpt>SO_KEEPALIVE<ept id="p5">**</ept>, <bpt id="p6">**</bpt>SO_LINGER<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>SO_OOBINLINE<ept id="p7">**</ept> are not supported on sockets of type <bpt id="p8">**</bpt>SOCK_DGRAM<ept id="p8">**</ept>.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in <ph id="ph1">`lpOptionValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Options affect socket operations, such as the routing of packets, out-of-band data transfer, and so on.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The following options are supported for <ph id="ph1">`GetSockOpt`</ph>.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>The Type identifies the type of data addressed by <ph id="ph1">`lpOptionValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>TCP_NODELAY<ept id="p1">**</ept> option uses level <bpt id="p2">**</bpt>IPPROTO_TCP<ept id="p2">**</ept>; all other options use level <bpt id="p3">**</bpt>SOL_SOCKET<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>SO_ACCEPTCONN</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Socket is listening.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>SO_BROADCAST</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Socket is configured for the transmission of broadcast messages.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>SO_DEBUG</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Debugging is enabled.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>SO_DONTLINGER</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>If true, the <bpt id="p1">**</bpt>SO_LINGER<ept id="p1">**</ept> option is disabled.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>SO_DONTROUTE</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Routing is disabled.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>SO_ERROR</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Retrieve error status and clear.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>SO_KEEPALIVE</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Keep-alives are being sent.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>SO_LINGER</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>struct LINGER</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Returns the current linger options.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>SO_OOBINLINE</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Out-of-band data is being received in the normal data stream.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>SO_RCVBUF</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Buffer size for receives.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>SO_REUSEADDR</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The socket can be bound to an address which is already in use.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>SO_SNDBUF</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Buffer size for sends.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>SO_TYPE</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The type of the socket (for example, <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>TCP_NODELAY</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Disables the Nagle algorithm for send coalescing.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Berkeley Software Distribution (BSD) options not supported for <ph id="ph1">`GetSockOpt`</ph> are:</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>SO_RCVLOWAT</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Receive low water mark.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>SO_RCVTIMEO</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Receive timeout.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>SO_SNDLOWAT</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Send low water mark.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>SO_SNDTIMEO</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Send timeout.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Get options in IP header.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>TCP_MAXSEG</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>Get TCP maximum segment size.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`GetSockOpt`</ph> with an unsupported option will result in an error code of <bpt id="p1">**</bpt>WSAENOPROTOOPT<ept id="p1">**</ept> being returned from <ph id="ph2">`GetLastError`</ph>.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::IOCtl</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Call this member function to control the mode of a socket.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The command to perform on the socket.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>A pointer to a parameter for <ph id="ph1">`lCommand`</ph>.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> <ph id="ph1">`lCommand`</ph> is not a valid command, or <ph id="ph2">`lpArgument`</ph> is not an acceptable parameter for <ph id="ph3">`lCommand`</ph>, or the command is not applicable to the type of socket supplied.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>This routine can be used on any socket in any state.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>It is used to get or retrieve operating parameters associated with the socket, independent of the protocol and communications subsystem.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The following commands are supported:</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FIONBIO<ept id="p1">**</ept> Enable or disable nonblocking mode on the socket.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`lpArgument`</ph> parameter points at a <ph id="ph2">`DWORD`</ph>, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`AsyncSelect`</ph> has been issued on a socket, then any attempt to use <bpt id="p1">**</bpt>IOCtl<ept id="p1">**</ept> to set the socket back to blocking mode will fail with <bpt id="p2">**</bpt>WSAEINVAL<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>To set the socket back to blocking mode and prevent the <bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> error, an application must first disable <ph id="ph1">`AsyncSelect`</ph> by calling <ph id="ph2">`AsyncSelect`</ph> with the <ph id="ph3">`lEvent`</ph> parameter equal to 0, then call <bpt id="p2">**</bpt>IOCtl<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FIONREAD<ept id="p1">**</ept> Determine the maximum number of bytes that can be read with one <bpt id="p2">**</bpt>Receive<ept id="p2">**</ept> call from this socket.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`lpArgument`</ph> parameter points at a <ph id="ph2">`DWORD`</ph> in which <bpt id="p1">**</bpt>IOCtl<ept id="p1">**</ept> stores the result.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>If this socket is of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>, <bpt id="p2">**</bpt>FIONREAD<ept id="p2">**</ept> returns the total amount of data which can be read in a single <bpt id="p3">**</bpt>Receive<ept id="p3">**</ept>; this is normally the same as the total amount of data queued on the socket.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>If this socket is of type <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept>, <bpt id="p2">**</bpt>FIONREAD<ept id="p2">**</ept> returns the size of the first datagram queued on the socket.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SIOCATMARK<ept id="p1">**</ept> Determine whether all out-of-band data has been read.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>This applies only to a socket of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> which has been configured for in-line reception of any out-of-band data ( <bpt id="p2">**</bpt>SO_OOBINLINE<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>If no out-of-band data is waiting to be read, the operation returns nonzero.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Otherwise it returns 0, and the next <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> or <ph id="ph1">`ReceiveFrom`</ph> performed on the socket will retrieve some or all of the data preceding the "mark"; the application should use the <bpt id="p2">**</bpt>SIOCATMARK<ept id="p2">**</ept> operation to determine whether any data remains.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If there is any normal data preceding the "urgent" (out-of-band) data, it will be received in order.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>(Note that a <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> or <ph id="ph1">`ReceiveFrom`</ph> will never mix out-of-band and normal data in the same call.) The <ph id="ph2">`lpArgument`</ph> parameter points at a <ph id="ph3">`DWORD`</ph> in which <bpt id="p2">**</bpt>IOCtl<ept id="p2">**</ept> stores the result.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>This function is a subset of <bpt id="p1">**</bpt>ioctl()<ept id="p1">**</ept> as used in Berkeley sockets.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>In particular, there is no command which is equivalent to <bpt id="p1">**</bpt>FIOASYNC<ept id="p1">**</ept>, while <bpt id="p2">**</bpt>SIOCATMARK<ept id="p2">**</ept> is the only socket-level command which is supported.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Listen</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Call this member function to listen for incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>nConnectionBacklog</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>The maximum length to which the queue of pending connections can grow.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Valid range is from 1 to 5.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRINUSE<ept id="p1">**</ept> An attempt has been made to listen on an address in use.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept> or is already connected.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEISCONN<ept id="p1">**</ept> The socket is already connected.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMFILE<ept id="p1">**</ept> No more file descriptors are available.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>No buffer space is available.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP<ept id="p1">**</ept> The referenced socket is not of a type that supports the <ph id="ph1">`Listen`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>To accept connections, the socket is first created with <bpt id="p1">**</bpt>Create<ept id="p1">**</ept>, a backlog for incoming connections is specified with <ph id="ph1">`Listen`</ph>, and then the connections are accepted with <bpt id="p2">**</bpt>Accept<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>applies only to sockets that support connections, that is, those of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>This socket is put into "passive" mode where incoming connections are acknowledged and queued pending acceptance by the process.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>This function is typically used by servers (or any application that wants to accept connections) that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of <bpt id="p1">**</bpt>WSAECONNREFUSED<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>attempts to continue to function rationally when there are no available ports (descriptors).</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>It will accept connections until the queue is emptied.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>If ports become available, a later call to <ph id="ph1">`Listen`</ph> or <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> will refill the queue to the current or most recent "backlog," if possible, and resume listening for incoming connections.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::m_hSocket</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Contains the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle for the socket encapsulated by this <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnAccept</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify a listening socket that it can accept pending connection requests by calling the <bpt id="p1">[</bpt>Accept<ept id="p1">](#casyncsocket__accept)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>The following error codes applies to the <ph id="ph1">`OnAccept`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnClose</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify this socket that the connected socket is closed by its process.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The following error codes apply to the <ph id="ph1">`OnClose`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The connection was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The connection was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnConnect</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify this connecting socket that its connection attempt is completed, whether successfully or in error.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The following error codes apply to the <ph id="ph1">`OnConnect`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRINUSE<ept id="p1">**</ept> The specified address is already in use.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRNOTAVAIL<ept id="p1">**</ept> The specified address is not available from the local machine.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> Addresses in the specified family cannot be used with this socket.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNREFUSED<ept id="p1">**</ept> The attempt to connect was forcefully rejected.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEDESTADDRREQ<ept id="p1">**</ept> A destination address is required.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument is incorrect.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket is already bound to an address.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEISCONN<ept id="p1">**</ept> The socket is already connected.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMFILE<ept id="p1">**</ept> No more file descriptors are available.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETUNREACH<ept id="p1">**</ept> The network cannot be reached from this host at this time.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>No buffer space is available.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The socket cannot be connected.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is a file, not a socket.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAETIMEDOUT<ept id="p1">**</ept> The attempt to connect timed out without establishing a connection.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">[</bpt>CSocket<ept id="p1">](../../mfc/reference/csocket-class.md)</ept>, the <ph id="ph1">`OnConnect`</ph> notification function is never called.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>For connections, you simply call <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept>, which will return when the connection is completed (either successfully or in error).</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>How connection notifications are handled is an MFC implementation detail.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>NVC_MFCAsyncSocket#1</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnOutOfBandData</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify the receiving socket that the sending socket has out-of-band data to send.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The following error codes apply to the <ph id="ph1">`OnOutOfBandData`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Out-of-band data is a logically independent channel that is associated with each pair of connected sockets of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>The channel is generally used to send urgent data.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>MFC supports out-of-band data, but users of class <ph id="ph1">`CAsyncSocket`</ph> are discouraged from using it.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The easier way is to create a second socket for passing such data.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>For more information about out-of-band data, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnReceive</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify this socket that there is data in the buffer that can be retrieved by calling the <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The following error codes apply to the <ph id="ph1">`OnReceive`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>NVC_MFCAsyncSocket#2</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::OnSend</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>Called by the framework to notify the socket that it can now send data by calling the <bpt id="p1">**</bpt>Send<ept id="p1">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The most recent error on a socket.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The following error codes apply to the <ph id="ph1">`OnSend`</ph> member function:</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>0<ept id="p1">**</ept> The function executed successfully.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Socket Notifications<ept id="p1">](../../mfc/windows-sockets-socket-notifications.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>NVC_MFCAsyncSocket#3</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::operator =</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>A reference to an existing <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>Call this function to copy an existing <ph id="ph1">`CAsyncSocket`</ph> object to another <ph id="ph2">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::operator SOCKET</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Use this operator to retrieve the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle of the <ph id="ph1">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>If successful, the handle of the <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> object; otherwise, <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>You can use the handle to call Windows APIs directly.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Receive</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Call this member function to receive data from a socket.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>A buffer for the incoming data.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>The length of <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_PEEK<ept id="p1">**</ept> Peek at the incoming data.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The data is copied into the buffer but is not removed from the input queue.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Process out-of-band data.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>If no error occurs, <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> returns the number of bytes received.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>If the connection has been closed, it returns 0.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id="p2">[</bpt>GetLastError<ept id="p2">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <bpt id="p2">**</bpt>Receive<ept id="p2">**</ept> on a socket after <ph id="ph1">`ShutDown`</ph> has been invoked with <ph id="ph2">`nHow`</ph> set to 0 or 2.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the <bpt id="p2">**</bpt>Receive<ept id="p2">**</ept> operation would block.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The datagram was too large to fit into the specified buffer and was truncated.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>This function is used for connected stream or datagram sockets and is used to read incoming data.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>For sockets of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id="p1">**</bpt>SO_OOBINLINE<ept id="p1">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The application can use the <bpt id="p1">**</bpt>IOCtlSIOCATMARK<ept id="p1">**</ept> option or <bpt id="p2">[</bpt>OnOutOfBandData<ept id="p2">](#casyncsocket__onoutofbanddata)</ept> to determine whether any more out-of-band data remains to be read.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, the excess data is lost, and <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> returns a value of <bpt id="p2">**</bpt>SOCKET_ERROR<ept id="p2">**</ept> with the error code set to <bpt id="p3">**</bpt>WSAEMSGSIZE<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>If no incoming data is available at the socket, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned with the error code set to <bpt id="p2">**</bpt>WSAEWOULDBLOCK<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>OnReceive<ept id="p1">](#casyncsocket__onreceive)</ept> callback function can be used to determine when more data arrives.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>If the socket is of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> and the remote side has shut down the connection gracefully, a <bpt id="p2">**</bpt>Receive<ept id="p2">**</ept> will complete immediately with 0 bytes received.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>If the connection has been reset, a <bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> will fail with the error <bpt id="p2">**</bpt>WSAECONNRESET<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Receive<ept id="p1">**</ept> should be called only once for each time <bpt id="p2">[</bpt>CAsyncSocket::OnReceive<ept id="p2">](#casyncsocket__onreceive)</ept> is called.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>CAsyncSocket::OnReceive<ept id="p1">](#casyncsocket__onreceive)</ept>.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ReceiveFrom</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>Call this member function to receive a datagram and store the source address in the <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure or in <ph id="ph1">`rSocketAddress`</ph>.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>A buffer for the incoming data.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The length of <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that holds the source address upon return.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>A pointer to the length of the source address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_PEEK<ept id="p1">**</ept> Peek at the incoming data.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>The data is copied into the buffer but is not removed from the input queue.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Process out-of-band data.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>If no error occurs, <ph id="ph1">`ReceiveFrom`</ph> returns the number of bytes received.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>If the connection has been closed, it returns 0.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <ph id="ph1">`GetLastError`</ph>.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument was invalid: the <ph id="ph2">`lpSockAddr`</ph> buffer was too small to accommodate the peer address.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <ph id="ph1">`ReceiveFrom`</ph> on a socket after <ph id="ph2">`ShutDown`</ph> has been invoked with <ph id="ph3">`nHow`</ph> set to 0 or 2.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the <ph id="ph1">`ReceiveFrom`</ph> operation would block.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The datagram was too large to fit into the specified buffer and was truncated.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>To handle IPv6 addresses, use <bpt id="p1">[</bpt>CAsyncSocket::ReceiveFromEx<ept id="p1">](#casyncsocket__receivefromex)</ept>.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>For sockets of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id="p1">**</bpt>SO_OOBINLINE<ept id="p1">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The application can use the <bpt id="p1">**</bpt>IOCtlSIOCATMARK<ept id="p1">**</ept> option or <ph id="ph1">`OnOutOfBandData`</ph> to determine whether any more out-of-band data remains to be read.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`lpSockAddr`</ph> and <ph id="ph2">`lpSockAddrLen`</ph> parameters are ignored for <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> sockets.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and <ph id="ph1">`ReceiveFrom`</ph> returns a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> with the error code set to <bpt id="p2">**</bpt>WSAEMSGSIZE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`lpSockAddr`</ph> is nonzero, and the socket is of type <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept>, the network address of the socket which sent the data is copied to the corresponding <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The value pointed to by <ph id="ph1">`lpSockAddrLen`</ph> is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>If no incoming data is available at the socket, the <ph id="ph1">`ReceiveFrom`</ph> call waits for data to arrive unless the socket is nonblocking.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>In this case, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned with the error code set to <bpt id="p2">**</bpt>WSAEWOULDBLOCK<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`OnReceive`</ph> callback can be used to determine when more data arrives.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>If the socket is of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> and the remote side has shut down the connection gracefully, a <ph id="ph1">`ReceiveFrom`</ph> will complete immediately with 0 bytes received.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ReceiveFromEx</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Call this member function to receive a datagram and store the source address in the <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure or in <ph id="ph1">`rSocketAddress`</ph> (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>A buffer for the incoming data.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>The length of <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>Reference to a <ph id="ph1">`CString`</ph> object that receives a dotted number IP address.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Reference to a <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> that stores a port.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_PEEK<ept id="p1">**</ept> Peek at the incoming data.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>The data is copied into the buffer but is not removed from the input queue.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Process out-of-band data.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>If no error occurs, <ph id="ph1">`ReceiveFromEx`</ph> returns the number of bytes received.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>If the connection has been closed, it returns 0.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <ph id="ph1">`GetLastError`</ph>.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpSockAddrLen`</ph> argument was invalid: the <ph id="ph2">`lpSockAddr`</ph> buffer was too small to accommodate the peer address.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <ph id="ph1">`ReceiveFromEx`</ph> on a socket after <ph id="ph2">`ShutDown`</ph> has been invoked with <ph id="ph3">`nHow`</ph> set to 0 or 2.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the <ph id="ph1">`ReceiveFromEx`</ph> operation would block.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The datagram was too large to fit into the specified buffer and was truncated.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>This function is the same as <bpt id="p1">[</bpt>CAsyncSocket::ReceiveFrom<ept id="p1">](#casyncsocket__receivefrom)</ept> except that it handles IPv6 addresses as well as older protocols.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>For sockets of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id="p1">**</bpt>SO_OOBINLINE<ept id="p1">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The application can use the <bpt id="p1">**</bpt>IOCtlSIOCATMARK<ept id="p1">**</ept> option or <ph id="ph1">`OnOutOfBandData`</ph> to determine whether any more out-of-band data remains to be read.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`lpSockAddr`</ph> and <ph id="ph2">`lpSockAddrLen`</ph> parameters are ignored for <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> sockets.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and <ph id="ph1">`ReceiveFromEx`</ph> returns a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> with the error code set to <bpt id="p2">**</bpt>WSAEMSGSIZE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`lpSockAddr`</ph> is nonzero, and the socket is of type <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept>, the network address of the socket which sent the data is copied to the corresponding <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>The value pointed to by <ph id="ph1">`lpSockAddrLen`</ph> is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>If no incoming data is available at the socket, the <ph id="ph1">`ReceiveFromEx`</ph> call waits for data to arrive unless the socket is nonblocking.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>In this case, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned with the error code set to <bpt id="p2">**</bpt>WSAEWOULDBLOCK<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`OnReceive`</ph> callback can be used to determine when more data arrives.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>If the socket is of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> and the remote side has shut down the connection gracefully, a <ph id="ph1">`ReceiveFromEx`</ph> will complete immediately with 0 bytes received.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::Send</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Call this member function to send data on a connected socket.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>A buffer containing the data to be transmitted.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>The length of the data in <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_DONTROUTE<ept id="p1">**</ept> Specifies that the data should not be subject to routing.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>A Windows Sockets supplier can choose to ignore this flag.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Send out-of-band data ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>If no error occurs, <bpt id="p1">**</bpt>Send<ept id="p1">**</ept> returns the total number of characters sent.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>(Note that this can be less than the number indicated by <ph id="ph1">`nBufLen`</ph>.) Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id="p2">[</bpt>GetLastError<ept id="p2">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEACCES<ept id="p1">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpBuf`</ph> argument is not in a valid part of the user address space.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETRESET<ept id="p1">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>The Windows Sockets implementation reports a buffer deadlock.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <bpt id="p2">**</bpt>Send<ept id="p2">**</ept> on a socket after <ph id="ph1">`ShutDown`</ph> has been invoked with <ph id="ph2">`nHow`</ph> set to 1 or 2.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the requested operation would block.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The socket is of type <bpt id="p2">**</bpt>SOCK_DGRAM<ept id="p2">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The socket has not been bound with <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Send<ept id="p1">**</ept> is used to write outgoing data on connected stream or datagram sockets.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id="p1">**</bpt>iMaxUdpDg<ept id="p1">**</ept> element in the <bpt id="p2">[</bpt>WSADATA<ept id="p2">](../../mfc/reference/wsadata-structure.md)</ept> structure returned by <ph id="ph1">`AfxSocketInit`</ph>.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>If the data is too long to pass atomically through the underlying protocol, the error <bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> is returned via <ph id="ph1">`GetLastError`</ph>, and no data is transmitted.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>Note that for a datagram socket the successful completion of a <bpt id="p1">**</bpt>Send<ept id="p1">**</ept> does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>On <ph id="ph1">`CAsyncSocket`</ph> objects of type <bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept>, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>CAsyncSocket::OnSend<ept id="p1">](#casyncsocket__onsend)</ept>.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SendTo</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Call this member function to send data to a specific destination.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>A buffer containing the data to be transmitted.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>The length of the data in <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>The port identifying the socket application.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>The network address of the socket to which this object is connected: a machine name such as "ftp.microsoft.com," or a dotted number such as "128.56.22.8".</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_DONTROUTE<ept id="p1">**</ept> Specifies that the data should not be subject to routing.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>A Windows Sockets supplier can choose to ignore this flag.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Send out-of-band data ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>SOCKADDR<ept id="p1">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address of the target socket.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The length of the address in <ph id="ph1">`lpSockAddr`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>If no error occurs, <ph id="ph1">`SendTo`</ph> returns the total number of characters sent.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>(Note that this can be less than the number indicated by <ph id="ph1">`nBufLen`</ph>.) Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id="p2">[</bpt>GetLastError<ept id="p2">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEACCES<ept id="p1">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpBuf`</ph> or <ph id="ph2">`lpSockAddr`</ph> parameters are not part of the user address space, or the <ph id="ph3">`lpSockAddr`</ph> argument is too small (less than the size of a <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure).</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The host name is invalid.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETRESET<ept id="p1">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The Windows Sockets implementation reports a buffer deadlock.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <ph id="ph1">`SendTo`</ph> on a socket after <ph id="ph2">`ShutDown`</ph> has been invoked with <ph id="ph3">`nHow`</ph> set to 1 or 2.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the requested operation would block.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The socket is of type <bpt id="p2">**</bpt>SOCK_DGRAM<ept id="p2">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRNOTAVAIL<ept id="p1">**</ept> The specified address is not available from the local machine.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> Addresses in the specified family cannot be used with this socket.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEDESTADDRREQ<ept id="p1">**</ept> A destination address is required.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETUNREACH<ept id="p1">**</ept> The network cannot be reached from this host at this time.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>is used on datagram or stream sockets and is used to write outgoing data on a socket.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id="p1">**</bpt>iMaxUdpDg<ept id="p1">**</ept> element in the <bpt id="p2">[</bpt>WSADATA<ept id="p2">](../../mfc/reference/wsadata-structure.md)</ept> structure filled out by <bpt id="p3">[</bpt>AfxSocketInit<ept id="p3">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept>.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>If the data is too long to pass atomically through the underlying protocol, the error <bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> is returned, and no data is transmitted.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>Note that the successful completion of a <ph id="ph1">`SendTo`</ph> does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>is only used on a <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> socket to send a datagram to a specific socket identified by the <ph id="ph1">`lpSockAddr`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>To send a broadcast (on a <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> only), the address in the <ph id="ph1">`lpSockAddr`</ph> parameter should be constructed using the special IP address <bpt id="p2">**</bpt>INADDR_BROADCAST<ept id="p2">**</ept> (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>Or, if the <ph id="ph1">`lpszHostAddress`</ph> parameter is <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, the socket is configured for broadcast.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>To handle IPv6 addresses, use <bpt id="p1">[</bpt>CAsyncSocket::SendToEx<ept id="p1">](#casyncsocket__sendtoex)</ept>.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SendToEx</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Call this member function to send data to a specific destination (handles IPv6 addresses).</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>A buffer containing the data to be transmitted.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>The length of the data in <ph id="ph1">`lpBuf`</ph> in bytes.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>The port identifying the socket application.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>The network address of the socket to which this object is connected: a machine name such as "ftp.microsoft.com," or a dotted number such as "128.56.22.8".</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>Specifies the way in which the call is made.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>The semantics of this function are determined by the socket options and the <ph id="ph1">`nFlags`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The latter is constructed by combining any of the following values with the C++ <ph id="ph1">`OR`</ph> operator:</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_DONTROUTE<ept id="p1">**</ept> Specifies that the data should not be subject to routing.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>A Windows Sockets supplier can choose to ignore this flag.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MSG_OOB<ept id="p1">**</ept> Send out-of-band data ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>If no error occurs, <ph id="ph1">`SendToEx`</ph> returns the total number of characters sent.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>(Note that this can be less than the number indicated by <ph id="ph1">`nBufLen`</ph>.) Otherwise, a value of <bpt id="p1">**</bpt>SOCKET_ERROR<ept id="p1">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id="p2">[</bpt>GetLastError<ept id="p2">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEACCES<ept id="p1">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> The <ph id="ph1">`lpBuf`</ph> or <ph id="ph2">`lpSockAddr`</ph> parameters are not part of the user address space, or the <ph id="ph3">`lpSockAddr`</ph> argument is too small (less than the size of a <bpt id="p2">[</bpt>SOCKADDR<ept id="p2">](../../mfc/reference/sockaddr-structure.md)</ept> structure).</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> The host name is invalid.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETRESET<ept id="p1">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The Windows Sockets implementation reports a buffer deadlock.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id="p1">**</ept> was specified, but the socket is not of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAESHUTDOWN<ept id="p1">**</ept> The socket has been shut down; it is not possible to call <ph id="ph1">`SendToEx`</ph> on a socket after <ph id="ph2">`ShutDown`</ph> has been invoked with <ph id="ph3">`nHow`</ph> set to 1 or 2.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEWOULDBLOCK<ept id="p1">**</ept> The socket is marked as nonblocking and the requested operation would block.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> The socket is of type <bpt id="p2">**</bpt>SOCK_DGRAM<ept id="p2">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNABORTED<ept id="p1">**</ept> The virtual circuit was aborted due to timeout or other failure.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAECONNRESET<ept id="p1">**</ept> The virtual circuit was reset by the remote side.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEADDRNOTAVAIL<ept id="p1">**</ept> The specified address is not available from the local machine.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEAFNOSUPPORT<ept id="p1">**</ept> Addresses in the specified family cannot be used with this socket.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEDESTADDRREQ<ept id="p1">**</ept> A destination address is required.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETUNREACH<ept id="p1">**</ept> The network cannot be reached from this host at this time.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>This method is the same as <bpt id="p1">[</bpt>CAsyncSocket::SendTo<ept id="p1">](#casyncsocket__sendto)</ept> except that it handles IPv6 addresses as well as older protocols.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>is used on datagram or stream sockets and is used to write outgoing data on a socket.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id="p1">**</bpt>iMaxUdpDg<ept id="p1">**</ept> element in the <bpt id="p2">[</bpt>WSADATA<ept id="p2">](../../mfc/reference/wsadata-structure.md)</ept> structure filled out by <bpt id="p3">[</bpt>AfxSocketInit<ept id="p3">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept>.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>If the data is too long to pass atomically through the underlying protocol, the error <bpt id="p1">**</bpt>WSAEMSGSIZE<ept id="p1">**</ept> is returned, and no data is transmitted.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Note that the successful completion of a <ph id="ph1">`SendToEx`</ph> does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>is only used on a <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> socket to send a datagram to a specific socket identified by the <ph id="ph1">`lpSockAddr`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>To send a broadcast (on a <bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> only), the address in the <ph id="ph1">`lpSockAddr`</ph> parameter should be constructed using the special IP address <bpt id="p2">**</bpt>INADDR_BROADCAST<ept id="p2">**</ept> (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>Or, if the <ph id="ph1">`lpszHostAddress`</ph> parameter is <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, the socket is configured for broadcast.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::SetSockOpt</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>Call this member function to set a socket option.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>The socket option for which the value is to be set.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>A pointer to the buffer in which the value for the requested option is supplied.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>The size of the <ph id="ph1">`lpOptionValue`</ph> buffer in bytes.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>The level at which the option is defined; the only supported levels are <bpt id="p1">**</bpt>SOL_SOCKET<ept id="p1">**</ept> and <bpt id="p2">**</bpt>IPPROTO_TCP<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEFAULT<ept id="p1">**</ept> <ph id="ph1">`lpOptionValue`</ph> is not in a valid part of the process address space.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> <ph id="ph1">`nLevel`</ph> is not valid, or the information in <ph id="ph2">`lpOptionValue`</ph> is not valid.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETRESET<ept id="p1">**</ept> Connection has timed out when <bpt id="p2">**</bpt>SO_KEEPALIVE<ept id="p2">**</ept> is set.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOPROTOOPT<ept id="p1">**</ept> The option is unknown or unsupported.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>In particular, <bpt id="p1">**</bpt>SO_BROADCAST<ept id="p1">**</ept> is not supported on sockets of type <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept>, while <bpt id="p3">**</bpt>SO_DONTLINGER<ept id="p3">**</ept>, <bpt id="p4">**</bpt>SO_KEEPALIVE<ept id="p4">**</ept>, <bpt id="p5">**</bpt>SO_LINGER<ept id="p5">**</ept>, and <bpt id="p6">**</bpt>SO_OOBINLINE<ept id="p6">**</ept> are not supported on sockets of type <bpt id="p7">**</bpt>SOCK_DGRAM<ept id="p7">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> Connection has been reset when <bpt id="p2">**</bpt>SO_KEEPALIVE<ept id="p2">**</ept> is set.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>sets the current value for a socket option associated with a socket of any type, in any state.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>Although options can exist at multiple protocol levels, this specification only defines options that exist at the uppermost "socket" level.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>Options affect socket operations, such as whether expedited data is received in the normal data stream, whether broadcast messages can be sent on the socket, and so on.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>To enable a Boolean option, <ph id="ph1">`lpOptionValue`</ph> points to a nonzero integer.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>To disable the option <ph id="ph1">`lpOptionValue`</ph> points to an integer equal to zero.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>should be equal to <bpt id="p1">**</bpt>sizeof(BOOL)<ept id="p1">**</ept> for Boolean options.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>For other options, <ph id="ph1">`lpOptionValue`</ph> points to the integer or structure that contains the desired value for the option, and <ph id="ph2">`nOptionLen`</ph> is the length of the integer or structure.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SO_LINGER<ept id="p1">**</ept> controls the action taken when unsent data is queued on a socket and the <bpt id="p2">**</bpt>Close<ept id="p2">**</ept> function is called to close the socket.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>By default, a socket cannot be bound (see <bpt id="p1">[</bpt>Bind<ept id="p1">](#casyncsocket__bind)</ept>) to a local address which is already in use.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>On occasion, however, it may be desirable to "reuse" an address in this way.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>To inform the Windows Sockets implementation that a <bpt id="p1">**</bpt>Bind<ept id="p1">**</ept> call on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the <bpt id="p2">**</bpt>SO_REUSEADDR<ept id="p2">**</ept> socket option for the socket before issuing the <bpt id="p3">**</bpt>Bind<ept id="p3">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>Note that the option is interpreted only at the time of the <bpt id="p1">**</bpt>Bind<ept id="p1">**</ept> call: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept> call has no effect on this or any other socket.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>An application can request that the Windows Sockets implementation enable the use of "keep-alive" packets on Transmission Control Protocol (TCP) connections by turning on the <bpt id="p1">**</bpt>SO_KEEPALIVE<ept id="p1">**</ept> socket option.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>A Windows Sockets implementation need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: "Requirements for Internet Hosts â€” Communication Layers."</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>If a connection is dropped as the result of "keep-alives" the error code <bpt id="p1">**</bpt>WSAENETRESET<ept id="p1">**</ept> is returned to any calls in progress on the socket, and any subsequent calls will fail with <bpt id="p2">**</bpt>WSAENOTCONN<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>TCP_NODELAY<ept id="p1">**</ept> option disables the Nagle algorithm.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>The Nagle algorithm is used to reduce the number of small packets sent by a host by buffering unacknowledged send data until a full-size packet can be sent.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>However, for some applications this algorithm can impede performance, and <bpt id="p1">**</bpt>TCP_NODELAY<ept id="p1">**</ept> can be used to turn it off.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>Application writers should not set <bpt id="p1">**</bpt>TCP_NODELAY<ept id="p1">**</ept> unless the impact of doing so is well-understood and desired, since setting <bpt id="p2">**</bpt>TCP_NODELAY<ept id="p2">**</ept> can have a significant negative impact on network performance.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TCP_NODELAY<ept id="p1">**</ept> is the only supported socket option which uses level <bpt id="p2">**</bpt>IPPROTO_TCP<ept id="p2">**</ept>; all other options use level <bpt id="p3">**</bpt>SOL_SOCKET<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>Some implementations of Windows Sockets supply output debug information if the <bpt id="p1">**</bpt>SO_DEBUG<ept id="p1">**</ept> option is set by an application.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>The following options are supported for <ph id="ph1">`SetSockOpt`</ph>.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>The Type identifies the type of data addressed by <ph id="ph1">`lpOptionValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>SO_BROADCAST</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast messages on the socket.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>SO_DEBUG</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Record debugging information.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>SO_DONTLINGER</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>Don't block <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> waiting for unsent data to be sent.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>Setting this option is equivalent to setting <bpt id="p1">**</bpt>SO_LINGER<ept id="p1">**</ept> with <bpt id="p2">**</bpt>l_onoff<ept id="p2">**</ept> set to zero.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>SO_DONTROUTE</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>Don't route: send directly to interface.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>SO_KEEPALIVE</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>Send keep-alives.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>SO_LINGER</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>struct LINGER</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>Linger on <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> if unsent data is present.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>SO_OOBINLINE</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>Receive out-of-band data in the normal data stream.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>SO_RCVBUF</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>Specify buffer size for receives.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>SO_REUSEADDR</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>Allow the socket to be bound to an address which is already in use.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Bind<ept id="p1">](#casyncsocket__bind)</ept>.)</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>SO_SNDBUF</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>Specify buffer size for sends.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>TCP_NODELAY</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>Disables the Nagle algorithm for send coalescing.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>Berkeley Software Distribution (BSD) options not supported for <ph id="ph1">`SetSockOpt`</ph> are:</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>SO_ACCEPTCONN</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>Socket is listening</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>SO_ERROR</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>Get error status and clear.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>SO_RCVLOWAT</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>Receive low water mark.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>SO_RCVTIMEO</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>Receive timeout</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>SO_SNDLOWAT</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>Send low water mark.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>SO_SNDTIMEO</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>Send timeout.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>SO_TYPE</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>Type of the socket.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>Set options field in IP header.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>CAsyncSocket::ShutDown</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>Call this member function to disable sends, receives, or both on the socket.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>A flag that describes what types of operation will no longer be allowed, using the following enumerated values:</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>receives = 0</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>sends = 1</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>both = 2</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id="p1">[</bpt>GetLastError<ept id="p1">](#casyncsocket__getlasterror)</ept>.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>The following errors apply to this member function:</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSANOTINITIALISED<ept id="p1">**</ept> A successful <bpt id="p2">[</bpt>AfxSocketInit<ept id="p2">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENETDOWN<ept id="p1">**</ept> The Windows Sockets implementation detected that the network subsystem failed.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINVAL<ept id="p1">**</ept> <ph id="ph1">`nHow`</ph> is not valid.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAEINPROGRESS<ept id="p1">**</ept> A blocking Windows Sockets operation is in progress.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTCONN<ept id="p1">**</ept> The socket is not connected ( <bpt id="p2">**</bpt>SOCK_STREAM<ept id="p2">**</ept> only).</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WSAENOTSOCK<ept id="p1">**</ept> The descriptor is not a socket.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>is used on all types of sockets to disable reception, transmission, or both.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`nHow`</ph> is 0, subsequent receives on the socket will be disallowed.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>This has no effect on the lower protocol layers.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>For Transmission Control Protocol (TCP), the TCP window is not changed and incoming data will be accepted (but not acknowledged) until the window is exhausted.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>For User Datagram Protocol (UDP), incoming datagrams are accepted and queued.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>In no case will an ICMP error packet be generated.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`nHow`</ph> is 1, subsequent sends are disallowed.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>For TCP sockets, a FIN will be sent.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>Setting <ph id="ph1">`nHow`</ph> to 2 disables both sends and receives as described above.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`ShutDown`</ph> does not close the socket, and resources attached to the socket will not be freed until <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> is called.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>An application should not rely on being able to reuse a socket after it has been shut down.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>In particular, a Windows Sockets implementation is not required to support the use of <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> on such a socket.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>CAsyncSocket::OnReceive<ept id="p1">](#casyncsocket__onreceive)</ept>.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>CASyncSocket::Socket</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>Allocates a socket handle.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>Specifies <ph id="ph1">`SOCK_STREAM`</ph> or <ph id="ph2">`SOCK_DGRAM`</ph>.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>A bitmask that specifies a combination of network events in which the application is interested.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of readiness for reading.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of readiness for writing.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of the arrival of out-of-band data.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of incoming connections.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of completed connection.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>: Want to receive notification of socket closure.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>Protocol to be used with the socket that is specific to the indicated address family.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>Address family specification.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`TRUE`</ph> on success, <ph id="ph2">`FALSE`</ph> on failure.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>This method allocates a socket handle.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>It does not call <bpt id="p1">[</bpt>CAsyncSocket::Bind<ept id="p1">](#casyncsocket__bind)</ept> to bind the socket to a specified address, so you need to call <ph id="ph1">`Bind`</ph> later to bind the socket to a specified address.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">[</bpt>CAsyncSocket::SetSockOpt<ept id="p1">](#casyncsocket__setsockopt)</ept> to set the socket option before it is bound.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source>CObject Class</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>Hierarchy Chart</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>CSocket Class</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>CSocketFile Class</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>