<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9c20c5eaa5c65ac59f3f14a97dee1ab65de0fc86</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\iterator-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ffaebc6133dc8c3c6ceb23d88cfa6a2ea82b41c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4cea5d60dce2df86dc18c6826e321c6b5f073bd8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>iterator<ph id="ph1">&amp;gt;</ph> functions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>iterator<ph id="ph1">&amp;gt;</ph> functions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>advance</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>back_inserter</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>begin</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>cbegin</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>cend</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>distance</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>end</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>front_inserter</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>inserter</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>make_checked_array_iterator</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>make_move_iterator</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>make_unchecked_array_iterator</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>next</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>prev</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>advance</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Increments an iterator by a specified number of positions.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The iterator that is to be incremented and that must satisfy the requirements for an input iterator.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>An integral type that is convertible to the iterator's difference type and that specifies the number of increments the position of the iterator is to be advanced.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The range advanced through must be nonsingular, where the iterators must be dereferenceable or past the end.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">**</bpt>InputIterator<ept id="p1">**</ept> satisfies the requirements for a bidirectional iterator type, then <ph id="ph1">`Off`</ph> may be negative.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>InputIterator<ept id="p1">**</ept> is an input or forward iterator type, <ph id="ph1">`Off`</ph> must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The advance function has constant complexity when <bpt id="p1">**</bpt>InputIterator<ept id="p1">**</ept> satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>back_inserter</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Creates an iterator that can insert elements at the back of a specified container.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The container into which the back insertion is to be executed.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`back_insert_iterator`</ph> associated with the container object <ph id="ph2">`_Cont`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Within the Standard Template Library, the argument must refer to one of the three sequence containers that have the member function <ph id="ph1">`push_back`</ph>: <bpt id="p1">[</bpt>deque Class<ept id="p1">](../standard-library/deque-class.md)</ept>, <bpt id="p2">[</bpt>list Class<ept id="p2">](../standard-library/list-class.md)</ept>, or <bpt id="p3">[</bpt>vector Class<ept id="p3">](../standard-library/vector-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>begin</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Retrieves an iterator to the first element in a specified container.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A container.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An array of objects of type <ph id="ph1">`Ty`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first two template functions return <ph id="ph1">`cont.begin()`</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first function is non-constant; the second one is constant.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The third template function returns <ph id="ph1">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>We recommend that you use this template function in place of container member <ph id="ph1">`begin()`</ph> when more generic behavior is required.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The function <ph id="ph1">`reverse_sort`</ph> supports containers of any kind, in addition to regular arrays, because it calls the non-member version of <ph id="ph2">`begin()`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`reverse_sort`</ph> were coded to use the container member <ph id="ph2">`begin()`</ph>:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Then sending an array to it would cause this compiler error:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>cbegin</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Retrieves a const iterator to the first element in a specified container.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A container or initializer_list.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A constant <ph id="ph1">`cont.begin()`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This function works with all STL containers and with <bpt id="p1">[</bpt>initializer_list<ept id="p1">](../standard-library/initializer-list-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can use this member function in place of the <ph id="ph1">`begin()`</ph> template function to guarantee that the return value is <ph id="ph2">`const_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Typically, it's used in conjunction with the <bpt id="p1">[</bpt>auto<ept id="p1">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the example, consider <ph id="ph1">`Container`</ph> to be a modifiable (non- <ph id="ph2">`const`</ph>) container or <ph id="ph3">`initializer_list`</ph> of any kind that supports <ph id="ph4">`begin()`</ph> and <ph id="ph5">`cbegin()`</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>cend</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Retrieves a const iterator to the element that follows the last element in the specified container.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A container or initializer_list.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A constant <ph id="ph1">`cont.end()`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This function works with all STL containers and with <bpt id="p1">[</bpt>initializer_list<ept id="p1">](../standard-library/initializer-list-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You can use this member function in place of the <bpt id="p1">[</bpt>end()<ept id="p1">](../standard-library/iterator-functions.md#end)</ept> template function to guarantee that the return value is <ph id="ph1">`const_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Typically, it's used in conjunction with the <bpt id="p1">[</bpt>auto<ept id="p1">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In the example, consider <ph id="ph1">`Container`</ph> to be a modifiable (non- <ph id="ph2">`const`</ph>) container or <ph id="ph3">`initializer_list`</ph> of any kind that supports <ph id="ph4">`end()`</ph> and <ph id="ph5">`cend()`</ph>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>distance</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Determines the number of increments between the positions addressed by two iterators.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The first iterator whose distance from the second is to be determined.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The second iterator whose distance from the first is to be determined.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The number of times that <ph id="ph1">` first`</ph> must be incremented until it equal <ph id="ph2">` last`</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The distance function has constant complexity when <bpt id="p1">**</bpt>InputIterator<ept id="p1">**</ept> satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>end</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Retrieves an iterator to the element that follows the last element in the specified container.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A container.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>An array of objects of type <ph id="ph1">`Ty`</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The first two template functions return <ph id="ph1">`cont.end()`</ph> (the first is non-constant and the second is constant).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The third template function returns <ph id="ph1">`array + Size`</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For a code example, see <bpt id="p1">[</bpt>begin<ept id="p1">](../standard-library/iterator-functions.md#begin)</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>front_inserter</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Creates an iterator that can insert elements at the front of a specified container.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The container object whose front is having an element inserted.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`front_insert_iterator`</ph> associated with the container object <ph id="ph2">`_Cont`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The member function <bpt id="p1">[</bpt>front_insert_iterator<ept id="p1">](../standard-library/front-insert-iterator-class.md#front_insert_iterator__front_insert_iterator)</ept> of the front_insert_iterator class may also be used.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Within the Standard Template Library, the argument must refer to one of the two sequence containers that have the member function <ph id="ph1">`push_back`</ph>: <bpt id="p1">[</bpt>deque Class<ept id="p1">](../standard-library/deque-class.md)</ept> or "list Class".</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>inserter</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A helper template function that lets you use <ph id="ph1">`inserter(``_Cont``,``_Where``)`</ph> instead of <ph id="ph2">`insert_iterator&lt;Container&gt;(``_Cont`</ph>, <ph id="ph3">`_Where``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The container to which new elements are to be added.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>An iterator locating the point of insertion.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The template function returns <bpt id="p1">[</bpt>insert_iterator<ept id="p1">](../standard-library/insert-iterator-class.md#insert_iterator__insert_iterator)</ept><ph id="ph1">`&lt;Container&gt;(``_Cont``,`</ph> <ph id="ph2">`_Where``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>make_checked_array_iterator</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Creates a <bpt id="p1">[</bpt>checked_array_iterator<ept id="p1">](../standard-library/checked-array-iterator-class.md)</ept> that can be used by other algorithms.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This function is a Microsoft extension of the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A pointer to the destination array.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The size of the destination array.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Optional index into the array.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">`checked_array_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`make_checked_array_iterator`</ph> function is defined in the <ph id="ph2">`stdext`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This function takes a raw pointer—which would ordinarily cause concern about bounds overrun—and wraps it in a <bpt id="p1">[</bpt>checked_array_iterator<ept id="p1">](../standard-library/checked-array-iterator-class.md)</ept> class that does checking.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Because that class is marked as checked, the STL doesn't warn about it.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information and code examples, see <bpt id="p1">[</bpt>Checked Iterators<ept id="p1">](../standard-library/checked-iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In the following example, a <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept> is created and populated with 10 items.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The contents of the vector are copied into an array by using the copy algorithm, and then <ph id="ph1">`make_checked_array_iterator`</ph> is used to specify the destination.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This is followed by an intentional violation of the bounds checking so that a debug assertion failure is triggered.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>make_move_iterator</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Creates a <ph id="ph1">`move iterator`</ph> that contains the provided iterator as the <ph id="ph2">`stored`</ph> iterator.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The iterator stored in the new move iterator.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`move_iterator``&lt;Iterator&gt;(``_It``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>make_unchecked_array_iterator</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Creates an <bpt id="p1">[</bpt>unchecked_array_iterator<ept id="p1">](../standard-library/unchecked-array-iterator-class.md)</ept> that can be used by other algorithms.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This function is a Microsoft extension of the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>A pointer to the destination array.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">`unchecked_array_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`make_unchecked_array_iterator`</ph> function is defined in the <ph id="ph2">`stdext`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This function takes a raw pointer and wraps it in a class that performs no checking and therefore optimizes away to nothing, but it also silences compiler warnings such as <bpt id="p1">[</bpt>C4996<ept id="p1">](../error-messages/compiler-warnings/compiler-warning-level-3-c4996.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Therefore, this is a targeted way to deal with unchecked-pointer warnings without globally silencing them or incurring the cost of checking.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For more information and code examples, see <bpt id="p1">[</bpt>Checked Iterators<ept id="p1">](../standard-library/checked-iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In the following example, a <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept> is created and populated with 10 items.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The contents of the vector are copied into an array by using the copy algorithm, and then <ph id="ph1">`make_unchecked_array_iterator`</ph> is used to specify the destination.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>next</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Iterates a specified number of times and returns the new iterator position.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The current position.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The number of times to iterate.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Returns the new iterator position after iterating <ph id="ph1">`_Off`</ph> times.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`next`</ph> incremented <ph id="ph2">`_Off`</ph> times</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>prev</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Iterates in reverse a specified number of times and returns the new iterator position.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The current position.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The number of times to iterate.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`next`</ph> decremented <ph id="ph2">`off`</ph> times.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>iterator&gt;</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>