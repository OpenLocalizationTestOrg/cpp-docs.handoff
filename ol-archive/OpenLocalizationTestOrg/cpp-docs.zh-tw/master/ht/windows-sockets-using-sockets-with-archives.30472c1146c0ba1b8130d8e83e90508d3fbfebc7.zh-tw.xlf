<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c7ef8549b286b02bae6b0467498ac14600243172</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\windows-sockets-using-sockets-with-archives.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">938d2f8b320d63fc98e34c844ef53e2e1d7cbfba</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a521f44284ae1d143a27caa772688f72a70348bc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Windows Sockets: Using Sockets with Archives | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Windows Sockets: Using Sockets with Archives</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This article describes the <bpt id="p1">[</bpt>CSocket programming model<ept id="p1">](#_core_the_csocket_programming_model)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Class <bpt id="p1">[</bpt>CSocket<ept id="p1">](../mfc/reference/csocket-class.md)</ept> supplies socket support at a higher level of abstraction than does class <bpt id="p2">[</bpt>CAsyncSocket<ept id="p2">](../mfc/reference/casyncsocket-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>uses a version of the MFC serialization protocol to pass data to and from a socket object through an MFC <bpt id="p1">[</bpt>CArchive<ept id="p1">](../mfc/reference/carchive-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>provides blocking (while managing background processing of Windows messages) and gives you access to <ph id="ph1">`CArchive`</ph>, which manages many aspects of the communication that you would have to do yourself using either the raw API or class <ph id="ph2">`CAsyncSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can use class <ph id="ph1">`CSocket`</ph> by itself, as a more convenient version of <ph id="ph2">`CAsyncSocket`</ph>, but the simplest programming model is to use <ph id="ph3">`CSocket`</ph> with a <ph id="ph4">`CArchive`</ph> object.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information about how the implementation of sockets with archives works, see <bpt id="p1">[</bpt>Windows Sockets: How Sockets with Archives Work<ept id="p1">](../mfc/windows-sockets-how-sockets-with-archives-work.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example code, see <bpt id="p1">[</bpt>Windows Sockets: Sequence of Operations<ept id="p1">](../mfc/windows-sockets-sequence-of-operations.md)</ept> and <bpt id="p2">[</bpt>Windows Sockets: Example of Sockets Using Archives<ept id="p2">](../mfc/windows-sockets-example-of-sockets-using-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For information about some of the functionality you can gain by deriving your own classes from the sockets classes, see <bpt id="p1">[</bpt>Windows Sockets: Deriving from Socket Classes<ept id="p1">](../mfc/windows-sockets-deriving-from-socket-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you are writing an MFC client program to communicate with established (non-MFC) servers, do not send C++ objects through the archive.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Unless the server is an MFC application that understands the kinds of objects you want to send, it will not be able to receive and deserialize your objects.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For related material on the subject of communicating with non-MFC applications, also see the article <bpt id="p1">[</bpt>Windows Sockets: Byte Ordering<ept id="p1">](../mfc/windows-sockets-byte-ordering.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The CSocket Programming Model</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Using a <ph id="ph1">`CSocket`</ph> object involves creating and associating together several MFC class objects.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the general procedure below, each step is taken by both the server socket and the client socket, except for step 3, in which each socket type requires a different action.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>At run time, the server application usually starts first to be ready and "listening" when the client application seeks a connection.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If the server is not ready when the client tries to connect, you typically require the user application to try connecting again later.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To set up communication between a server socket and a client socket</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Construct a <bpt id="p1">[</bpt>CSocket<ept id="p1">](../mfc/reference/csocket-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use the object to create the underlying <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For a <ph id="ph1">`CSocket`</ph> client object, you should normally use the default parameters to <bpt id="p1">[</bpt>Create<ept id="p1">](../mfc/reference/casyncsocket-class.md#casyncsocket__create)</ept>, unless you need a datagram socket.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For a <ph id="ph1">`CSocket`</ph> server object, you must specify a port in the <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>does not work with datagram sockets.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If you want to use <ph id="ph1">`CSocket`</ph> for a datagram socket, you must use the class as you would use <ph id="ph2">`CAsyncSocket`</ph>, that is, without an archive.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Because datagrams are unreliable (not guaranteed to arrive and may be repeated or out of sequence), they are not compatible with serialization through an archive.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You expect a serialization operation to complete reliably and in sequence.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you try to use <ph id="ph1">`CSocket`</ph> with a <ph id="ph2">`CArchive`</ph> object for a datagram, an MFC assertion fails.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If the socket is a client, call <bpt id="p1">[</bpt>CAsyncSocket::Connect<ept id="p1">](../mfc/reference/casyncsocket-class.md#casyncsocket__connect)</ept> to connect the socket object to a server socket.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If the socket is a server, call <bpt id="p1">[</bpt>CAsyncSocket::Listen<ept id="p1">](../mfc/reference/casyncsocket-class.md#casyncsocket__listen)</ept> to begin listening for connect attempts from a client.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Upon receiving a connection request, accept it by calling <bpt id="p1">[</bpt>CAsyncSocket::Accept<ept id="p1">](../mfc/reference/casyncsocket-class.md#casyncsocket__accept)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> member function takes a reference to a new, empty <ph id="ph1">`CSocket`</ph> object as its parameter.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You must construct this object before you call <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If this socket object goes out of scope, the connection closes.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Do not call <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> for this new socket object.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Create a <bpt id="p1">[</bpt>CSocketFile<ept id="p1">](../mfc/reference/csocketfile-class.md)</ept> object, associating the <ph id="ph1">`CSocket`</ph> object with it.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Create a <bpt id="p1">[</bpt>CArchive<ept id="p1">](../mfc/reference/carchive-class.md)</ept> object for either loading (receiving) or storing (sending) data.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The archive is associated with the <ph id="ph1">`CSocketFile`</ph> object.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Keep in mind that <ph id="ph1">`CArchive`</ph> does not work with datagram sockets.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`CArchive`</ph> object to pass data between the client and server sockets.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Keep in mind that a given <ph id="ph1">`CArchive`</ph> object moves data in one direction only: either for loading (receiving) or storing (sending).</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In some cases, you will use two <ph id="ph1">`CArchive`</ph> objects: one for sending data, the other for receiving acknowledgments.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>After accepting a connection and setting up the archive, you can perform such tasks as validating passwords.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Destroy the archive, socket file, and socket objects.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Class <ph id="ph1">`CArchive`</ph> supplies the <ph id="ph2">`IsBufferEmpty`</ph> member function specifically for use with class <ph id="ph3">`CSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the buffer contains multiple data messages, for example, you need to loop until all of them are read and the buffer is cleared.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Otherwise, your next notification that there is data to be received may be indefinitely delayed.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`IsBufferEmpty`</ph> to assure that you retrieve all data.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The article <bpt id="p1">[</bpt>Windows Sockets: Sequence of Operations<ept id="p1">](../mfc/windows-sockets-sequence-of-operations.md)</ept> illustrates both sides of this process with example code.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Windows Sockets: Stream Sockets</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Windows Sockets: Datagram Sockets</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Windows Sockets in MFC</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>CSocket::Create</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>