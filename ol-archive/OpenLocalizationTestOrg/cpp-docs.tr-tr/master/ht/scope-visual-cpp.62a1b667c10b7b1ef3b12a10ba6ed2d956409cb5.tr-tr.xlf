<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0369fda0a1caab7d0965317f896e4638e80ce308</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\scope-visual-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec3615531137c4a6dfd09d8465ed097cabe53f0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6e4276e9fbc25d450965cf1016a692e7b8aafc35</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Scope (Visual C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Scope (Visual C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ names can be used only in certain regions of a program.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This area is called the "scope" of the name.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Scope determines the "lifetime" of a name that does not denote an object of static extent.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Scope also determines the visibility of a name, when class constructors and destructors are called, and when variables local to the scope are initialized.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Constructors<ept id="p1">](../cpp/constructors-cpp.md)</ept> and <bpt id="p2">[</bpt>Destructors<ept id="p2">](../cpp/destructors-cpp.md)</ept>.) There are five kinds of scope:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Local scope<ept id="p1">**</ept> A name declared within a block is accessible only within that block and blocks enclosed by it, and only after the point of declaration.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The names of formal arguments to a function in the scope of the outermost block of the function have local scope, as if they had been declared inside the block enclosing the function body.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Consider the following code fragment:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Because the declaration of <ph id="ph1">`i`</ph> is in a block enclosed by curly braces, <ph id="ph2">`i`</ph> has local scope and is never accessible because no code accesses it before the closing curly brace.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Function scope<ept id="p1">**</ept> Labels are the only names that have function scope.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>They can be used anywhere within a function, but are not accessible outside that function.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Formal arguments (arguments specified in function definitions) to functions are considered to be in the scope of the outermost block of the function body.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>File scope<ept id="p1">**</ept> Any name declared outside all blocks or classes has file scope.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It is accessible anywhere in the translation unit after its declaration.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Names with file scope that do not declare static objects are often called global names.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In C++, file scope is also known as namespace scope.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Class scope<ept id="p1">**</ept> Names of class members have class scope.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Class member functions can be accessed only by using the member-selection operators (<bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>or <bpt id="p1">**</bpt>–&gt;<ept id="p1">**</ept>) or pointer-to-member operators (<bpt id="p2">**</bpt>.<ph id="ph1">\*</ph><ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>or <bpt id="p1">**</bpt>–&gt;<ph id="ph1">\*</ph><ept id="p1">**</ept>) on an object or pointer to an object of that class; nonstatic class member data is considered local to the object of that class.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the following class declaration:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The class members <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> are considered to be in the scope of class <ph id="ph3">`Point`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Prototype scope<ept id="p1">**</ept> Names declared in a function prototype are visible only until the end of the prototype.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following prototype declares three names (<ph id="ph1">`strDestination`</ph>, <ph id="ph2">`numberOfElements`</ph>, and <ph id="ph3">`strSource`</ph>); these names go out of scope at the end of the prototype:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Hiding Names</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can hide a name by declaring it in an enclosed block.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following figure, <ph id="ph1">`i`</ph> is redeclared within the inner block, thereby hiding the variable associated with <ph id="ph2">`i`</ph> in the outer block scope.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Block&amp;#45;scope name hiding</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Block Scope and Name Hiding</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The output from the program shown in the figure is:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The argument <ph id="ph1">`szWhat`</ph> is considered to be in the scope of the function.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Therefore, it is treated as if it had been declared in the outermost block of the function.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Hiding class names</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can hide class names by declaring a function, object or variable, or enumerator in the same scope.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, the class name can still be accessed when prefixed by the keyword <bpt id="p1">**</bpt>class<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Any place the class name (<ph id="ph1">`Account`</ph>) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This rule does not apply when the class name occurs on the left side of the scope-resolution operator (::).</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Names on the left side of the scope-resolution operator are always considered class names.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to declare a pointer to an object of type <ph id="ph1">`Account`</ph> using the <bpt id="p1">**</bpt>class<ept id="p1">**</ept> keyword:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Account`</ph> in the initializer (in parentheses) in the preceding statement has file scope; it is of type <bpt id="p1">**</bpt>double<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The reuse of identifier names as shown in this example is considered poor programming style.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information about pointers, see <bpt id="p1">[</bpt>Derived Types<ept id="p1">](http://msdn.microsoft.com/en-us/aa14183c-02fe-4d81-95fe-beddb0c01c7c)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For information about declaration and initialization of class objects, see <bpt id="p1">[</bpt>Classes, Structures, and Unions<ept id="p1">](../cpp/classes-and-structs-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For information about using the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> and <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> free-store operators, see <bpt id="p3">[</bpt>new and delete operators<ept id="p3">](new-and-delete-operators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Hiding names with file scope</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can hide names with file scope by explicitly declaring the same name in block scope.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>However, file-scope names can be accessed using the scope-resolution operator (<ph id="ph1">`::`</ph>).</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>