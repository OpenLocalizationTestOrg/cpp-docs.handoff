<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a9202cf875edb14ea9c84eb11fe147b1c015a07c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\initializers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">de793490b9b65657c9ae976d836dd01c45fbbcbe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67e898cdc692e4a38da30d8b46d254d13771a0c0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Initializers | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Initializers</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An initializer specifies the initial value of a variable.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can initialize variables in these contexts:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In the definition of a variable:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>As one of the parameters of a function:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>As the return value of a function:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Initializers may take these forms:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>An expression (or a comma-separated list of expressions) in parentheses:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An equals sign followed by an expression:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A braced initializer list.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The list may be empty or may consist of a set of lists, as in the following example:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Kinds of initialization</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>There are several kinds of initialization, which may occur at different points in program execution.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Different kinds of initialization are not mutually exclusive—for example, list initialization can trigger value initialization and in other circumstances, it can trigger aggregate initialization.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Zero initialization</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Zero initialization is the setting of a variable to a zero value implicitly converted to the type:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Numeric variables are initialized to 0 (or 0.0, or 0.0000000000, etc.).</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Char variables are initialized to ‘\0’.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Pointers are initialized to <ph id="ph1">`nullptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Arrays, <bpt id="p1">[</bpt>POD<ept id="p1">](../standard-library/is-pod-class.md)</ept> classes, structs, and unions have their members initialized to a zero value.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed at different times:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>At program startup, for all named variables that have static duration.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>These variables may later be initialized again.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>During value initialization, for scalar types and POD class types that are initialized by using empty braces.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For arrays that have only a subset of their members initialized.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Here are some examples of zero initialization:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Default initialization</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Default initialization for classes, structs, and unions is initialization with a default constructor.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The default constructor can be called with no initialization expression or with the <ph id="ph1">`new`</ph> keyword:</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If the class, struct, or union does not have a default constructor, the compiler emits an error.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Scalar variables are default initialized when they are defined with no initialization expression.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>They have indeterminate values.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Arrays are default initialized when they are defined with no initialization expression.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When an array is default-initialized, its members are default initialized and have indeterminate values, as in the following example:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If the array members do not have a default constructor, the compiler emits an error.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Default initialization of constant variables</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Constant variables must be declared together with an initializer.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If they are scalar types they cause a compiler error, and if they are class types that have a default constructor they cause a warning:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Default initialization of static variables</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Static variables that are declared with no initializer are initialized to 0 (implicitly converted to the type).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information about initialization of global static objects, see <bpt id="p1">[</bpt>Additional Startup Considerations<ept id="p1">](../cpp/additional-startup-considerations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Value initialization</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Value initialization occurs in the following cases:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>a named value is initialized using empty brace initialization</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>an anonymous temporary object is initialized using empty parentheses or braces</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>an object is initialized with the <ph id="ph1">`new`</ph> keyword plus empty parentheses or braces</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Value initialization does the following:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>for classes with at least one public constructor, the default constructor is called</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>for non-union classes with no declared constructors, the object is zero-initialized and the default constructor is called</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>for arrays, every element is value-initialized</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>in all other cases, the variable is zero initialized</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Copy initialization</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Copy initialization is the initialization of one object using a different object.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It occurs in the following cases:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>a variable is initialized using an equals sign</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>an argument is passed to a function</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>an object is returned from a function</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>an exception is thrown or caught</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>a non-static data member is initialized using an equals sign</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>class, struct, and union members are initialized by copy initialization during aggregate initialization.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Aggregate initialization<ept id="p1">](#agginit)</ept> for examples.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The following code shows several examples of copy initialization:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Copy initialization cannot invoke explicit constructors.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In some cases, if the copy constructor of the class is deleted or inaccessible, copy initialization causes a compiler error.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Direct initialization</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Direct initialization is initialization using (non-empty) braces or parentheses.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Unlike copy initialization, it can invoke explicit constructors.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It occurs in the following cases:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>a variable is initialized with non-empty braces or parentheses</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>a variable is initialized with the <ph id="ph1">`new`</ph> keyword plus non-empty braces or parentheses</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>a variable is initialized with</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>in a constructor, base classes and non-static members are initialized with an initializer list</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>in the copy of a captured variable inside a lambda expression</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The following code shows some examples of direct initialization:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>List initialization</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>List initialization occurs when a variable is initialized using a braced initializer list.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Braced initializer lists can be used in the following cases:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>a variable is initialized</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>a class is initialized with the <ph id="ph1">`new`</ph> keyword</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>an object is returned from a function</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>an argument passed to a function</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>one of the arguments in a direct initialization</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>in a non-static data member initializer</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>in a constructor initializer list</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following code shows some examples of list initialization:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Aggregate initialization is a form of list initialization for arrays or class types (often structs or unions) that have:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>no private or protected members</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>no user-provided constructors, except for explicitly defaulted or deleted constructors</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>no base classes</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>no virtual member functions</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>no brace-or-equal initializers for non-static members</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Aggregate initializers consist of a braced initialization list, with or without an equals sign, as in the following example:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You should see the following output:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Array members that declared but not explicitly initialized during aggregate initialization are zero-initialized, as in <ph id="ph1">`myArr3`</ph> above.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Initializing unions and structs</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If a union does not have a constructor, you can initialize it with a single value (or with another instance of a union).</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The value is used to initialize the first non-static field.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This is different from struct initialization, in which the first value in the initializer is used to initialize the first field, the second to initialize the second field, and so on.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Compare the initialization of unions and structs in the following example:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Initializing aggregates that contain aggregates</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Aggregate types can contain other aggregate types, for example arrays of arrays, arrays of structs, and so on.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>These types are initialized by using nested sets of braces, for example:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Reference initialization</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Variables of reference type must be initialized with an object of the type from which the reference type is derived, or with an object of a type that can be converted to the type from which the reference type is derived.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The only way to initialize a reference with a temporary object is to initialize a constant temporary object.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Once initialized, a reference-type variable always points to the same object; it cannot be modified to point to another object.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Although the syntax can be the same, initialization of reference-type variables and assignment to reference-type variables are semantically different.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the preceding example, the assignments that change <ph id="ph1">`iVar`</ph> and <ph id="ph2">`lVar`</ph> look similar to the initializations, but have different effects.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The initialization specifies the object to which the reference-type variable points; the assignment assigns to the referred-to object through the reference.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Because both passing an argument of reference type to a function and returning a value of reference type from a function are initializations, the formal arguments to a function are initialized correctly, as are the references returned.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Reference-type variables can be declared without initializers only in the following:</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Function declarations (prototypes).</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Function-return type declarations.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Declaration of a reference-type class member.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Declaration of a variable explicitly specified as <ph id="ph1">`extern`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>When initializing a reference-type variable, the compiler uses the decision graph shown in the following figure to select between creating a reference to an object or creating a temporary object to which the reference points.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decision graph for initialization of ref types</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Decision Graph for Initialization of Reference Types</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>References to <ph id="ph1">`volatile`</ph> types (declared as <ph id="ph2">`volatile`</ph> <bpt id="p1">*</bpt>typename<ept id="p1">*</ept><bpt id="p2">**</bpt><ph id="ph3">&amp;</ph><ept id="p2">**</ept> <bpt id="p3">*</bpt>identifier<ept id="p3">*</ept>) can be initialized with <ph id="ph4">`volatile`</ph> objects of the same type or with objects that have not been declared as <ph id="ph5">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>They cannot, however, be initialized with <bpt id="p1">**</bpt>const<ept id="p1">**</ept> objects of that type.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Similarly, references to <bpt id="p1">**</bpt>const<ept id="p1">**</ept> types (declared as <bpt id="p2">**</bpt>const<ept id="p2">**</ept> <bpt id="p3">*</bpt>typename<ept id="p3">*</ept><bpt id="p4">**</bpt><ph id="ph1">&amp;</ph><ept id="p4">**</ept> <bpt id="p5">*</bpt>identifier<ept id="p5">*</ept>) can be initialized with <bpt id="p6">**</bpt>const<ept id="p6">**</ept> objects of the same type (or anything that has a conversion to that type or with objects that have not been declared as <bpt id="p7">**</bpt>const<ept id="p7">**</ept>).</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>They cannot, however, be initialized with <ph id="ph1">`volatile`</ph> objects of that type.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>References that are not qualified with either the <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> keyword can be initialized only with objects declared as neither <bpt id="p2">**</bpt>const<ept id="p2">**</ept> nor <ph id="ph2">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Initialization of external variables</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Declarations of automatic, register, static, and external variables can contain initializers.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>However, declarations of external variables can contain initializers only if the variables are not declared as <ph id="ph1">`extern`</ph>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>