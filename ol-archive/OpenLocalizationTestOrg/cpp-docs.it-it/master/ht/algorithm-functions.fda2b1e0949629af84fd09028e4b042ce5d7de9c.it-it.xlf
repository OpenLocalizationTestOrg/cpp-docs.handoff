<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ac73dec06f1bee1a55a847b8819b63c9c16ad45f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\algorithm-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e305248030682259443ed0b1b2e2b3fa331e2ff6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6c77855f8dec50e91df7b526dff2095d44b0ddc4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>algorithm<ph id="ph1">&amp;gt;</ph> functions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>algorithm<ph id="ph1">&amp;gt;</ph> functions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>move</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>adjacent_find</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>all_of</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>any_of</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>binary_search</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>copy</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>copy_backward</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>copy_if</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>copy_n</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>count</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>count_if</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>equal</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>equal_range</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>fill</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>fill_n</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>find</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>find_end</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>find_first_of</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>find_if</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>find_if_not</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>for_each</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>generate</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>generate_n</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>includes</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>inplace_merge</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>is_heap</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>is_heap_until</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>is_partitioned</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>is_permutation</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>is_sorted</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>is_sorted_until</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>iter_swap</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>lexicographical_compare</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>lower_bound</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>make_heap</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>max</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>max_element</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>merge</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>min</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>min_element</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>minmax</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>minmax_element</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>mismatch</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>move_backward</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>next_permutation</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>none_of</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>nth_element</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>partial_sort</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>partial_sort_copy</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>partition</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>partition_copy</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>partition_point</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>pop_heap</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>prev_permutation</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>push_heap</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>random_shuffle</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>remove</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>remove_copy</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>remove_copy_if</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>remove_if</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>replace</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>replace_copy</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>replace_copy_if</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>replace_if</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>reverse</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>reverse_copy</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>rotate</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>rotate_copy</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>search</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>search_n</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>set_difference</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>set_intersection</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>set_symmetric_difference</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>set_union</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>sort</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>sort_heap</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>stable_partition</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>stable_sort</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>std::shuffle</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>swap</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>swap_ranges</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>transform</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>unique</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>unique_copy</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>upper_bound</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>adjacent_find</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Searches for two adjacent elements that are either equal or satisfy a specified condition.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The binary predicate giving the condition to be satisfied by the values of the adjacent elements in the range being searched.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>A forward iterator to the first element of the adjacent pair that are either equal to each other (in the first version) or that satisfy the condition given by the binary predicate (in the second version), provided that such a pair of elements is found.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Otherwise, an iterator pointing to <ph id="ph1">`last`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`adjacent_find`</ph> algorithm is a nonmutating sequence algorithm.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The range to be searched must be valid; all pointers must be dereferenceable and the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The time complexity of the algorithm is linear in the number of elements contained in the range.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>all_of</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is present at each element in the given range.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where to start to check for a condition.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The iterator marks where a range of elements starts.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of the range of elements to check for a condition.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>A condition to test for.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This is a user-defined predicate function object that defines the condition to be satisfied by an element being checked.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the condition is detected at each element in the indicated range, and <ph id="ph2">`false`</ph> if the condition is not detected at least one time.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`true`</ph> only if, for each <ph id="ph2">`N`</ph> in the range <ph id="ph3">`[0,Last - first)`</ph>, the predicate <ph id="ph4">`comp(*(_First + N))`</ph> is <ph id="ph5">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>any_of</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is present at least once in the specified range of elements.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where to start checking a range of elements for a condition.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of the range of elements to check for a condition.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>A condition to test for.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This is provided by a user-defined predicate function object.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The predicate defines the condition to be satisfied by the element being tested.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the condition is detected at least once in the indicated range, <ph id="ph2">`false`</ph> if the condition is never detected.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`true`</ph> only if, for some <ph id="ph2">`N`</ph> in the range</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>, the predicate <ph id="ph1">`comp``(*(`</ph> <ph id="ph2">`first`</ph> <ph id="ph3">`+ N))`</ph> is true.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>binary_search</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Tests whether there is an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The value required to be matched by the value of the element or that must satisfy the condition with the element value specified by the binary predicate.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <ph id="ph1">`true`</ph>when satisfied and <ph id="ph2">`false`</ph> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>if an element is found in the range that is equal or equivalent to the specified value; otherwise, <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The sorted source range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The sorted range must each be arranged as a precondition to the application of the <ph id="ph1">`binary_search`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by <ph id="ph1">`binary_search`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The value types of the forward iterators need to be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id="ph1">`last`</ph> – <ph id="ph2">`first`</ph>).</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>copy</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the source range.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position that is one past the final element in the source range.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>destBeg</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <ph id="ph1">`result`</ph> + ( <ph id="ph2">`last`</ph> –  <ph id="ph3">`first`</ph> ).</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Because the algorithm copies the source elements in order beginning with the first element, the destination range can overlap with the source range provided the <ph id="ph1">`last`</ph> position of the source range is not contained in the destination range.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>copy<ept id="p1">**</ept> can be used to shift elements to the left but not the right, unless there is no overlap between the source and destination ranges.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>To shift to the right any number of positions, use the <bpt id="p1">[</bpt>copy_backward<ept id="p1">](../standard-library/algorithm-functions.md#copy_backward)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>copy<ept id="p1">**</ept> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>It cannot be used to create new elements and cannot insert elements into an empty container directly.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>copy_backward</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the source range.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position that is one past the final element in the source range.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of one past the final element in the destination range.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <ph id="ph1">`destEnd`</ph> – ( <ph id="ph2">`last`</ph> –  <ph id="ph3">`first`</ph> ).</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`copy_backward`</ph> algorithm imposes more stringent requirements than that the copy algorithm.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Both its input and output iterators must be bidirectional.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`copy_backward`</ph> and <bpt id="p1">[</bpt>move_backward<ept id="p1">](../standard-library/algorithm-functions.md#move_backward)</ept> algorithms are the only Standard Template Library algorithms designating the output range with an iterator pointing to the end of the destination range.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Because the algorithm copies the source elements in order beginning with the last element, the destination range can overlap with the source range provided the  <ph id="ph1">`first`</ph> position of the source range is not contained in the destination range.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>can be used to shift elements to the right but not the left, unless there is no overlap between the source and destination ranges.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>To shift to the left any number of positions, use the <bpt id="p1">[</bpt>copy<ept id="p1">](../standard-library/algorithm-functions.md#copy)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`copy_backward`</ph> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>It cannot be used to create new elements and cannot insert elements into an empty container directly.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>copy_if</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In a range of elements, copies the elements that are <ph id="ph1">`true`</ph> for the specified condition.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the start of a range to check for the condition.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of the range.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The output iterator that indicates the destination for the copied elements.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The condition against which every element in the range is tested.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>This condition is provided by a user-defined predicate function object.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A predicate takes one argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>An output iterator that equals <ph id="ph1">`dest`</ph> incremented once for each element that fulfills the condition.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In other words, the return value minus <ph id="ph1">`dest`</ph> equals the number of copied elements.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The template function evaluates</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>once for each <ph id="ph1">`N`</ph> in the range <ph id="ph2">`[0, last - first)`</ph>, for strictly increasing values of <ph id="ph3">`N`</ph> starting with the lowest value.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`dest`</ph> and  <ph id="ph2">`first`</ph> designate regions of storage, <ph id="ph3">`dest`</ph> must not be in the range <ph id="ph4">`[`</ph> <ph id="ph5">`first``,`</ph> <ph id="ph6">`last``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>copy_n</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Copies a specified number of elements.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where to copy elements from.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A signed or unsigned integer type specifying the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>An output iterator that indicates where to copy elements to.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Returns an output iterator where elements have been copied to.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>It is the same as the returned value of the third parameter, <ph id="ph1">`dest`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The template function evaluates <ph id="ph1">`*(dest + N) = *(first + N))`</ph> once for each <ph id="ph2">`N`</ph> in the range <ph id="ph3">`[0,`</ph> <ph id="ph4">`count``)`</ph>, for strictly increasing values of <ph id="ph5">`N`</ph> starting with the lowest value.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>It then returns <ph id="ph1">`dest`</ph> <ph id="ph2">`+ N`</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`dest`</ph> and <ph id="ph2">`first`</ph> designate regions of storage, <ph id="ph3">`dest`</ph> must not be in the range <ph id="ph4">`[``first``,`</ph> <ph id="ph5">`Last``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>count</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in a range whose values match a specified value.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be traversed.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range to be traversed.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The value of the elements to be counted.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The difference type of the <bpt id="p1">**</bpt>InputIterator<ept id="p1">**</ept> that counts the number of elements in the range [  <ph id="ph1">`first`</ph>, <ph id="ph2">`last`</ph> ) that have value <ph id="ph3">`val`</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>This algorithm is generalized to count elements that satisfy any predicate with the template function <bpt id="p1">[</bpt>count_if<ept id="p1">](../standard-library/algorithm-functions.md#count_if)</ept>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>count_if</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in a range whose values satisfy a specified condition.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if an element is to be counted.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A predicate takes single argument and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> or <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The number of elements that satisfy the condition specified by the predicate.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This template function is a generalization of the algorithm <bpt id="p1">[</bpt>count<ept id="p1">](../standard-library/algorithm-functions.md#count)</ept>, replacing the predicate "equals a specific value" with any predicate.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>equal</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Compares two ranges element by element for equality or equivalence in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`std::equal`</ph> when comparing elements in different container types (for example <ph id="ph2">`vector`</ph> and <ph id="ph3">`list`</ph>) or when comparing different element types, or when you need to compare sub-ranges of containers.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Otherwise, when comparing elements of the same type in the same container type, use the non-member <ph id="ph1">`operator==`</ph> that is provided for each container.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first range to be tested.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first range to be tested.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the second range to be tested.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of one past the last element in the second range to be tested.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if and only if the ranges are identical or equivalent under the binary predicate when compared element by element; otherwise, <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>If the two ranges are equal length, then the time complexity of the algorithm is linear in the number of elements contained in the range.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Otherwise the function immediately returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Neither the <ph id="ph1">`operator==`</ph> nor the user-defined predicate is required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>equal_range</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Given an ordered range, finds the subrange in which all elements are equivalent to a given value.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The value being searched for in the ordered range.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>A pair of forward iterators that specify a subrange, contained within the range searched, in which all of the elements are equivalent to <ph id="ph1">`val`</ph> in the sense defined by the binary predicate used (either <ph id="ph2">`comp`</ph> or the default, less-than).</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>If no elements in the range are equivalent to <ph id="ph1">`val`</ph>, the returned pair of forward iterators are equal and specify the point where <ph id="ph2">`val`</ph> could be inserted without disturbing the order of the range.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The first iterator of the pair returned by the algorithm is <bpt id="p1">[</bpt>lower_bound<ept id="p1">](../standard-library/algorithm-functions.md#lower_bound)</ept>, and the second iterator is <bpt id="p2">[</bpt>upper_bound<ept id="p2">](../standard-library/algorithm-functions.md#upper_bound)</ept>.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The range must be sorted according to the predicate provided to <ph id="ph1">`equal_range`</ph>.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>For example, if you are going to use the greater-than predicate, the range must be sorted in descending order.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Elements in the possibly empty subrange defined by the pair of iterators returned by <ph id="ph1">`equal_range`</ph> will be equivalent to <ph id="ph2">`val`</ph> in the sense defined by the predicate used.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id="ph1">`last`</ph> – <ph id="ph2">`first`</ph>).</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>fill</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Assigns the same new value to every element in a specified range.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be traversed.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be traversed.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The value to be assigned to elements in the range [  <ph id="ph1">`first`</ph>, <ph id="ph2">`last`</ph>).</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The complexity is linear with the size of the range.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>fill_n</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a specified number of elements in a range beginning with a particular element.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the range to be assigned the value <ph id="ph1">`Val`</ph>.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>A signed or unsigned integer type specifying the number of elements to be assigned the value.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The value to be assigned to elements in the range [ <ph id="ph1">`First`</ph>,          <bpt id="p1">*</bpt>First + Count<ept id="p1">*</ept>).</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>An iterator to the element that follows the last element filled if <ph id="ph1">`Count`</ph> &gt; zero, otherwise the first element.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The complexity is linear with the size of the range.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>find</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Locates the position of the first occurrence of an element in a range that has a specified value.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be searched for the specified value.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range to be searched for the specified value.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The value to be searched for.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first occurrence of the specified value in the range being searched.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>If no element is found with an equivalent value, returns <ph id="ph1">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>For a code example using <ph id="ph1">`find()`</ph>, see <bpt id="p1">[</bpt>find_if<ept id="p1">](../standard-library/algorithm-functions.md#find_if)</ept>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>find_end</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Looks in a range for the last subsequence that is identical to a specified sequence or that is equivalent in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the last element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to search for.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the last element in the range to search for.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element of the last subsequence within [First1, Last1) that matches the specified sequence [First2, Last2).</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>find_first_of</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Searches for the first occurrence of any of several values within a target range or for the first occurrence of any of several elements that are equivalent in a sense specified by a binary predicate to a specified set of the elements.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be matched.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be matched.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>find_if</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Locates the position of the first occurrence of an element in a range that satisfies a specified condition.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object or <bpt id="p1">[</bpt>lambda expression<ept id="p1">](../cpp/lambda-expressions-in-cpp.md)</ept> that defines the condition to be satisfied by the element being searched for.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>A predicate takes single argument and returns <ph id="ph1">`true`</ph> (satisfied) or <ph id="ph2">`false`</ph> (not satisfied).</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The signature of <ph id="ph1">`pred`</ph> must effectively be <ph id="ph2">`bool pred(const T&amp; arg);`</ph>, where <ph id="ph3">`T`</ph> is a type to which <ph id="ph4">`InputIterator`</ph> can be implicitly converted when dereferenced.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`const`</ph> keyword is shown only to illustrate that the function object or lambda should not modify the argument.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An input iterator that refers to the first element in the range that satisfies the condition specified by the predicate (the predicate results in <ph id="ph1">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>If no element is found to satisfy the predicate, returns <ph id="ph1">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>This template function is a generalization of the algorithm <bpt id="p1">[</bpt>find<ept id="p1">](../standard-library/algorithm-functions.md#find)</ept>, replacing the predicate "equals a specific value" with any predicate.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>For the logical opposite (find the first element that does not satisfy the predicate), see <bpt id="p1">[</bpt>find_if_not<ept id="p1">](../standard-library/algorithm-functions.md#find_if_not)</ept>.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>find_if_not</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Returns the first element in the indicated range that does not satisfy a condition.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object or <bpt id="p1">[</bpt>lambda expression<ept id="p1">](../cpp/lambda-expressions-in-cpp.md)</ept> that defines the condition to be not satisfied by the element being searched for.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>A predicate takes single argument and returns <ph id="ph1">`true`</ph> (satisfied) or <ph id="ph2">`false`</ph> (not satisfied).</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The signature of <ph id="ph1">`pred`</ph> must effectively be <ph id="ph2">`bool pred(const T&amp; arg);`</ph>, where <ph id="ph3">`T`</ph> is a type to which <ph id="ph4">`InputIterator`</ph> can be implicitly converted when dereferenced.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`const`</ph> keyword is shown only to illustrate that the function object or lambda should not modify the argument.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>An input iterator that refers to the first element in the range that does not satisfy the condition specified by the predicate (the predicate results in <ph id="ph1">`false`</ph>).</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>If all elements satisfy the predicate (the predicate results in <ph id="ph1">`true`</ph> for every element), returns <ph id="ph2">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>This template function is a generalization of the algorithm <bpt id="p1">[</bpt>find<ept id="p1">](../standard-library/algorithm-functions.md#find)</ept>, replacing the predicate "equals a specific value" with any predicate.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>For the logical opposite (find the first element that does satisfy the predicate), see <bpt id="p1">[</bpt>find_if<ept id="p1">](../standard-library/algorithm-functions.md#find_if)</ept>.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>For a code example readily adaptable to <ph id="ph1">`find_if_not()`</ph>, see <bpt id="p1">[</bpt>find_if<ept id="p1">](../standard-library/algorithm-functions.md#find_if)</ept>.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>for_each</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Applies a specified function object to each element in a forward order within a range and returns the function object.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range to be operated on.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range operated on.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>User-defined function object that is applied to each element in the range.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>A copy of the function object after it has been applied to all of the elements in the range.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The algorithm <ph id="ph1">`for_each`</ph> is very flexible, allowing the modification of each element within a range in different, user-specified ways.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Templatized functions may be reused in a modified form by passing different parameters.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>User-defined functions may accumulate information within an internal state that the algorithm may return after processing all of the elements in the range.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The complexity is linear with at most ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>generate</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Assigns the values generated by a function object to each element in a range.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to which values are to be assigned.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to which values are to be assigned.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The function object is invoked for each element in the range and does not need to return the same value each time it is called.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>It may, for example, read from a file or refer to and modify a local state.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The generator's result type must be convertible to the value type of the forward iterators for the range.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The complexity is linear, with exactly ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) calls to the generator being required.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>generate_n</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>Assigns the values generated by a function object to a specified number of elements in a range and returns to the position one past the last assigned value.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of first element in the range to which values are to be assigned.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>A signed or unsigned integer type specifying the number of elements to be assigned a value by the generator function.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The function object is invoked for each element in the range and does not need to return the same value each time it is called.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>It may, for example, read from a file or refer to and modify a local state.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The generator's result type must be convertible to the value type of the forward iterators for the range.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The complexity is linear, with exactly <ph id="ph1">`Count`</ph> calls to the generator being required.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>includes</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Tests whether one sorted range contains all the elements contained in a second sorted range, where the ordering or equivalence criterion between elements may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the first sorted range contains all the elements in the second sorted range; otherwise, <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>Another way to think of this test is that it determined whether the second source range is a subset of the first source range.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the algorithm includes in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm <bpt id="p1">**</bpt>merge<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>More precisely, the algorithm tests whether all the elements in the first sorted range under a specified binary predicate have equivalent ordering to those in the second sorted range.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most 2 <ph id="ph1">\*</ph> ( ( <bpt id="p1">*</bpt>last1 – first1<ept id="p1">*</ept>) – ( <bpt id="p2">*</bpt> last2 – first2<ept id="p2">*</ept>) ) – 1 comparisons for nonempty source ranges.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>inplace_merge</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Combines the elements from two consecutive sorted ranges into a single sorted range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the first of two consecutive sorted ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the second of two consecutive sorted ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position one past the last element in the second of two consecutive sorted ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The sorted consecutive ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The sorted consecutive ranges must each be arranged as a precondition to the application of the <ph id="ph1">`inplace_merge`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the element is the first range precedes the element from the second in the combined range.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The complexity depends on the available memory as the algorithm allocates memory to a temporary buffer.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>If sufficient memory is available, the best case is linear with ( <bpt id="p1">*</bpt> last – first<ept id="p1">*</ept>) – 1 comparisons; if no auxiliary memory is available, the worst case is  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> log <bpt id="p3">*</bpt>(N)<ept id="p3">*</ept>, where  <bpt id="p4">*</bpt>N<ept id="p4">*</ept> = ( <bpt id="p5">*</bpt> last – first<ept id="p5">*</ept>).</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>is_heap</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range form a heap.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>A random access iterator that indicates the start of a range to check for a heap.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>A random access iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>A condition to test to order elements.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>A binary predicate takes a single argument and returns <ph id="ph1">`true`</ph>or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range form a heap, <ph id="ph2">`false`</ph> if they do not.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>The first template function returns <bpt id="p1">[</bpt>is_heap_until<ept id="p1">](../standard-library/algorithm-functions.md#is_heap_until)</ept><ph id="ph1">`(`</ph> <ph id="ph2">`first``,`</ph> <ph id="ph3">`last``) ==`</ph> <ph id="ph4">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The second template function returns</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>is_heap_until</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Returns an iterator positioned at the first element in the range [ <ph id="ph1">`begin`</ph>, <ph id="ph2">`end`</ph>) that does not satisfy the heap ordering condition, or <ph id="ph3">`end`</ph> if the range forms a heap.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>A random access iterator that specifies the first element of a range to check for a heap.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>A random access iterator that specifies the end of the range to check for a heap.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>A binary predicate that specifies the strict weak ordering condition that defines a heap.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The default predicate when <ph id="ph1">`compare`</ph> is not specified is <ph id="ph2">`std::less&lt;&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`end`</ph> if the specified range forms a heap or contains one or fewer elements.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Otherwise, returns an iterator for the first element found that does not satisfy the heap condition.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The first template function returns the last iterator <ph id="ph1">`next`</ph> in <ph id="ph2">`[``begin``,`</ph> <ph id="ph3">`end``]`</ph> where <ph id="ph4">`[``begin``, next)`</ph> is a heap ordered by the function object <ph id="ph5">`std::less&lt;&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>If the distance <ph id="ph1">`end`</ph> <ph id="ph2">`-`</ph> <ph id="ph3">`begin`</ph> <ph id="ph4">`&lt; 2`</ph>, the function returns <ph id="ph5">`end`</ph>.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>The second template function behaves the same as the first, except that it uses the predicate <ph id="ph1">`compare`</ph> instead of <ph id="ph2">`std::less&lt;&gt;`</ph> as the heap ordering condition.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>is_partitioned</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if all the elements in the given range that test <ph id="ph2">`true`</ph> for a condition come before any elements that test <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where a range starts to check for a condition.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The condition to test for.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph>or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>Returns true when all of the elements in the given range that test <ph id="ph1">`true`</ph> for a condition come before any elements that test <ph id="ph2">`false`</ph>, and otherwise returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`true`</ph> only if all elements in <ph id="ph2">`[`</ph> <ph id="ph3">`first``,`</ph> <ph id="ph4">`last``)`</ph> are partitioned by <ph id="ph5">`comp`</ph>; that is, all elements <ph id="ph6">`X`</ph> in <ph id="ph7">`[`</ph> <ph id="ph8">`first``,`</ph> <ph id="ph9">`last``)`</ph> for which <ph id="ph10">`comp``(X)`</ph> is true occur before all elements <ph id="ph11">`Y`</ph> for which <ph id="ph12">`comp``(Y)`</ph> is <ph id="ph13">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>is_permutation</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>Returns true if both ranges contain the same elements, whether or not the elements are in the same order.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>A forward iterator that refers to the first element of the range.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>A forward iterator that refers one past the last element of the range.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>A forward iterator that refers to the first element of a second range, used for comparison.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>A forward iterator that refers to one past the last element of a second range, used for comparison.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>A predicate that tests for equivalence and returns a <ph id="ph1">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>when the ranges can be rearranged so as to be identical according to the comparator predicate; otherwise, <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>has quadratic complexity in the worst case.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The first template function assumes that there are as many elements in the range beginning at <ph id="ph1">`First2`</ph> as there are in the range designated by [ <ph id="ph2">`First1`</ph>, <ph id="ph3">`Last1`</ph>).</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>If there are more elements in the second range, they are ignored; if there are less, undefined behavior will occur.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>The third template function (C++14 and later) does not make this assumption.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>Both return <ph id="ph1">`true`</ph> only if, for each element X in the range designated by [ <ph id="ph2">`First1`</ph>, <ph id="ph3">`Last1`</ph>) there are as many elements Y in the same range for which X == Y as there are in the range beginning at <ph id="ph4">`First2`</ph> or [ <ph id="ph5">`First2, Last2).`</ph> Here, <ph id="ph6">`operator==`</ph> must perform a pairwise comparison between its operands.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>The second and fourth template functions behave the same, except that they replace <ph id="ph1">`operator==(X, Y)`</ph> with <ph id="ph2">`Pred(X, Y)`</ph>.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>To behave correctly, the predicate must be symmetric, reflexive and transitive.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The following example shows how to use <ph id="ph1">`is_permutation`</ph>:</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>is_sorted</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range are in sorted order.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates where the range to check begins.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The condition to test to determine an order between two elements.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>This performs the same task as <ph id="ph1">`operator&lt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>The first template function returns <bpt id="p1">[</bpt>is_sorted_until<ept id="p1">](http://msdn.microsoft.com/en-us/bbad99d0-deaa-4fe6-ae58-eb5b3e4dded0)</ept><ph id="ph1">`(`</ph> <ph id="ph2">`first``,`</ph> <ph id="ph3">`last``) ==`</ph> <ph id="ph4">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>The operator&lt; function performs the order comparison.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The second template function returns <ph id="ph1">`is_sorted_until``(`</ph> <ph id="ph2">`first``,`</ph> <ph id="ph3">`last``,`</ph> <ph id="ph4">`comp``) ==`</ph> <ph id="ph5">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`comp`</ph> predicate function performs the order comparison.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>is_sorted_until</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`ForwardIterator`</ph> that is set to the last element that is in sorted order from a specified range.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The second version lets you provide a <ph id="ph1">`BinaryPredicate`</ph> function that returns <ph id="ph2">`true`</ph> when two given elements are in sorted order, and <ph id="ph3">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates where the range to check starts.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>The condition to test to determine an order between two elements.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`ForwardIterator`</ph> set to the last element in sorted order.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The sorted sequence starts from  <ph id="ph1">`first`</ph>.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The first template function returns the last iterator <ph id="ph1">`next`</ph> in <ph id="ph2">`[`</ph> <ph id="ph3">`first``,`</ph> <ph id="ph4">`last``]`</ph> so that <ph id="ph5">`[`</ph> <ph id="ph6">`first``, next)`</ph> is a sorted sequence ordered by <ph id="ph7">`operator&lt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`distance()`</ph> <ph id="ph2">`&lt; 2`</ph> the function returns <ph id="ph3">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>The second template function behaves the same, except that it replaces <ph id="ph1">`operator&lt;(X, Y)`</ph> with <ph id="ph2">`comp``(X, Y)`</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>iter_swap</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Exchanges two values referred to by a pair of specified iterators.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>One of the forward iterators whose value is to be exchanged.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The second of the forward iterators whose value is to be exchanged.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>should be used in preference to i <bpt id="p1">**</bpt>ter_swap<ept id="p1">**</ept>, which was included in the C++ Standard for backward compatibility.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Fit1`</ph> and <ph id="ph2">`Fit2`</ph> are forward iterators, then <ph id="ph3">`iter_swap`</ph> ( <ph id="ph4">`Fit1`</ph>, <ph id="ph5">`Fit2`</ph> ), is equivalent to <ph id="ph6">`swap`</ph> ( * <ph id="ph7">`Fit1`</ph>, <ph id="ph8">\*</ph> <ph id="ph9">`Fit2`</ph> ).</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>The value types of the input forward iterators must have the same value.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>lexicographical_compare</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Compares element by element between two sequences to determine which is lesser of the two.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first range to be compared.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the first range to be compared.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the second range to be compared.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the second range to be compared.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the first range is lexicographically less than the second range; otherwise <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>A lexicographical comparison between sequences compares them element by element until:</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>It finds two corresponding elements unequal, and the result of their comparison is taken as the result of the comparison between sequences.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>No inequalities are found, but one sequence has more elements than the other, and the shorter sequence is considered less than the longer sequence.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>No inequalities are found and the sequences have the same number of elements, and so the sequences are equal and the result of the comparison is false.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>lower_bound</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Finds the position of the first element in an ordered range that has a value greater than or equivalent to a specified value, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The value whose first position or possible first position is being searched for in the ordered range.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>A forward iterator at the position of the first element in an ordered range with a value that is greater than or equivalent to a specified value, where the equivalence is specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>A sorted range is a precondition of using <ph id="ph1">`lower_bound`</ph> and where the ordering is the same as specified by with binary predicate.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The range is not modified by the algorithm <ph id="ph1">`lower_bound`</ph>.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id="ph1">`last – first`</ph>).</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>make_heap</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Converts elements from a specified range into a heap in which the first element is the largest and for which a sorting criterion may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be converted into a heap.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be converted into a heap.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Heaps have two properties:</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The first element is always the largest.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Elements may be added or removed in logarithmic time.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id="p1">[</bpt>priority_queue Class<ept id="p1">](../standard-library/priority-queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The complexity is linear, requiring 3 <ph id="ph1">\*</ph> ( <bpt id="p1">*</bpt> last – first<ept id="p1">*</ept>) comparisons.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>max</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>Compares two objects and returns the larger of the two, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>The first of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The second of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>A binary predicate used to compare the two objects.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The initializer list that contains the objects to be compared.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The greater of the two objects, unless neither is greater; in that case, it returns the first of the two objects.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>In the case of an initializer_list, it returns the greatest of the objects in the list.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`max`</ph> algorithm is unusual in having objects passed as parameters.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>If you need a function that operates on a range of elements, use <bpt id="p1">[</bpt>max_element<ept id="p1">](../standard-library/algorithm-functions.md#max_element)</ept> instead.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>max_element</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of largest element in a specified range where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched for the largest element.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched for the largest element.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first occurrence of the largest element in the range searched.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>The complexity is linear: ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) – 1 comparisons are required for a nonempty range.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>merge</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Combines all of the elements from two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be combined and sorted into a single range.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range where the two source ranges are to be combined into a single sorted range.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the last element in the sorted destination range.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the <bpt id="p1">**</bpt>merge<ept id="p1">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved in the destination range.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm <bpt id="p1">**</bpt>merge<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most ( <bpt id="p1">*</bpt> last1 – first1<ept id="p1">*</ept>) – ( <bpt id="p2">*</bpt> last2 – first2<ept id="p2">*</ept>) – 1 comparisons.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>list class<ept id="p1">](../standard-library/list-class.md)</ept> provides a member function "merge" to merge the elements of two lists.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>min</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>Compares two objects and returns the lesser of the two, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The first of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The second of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>A binary predicate used to compare the two objects.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The initializer_list that contains the members to be compared.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The lesser of the two objects, unless neither is lesser; in that case, it returns the first of the two objects.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>In the case of an initializer_list, it returns the least of the objects in the list.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`min`</ph> algorithm is unusual in having objects passed as parameters.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Most Standard Template Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>If you need a function that uses a range of elements, use <bpt id="p1">[</bpt>min_element<ept id="p1">](../standard-library/algorithm-functions.md#min_element)</ept>.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>min_element</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of smallest element in a specified range where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched for the smallest element.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched for the smallest element.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first occurrence of the smallest element in the range searched.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>The complexity is linear: ( <ph id="ph1">`last`</ph> – <ph id="ph2">`first`</ph>) – 1 comparisons are required for a nonempty range.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>minmax_element</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Performs the work performed by <ph id="ph1">`min_element`</ph> and <ph id="ph2">`max_element`</ph> in one call.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates the beginning of a range.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>A forward iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>An optional test used to order elements.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>Returns</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>min_element<ept id="p1">](../standard-library/algorithm-functions.md#min_element)</ept>(  <ph id="ph1">`first`</ph>, <ph id="ph2">`last`</ph>), <bpt id="p2">[</bpt>max_element<ept id="p2">](../standard-library/algorithm-functions.md#max_element)</ept>(  <ph id="ph3">`first`</ph>, <ph id="ph4">`last`</ph>)).</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>The first template function returns</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>The second template function behaves the same, except that it replaces <ph id="ph1">`operator&lt;(X, Y)`</ph> with <ph id="ph2">`comp``(X, Y)`</ph>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>If the sequence is non-empty, the function performs at most <ph id="ph1">`3 * (``last`</ph> <ph id="ph2">`-`</ph>  <ph id="ph3">`first`</ph> <ph id="ph4">`- 1) / 2`</ph> comparisons.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>minmax</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>Compares two input parameters and returns them as a pair, in order of lesser to greater.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>The first of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>The second of the two objects being compared.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>A binary predicate used to compare the two objects.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The initializer_list that contains the members to be compared.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The first template function returns <ph id="ph1">`pair&lt;const Type&amp;, const Type&amp;&gt;(``right``,`</ph> <ph id="ph2">`left``)`</ph> if <ph id="ph3">`right`</ph> is less than <ph id="ph4">`left`</ph>.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns <ph id="ph1">`pair&lt;const Type&amp;, const Type&amp;&gt;(``left``,`</ph> <ph id="ph2">`right``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>The second member function returns a pair where the first element is the lesser and the second is the greater when compared by the predicate <ph id="ph1">`comp`</ph>.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>The remaining template functions behave the same, except that they replace the <ph id="ph1">`left`</ph> and <ph id="ph2">`right`</ph> parameters with <ph id="ph3">`_IList`</ph>.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>The function performs exactly one comparison.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>mismatch</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Compares two ranges element by element and locates the first position where a difference occurs.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first range to be tested.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first range to be tested.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the second range to be tested.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of one past the last element in the second range to be tested.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that compares the current elements in each range and determines whether they are equivalent.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>It returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>A pair of iterators addressing the positions of the mismatch in the two ranges, the first component iterator to the position in the first range and the second component iterator to the position in the second range.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>If there is no difference between the elements in the ranges compared or if the binary predicate in the second version is satisfied by all element pairs from the two ranges, then the first component iterator points to the position one past the final element in the first range and the second component iterator to position one past the final element tested in the second range.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The first template function assumes that there are as many elements in the range beginning at first2 as there are in the range designated by [first1, last1).</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>If there are more in the second range, they are ignored; if there are less then undefined behavior will result.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>The time complexity of the algorithm is linear in the number of elements contained in the shorter range.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The user-defined predicate is not required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use mismatch.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The C++03 overload is shown only in order to demonstrate how it can produce an unexpected result.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>alg<ph id="ph1">&amp;gt;</ph> move</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Move elements associated with a specified range.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where to start the range of elements to move.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of a range of elements to move.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>The output iterator that is to contain the moved elements.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The template function evaluates <ph id="ph1">`*(``dest`</ph> <ph id="ph2">`+ N) =`</ph>  move <ph id="ph3">`(*(`</ph> <ph id="ph4">`first`</ph> <ph id="ph5">`+ N)))`</ph> once for each <ph id="ph6">`N`</ph> in the range <ph id="ph7">`[0,`</ph> <ph id="ph8">`last`</ph> <ph id="ph9">`-`</ph>  <ph id="ph10">`first``)`</ph>, for strictly increasing values of <ph id="ph11">`N`</ph> starting with the lowest value.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>It then returns <ph id="ph1">`dest`</ph> <ph id="ph2">`+ N`</ph>.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`dest`</ph>and  <ph id="ph2">`first`</ph> designate regions of storage, <ph id="ph3">`dest`</ph> must not be in the range <ph id="ph4">`[`</ph> <ph id="ph5">`first``,`</ph> <ph id="ph6">`last``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>move_backward</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Moves the elements of one iterator to another.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The move starts with the last element in a specified range, and ends with the first element in that range.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>An iterator that indicates the start of a range to move elements from.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>An iterator that indicates the end of a range to move elements from.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>This element is not moved.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of one past the final element in the destination range.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>The template function evaluates <ph id="ph1">`*(``destEnd`</ph> <ph id="ph2">`- N - 1) =`</ph> <ph id="ph3">`move``(*(``last`</ph> <ph id="ph4">`- N - 1)))`</ph> once for each <ph id="ph5">`N`</ph> in the range <ph id="ph6">`[0,`</ph> <ph id="ph7">`last`</ph> <ph id="ph8">`-`</ph>  <ph id="ph9">`first``)`</ph>, for strictly increasing values of <ph id="ph10">`N`</ph> starting with the lowest value.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>It then returns <ph id="ph1">`destEnd`</ph> <ph id="ph2">`- (``last`</ph> <ph id="ph3">`-`</ph>  <ph id="ph4">`first``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`destEnd`</ph> and  <ph id="ph2">`first`</ph> designate regions of storage, <ph id="ph3">`destEnd`</ph> must not be in the range <ph id="ph4">`[`</ph> <ph id="ph5">`first``,`</ph> <ph id="ph6">`last``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>and <ph id="ph1">`move_backward`</ph> are functionally equivalent to using <ph id="ph2">`copy`</ph> and <ph id="ph3">`copy_backward`</ph> with a move iterator.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>next_permutation</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position of the first element in the range to be permuted.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position one past the final element in the range to be permuted.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the lexicographically next permutation exists and has replaced the original ordering of the range; otherwise <bpt id="p2">**</bpt>false<ept id="p2">**</ept>, in which case the ordering is transformed into the lexicographically smallest permutation.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>The default binary predicate is less than and the elements in the range must be less than comparable to insure that the next permutation is well defined.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The complexity is linear with at most ( <bpt id="p1">*</bpt> last – first<ept id="p1">*</ept>)/2 swaps.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>nth_element</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>Partitions a range of elements, correctly locating the                 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>_Nth</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of element to be correctly ordered on the boundary of the partition.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`nth_element`</ph> algorithm does not guarantee that elements in the sub-ranges either side of the  <bpt id="p1">*</bpt>n<ept id="p1">*</ept>th element are sorted.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>It thus makes fewer guarantees than <ph id="ph1">`partial_sort`</ph>, which orders the elements in the range below some chosen element, and may be used as a faster alternative to <ph id="ph2">`partial_sort`</ph> when the ordering of the lower range is not required.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Elements are equivalent, but not necessarily equal, if neither is less than the other.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>The average of a sort complexity is linear with respect to  <bpt id="p1">*</bpt> last – first<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>none_of</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is never present among elements in the given range.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates where to start to check a range of elements for a condition.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of a range of elements.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The condition to test for.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>This is provided by a user-defined predicate function object that defines the condition.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the condition is not detected at least once in the indicated range, and <ph id="ph2">`false`</ph> if the condition is detected.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>The template function returns <ph id="ph1">`true`</ph> only if, for some <ph id="ph2">`N`</ph> in the range <ph id="ph3">`[0,`</ph> <ph id="ph4">`last`</ph> <ph id="ph5">`-`</ph>  <ph id="ph6">`first``)`</ph>, the predicate <ph id="ph7">`comp``(*(`</ph> <ph id="ph8">`first`</ph> <ph id="ph9">`+ N))`</ph> is always <ph id="ph10">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>partial_sort</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>Arranges a specified number of the smaller elements in a range into a nondescending order or according to an ordering criterion specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the subrange to be sorted.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be partially sorted.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Elements are equivalent, but not necessarily equal, if neither is less than the other.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>sort<ept id="p1">**</ept> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>The algorithm <ph id="ph1">`stable_sort`</ph> does preserve this original ordering.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>The average partial sort complexity is  <bpt id="p1">*</bpt>O<ept id="p1">*</ept>(( <ph id="ph1">`last`- `first`</ph>) log ( <ph id="ph2">`sortEnd`- `first`</ph>)).</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>partial_sort_copy</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range into a destination range where the source elements are ordered by either less than or another specified binary predicate.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the source range.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the source range.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the sorted destination range.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the sorted destination range.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <ph id="ph1">`true`</ph> when satisfied and <ph id="ph2">`false`</ph> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the element in the destination range one position beyond the last element inserted from the source range.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>The source and destination ranges must not overlap and must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The binary predicate must provide a strict weak ordering so that elements that are not equivalent are ordered, but elements that are equivalent are not.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>Two elements are equivalent under less than, but not necessarily equal, if neither is less than the other.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>partition</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position one past the final element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if an element is to be classified.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> or <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>Elements  <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and  <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are equivalent, but not necessarily equal, if both  <bpt id="p3">*</bpt>Pr<ept id="p3">*</ept> ( <bpt id="p4">*</bpt>a<ept id="p4">*</ept>,  <bpt id="p5">*</bpt>b<ept id="p5">*</ept>) is false and  <bpt id="p6">*</bpt>Pr<ept id="p6">*</ept> ( <bpt id="p7">*</bpt>b<ept id="p7">*</ept>,  <bpt id="p8">*</bpt>a<ept id="p8">*</ept>) if false, where  <bpt id="p9">*</bpt>Pr<ept id="p9">*</ept> is the parameter-specified predicate.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>partition<ept id="p1">**</ept> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The algorithm <bpt id="p1">**</bpt>stable_ partition<ept id="p1">**</ept> does preserve this original ordering.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>The complexity is linear: there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) applications of <ph id="ph3">`comp`</ph> and at most ( <ph id="ph4">`last`</ph> –  <ph id="ph5">`first`</ph>)/2 swaps.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>partition_copy</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>Copies elements for which a condition is <ph id="ph1">`true`</ph> to one destination, and for which the condition is <ph id="ph2">`false`</ph> to another.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>The elements must come from a specified range.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the beginning of a range to check for a condition.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>An input iterator that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>An output iterator used to copy elements that return true for a condition tested by using <ph id="ph1">`_Pred`</ph>.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>An output iterator used to copy elements that return false for a condition tested by using <ph id="ph1">`_Pred`</ph>.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The condition to test for.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>This is provided by a user-defined predicate function object that defines the condition to be tested.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>The template function copies each element <ph id="ph1">`X`</ph> in <ph id="ph2">`[`</ph> <ph id="ph3">`first``,`</ph> <ph id="ph4">`last``)`</ph> to <ph id="ph5">`*``dest1``++`</ph> if <ph id="ph6">`_Pred``(X)`</ph> is true, or to <ph id="ph7">`*``dest2``++ if not`</ph>.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>It returns <ph id="ph1">`pair&lt;OutputIterator1, OutputIterator2&gt;(``dest1``,`</ph> <ph id="ph2">`dest2``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>partition_point</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>Returns the first element in the given range that does not satisfy the condition.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>The elements are sorted so that those that satisfy the condition come before those that do not.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`ForwardIterator`</ph> that indicates the start of a range to check for a condition.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`ForwardIterator`</ph> that indicates the end of a range.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The condition to test for.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>A predicate takes a single argument and returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`ForwardIterator`</ph> that refers to the first element that does not fulfill the condition tested for by <ph id="ph2">`comp`</ph>, or returns <ph id="ph3">`last`</ph> if one is not found.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>The template function finds the first iterator <ph id="ph1">`it`</ph> in <ph id="ph2">`[`</ph> <ph id="ph3">`first``,``last``)`</ph> for which <ph id="ph4">`comp(*it)`</ph> is <ph id="ph5">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>The sequence must be ordered by <ph id="ph1">`comp`</ph>.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>pop_heap</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Removes the largest element from the front of a heap to the next-to-last position in the range and then forms a new heap from the remaining elements.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the heap.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the heap.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`pop_heap`</ph> algorithm is the inverse of the operation performed by the push_heap algorithm, in which an element at the next-to-last position of a range is added to a heap consisting of the prior elements in the range, in the case when the element being added to the heap is larger than any of the elements already in the heap.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>Heaps have two properties:</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>The first element is always the largest.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>Elements may be added or removed in logarithmic time.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id="p1">[</bpt>priority_queue Class<ept id="p1">](../standard-library/priority-queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>The range excluding the newly added element at the end must be a heap.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>The complexity is logarithmic, requiring at most log ( <bpt id="p1">*</bpt> last – first<ept id="p1">*</ept>) comparisons.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>prev_permutation</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Reorders the elements in a range so that the original ordering is replaced by the lexicographically previous greater permutation if it exists, where the sense of previous may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position of the first element in the range to be permuted.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position one past the final element in the range to be permuted.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <ph id="ph1">`true`</ph> when satisfied and <ph id="ph2">`false`</ph> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>if the lexicographically previous permutation exists and has replaced the original ordering of the range; otherwise <ph id="ph1">`false`</ph>, in which case the ordering is transformed into the lexicographically largest permutation.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The default binary predicate is less than and the elements in the range must be less-than comparable to ensure that the previous permutation is well defined.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The complexity is linear, with at most ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>)/2 swaps.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>push_heap</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Adds an element that is at the end of a range to an existing heap consisting of the prior elements in the range.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the heap.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be converted into a heap.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>The element must first be pushed back to the end of an existing heap and then the algorithm is used to add this element to the existing heap.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>Heaps have two properties:</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The first element is always the largest.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Elements may be added or removed in logarithmic time.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id="p1">[</bpt>priority_queue Class<ept id="p1">](../standard-library/priority-queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>The range excluding the newly added element at the end must be a heap.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>The complexity is logarithmic, requiring at most log ( <bpt id="p1">*</bpt>last – first<ept id="p1">*</ept>) comparisons.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>random_shuffle</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>The std::random_shuffle() function is deprecated, replaced by <bpt id="p1">[</bpt>std::shuffle()<ept id="p1">](../standard-library/algorithm-functions.md#std__shuffle)</ept>.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>For a code example and more information, see <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>random&gt;<ept id="p1">](../standard-library/random.md)</ept> and the Stackoverflow posting                 <bpt id="p2">[</bpt>Why are std::random_shuffle methods being deprecated in C++14?<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=397954)</ept>.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>remove</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>Eliminates a specified value from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>The value that is to be removed from the range.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>The order of the elements not removed remains stable.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>The complexity is linear; there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>list class<ept id="p1">](../standard-library/list-class.md)</ept> has a more efficient member function version of <bpt id="p2">**</bpt>remove<ept id="p2">**</ept>, which also relinks pointers.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>remove_copy</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range to a destination range, except that elements of a specified value are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range to which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>The value that is to be removed from the range.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the new end position of the destination range, one past the final element of the copy of the remnant sequence free of the specified value.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>The order of the elements not removed remains stable.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>The complexity is linear; there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>remove_copy_if</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range to a destination range, except that satisfying a predicate are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range to which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>The unary predicate that must be satisfied is the value of an element is to be replaced.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the new end position of the destination range, one past the final element of the remnant sequence free of the elements satisfying the predicate.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>The order of the elements not removed remains stable.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>The complexity is linear: there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>For information on how these functions behave, see <bpt id="p1">[</bpt>Checked Iterators<ept id="p1">](../standard-library/checked-iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>remove_if</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>Eliminates elements that satisfy a predicate from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the position of the first element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the position one past the final element in the range from which elements are being removed.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>The unary predicate that must be satisfied is the value of an element is to be replaced.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>The order of the elements not removed remains stable.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>The complexity is linear: there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>List has a more efficient member function version of remove which relinks pointers.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>replace</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>Examines each element in a range and replaces it if it matches a specified value.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the position of the first element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the position one past the final element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>The old value of the elements being replaced.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The new value being assigned to the elements with the old value.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>The order of the elements not replaced remains stable.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>The complexity is linear; there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments of new values.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>replace_copy</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>Examines each element in a source range and replaces it if it matches a specified value while copying the result into a new destination range.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>An input iterator pointing to the position of the first element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>An input iterator pointing to the position one past the final element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the first element in the destination range to where the altered sequence of elements is being copied.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>The old value of the elements being replaced.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>The new value being assigned to the elements with the old value.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>The order of the elements not replaced remains stable.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>The complexity is linear: there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments of new values.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>replace_copy_if</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>Examines each element in a source range and replaces it if it satisfies a specified predicate while copying the result into a new destination range.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>An input iterator pointing to the position of the first element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>An input iterator pointing to the position one past the final element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the position of the first element in the destination range to which elements are being copied.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>The unary predicate that must be satisfied is the value of an element is to be replaced.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>The new value being assigned to the elements whose old value satisfies the predicate.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>The order of the elements not replaced remains stable.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>The complexity is linear; there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments of new values.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>replace_if</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>Examines each element in a range and replaces it if it satisfies a specified predicate.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the position of the first element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the position one past the final element in the range from which elements are being replaced.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>The unary predicate that must be satisfied is the value of an element is to be replaced.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>The new value being assigned to the elements whose old value satisfies the predicate.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>The order of the elements not replaced remains stable.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>The algorithm <ph id="ph1">`replace_if`</ph> is a generalization of the algorithm <bpt id="p1">**</bpt>replace<ept id="p1">**</ept>, allowing any predicate to be specified, rather than equality to a specified constant value.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the equality between elements must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>The complexity is linear: there are ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons for equality and at most ( <ph id="ph3">`last`</ph> –  <ph id="ph4">`first`</ph>) assignments of new values.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>reverse</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements within a range.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position of the first element in the range within which the elements are being permuted.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position one past the final element in the range within which the elements are being permuted.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>reverse_copy</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements within a source range while copying them into a destination range</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position of the first element in the source range within which the elements are being permuted.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator pointing to the position one past the final element in the source range within which the elements are being permuted.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the position of the first element in the destination range to which elements are being copied.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>rotate</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>Exchanges the elements in two adjacent ranges.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be rotated.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be rotated.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>The complexity is linear with at most ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) swaps.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>rotate_copy</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve">
          <source>Exchanges the elements in two adjacent ranges within a source range and copies the result to a destination range.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be rotated.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>_</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be rotated.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the final element in the destination range.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source>The complexity is linear with at most ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) swaps.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>search</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve">
          <source>Searches for the first occurrence of a sequence within a target range whose elements are equal to those in a given sequence of elements or whose elements are equivalent in a sense specified by a binary predicate to the elements in the given sequence.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be matched.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be matched.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>Average complexity is linear with respect to the size of the searched range, and worst case complexity is also linear with respect to the size of the sequence being searched for.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>search_n</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve">
          <source>Searches for the first subsequence in a range that of a specified number of elements having a particular value or a relation to that value as specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>The size of the subsequence being searched for.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>The value of the elements in the sequence being searched for.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`operator==`</ph> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source>Complexity is linear with respect to the size of the searched.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>set_difference</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to one sorted source range, but not to a second sorted source range, into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the last element in the sorted destination range representing the difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source>The destination range should not overlap either of the source ranges and should be large enough to contain the first source range.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the <ph id="ph1">`set_difference`</ph> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved in the destination range.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm merge.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than-comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>If the source ranges contain duplicates of an element such that there are more in the first source range than in the second, then the destination range will contain the number by which the occurrences of those elements in the first source range exceed the occurrences of those elements in the second source range.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most 2 <ph id="ph1">\*</ph> ( ( <bpt id="p1">*</bpt>last1 – first1<ept id="p1">*</ept>) – ( <bpt id="p2">*</bpt>last2 – first2<ept id="p2">*</ept>) ) – 1 comparisons for nonempty source ranges.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>set_intersection</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to both sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>_<ept id="p1">**</ept> <bpt id="p2">*</bpt>Result<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the last element in the sorted destination range representing the intersection of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve">
          <source>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the merge algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved in the destination range.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve">
          <source>If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most 2 <ph id="ph1">\*</ph> ( ( <bpt id="p1">*</bpt>last1 – first1<ept id="p1">*</ept>) + ( <bpt id="p2">*</bpt>last2 – first2<ept id="p2">*</ept>) ) – 1 comparisons for nonempty source ranges.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve">
          <source>set_symmetric_difference</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to one, but not both, of the sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>_<ept id="p1">**</ept> <bpt id="p2">*</bpt>Result<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the last element in the sorted destination range representing the symmetric difference of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve">
          <source>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the <bpt id="p1">**</bpt>merge<ept id="p1">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved in the destination range.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm merge.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source>If the source ranges contain duplicates of an element, then the destination range will contain the absolute value of the number by which the occurrences of those elements in the one of the source ranges exceeds the occurrences of those elements in the second source range.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most 2 <ph id="ph1">\*</ph> ( (<bpt id="p1">*</bpt>last1 – first1<ept id="p1">*</ept>) – (<bpt id="p2">*</bpt>last2 – first2<ept id="p2">*</ept>) ) – 1 comparisons for nonempty source ranges.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>set_union</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to at least one of two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>_<ept id="p1">**</ept> <bpt id="p2">*</bpt>Result<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the sense in which one element is greater than another.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve">
          <source>The binary predicate takes two arguments and should return <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when the first element is less than the second element and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> otherwise.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the last element in the sorted destination range representing the union of the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>The sorted source ranges must each be arranged as a precondition to the application of the <bpt id="p1">**</bpt>merge<ept id="p1">**</ept> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source>The operation is stable as the relative order of elements within each range is preserved in the destination range.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>The source ranges are not modified by the algorithm <bpt id="p1">**</bpt>merge<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve">
          <source>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source>When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is linear with at most 2 <ph id="ph1">\*</ph> ( ( <bpt id="p1">*</bpt>last1 – first1<ept id="p1">*</ept>) – ( <bpt id="p2">*</bpt>last2 – first2<ept id="p2">*</ept>) ) – 1 comparisons.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve">
          <source>std::shuffle</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve">
          <source>Shuffles (rearranges) elements for a given range by using a random number generator.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve">
          <source>An iterator to the first element in the range to be shuffled, inclusive.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>Must meet the requirements of <ph id="ph1">`RandomAccessIterator`</ph> and <ph id="ph2">`ValueSwappable`</ph>.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve">
          <source>An iterator to the last element in the range to be shuffled, exclusive.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve">
          <source>Must meet the requirements of <ph id="ph1">`RandomAccessIterator`</ph> and <ph id="ph2">`ValueSwappable`</ph>.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source>The random number generator that the <ph id="ph1">`shuffle()`</ph> function will use for the operation.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>Must meet the requirements of a <ph id="ph1">`UniformRandomNumberGenerator`</ph>.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve">
          <source>For more information, and a code sample that uses <ph id="ph1">`shuffle()`</ph>, see <bpt id="p1">[</bpt><ph id="ph2">\&lt;</ph>random&gt;<ept id="p1">](../standard-library/random.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve">
          <source>sort</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source>This binary predicate takes two arguments and returns <ph id="ph1">`true`</ph> if the two arguments are in order and <ph id="ph2">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source>This comparator function must impose a strict weak ordering on pairs of elements from the sequence.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Algorithms<ept id="p1">](../standard-library/algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>Elements are equivalent, but not necessarily equal, if neither is less than the other.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`sort`</ph> algorithm is not stable and so does not guarantee that the relative ordering of equivalent elements will be preserved.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source>The algorithm <ph id="ph1">`stable_sort`</ph> does preserve this original ordering.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve">
          <source>The average of a sort complexity is  <bpt id="p1">*</bpt>O<ept id="p1">*</ept>( <bpt id="p2">*</bpt>N<ept id="p2">*</ept> log  <bpt id="p3">*</bpt>N<ept id="p3">*</ept>), where  <bpt id="p4">*</bpt>N<ept id="p4">*</ept><ph id="ph1"> =  </ph><bpt id="p5">*</bpt>last – first<ept id="p5">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve">
          <source>sort_heap</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve">
          <source>Converts a heap into a sorted range.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the target heap.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the target heap.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source>Heaps have two properties:</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>The first element is always the largest.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>Elements may be added or removed in logarithmic time.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve">
          <source>After the application if this algorithm, the range it was applied to is no longer a heap.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve">
          <source>This is not a stable sort because the relative order of equivalent elements is not necessarily preserved.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve">
          <source>Heaps are an ideal way to implement priority queues and they are used in the implementation of the Standard Template Library container adaptor <bpt id="p1">[</bpt>priority_queue Class<ept id="p1">](../standard-library/priority-queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>The complexity is at most  <bpt id="p1">*</bpt>N<ept id="p1">*</ept> log  <bpt id="p2">*</bpt>N<ept id="p2">*</ept>, where  <bpt id="p3">*</bpt>N<ept id="p3">*</ept> = ( <bpt id="p4">*</bpt>last – first<ept id="p4">*</ept>).</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>stable_partition</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve">
          <source>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it, preserving the relative order of equivalent elements.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position one past the final element in the range to be partitioned.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if an element is to be classified.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve">
          <source>A predicate takes single argument and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> or <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve">
          <source>Elements  <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and  <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are equivalent, but not necessarily equal, if both  <bpt id="p3">*</bpt>Pr<ept id="p3">*</ept> ( <bpt id="p4">*</bpt>a<ept id="p4">*</ept>,  <bpt id="p5">*</bpt>b<ept id="p5">*</ept>) is false and  <bpt id="p6">*</bpt>Pr<ept id="p6">*</ept> ( <bpt id="p7">*</bpt>b<ept id="p7">*</ept>,  <bpt id="p8">*</bpt>a<ept id="p8">*</ept>) if false, where  <bpt id="p9">*</bpt>Pr<ept id="p9">*</ept> is the parameter-specified predicate.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>stable_ partition<ept id="p1">**</ept> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve">
          <source>The algorithm <bpt id="p1">**</bpt>partition<ept id="p1">**</ept> does not necessarily preserve this original ordering.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve">
          <source>stable_sort</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate and preserves the relative ordering of equivalent elements.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve">
          <source>A bidirectional iterator addressing the position one past the final element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source>Elements are equivalent, but not necessarily equal, if neither is less than the other.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>sort<ept id="p1">**</ept> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve">
          <source>The run-time complexity of <ph id="ph1">`stable_sort`</ph> depends on the amount of memory available, but the best case (given sufficient memory) is  <bpt id="p1">*</bpt>O<ept id="p1">*</ept>( <bpt id="p2">*</bpt>N<ept id="p2">*</ept> log  <bpt id="p3">*</bpt>N<ept id="p3">*</ept>) and the worst case is  <bpt id="p4">*</bpt>O<ept id="p4">*</ept>(  <bpt id="p5">*</bpt>N<ept id="p5">*</ept> ( log  <bpt id="p6">*</bpt>N<ept id="p6">*</ept> )2 ), where  <bpt id="p7">*</bpt>N<ept id="p7">*</ept><ph id="ph2"> =  </ph><bpt id="p8">*</bpt>last – First.<ept id="p8">*</ept></source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve">
          <source>Usually, the <bpt id="p1">**</bpt>sort<ept id="p1">**</ept> algorithm is significantly faster than <ph id="ph1">`stable_sort`</ph>.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve">
          <source>swap</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve">
          <source>The first override exchanges the values of two objects.</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve">
          <source>The second override exchanges the values between two arrays of objects.</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve">
          <source>For the first override, the first object to have its contents exchanged.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve">
          <source>For the second override, the first array of objects to have its contents exchanged.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve">
          <source>For the first override, the second object to have its contents exchanged.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve">
          <source>For the second override, the second array of objects to have its contents exchanged.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve">
          <source>The first overload is designed to operate on individual objects.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve">
          <source>The second overload swaps the contents of objects between two arrays.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve">
          <source>swap_ranges</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve">
          <source>Exchanges the elements of one range with the elements of another, equal sized range.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the first position of the first range whose elements are to be exchanged.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to one past the final position of the first range whose elements are to be exchanged.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to the first position of the second range whose elements are to be exchanged.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>A forward iterator pointing to one past the final position of the second range whose elements are to be exchanged.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve">
          <source>The second range has to be as large as the first range.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve">
          <source>The complexity is linear with <ph id="ph1">`last1`</ph> –  <ph id="ph2">`first1`</ph> swaps performed.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve">
          <source>If elements from containers of the same type are being swapped, them the <ph id="ph1">`swap`</ph> member function from that container should be used, because the member function typically has constant complexity.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve">
          <source>transform</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve">
          <source>Applies a specified function object to each element in a source range or to a pair of elements from two source ranges and copies the return values of the function object into a destination range.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first source range to be operated on.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the first source range operated on.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the second source range to be operated on.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source>User-defined unary function object used in the first version of the algorithm that is applied to each element in the first source range or A user-defined (UD) binary function object used in the second version of the algorithm that is applied pairwise, in a forward order, to the two source ranges.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the final element in the destination range that is receiving the output elements transformed by the function object.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve">
          <source>The destination range must be large enough to contain the transformed source range.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`result`</ph> is set equal to  <ph id="ph2">`first1`</ph> in the first version of the algorithm <bpt id="p1">*</bpt>,<ept id="p1">*</ept> then the source and destination ranges will be the same and the sequence will be modified in place.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve">
          <source>But the <ph id="ph1">`result`</ph> may not address a position within the range [  <ph id="ph2">`first1`</ph> +1, <ph id="ph3">`last1`</ph>).</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve">
          <source>The complexity is linear with at most ( <ph id="ph1">`last1`</ph> –  <ph id="ph2">`first1`</ph>) comparisons.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve">
          <source>unique</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve">
          <source>Removes duplicate elements that are adjacent to each other in a specified range.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the range to be scanned for duplicate removal.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the range to be scanned for duplicate removal.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source>A forward iterator to the new end of the modified sequence that contains no consecutive duplicates, addressing the position one past the last element not removed.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source>Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve">
          <source>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve">
          <source>he number of elements in the sequence is not changed by the algorithm <bpt id="p1">**</bpt>unique<ept id="p1">**</ept> and the elements beyond the end of the modified sequence are dereferenceable but not specified.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve">
          <source>The complexity is linear, requiring ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) – 1 comparisons.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve">
          <source>List provides a more efficient member function "unique", which may perform better.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used on an associative container.</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve">
          <source>unique_copy</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range into a destination range except for the duplicate elements that are adjacent to each other.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position of the first element in the source range to be copied.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the position one past the final element in the source range to be copied.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range that is receiving the copy with consecutive duplicates removed.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the final element in the destination range that is receiving the copy with consecutive duplicates removed.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve">
          <source>Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve">
          <source>The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve">
          <source>The ranges referenced must be valid; all pointers must be dereferenceable and within a sequence the last position is reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve">
          <source>The complexity is linear, requiring ( <ph id="ph1">`last`</ph> –  <ph id="ph2">`first`</ph>) comparisons.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source>upper_bound</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve">
          <source>Finds the position of the first element in an ordered range that has a value that is greater than a specified value, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve">
          <source>The position of the first element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve">
          <source>The position one past the final element in the range to be searched.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve">
          <source>The value in the ordered range that needs to be exceeded by the value of the element addressed by the iterator returned.</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve">
          <source>User-defined predicate function object that defines sense in which one element is less than another.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> when satisfied and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve">
          <source>A forward iterator to the position of the first element that has a value greater than a specified value.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve">
          <source>The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve">
          <source>A sorted range is a precondition of the use of <ph id="ph1">`upper_bound`</ph> and where the ordering criterion is the same as specified by the binary predicate.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve">
          <source>The range is not modified by <ph id="ph1">`upper_bound`</ph>.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve">
          <source>The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve">
          <source>This results in an ordering between the nonequivalent elements</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve">
          <source>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to ( <ph id="ph1">`last - first`</ph>).</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve">
          <source>algorithm&gt;</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>