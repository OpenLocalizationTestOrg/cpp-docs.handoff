<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fe2885571c0a1f40f855e883d1c1d65a6768b03a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\tn041-mfc-ole1-migration-to-mfc-ole-2.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c50a8d9ff4ed78b3f23d2015a6d831c1301e88cb</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2d0177438b616415d5fe99c559e90f127cf3ce58</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>TN041: MFC-OLE1 Migration to MFC-OLE 2 | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>TN041: MFC/OLE1 Migration to MFC/OLE 2</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The following technical note has not been updated since it was first included in the online documentation.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>As a result, some procedures and topics might be out of date or incorrect.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For the latest information, it is recommended that you search for the topic of interest in the online documentation index.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>General Issues Relating to Migration</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>One of the design goals for the OLE 2 classes in MFC 2.5 (and higher) was to retain much of the same architecture put in place in MFC 2.0 for OLE 1.0 support.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>As a result, many of the same OLE classes in MFC 2.0 still exist in this version of MFC (<ph id="ph1">`COleDocument`</ph>, <ph id="ph2">`COleServerDoc`</ph>, <ph id="ph3">`COleClientItem`</ph>, <ph id="ph4">`COleServerItem`</ph>).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In addition, many of the APIs in these classes are exactly the same.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>However, OLE 2 is drastically different from OLE 1.0 so you can expect that some of the details have changed.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you are familiar with MFC 2.0's OLE1 support, you'll feel at home with MFC's 2.0 support.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If you are taking an existing MFC/OLE1 application and adding OLE 2 functionality to it, you should read this note first.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This note covers some general issues you may encounter while porting your OLE1 functionality to MFC/OLE 2 and then discusses the problems uncovered while porting two applications included in MFC 2.0: the MFC OLE samples <bpt id="p1">[</bpt>OCLIENT<ept id="p1">](../visual-cpp-samples.md)</ept> and <bpt id="p2">[</bpt>HIERSVR<ept id="p2">](../visual-cpp-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>MFC Document/View Architecture Is Important</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If your application does not use MFC's Document/View architecture and you want to add OLE 2 support to your application, now is the time to move to Document/View.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Many of the benefits of MFC's OLE 2 classes are only realized once your application is using the built-in architecture and components of MFC.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Implementing a server or container without using the MFC architecture is possible, but not recommended.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Use MFC Implementation Instead of Your Own</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>MFC "canned implementation" classes such as <ph id="ph1">`CToolBar`</ph>, <ph id="ph2">`CStatusBar`</ph>, and <ph id="ph3">`CScrollView`</ph> have built-in special case code for OLE 2 support.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>So, if you can use these classes in your application you'll benefit from the effort put into them to make them OLE aware.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Again, it is possible to "roll-your-own" classes here for these purposes, but it is not suggested.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If you need to implement similar functionality, the MFC source code is an excellent reference for dealing with some of the finer points of OLE (especially when it comes to in-place activation).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Examine the MFC Sample Code</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>There are a number of MFC samples that include OLE functionality.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Each of these applications implements OLE from a different angle:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>HIERSVR<ept id="p1">](../visual-cpp-samples.md)</ept> Meant mostly for use as a server application.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It was included in MFC 2.0 as an MFC/OLE1 application and has been ported to MFC/OLE 2 and then extended such that it implements many OLE features available in OLE 2.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>OCLIENT<ept id="p1">](../visual-cpp-samples.md)</ept> This is a stand-alone container application, meant to demonstrate many of the OLE features from a container standpoint.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It too was ported from MFC 2.0, and then extended to support many of the more advanced OLE features, such as custom clipboard formats and links to embedded items.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DRAWCLI<ept id="p1">](../visual-cpp-samples.md)</ept> This application implements OLE container support much like OCLIENT does, except that it does so within the framework of an existing object-oriented drawing program.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It shows you how you might implement OLE container support and integrate it into your existing application.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SUPERPAD<ept id="p1">](../visual-cpp-samples.md)</ept> This application, as well as being a fine stand-alone application, is also an OLE server.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The server support it implements is quite minimalist.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Of particular interest is how it uses OLE clipboard services to copy data to the clipboard, but uses the functionality built into the Windows "edit" control to implement clipboard paste functionality.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This shows an interesting mix of traditional Windows API usage as well as integration with the new OLE APIs.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information on the sample applications, see the "MFC Sample Help".</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Case Study: OCLIENT from MFC 2.0</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>As discussed above, <bpt id="p1">[</bpt>OCLIENT<ept id="p1">](../visual-cpp-samples.md)</ept> was included in MFC 2.0 and implemented OLE with MFC/OLE1.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The steps by which this application was initially converted to use the MFC/OLE 2 classes are described below.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A number of features were added after the initial port was completed to better illustrate the MFC/OLE classes.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>These features will not be covered here; refer to the sample itself for more information on those advanced features.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The compiler errors and step-by-step process was created with Visual C++ 2.0.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Specific error messages and locations may have changed with Visual C++ 4.0, but the conceptual information remains valid.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Getting It Up and Running</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The approach taken to port the OCLIENT sample to MFC/OLE is to start by building it and fixing the obvious compiler errors that will result.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If you take the OCLIENT sample from MFC 2.0 and compile it under this version of MFC, you'll find that there are not that many errors to resolve.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The errors in the order in which they occurred are described below.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Compile and Fix Errors</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The first error concerns <ph id="ph1">`COleClientItem::Draw`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1 it took more parameters than the MFC/OLE version takes.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The extra parameters were often not necessary and usually NULL (as in this example).</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This version of MFC can automatically determine the values for the lpWBounds when the CDC that is being drawn to is a metafile DC.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In addition, the pFormatDC parameter is no longer necessary since the framework will build one from the "attribute DC" of the pDC passed in.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>So to fix this problem, you simply remove the two extra NULL parameters to the Draw call.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The errors above result from the fact that all of the <bpt id="p1">**</bpt>COleClientItem::CreateXXXX<ept id="p1">**</ept> functions in MFC/OLE1 required that a unique name be passed to represent the item.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This was a requirement of the underlying OLE API.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This is not necessary in MFC/OLE 2 since OLE 2 does not use DDE as the underlying communications mechanism (the name was used in DDE conversations).</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can remove the <bpt id="p1">**</bpt>CreateNewName<ept id="p1">**</ept> function as well as all references to it.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It is easy to find out what each MFC/OLE function is expecting in this version simply by placing your cursor on the call and pressing F1.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Another area that is significantly different is OLE 2 clipboard handling.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>With OLE1, you used the Windows clipboard APIs interact with the clipboard.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>With OLE 2 this is done with a different mechanism.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The MFC/OLE1 APIs assumed that the clipboard was open before copying a <ph id="ph1">`COleClientItem`</ph> object to the clipboard.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is no longer necessary and will cause all MFC/OLE clipboard operations to fail.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>While you edit the code to remove dependencies on <bpt id="p1">**</bpt>CreateNewName<ept id="p1">**</ept>, you should also remove the code that opens and closes the Windows clipboard.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>These errors result from the <bpt id="p1">**</bpt>CMainView::OnInsertObject<ept id="p1">**</ept> handler.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Handling the "Insert New Object" command is another area where things have changed quite a bit.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this case, it is easiest to simply merge the original implementation with that provided by AppWizard for a new OLE Container application.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In fact, this is a technique that you can apply to porting other applications.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1, you displayed the "Insert Object" dialog by calling <bpt id="p1">**</bpt>AfxOleInsertDialog<ept id="p1">**</ept> function.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In this version you construct a <bpt id="p1">**</bpt>COleInsertObject<ept id="p1">**</ept> dialog object and call <ph id="ph1">`DoModal`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In addition, new OLE items are created with a <bpt id="p1">**</bpt>CLSID<ept id="p1">**</ept> instead of a classname string.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The end result should look something like this</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Insert New Object may be different for your application):</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It is also necessary to include <ph id="ph1">\&lt;</ph>afxodlgs.h&gt;, which contains the declaration for the <bpt id="p1">**</bpt>COleInsertObject<ept id="p1">**</ept> dialog class as well as the other standard dialogs provided by MFC.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>These errors are caused by the fact that some OLE1 constants have changed in OLE 2, even though in concept they are the same.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In this case <bpt id="p1">**</bpt>OLEVERB_PRIMARY<ept id="p1">**</ept> has changed to <ph id="ph1">`OLEIVERB_PRIMARY`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In both OLE1 and OLE 2, the primary verb is usually executed by a container when the user double-clicks on an item.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In addition, <ph id="ph1">`DoVerb`</ph> now takes an extra parameter — a pointer to a view (<ph id="ph2">`CView`</ph>*).</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This parameter is only used to implement "Visual Editing" (or in-place activation).</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For now you set that parameter to NULL, because you are not implementing this feature at this time.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>To make sure that the framework never attempts to in-place activate, you should override <ph id="ph1">`COleClientItem::CanActivate`</ph> as follows:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1, <bpt id="p1">**</bpt>COleClientItem::GetBounds<ept id="p1">**</ept> and <bpt id="p2">**</bpt>SetBounds<ept id="p2">**</ept> were used to query and manipulate the extent of an item (the <bpt id="p3">**</bpt>left<ept id="p3">**</ept> and <bpt id="p4">**</bpt>top<ept id="p4">**</ept> members were always zero).</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In MFC/OLE 2 this is more directly supported by <ph id="ph1">`COleClientItem::GetExtent`</ph> and <ph id="ph2">`SetExtent`</ph>, which deal with a <bpt id="p1">**</bpt>SIZE<ept id="p1">**</ept> or <ph id="ph3">`CSize`</ph> instead.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The code for your new SetItemRectToServer, and UpdateItemRectFromServer calls look like this:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1 synchronous API calls from a container to a server were <bpt id="p1">*</bpt>simulated<ept id="p1">*</ept>, because OLE1 was inherently asynchronous in many cases.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It was necessary to check for an outstanding asynchronous call in progress before processing commands from the user.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>MFC/OLE1 provided the <bpt id="p1">**</bpt>COleClientItem::InWaitForRelease<ept id="p1">**</ept> function for doing so.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In MFC/OLE 2 this is not necessary, so you can to remove the override of OnCommand in CMainFrame all together.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>At this point OCLIENT will compile and link.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Other Necessary Changes</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>There are few things that are not done that will keep OCLIENT from running, however.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>It is better to fix these problems now instead of later.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>First, it is necessary to initialize the OLE libraries.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This is done by calling <bpt id="p1">**</bpt>AfxOleInit<ept id="p1">**</ept> from <ph id="ph1">`InitInstance`</ph>:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>It is also a good idea to check for virtual functions for parameter list changes.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>One such function is <ph id="ph1">`COleClientItem::OnChange`</ph>, overridden in every MFC/OLE container application.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>By looking at online help, you'll see that an extra 'DWORD dwParam' was added.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The new CRectItem::OnChange looks as follows:</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1, container applications derived the document class from <bpt id="p1">**</bpt>COleClientDoc<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In MFC/OLE 2 this class has been removed and replaced by <ph id="ph1">`COleDocument`</ph> (this new organization makes it easier to build container/server applications).</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>There is a <ph id="ph1">`#define`</ph> that maps <bpt id="p1">**</bpt>COleClientDoc<ept id="p1">**</ept> to <ph id="ph2">`COleDocument`</ph> to simplify porting of MFC/OLE1 applications to MFC/OLE 2, such as OCLIENT.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One of the features not supplied by <ph id="ph1">`COleDocument`</ph> that was provided by <bpt id="p1">**</bpt>COleClientDoc<ept id="p1">**</ept> is the standard command message map entries.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This is done so that server applications, which also use <ph id="ph1">`COleDocument`</ph> (indirectly), do not carry with them the overhead of these command handlers unless they are a container/server application.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You need to add the following entries to the CMainDoc message map:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The implementation of all of these commands is in <ph id="ph1">`COleDocument`</ph>, which is the base class for your document.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>At this point, OCLIENT is a functional OLE container application.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It is possible to insert items of any type (OLE1 or OLE 2).</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Since the necessary code to enable in-place activation is not implemented, items are edited in a separate window much like with OLE1.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The next section discusses the necessary changes to enable in-place editing (sometimes called "Visual Editing").</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Adding "Visual Editing"</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>One of the most interesting features of OLE is in-place activation (or "Visual Editing").</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This feature allows the server application to take over portions of the container's user interface to provided a more seamless editing interface for the user.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To implement in-place activation to OCLIENT, some special resources need to be added, as well as some additional code.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These resources and the code are normally provided by AppWizard — in fact, much of the code here was borrowed directly from a fresh AppWizard application with "Container" support.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>First of all, it is necessary to add a menu resource to be used when there is an item which is in-place active.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You can create this extra menu resource in Visual C++ by copying the IDR_OCLITYPE resource and removing all but the File and Window pop-ups.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Two separator bars are inserted between the File and Window pop-ups to indicate the separation of groups (it should look like: File &amp;#124; &amp;#124; Window).</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For more information on what these separators mean and how the server and container menus are merged see "Menus and Resources: Menu Merging" in <bpt id="p1">*</bpt>OLE 2 Classes<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Once you have these menus created, you need to let the framework know about them.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This is done by calling <ph id="ph1">`CDocTemplate::SetContainerInfo`</ph> for the document template before you add it to the document template list in your InitInstance.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The new code to register the document template looks like this:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The IDR_OLECLITYPE_INPLACE resource is the special in-place resource created in Visual C++.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>To enable in-place activation, there are some things that need to change in both the <ph id="ph1">`CView`</ph> (CMainView) derived class as well as the <ph id="ph2">`COleClientItem`</ph> derived class (CRectItem).</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>All of these overrides are provided by AppWizard and most of the implementation will come directly from a default AppWizard application.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In the first step of this port, in-place activation was disabled entirely by overriding <ph id="ph1">`COleClientItem::CanActivate`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This override should be removed to allow in-place activation.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In addition, NULL was passed to all calls to <ph id="ph1">`DoVerb`</ph> (there are two of them) because providing the view was only necessary for in-place activation.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To fully implement in-place activation, it is necessary to pass the correct view in the <ph id="ph1">`DoVerb`</ph> call.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>One of these calls is in <bpt id="p1">**</bpt>CMainView::OnInsertObject<ept id="p1">**</ept>:</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Another is in <bpt id="p1">**</bpt>CMainView::OnLButtonDblClk<ept id="p1">**</ept>:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>It is necessary to override <ph id="ph1">`COleClientItem::OnGetItemPosition`</ph>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>This tells the server where to put its window relative to the container's window when the item is in-place activated.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For OCLIENT, the implementation is trivial:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Most servers also implement what is called "in-place resizing."</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This allows the server window to be sized and moved while the user is editing the item.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The container must participate in this action, since moving or resizing the window usually affects the position and size within the container document itself.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The implementation for OCLIENT synchronizes the internal rectangle maintained by m_rect with the new position and size.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>At this point, there is enough code to allow an item to be in-place activated and to deal with sizing and moving the item when it is active, but no code will allow the user to exit the editing session.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Although some servers will provide this functionality themselves by handling the escape key, it is suggested that containers provide two ways to deactivate an item: (1) by clicking outside the item, and (2) by pressing the ESCAPE key.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For the ESCAPE key, add an accelerator with Visual C++ that maps the VK_ESCAPE key to a command, ID_CANCEL_EDIT is added to the resources.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The handler for this command follows:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>To handle the case where the user clicks outside the item, you add the following code to the start of <bpt id="p1">**</bpt>CMainView::SetSelection<ept id="p1">**</ept>:</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>When an item is in-place active, it should have the focus.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>To make sure this is the case you handle OnSetFocus so that focus is always transferred to the active item when your view receives the focus:</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When the view is resized, you need to notify the active item that the clipping rectangle has changed.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>To do this you provide a handler for <ph id="ph1">`OnSize`</ph>:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Case Study: HIERSVR from MFC 2.0</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>HIERSVR<ept id="p1">](../visual-cpp-samples.md)</ept> was also included in MFC 2.0 and implemented OLE with MFC/OLE1.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This note briefly describes the steps by which this application was initially converted to use the MFC/OLE 2 classes.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A number of features were added after the initial port was completed to better illustrate the MFC/OLE 2 classes.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>These features will not be covered here; refer to the sample itself for more information on those advanced features.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The compiler errors and step-by-step process was created with Visual C++ 2.0.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Specific error messages and locations may have changed with Visual C++ 4.0, but the conceptual information remains valid.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Getting It Up and Running</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The approach taken to port the HIERSVR sample to MFC/OLE is to start by building it and fixing the obvious compiler errors that will result.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If you take the HIERSVR sample from MFC 2.0 and compile it under this version of MFC, you'll find that there are not many errors to resolve (although there are more than with the OCLIENT sample).</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The errors in the order in which they usually occur are described below.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Compile and Fix Errors</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>This first error points out a much larger problem with the <ph id="ph1">`InitInstance`</ph> function for servers.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The initialization required for an OLE server is probably one of the biggest changes you'll have to make to your MFC/OLE1 application to get it running.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The best thing to do is look at what AppWizard creates for an OLE server and modify your code as appropriate.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Here are some points to keep in mind:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>It is necessary to initialize the OLE libraries by calling <bpt id="p1">**</bpt>AfxOleInit<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Call SetServerInfo on the document template object to set server resource handles and runtime class information that you can't set with the <ph id="ph1">`CDocTemplate`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Don't show the main window of your application if /Embedding is present on the command line.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>You'll need a <bpt id="p1">**</bpt>GUID<ept id="p1">**</ept> for your document.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This is a unique identifier for your document's type (128 bits).</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>AppWizard will create one for you — so if you use the technique described here of copying the new code from a new AppWizard generated server application, you can simply "steal" the GUID from that application.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>If not, you can use the GUIDGEN.EXE utility in the BIN directory.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>It is necessary to "connect" your <ph id="ph1">`COleTemplateServer`</ph> object to the document template by calling <ph id="ph2">`COleTemplateServer::ConnectTemplate`</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Update the system registry when your application is run stand-alone.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This way, if the user moves the .EXE for your application, running it from its new location will update the Windows system registration database to point to the new location.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>After applying all of these changes based on what AppWizard creates for <ph id="ph1">`InitInstance`</ph>, the <ph id="ph2">`InitInstance`</ph> (and related GUID) for HIERSVR should read as follows:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>You will notice that the code above refers to a new resource ID, IDR_HIERSVRTYPE_SRVR_EMB.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is the menu resource to be used when a document that is embedded in another container is edited.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>In MFC/OLE1 the menu items specific to editing an embedded item were modified on the fly.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Using an entirely different menu structure when editing an embedded item instead of editing a file-based document makes it much easier to provide different user interfaces for these two separate modes.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>As you'll see later, an entirely separate menu resource is used when editing an embedded object in-place.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>To create this resource, load the resource script into Visual C++ and copy the existing IDR_HIERSVRTYPE menu resource.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Rename the new resource to IDR_HIERSVRTYPE_SRVR_EMB (this is the same naming convention that AppWizard uses).</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Next change "File Save" to "File Update"; give it command ID <bpt id="p1">**</bpt>ID_FILE_UPDATE<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Also change "File Save As" to "File Save Copy As"; give it command ID <bpt id="p1">**</bpt>ID_FILE_SAVE_COPY_AS<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The framework provides the implementation of both of these commands.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>There are a number of errors resulting from the override of <ph id="ph1">`OnSetData`</ph>, since it is referring to the <bpt id="p1">**</bpt>OLESTATUS<ept id="p1">**</ept> type.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OLESTATUS<ept id="p1">**</ept> was the way OLE1 returned errors.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>This has changed to <ph id="ph1">`HRESULT`</ph> in OLE 2, although MFC usually converts an <ph id="ph2">`HRESULT`</ph> into a <ph id="ph3">`COleException`</ph> containing the error.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>In this particular case, the override of <ph id="ph1">`OnSetData`</ph> is no longer necessary, so the easiest thing to do is to remove it.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`COleServerItem`</ph> constructor takes an extra 'BOOL' parameter.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>This flag determines how memory management is done on the <ph id="ph1">`COleServerItem`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>By setting it to TRUE, the framework handles the memory management of these objects — deleting them when they are no longer necessary.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>HIERSVR uses <bpt id="p1">**</bpt>CServerItem<ept id="p1">**</ept> (derived from <ph id="ph1">`COleServerItem`</ph>) objects as part of its native data, so you'll set this flag to FALSE.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This lets HIERSVR determine when each server item is deleted.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>As these errors imply, there are some 'pure-virtual' functions that have not been overridden in CServerItem.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Most likely this is caused by the fact that OnDraw's parameter list has changed.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>To fix this error, change <bpt id="p1">**</bpt>CServerItem::OnDraw<ept id="p1">**</ept> as follows (as well as the declaration in svritem.h):</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The new parameter is 'rSize'.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This allows you to fill in the size of the drawing, if convenient.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>This size must be in <bpt id="p1">**</bpt>HIMETRIC<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>In this case, it is not convenient to fill this value in, so the framework calls <ph id="ph1">`OnGetExtent`</ph> to retrieve the extent.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>For that to work, you'll have to implement <ph id="ph1">`OnGetExtent`</ph>:</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In the CServerItem::CalcNodeSize function the item size is converted to <bpt id="p1">**</bpt>HIMETRIC<ept id="p1">**</ept> and stored in <bpt id="p2">**</bpt>m_rectBounds<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The undocumented '<bpt id="p1">**</bpt>m_rectBounds<ept id="p1">**</ept>' member of <ph id="ph1">`COleServerItem`</ph> does not exist (it has been partially replaced by <ph id="ph2">`m_sizeExtent`</ph>, but in OLE 2 this member has a slightly different usage than <bpt id="p2">**</bpt>m_rectBounds<ept id="p2">**</ept> did in OLE1).</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Instead of setting the <bpt id="p1">**</bpt>HIMETRIC<ept id="p1">**</ept> size into this member variable, you'll return it.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>This return value is used in <ph id="ph1">`OnGetExtent`</ph>, implemented previously.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>CServerItem also overrides <bpt id="p1">**</bpt>COleServerItem::OnGetTextData<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This function is obsolete in MFC/OLE and is replaced by a different mechanism.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The MFC 3.0 version of the MFC OLE sample <bpt id="p1">[</bpt>HIERSVR<ept id="p1">](../visual-cpp-samples.md)</ept> implements this functionality by overriding <ph id="ph1">`COleServerItem::OnRenderFileData`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>This functionality is not important for this basic port, so you can remove the OnGetTextData override.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>There are many more errors in svritem.cpp that have not been addressed.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>They are not "real" errors — just errors caused by previous errors.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>no longer supports the 'bIncludeNative' flag.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The native data (the data written out by the server item's Serialize function) is always copied, so you remove the first parameter.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>In addition, <ph id="ph1">`CopyToClipboard`</ph> will throw an exception when an error happens instead of returning FALSE.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Change the code for CServerView::OnEditCopy as follows:</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Although there were more errors resulting from the compilation of the MFC 2.0 version of HIERSVR than there were for the same version of OCLIENT, there were actually fewer changes.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>At this point HIERSVR will compile and link and function as an OLE server, but without the in-place editing feature, which will be implemented next.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Adding "Visual Editing"</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>To add "Visual Editing" (or in-place activation) to this server application, there are only a few things you must take care of:</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>You need a special menu resource to be used when the item is in-place active.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This application has a toolbar, so you'll need a toolbar with only a subset of the normal toolbar to match the menu commands available from the server (matches the menu resource mentioned above).</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>You need a new class derived from <ph id="ph1">`COleIPFrameWnd`</ph> that provides the in-place user interface (much like CMainFrame, derived from <ph id="ph2">`CMDIFrameWnd`</ph>, provides the MDI user interface).</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>You need to tell the framework about these special resources and classes.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The menu resource is easy to create.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Run Visual C++, copy the menu resource IDR_HIERSVRTYPE to a menu resource called IDR_HIERSVRTYPE_SRVR_IP.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Modify the menu so that only the Edit and Help menu popups are left.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Add two separators to the menu in between the Edit and Help menus (it should look like: Edit &amp;#124; &amp;#124; Help).</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>For more information on what these separators mean and how the server and container menus are merged, see "Menus and Resources: Menu Merging" in <bpt id="p1">*</bpt>OLE 2 Classes<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The bitmap for the subset toolbar can be easily created by copying the one from a fresh AppWizard generated application with a "Server" option checked.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>This bitmap can then be imported into Visual C++.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Be sure to give the bitmap an ID of IDR_HIERSVRTYPE_SRVR_IP.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The class derived from <ph id="ph1">`COleIPFrameWnd`</ph> can be copied from an AppWizard generated application with server support as well.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Copy both files, IPFRAME.CPP and IPFRAME.H and add them to the project.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Make sure that the <ph id="ph1">`LoadBitmap`</ph> call refers to IDR_HIERSVRTYPE_SRVR_IP, the bitmap created in the previous step.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Now that all the new resources and classes are created, add the necessary code so that the framework knows about these (and knows that this application now supports in-place editing).</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>This is done by adding some more parameters to the <ph id="ph1">`SetServerInfo`</ph> call in the <ph id="ph2">`InitInstance`</ph> function:</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>It is now ready to run in-place in any container that also supports in-place activation.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>But, there is one minor bug still lurking in the code.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>HIERSVR supports a context menu, displayed when the user presses the right mouse button.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>This menu works when HIERSVR is fully open, but does not work when editing an embedding in-place.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The reason can be pinned down to this single line of code in CServerView::OnRButtonDown:</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Notice the reference to <bpt id="p1">**</bpt>AfxGetApp()-&gt;m_pMainWnd<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>When the server is in-place activated, it has a main window and m_pMainWnd is set, but it is usually invisible.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Furthermore, this window refers to the <bpt id="p1">*</bpt>main<ept id="p1">*</ept> window of the application, the MDI frame window that appears when the server is fully open or run stand-alone.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>It does not refer to the active frame window — which when in-place activated is a frame window derived from <ph id="ph1">`COleIPFrameWnd`</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>To get the correct active window even when in-place editing, this version of MFC adds a new function, <ph id="ph1">`AfxGetMainWnd`</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Generally, you should use this function instead of <bpt id="p1">**</bpt>AfxGetApp()-&gt;m_pMainWnd<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>This code needs to change as follows:</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Now you have an OLE server minimally enabled for functional in-place activation.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>But there are still many features available with MFC/OLE 2 that were not available in MFC/OLE1.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>See the HIERSVR sample for more ideas on features you might want to implement.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Some of the features that HIERSVR implements are listed below:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Zooming, for true WYSISYG behavior with respect to the container.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Drag / drop and a custom clipboard format.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Scrolling the container window as the selection is changed.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The HIERSVR sample in MFC 3.0 also uses a slightly different design for its server items.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>This helps conserve memory and makes your links more flexible.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>With the 2.0 version of HIERSVR each node in the tree <bpt id="p1">*</bpt>is-a<ept id="p1">*</ept> <ph id="ph1">`COleServerItem`</ph>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>carries a bit more overhead than is strictly necessary for each of these nodes, but a <ph id="ph1">`COleServerItem`</ph> is required for each active link.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>But for the most part, there are very few active links at any given time.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>To make this more efficient, the HIERSVR in this version of MFC separates the node from the <ph id="ph1">`COleServerItem`</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>It has both a CServerNode and a <bpt id="p1">**</bpt>CServerItem<ept id="p1">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>CServerItem<ept id="p1">**</ept> (derived from <ph id="ph1">`COleServerItem`</ph>) is only created as necessary.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Once the container (or containers) stop using that particular link to that particular node, the CServerItem object associated with the CServerNode is deleted.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>This design is more efficient and more flexible.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Its flexibility comes in when dealing with multiple selection links.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Neither of these two versions of HIERSVR support multiple selection, but it would be much easier to add (and to support links to such selections) with the MFC 3.0 version of HIERSVR, since the <ph id="ph1">`COleServerItem`</ph> is separated from the native data.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Technical Notes by Number</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Technical Notes by Category</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>