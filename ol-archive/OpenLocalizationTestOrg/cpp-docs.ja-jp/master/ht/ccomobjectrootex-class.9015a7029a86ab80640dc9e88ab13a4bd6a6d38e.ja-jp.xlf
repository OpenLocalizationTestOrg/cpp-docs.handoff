<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1dc3db19842764d6014e024b636218a0a98fafff</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\atl\reference\ccomobjectrootex-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df681e9f5f4d51cf5153f2bf6f0273def89cf96a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">843f4f867c6d4ae21bb7d89527d405e5286c8542</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This class provides methods to handle object reference count management for both nonaggregated and aggregated objects.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The class whose methods implement the desired threading model.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can explicitly choose the threading model by setting <ph id="ph1">`ThreadModel`</ph> to <bpt id="p1">[</bpt>CComSingleThreadModel<ept id="p1">](../../atl/reference/ccomsinglethreadmodel-class.md)</ept>, <bpt id="p2">[</bpt>CComMultiThreadModel<ept id="p2">](../../atl/reference/ccommultithreadmodel-class.md)</ept>, or <bpt id="p3">[</bpt>CComMultiThreadModelNoCS<ept id="p3">](../../atl/reference/ccommultithreadmodelnocs-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can accept the server's default thread model by setting <ph id="ph1">`ThreadModel`</ph> to <bpt id="p1">[</bpt>CComObjectThreadModel<ept id="p1">](atl-typedefs.md#ccomobjectthreadmodel)</ept> or <bpt id="p2">[</bpt>CComGlobalsThreadModel<ept id="p2">](atl-typedefs.md#ccomglobalsthreadmodel)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Methods</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Constructor.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>InternalAddRef</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Increments the reference count for a nonaggregated object.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>InternalRelease</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Decrements the reference count for a nonaggregated object.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Lock</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, obtains ownership of a critical section object.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Unlock</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, releases ownership of a critical section object.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>CComObjectRootBase Methods</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>FinalConstruct</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Override in your class to perform any initialization required by your object.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>FinalRelease</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Override in your class to perform any cleanup required by your object.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>OuterAddRef</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Increments the reference count for an aggregated object.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>OuterQueryInterface</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Delegates to the outer <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> of an aggregated object.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>OuterRelease</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Decrements the reference count for an aggregated object.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Static Functions</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>InternalQueryInterface</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Delegates to the <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> of a nonaggregated object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>ObjectMain</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Called during module initialization and termination for derived classes listed in the object map.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Data Members</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>m_dwRef</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">`m_pOuterUnknown`</ph>, part of a union.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Used when the object is not aggregated to hold the reference count of <ph id="ph1">`AddRef`</ph> and <bpt id="p1">**</bpt>Release<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>m_pOuterUnknown</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">`m_dwRef`</ph>, part of a union.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Used when the object is aggregated to hold a pointer to the outer unknown.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>handles object reference count management for both nonaggregated and aggregated objects.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It holds the object reference count if your object is not being aggregated, and holds the pointer to the outer unknown if your object is being aggregated.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For aggregated objects, <ph id="ph1">`CComObjectRootEx`</ph> methods can be used to handle the failure of the inner object to construct, and to protect the outer object from deletion when inner interfaces are released or the inner object is deleted.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A class that implements a COM server must inherit from <ph id="ph1">`CComObjectRootEx`</ph> or <bpt id="p1">[</bpt>CComObjectRoot<ept id="p1">](../../atl/reference/ccomobjectroot-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If your class definition specifies the <bpt id="p1">[</bpt>DECLARE_POLY_AGGREGATABLE<ept id="p1">](http://msdn.microsoft.com/library/7569e738-cfbc-4404-ba1d-78dcefa3bdb3)</ept> macro, ATL creates an instance of <bpt id="p2">**</bpt>CComPolyObject<ph id="ph1">\&lt;</ph>CYourClass&gt;<ept id="p2">**</ept> when <bpt id="p3">**</bpt>IClassFactory::CreateInstance<ept id="p3">**</ept> is called.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>During creation, the value of the outer unknown is checked.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If it is <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, <bpt id="p2">**</bpt>IUnknown<ept id="p2">**</ept> is implemented for a nonaggregated object.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If the outer unknown is not <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, <bpt id="p2">**</bpt>IUnknown<ept id="p2">**</ept> is implemented for an aggregated object.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If your class does not specify the <ph id="ph1">`DECLARE_POLY_AGGREGATABLE`</ph> macro, ATL creates an instance of <bpt id="p1">**</bpt>CAggComObject<ph id="ph2">\&lt;</ph>CYourClass&gt;<ept id="p1">**</ept> for aggregated objects or an instance of <bpt id="p2">**</bpt>CComObject<ph id="ph3">\&lt;</ph>CYourClass&gt;<ept id="p2">**</ept> for nonaggregated objects.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The advantage of using <ph id="ph1">`CComPolyObject`</ph> is that you avoid having both <ph id="ph2">`CComAggObject`</ph> and <ph id="ph3">`CComObject`</ph> in your module to handle the aggregated and nonaggregated cases.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A single <ph id="ph1">`CComPolyObject`</ph> object handles both cases.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Therefore, only one copy of the vtable and one copy of the functions exist in your module.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If your vtable is large, this can substantially decrease your module size.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, if your vtable is small, using <ph id="ph1">`CComPolyObject`</ph> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <ph id="ph2">`CComAggObject`</ph> and <ph id="ph3">`CComObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If your object is aggregated, <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is implemented by <ph id="ph1">`CComAggObject`</ph> or <ph id="ph2">`CComPolyObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>These classes delegate <ph id="ph1">`QueryInterface`</ph>, <ph id="ph2">`AddRef`</ph>, and <bpt id="p1">**</bpt>Release<ept id="p1">**</ept> calls to <ph id="ph3">`CComObjectRootEx`</ph>'s <ph id="ph4">`OuterQueryInterface`</ph>, <ph id="ph5">`OuterAddRef`</ph>, and <ph id="ph6">`OuterRelease`</ph> to forward to the outer unknown.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Typically, you override <ph id="ph1">`CComObjectRootEx::FinalConstruct`</ph> in your class to create any aggregated objects, and override <ph id="ph2">`CComObjectRootEx::FinalRelease`</ph> to free any aggregated objects.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If your object is not aggregated, <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> is implemented by <ph id="ph1">`CComObject`</ph> or <ph id="ph2">`CComPolyObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this case, calls to <ph id="ph1">`QueryInterface`</ph>, <ph id="ph2">`AddRef`</ph>, and <bpt id="p1">**</bpt>Release<ept id="p1">**</ept> are delegated to <ph id="ph3">`CComObjectRootEx`</ph>'s <ph id="ph4">`InternalQueryInterface`</ph>, <ph id="ph5">`InternalAddRef`</ph>, and <ph id="ph6">`InternalRelease`</ph> to perform the actual operations.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> atlcom.h</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::CComObjectRootEx</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The constructor initializes the reference count to 0.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::FinalConstruct</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can override this method in your derived class to perform any initialization required for your object.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Return <ph id="ph1">`S_OK`</ph> on success or one of the standard error <ph id="ph2">`HRESULT`</ph> values.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`CComObjectRootEx::FinalConstruct`</ph> simply returns <ph id="ph2">`S_OK`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>There are advantages to performing initialization in <ph id="ph1">`FinalConstruct`</ph> rather than the constructor of your class:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You cannot return a status code from a constructor, but you can return an <ph id="ph1">`HRESULT`</ph> by means of <ph id="ph2">`FinalConstruct`</ph>'s return value.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When objects of your class are being created using the standard class factory provided by ATL, this return value is propagated back to the COM client allowing you to provide them with detailed error information.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You cannot call virtual functions through the virtual function mechanism from the constructor of a class.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Calling a virtual function from the constructor of a class results in a statically resolved call to the function as it is defined at that point in the inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Calls to pure virtual functions result in linker errors.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Your class is not the most derived class in the inheritance hierarchy â€” it relies on a derived class supplied by ATL to provide some of its functionality.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>There is a good chance that your initialization will need to use the features provided by that class (this is certainly true when objects of your class need to aggregate other objects), but the constructor in your class has no way to access those features.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The construction code for your class is executed before the most derived class is fully constructed.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`FinalConstruct`</ph> is called immediately after the most derived class is fully constructed allowing you to call virtual functions and use the reference-counting implementation provided by ATL.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Typically, override this method in the class derived from <ph id="ph1">`CComObjectRootEx`</ph> to create any aggregated objects.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>NVC_ATL_COM#40</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the construction fails, you can return an error.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You can also use the macro <bpt id="p1">[</bpt>DECLARE_PROTECT_FINAL_CONSTRUCT<ept id="p1">](http://msdn.microsoft.com/library/2d2e5ddc-057a-43ca-87c8-d3477a8193a0)</ept> to protect your outer object from being deleted if, during creation, the internal aggregated object increments the reference count then decrements the count to 0.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Here is a typical way to create an aggregate:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Add an <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> pointer to your class object and initialize it to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept> in the constructor.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Override <ph id="ph1">`FinalConstruct`</ph> to create the aggregate.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> pointer you defined as the parameter to the <bpt id="p2">[</bpt>COM_INTERFACE_ENTRY_AGGREGATE<ept id="p2">](http://msdn.microsoft.com/library/c671fa40-a57b-4797-ae88-c9762dabd4dc)</ept> macro.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Override <ph id="ph1">`FinalRelease`</ph> to release the <bpt id="p1">**</bpt>IUnknown<ept id="p1">**</ept> pointer.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::FinalRelease</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can override this method in your derived class to perform any cleanup required for your object.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`CComObjectRootEx::FinalRelease`</ph> does nothing.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Performing cleanup in <ph id="ph1">`FinalRelease`</ph> is preferable to adding code to the destructor of your class since the object is still fully constructed at the point at which <ph id="ph2">`FinalRelease`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This enables you to safely access the methods provided by the most derived class.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This is particularly important for freeing any aggregated objects before deletion.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::InternalAddRef</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Increments the reference count of a nonaggregated object by 1.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A value that may be useful for diagnostics and testing.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, <bpt id="p1">**</bpt>InterlockedIncrement<ept id="p1">**</ept> is used to prevent more than one thread from changing the reference count at the same time.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::InternalQueryInterface</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Retrieves a pointer to the requested interface.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>[in] A pointer to the object that contains the COM map of interfaces exposed to <ph id="ph1">`QueryInterface`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>[in] A pointer to the <bpt id="p1">**</bpt>_ATL_INTMAP_ENTRY<ept id="p1">**</ept> structure that accesses a map of available interfaces.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>[in] The GUID of the interface being requested.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>[out] A pointer to the interface pointer specified in <ph id="ph1">`iid`</ph>, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> if the interface is not found.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>One of the standard <ph id="ph1">`HRESULT`</ph> values.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>only handles interfaces in the COM map table.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>If your object is aggregated, <ph id="ph1">`InternalQueryInterface`</ph> does not delegate to the outer unknown.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>You can enter interfaces into the COM map table with the macro <bpt id="p1">[</bpt>COM_INTERFACE_ENTRY<ept id="p1">](http://msdn.microsoft.com/library/19dcb768-2e1f-4b8d-a618-453a01a4bd00)</ept> or one of its variants.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::InternalRelease</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Decrements the reference count of a nonaggregated object by 1.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In both non-debug and debug builds, this function returns a value which may be useful for diagnostics or testing.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The exact value returned depends on many factors such as the operating system used, and may, or may not, be the reference count.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, <bpt id="p1">**</bpt>InterlockedDecrement<ept id="p1">**</ept> is used to prevent more than one thread from changing the reference count at the same time.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::Lock</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, this method calls the Win32 API function <bpt id="p1">[</bpt>EnterCriticalSection<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682608)</ept>, which waits until the thread can take ownership of the critical section object obtained through a private data member.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>When the protected code finishes executing, the thread must call <ph id="ph1">`Unlock`</ph> to release ownership of the critical section.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If the thread model is single-threaded, this method does nothing.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::m_dwRef</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Part of a union that accesses four bytes of memory.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">`m_pOuterUnknown`</ph>, part of a union:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If the object is not aggregated, the reference count accessed by <ph id="ph1">`AddRef`</ph> and <bpt id="p1">**</bpt>Release<ept id="p1">**</ept> is stored in <ph id="ph2">`m_dwRef`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If the object is aggregated, the pointer to the outer unknown is stored in <bpt id="p1">[</bpt>m_pOuterUnknown<ept id="p1">](#ccomobjectrootex__m_pouterunknown)</ept>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::m_pOuterUnknown</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Part of a union that accesses four bytes of memory.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">`m_dwRef`</ph>, part of a union:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If the object is aggregated, the pointer to the outer unknown is stored in <ph id="ph1">`m_pOuterUnknown`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If the object is not aggregated, the reference count accessed by <ph id="ph1">`AddRef`</ph> and <bpt id="p1">**</bpt>Release<ept id="p1">**</ept> is stored in <bpt id="p2">[</bpt>m_dwRef<ept id="p2">](#ccomobjectrootex__m_dwref)</ept>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::ObjectMain</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For each class listed in the <bpt id="p1">[</bpt>object map<ept id="p1">](http://msdn.microsoft.com/en-us/b57619cc-534f-4b8f-bfd4-0c12f937202f)</ept>, this function is called once when the module is initialized, and again when it is terminated.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>[out] The value is <bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the class is being initialized; otherwise <bpt id="p2">**</bpt>false<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The value of the <ph id="ph1">`bStarting`</ph> parameter indicates whether the module is being initialized or terminated.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The default implementation of <ph id="ph1">`ObjectMain`</ph> does nothing, but you can override this function in your class to initialize or clean up resources that you want to allocate for the class.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`ObjectMain`</ph> is called before any instances of the class are requested.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>is called from the entry point of the DLL, so the type of operation that the entry-point function can perform is restricted.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For more information on these restrictions, see <bpt id="p1">[</bpt>Run-Time Library Behavior<ept id="p1">](../../build/run-time-library-behavior.md)</ept> and <bpt id="p2">[</bpt>DllMain<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682583)</ept>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>NVC_ATL_COM#41</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::OuterAddRef</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the outer unknown of an aggregation.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>A value that may be useful for diagnostics and testing.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::OuterQueryInterface</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Retrieves an indirect pointer to the requested interface.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>[in] The GUID of the interface being requested.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>[out] A pointer to the interface pointer specified in <ph id="ph1">`iid`</ph>, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> if the aggregation does not support the interface.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>One of the standard <ph id="ph1">`HRESULT`</ph> values.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::OuterRelease</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Decrements the reference count of the outer unknown of an aggregation.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In non-debug builds, always returns 0.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>In debug builds, returns a value that may be useful for diagnostics or testing.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>CComObjectRootEx::Unlock</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If the thread model is multithreaded, this method calls the Win32 API function <bpt id="p1">[</bpt>LeaveCriticalSection<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms684169)</ept>, which releases ownership of the critical section object obtained through a private data member.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To obtain ownership, the thread must call <ph id="ph1">`Lock`</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Each call to <ph id="ph1">`Lock`</ph> requires a corresponding call to <ph id="ph2">`Unlock`</ph> to release ownership of the critical section.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>If the thread model is single-threaded, this method does nothing.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>CComAggObject Class</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>CComObject Class</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>CComPolyObject Class</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Class Overview</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>