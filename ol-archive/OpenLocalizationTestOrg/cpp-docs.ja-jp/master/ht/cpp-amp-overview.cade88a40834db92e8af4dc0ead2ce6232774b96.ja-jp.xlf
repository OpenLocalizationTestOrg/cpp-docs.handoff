<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ec57b01cf85eeba1285878fec16d335e930ddca6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\amp\cpp-amp-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">86ae4fc637eb6568229babd294bd692f287baa27</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">37c82dbe42b8b62063d7bbd4a356b502d723e947</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>C++ AMP Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>C++ AMP Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ Accelerated Massive Parallelism (C++ AMP) accelerates execution of C++ code by taking advantage of data-parallel hardware such as a graphics processing unit (GPU) on a discrete graphics card.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>By using C++ AMP, you can code multi-dimensional data algorithms so that execution can be accelerated by using parallelism on heterogeneous hardware.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The C++ AMP programming model includes multidimensional arrays, indexing, memory transfer, tiling, and a mathematical function library.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use C++ AMP language extensions to control how data is moved from the CPU to the GPU and back, so that you can improve performance.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>System Requirements</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">[!INCLUDE[win8](../../build/reference/includes/win8_md.md)]</ph>, <ph id="ph2">[!INCLUDE[winsvr08_r2](../../parallel/amp/includes/winsvr08_r2_md.md)]</ph>, or</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DirectX 11 Feature Level 11.0 or later hardware</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For debugging on the software emulator, <ph id="ph1">[!INCLUDE[win8](../../build/reference/includes/win8_md.md)]</ph> or <ph id="ph2">[!INCLUDE[winserver8](../../build/reference/includes/winserver8_md.md)]</ph> is required.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For debugging on the hardware, you must install the drivers for your graphics card.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Debugging GPU Code<ept id="p1">](/visualstudio/debugger/debugging-gpu-code)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Introduction</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following two examples illustrate the primary components of C++ AMP.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Assume that you want to add the corresponding elements of two one-dimensional arrays.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, you might want to add <ph id="ph1">`{1, 2, 3, 4, 5}`</ph> and <ph id="ph2">`{6, 7, 8, 9, 10}`</ph> to obtain <ph id="ph3">`{7, 9, 11, 13, 15}`</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Without using C++ AMP, you might write the following code to add the numbers and display the results.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The important parts of the code are as follows:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Data: The data consists of three arrays.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>All have the same rank (one) and length (five).</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Iteration: The first <ph id="ph1">`for`</ph> loop provides a mechanism for iterating through the elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The code that you want to execute to compute the sums is contained in the first <ph id="ph1">`for`</ph> block.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Index: The <ph id="ph1">`idx`</ph> variable accesses the individual elements of the arrays.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Using C++ AMP, you might write the following code instead.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The same basic elements are present, but C++ AMP constructs are used:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Data: You use C++ arrays to construct three C++ AMP <bpt id="p1">[</bpt>array_view<ept id="p1">](../../parallel/amp/reference/array-view-class.md)</ept> objects.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You supply four values to construct an <ph id="ph1">`array_view`</ph> object: the data values, the rank, the element type, and the length of the <ph id="ph2">`array_view`</ph> object in each dimension.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The rank and type are passed as type parameters.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The data and length are passed as constructor parameters.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In this example, the C++ array that is passed to the constructor is one-dimensional.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The rank and length are used to construct the rectangular shape of the data in the <ph id="ph1">`array_view`</ph> object, and the data values are used to fill the array.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The runtime library also includes the <bpt id="p1">[</bpt>array Class<ept id="p1">](../../parallel/amp/reference/array-class.md)</ept>, which has an interface that resembles the <ph id="ph1">`array_view`</ph> class and is discussed later in this article.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Iteration: The <bpt id="p1">[</bpt>parallel_for_each Function (C++ AMP)<ept id="p1">](reference/concurrency-namespace-functions-amp.md#parallel_for_each)</ept> provides a mechanism for iterating through the data elements, or <bpt id="p2">*</bpt>compute domain<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In this example, the compute domain is specified by <ph id="ph1">`sum.extent`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The code that you want to execute is contained in a lambda expression, or <bpt id="p1">*</bpt>kernel function<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict(amp)`</ph> indicates that only the subset of the C++ language that C++ AMP can accelerate is used.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Index: The <bpt id="p1">[</bpt>index Class<ept id="p1">](../../parallel/amp/reference/index-class.md)</ept> variable, <ph id="ph1">`idx`</ph>, is declared with a rank of one to match the rank of the <ph id="ph2">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>By using the index, you can access the individual elements of the <ph id="ph1">`array_view`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Shaping and Indexing Data: index and extent</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You must define the data values and declare the shape of the data before you can run the kernel code.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>All data is defined to be an array (rectangular), and you can define the array to have any rank (number of dimensions).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The data can be any size in any of the dimensions.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>index Class</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>index Class<ept id="p1">](../../parallel/amp/reference/index-class.md)</ept> specifies a location in the <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> object by encapsulating the offset from the origin in each dimension into one object.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When you access a location in the array, you pass an <ph id="ph1">`index`</ph> object to the indexing operator, <ph id="ph2">`[]`</ph>, instead of a list of integer indexes.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can access the elements in each dimension by using the <bpt id="p1">[</bpt>array::operator() Operator<ept id="p1">](reference/array-class.md#array__operator_call)</ept> or the <bpt id="p2">[</bpt>array_view::operator() Operator<ept id="p2">](reference/array-view-class.md#array_view__operator_call)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following example creates a one-dimensional index that specifies the third element in a one-dimensional <ph id="ph1">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The index is used to print the third element in the <ph id="ph1">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The output is 3.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following example creates a two-dimensional index that specifies the element where the row = 1 and the column = 2 in a two-dimensional <ph id="ph1">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The first parameter in the <ph id="ph1">`index`</ph> constructor is the row component, and the second parameter is the column component.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The output is 6.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The following example creates a three-dimensional index that specifies the element  where the depth = 0, the row = 1, and the column = 3 in a three-dimensional <ph id="ph1">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Notice that the first parameter is the depth component, the second parameter is the row component, and the third parameter is the column component.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The output is 8.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>extent Class</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>extent Class<ept id="p1">](../../parallel/amp/reference/extent-class.md)</ept> specifies the length of the data in each dimension of the <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can create an extent and use it to create an <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can also retrieve the extent of an existing <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following example prints the length of the extent in each dimension of an <ph id="ph1">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The following example creates an <ph id="ph1">`array_view`</ph> object that has the same dimensions as the object in the previous example, but this example uses an <ph id="ph2">`extent`</ph> object instead of using explicit parameters in the <ph id="ph3">`array_view`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Moving Data to the Accelerator: array and array_view</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Two data containers used to move data to the accelerator are defined in the runtime library.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>They are the <bpt id="p1">[</bpt>array Class<ept id="p1">](../../parallel/amp/reference/array-class.md)</ept> and the <bpt id="p2">[</bpt>array_view Class<ept id="p2">](../../parallel/amp/reference/array-view-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`array`</ph> class is a container class that creates a deep copy of the data when the object is constructed.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`array_view`</ph> class is a wrapper class that copies the data when the kernel function accesses the data.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When the data is needed on the source device the data is copied back.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>array Class</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When an <ph id="ph1">`array`</ph> object is constructed, a deep copy of the data is created on the accelerator if you use a constructor that includes a pointer to the data set.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The kernel function modifies the copy on the accelerator.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When the execution of the kernel function is finished, you must copy the data back to the source data structure.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example multiplies each element in a vector by 10.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>After the kernel function is finished, the <ph id="ph1">`vector conversion operator`</ph> is used to copy the data back into the vector object.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>array_view Class</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`array_view`</ph> has nearly the same members as the <ph id="ph2">`array`</ph> class, but the underlying behavior is not the same.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Data passed to the <ph id="ph1">`array_view`</ph> constructor is not replicated on the GPU as it is with an <ph id="ph2">`array`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Instead, the data is copied to the accelerator when the kernel function is executed.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Therefore, if you create two <ph id="ph1">`array_view`</ph> objects that use the same data, both <ph id="ph2">`array_view`</ph> objects refer to the same memory space.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When you do this, you have to synchronize any multithreaded access.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The main advantage of using the <ph id="ph1">`array_view`</ph> class is that data is moved only if it is necessary.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Comparison of array and array_view</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following table summarizes the similarities and differences between the <ph id="ph1">`array`</ph> and <ph id="ph2">`array_view`</ph> classes.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>array class</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>array_view class</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When rank is determined</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>At compile time.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>At compile time.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When extent is determined</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>At run time.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>At run time.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Shape</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Rectangular.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Rectangular.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Data storage</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Is a data container.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Is a data wrapper.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Copy</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Explicit and deep copy at definition.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Implicit copy when it is accessed by the kernel function.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Data retrieval</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>By copying the array data back to an object on the CPU thread.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>By direct access of the <ph id="ph1">`array_view`</ph> object or by calling the <bpt id="p1">[</bpt>array_view::synchronize Method<ept id="p1">](reference/array-view-class.md#synchronize)</ept> to continue accessing the data on the original container.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Shared memory with array and array_view</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Shared memory is memory that can be accessed by both the CPU and the accelerator.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The use of shared memory eliminates or significantly reduces the overhead of copying data between the CPU and the accelerator.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Although the memory is shared, it cannot be accessed concurrently by both the CPU and the accelerator, and doing so causes undefined behavior.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>objects can be used to specify fine-grained control over the use of shared memory if the associated accelerator supports it.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Whether an accelerator supports shared memory is determined by the accelerator’s <bpt id="p1">[</bpt>supports_cpu_shared_memory<ept id="p1">](reference/accelerator-class.md#supports_cpu_shared_memory)</ept> property, which returns <ph id="ph1">`true`</ph> when shared memory is supported.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If shared memory is supported, the default <bpt id="p1">[</bpt>access_type Enumeration<ept id="p1">](reference/concurrency-namespace-enums-amp.md#access_type)</ept> for memory allocations on the accelerator is determined by the <ph id="ph1">`default_cpu_access_type`</ph> property.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`array`</ph> and <ph id="ph2">`array_view`</ph> objects take on the same <ph id="ph3">`access_type`</ph> as the primary associated <ph id="ph4">`accelerator`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>By setting the <bpt id="p1">[</bpt>array::cpu_access_type Data Member<ept id="p1">](reference/array-class.md#cpu_access_type)</ept> property of an <ph id="ph1">`array`</ph> explicitly, you can exercise fine-grained control over how shared memory is used, so that you can optimize the app for the hardware’s performance characteristics, based on the memory access patterns of its computation kernels.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`array_view`</ph> reflects the same <ph id="ph2">`cpu_access_type`</ph> as the <ph id="ph3">`array`</ph> that it’s associated with; or, if the array_view is constructed without a data source, its <ph id="ph4">`access_type`</ph> reflects the environment that first causes it to allocate storage.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>That is, if it’s first accessed by the host (CPU), then it behaves as if it were created over a CPU data source and shares the <ph id="ph1">`access_type`</ph> of the <ph id="ph2">`accelerator_view`</ph> associated by capture; however, if it's first accessed by an <ph id="ph3">`accelerator_view`</ph>, then it behaves as if it were created over an <ph id="ph4">`array`</ph> created on that <ph id="ph5">`accelerator_view`</ph> and shares the <ph id="ph6">`array`</ph>’s <ph id="ph7">`access_type`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The following code example shows how to determine whether the default accelerator supports shared memory, and then creates several arrays that have different cpu_access_type configurations.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Executing Code over Data: parallel_for_each</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>parallel_for_each<ept id="p1">](reference/concurrency-namespace-functions-amp.md#parallel_for_each)</ept> function defines the code that you want to run on the accelerator against the data in the <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Consider the following code from the introduction of this topic.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`parallel_for_each`</ph> method takes two arguments, a compute domain and a lambda expression.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>compute domain<ept id="p1">*</ept> is an <ph id="ph1">`extent`</ph> object or a <ph id="ph2">`tiled_extent`</ph> object that defines the set of threads to create for parallel execution.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>One thread is generated for each element in the compute domain.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`extent`</ph> object is one-dimensional and has five elements.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, five threads are started.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> defines the code to run on each thread.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The capture clause, <ph id="ph1">`[=]`</ph>, specifies that the body of the lambda expression accesses all captured variables by value, which in this case are <ph id="ph2">`a`</ph>, <ph id="ph3">`b`</ph>, and <ph id="ph4">`sum`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In this example, the parameter list creates a one-dimensional <ph id="ph1">`index`</ph> variable named <ph id="ph2">`idx`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The value of the <ph id="ph1">`idx[0]`</ph> is 0 in the first thread and increases by one in each subsequent thread.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict(amp)`</ph> indicates that only the subset of the C++ language that C++ AMP can accelerate is used.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The limitations on functions that have the restrict modifier are described in <bpt id="p1">[</bpt>restrict (C++ AMP)<ept id="p1">](../../cpp/restrict-cpp-amp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For more information, see, <bpt id="p1">[</bpt>Lambda Expression Syntax<ept id="p1">](../../cpp/lambda-expression-syntax.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The lambda expression can include the code to execute or it can call a separate kernel function.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The kernel function must include the <ph id="ph1">`restrict(amp)`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous example, but it calls a separate kernel function.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Accelerating Code: Tiles and Barriers</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>You can gain additional acceleration by using tiling.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Tiling divides the threads into equal rectangular subsets or <bpt id="p1">*</bpt>tiles<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You determine the appropriate tile size based on your data set and the algorithm that you are coding.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For each thread, you have access to the <bpt id="p1">*</bpt>global<ept id="p1">*</ept> location of a data element relative to the whole <ph id="ph1">`array`</ph> or <ph id="ph2">`array_view`</ph> and access to the <bpt id="p2">*</bpt>local<ept id="p2">*</ept> location relative to the tile.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Using the local index value simplifies your code because you don't have to write the code to translate index values from global to local.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>To use tiling, call the <bpt id="p1">[</bpt>extent::tile Method<ept id="p1">](reference/extent-class.md#tile)</ept> on the compute domain in the <ph id="ph1">`parallel_for_each`</ph> method, and use a <bpt id="p2">[</bpt>tiled_index<ept id="p2">](../../parallel/amp/reference/tiled-index-class.md)</ept> object in the lambda expression.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In typical applications, the elements in a tile are related in some way, and the code has to access and keep track of values across the tile.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>tile_static Keyword<ept id="p1">](../../cpp/tile-static-keyword.md)</ept> keyword and the <bpt id="p2">[</bpt>tile_barrier::wait Method<ept id="p2">](reference/tile-barrier-class.md#wait)</ept> to accomplish this.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A variable that has the <ph id="ph1">`tile_static`</ph> keyword has a scope across an entire tile, and an instance of the variable is created for each tile.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>You must handle synchronization of tile-thread access to the variable.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>tile_barrier::wait Method<ept id="p1">](reference/tile-barrier-class.md#wait)</ept> stops execution of the current thread until all the threads in the tile have reached the call to <ph id="ph1">`tile_barrier::wait`</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>So you can accumulate values across the tile by using <ph id="ph1">`tile_static`</ph> variables.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Then you can finish any computations that require access to all the values.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The following diagram represents a two-dimensional array of sampling data that is arranged in tiles.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Index values in a tiled extent</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following code example uses the sampling data from the previous diagram.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The code replaces each value in the tile by the average of the values in the tile.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Math Libraries</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>C++ AMP includes two math libraries.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The double-precision library in the <bpt id="p1">[</bpt>Concurrency::precise_math Namespace<ept id="p1">](../../parallel/amp/reference/concurrency-precise-math-namespace.md)</ept> provides support for double-precision functions.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>It also provides support for single-precision functions, although double-precision support on the hardware is still required.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It complies with the <bpt id="p1">[</bpt>C99 Specification (ISO/IEC 9899)<ept id="p1">](http://go.microsoft.com/fwlink/linkid=225887)</ept>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The accelerator must support full double precision.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>You can determine whether it does by checking the value of the <bpt id="p1">[</bpt>accelerator::supports_double_precision Data Member<ept id="p1">](reference/accelerator-class.md#supports_double_precision)</ept>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The fast math library,  in the <bpt id="p1">[</bpt>Concurrency::fast_math Namespace<ept id="p1">](../../parallel/amp/reference/concurrency-fast-math-namespace.md)</ept>, contains another set of math functions.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>These functions, which support only <ph id="ph1">`float`</ph> operands, execute more quickly but aren’t as precise as those in the double-precision math library.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The functions are contained in the <ph id="ph1">\&lt;</ph>amp_math.h&gt; header file and all are declared with <ph id="ph2">`restrict(amp)`</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The functions in the <ph id="ph1">\&lt;</ph>cmath&gt; header file are imported into both the <ph id="ph2">`fast_math`</ph> and <ph id="ph3">`precise_math`</ph> namespaces.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict`</ph> keyword is used to distinguish the <ph id="ph2">\&lt;</ph>cmath&gt; version and the C++ AMP version.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following code calculates the base-10 logarithm, using the fast method, of each value that is in the compute domain.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Graphics Library</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>C++ AMP includes a graphics library that is designed for accelerated graphics programming.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This library is used only on devices that support native graphics functionality.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The methods are in the <bpt id="p1">[</bpt>Concurrency::graphics Namespace<ept id="p1">](../../parallel/amp/reference/concurrency-graphics-namespace.md)</ept> and are contained in the <ph id="ph1">\&lt;</ph>amp_graphics.h&gt; header file.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The key components of the graphics library are:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>texture Class<ept id="p1">](../../parallel/amp/reference/texture-class.md)</ept>: You can use the texture class to create textures from memory or from a file.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Textures resemble arrays because they contain data, and they resemble containers in the Standard Template Library (STL) with respect to assignment and copy construction.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>STL Containers<ept id="p1">](../../standard-library/stl-containers.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The template parameters for the <ph id="ph1">`texture`</ph> class are the element type and the rank.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The rank can be 1, 2, or 3.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The element type can be one of the short vector types that are described later in this article.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>writeonly_texture_view Class<ept id="p1">](../../parallel/amp/reference/writeonly-texture-view-class.md)</ept>: Provides write-only access to any texture.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Short Vector Library<ept id="p1">](http://msdn.microsoft.com/en-us/4c4f5bed-c396-493b-a238-c347563f645f)</ept>: Defines a set of short vector types of length 2, 3, and 4 that are based on <ph id="ph1">`int`</ph>, <ph id="ph2">`uint`</ph>, <ph id="ph3">`float`</ph>, <ph id="ph4">`double`</ph>, <bpt id="p2">[</bpt>norm<ept id="p2">](../../parallel/amp/reference/norm-class.md)</ept>, or <bpt id="p3">[</bpt>unorm<ept id="p3">](../../parallel/amp/reference/unorm-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Apps</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Like other C++ libraries, you can use C++ AMP in your <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>These articles describe how to include C++ AMP code in apps that is created by using C++, C#, Visual Basic, or JavaScript:</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Using C++ AMP in Windows Store Apps</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Bing Maps Trip Optimizer, a Window Store app in JavaScript and C++</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>How to use C++ AMP from C# using the Windows Runtime</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>How to use C++ AMP from C</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Calling Native Functions from Managed Code</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>C++ AMP and Concurrency Visualizer</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The Concurrency Visualizer includes support for analyzing performance of C++ AMP code.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>These articles describe these features:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>GPU Activity Graph</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>GPU Activity (Paging)</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>GPU Activity (This Process)</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>GPU Activity (Other Processes)</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Channels (Threads View)</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Analyzing C++ AMP Code with the Concurrency Visualizer</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Performance Recommendations</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Modulus and division of unsigned integers have significantly better performance than modulus and division of signed integers.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>We recommend that you use unsigned integers when possible.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>C++ AMP (C++ Accelerated Massive Parallelism)</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Lambda Expression Syntax</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Reference (C++ AMP)</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Parallel Programming in Native Code Blog</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>