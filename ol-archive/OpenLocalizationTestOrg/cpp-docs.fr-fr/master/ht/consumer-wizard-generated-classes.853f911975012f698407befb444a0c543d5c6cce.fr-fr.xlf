<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6304e9876a447716849c54a9042cb868e9e6440a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\data\oledb\consumer-wizard-generated-classes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3bb58c9d23fa7616bc07ac60260218300f000b9c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a19e1ca6b9c79ba3fc8fee19fbdaab0a09757e87</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Consumer Wizard-Generated Classes | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Consumer Wizard-Generated Classes</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>When you use the ATL OLE DB Consumer Wizard to generate a consumer, you have the choice of using OLE DB Templates or OLE DB attributes.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In both cases, the wizard generates a command class and a user record class.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The command class contains code to open the data source and rowset you specified in the wizard.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The user record class contains a column map for the database table you selected.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, the generated code differs in each case:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you select a templated consumer, the wizard generates a command class and a user record class.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The command class will have the name that you enter in the Class box in the wizard (for example, <ph id="ph1">`CProducts`</ph>), and the user record class will have a name of the form "<bpt id="p1">*</bpt>ClassName<ept id="p1">*</ept>Accessor" (for example, <ph id="ph2">`CProductsAccessor`</ph>).</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Both classes are placed in the consumer's header file.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you select an attributed consumer, the user record class will have a name of the form "_<bpt id="p1">*</bpt>ClassName<ept id="p1">*</ept>Accessor" and will be injected.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>That is, you will be able to view only the command class in the text editor; you can only view the user record class as injected code.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For information about viewing injected code, see <bpt id="p1">[</bpt>Debugging Injected Code<ept id="p1">](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following examples use a command class created on the Products table of the Northwind database to demonstrate the wizard-generated consumer code for the command class and user record class.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Templated User Record Classes</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If you create an OLE DB consumer using the OLE DB Templates (rather than the OLE DB attributes), the wizard generates code as described in this section.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Column Data Members</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The first part of the user record class includes the data member declarations and the status and length data members for each data-bound column.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For information about these data members, see <bpt id="p1">[</bpt>Field Status Data Members in Wizard-Generated Accessors<ept id="p1">](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you modify the user record class or write your own consumer, the data variables must come before the status and length variables.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The ATL OLE DB Consumer Wizard uses the <bpt id="p1">**</bpt>DB_NUMERIC<ept id="p1">**</ept> type to bind numeric data types.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It formerly used <bpt id="p1">**</bpt>DBTYPE_VARNUMERIC<ept id="p1">**</ept> (the format of which is described by the <bpt id="p2">**</bpt>DB_VARNUMERIC<ept id="p2">**</ept> type; see Oledb.h).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If you do not use the wizard to create consumers, it is recommended that you use <bpt id="p1">**</bpt>DB_NUMERIC<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Rowset Properties</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Next, the wizard sets rowset properties.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you selected <bpt id="p1">**</bpt>Change<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Insert<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> in the ATL OLE DB Consumer Wizard, the appropriate properties are set here (DBPROP_IRowsetChange is always set, then one or more of DBPROPVAL_UP_CHANGE, DBPROPVAL_UP_INSERT, and/or DBPROPVAL_UP_DELETE, respectively).</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Command or Table Class</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you specify a command class, the wizard declares the command class; for templated code, the command looks like this:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Column Map</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The wizard then generates the column bindings or column map.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To fix several issues with some providers, the following code might bind columns in a different order than that reported by the provider.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Class Declaration</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Finally, the wizard generates a command class declaration such as the following:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Attribute-Injected User Record Classes</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you create an OLE DB consumer using the database attributes (<bpt id="p1">[</bpt>db_command<ept id="p1">](../../windows/db-command.md)</ept> or <bpt id="p2">[</bpt>db_table<ept id="p2">](../../windows/db-table.md)</ept>), the attributes inject a user record class with a name of the form "_<bpt id="p3">*</bpt>ClassName<ept id="p3">*</ept>Accessor."</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if you named your command class <ph id="ph1">`COrders`</ph>, the user record class will be <ph id="ph2">`_COrdersAccessor`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Although the user record class appears in Class View, double-clicking it navigates to the command or table class in the header file instead.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In these cases, you can only view the actual declaration of the user record class by viewing the attribute-injected code.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There can be potential complications if you add or override methods in attributed consumers.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, you could add a <ph id="ph1">`_COrdersAccessor`</ph> constructor to the <ph id="ph2">`COrders`</ph> declaration, but note that in reality this adds a constructor to the injected <ph id="ph3">`COrdersAccessor`</ph> class.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Such a constructor can initialize the columns/parameters, but you cannot create a copy constructor this way, because it cannot directly instantiate the <ph id="ph1">`COrdersAccessor`</ph> object.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you need a constructor (or other method) directly on the <ph id="ph1">`COrders`</ph> class, it is recommended that you define a new class deriving from <ph id="ph2">`COrders`</ph> and add the necessary methods there.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the wizard generates a declaration for the class <ph id="ph1">`COrders`</ph>, but the user record class <ph id="ph2">`COrdersAccessor`</ph> does not appear, because the attributes inject it.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The injected command class declaration looks like this:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Most of the injected code is the same as or similar to the templated version.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The main differences are in the injected methods, which are described in <bpt id="p1">[</bpt>Consumer Wizard-Generated Methods<ept id="p1">](../../data/oledb/consumer-wizard-generated-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For information about viewing injected code, see <bpt id="p1">[</bpt>Debugging Injected Code<ept id="p1">](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Creating an OLE DB Consumer Using a Wizard</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>