<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">394723354c4d30b61f7b9062e652172833b7a6e9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\data\oledb\testing-the-read-only-provider.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba1c49c467ff21b96dea84d3f27e79736a24db3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a29851f0f6d85df5c63e1274dc140df84714d70b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Testing the Read-Only Provider | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Testing the Read-Only Provider</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>To test a provider, you need a consumer.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It helps if the consumer can match up with the provider.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The OLE DB consumer templates are a thin wrapper around OLE DB and match with the provider COM objects.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Because the source is shipped with the consumer templates, it is easy to debug a provider with them.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The consumer templates are also a very small and fast way to develop consumer applications.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The example in this topic creates a default MFC Application Wizard application for a test consumer.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The test application is a simple dialog with OLE DB consumer template code added.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To create the test application</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>On the <bpt id="p1">**</bpt>File<ept id="p1">**</ept> menu, click <bpt id="p2">**</bpt>New<ept id="p2">**</ept>, and then click <bpt id="p3">**</bpt>Project<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the Project Types pane, select the <bpt id="p1">**</bpt>Visual C++ Projects<ept id="p1">**</ept> folder.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In the Templates pane, select <bpt id="p1">**</bpt>MFC Application<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For the project name, enter <bpt id="p1">**</bpt>TestProv<ept id="p1">**</ept>, and then click <bpt id="p2">**</bpt>OK<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The MFC Application Wizard appears.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>On the <bpt id="p1">**</bpt>Application Type<ept id="p1">**</ept> page, select <bpt id="p2">**</bpt>Dialog based<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>On the <bpt id="p1">**</bpt>Advanced Features<ept id="p1">**</ept> page, select <bpt id="p2">**</bpt>Automation<ept id="p2">**</ept>, and then click <bpt id="p3">**</bpt>Finish<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The application does not require Automation support if you add <bpt id="p1">**</bpt>CoInitialize<ept id="p1">**</ept> in <bpt id="p2">**</bpt>CTestProvApp::InitInstance<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can view and edit the TestProv dialog box (IDD_TESTPROV_DIALOG) by selecting it in Resource View.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Place two list boxes, one for each string in the rowset, in the dialog box.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Turn off the sort property for both list boxes by pressing ALT+Enter when a list box is selected, clicking the <bpt id="p1">**</bpt>Styles<ept id="p1">**</ept> tab, and clearing the <bpt id="p2">**</bpt>Sort<ept id="p2">**</ept> check box.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Also, place a <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> button on the dialog box to fetch the file.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The finished TestProv dialog box should have two list boxes labeled "String 1" and "String 2", respectively; it also has <bpt id="p1">**</bpt>OK<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Run<ept id="p3">**</ept> buttons.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Open the header file for the dialog class (in this case TestProvDlg.h).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Add the following code to the header file (outside of any class declarations):</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The code represents a user record that defines what columns will be in the rowset.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When the client calls <bpt id="p1">**</bpt>IAccessor::CreateAccessor<ept id="p1">**</ept>, it uses these entries to specify which columns to bind.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The OLE DB consumer templates also allow you to bind columns dynamically.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The COLUMN_ENTRY macros are the client-side version of the PROVIDER_COLUMN_ENTRY macros.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The two COLUMN_ENTRY macros specify the ordinal, type, length, and data member for the two strings.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Add a handler function for the <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> button by pressing CTRL and double-clicking the <bpt id="p2">**</bpt>Run<ept id="p2">**</ept> button.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Place the following code in the function:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CCommand`</ph>, <ph id="ph2">`CDataSource`</ph>, and <ph id="ph3">`CSession`</ph> classes all belong to the OLE DB consumer templates.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Each class mimics a COM object in the provider.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CCommand`</ph> object takes the <ph id="ph2">`CProvider`</ph> class, declared in the header file, as a template parameter.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CProvider`</ph> parameter represents bindings that you use to access the data from the provider.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Here is the <ph id="ph1">`Open`</ph> code for the data source, session, and command:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The lines to open each of the classes create each COM object in the provider.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To locate the provider, use the ProgID of the provider.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can get the ProgID from the system registry or by looking in the MyProvider.rgs file (open the provider's directory and search for the ProgID key).</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The MyData.txt file is included with the MyProv sample.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To create a file of your own, use an editor and type an even number of strings, pressing ENTER between each string.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Change the path name if you move the file.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pass in the string "c:<ph id="ph1">\\</ph>\samples<ph id="ph2">\\</ph>\myprov<ph id="ph3">\\</ph>\MyData.txt" in the <ph id="ph4">`table.Open`</ph> line.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you step into the <ph id="ph1">`Open`</ph> call, you see that this string is passed to the <ph id="ph2">`SetCommandText`</ph> method in the provider.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`ICommandText::Execute`</ph> method used that string.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>To fetch the data, call <ph id="ph1">`MoveNext`</ph> on the table.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>calls the <bpt id="p1">**</bpt>IRowset::GetNextRows<ept id="p1">**</ept>, <ph id="ph1">`GetRowCount`</ph>, and <ph id="ph2">`GetData`</ph> functions.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When there are no more rows (that is, the current position in the rowset is greater than <ph id="ph1">`GetRowCount`</ph>), the loop terminates:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Note that when there are no more rows, providers return <bpt id="p1">**</bpt>DB_S_ENDOFROWSET<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>DB_S_ENDOFROWSET<ept id="p1">**</ept> value is not an error.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You should always check against <ph id="ph1">`S_OK`</ph> to cancel a data fetch loop and not use the SUCCEEDED macro.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You should now be able to build and test the program.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Enhancing the Simple Read-Only Provider</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>