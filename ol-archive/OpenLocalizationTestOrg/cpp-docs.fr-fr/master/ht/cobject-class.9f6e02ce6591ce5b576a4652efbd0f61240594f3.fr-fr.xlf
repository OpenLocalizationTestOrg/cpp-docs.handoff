<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad75c7f7ac8bb4db9df015d0370ba570f9a01a7e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\cobject-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1870a15e2360c9d4b481302d195b60a06b5952c4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a12f0b55bd2320157d46507f5e9b5b9b7d34c099</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CObject Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CObject Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The principal base class for the Microsoft Foundation Class Library.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Protected Constructors</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>CObject::CObject</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Default constructor.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>CObject::AssertValid</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Validates this object's integrity.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>CObject::Dump</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Produces a diagnostic dump of this object.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>CObject::GetRuntimeClass</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">`CRuntimeClass`</ph> structure corresponding to this object's class.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>CObject::IsKindOf</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Tests this object's relationship to a given class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>CObject::IsSerializable</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Tests to see whether this object can be serialized.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>CObject::Serialize</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Loads or stores an object from/to an archive.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Public Operators</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>CObject::operator delete</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Special <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> operator.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>CObject::operator new</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Special <bpt id="p1">**</bpt>new<ept id="p1">**</ept> operator.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It serves as the root not only for library classes such as <ph id="ph1">`CFile`</ph> and <ph id="ph2">`CObList`</ph>, but also for the classes that you write.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>provides basic services, including</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Serialization support</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Run-time class information</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Object diagnostic output</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Compatibility with collection classes</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`CObject`</ph> does not support multiple inheritance.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Your derived classes can have only one <ph id="ph1">`CObject`</ph> base class, and that <ph id="ph2">`CObject`</ph> must be leftmost in the hierarchy.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>It is permissible, however, to have structures and non- <ph id="ph1">`CObject`</ph>-derived classes in right-hand multiple-inheritance branches.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You will realize major benefits from <ph id="ph1">`CObject`</ph> derivation if you use some of the optional macros in your class implementation and declarations.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first-level macros, <bpt id="p1">[</bpt>DECLARE_DYNAMIC<ept id="p1">](run-time-object-model-services.md#declare_dynamic)</ept> and <bpt id="p2">[</bpt>IMPLEMENT_DYNAMIC<ept id="p2">](run-time-object-model-services.md#implement_dynamic)</ept>, permit run-time access to the class name and its position in the hierarchy.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This, in turn, allows meaningful diagnostic dumping.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second-level macros, <bpt id="p1">[</bpt>DECLARE_SERIAL<ept id="p1">](run-time-object-model-services.md#declare_serial)</ept> and <bpt id="p2">[</bpt>IMPLEMENT_SERIAL<ept id="p2">](run-time-object-model-services.md#implement_serial)</ept>, include all the functionality of the first-level macros, and they enable an object to be "serialized" to and from an "archive."</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For information about deriving Microsoft Foundation classes and C++ classes in general and using <ph id="ph1">`CObject`</ph>, see <bpt id="p1">[</bpt>Using CObject<ept id="p1">](../../mfc/using-cobject.md)</ept> and <bpt id="p2">[</bpt>Serialization<ept id="p2">](../../mfc/serialization-in-mfc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> afx.h</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>CObject::AssertValid</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Validates this object's integrity.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>performs a validity check on this object by checking its internal state.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the Debug version of the library, <ph id="ph1">`AssertValid`</ph> may assert and thus terminate the program with a message that lists the line number and filename where the assertion failed.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When you write your own class, you should override the <ph id="ph1">`AssertValid`</ph> function to provide diagnostic services for yourself and other users of your class.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The overridden <ph id="ph1">`AssertValid`</ph> usually calls the <ph id="ph2">`AssertValid`</ph> function of its base class before checking data members unique to the derived class.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`AssertValid`</ph> is a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> function, you are not permitted to change the object state during the test.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Your own derived class <ph id="ph1">`AssertValid`</ph> functions should not throw exceptions but rather should assert whether they detect invalid object data.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The definition of "validity" depends on the object's class.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>As a rule, the function should perform a "shallow check."</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>That is, if an object contains pointers to other objects, it should check to see whether the pointers are not null, but it should not perform validity testing on the objects referred to by the pointers.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#7</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For another example, see <bpt id="p1">[</bpt>AfxDoForAllObjects<ept id="p1">](diagnostic-services.md#afxdoforallobjects)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>CObject::CObject</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>These functions are the standard <ph id="ph1">`CObject`</ph> constructors.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>objectSrc</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A reference to another</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The default version is automatically called by the constructor of your derived class.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If your class is serializable (it incorporates the <ph id="ph1">`IMPLEMENT_SERIAL`</ph> macro), then you must have a default constructor (a constructor with no arguments) in your class declaration.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you do not need a default constructor, declare a private or protected "empty" constructor.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Using CObject<ept id="p1">](../../mfc/using-cobject.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The standard C++ default class copy constructor does a member-by-member copy.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The presence of the private <ph id="ph1">`CObject`</ph> copy constructor guarantees a compiler error message if the copy constructor of your class is needed but not available.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You must therefore provide a copy constructor if your class requires this capability.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in the <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#8</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>CObject::Dump</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Dumps the contents of your object to a <bpt id="p1">[</bpt>CDumpContext<ept id="p1">](../../mfc/reference/cdumpcontext-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The diagnostic dump context for dumping, usually <ph id="ph1">`afxDump`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>When you write your own class, you should override the <ph id="ph1">`Dump`</ph> function to provide diagnostic services for yourself and other users of your class.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The overridden <ph id="ph1">`Dump`</ph> usually calls the <ph id="ph2">`Dump`</ph> function of its base class before printing data members unique to the derived class.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>prints the class name if your class uses the <ph id="ph1">`IMPLEMENT_DYNAMIC`</ph> or <ph id="ph2">`IMPLEMENT_SERIAL`</ph> macro.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Your <ph id="ph1">`Dump`</ph> function should not print a newline character at the end of its output.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>calls make sense only in the Debug version of the Microsoft Foundation Class Library.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You should bracket calls, function declarations, and function implementations with <bpt id="p1">**</bpt>#ifdef _DEBUG<ept id="p1">**</ept><ph id="ph1">/ `#endif`</ph> statements for conditional compilation.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Since <ph id="ph1">`Dump`</ph> is a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> function, you are not permitted to change the object state during the dump.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CDumpContext insertion (&lt;&lt;) operator<ept id="p1">](../../mfc/reference/cdumpcontext-class.md#cdumpcontext__operator__lt__lt_)</ept> calls <ph id="ph1">`Dump`</ph> when a <ph id="ph2">`CObject`</ph> pointer is inserted.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>permits only "acyclic" dumping of objects.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can dump a list of objects, for example, but if one of the objects is the list itself, you will eventually overflow the stack.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#9</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>CObject::GetRuntimeClass</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">`CRuntimeClass`</ph> structure corresponding to this object's class.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A pointer to the <bpt id="p1">[</bpt>CRuntimeClass<ept id="p1">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure corresponding to this object's class; never <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>There is one <ph id="ph1">`CRuntimeClass`</ph> structure for each <ph id="ph2">`CObject`</ph>-derived class.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The structure members are as follows:</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>LPCSTR m_lpszClassName<ept id="p1">**</ept> A null-terminated string containing the ASCII class name.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>int m_nObjectSize<ept id="p1">**</ept> The size of the object, in bytes.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If the object has data members that point to allocated memory, the size of that memory is not included.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>UINT m_wSchema<ept id="p1">**</ept> The schema number ( – 1 for nonserializable classes).</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>IMPLEMENT_SERIAL<ept id="p1">](run-time-object-model-services.md#implement_serial)</ept> macro for a description of schema number.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CObject<ph id="ph1">\*</ph> ( PASCAL<ph id="ph2">\*</ph> m_pfnCreateObject )( )<ept id="p1">**</ept> A function pointer to the default constructor that creates an object of your class (valid only if the class supports dynamic creation; otherwise, returns <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRuntimeClass<ph id="ph1">\*</ph> ( PASCAL<ph id="ph2">\*</ph> m_pfn_GetBaseClass )( )<ept id="p1">**</ept> If your application is dynamically linked to the AFXDLL version of MFC, a pointer to a function that returns the <ph id="ph3">`CRuntimeClass`</ph> structure of the base class.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRuntimeClass<ph id="ph1">\*</ph> m_pBaseClass<ept id="p1">**</ept> If your application is statically linked to MFC, a pointer to the <ph id="ph2">`CRuntimeClass`</ph> structure of the base class.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This function requires use of the <bpt id="p1">[</bpt>IMPLEMENT_DYNAMIC<ept id="p1">](run-time-object-model-services.md#implement_dynamic)</ept>, <bpt id="p2">[</bpt>IMPLEMENT_DYNCREATE<ept id="p2">](run-time-object-model-services.md#implement_dyncreate)</ept>, or <bpt id="p3">[</bpt>IMPLEMENT_SERIAL<ept id="p3">](run-time-object-model-services.md#implement_serial)</ept> macro in the class implementation.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You will get incorrect results otherwise.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#10</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>CObject::IsKindOf</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Tests this object's relationship to a given class.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>CRuntimeClass<ept id="p1">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure associated with your <ph id="ph1">`CObject`</ph>-derived class.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Nonzero if the object corresponds to the class; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This function tests <ph id="ph1">`pClass`</ph> to see if (1) it is an object of the specified class or (2) it is an object of a class derived from the specified class.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This function works only for classes declared with the <bpt id="p1">[</bpt>DECLARE_DYNAMIC<ept id="p1">](run-time-object-model-services.md#declare_dynamic)</ept>, <bpt id="p2">[</bpt>DECLARE_DYNCREATE<ept id="p2">](run-time-object-model-services.md#declare_dyncreate)</ept>, or <bpt id="p3">[</bpt>DECLARE_SERIAL<ept id="p3">](run-time-object-model-services.md#declare_serial)</ept> macro.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Do not use this function extensively because it defeats the C++ polymorphism feature.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Use virtual functions instead.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#11</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>CObject::IsSerializable</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Tests whether this object is eligible for serialization.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Nonzero if this object can be serialized; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For a class to be serializable, its declaration must contain the <bpt id="p1">[</bpt>DECLARE_SERIAL<ept id="p1">](run-time-object-model-services.md#declare_serial)</ept> macro, and the implementation must contain the <bpt id="p2">[</bpt>IMPLEMENT_SERIAL<ept id="p2">](run-time-object-model-services.md#implement_serial)</ept> macro.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Do not override this function.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#12</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>CObject::operator delete</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For the Release version of the library, operator <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> frees the memory allocated by operator <bpt id="p2">**</bpt>new<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>In the Debug version, operator <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> participates in an allocation-monitoring scheme designed to detect memory leaks.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If you use the code line</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#14</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>before any of your implementations in a .CPP file, then the third version of <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> will be used, storing the filename and line number in the allocated block for later reporting.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You do not have to worry about supplying the extra parameters; a macro takes care of that for you.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Even if you do not use <ph id="ph1">`DEBUG_NEW`</ph> in Debug mode, you still get leak detection, but without the source-file line-number reporting described above.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>If you override operators <bpt id="p1">**</bpt>new<ept id="p1">**</ept> and <bpt id="p2">**</bpt>delete<ept id="p2">**</ept>, you forfeit this diagnostic capability.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in the <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#15</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>CObject::operator new</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For the Release version of the library, operator <bpt id="p1">**</bpt>new<ept id="p1">**</ept> performs an optimal memory allocation in a manner similar to <ph id="ph1">`malloc`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>In the Debug version, operator <bpt id="p1">**</bpt>new<ept id="p1">**</ept> participates in an allocation-monitoring scheme designed to detect memory leaks.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If you use the code line</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#14</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>before any of your implementations in a .CPP file, then the second version of <bpt id="p1">**</bpt>new<ept id="p1">**</ept> will be used, storing the filename and line number in the allocated block for later reporting.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>You do not have to worry about supplying the extra parameters; a macro takes care of that for you.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Even if you do not use <ph id="ph1">`DEBUG_NEW`</ph> in Debug mode, you still get leak detection, but without the source-file line-number reporting described above.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If you override this operator, you must also override <bpt id="p1">**</bpt>delete<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Do not use the standard library <bpt id="p1">**</bpt>_new_handler<ept id="p1">**</ept> function.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in the <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#16</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>CObject::Serialize</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Reads or writes this object from or to an archive.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CArchive`</ph> object to serialize to or from.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>You must override <ph id="ph1">`Serialize`</ph> for each class that you intend to serialize.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The overridden <ph id="ph1">`Serialize`</ph> must first call the <ph id="ph2">`Serialize`</ph> function of its base class.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You must also use the <bpt id="p1">[</bpt>DECLARE_SERIAL<ept id="p1">](run-time-object-model-services.md#declare_serial)</ept> macro in your class declaration, and you must use the <bpt id="p2">[</bpt>IMPLEMENT_SERIAL<ept id="p2">](run-time-object-model-services.md#implement_serial)</ept> macro in the implementation.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>CArchive::IsLoading<ept id="p1">](../../mfc/reference/carchive-class.md#carchive__isloading)</ept> or <bpt id="p2">[</bpt>CArchive::IsStoring<ept id="p2">](../../mfc/reference/carchive-class.md#carchive__isstoring)</ept> to determine whether the archive is loading or storing.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>is called by <bpt id="p1">[</bpt>CArchive::ReadObject<ept id="p1">](../../mfc/reference/carchive-class.md#carchive__readobject)</ept> and <bpt id="p2">[</bpt>CArchive::WriteObject<ept id="p2">](../../mfc/reference/carchive-class.md#carchive__writeobject)</ept>.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>These functions are associated with the <ph id="ph1">`CArchive`</ph> insertion operator ( <bpt id="p1">**</bpt><ph id="ph2">&lt;\&lt;</ph><ept id="p1">**</ept>) and extraction operator ( <bpt id="p2">**</bpt><ph id="ph3">&gt;&gt;</ph><ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For serialization examples, see the article <bpt id="p1">[</bpt>Serialization: Serializing an Object<ept id="p1">](../../mfc/serialization-serializing-an-object.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CObList::CObList<ept id="p1">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept> for a listing of the <ph id="ph1">`CAge`</ph> class used in all <ph id="ph2">`CObject`</ph> examples.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#13</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Hierarchy Chart</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>