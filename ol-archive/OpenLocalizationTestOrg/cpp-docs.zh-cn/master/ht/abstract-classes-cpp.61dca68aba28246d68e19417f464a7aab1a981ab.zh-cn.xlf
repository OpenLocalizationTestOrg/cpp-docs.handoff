<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">246c62f63427d09f4d113bd0b52ec176fb3bd025</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\abstract-classes-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">12d3fcc62c887660e2d002e8976d846acf6c3d0d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25d681089cd63cfe7e8b128e35dcf6ca0e7f2023</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Abstract Classes (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Abstract Classes (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Abstract classes act as expressions of general concepts from which more specific classes can be derived.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You cannot create an object of an abstract class type; however, you can use pointers and references to abstract class types.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A class that contains at least one pure virtual function is considered an abstract class.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Classes derived from the abstract class must implement the pure virtual function or they, too, are abstract classes.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A virtual function is declared as "pure" by using the <bpt id="p1">*</bpt>pure-specifier<ept id="p1">*</ept> syntax (described in <bpt id="p2">[</bpt>Class Protocol Implementation<ept id="p2">](http://msdn.microsoft.com/en-us/a319f1b3-05e8-400e-950a-1ca6eb105ab5)</ept>).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Consider the example presented in <bpt id="p1">[</bpt>Virtual Functions<ept id="p1">](../cpp/virtual-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The intent of class <ph id="ph1">`Account`</ph> is to provide general functionality, but objects of type <ph id="ph2">`Account`</ph> are too general to be useful.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`Account`</ph> is a good candidate for an abstract class:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The only difference between this declaration and the previous one is that <ph id="ph1">`PrintBalance`</ph> is declared with the pure specifier (<ph id="ph2">`= 0`</ph>).</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Restrictions on abstract classes</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Abstract classes cannot be used for:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Variables or member data</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Argument types</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Function return types</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Types of explicit conversions</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Another restriction is that if the constructor for an abstract class calls a pure virtual function, either directly or indirectly, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, constructors and destructors for abstract classes can call other member functions.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Pure virtual functions can be defined for abstract classes, but they can be called directly only by using the syntax:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>abstract-class-name<ept id="p1">*</ept> <ph id="ph1">`::`</ph> <bpt id="p2">*</bpt>function-name<ept id="p2">*</ept><bpt id="p3">**</bpt>( )<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This helps when designing class hierarchies whose base class(es) include pure virtual destructors, because base class destructors are always called in the process of destroying an object.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the object pointed to by <ph id="ph1">`pDerived`</ph> is deleted, the destructor for class <ph id="ph2">`derived`</ph> is called and then the destructor for class <ph id="ph3">`base`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The empty implementation for the pure virtual function ensures that at least some implementation exists for the function.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In the preceding example, the pure virtual function <ph id="ph1">`base::~base`</ph> is called implicitly from <ph id="ph2">`derived::~derived`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It is also possible to call pure virtual functions explicitly using a fully qualified member-function name.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>