<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">235b3bcf9039bae38261d123535e411939d19685</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\creating-asynchronous-operations-in-cpp-for-windows-store-apps.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1bccc56e618446c061d96aa76344696d33f3d723</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">efa37c1ada66cde457836928134f432cb705dfc1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating Asynchronous Operations in C++ for Windows Store Apps | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Creating Asynchronous Operations in C++ for Windows Store Apps</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This document describes some of the key points to keep in mind when you use the task class to produce Windows ThreadPool-based asynchronous operations in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The use of asynchronous programming is a key component in the <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app model because it enables apps to remain responsive to user input.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can start a long-running task without blocking the UI thread, and you can receive the results of the task later.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can also cancel tasks and receive progress notifications as tasks run in the background.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The document <bpt id="p1">[</bpt>Asynchronous programming in C++<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh780559.aspx)</ept> provides an overview of the asynchronous pattern that's available in Visual C++ to create <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>That document teaches how to both consume and create chains of asynchronous <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> operations.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This section describes how to use the types in ppltasks.h to produce asynchronous operations that can be consumed by another <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> component and how to control how asynchronous work is executed.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Also consider reading <bpt id="p1">[</bpt>Async programming patterns and tips in Hilo (Windows Store apps using C++ and XAML)<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/jj160321.aspx)</ept> to learn how we used the task class to implement asynchronous operations in Hilo, a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app using C++ and XAML.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>Parallel Patterns Library<ept id="p1">](../../parallel/concrt/parallel-patterns-library-ppl.md)</ept> (PPL) and <bpt id="p2">[</bpt>Asynchronous Agents Library<ept id="p2">](../../parallel/concrt/asynchronous-agents-library.md)</ept> in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>However, you cannot use the Task Scheduler or the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This document describes additional features that the PPL provides that are available only to a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, and not to a desktop app.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Key points</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency::create_async<ept id="p1">](reference/concurrency-namespace-functions.md#create_async)</ept> to create asynchronous operations that can be used by other components (which might be written in languages other than C++).</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency::progress_reporter<ept id="p1">](../../parallel/concrt/reference/progress-reporter-class.md)</ept> to report progress notifications to components that call your asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use cancellation tokens to enable internal asynchronous operations to cancel.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The behavior of the <ph id="ph1">`create_async`</ph> function depends on the return type of the work function that is passed to it.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A work function that returns a task (either <ph id="ph1">`task&lt;T&gt;`</ph> or <ph id="ph2">`task&lt;void&gt;`</ph>) runs synchronously in the context that called <ph id="ph3">`create_async`</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A work function that returns <ph id="ph1">`T`</ph> or <ph id="ph2">`void`</ph> runs in an arbitrary context.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>concurrency::task::then<ept id="p1">](reference/task-class.md#then)</ept> method to create a chain of tasks that run one after another.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, the default context for a task’s continuations depends on how that task was constructed.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If the task was created by passing an asynchronous action to the task constructor, or by passing a lambda expression that returns an asynchronous action, then the default context for all continuations of that task is the current context.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If the task is not constructed from an asynchronous action, then an arbitrary context is used by default for the task’s continuations.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can override the default context with the <bpt id="p1">[</bpt>concurrency::task_continuation_context<ept id="p1">](../../parallel/concrt/reference/task-continuation-context-class.md)</ept> class.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In this document</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Creating Asynchronous Operations</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Example: Creating a C++ Windows Runtime Component</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Controlling the Execution Thread</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Example: Controlling Execution in a Windows Store App with C++ and XAML</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Creating Asynchronous Operations</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can use the task and continuation model in the Parallel Patterns Library (PPL) to define background tasks as well as additional tasks that run when the previous task completes.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This functionality is provided by the <bpt id="p1">[</bpt>concurrency::task<ept id="p1">](../../parallel/concrt/reference/task-class.md)</ept> class.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For more information about this model and the <ph id="ph1">`task`</ph> class, see <bpt id="p1">[</bpt>Task Parallelism<ept id="p1">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> is a programming interface that you can use to create <ph id="ph2">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps that run only in a special operating system environment.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Such apps use authorized functions, data types, and devices, and are distributed from the <ph id="ph1">[!INCLUDE[win8_appstore_long](../../build/reference/includes/win8_appstore_long_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> is represented by the <bpt id="p1">*</bpt>Application Binary Interface<ept id="p1">*</ept> (ABI).</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The ABI is an underlying binary contract that makes <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> APIs available to programming languages such as Visual C++.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By using the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph>, you can use the best features of various programming languages and combine them into one app.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, you might create your UI in JavaScript and perform the computationally-intensive app logic in a C++ component.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The ability to perform these computationally-intensive operations in the background is a key factor in keeping your UI responsive.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`task`</ph> class is specific to C++, you must use a <ph id="ph2">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> interface to communicate asynchronous operations to other components (which might be written in languages other than C++).</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> provides four interfaces that you can use to represent asynchronous operations:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Windows::Foundation::IAsyncAction</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Represents an asynchronous action.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Windows::Foundation::IAsyncActionWithProgress<ph id="ph1">\&lt;</ph>TProgress&gt;</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Represents an asynchronous action that reports progress.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Windows::Foundation::IAsyncOperation<ph id="ph1">\&lt;</ph>TResult&gt;</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Represents an asynchronous operation that returns a result.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows::Foundation::IAsyncOperationWithProgress<ph id="ph1">\&lt;</ph>TResult, TProgress&gt;</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Represents an asynchronous operation that returns a result and reports progress.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The notion of an <bpt id="p1">*</bpt>action<ept id="p1">*</ept> means that the asynchronous task doesn't produce a value (think of a function that returns <ph id="ph1">`void`</ph>).</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The notion of an <bpt id="p1">*</bpt>operation<ept id="p1">*</ept> means that the asynchronous task does produce a value.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The notion of <bpt id="p1">*</bpt>progress<ept id="p1">*</ept> means that the task can report progress messages to the caller.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>JavaScript, the .NET Framework, and Visual C++ each provides its own way to create instances of these interfaces for use across the ABI boundary.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For Visual C++, the PPL provides the <bpt id="p1">[</bpt>concurrency::create_async<ept id="p1">](reference/concurrency-namespace-functions.md#create_async)</ept> function.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This function creates a <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> asynchronous action or operation that represents the completion of a task.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`create_async`</ph> function takes a work function (typically a lambda expression), internally creates a <ph id="ph2">`task`</ph> object, and wraps that task in one of the four asynchronous <ph id="ph3">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> interfaces.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`create_async`</ph> only when you have to create functionality that can be accessed from another language or another <ph id="ph2">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> component.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`task`</ph> class directly when you know that the operation is both produced and consumed by C++ code in the same component.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The return type of <ph id="ph1">`create_async`</ph> is determined by the type of its arguments.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, if your work function doesn't return a value and doesn't report progress, <ph id="ph1">`create_async`</ph> returns <ph id="ph2">`IAsyncAction`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If your work function doesn't return a value and also reports progress, <ph id="ph1">`create_async`</ph> returns <ph id="ph2">`IAsyncActionWithProgress`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>To report progress, provide a <bpt id="p1">[</bpt>concurrency::progress_reporter<ept id="p1">](../../parallel/concrt/reference/progress-reporter-class.md)</ept> object as the parameter to your work function.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The ability to report progress enables you to report what amount of work was performed and what amount still remains (for example, as a percentage).</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It also enables you to report results as they become available.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IAsyncAction`</ph>, <ph id="ph2">`IAsyncActionWithProgress&lt;TProgress&gt;`</ph>, <ph id="ph3">`IAsyncOperation&lt;TResult&gt;`</ph>, and <ph id="ph4">`IAsyncActionOperationWithProgress&lt;TProgress, TProgress&gt;`</ph> interfaces each provide a <ph id="ph5">`Cancel`</ph> method that enables you to cancel the asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`task`</ph> class works with cancellation tokens.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When you use a cancellation token to cancel work, the runtime does not start new work that subscribes to that token.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Work that is already active can monitor its cancellation token and stop when it can.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This mechanism is described in greater detail in the document <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can connect task cancellation with the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]`Cancel`</ph> methods in two ways.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>First, you can define the work function that you pass to <ph id="ph1">`create_async`</ph> to take a <bpt id="p1">[</bpt>concurrency::cancellation_token<ept id="p1">](../../parallel/concrt/reference/cancellation-token-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`Cancel`</ph> method is called, this cancellation token is cancelled and the normal cancellation rules apply to the underlying <ph id="ph2">`task`</ph> object that supports the <ph id="ph3">`create_async`</ph> call.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you do not provide a <ph id="ph1">`cancellation_token`</ph> object, the underlying <ph id="ph2">`task`</ph> object defines one implicitly.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Define a <ph id="ph1">`cancellation_token`</ph> object when you need to cooperatively respond to cancellation in your work function.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The section <bpt id="p1">[</bpt>Example: Controlling Execution in a Windows Store App with C++ and XAML<ept id="p1">](#example-app)</ept> shows an example of how to perform cancellation in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app with C# and XAML that uses a custom <ph id="ph2">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> C++ component.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In a chain of task continuations, always clean up state and then call <bpt id="p1">[</bpt>concurrency::cancel_current_task<ept id="p1">](reference/concurrency-namespace-functions.md#cancel_current_task)</ept> when the cancellation token is cancelled.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If you return early instead of calling <ph id="ph1">`cancel_current_task`</ph>, the operation transitions to the completed state instead of the canceled state.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following table summarizes the combinations that you can use to define asynchronous operations in your app.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>To create this <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> interface</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Return this type from</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Pass these parameter types to your work function to use an implicit cancellation token</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Pass these parameter types to your work function to use an explicit cancellation token</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>(none)</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`cancellation_token`</ph>)</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`progress_reporter`</ph>)</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`progress_reporter`</ph>, <ph id="ph2">`cancellation_token`</ph>)</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>(none)</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`cancellation_token`</ph>)</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`progress_reporter`</ph>)</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`progress_reporter`</ph>, <ph id="ph2">`cancellation_token`</ph>)</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can return a value or a <ph id="ph1">`task`</ph> object from the work function that you pass to the <ph id="ph2">`create_async`</ph> function.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>These variations produce different behaviors.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When you return a value, the work function is wrapped in a <ph id="ph1">`task`</ph> so that it can be run on a background thread.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In addition, the underlying <ph id="ph1">`task`</ph> uses an implicit cancellation token.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Conversely, if you return a <ph id="ph1">`task`</ph> object, the work function runs synchronously.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Therefore, if you return a <ph id="ph1">`task`</ph> object, ensure that any lengthy operations in your work function also run as tasks to enable your app to remain responsive.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In addition, the underlying <ph id="ph1">`task`</ph> does not use an implicit cancellation token.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Therefore, you need to define your work function to take a <ph id="ph1">`cancellation_token`</ph> object if you require support for cancellation when you return a <ph id="ph2">`task`</ph> object from <ph id="ph3">`create_async`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following example shows the various ways to create an <ph id="ph1">`IAsyncAction`</ph> object that can be consumed by another <ph id="ph2">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> component.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-primes#100</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Example: Creating a C++ Windows Runtime Component and Consuming it from C</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Consider an app that uses XAML and C# to define the UI and a C++ <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> component to perform compute-intensive operations.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In this example, the C++ component computes which numbers in a given range are prime.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>To illustrate the differences among the four <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> asynchronous task interfaces, start, in Visual Studio, by creating a <bpt id="p1">**</bpt>Blank Solution<ept id="p1">**</ept> and naming it <ph id="ph2">`Primes`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Then add to the solution a <bpt id="p1">**</bpt>Windows Runtime Component<ept id="p1">**</ept> project and naming it <ph id="ph1">`PrimesLibrary`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Add the following code to the generated C++ header file (this example renames Class1.h to Primes.h).</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">`public`</ph> method defines one of the four asynchronous interfaces.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The methods that return a value return a <bpt id="p1">[</bpt>Windows::Foundation::Collections::IVector<ph id="ph1">\&lt;</ph>int&gt;<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/br206631.aspx)</ept> object.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The methods that report progress produce <ph id="ph1">`double`</ph> values that define the percentage of overall work that has completed.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-primes#1</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>By convention, asynchronous method names in the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> typically end with "Async".</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Add the following code to the generated C++ source file (this example renames Class1.cpp to Primes.cpp).</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`is_prime`</ph> function determines whether its input is prime.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The remaining methods implement the <ph id="ph1">`Primes`</ph> class.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Each call to <ph id="ph1">`create_async`</ph> uses a signature that's compatible with the method from which it is called.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example, because <ph id="ph1">`Primes::ComputePrimesAsync`</ph> returns <ph id="ph2">`IAsyncAction`</ph>, the work function that's provided to <ph id="ph3">`create_async`</ph> doesn't return a value and doesn't take a <ph id="ph4">`progress_reporter`</ph> object as its parameter.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-primes#2</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Each method first performs validation to ensure that that the input parameters are non-negative.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If an input value is negative, the method throws <bpt id="p1">[</bpt>Platform::InvalidArgumentException<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh755794\(v=vs.110\).aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Error handling is explained later in this section.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>To consume these methods from a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, use the Visual C# <bpt id="p1">**</bpt>Blank App (XAML)<ept id="p1">**</ept> template to add a second project to the Visual Studio solution.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This example names the project <ph id="ph1">`Primes`</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Then, from the <ph id="ph1">`Primes`</ph> project, add a reference to the <ph id="ph2">`PrimesLibrary`</ph> project.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Add the following code to MainPage.xaml.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This code defines the UI so that you can call the C++ component and display results.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-primes#3</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Add the following code to the <ph id="ph1">`MainPage`</ph> class in MainPage.xaml.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This code defines a <ph id="ph1">`Primes`</ph> object and the button event handlers.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-primes#4</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>These methods use the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to update the UI after the asynchronous operations complete.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For information about the asynchronous patterns that are available to C# and Visual Basic, see <bpt id="p1">[</bpt>Asynchronous patterns in Windows Store apps with C#<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh464924.aspx)</ept> and <bpt id="p2">[</bpt>Asynchronous patterns in Windows Store apps with VB<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/hh464924.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`getPrimesCancellation`</ph> and <ph id="ph2">`cancelGetPrimes`</ph> methods work together to enable the user to cancel the operation.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>When the user chooses the <bpt id="p1">**</bpt>Cancel<ept id="p1">**</ept> button, the <ph id="ph1">`cancelGetPrimes`</ph> method calls <bpt id="p2">[</bpt>IAsyncOperationWithProgress<ph id="ph2">\&lt;</ph>TResult, TProgress&gt;::Cancel<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncinfo.cancel.aspx)</ept> to cancel the operation.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The Concurrency Runtime, which manages the underlying asynchronous operation, throws an internal exception type that's caught by the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> to communicate that cancellation has completed.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For more information about the cancellation model, see <bpt id="p1">[</bpt>Cancellation<ept id="p1">](../../parallel/concrt/cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>To enable the PPL to correctly report to the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> that it has canceled the operation, do not catch this internal exception type.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This means that you should also not catch all exceptions (<ph id="ph1">`catch (...)`</ph>).</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If you must catch all exceptions, rethrow the exception to ensure that the <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> can complete the cancellation operation.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The following illustration shows the <ph id="ph1">`Primes`</ph> app after each option has been chosen.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Windows Store Primes app</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For examples that use <ph id="ph1">`create_async`</ph> to create asynchronous tasks that can be consumed by other languages, see <bpt id="p1">[</bpt>Using C++ in the Bing Maps Trip Optimizer sample<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh699891\(v=vs.110\).aspx)</ept> and <bpt id="p2">[</bpt>Windows 8 Asynchronous Operations in C++ with PPL<ept id="p2">](http://code.msdn.microsoft.com/windowsapps/windows-8-asynchronous-08009a0d)</ept>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Controlling the Execution Thread</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]</ph> uses the COM threading model.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In this model, objects are hosted in different apartments, depending on how they handle their synchronization.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Thread-safe objects are hosted in the multi-threaded apartment (MTA).</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Objects that must be accessed by a single thread are hosted in a single-threaded apartment (STA).</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In an app that has a UI, the ASTA (Application STA) thread is responsible for pumping window messages and is the only thread in the process that can update the STA-hosted UI controls.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This has two consequences.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>First, to enable the app to remain responsive, all CPU-intensive and I/O operations should not be run on the ASTA thread.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Second, results that come from background threads must be marshaled back to the ASTA to update the UI.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>In a C++ <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app, <ph id="ph2">`MainPage`</ph> and other XAML pages all run on the ATSA.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Therefore, task continuations that are declared on the ASTA are run there by default so you can update controls directly in the continuation body.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>However, if you nest a task in another task, any continuations on that nested task run in the MTA.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Therefore, you need to consider whether to explicitly specify on what context these continuations run.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>A task that's created from an asynchronous operation, such as <ph id="ph1">`IAsyncOperation&lt;TResult&gt;`</ph>, uses special semantics that can help you ignore the threading details.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Although an operation might run on a background thread (or it may not be backed by a thread at all), its continuations are by default guaranteed to run on the apartment that started the continuation operations (in other words, from the apartment that called <ph id="ph1">`task::then`</ph>).</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>concurrency::task_continuation_context<ept id="p1">](../../parallel/concrt/reference/task-continuation-context-class.md)</ept> class to control the execution context of a continuation.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Use these static helper methods to create <ph id="ph1">`task_continuation_context`</ph> objects:</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency::task_continuation_context::use_arbitrary<ept id="p1">](reference/task-continuation-context-class.md#use_arbitrary)</ept> to specify that the continuation runs on a background thread.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency::task_continuation_context::use_current<ept id="p1">](reference/task-continuation-context-class.md#use_current)</ept> to specify that the continuation runs on the thread that called <ph id="ph1">`task::then`</ph>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>You can pass a <ph id="ph1">`task_continuation_context`</ph> object to the <bpt id="p1">[</bpt>task::then<ept id="p1">](reference/task-class.md#then)</ept> method to explicitly control the execution context of the continuation or you can pass the task to another apartment and then call the <ph id="ph2">`task::then`</ph> method to implicitly control the execution context.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Because the main UI thread of <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps run under STA, continuations that you create on that STA by default run on the STA.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Accordingly, continuations that you create on the MTA run on the MTA.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The following section shows an app that reads a file from disk, finds the most common words in that file, and then shows the results in the UI.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The final operation, updating the UI, occurs on the UI thread.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This behavior is specific to <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For desktop apps, you do not control where continuations run.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Instead, the scheduler chooses a worker thread on which to run each continuation.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Do not call <bpt id="p1">[</bpt>concurrency::task::wait<ept id="p1">](reference/task-class.md#wait)</ept> in the body of a continuation that runs on the STA.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Otherwise, the runtime throws <bpt id="p1">[</bpt>concurrency::invalid_operation<ept id="p1">](../../parallel/concrt/reference/invalid-operation-class.md)</ept> because this method blocks the current thread and can cause the app to become unresponsive.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>However, you can call the <bpt id="p1">[</bpt>concurrency::task::get<ept id="p1">](reference/task-class.md#get)</ept> method to receive the result of the antecedent task in a task-based continuation.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Example: Controlling Execution in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> App with C++ and XAML</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Consider a C++ XAML app that reads a file from disk, finds the most common words in that file, and then shows the results in the UI.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>To create this app, start, in Visual Studio, by creating a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph><bpt id="p1">**</bpt>Blank App (XAML)<ept id="p1">**</ept> project and naming it <ph id="ph2">`CommonWords`</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>In your app manifest, specify the <bpt id="p1">**</bpt>Documents Library<ept id="p1">**</ept> capability to enable the app to access the Documents folder.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Also add the Text (.txt) file type to the declarations section of the app manifest.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For more information about app capabilities and declarations, see <bpt id="p1">[</bpt>App packages and deployment<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh464929.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Update the <ph id="ph1">`Grid`</ph> element in MainPage.xaml to include a <ph id="ph2">`ProgressRing`</ph> element and a <ph id="ph3">`TextBlock`</ph> element.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ProgressRing`</ph> indicates that the operation is in progress and the <ph id="ph2">`TextBlock`</ph> shows the results of the computation.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#1</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Add the following <ph id="ph1">`#include`</ph> statements to pch.h.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#2</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Add the following method declarations to the <ph id="ph1">`MainPage`</ph> class (MainPage.h).</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#3</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Add the following <ph id="ph1">`using`</ph> statements to MainPage.cpp.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#4</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In MainPage.cpp, implement the <ph id="ph1">`MainPage::MakeWordList`</ph>, <ph id="ph2">`MainPage::FindCommonWords`</ph>, and <ph id="ph3">`MainPage::ShowResults`</ph> methods.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MainPage::MakeWordList`</ph> and <ph id="ph2">`MainPage::FindCommonWords`</ph> perform computationally-intensive operations.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MainPage::ShowResults`</ph> method displays the result of the computation in the UI.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#5</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Modify the <ph id="ph1">`MainPage`</ph> constructor to create a chain of continuation tasks that displays in the UI the common words in the book <bpt id="p1">*</bpt>The Iliad<ept id="p1">*</ept> by Homer.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The first two continuation tasks, which split the text into individual words and find common words, can be time consuming and are therefore explicitly set to run in the background.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The final continuation task, which updates the UI, specifies no continuation context, and therefore follows the apartment threading rules.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>concrt-windowsstore-commonwords#6</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to specify execution contexts and how to compose a chain of continuations.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Recall that by default a task that's created from an asynchronous operation runs its continuations on the apartment that called <ph id="ph1">`task::then`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Therefore, this example uses <ph id="ph1">`task_continuation_context::use_arbitrary`</ph> to specify that operations that do not involve the UI be performed on a background thread.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The following illustration shows the results of the <ph id="ph1">`CommonWords`</ph> app.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Windows Store CommonWords app</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In this example, it’s possible to support cancellation because the <ph id="ph1">`task`</ph> objects that support <ph id="ph2">`create_async`</ph> use an implicit cancellation token.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Define your work function to take a <ph id="ph1">`cancellation_token`</ph> object if your tasks need to respond to cancellation in a cooperative manner.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For more info about cancellation in the PPL, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept></source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Concurrency Runtime</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>