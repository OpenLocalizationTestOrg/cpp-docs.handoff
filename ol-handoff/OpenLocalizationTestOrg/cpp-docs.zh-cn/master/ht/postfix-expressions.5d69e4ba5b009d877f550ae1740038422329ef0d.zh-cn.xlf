<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9760289f58491b4e84366df82919f12739017317</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\postfix-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">07d117b4115d6e10be9074d4250e18244e23259d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9cfad66c090d2941e64813f2ebbce20fb04e5168</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Postfix Expressions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Postfix Expressions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Postfix expressions consist of primary expressions or expressions in which postfix operators follow a primary expression.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The postfix operators are listed in the following table.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Postfix Operators</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Operator Name</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Operator Notation</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Subscript operator</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[ ]</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>( )</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Explicit type conversion operator</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-name<ept id="p1">*</ept> <bpt id="p2">**</bpt>( )<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Member access operator</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>or <bpt id="p1">**</bpt>–&gt;<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Postfix increment operator</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Postfix decrement operator</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>––</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following syntax describes possible postfix expressions:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>postfix-expression<ept id="p1">*</ept> above may be a primary expression or another postfix expression.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">**</bpt>primary expressions<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Postfix expressions group left to right, thus allowing the expressions to be chained together as follows:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In the above expression, func is a primary expression, func(1) is a function postfix expression, func(1)-&gt;GetData is a postfix expression specifying a member of the class, func(1)-&gt;GetData() is another function postfix expression, and the entire expression is a postfix expression incrementing the return value of GetData.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The meaning of the expression as a whole is "call func passing 1 as an argument and get a pointer to a class as a return value.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Then call GetValue() on that class, then increment the value returned.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The expressions listed above are assignment expressions, meaning that the result of these expressions must be an r-value.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The postfix expression form</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>indicates the invocation of the constructor.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If the simple-type-name is a fundamental type, the expression list must be a single expression, and this expression indicates a cast of the expression's value to the fundamental type.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This type of cast expression mimics a constructor.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because this form allows fundamental types and classes to be constructed using the same syntax, this form is especially useful when defining template classes.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>cast-keyword<ept id="p1">*</ept> is one of <ph id="ph1">`dynamic_cast`</ph>, <ph id="ph2">`static_cast`</ph> or <ph id="ph3">`reinterpret_cast`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>More information may be found in <bpt id="p1">**</bpt>dynamic_cast<ept id="p1">**</ept>, <bpt id="p2">**</bpt>static_cast<ept id="p2">**</ept> and <bpt id="p3">**</bpt>reinterpet_cast<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`typeid`</ph> operator is considered a postfix expression.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">**</bpt>typeid operator<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Formal and actual arguments</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Calling programs pass information to called functions in "actual arguments."</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The called functions access the information using corresponding "formal arguments."</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When a function is called, the following tasks are performed:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>All actual arguments (those supplied by the caller) are evaluated.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>There is no implied order in which these arguments are evaluated, but all arguments are evaluated and all side effects completed prior to entry to the function.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Each formal argument is initialized with its corresponding actual argument in the expression list.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>(A formal argument is an argument that is declared in the function header and used in the body of a function.) Conversions are done as if by initialization — both standard and user-defined conversions are performed in converting an actual argument to the correct type.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The initialization performed is illustrated conceptually by the following code:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The conceptual initializations prior to the call are:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Note that the initialization is performed as if using the equal-sign syntax instead of the parentheses syntax.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A copy of <ph id="ph1">`i`</ph> is made prior to passing the value to the function.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Initializers<ept id="p1">](../cpp/initializers.md)</ept> and <bpt id="p2">[</bpt>Conversions<ept id="p2">](../cpp/user-defined-type-conversions-cpp.md)</ept>, <bpt id="p3">[</bpt>Initialization Using Special Member Functions<ept id="p3">](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca)</ept>, and <bpt id="p4">[</bpt>Explicit Initialization<ept id="p4">](http://msdn.microsoft.com/en-us/c89724f8-ddd3-4d77-b86d-77fcd8bd8595)</ept>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Therefore, if the function prototype (declaration) calls for an argument of type <bpt id="p1">**</bpt>long<ept id="p1">**</ept>, and if the calling program supplies an actual argument of type <ph id="ph1">`int`</ph>, the actual argument is promoted using a standard type conversion to type <bpt id="p2">**</bpt>long<ept id="p2">**</ept> (see <bpt id="p3">[</bpt>Standard Conversions<ept id="p3">](../cpp/standard-conversions.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>It is an error to supply an actual argument for which there is no standard or user-defined conversion to the type of the formal argument.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For actual arguments of class type, the formal argument is initialized by calling the class's constructor.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Constructors<ept id="p1">](../cpp/constructors-cpp.md)</ept> for more about these special class member functions.)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The function call is executed.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following program fragment demonstrates a function call:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`func`</ph> is called from main, the formal parameter <ph id="ph2">`param1`</ph> is initialized with the value of <ph id="ph3">`i`</ph> (<ph id="ph4">`i`</ph> is converted to type <bpt id="p1">**</bpt>long<ept id="p1">**</ept> to correspond to the correct type using a standard conversion), and the formal parameter <ph id="ph5">`param2`</ph> is initialized with the value of <ph id="ph6">`j`</ph> (<ph id="ph7">`j`</ph> is converted to type <bpt id="p2">**</bpt>double<ept id="p2">**</ept> using a standard conversion).</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Treatment of argument types</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Formal arguments declared as const types cannot be changed within the body of a function.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Functions can change any argument that is not of type <bpt id="p1">**</bpt>const<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, the change is local to the function and does not affect the actual argument's value unless the actual argument was a reference to an object not of type <bpt id="p1">**</bpt>const<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The following functions illustrate some of these concepts:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Ellipses and default arguments</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Functions can be declared to accept fewer arguments than specified in the function definition, using one of two methods: ellipsis (<ph id="ph1">`...`</ph>) or default arguments.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Ellipses denote that arguments may be required but that the number and types are not specified in the declaration.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This is normally poor C++ programming practice because it defeats one of the benefits of C++: type safety.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Different conversions are applied to functions declared with ellipses than to those functions for which the formal and actual argument types are known:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If the actual argument is of type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>, it is promoted to type <bpt id="p2">**</bpt>double<ept id="p2">**</ept> prior to the function call.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Any signed or unsigned <ph id="ph1">`char`</ph>, <bpt id="p1">**</bpt>short<ept id="p1">**</ept>, enumerated type, or bit field is converted to either a signed or an unsigned <ph id="ph2">`int`</ph> using integral promotion.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Any argument of class type is passed by value as a data structure; the copy is created by binary copying instead of by invoking the class's copy constructor (if one exists).</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Ellipses, if used, must be declared last in the argument list.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information about passing a variable number of arguments, see the discussion of <bpt id="p1">[</bpt>va_arg, va_start, and va_list<ept id="p1">](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md)</ept> in the <bpt id="p2">*</bpt>Run-Time Library Reference<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For information on default arguments in CLR programming, see <bpt id="p1">[</bpt>Variable Argument Lists (...) (C++/CLI)<ept id="p1">](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Default arguments enable you to specify the value an argument should assume if none is supplied in the function call.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following code fragment shows how default arguments work.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information about restrictions on specifying default arguments, see <bpt id="p1">[</bpt>Default Arguments<ept id="p1">](../cpp/default-arguments.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The preceding program declares a function, <ph id="ph1">`print`</ph>, that takes two arguments.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, the second argument, <ph id="ph1">`terminator`</ph>, has a default value, <ph id="ph2">`"\n"`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>main<ept id="p1">**</ept>, the first two calls to <ph id="ph1">`print`</ph> allow the default second argument to supply a new line to terminate the printed string.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The third call specifies an explicit value for the second argument.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The output from the program is</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Types of Expressions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>