<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b8f01b039727b911576a38e07b72c40155903dbc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\string-and-character-literals-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0e5d891a977c228291f458c2536ed8ac13cb4433</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">11d20eea5b4cb8cdea007ddbaa9cf05b0e091078</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>String and Character Literals  (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>String and Character Literals  (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ supports various string and character types, and provides ways to express literal values of each of these types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In your source code, you express the content of your character and string literals using a character set.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Universal character names and escape characters allow you to express any string using only the basic source character set.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A raw string literal enables you to avoid using escape characters, and can be used to express all types of string literals.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can also create std::string literals without having to perform extra construction or conversion steps.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>String literals can have no prefix, or <ph id="ph1">`u8`</ph>, <ph id="ph2">`L`</ph>, <ph id="ph3">`u`</ph>, and  <ph id="ph4">`U`</ph> prefixes to denote narrow character (single-byte or multi-byte), UTF-8, wide character (UCS-2 or UTF-16), UTF-16 and UTF-32 encodings, respectively.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A raw string literal can have <ph id="ph1">`R`</ph>, <ph id="ph2">`u8R`</ph>, <ph id="ph3">`LR`</ph>, <ph id="ph4">`uR`</ph> and <ph id="ph5">`UR`</ph> prefixes for the raw version equivalents of these encodings.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To create temporary or static std::string values, you can use string literals or raw string literals with an <ph id="ph1">`s`</ph> suffix.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more information, see the String literals section below.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information on the basic source character set, universal character names, and using characters from extended codepages in your source code, see <bpt id="p1">[</bpt>Character Sets<ept id="p1">](../cpp/character-sets2.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Character literals</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>character literal<ept id="p1">*</ept> is composed of a constant character.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is represented by the character surrounded by single quotation marks.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>There are five kinds of character literals:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Ordinary character literals of type <ph id="ph1">`char`</ph>, for example</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>UTF-8 character literals of type <ph id="ph1">`char`</ph>, for example</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Wide-character literals of type <ph id="ph1">`wchar_t`</ph>, for example</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>UTF-16 character literals of type <ph id="ph1">`char16_t`</ph>, for example</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>UTF-32 character literals of type <ph id="ph1">`char32_t`</ph>, for example</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The character used for a character literal may be any character, except for the reserved characters backslash ('<ph id="ph1">\\</ph>'), single quotation mark ('), or new line.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Reserved characters can be specified by using an escape sequence.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Characters may be specified by using universal character names, as long as the type is large enough to hold the character.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Encoding</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Character literals are encoded differently based their prefix.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A character literal without a prefix is an ordinary character literal.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The value of an ordinary character literal containing a single character, escape sequence, or universal character name that can be represented in the execution character set has a value equal to the numerical value of its encoding in the execution character set.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>An ordinary character literal that contains more than one character, escape sequence, or universal character name is a <bpt id="p1">*</bpt>multicharacter literal<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A multicharacter literal or an ordinary character literal  that can't be represented in the execution character set is conditionally-supported, has type int, and its value is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A character literal that begins with the L prefix is a wide-character literal.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The value of a wide-character literal containing a single character, escape sequence, or universal character name has a value equal to the numerical value of its encoding in the execution wide-character set unless the character literal has no representation in the execution wide-character set, in which case the value is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The value of a wide-character literal containing multiple characters, escape sequences, or universal character names is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A character literal that begins with the u8 prefix is a UTF-8 character literal.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The value of a UTF-8 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-8 code unit (corresponding to the C0 Controls and Basic Latin Unicode block).</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If the value can't be represented by a single UTF-8 code unit, the program is ill-formed.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A character literal that begins with the u prefix is a UTF-16 character literal.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The value of a UTF-16 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value if it can be represented by a single UTF-16 code unit (corresponding to the basic multi-lingual plane).</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If the value can't be represented by a single UTF-16 code unit, the program is ill-formed.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A UTF-16 character literal containing more than one character, escape sequence, or universal character name is ill-formed.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A character literal that begins with the U prefix is a UTF-32 character literal.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The value of a UTF-32 character literal containing a single character, escape sequence, or universal character name has a value equal to its ISO 10646 code point value.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A UTF-8 character literal containing more than one character, escape sequence, or universal character name is ill-formed.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Escape Sequences</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>There are three kinds of escape sequences: simple, octal, and hexadecimal.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Escape sequences may be any of the following:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Escape sequence</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Escape sequence</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>newline</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>\n</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>backslash</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>horizontal tab</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>\t</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>question mark</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>or <ph id="ph1">\\</ph>?</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>vertical tab</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>\v</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>single quote</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>'</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>backspace</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>\b</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>double quote</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>"</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>carriage return</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>\r</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>the null character</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>\0</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>form feed</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>\f</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>octal</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>\ooo</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>alert (bell)</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>\a</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>hexadecimal</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>\xhhh</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following code shows some examples of escaped characters using ordinary character literals.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The same escape sequence syntax is valid for the other character literal types.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>To create a value from an ordinary character literal (those without a prefix), the compiler converts the character  or character sequence between single quotes into 8-bit values within a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Multiple characters in the literal fill corresponding bytes as needed from high-order to low-order.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To create a <ph id="ph1">`char`</ph> value, the compiler takes the low-order byte.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To create a <ph id="ph1">`wchar_t`</ph> or <ph id="ph2">`char16_t`</ph> value, the compiler takes the low-order word.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The compiler warns that the result is truncated if any bits are set above the assigned byte or word.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>An octal escape sequence is a backslash followed by a sequence of up to 3 octal digits.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The behavior of an octal escape sequence that appears to contain more than three digits is treated as a 3-digit octal sequence followed by the subsequent digits as characters; this can give surprising results.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Escape sequences that appear to contain non-octal characters are evaluated as an octal sequence up to the last octal character, followed by the remaining characters.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A hexadecimal escape sequence is a backslash followed by the character <ph id="ph1">`x`</ph>, followed by a sequence of hexadecimal digits.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>An escape sequence that contains no hexadecimal digits causes compiler error C2153: "hex literals must have at least one hex digit".</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Leading zeroes are ignored.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>An escape sequence that appears to have hexadecimal and non-hexadecimal characters is evaluated as a hexadecimal escape sequence up to  the last hexadecimal character, followed by the non-hexadecimal characters.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In an ordinary or u8-prefixed character literal, the highest hexadecimal value is 0xFF.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In an L-prefixed or u-prefixed wide character literal, the highest hexadecimal value is 0xFFFF.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In a U-prefixed wide character literal, the highest hexadecimal value is 0xFFFFFFFF.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If a wide character literal prefixed with <ph id="ph1">`L`</ph> contains more than one character, the value is taken from the first character.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Subsequent characters are ignored, unlike the behavior of the equivalent ordinary character literal.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The backslash character (<ph id="ph1">\\</ph>) is a line-continuation character when it is placed at the end of a line.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If you want a backslash character to appear as a character literal, you must type two backslashes in a row (<ph id="ph1">`\\`</ph>).</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For more information about the line continuation character, see <bpt id="p1">[</bpt>Phases of Translation<ept id="p1">](../preprocessor/phases-of-translation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Universal character names</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In character literals and native (non-raw) string literals, any character may be represented by a universal character name.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Universal character names are formed by a prefix \U followed by an eight-digit Unicode code point, or by a prefix \u followed by a four digit Unicode code point.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>All eight or four digits, respectively, must be present to make a well-formed universal character name.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Universal character names cannot encode values in the surrogate code point range D800-DFFF.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For Unicode surrogate pairs, specify the universal character name by using <ph id="ph1">`\UNNNNNNNN`</ph>, where NNNNNNNN is the eight-digit code point for the character.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The compiler generates a surrogate pair if required.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In C++03, the language only allowed a subset of characters to be represented by their universal character names, and allowed some universal character names that didn’t actually represent any valid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This was fixed in the C++11 standard.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In C++11, both character and string literals and identifiers can use universal character names.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information on universal character names, see <bpt id="p1">[</bpt>Character Sets<ept id="p1">](../cpp/character-sets2.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For more information about Unicode, see <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://msdn.microsoft.com/library/dd374081\(v=vs.85\).aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For more information about surrogate pairs, see <bpt id="p1">[</bpt>Surrogate Pairs and Supplementary Characters<ept id="p1">](http://msdn.microsoft.com/library/dd374069\(v=vs.85\).aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>String literals</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>A string literal represents a sequence of characters that together form a null-terminated string.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The characters must be enclosed between double quotation marks.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>There are the following kinds of string literals:</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Narrow String Literals</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A narrow string literal is a non-prefixed, double-quote delimited, null-terminated array of type <ph id="ph1">`const`</ph> <ph id="ph2">`char`</ph>[<ph id="ph3">`n`</ph>], where n is the length of the array in bytes.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>A narrow string literal may contain any graphic character except the double quotation mark (<ph id="ph1">`"`</ph>), backslash (<ph id="ph2">`\`</ph>), or newline character.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>A narrow string literal may also contain the escape sequences listed above, and universal character names that fit in a byte.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>UTF-8 encoded strings</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded string is a u8-prefixed, double-quote delimited, null-terminated array of type  <ph id="ph1">`const``char`</ph>[<ph id="ph2">`n`</ph>], where n is the length of the encoded array in bytes.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A u8-prefixed string literal may contain any graphic character except the double quotation mark (<ph id="ph1">`"`</ph>), backslash (<ph id="ph2">`\`</ph>), or newline character.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A u8-prefixed string literal may also contain the escape sequences listed above, and any universal character name.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Wide String Literals</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>A wide string literal is a null-terminated array of constant <ph id="ph1">`wchar_t`</ph> that is prefixed by '<ph id="ph2">`L`</ph>' and contains any graphic character except the double quotation mark ("), backslash (<ph id="ph3">\\</ph>), or newline character.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A wide string literal may contain the escape sequences listed above and any universal character name.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>char16_t and char32_t (C++11)</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>C++11 introduces the portable <ph id="ph1">`char16_t`</ph> (16-bit Unicode) and <ph id="ph2">`char32_t`</ph> (32-bit Unicode) character types:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Raw String Literals (C++11)</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A raw string literal is a null-terminated array—of any character type—that contains any graphic character, including the double quotation mark ("), backslash (<ph id="ph1">\\</ph>), or newline character.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Raw string literals are often used in regular expressions that use character classes, and in HTML strings and XML strings.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For examples, see the following article: <bpt id="p1">[</bpt>Bjarne Stroustrup's FAQ on C++11<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=401172)</ept>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>A delimiter is a user-defined sequence of up to 16 characters that immediately precedes the opening parenthesis of a raw string literal and immediately follows its closing parenthesis.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example, in <ph id="ph1">`R"abc(Hello"\()abc"`</ph> the delimiter sequence is <ph id="ph2">`abc`</ph> and the string content is <ph id="ph3">`Hello"\(`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>You can use a delimiter to disambiguate raw strings that contain both double quotation marks and parentheses.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This causes a compiler error:</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>But a delimiter resolves it:</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You can construct a raw string literal in which there is a newline (not the escaped character) in the source:</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>std::string Literals (C++14)</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>std::string literals are Standard Library implementations of user-defined literals (see below) that are represented as "xyx"s (with a <ph id="ph1">`s`</ph> suffix).</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>This kind of string literal produces a temporary object of type std::string, std::wstring, std::u32string or std::u16string depending on the prefix that is specified.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>When no prefix is used, as above, a std::string is produced.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>L"xyz"s produces a std::wstring.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>u"xyz"s produces a <bpt id="p1">[</bpt>std::u16string<ept id="p1">](http://msdn.microsoft.com/Library/5e1dcd3a-b1e4-4ee0-8389-629f7c2061c1)</ept>, and U"xyz"s produces a <bpt id="p2">[</bpt>std::u32string<ept id="p2">](http://msdn.microsoft.com/Library/fd3970a3-a8b2-42ff-aadd-1cc99045f88a)</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The s suffix may also be used on raw string literals:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>std::string literals are defined in the namespace <ph id="ph1">`std::literals::string_literals`</ph> in the <ph id="ph2">\&lt;</ph>string&gt; header file.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`std::literals::string_literals`</ph>, and <ph id="ph2">`std::literals`</ph> are both declared as <bpt id="p1">[</bpt>inline namespaces<ept id="p1">](../cpp/namespaces-cpp.md)</ept>, <ph id="ph3">`std::literals::string_literals`</ph> is automatically treated as if it belonged directly in namespace <ph id="ph4">`std`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Size of String Literals</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For ANSI char<ph id="ph1">\*</ph> strings and other single-byte encodings (not UTF-8), the size (in bytes) of a string literal is the number of characters plus 1 for the terminating null character.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For all other string types, the size is not strictly related to the number of characters.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>UTF-8 uses up to four char elements to encode some <bpt id="p1">*</bpt>code units<ept id="p1">*</ept>, and char16_t or wchar_t encoded as UTF-16 may use two elements (for a total of four bytes) to encode a single <bpt id="p2">*</bpt>code unit<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>This example shows the size of a wide string literal in bytes:</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Notice that <ph id="ph1">`strlen()`</ph> and <ph id="ph2">`wcslen()`</ph> do not include the size of the terminating null character, whose size is equal to the element size of the string type: one byte on a char* string, two bytes on wchar_t<ph id="ph3">\*</ph> or char16_t<ph id="ph4">\*</ph> strings, and four bytes on char32_t<ph id="ph5">\*</ph> strings.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The maximum length of a string literal is 65535 bytes.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This limit applies to both narrow string literals and wide string literals.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Modifying String Literals</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Because string literals (not including std:string literals) are constants, trying to modify them—for example, str[2] = 'A'—causes a compiler error.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In Visual C++ you can use a string literal to initialize a pointer to non-const <ph id="ph1">`char`</ph> or <ph id="ph2">`wchar_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This is allowed in C99 code, but is deprecated in C++98 and removed in C++11.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>An attempt to modify the string causes an access violation, as in this example:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>You can cause the compiler to emit an error when a string literal is converted to a non_const character pointer when you set the <bpt id="p1">[</bpt>/Zc:strictStrings (Disable string literal type conversion)<ept id="p1">](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md)</ept> compiler option.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>We recommend it for standards-compliant portable code.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>It is also a good practice to use the <ph id="ph1">`auto`</ph> keyword to declare string literal-initialized pointers, because it resolves to the correct (const) type.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For example, this code example catches an attempt to write to a string literal at compile time:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>In some cases, identical string literals may be pooled to save space in the executable file.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In string-literal pooling, the compiler causes all references to a particular string literal to point to the same location in memory, instead of having each reference point to a separate instance of the string literal.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To enable string pooling, use the <bpt id="p1">[</bpt>/GF<ept id="p1">](../build/reference/gf-eliminate-duplicate-strings.md)</ept> compiler option.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Concatenating adjacent string literals</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Adjacent wide or narrow string literals are concatenated.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This declaration:</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>is identical to this declaration:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>and to this declaration:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Using embedded hexadecimal escape codes to specify string literals can cause unexpected results.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following example seeks to create a string literal that contains the ASCII 5 character, followed by the characters f, i, v, and e:</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The actual result is a hexadecimal 5F, which is the ASCII code for an underscore, followed by the characters i, v, and e.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>To get the correct result, you can use one of these:</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>std::string literals, because they are std::string types, can be concatenated with the + operator that is defined for <bpt id="p1">[</bpt>basic_string<ept id="p1">](../standard-library/basic-string-class.md)</ept> types.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>They can also be concatenated in the same way as adjacent string literals.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In both cases, the string encoding and the suffix must match:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>String literals with universal character names</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Native (non-raw) string literals may use universal character names to represent any character, as long as the universal character name can be encoded as one or more characters in the string type.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For example, a universal character name representing an extended character cannot be encoded in a narrow string using the ANSI code page, but it can be encoded in narrow strings in some multi-byte code pages, or in UTF-8 strings, or in a wide string.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In C++11, Unicode support is extended by the char16_t* and char32_t<ph id="ph1">\*</ph> string types:</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Numeric, Boolean and Pointer Literals</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>