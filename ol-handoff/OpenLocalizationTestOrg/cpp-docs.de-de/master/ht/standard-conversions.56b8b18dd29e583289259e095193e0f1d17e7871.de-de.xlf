<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b66155b5d8410f758cc30acd4e3a4f3f4a0eafd2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\standard-conversions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">753f788e3c5bf0d576cd99cd70aa12ff845275e9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9121881cb055f631761949478353b288a3428ad0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Standard Conversions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Standard Conversions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The C++ language defines conversions between its fundamental types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It also defines conversions for pointer, reference, and pointer-to-member derived types.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>These conversions are called "standard conversions."</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>(For more information about types, standard types, and derived types, see <bpt id="p1">[</bpt>Types<ept id="p1">](http://msdn.microsoft.com/en-us/6882ee83-ea32-4373-8d57-c3efbbc15af0)</ept>.)</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This section discusses the following standard conversions:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Integral promotions</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Integral conversions</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Floating conversions</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Floating and integral conversions</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Arithmetic conversions</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Pointer conversions</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference conversions</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Pointer-to-member conversions</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>User-defined types can specify their own conversions.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Conversion of user-defined types is covered in <bpt id="p1">[</bpt>Constructors<ept id="p1">](../cpp/constructors-cpp.md)</ept> and <bpt id="p2">[</bpt>Conversions<ept id="p2">](../cpp/user-defined-type-conversions-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following code causes conversions (in this example, integral promotions):</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The result of a conversion is an l-value only if it produces a reference type.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, a user-defined conversion declared as <ph id="ph1">`operator int&amp;()`</ph> returns a reference and is an l-value.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>However, a conversion declared as <ph id="ph1">`operator int()`</ph>returns an object and is not an l-value.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Integral promotions</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Objects of an integral type can be converted to another wider integral type (that is, a type that can represent a larger set of values).</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This widening type of conversion is called "integral promotion."</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>With integral promotion, you can use the following in an expression wherever another integral type can be used:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Objects, literals, and constants of type <ph id="ph1">`char`</ph> and</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Enumeration types</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>bit fields</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Enumerators</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>C++ promotions are "value-preserving."</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>That is, the value after the promotion is guaranteed to be the same as the value before the promotion.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In value-preserving promotions, objects of shorter integral types (such as bit fields or objects of type <ph id="ph1">`char`</ph>) are promoted to type <ph id="ph2">`int`</ph> if <ph id="ph3">`int`</ph> can represent the full range of the original type.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`int`</ph> cannot represent the full range of values, then the object is promoted to type <ph id="ph2">`unsigned int`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Although this strategy is the same as that used by ANSI C, value-preserving conversions do not preserve the "signedness" of the object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Value-preserving promotions and promotions that preserve signedness normally produce the same results.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>However, they can produce different results if the promoted object is one of the following:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>An operand of <bpt id="p1">**</bpt><ph id="ph1">/</ph><ept id="p1">**</ept>, <ph id="ph2">`%`</ph>, <ph id="ph3">`/=`</ph>, <ph id="ph4">`%=`</ph>, <bpt id="p2">**</bpt><ph id="ph5">&lt;</ph><ept id="p2">**</ept>, <bpt id="p3">**</bpt><ph id="ph6">\&lt;=</ph><ept id="p3">**</ept>, <bpt id="p4">**</bpt><ph id="ph7">&gt;</ph><ept id="p4">**</ept>, or <bpt id="p5">**</bpt><ph id="ph8">&gt;=</ph><ept id="p5">**</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>These operators rely on sign for determining the result.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Therefore, value-preserving and sign-preserving promotions produce different results when applied to these operands.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The left operand of <bpt id="p1">**</bpt><ph id="ph1">&gt;&gt;</ph><ept id="p1">**</ept> or <bpt id="p2">**</bpt><ph id="ph2">&gt;&gt;=</ph><ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>These operators treat signed and unsigned quantities differently when performing a shift operation.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For signed quantities, shifting a quantity right causes the sign bit to be propagated into the vacated bit positions.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For unsigned quantities, the vacated bit positions are zero-filled.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>An argument to an overloaded function or operand of an overloaded operator that depends on the signedness of the type of that operand for argument matching.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Overloaded Operators<ept id="p1">](../cpp/operator-overloading.md)</ept> for more about defining overloaded operators.)</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Integral conversions</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Integral conversions are performed between integral types.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The integral types are <ph id="ph1">`char`</ph>, <ph id="ph2">`int`</ph>, and <bpt id="p1">**</bpt>long<ept id="p1">**</ept> (and the <bpt id="p2">**</bpt>short<ept id="p2">**</ept>, <bpt id="p3">**</bpt>signed<ept id="p3">**</ept>, and <ph id="ph3">`unsigned`</ph> versions of these types).</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Signed to unsigned</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Objects of signed integral types can be converted to corresponding unsigned types.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>When these conversions occur, the actual bit pattern does not change; however, the interpretation of the data changes.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Consider this code:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In the preceding example, a <ph id="ph1">`signed short`</ph>, <ph id="ph2">`i`</ph>, is defined and initialized to a negative number.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`(u = i)`</ph> causes <ph id="ph2">`i`</ph> to be converted to an <bpt id="p1">**</bpt>unsigned short<ept id="p1">**</ept> prior to the assignment to <ph id="ph3">`u`</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Unsigned to signed</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Objects of unsigned integral types can be converted to corresponding signed types.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>However, such a conversion can cause misinterpretation of data if the value of the unsigned object is outside the range representable by the signed type, as demonstrated in the following example:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In the preceding example, <ph id="ph1">`u`</ph> is an <ph id="ph2">`unsigned`</ph> <bpt id="p1">**</bpt>short<ept id="p1">**</ept> integral object that must be converted to a signed quantity to evaluate the expression <ph id="ph3">`(i = u)`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because its value cannot be properly represented in a <ph id="ph1">`signed short`</ph>, the data is misinterpreted as shown.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Floating point conversions</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>An object of a floating type can be safely converted to a more precise floating type — that is, the conversion causes no loss of significance.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, conversions from <bpt id="p1">**</bpt>float<ept id="p1">**</ept> to <bpt id="p2">**</bpt>double<ept id="p2">**</ept> or from <bpt id="p3">**</bpt>double<ept id="p3">**</ept> to <ph id="ph1">`long double`</ph> are safe, and the value is unchanged.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>An object of a floating type can also be converted to a less precise type, if it is in a range representable by that type.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Floating Limits<ept id="p1">](../cpp/floating-limits.md)</ept> for the ranges of floating types.) If the original value cannot be represented precisely, it can be converted to either the next higher or the next lower representable value.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If no such value exists, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The maximum value representable by type <bpt id="p1">**</bpt>float<ept id="p1">**</ept> is 3.402823466E38 — a much smaller number than 1E300.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Therefore, the number is converted to infinity, and the result is 1.#INF.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Conversions between integral and floating point types</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Certain expressions can cause objects of floating type to be converted to integral types, or vice versa.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When an object of integral type is converted to a floating type and the original value cannot be represented exactly, the result is either the next higher or the next lower representable value.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>When an object of floating type is converted to an integral type, the fractional part is truncated.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>No rounding takes place in the conversion process.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Truncation means that a number like 1.3 is converted to 1, and –1.3 is converted to –1.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Arithmetic conversions</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Many binary operators (discussed in <bpt id="p1">[</bpt>Expressions with Binary Operators<ept id="p1">](../cpp/expressions-with-binary-operators.md)</ept>) cause conversions of operands and yield results the same way.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The way these operators cause conversions is called "usual arithmetic conversions."</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Arithmetic conversions of operands of different native types are performed as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Typedef types behave according to their underlying native types.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Conditions for Type Conversion</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Conditions Met</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Conversion</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Either operand is of type <bpt id="p1">**</bpt>long double<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Other operand is converted to type <bpt id="p1">**</bpt>long double<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Preceding condition not met and either operand is of type <bpt id="p1">**</bpt>double<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Other operand is converted to type <bpt id="p1">**</bpt>double<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Preceding conditions not met and either operand is of type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Other operand is converted to type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Preceding conditions not met (none of the operands are of floating types).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Integral promotions are performed on the operands as follows:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>-   If either operand is of type <ph id="ph1">`unsigned`</ph> <bpt id="p1">**</bpt>long<ept id="p1">**</ept>, the other operand is converted to type <ph id="ph2">`unsigned long`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>-   If preceding condition not met, and if either operand is of type <bpt id="p1">**</bpt>long<ept id="p1">**</ept> and the other of type <ph id="ph1">`unsigned`</ph> <ph id="ph2">`int`</ph>, both operands are converted to type <ph id="ph3">`unsigned long`</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>-   If the preceding two conditions are not met, and if either operand is of type <bpt id="p1">**</bpt>long<ept id="p1">**</ept>, the other operand is converted to type <bpt id="p2">**</bpt>long<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>-   If the preceding three conditions are not met, and if either operand is of type <ph id="ph1">`unsigned int`</ph>, the other operand is converted to type <ph id="ph2">`unsigned int`</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>-   If none of the preceding conditions are met, both operands are converted to type <ph id="ph1">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following code illustrates the conversion rules described in the table:</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The first statement in the preceding example shows multiplication of two integral types, <ph id="ph1">`iVal`</ph> and <ph id="ph2">`ulVal`</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The condition met is that neither operand is of floating type and one operand is of type <ph id="ph1">`unsigned int`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Therefore, the other operand, <ph id="ph1">`iVal`</ph>, is converted to type <ph id="ph2">`unsigned int`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The result is assigned to <ph id="ph1">`dVal`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The condition met is that one operand is of type <bpt id="p1">**</bpt>double<ept id="p1">**</ept>; therefore, the <ph id="ph1">`unsigned int`</ph> result of the multiplication is converted to type <bpt id="p2">**</bpt>double<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The second statement in the preceding example shows addition of a <bpt id="p1">**</bpt>float<ept id="p1">**</ept> and an integral type, <ph id="ph1">`fVal`</ph> and <ph id="ph2">`ulVal`</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ulVal`</ph> variable is converted to type <bpt id="p1">**</bpt>float<ept id="p1">**</ept> (third condition in the table).</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The result of the addition is converted to type <bpt id="p1">**</bpt>double<ept id="p1">**</ept> (second condition in the table) and assigned to <ph id="ph1">`dVal`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Pointer conversions</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pointers can be converted during assignment, initialization, comparison, and other expressions.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Pointer to classes</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>There are two cases in which a pointer to a class can be converted to a pointer to a base class.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The first case is when the specified base class is accessible and the conversion is unambiguous.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Multiple Base Classes<ept id="p1">](../cpp/multiple-base-classes.md)</ept> for more information about ambiguous base-class references.)</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Whether a base class is accessible depends on the kind of inheritance used in derivation.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Consider the inheritance illustrated in the following figure.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Inheritance graph showing base&amp;#45;class accessibility</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Inheritance Graph for Illustration of Base-Class Accessibility</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The following table shows the base-class accessibility for the situation illustrated in the figure.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Base-Class Accessibility</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Type of Function</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Derivation</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Conversion from</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>B* to A<ph id="ph1">\*</ph> Legal?</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>External (not class-scoped) function</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Private</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Protected</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Public</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>B member function (in B scope)</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Private</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Protected</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Public</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>C member function (in C scope)</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Private</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Protected</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Public</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The second case in which a pointer to a class can be converted to a pointer to a base class is when you use an explicit type conversion.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Expressions with Explicit Type Conversions<ept id="p1">](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)</ept> for more information about explicit type conversions.)</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The result of such a conversion is a pointer to the "subobject," the portion of the object that is completely described by the base class.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The following code defines two classes, <ph id="ph1">`A`</ph> and <ph id="ph2">`B`</ph>, where <ph id="ph3">`B`</ph> is derived from <ph id="ph4">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>(For more information on inheritance, see <bpt id="p1">[</bpt>Derived Classes<ept id="p1">](../cpp/inheritance-cpp.md)</ept>.) It then defines <ph id="ph1">`bObject`</ph>, an object of type <ph id="ph2">`B`</ph>, and two pointers (<ph id="ph3">`pA`</ph> and <ph id="ph4">`pB`</ph>) that point to the object.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The pointer <ph id="ph1">`pA`</ph> is of type <ph id="ph2">`A *`</ph>, which can be interpreted as meaning "pointer to an object of type <ph id="ph3">`A`</ph>."</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Members of <ph id="ph1">`bObject`</ph> <ph id="ph2">`(`</ph>such as <ph id="ph3">`BComponent`</ph> and <ph id="ph4">`BMemberFunc`</ph>) are unique to type <ph id="ph5">`B`</ph> and are therefore inaccessible through <ph id="ph6">`pA`</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`pA`</ph> pointer allows access only to those characteristics (member functions and data) of the object that are defined in class <ph id="ph2">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Pointer to function</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A pointer to a function can be converted to type <bpt id="p1">**</bpt>void <ph id="ph1">\*</ph><ept id="p1">**</ept>, if type <bpt id="p2">**</bpt>void <ph id="ph2">\*</ph><ept id="p2">**</ept> is large enough to hold that pointer.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Pointer to void</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Pointers to type <ph id="ph1">`void`</ph> can be converted to pointers to any other type, but only with an explicit type cast (unlike in C).</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Expressions with Explicit Type Conversions<ept id="p1">](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)</ept> for more information about type casts.) A pointer to any type can be converted implicitly to a pointer to type <ph id="ph1">`void`</ph>.A pointer to an incomplete object of a type can be converted to a pointer to <ph id="ph2">`void`</ph> (implicitly) and back (explicitly).</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The result of such a conversion is equal to the value of the original pointer.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>An object is considered incomplete if it is declared, but there is insufficient information available to determine its size or base class.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>A pointer to any object that is not <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> can be implicitly converted to a pointer of type <bpt id="p2">**</bpt>void <ph id="ph2">\*</ph><ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>const and volatile pointers</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>C++ does not supply a standard conversion from a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> type to a type that is not <bpt id="p2">**</bpt>const<ept id="p2">**</ept> or <ph id="ph2">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>However, any sort of conversion can be specified using explicit type casts (including conversions that are unsafe).</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>C++ pointers to members, except pointers to static members, are different from normal pointers and do not have the same standard conversions.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Pointers to static members are normal pointers and have the same conversions as normal pointers.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>null pointer conversions</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>An integral constant expression that evaluates to zero, or such an expression cast to a pointer type, is converted to a pointer called the "null pointer."</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>In C++11 the <bpt id="p1">[</bpt>nullptr<ept id="p1">](../cpp/nullptr.md)</ept> type should be preferred to the C-style null pointer.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Pointer expression conversions</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Any expression with an array type can be converted to a pointer of the same type.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The result of the conversion is a pointer to the first array element.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The following example demonstrates such a conversion:</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>An expression that results in a function returning a particular type is converted to a pointer to a function returning that type, except when:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The expression is used as an operand to the address-of operator (<bpt id="p1">**</bpt><ph id="ph1">&amp;</ph><ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The expression is used as an operand to the function-call operator.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Reference conversions</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>A reference to a class can be converted to a reference to a base class in the following cases:</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The specified base class is accessible.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The conversion is unambiguous.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Multiple Base Classes<ept id="p1">](../cpp/multiple-base-classes.md)</ept> for more information about ambiguous base-class references.)</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The result of the conversion is a pointer to the subobject that represents the base class.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Pointer to member</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Pointers to class members can be converted during assignment, initialization, comparison, and other expressions.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This section describes the following pointer-to-member conversions:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Pointer to base class member</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>A pointer to a member of a base class can be converted to a pointer to a member of a class derived from it, when the following conditions are met:</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The inverse conversion, from pointer to derived class to base-class pointer, is accessible.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The derived class does not inherit virtually from the base class.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When the left operand is a pointer to member, the right operand must be of pointer-to-member type or be a constant expression that evaluates to 0.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This assignment is valid only in the following cases:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The right operand is a pointer to a member of the same class as the left operand.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The left operand is a pointer to a member of a class derived publicly and unambiguously from the class of the right operand.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Integral constant conversions</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>An integral constant expression that evaluates to zero is converted to a pointer called the "null pointer."</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following code illustrates the definition of a pointer to member <ph id="ph1">`i`</ph> in class <ph id="ph2">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The pointer, <ph id="ph1">`pai`</ph>, is initialized to 0, which is the null pointer.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>C++ Language Reference</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>