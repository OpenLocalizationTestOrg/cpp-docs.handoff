<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">47b3f15342dab4c5172139ea3182944719cbe25a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\task-parallelism-concurrency-runtime.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84a70da8d3bc85714bdc63a296644d3d94d17ba8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d243f25f55d5dd2fa092522ba34538cb663c1f13</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Task Parallelism (Concurrency Runtime) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Task Parallelism (Concurrency Runtime)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In the Concurrency Runtime, a <bpt id="p1">*</bpt>task<ept id="p1">*</ept> is a unit of work that performs a specific job and typically runs in parallel with other tasks.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A task can be decomposed into additional, more fine-grained tasks that are organized into a <bpt id="p1">*</bpt>task group<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You use tasks when you write asynchronous code and want some operation to occur after the asynchronous operation completes.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, you could use a task to asynchronously read from a file and then use another task—a <bpt id="p1">*</bpt>continuation task<ept id="p1">*</ept>, which is explained later in this document—to process the data after it becomes available.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Conversely, you can use tasks groups to decompose parallel work into smaller pieces.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a recursive algorithm that divides the remaining work into two partitions.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can use task groups to run these partitions concurrently, and then wait for the divided work to complete.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When you want to apply the same routine to every element of a collection in parallel, use a parallel algorithm, such as <bpt id="p1">[</bpt>concurrency::parallel_for<ept id="p1">](reference/concurrency-namespace-functions.md#parallel_for)</ept>, instead of a task or task group.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more information about parallel algorithms, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Key Points</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When you pass variables to a lambda expression by reference, you must guarantee that the lifetime of that variable persists until the task finishes.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Use tasks (the <bpt id="p1">[</bpt>concurrency::task<ept id="p1">](../../parallel/concrt/reference/task-class.md)</ept> class) when you write asynchronous code.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The task class uses the Windows ThreadPool as its scheduler, not the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Use task groups (the <bpt id="p1">[</bpt>concurrency::task_group<ept id="p1">](reference/task-group-class.md)</ept> class or the <bpt id="p2">[</bpt>concurrency::parallel_invoke<ept id="p2">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm) when you want to decompose parallel work into smaller pieces and then wait for those smaller pieces to complete.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>concurrency::task::then<ept id="p1">](reference/task-class.md#then)</ept> method to create continuations.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>continuation<ept id="p1">*</ept> is a task that runs asynchronously after another task completes.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can connect any number of continuations to form a chain of asynchronous work.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency:: HYPERLINK "http://msdn.microsoft.com/library/system.threading.tasks.task.whenall(v=VS.110).aspx" when_all<ept id="p1">](reference/concurrency-namespace-functions.md#when_all)</ept> to create a task that completes after every member of a set of tasks completes.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>concurrency::when_any<ept id="p1">](reference/concurrency-namespace-functions.md#when_all)</ept> to create a task that completes after one member of a set of tasks completes.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Tasks and task groups can participate in the Parallel Patterns Library (PPL) cancellation mechanism.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>To learn how the runtime handles exceptions that are thrown by tasks and task groups, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In this Document</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Using Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The task Class</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Continuation Tasks</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Value-Based Versus Task-Based Continuations</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Composing Tasks</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The when_all Function</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The when_any Function</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Delayed Task Execution</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Task Groups</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Comparing task_group to structured_task_group</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Robust Programming</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Using Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Because of their succinct syntax, lambda expressions are a common way to define the work that is performed by tasks and task groups.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Here are some usage tips:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Because tasks typically run on background threads, be aware of the object lifetime when you capture variables in lambda expressions.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you capture a variable by value, a copy of that variable is made in the lambda body.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When you capture by reference, a copy is not made.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Therefore, ensure that the lifetime of any variable that you capture by reference outlives the task that uses it.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When you pass a lambda expression to a task, don’t capture variables that are allocated on the stack by reference.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Be explicit about the variables you capture in lambda expressions so   that you can identify what you’re capturing by value versus by reference.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For this reason we recommend that you do not use the <ph id="ph1">`[=]`</ph> or <ph id="ph2">`[&amp;]`</ph> options for lambda expressions.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A common pattern is when one task in a continuation chain assigns to a variable, and another task reads that variable.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can’t capture by value because each continuation task would hold a different copy of the variable.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For stack-allocated variables, you also can’t capture by reference because the variable may no longer be valid.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>To solve this problem, use a smart pointer, such as <bpt id="p1">[</bpt>std::shared_ptr<ept id="p1">](../../standard-library/shared-ptr-class.md)</ept>, to wrap the variable and pass the smart pointer by value.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In this way, the underlying object can be assigned to and read from, and will outlive the tasks that use it.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use this technique even when the variable is a pointer or a reference-counted handle (<ph id="ph1">`^`</ph>) to a Windows Runtime object.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Here’s a basic example:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>concrt-lambda-task-lifetime#1</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information about lambda expressions, see <bpt id="p1">[</bpt>Lambda Expressions<ept id="p1">](../../cpp/lambda-expressions-in-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The task Class</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>concurrency::task<ept id="p1">](../../parallel/concrt/reference/task-class.md)</ept> class to compose tasks into a set of dependent operations.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This composition model is supported by the notion of <bpt id="p1">*</bpt>continuations<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A continuation enables code to be executed when the previous, or <bpt id="p1">*</bpt>antecedent<ept id="p1">*</ept>, task completes.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The result of the antecedent task is passed as the input to the one or more continuation tasks.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>When an antecedent task completes, any continuation tasks that are waiting on it are scheduled for execution.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each continuation task receives a copy of the result of the antecedent task.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In turn, those continuation tasks may also be antecedent tasks for other continuations, thereby creating a chain of tasks.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Continuations help you create arbitrary-length chains of tasks that have specific dependencies among them.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In addition, a task can participate in cancellation either before a tasks starts or in a cooperative manner while it is running.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information about this cancellation model, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>is a template class.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The type parameter <ph id="ph1">`T`</ph> is the type of the result that is produced by the task.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This type can be <ph id="ph1">`void`</ph> if the task does not return a value.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>cannot use the <ph id="ph1">`const`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD When you create a task, you provide a <bpt id="p1">*</bpt>work function<ept id="p1">*</ept> that performs the task body.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This work function comes in the form of a lambda function, function pointer, or function object.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>To wait for a task to finish without obtaining the result, call the <bpt id="p1">[</bpt>concurrency::task::wait<ept id="p1">](reference/task-class.md#wait)</ept> method.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`task::wait`</ph> method returns a <bpt id="p1">[</bpt>concurrency::task_status<ept id="p1">](reference/concurrency-namespace-enums.md#task_group_status)</ept> value that describes whether the task was completed or canceled.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To get the result of the task, call the <bpt id="p1">[</bpt>concurrency::task::get<ept id="p1">](reference/task-class.md#get)</ept> method.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This method calls <ph id="ph1">`task::wait`</ph> to wait for the task to finish, and therefore blocks execution of the current thread until the result is available.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a task, wait for its result, and display its value.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The examples in this documentation use lambda functions because they provide a more succinct syntax.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, you can also use function pointers and function objects when you use tasks.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>concrt-basic-task#1</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">[</bpt>concurrency::create_task<ept id="p1">](reference/concurrency-namespace-functions.md#create_task)</ept> function, you can use the <ph id="ph1">`auto`</ph> keyword instead of declaring the type.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, consider this code that creates and prints the identity matrix:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>concrt-create-task#1</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`create_task`</ph> function to create the equivalent operation.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>concrt-create-task#2</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the execution of a task, the runtime marshals that exception in the subsequent call to <ph id="ph1">`task::get`</ph> or <ph id="ph2">`task::wait`</ph>, or to a task-based continuation.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more information about the task exception-handling mechanism, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For an example that uses <ph id="ph1">`task`</ph>, <bpt id="p1">[</bpt>concurrency::task_completion_event<ept id="p1">](../../parallel/concrt/reference/task-completion-event-class.md)</ept>, cancellation, see <bpt id="p2">[</bpt>Walkthrough: Connecting Using Tasks and XML HTTP Requests<ept id="p2">](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>(The <ph id="ph1">`task_completion_event`</ph> class is described later in this document.)</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To learn details that are specific to tasks in <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps, see <bpt id="p1">[</bpt>Asynchronous programming in C++<ept id="p1">](http://msdn.microsoft.com/en-us/512700b7-7863-44cc-93a2-366938052f31)</ept> and <bpt id="p2">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id="p2">](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Continuation Tasks</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In asynchronous programming, it is very common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Traditionally, this is done by using callback methods.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In the Concurrency Runtime, the same functionality is provided by <bpt id="p1">*</bpt>continuation tasks<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the <bpt id="p1">*</bpt>antecedent<ept id="p1">*</ept>, when the antecedent completes.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>By using continuations, you can:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Pass data from the antecedent to the continuation.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Specify the precise conditions under which the continuation is invoked or not invoked.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Cancel a continuation either before it starts or cooperatively while it is running.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Provide hints about how the continuation should be scheduled.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>(This applies to <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps only.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id="p1">](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Invoke multiple continuations from the same antecedent.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Invoke one continuation when all or any of multiple antecedents complete.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Chain continuations one after another to any length.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Use a continuation to handle exceptions that are thrown by the antecedent.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>These features enable you to execute one or more tasks when the first task completes.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>For example, you can create a continuation that compresses a file after the first task reads it from disk.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous one to use the <bpt id="p1">[</bpt>concurrency::task::then<ept id="p1">](reference/task-class.md#then)</ept> method to schedule a continuation that prints the value of the antecedent task when it is available.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>concrt-basic-continuation#1</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>You can chain and nest tasks to any length.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A task can also have multiple continuations.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The following example illustrates a basic continuation chain that increments the value of the previous task three times.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>concrt-continuation-chain#1</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>A continuation can also return another task.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If there is no cancellation, then this task is executed before the subsequent continuation.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This technique is known as <bpt id="p1">*</bpt>asynchronous unwrapping<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Asynchronous unwrapping is useful when you want to perform additional work in the background, but do not want the current task to block the current thread.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>(This is common in <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps, where continuations can run on the UI thread).</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example shows three tasks.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The first task returns another task that is run before a continuation task.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>concrt-async-unwrapping#1</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>When a continuation of a task returns a nested task of type <ph id="ph1">`N`</ph>, the resulting task has the type <ph id="ph2">`N`</ph>, not <ph id="ph3">`task&lt;N&gt;`</ph>, and completes when the nested task completes.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In other words, the continuation performs the unwrapping of the nested task.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Value-Based Versus Task-Based Continuations</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Given a <ph id="ph1">`task`</ph> object whose return type is <ph id="ph2">`T`</ph>, you can provide a value of type <ph id="ph3">`T`</ph> or <ph id="ph4">`task&lt;T&gt;`</ph> to its continuation tasks.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A continuation that takes type <ph id="ph1">`T`</ph> is known as a <bpt id="p1">*</bpt>value-based continuation<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A value-based continuation is scheduled for execution when the antecedent task completes without error and is not canceled.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A continuation that takes type <ph id="ph1">`task&lt;T&gt;`</ph> as its parameter is known as a <bpt id="p1">*</bpt>task-based continuation<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You can then call <ph id="ph1">`task::get`</ph> to get the result of the antecedent task.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If the antecedent task was canceled, <ph id="ph1">`task::get`</ph> throws <bpt id="p1">[</bpt>concurrency::task_canceled<ept id="p1">](../../parallel/concrt/reference/task-canceled-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If the antecedent task threw an exception, <ph id="ph1">`task::get`</ph> rethrows that exception.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A task-based continuation is not marked as canceled when its antecedent task is canceled.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Composing Tasks</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This section describes the <bpt id="p1">[</bpt>concurrency::when_all<ept id="p1">](reference/concurrency-namespace-functions.md#when_all)</ept> and <bpt id="p2">[</bpt>concurrency::when_any<ept id="p2">](reference/concurrency-namespace-functions.md#when_all)</ept> functions, which can help you compose multiple tasks to implement common patterns.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The when_all Function</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`when_all`</ph> function produces a task that completes after a set of tasks complete.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This function returns a std::<bpt id="p1">[</bpt>vector<ept id="p1">](../../standard-library/vector-class.md)</ept> object that contains the result of each task in the set.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The following basic example uses <ph id="ph1">`when_all`</ph> to create a task that represents the completion of three other tasks.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>concrt-join-tasks#1</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The tasks that you pass to <ph id="ph1">`when_all`</ph> must be uniform.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>In other words, they must all return the same type.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">`&amp;&amp;`</ph> syntax to produce a task that completes after a set of tasks complete, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It is common to use a continuation together with <ph id="ph1">`when_all`</ph> to perform an action after a set of tasks finishes.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous one to print the sum of three tasks that each produce an <ph id="ph1">`int`</ph> result.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>concrt-join-tasks#2</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In this example, you can also specify<ph id="ph1">`task&lt;vector&lt;int&gt;&gt;`</ph> to produce a task-based continuation.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If any task in a set of tasks is canceled or throws an exception, <ph id="ph1">`when_all`</ph> immediately completes and does not wait for the remaining tasks to finish.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the runtime rethrows the exception when you call <ph id="ph1">`task::get`</ph> or <ph id="ph2">`task::wait`</ph> on the task object that <ph id="ph3">`when_all`</ph> returns.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If more than one task throws, the runtime chooses one of them.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Therefore, ensure that you observe all exceptions after all tasks complete; an unhandled task exception causes the app to terminate.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Here’s a utility function that you can use to ensure that your program observes all exceptions.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For each task in the provided range, <ph id="ph1">`observe_all_exceptions`</ph> triggers any exception that occurred to be rethrown and then swallows that exception.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>concrt-eh-when_all#1</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Consider a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app that uses C++ and XAML and writes a set of files to disk.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The following example shows how to use <ph id="ph1">`when_all`</ph> and <ph id="ph2">`observe_all_exceptions`</ph> to ensure that the program observes all exceptions.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>concrt-eh-when_all#2</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>To run this example</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In MainPage.xaml, add a <ph id="ph1">`Button`</ph> control.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>concrt-eh-when_all#3</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In MainPage.xaml.h, add these forward declarations to the <ph id="ph1">`private`</ph> section of the <ph id="ph2">`MainPage`</ph> class declaration.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>concrt-eh-when_all#4</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>In MainPage.xaml.cpp, implement the <ph id="ph1">`Button_Click`</ph> event handler.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>concrt-eh-when_all#5</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>In MainPage.xaml.cpp, implement <ph id="ph1">`WriteFilesAsync`</ph> as shown in the example.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>is a non-blocking function that produces a <ph id="ph1">`task`</ph> as its result.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">[</bpt>task::wait<ept id="p1">](reference/task-class.md#wait)</ept>, it is safe to call this function in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA (Application STA) thread.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The when_any Function</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`when_any`</ph> function produces a task that completes when the first task in a set of tasks completes.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This function returns a <bpt id="p1">[</bpt>std::pair<ept id="p1">](../../standard-library/pair-structure.md)</ept> object that contains the result of the completed task and the index of that task in the set.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`when_any`</ph> function is especially useful in the following scenarios:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Redundant operations.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Consider an algorithm or operation that can be performed in many ways.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`when_any`</ph> function to select the operation that finishes first and then cancel the remaining operations.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Interleaved operations.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can start multiple operations that all must finish and use the <ph id="ph1">`when_any`</ph> function to process results as each operation finishes.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>After one operation finishes, you can start one or more additional tasks.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Throttled operations.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`when_any`</ph> function to extend the previous scenario by limiting the number of concurrent operations.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Expired operations.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`when_any`</ph> function to select between one or more tasks and a task that finishes after a specific time.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>As with <ph id="ph1">`when_all`</ph>, it is common to use a continuation that has <ph id="ph2">`when_any`</ph> to perform action when the first in a set of tasks finish.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following basic example uses <ph id="ph1">`when_any`</ph> to create a task that completes when the first of three other tasks completes.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>concrt-select-task#1</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>In this example, you can also specify <ph id="ph1">`task&lt;pair&lt;int, size_t&gt;&gt;`</ph> to produce a task-based continuation.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>As with <ph id="ph1">`when_all`</ph>, the tasks that you pass to <ph id="ph2">`when_any`</ph> must all return the same type.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">`||`</ph> syntax to produce a task that completes after the first task in a set of tasks completes, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>As with <ph id="ph1">`when_all`</ph>, <ph id="ph2">`when_any`</ph> is non-blocking and is safe to call in a <ph id="ph3">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA thread.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Delayed Task Execution</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to delay the execution of a task until a condition is satisfied, or to start a task in response to an external event.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>For example, in asynchronous programming, you might have to start a task in response to an I/O completion event.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Two ways to accomplish this are to use a continuation or to start a task and wait on an event inside the task’s work function.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>However, there are cases where is it not possible to use one of these techniques.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For example, to create a continuation, you must have the antecedent task.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, if you do not have the antecedent task, you can create a <bpt id="p1">*</bpt>task completion event<ept id="p1">*</ept> and later chain that completion event to the antecedent task when it becomes available.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>In addition, because a waiting task also blocks a thread, you can use task completion events to perform work when an asynchronous operation completes, and thereby free a thread.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::task_completion_event<ept id="p1">](../../parallel/concrt/reference/task-completion-event-class.md)</ept> class helps simplify such composition of tasks.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`task`</ph> class, the type parameter <ph id="ph2">`T`</ph> is the type of the result that is produced by the task.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>This type can be <ph id="ph1">`void`</ph> if the task does not return a value.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>cannot use the <ph id="ph1">`const`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Typically, a <ph id="ph1">`task_completion_event`</ph> object is provided to a thread or task that will signal it when the value for it becomes available.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>At the same time, one or more tasks are set as listeners of that event.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>When the event is set, the listener tasks complete and their continuations are scheduled to run.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For an example that uses <ph id="ph1">`task_completion_event`</ph> to implement a task that completes after a delay, see <bpt id="p1">[</bpt>How to: Create a Task that Completes After a Delay<ept id="p1">](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Task Groups</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>task group<ept id="p1">*</ept> organizes a collection of tasks.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Task groups push tasks on to a work-stealing queue.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The scheduler removes tasks from this queue and executes them on available computing resources.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>After you add tasks to a task group, you can wait for all tasks to finish or cancel tasks that have not yet started.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The PPL uses the <bpt id="p1">[</bpt>concurrency::task_group<ept id="p1">](reference/task-group-class.md)</ept> and <bpt id="p2">[</bpt>concurrency::structured_task_group<ept id="p2">](../../parallel/concrt/reference/structured-task-group-class.md)</ept> classes to represent task groups, and the <bpt id="p3">[</bpt>concurrency::task_handle<ept id="p3">](../../parallel/concrt/reference/task-handle-class.md)</ept> class to represent the tasks that run in these groups.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`task_handle`</ph> class encapsulates the code that performs work.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`task`</ph> class, the work function comes in the form of a lambda function, function pointer, or function object.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>You typically do not need to work with <ph id="ph1">`task_handle`</ph> objects directly.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Instead, you pass work functions to a task group, and the task group creates and manages the <ph id="ph1">`task_handle`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The PPL divides task groups into these two categories: <bpt id="p1">*</bpt>unstructured task groups<ept id="p1">*</ept> and <bpt id="p2">*</bpt>structured task groups<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The PPL uses the <ph id="ph1">`task_group`</ph> class to represent unstructured task groups and the <ph id="ph2">`structured_task_group`</ph> class to represent structured task groups.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The PPL also defines the <bpt id="p1">[</bpt>concurrency::parallel_invoke<ept id="p1">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm, which uses the <ph id="ph1">`structured_task_group`</ph> class to execute a set of tasks in parallel.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`parallel_invoke`</ph> algorithm has a more succinct syntax, we recommend that you use it instead of the <ph id="ph2">`structured_task_group`</ph> class when you can.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The topic <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../parallel/concrt/parallel-algorithms.md)</ept> describes <ph id="ph1">`parallel_invoke`</ph> in greater detail.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`parallel_invoke`</ph> when you have several independent tasks that you want to execute at the same time, and you must wait for all tasks to finish before you continue.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This technique is often referred to as <bpt id="p1">*</bpt>fork and join<ept id="p1">*</ept> parallelism.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`task_group`</ph> when you have several independent tasks that you want to execute at the same time, but you want to wait for the tasks to finish at a later time.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>For example, you can add tasks to a <ph id="ph1">`task_group`</ph> object and wait for the tasks to finish in another function or from another thread.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Task groups support the concept of cancellation.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Cancellation enables you to signal to all active tasks that you want to cancel the overall operation.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Cancellation also prevents tasks that have not yet started from starting.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>For more information about cancellation, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The runtime also provides an exception-handling model that enables you to throw an exception from a task and handle that exception when you wait for the associated task group to finish.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>For more information about this exception-handling model, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Comparing task_group to structured_task_group</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Although we recommend that you use <ph id="ph1">`task_group`</ph> or <ph id="ph2">`parallel_invoke`</ph> instead of the <ph id="ph3">`structured_task_group`</ph> class, there are cases where you want to use <ph id="ph4">`structured_task_group`</ph>, for example, when you write a parallel algorithm that performs a variable number of tasks or requires support for cancellation.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This section explains the differences between the <ph id="ph1">`task_group`</ph> and <ph id="ph2">`structured_task_group`</ph> classes.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`task_group`</ph> class is thread-safe.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Therefore you can add tasks to a <ph id="ph1">`task_group`</ph> object from multiple threads and wait on or cancel a <ph id="ph2">`task_group`</ph> object from multiple threads.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The construction and destruction of a <ph id="ph1">`structured_task_group`</ph> object must occur in the same lexical scope.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>In addition, all operations on a <ph id="ph1">`structured_task_group`</ph> object must occur on the same thread.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The exception to this rule is the <bpt id="p1">[</bpt>concurrency::structured_task_group::cancel<ept id="p1">](reference/structured-task-group-class.md#cancel)</ept> and <bpt id="p2">[</bpt>concurrency::structured_task_group::is_canceling<ept id="p2">](reference/structured-task-group-class.md#is_canceling)</ept> methods.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A child task can call these methods to cancel the parent task group or check for cancelation at any time.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>You can run additional tasks on a <ph id="ph1">`task_group`</ph> object after you call the <bpt id="p1">[</bpt>concurrency::task_group::wait<ept id="p1">](reference/task-group-class.md#wait)</ept> or <bpt id="p2">[</bpt>concurrency::task_group::run_and_wait<ept id="p2">](reference/task-group-class.md#run_and_wait)</ept> method.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Conversely, if you run additional tasks on a <ph id="ph1">`structured_task_group`</ph> object after you call the <bpt id="p1">[</bpt>concurrency::structured_task_group::wait<ept id="p1">](reference/structured-task-group-class.md#wait)</ept> or <bpt id="p2">[</bpt>concurrency::structured_task_group::run_and_wait<ept id="p2">](reference/structured-task-group-class.md#run_and_wait)</ept> methods, then the behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`structured_task_group`</ph> class does not synchronize across threads, it has less execution overhead than the <ph id="ph2">`task_group`</ph> class.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Therefore, if your problem does not require that you schedule work from multiple threads and you cannot use the <ph id="ph1">`parallel_invoke`</ph> algorithm, the <ph id="ph2">`structured_task_group`</ph> class can help you write better performing code.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>If you use one <ph id="ph1">`structured_task_group`</ph> object inside another <ph id="ph2">`structured_task_group`</ph> object, the inner object must finish and be destroyed before the outer object finishes.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`task_group`</ph> class does not require for nested task groups to finish before the outer group finishes.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Unstructured task groups and structured task groups work with task handles in different ways.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>You can pass work functions directly to a <ph id="ph1">`task_group`</ph> object; the <ph id="ph2">`task_group`</ph> object will create and manage the task handle for you.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`structured_task_group`</ph> class requires you to manage a <ph id="ph2">`task_handle`</ph> object for each task.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Every <ph id="ph1">`task_handle`</ph> object must remain valid throughout the lifetime of its associated <ph id="ph2">`structured_task_group`</ph> object.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>concurrency::make_task<ept id="p1">](reference/concurrency-namespace-functions.md#make_task)</ept> function to create a <ph id="ph1">`task_handle`</ph> object, as shown in the following basic example:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>concrt-make-task-structure#1</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>To manage task handles for cases where you have a variable number of tasks, use a stack-allocation routine such as <bpt id="p1">[</bpt>_malloca<ept id="p1">](../../c-runtime-library/reference/malloca.md)</ept> or a container class, such as std::<bpt id="p2">[</bpt>vector<ept id="p2">](../../standard-library/vector-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`task_group`</ph> and <ph id="ph2">`structured_task_group`</ph> support cancellation.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>For more information about cancellation, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](cancellation-in-the-ppl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The following basic example shows how to work with task groups.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>This example uses the <ph id="ph1">`parallel_invoke`</ph> algorithm to perform two tasks concurrently.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Each task adds sub-tasks to a <ph id="ph1">`task_group`</ph> object.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`task_group`</ph> class allows for multiple tasks to add tasks to it concurrently.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>concrt-using-task-groups#1</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The following is sample output for this example:</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`parallel_invoke`</ph> algorithm runs tasks concurrently, the order of the output messages could vary.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>For complete examples that show how to use the <ph id="ph1">`parallel_invoke`</ph> algorithm, see <bpt id="p1">[</bpt>How to: Use parallel_invoke to Write a Parallel Sort Routine<ept id="p1">](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)</ept> and <bpt id="p2">[</bpt>How to: Use parallel_invoke to Execute Parallel Operations<ept id="p2">](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For a complete example that uses the <ph id="ph1">`task_group`</ph> class to implement asynchronous futures, see <bpt id="p1">[</bpt>Walkthrough: Implementing Futures<ept id="p1">](../../parallel/concrt/walkthrough-implementing-futures.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Robust Programming</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Make sure that you understand the role of cancellation and exception handling when you use tasks, task groups, and parallel algorithms.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>For example, in a tree of parallel work, a task that is canceled prevents child tasks from running.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This can cause problems if one of the child tasks performs an operation that is important to your application, such as freeing a resource.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>In addition, if a child task throws an exception, that exception could propagate through an object destructor and cause undefined behavior in your application.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>For an example that illustrates these points, see the <bpt id="p1">[</bpt>Understand how Cancellation and Exception Handling Affect Object Destruction<ept id="p1">](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction)</ept> section in the Best Practices in the Parallel Patterns Library document.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>For more information about the cancellation and exception-handling models in the PPL, see <bpt id="p1">[</bpt>Cancellation<ept id="p1">](../../parallel/concrt/cancellation-in-the-ppl.md)</ept> and <bpt id="p2">[</bpt>Exception Handling<ept id="p2">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Title</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>How to: Use parallel_invoke to Write a Parallel Sort Routine</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">`parallel_invoke`</ph> algorithm to improve the performance of the bitonic sort algorithm.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>How to: Use parallel_invoke to Execute Parallel Operations</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">`parallel_invoke`</ph> algorithm to improve the performance of a program that performs multiple operations on a shared data source.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>How to: Create a Task that Completes After a Delay</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">`task`</ph>, <ph id="ph2">`cancellation_token_source`</ph>, <ph id="ph3">`cancellation_token`</ph>, and <ph id="ph4">`task_completion_event`</ph> classes to create a task that completes after a delay.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Walkthrough: Implementing Futures</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Shows how to combine existing functionality in the Concurrency Runtime into something that does more.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Parallel Patterns Library (PPL)</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Describes the PPL, which provides an imperative programming model for developing concurrent applications.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Reference</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>task Class (Concurrency Runtime)</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>task_completion_event Class</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>when_all Function</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>when_any Function</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>task_group Class</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>parallel_invoke Function</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>structured_task_group Class</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>