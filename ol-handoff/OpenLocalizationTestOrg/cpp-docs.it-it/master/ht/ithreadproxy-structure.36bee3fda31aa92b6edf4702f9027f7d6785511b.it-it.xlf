<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">baa3266d1068672df96595fa8b9bcc974d52e7fa</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\reference\ithreadproxy-structure.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">43cf2c1f9c7f1c81777267562852c0aeca49e395</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df7e1cd398927b5e16d728e9e2df9d0e8e40a40c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>IThreadProxy Structure | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>IThreadProxy Structure</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An abstraction for a thread of execution.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Depending on the <ph id="ph1">`SchedulerType`</ph> policy key of the scheduler you create, the Resource Manager will grant you a thread proxy that is backed by either a regular Win32 thread or a user-mode schedulable (UMS) thread.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>UMS threads are supported on 64-bit operating systems with version Windows 7 and higher.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>IThreadProxy::GetId Method</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the thread proxy.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>IThreadProxy::SwitchOut Method</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Disassociates the context from the underlying virtual processor root.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>IThreadProxy::SwitchTo Method</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Performs a cooperative context switch from the currently executing context to a different one.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>IThreadProxy::YieldToSystem Method</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The operating system selects the next thread to be executed.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Thread proxies are coupled to execution contexts represented by the interface <ph id="ph1">`IExecutionContext`</ph> as a means of dispatching work.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> concrtrm.h</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> concurrency</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>IThreadProxy::GetId Method</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the thread proxy.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A unique integer identifier.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>IThreadProxy::SwitchOut Method</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Disassociates the context from the underlying virtual processor root.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Indicates the state of the thread proxy that is executing the switch.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The parameter is of type <ph id="ph1">`SwitchingProxyState`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`SwitchOut`</ph> if you need to disassociate a context from the virtual processor root it is executing on, for any reason.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Depending on the value you pass in to the parameter <ph id="ph1">`switchState`</ph>, and whether or not it is executing on a virtual processor root, the call will either return immediately or block the thread proxy associated with the context.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It is an error to call <ph id="ph1">`SwitchOut`</ph> with the parameter set to <ph id="ph2">`Idle`</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Doing so will result in an <bpt id="p1">[</bpt>invalid_argument<ept id="p1">](../../../standard-library/invalid-argument-class.md)</ept> exception.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>is useful when you want to reduce the number of virtual processor roots your scheduler has, either because the Resource Manager has instructed you to do so, or because you requested a temporary oversubscribed virtual processor root, and are done with it.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In this case you should invoke the method <bpt id="p1">[</bpt>IVirtualProcessorRoot::Remove Method<ept id="p1">](http://msdn.microsoft.com/en-us/ad699b4a-1972-4390-97ee-9c083ba7d9e4)</ept> on the virtual processor root, before making a call to <ph id="ph1">`SwitchOut`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Blocking`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This will block the thread proxy and it will resume execution when a different virtual processor root in the scheduler is available to execute it.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The blocking thread proxy can be resumed by calling the function <ph id="ph1">`SwitchTo`</ph> to switch to this thread proxy's execution context.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can also resume the thread proxy, by using its associated context to activate a virtual processor root.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information on how to do this, see <bpt id="p1">[</bpt>IVirtualProcessorRoot::Activate<ept id="p1">](ivirtualprocessorroot-structure.md#activate)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>may also be used when you want reinitialize the virtual processor so it may be activated in the future while either blocking the thread proxy or temporarily detaching it from the virtual processor root it is running on, and the scheduler it is dispatching work for.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`SwitchOut`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Blocking`</ph> if you wish to block the thread proxy.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It can later be resumed using either <ph id="ph1">`SwitchTo`</ph> or <ph id="ph2">`IVirtualProcessorRoot::Activate`</ph> as noted above.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`SwitchOut`</ph> with the parameter set to <ph id="ph2">`Nesting`</ph> when you want to temporarily detach this thread proxy from the virtual processor root it is running on, and the scheduler the virtual processor is associated with.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`SwitchOut`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Nesting`</ph> while it is executing on a virtual processor root will cause the root to be reinitialized and the current thread proxy to continue executing without the need for one.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The thread proxy is considered to have left the scheduler until it calls the <bpt id="p1">[</bpt>IThreadProxy::SwitchOut<ept id="p1">](#switchout)</ept> method with <ph id="ph1">`Blocking`</ph> at a later point in time.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The second call to <ph id="ph1">`SwitchOut`</ph> with the parameter set to <ph id="ph2">`Blocking`</ph> is intended to return the context to a blocked state so that it can be resumed by either <ph id="ph3">`SwitchTo`</ph> or <ph id="ph4">`IVirtualProcessorRoot::Activate`</ph> in the scheduler it detached from.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because it was not executing on a virtual processor root, no reinitialization takes place.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A reinitialized virtual processor root is no different from a brand new virtual processor root your scheduler has been granted by the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can use it for execution by activating it with an execution context using <ph id="ph1">`IVirtualProcessorRoot::Activate`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>must be called on the <ph id="ph1">`IThreadProxy`</ph> interface that represents the currently executing thread or the results are undefined.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the libraries and headers that shipped with Visual Studio 2010, this method did not take a parameter and did not reinitialize the virtual processor root.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To preserve old behavior, the default parameter value of <ph id="ph1">`Blocking`</ph> is supplied.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>IThreadProxy::SwitchTo Method</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Performs a cooperative context switch from the currently executing context to a different one.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The execution context to cooperatively switch to.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Indicates the state of the thread proxy that is executing the switch.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The parameter is of type <ph id="ph1">`SwitchingProxyState`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Use this method to switch from one execution context to another, from the <bpt id="p1">[</bpt>IExecutionContext::Dispatch<ept id="p1">](iexecutioncontext-structure.md#dispatch)</ept> method of the first execution context.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The method associates the execution context <ph id="ph1">`pContext`</ph> with a thread proxy if it is not already associated with one.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The ownership of the current thread proxy is determined by the value you specify for the <ph id="ph1">`switchState`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Use the value <ph id="ph1">`Idle`</ph> when you want to return the currently executing thread proxy to the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`SwitchTo`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Idle`</ph> will cause the execution context <ph id="ph4">`pContext`</ph> to start executing on the underlying execution resource.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Ownership of this thread proxy is transferred to the Resource Manager, and you are expected to return from the execution context's <ph id="ph1">`Dispatch`</ph> method soon after <ph id="ph2">`SwitchTo`</ph> returns, in order to complete the transfer.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The execution context that the thread proxy was dispatching is disassociated from the thread proxy, and the scheduler is free to reuse it or destroy it as it sees fit.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Use the value <ph id="ph1">`Blocking`</ph> when you want this thread proxy to enter a blocked state.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`SwitchTo`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Blocking`</ph> will cause the execution context <ph id="ph4">`pContext`</ph> to start executing, and block the current thread proxy until it is resumed.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The scheduler retains ownership of the thread proxy when the thread proxy is in the <ph id="ph1">`Blocking`</ph> state.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The blocking thread proxy can be resumed by calling the function <ph id="ph1">`SwitchTo`</ph> to switch to this thread proxy's execution context.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can also resume the thread proxy, by using its associated context to activate a virtual processor root.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information on how to do this, see <bpt id="p1">[</bpt>IVirtualProcessorRoot::Activate<ept id="p1">](ivirtualprocessorroot-structure.md#activate)</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Use the value <ph id="ph1">`Nesting`</ph> when you want to temporarily detach this thread proxy from the virtual processor root it is running on, and the scheduler it is dispatching work for.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`SwitchTo`</ph> with the parameter <ph id="ph2">`switchState`</ph> set to <ph id="ph3">`Nesting`</ph> will cause the execution context <ph id="ph4">`pContext`</ph> to start executing and the current thread proxy also continues executing without the need for a virtual processor root.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The thread proxy is considered to have left the scheduler until it calls the <bpt id="p1">[</bpt>IThreadProxy::SwitchOut<ept id="p1">](#switchout)</ept> method at a later point in time.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IThreadProxy::SwitchOut`</ph> method could block the thread proxy until a virtual processor root is available to reschedule it.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>must be called on the <ph id="ph1">`IThreadProxy`</ph> interface that represents the currently executing thread or the results are undefined.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The function throws <ph id="ph1">`invalid_argument`</ph> if the parameter <ph id="ph2">`pContext`</ph> is set to <ph id="ph3">`NULL`</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>IThreadProxy::YieldToSystem Method</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The operating system selects the next thread to be executed.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When called by a thread proxy backed by a regular Windows thread, <ph id="ph1">`YieldToSystem`</ph> behaves exactly like the Windows function <ph id="ph2">`SwitchToThread`</ph>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, when called from user-mode schedulable (UMS) threads, the <ph id="ph1">`SwitchToThread`</ph> function delegates the task of picking the next thread to run to the user mode scheduler, not the operating system.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>To achieve the desired effect of switching to a different ready thread in the system, use <ph id="ph1">`YieldToSystem`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>must be called on the <ph id="ph1">`IThreadProxy`</ph> interface that represents the currently executing thread or the results are undefined.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>concurrency Namespace</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>IExecutionContext Structure</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>IScheduler Structure</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>IVirtualProcessorRoot Structure</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>