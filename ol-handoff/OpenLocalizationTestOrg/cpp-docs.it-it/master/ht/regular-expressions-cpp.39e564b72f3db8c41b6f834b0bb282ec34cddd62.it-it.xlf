<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3ba44635d2183649f6e1dbf58a748bd55b7985b5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\regular-expressions-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c5fb9a6d6ab7b288031e889a5e88fa9b9a73bfe9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">87c8a1c98aa3895bd73c763198873668dfa06a67</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular Expressions (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular Expressions (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic discusses the grammars of the various regular expression engines.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular Expression Grammar</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An element can be one of the following things:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>ordinary character<ept id="p1">*</ept> that matches the same character in the target sequence.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>wildcard character<ept id="p1">*</ept> '.' that matches any character in the target sequence except a newline.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>bracket expression<ept id="p1">*</ept> of the form "[<ph id="ph1">`expr`</ph>]", which matches a character or a collation element in the target sequence that is also in the set defined by the expression <ph id="ph2">`expr`</ph>, or of the form "[^<ph id="ph3">`expr`</ph>]", which matches a character or a collation element in the target sequence that is not in the set defined by the expression <ph id="ph4">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`expr`</ph> can contain any combination of the following things:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An individual character.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Adds that character to the set defined by <ph id="ph1">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>character range<ept id="p1">*</ept> of the form "<ph id="ph1">`ch1`-`ch2`</ph>".</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Adds the characters that are represented by values in the closed range [<ph id="ph1">`ch1`</ph>, <ph id="ph2">`ch2`</ph>] to the set defined by <ph id="ph3">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>character class<ept id="p1">*</ept> of the form "[:<ph id="ph1">`name`</ph>:]".</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Adds the characters in the named class to the set defined by <ph id="ph1">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>equivalence class<ept id="p1">*</ept> of the form "[=<ph id="ph1">`elt`</ph>=]".</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Adds the collating elements that are equivalent to <ph id="ph1">`elt`</ph> to the set defined by <ph id="ph2">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>collating symbol<ept id="p1">*</ept> of the form "[.<ph id="ph1">`elt`</ph>.]".</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Adds the collation element <ph id="ph1">`elt`</ph> to the set defined by <ph id="ph2">`expr`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>anchor<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Anchor '^' matches the beginning of the target sequence; anchor '$' matches the end of the target sequence.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>capture group<ept id="p1">*</ept> of the form "( <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> )", or "<ph id="ph1">\\</ph>( <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> <ph id="ph2">\\</ph>)" in <ph id="ph3">`BRE`</ph> and <ph id="ph4">`grep`</ph>, which matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>identity escape<ept id="p1">*</ept> of the form "<ph id="ph1">\\`k`</ph>", which matches the character <ph id="ph2">`k`</ph> in the target sequence.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>"a" matches the target sequence "a" but does not match the target sequences "B", "b", or "c".</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>"." matches all the target sequences "a", "B", "b", and "c".</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>"[b-z]" matches the target sequences "b" and "c" but does not match the target sequences "a" or "B".</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>"[:lower:]" matches the target sequences "a", "b", and "c" but does not match the target sequence "B".</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>"(a)" matches the target sequence "a" and associates capture group 1 with the subsequence "a", but does not match the target sequences "B", "b", or "c".</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, <ph id="ph2">`BRE`</ph>, and <ph id="ph3">`grep`</ph>, an element can also be a <bpt id="p1">*</bpt>back reference<ept id="p1">*</ept> of the form "<ph id="ph4">\\`dd`</ph>", where <ph id="ph5">`dd`</ph> represents a decimal value N that matches a sequence of characters in the target sequence that is the same as the sequence of characters that is matched by the Nth <bpt id="p2">*</bpt>capture group<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, "(a)\1" matches the target sequence "aa" because the first (and only) capture group matches the initial sequence "a" and then the \1 matches the final sequence "a".</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, an element can also be one of the following things:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>non-capture group<ept id="p1">*</ept> of the form "(: <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> )".</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A limited <bpt id="p1">*</bpt>file format escape<ept id="p1">*</ept> of the form "\f", "\n", "\r", "\t", or "\v".</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These match a form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>positive assert<ept id="p1">*</ept> of the form "(= <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> )".</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Matches the sequence of characters in the target sequence that is matched by the pattern between the delimiters, but does not change the match position in the target sequence.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>negative assert<ept id="p1">*</ept> of the form "(!</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> )".</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Matches any sequence of characters in the target sequence that does not match the pattern between the delimiters, and does not change the match position in the target sequence.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>hexadecimal escape sequence<ept id="p1">*</ept> of the form "\x<ph id="ph1">`hh`</ph>".</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Matches a character in the target sequence that is represented by the two hexadecimal digits <ph id="ph1">`hh`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>unicode escape sequence<ept id="p1">*</ept> of the form "\u<ph id="ph1">`hhhh`</ph>".</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Matches a character in the target sequence that is represented by the four hexadecimal digits <ph id="ph1">`hhhh`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>control escape sequence<ept id="p1">*</ept> of the form "\c<ph id="ph1">`k`</ph>".</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Matches the control character that is named by the character <ph id="ph1">`k`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>word boundary assert<ept id="p1">*</ept> of the form "\b".</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Matches when the current position in the target sequence is immediately after a <bpt id="p1">*</bpt>word boundary<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>negative word boundary assert<ept id="p1">*</ept> of the form "\B".</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Matches when the current position in the target sequence is not immediately after a <bpt id="p1">*</bpt>word boundary<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>dsw character escape<ept id="p1">*</ept> of the form "\d", "\D", "\s", "\S", "\w", "\W".</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Provides a short name for a character class.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"(:a)" matches the target sequence "a", but "(:a)\1" is invalid because there is no capture group 1.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>"(=a)a" matches the target sequence "a".</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The positive assert matches the initial sequence "a" in the target sequence and the final "a" in the regular expression matches the initial sequence "a" in the target sequence.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>"(!a)a" does not match the target sequence "a".</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>"a\b."</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>matches the target sequence "a~", but does not match the target sequence "ab".</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>"a\B."</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>matches the target sequence "ab", but does not match the target sequence "a~".</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`awk`</ph>, an element can also be one of the following things:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>file format escape<ept id="p1">*</ept> of the form "<ph id="ph1">\\\\</ph>", "\a", "\b", "\f", "\n", "\r", "\t", or "\v".</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>These match a backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively, in the target sequence.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>octal escape sequence<ept id="p1">*</ept> of the form "<ph id="ph1">\\`ooo`</ph>".</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Matches a character in the target sequence whose representation is the value represented by the one, two, or three octal digits <ph id="ph1">`ooo`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Repetition</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Any element other than a <bpt id="p1">*</bpt>positive assert<ept id="p1">*</ept>, a <bpt id="p2">*</bpt>negative assert<ept id="p2">*</ept>, or an <bpt id="p3">*</bpt>anchor<ept id="p3">*</ept> can be followed by a repetition count.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The most general kind of repetition count takes the form "{<ph id="ph1">`min`</ph>,<ph id="ph2">`max`</ph>}", or "<ph id="ph3">\\</ph>{<ph id="ph4">`min`</ph>,<ph id="ph5">`max`\\</ph>}" in <ph id="ph6">`BRE`</ph> and <ph id="ph7">`grep`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>An element that is followed by this form of repetition count matches at least <ph id="ph1">`min`</ph> successive occurrences and no more than <ph id="ph2">`max`</ph> successive occurrences of a sequence that matches the element.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For example, "a{2,3}" matches the target sequence "aa" and the target sequence "aaa", but not the target sequence "a" or the target sequence "aaaa".</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A repetition count can also take one of the following forms:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>"{<ph id="ph1">`min`</ph>}", or "<ph id="ph2">\\</ph>{<ph id="ph3">`min`\\</ph>}" in <ph id="ph4">`BRE`</ph> and <ph id="ph5">`grep`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Equivalent to "{<ph id="ph1">`min`</ph>,<ph id="ph2">`min`</ph>}".</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>"{<ph id="ph1">`min`</ph>,}", or "<ph id="ph2">\\</ph>{<ph id="ph3">`min`</ph>,<ph id="ph4">\\</ph>}" in <ph id="ph5">`BRE`</ph> and <ph id="ph6">`grep`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Equivalent to "{<ph id="ph1">`min`</ph>,unbounded}".</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>"*".</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Equivalent to "{0,unbounded}".</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>"a{2}" matches the target sequence "aa" but not the target sequence "a" or the target sequence "aaa".</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>"a{2,}" matches the target sequence "aa", the target sequence "aaa", and so on, but does not match the target sequence "a".</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>"a*" matches the target sequence "", the target sequence "a", the target sequence "aa", and so on.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For all grammars except <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, a repetition count can also take one of the following forms:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>"".</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Equivalent to "{0,1}".</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>"+".</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Equivalent to "{1,unbounded}".</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>"a" matches the target sequence "" and the target sequence "a", but not the target sequence "aa".</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>"a+" matches the target sequence "a", the target sequence "aa", and so on, but not the target sequence "".</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, all the forms of repetition count can be followed by the character '', which designates a <bpt id="p1">*</bpt>non-greedy repetition<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Regular expression elements, with or without <bpt id="p1">*</bpt>repetition counts<ept id="p1">*</ept>, can be concatenated to form longer regular expressions.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The resulting expression matches a target sequence that is a concatenation of the sequences that are matched by the individual elements.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For example, "a{2,3}b" matches the target sequence "aab" and the target sequence "aaab", but does not match the target sequence "ab" or the target sequence "aaaab".</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Alternation</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In all regular expression grammars except <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, a concatenated regular expression can be followed by the character '&amp;#124;' and another concatenated regular expression.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Any number of concatenated regular expressions can be combined in this manner.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The resulting expression matches any target sequence that matches one or more of the concatenated regular expressions.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>When more than one of the concatenated regular expressions matches the target sequence, <ph id="ph1">`ECMAScript`</ph> chooses the first of the concatenated regular expressions that matches the sequence as the match (<bpt id="p1">*</bpt>first match<ept id="p1">*</ept>); the other regular expression grammars choose the one that achieves the <bpt id="p2">*</bpt>longest match<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, "ab&amp;#124;cd" matches the target sequence "ab" and the target sequence "cd", but does not match the target sequence "abd" or the target sequence "acd".</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`grep`</ph> and <ph id="ph2">`egrep`</ph>, a newline character ('\n') can be used to separate alternations.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Subexpression</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, a subexpression is a concatenation.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In the other regular expression grammars, a subexpression is an alternation.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Grammar Summary</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table summarizes the features that are available in the various regular expression grammars:</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>BRE</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>ERE</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ECMA</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>grep</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>egrep</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>awk</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>alternation using '&amp;#124;'</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>alternation using '\n'</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>anchor</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>back reference</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>bracket expression</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>capture group using "()"</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>capture group using "<ph id="ph1">\\</ph>(<ph id="ph2">\\</ph>)"</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>control escape sequence</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>dsw character escape</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>file format escape</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>hexadecimal escape sequence</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>identity escape</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>negative assert</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>negative word boundary assert</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>non-capture group</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>non-greedy repetition</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>octal escape sequence</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>ordinary character</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>positive assert</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>repetition using "{}"</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>repetition using "<ph id="ph1">\\</ph>{<ph id="ph2">\\</ph>}"</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>repetition using '*'</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>repetition using '' and '+'</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>unicode escape sequence</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>wildcard character</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>word boundary assert</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Semantic Details</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Anchor</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>An anchor matches a position in the target string, not a character.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>A '^' matches the beginning of the target string, and a '$' matches the end of the target string.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Back Reference</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>A back reference is a backslash that is followed by a decimal value N. It matches the contents of the Nth <bpt id="p1">*</bpt>capture group<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The value of N must not be more than the number of capture groups that precede the back reference.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, the value of N is determined by the decimal digit that follows the backslash.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, the value of N is determined by all the decimal digits that immediately follow the backslash.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Therefore, in <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, the value of N is never more than 9, even if the regular expression has more than nine capture groups.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, the value of N is unbounded.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>"((a+)(b+))(c+)\3" matches the target sequence "aabbbcbbb".</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The back reference "\3" matches the text in the third capture group, that is, the "(b+)".</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>It does not match the target sequence "aabbbcbb".</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>"(a)\2" is not valid.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>"(b(((((((((a))))))))))\10" has different meanings in <ph id="ph1">`BRE`</ph> and in <ph id="ph2">`ECMAScript`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`BRE`</ph> the back reference is "\1".</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The back reference matches the contents of the first capture group (that is, the one that begins with "(b" and ends with the final ")" and comes before the back reference), and the final '0' matches the ordinary character '0'.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, the back reference is "\10".</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>It matches the tenth capture group, that is, the innermost one.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Bracket Expression</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A bracket expression defines a set of characters and <bpt id="p1">*</bpt>collating elements<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>When the bracket expression begins with the character '^' the match succeeds if no elements in the set match the current character in the target sequence.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Otherwise, the match succeeds if any one of the elements in the set matches the current character in the target sequence.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The set of characters can be defined by listing any combination of <bpt id="p1">*</bpt>individual characters<ept id="p1">*</ept>, <bpt id="p2">*</bpt>character ranges<ept id="p2">*</ept>, <bpt id="p3">*</bpt>character classes<ept id="p3">*</ept>, <bpt id="p4">*</bpt>equivalence classes<ept id="p4">*</ept>, and <bpt id="p5">*</bpt>collating symbols<ept id="p5">*</ept>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Capture Group</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>A capture group marks its contents as a single unit in the regular expression grammar and labels the target text that matches its contents.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The label that is associated with each capture group is a number, which is determined by counting the opening parentheses that mark capture groups up to and including the opening parenthesis that marks the current capture group.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>In this implementation, the maximum number of capture groups is 31.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>"ab+" matches the target sequence "abb", but does not match the target sequence "abab".</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>"(ab)+" does not match the target sequence "abb", but matches the target sequence "abab".</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>"((a+)(b+))(c+)" matches the target sequence "aabbbc" and associates capture group 1 with the subsequence "aabbb", capture group 2 with the subsequence "aa", capture group 3 with "bbb", and capture group 4 with the subsequence "c".</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Character Class</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A character class in a bracket expression adds all the characters in the named class to the character set that is defined by the bracket expression.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>To create a character class, use "[:" followed by the name of the class followed by ":]".</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Internally, names of character classes are recognized by calling <ph id="ph1">`id = traits.lookup_classname`</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>A character <ph id="ph1">`ch`</ph> belongs to such a class if <ph id="ph2">`traits.isctype(ch, id)`</ph> returns true.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The default <ph id="ph1">`regex_traits`</ph> template supports the class names in the following table.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Class Name</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>"alnum"</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>lowercase letters, uppercase letters, and digits</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>"alpha"</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>lowercase letters and uppercase letters</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>"blank"</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>space or tab</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>"cntrl"</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>the <bpt id="p1">*</bpt>file format escape<ept id="p1">*</ept> characters</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>"digit"</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>digits</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>"graph"</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>lowercase letters, uppercase letters, digits, and punctuation</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>"lower"</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>lowercase letters</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"print"</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>lowercase letters, uppercase letters, digits, punctuation, and space</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>"punct"</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>punctuation</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>"space"</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>space</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>"upper</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>uppercase characters</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>"xdigit"</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>digits, 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>"d"</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>same as digit</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>"s"</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>same as space</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>"w"</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>same as alnum</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Character Range</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>A character range in a bracket expression adds all the characters in the range to the character set that is defined by the bracket expression.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To create a character range, put the character '-' between the first and last characters in the range.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Doing this puts into the set all characters that have a numeric value that is more than or equal to the numeric value of the first character, and less than or equal to the numeric value of the last character.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Notice that this set of added characters depends on the platform-specific representation of characters.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>If the character '-' occurs at the beginning or the end of a bracket expression, or as the first or last character of a character range, it represents itself.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>"[0-7]" represents the set of characters { '0', '1', '2', '3', '4', '5', '6', '7' }.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>It matches the target sequences "0", "1", and so on, but not "a".</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>On systems that use the ASCII character encoding, "[h-k]" represents the set of characters { 'h', 'i', 'j', 'k' }.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>It matches the target sequences "h", "i", and so on, but not "\x8A" or "0".</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>On systems that use the EBCDIC character encoding, "[h-k]" represents the set of characters { 'h', 'i', '\x8A', '\x8B', '\x8C', '\x8D', '\x8E', '\x8F', '\x90', 'j', 'k' } ('h' is encoded as 0x88 and 'k' is encoded as 0x92).</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It matches the target sequences "h", "i", "\x8A", and so on, but not "0".</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>"[-0-24]" represents the set of characters { '-', '0', '1', '2', '4' }.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"[0-2-]" represents the set of characters { '0', '1', '2', '-' }.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>On systems that use the ASCII character encoding, "[+--]" represents the set of characters { '+', ',', '-' }.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>However, when locale-sensitive ranges are used, the characters in a range are determined by the collation rules for the locale.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Characters that collate after the first character in the definition of the range and before the last character in the definition of the range are in the set.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The two end characters are also in the set.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Collating Element</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>A collating element is a multi-character sequence that is treated as a single character.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Collating Symbol</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>A collating symbol in a bracket expression adds a <bpt id="p1">*</bpt>collating element<ept id="p1">*</ept> to the set that is defined by the bracket expression.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>To create a collating symbol, use "[."</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>followed by the collating element followed by ".]".</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Control Escape Sequence</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A control escape sequence is a backslash followed by the letter 'c' followed by one of the letters 'a' through 'z' or 'A' through 'Z'.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>It matches the ASCII control character that is named by that letter.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, "\ci" matches the target sequence "\x09", because <ph id="ph1">\&lt;</ph>ctrl-i&gt; has the value 0x09.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>DSW Character Escape</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>A dsw character escape is a short name for a character class, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Escape Sequence</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Equivalent Named Class</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Default Named Class</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>"\d"</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>"[[:d:]]"</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>"[[:digit:]]"</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>"\D"</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>"[^[:d:]]"</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>"[^[:digit:]]"</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>"\s"</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>"[[:s:]]"</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>"[[:space:]]"</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>"\S"</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>"[^[:s:]]"</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>"[^[:space:]]"</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>"\w"</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>"[[:w:]]"</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>"[a-zA-Z0-9_]"*</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>"\W"</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>"[^[:w:]]"</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>"[^a-zA-Z0-9_]"*</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>*ASCII character set</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Equivalence Class</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>An equivalence class in a bracket expression adds all the characters and <bpt id="p1">*</bpt>collating elements<ept id="p1">*</ept> that are equivalent to the collating element in the equivalence class definition to the set that is defined by the bracket expression.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>To create an equivalence class, use "[=" followed by a collating element followed by "=]".</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Internally, two collating elements <ph id="ph1">`elt1`</ph> and <ph id="ph2">`elt2`</ph> are equivalent if <ph id="ph3">`traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>File Format Escape</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>A file format escape consists of the usual C language character escape sequences, "<ph id="ph1">\\\\</ph>", "\a", "\b", "\f", "\n", "\r", "\t", "\v".These have the usual meanings, that is, backslash, alert, backspace, form feed, newline, carriage return, horizontal tab, and vertical tab, respectively.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, "\a" and "\b" are not allowed.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>("<ph id="ph1">\\\\</ph>" is allowed, but it is an identity escape, not a file format escape).</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Hexadecimal Escape Sequence</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>A hexadecimal escape sequence is a backslash followed by the letter 'x' followed by two hexadecimal digits (0-9a-fA-F).</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>It matches a character in the target sequence that has the value that is specified by the two digits.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>For example, "\x41" matches the target sequence "A" when ASCII character encoding is used.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Identity Escape</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>An identity escape is a backslash followed by a single character.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>It matches that character.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>It is required when the character has a special meaning; by using the identity escape, the special meaning is removed.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>"a*" matches the target sequence "aaa", but does not match the target sequence "a<ph id="ph1">\*</ph>".</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>"a<ph id="ph1">\\</ph>*" does not match the target sequence "aaa", but matches the target sequence "a<ph id="ph2">\*</ph>".</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The set of characters that are allowed in an identity escape depends on the regular expression grammar, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Grammar</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Allowed Identity Escape Characters</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>,</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>{ '(', ')', '{', '}', '.', '[', '<ph id="ph1">\\</ph>', '*', '^', '$' }</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>,</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>{ '(', ')', '{', '.', '[', '<ph id="ph1">\\</ph>', '*', '^', '$', '+', '', '&amp;#124;' }</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>plus { '"', '/' }</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>All characters except those that can be part of an identifier.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Typically, this includes letters, digits, '$', '_', and unicode escape sequences.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>For more information, see the ECMAScript Language Specification.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Individual Character</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>An individual character in a bracket expression adds that character to the character set that is defined by the bracket expression.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Anywhere in a bracket expression except at the beginning, a '^' represents itself.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>"[abc]" matches the target sequences "a", "b", and "c", but not the sequence "d".</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>"[^abc]" matches the target sequence "d", but not the target sequences "a", "b", or "c".</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>"[a^bc]" matches the target sequences "a", "b", "c", and "^", but not the target sequence "d".</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>In all regular expression grammars except <ph id="ph1">`ECMAScript`</ph>, if a ']' is the first character that follows the opening '[' or is the first character that follows an initial '^', it represents itself.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>"[]a" is invalid because there is no ']' to end the bracket expression.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>"[]abc]" matches the target sequences "a", "b", "c", and "]", but not the target sequence "d".</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>"[^]abc]" matches the target sequence "d", but not the target sequences "a", "b", "c", or "]".</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, use '<ph id="ph2">\\</ph>]' to represent the character ']' in a bracket expression.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>"[]a" matches the target sequence "a" because the bracket expression is empty.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>"[<ph id="ph1">\\</ph>]abc]" matches the target sequences "a", "b", "c", and "]" but not the target sequence "d".</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Negative Assert</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>A negative assert matches anything but its contents.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>It does not consume any characters in the target sequence.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>For example, "(!aa)(a*)" matches the target sequence "a" and associates capture group 1 with the subsequence "a".</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>It does not match the target sequence "aa" or the target sequence "aaa".</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Negative Word Boundary Assert</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>A negative word boundary assert matches if the current position in the target string is not immediately after a <bpt id="p1">*</bpt>word boundary<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Non-capture Group</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>A non-capture group marks its contents as a single unit in the regular expression grammar, but does not label the target text.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>For example, "(a)(:b)*(c) matches the target text "abbc" and associates capture group 1 with the subsequence "a" and capture group 2 with the subsequence "c".</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Non-greedy Repetition</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>A non-greedy repetition consumes the shortest subsequence of the target sequence that matches the pattern.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>A greedy repetition consumes the longest.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>For example, "(a+)(a*b)" matches the target sequence "aaab".</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>When a non-greedy repetition is used, it associates capture group 1 with the subsequence "a" at the beginning of the target sequence and capture group 2 with the subsequence "aab" at the end of the target sequence.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>When a greedy match is used, it associates capture group 1 with the subsequence "aaa" and capture group 2 with the subsequence "b".</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Octal Escape Sequence</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>An octal escape sequence is a backslash followed by one, two, or three octal digits (0-7).</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>It matches a character in the target sequence that has the value that is specified by those digits.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>If all the digits are '0', the sequence is invalid.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For example, "\101" matches the target sequence "A" when ASCII character encoding is used.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Ordinary Character</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>An ordinary character is any valid character that does not have a special meaning in the current grammar.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ECMAScript`</ph>, the following characters have special meanings:</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>^  $  \  .</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>*  +    (  )  [  ]  {  }  &amp;#124;</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, the following characters have special meanings:</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>[   \</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Also in <ph id="ph1">`BRE`</ph> and <ph id="ph2">`grep`</ph>, the following characters have special meanings when they are used in a particular context:</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>'*' has a special meaning in all cases except when it is the first character in a regular expression or the first character that follows an initial '^' in a regular expression, or when it is the first character of a capture group or the first character that follows an initial '^' in a capture group.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>'^' has a special meaning when it is the first character of a regular expression.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>'$' has a special meaning when it is the last character of a regular expression.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`ERE`</ph>, <ph id="ph2">`egrep`</ph>, and <ph id="ph3">`awk`</ph>, the following characters have special meanings:</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>[   \   (   *   +      {   &amp;#124;</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Also in <ph id="ph1">`ERE`</ph>, <ph id="ph2">`egrep`</ph>, and <ph id="ph3">`awk`</ph>, the following characters have special meanings when they are used in a particular context.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>')' has a special meaning when it matches a preceding '('.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>'^' has a special meaning when it is the first character of a regular expression.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>'$' has a special meaning when it is the last character of a regular expression.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An ordinary character matches the same character in the target sequence.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>By default, this means that the match succeeds if the two characters are represented by the same value.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>In a case-insensitive match, two characters <ph id="ph1">`ch0`</ph> and <ph id="ph2">`ch1`</ph> match if <ph id="ph3">`traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>In a locale-sensitive match, two characters <ph id="ph1">`ch0`</ph> and <ph id="ph2">`ch1`</ph> match if <ph id="ph3">`traits.translate(ch0) == traits.translate(ch1)`</ph>.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Positive Assert</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>A positive assert matches its contents, but does not consume any characters in the target sequence.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>"(=aa)(a*)" matches the target sequence "aaaa" and associates capture group 1 with the subsequence "aaaa".</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>"(aa)(a*)" matches the target sequence "aaaa" and associates capture group 1 with the subsequence "aa" at the beginning of the target sequence and capture group 2 with the subsequence "aa" at the end of the target sequence.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>"(=aa)(a)&amp;#124;(a)" matches the target sequence "a" and associates capture group 1 with an empty sequence (because the positive assert failed) and capture group 2 with the subsequence "a".</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>It also matches the target sequence "aa" and associates capture group 1 with the subsequence "aa" and capture group 2 with an empty sequence.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Unicode Escape Sequence</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>A unicode escape sequence is a backslash followed by the letter 'u' followed by four hexadecimal digits (0-9a-fA-F).</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>It matches a character in the target sequence that has the value that is specified by the four digits.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>For example, "\u0041" matches the target sequence "A" when ASCII character encoding is used.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Wildcard Character</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>A wildcard character matches any character in the target expression except a newline.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Word Boundary</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>A word boundary occurs in the following situations:</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The current character is at the beginning of the target sequence and is one of the word characters</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The current character position is past the end of the target sequence and the last character in the target sequence is one of the word characters.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The current character is one of the word characters and the preceding character is not.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The current character is not one of the word characters and the preceding character is.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Word Boundary Assert</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>A word boundary assert matches when the current position in the target string is immediately after a <bpt id="p1">*</bpt>word boundary<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Matching and Searching</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>For a regular expression to match a target sequence, the entire regular expression must match the entire target sequence.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>For example, the regular expression "bcd" matches the target sequence "bcd" but does not match the target sequence "abcd" nor the target sequence "bcde".</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>For a regular expression search to succeed, there must be a subsequence somewhere in the target sequence that matches the regular expression.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The search typically finds the left-most matching subsequence.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Examples:</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>A search for the regular expression "bcd" in the target sequence "bcd" succeeds and matches the entire sequence.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The same search in the target sequence "abcd" also succeeds and matches the last three characters.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The same search in the target sequence "bcde" also succeeds and matches the first three characters.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>A search for the regular expression "bcd" in the target sequence "bcdbcd" succeeds and matches the first three characters.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>If there is more than one subsequence that matches at some location in the target sequence, there are two ways to choose the matching pattern.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>First match<ept id="p1">*</ept> chooses the subsequence that was found first when the regular expression is matched.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Longest match<ept id="p1">*</ept> chooses the longest subsequence from the ones that match at that location.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>If there is more than one subsequence that has the maximal length, longest match chooses the one that was found first.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>For example, when first match is used, a search for the regular expression "b&amp;#124;bc" in the target sequence "abcd" matches the subsequence "b" because the left-hand term of the alternation matches that subsequence; therefore, first match does not try the right-hand term of the alternation.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>When longest match is used, the same search matches "bc" because "bc" is longer than "b".</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>A partial match succeeds if the match reaches the end of the target sequence without failing, even if it has not reached the end of the regular expression.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Therefore, after a partial match succeeds, appending characters to the target sequence could cause a later partial match to fail.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>However, after a partial match fails, appending characters to the target sequence cannot cause a later partial match to succeed.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>For example, with a partial match, "ab" matches the target sequence "a" but not "ac".</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>Format Flags</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>ECMAScript Format Rules</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>sed Format Rules</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Replacement Text</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>"$&amp;"</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>"&amp;"</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The character sequence that matches the entire regular expression (<ph id="ph1">`[match[0].first, match[0].second)`</ph>)</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>"$$"</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>"$"</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>"<ph id="ph1">\\</ph>&amp;"</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>"&amp;"</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>"$`" (dollar sign followed by back quote)</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>The character sequence that precedes the subsequence that matches the regular expression (<ph id="ph1">`[match.prefix().first, match.prefix().second)`</ph>)</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>"$'" (dollar sign followed by forward quote)</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The character sequence that follows the subsequence that matches the regular expression (<ph id="ph1">`[match.suffix().first, match.suffix().second)`</ph>)</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>"$n"</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>"\n"</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The character sequence that matches the capture group at position <ph id="ph1">`n`</ph>, where <ph id="ph2">`n`</ph> is a number between 0 and 9 (</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>"<ph id="ph1">\\</ph>\n"</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>"\n"</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>"$nn"</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The character sequence that matches the capture group at position <ph id="ph1">`nn`</ph>, where <ph id="ph2">`nn`</ph> is a number between 10 and 99 (</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>STL Overview</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>