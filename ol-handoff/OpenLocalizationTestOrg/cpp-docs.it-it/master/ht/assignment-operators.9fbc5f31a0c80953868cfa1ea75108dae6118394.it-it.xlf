<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1eaab94bd2073c516a6e056b35dd083f3c39d361</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\assignment-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0b36ff1ceb9f5970618cc09c7eb6f20e2ccc1c73</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64754dae1fd945a2bc1cae4dfe02db08cb0adb19</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Assignment Operators | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Assignment operators store a value in the object designated by the left operand.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>There are two kinds of assignment operations: simple assignment, in which the value of the second operand is stored in the object specified by the first operand, and compound assignment, in which an arithmetic, shift, or bitwise operation is performed prior to storing the result.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>All assignment operators in the following table except the = operator are compound assignment operators.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Store the value of the second operand in the object specified by the first operand (simple assignment).</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Multiply the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Divide the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Take modulus of the first operand specified by the value of the second operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Add the value of the second operand to the value of the first operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>–=</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Subtract the value of the second operand from the value of the first operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Shift the value of the first operand left the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Shift the value of the first operand right the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Obtain the bitwise AND of the first and second operands; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Obtain the bitwise exclusive OR of the first and second operands; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Obtain the bitwise inclusive OR of the first and second operands; store the result in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Operator Keywords</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Three of the compound assignment operators have text equivalents.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>They are:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>There are two ways to access these operator keywords in your programs: include the header file <ph id="ph1">`iso646.h`</ph>, or compile with the <bpt id="p1">[</bpt>/Za<ept id="p1">](../build/reference/za-ze-disable-language-extensions.md)</ept> (Disable language extensions) compiler option.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Simple assignment</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The simple assignment operator (=) causes the value of the second operand to be stored in the object specified by the first operand.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If both objects are of arithmetic types, the right operand is converted to the type of the left, prior to storing the value.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Objects of const and volatile types can be assigned to l-values of types that are just volatile or that are neither const nor volatile.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Assignment to objects of class type (struct, union, and class types) is performed by a function named operator=.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The default behavior of this operator function is to perform a bitwise copy; however, this behavior can be modified using overloaded operators.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Overloaded Operators<ept id="p1">](../cpp/operator-overloading.md)</ept> for more information.)</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>An object of any unambiguously derived class from a given base class can be assigned to an object of the base class.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The reverse is not true because there is an implicit conversion from derived class to base class but not from base class to derived class.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Assignments to reference types behave as if the assignment were being made to the object to which the reference points.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For class-type objects, assignment is different from initialization.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To illustrate how different assignment and initialization can be, consider the code</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The preceding code shows an initializer; it calls the constructor for <ph id="ph1">`UserType2`</ph> that takes an argument of type <ph id="ph2">`UserType1`</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Given the code</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>the assignment statement</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>can have one of the following effects:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Call the function operator= for <ph id="ph1">`UserType2`</ph>, provided operator= is provided with a <ph id="ph2">`UserType1`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Call the explicit conversion function <ph id="ph1">`UserType1::operator UserType2`</ph>, if such a function exists.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Call a constructor <ph id="ph1">`UserType2::UserType2`</ph>, provided such a constructor exists, that takes a <ph id="ph2">`UserType1`</ph> argument and copies the result.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The compound assignment operators, shown in the table in <bpt id="p1">[</bpt>Assignment Operators<ept id="p1">](../cpp/assignment-operators.md)</ept>, are specified in the form <bpt id="p2">*</bpt>e1<ept id="p2">*</ept> <ph id="ph1">`op`= </ph><bpt id="p3">*</bpt>e2<ept id="p3">*</ept>, where <bpt id="p4">*</bpt>e1<ept id="p4">*</ept> is a modifiable l-value not of const type and <bpt id="p5">*</bpt>e2<ept id="p5">*</ept> is one of the following:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>An arithmetic type</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A pointer, if <ph id="ph1">`op`</ph> is + or –</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>e1<ept id="p1">*</ept> <ph id="ph1">`op`= </ph><bpt id="p2">*</bpt>e2<ept id="p2">*</ept> form behaves as <bpt id="p3">*</bpt>e1<ept id="p3">*</ept> <bpt id="p4">*</bpt>= e1<ept id="p4">*</ept> <ph id="ph2">`op`</ph> <bpt id="p5">*</bpt>e2<ept id="p5">*</ept>, but <bpt id="p6">*</bpt>e1<ept id="p6">*</ept> is evaluated only once.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Compound assignment to an enumerated type generates an error message.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the left operand is of a pointer type, the right operand must be of a pointer type or it must be a constant expression that evaluates to 0.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the left operand is of an integral type, the right operand must not be of a pointer type.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Result of assignment operators</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The assignment operators return the value of the object specified by the left operand after the assignment.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The resultant type is the type of the left operand.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The result of an assignment expression is always an l-value.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>These operators have right-to-left associativity.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The left operand must be a modifiable l-value.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In ANSI C, the result of an assignment expression is not an l-value.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Therefore, the legal C++ expression <ph id="ph1">`(a += b) += c`</ph> is illegal in C.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Expressions with Binary Operators</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>C++ Built-in Operators, Precedence and Associativity</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>C Assignment Operators</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>