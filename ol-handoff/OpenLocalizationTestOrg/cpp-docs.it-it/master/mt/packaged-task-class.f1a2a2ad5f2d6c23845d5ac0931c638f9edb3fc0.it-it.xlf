<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">972b644092d17a7691b4cc90c3a4d0159a54b9fb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\packaged-task-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8a600eaa49866a9a65b310656edf98386b1680b8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8742740655e505bfab94edc760a14d16d45ed21b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>packaged_task Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>packaged_task Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Describes an <bpt id="p1">*</bpt>asynchronous provider<ept id="p1">*</ept> that is a call wrapper whose call signature is <ph id="ph1">`Ty(ArgTypes...)`</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Its <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept> holds a copy of its callable object in addition to the potential result.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::packaged_task Constructor<ept id="p1">](#packaged_task__packaged_task_constructor)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::~packaged_task Destructor<ept id="p1">](#packaged_task___dtorpackaged_task_destructor)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Destroys a <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::get_future<ept id="p1">](#packaged_task__get_future_method)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">[</bpt>future<ept id="p1">](../standard-library/future-class.md)</ept> object that has the same associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::make_ready_at_thread_exit<ept id="p1">](#packaged_task__make_ready_at_thread_exit_method)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Calls the callable object that's stored in the associated asynchronous state and atomically stores the returned value.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::reset<ept id="p1">](#packaged_task__reset_method)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Replaces the associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::swap<ept id="p1">](#packaged_task__swap_method)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Exchanges the associated asynchronous state with that of a specified object.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::valid<ept id="p1">](#packaged_task__valid_method)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Specifies whether the object has an associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Public Operators</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::operator=<ept id="p1">](#packaged_task__operator_eq)</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Transfers an associated asynchronous state from a specified object.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::operator()<ept id="p1">](#packaged_task__operator__)</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Calls the callable object that's stored in the associated asynchronous state, atomically stores the returned value, and sets the state to <bpt id="p1">*</bpt>ready<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>packaged_task::operator bool<ept id="p1">](#packaged_task__operator_bool)</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Specifies whether the object has an associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> future</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> std</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__get_future_method"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::get_future</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Returns an object of type <ph id="ph1">`future&lt;Ty&gt;`</ph> that has the same <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`packaged_task`</ph> object does not have an associated asynchronous state, this method throws a <bpt id="p1">[</bpt>future_error<ept id="p1">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id="ph2">`no_state`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If this method has already been called for a <ph id="ph1">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id="ph2">`future_error`</ph> that has an error code of <ph id="ph3">`future_already_retrieved`</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__make_ready_at_thread_exit_method"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::make_ready_at_thread_exit</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Calls the callable object that's stored in the <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept> and atomically stores the returned value.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`packaged_task`</ph> object doesn't have an associated asynchronous state, this method throws a <bpt id="p1">[</bpt>future_error<ept id="p1">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id="ph2">`no_state`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If this method or <bpt id="p1">[</bpt>make_ready_at_thread_exit<ept id="p1">](#packaged_task__make_ready_at_thread_exit_method)</ept> has already been called for a <ph id="ph1">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id="ph2">`future_error`</ph> that has an error code of <ph id="ph3">`promise_already_satisfied`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Otherwise, this operator calls <ph id="ph1">`INVOKE(fn, args..., Ty)`</ph>, where <bpt id="p1">*</bpt>fn<ept id="p1">*</ept> is the callable object that's stored in the associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Any returned value is stored atomically as the returned result of the associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In contrast to <bpt id="p1">[</bpt>packaged_task::operator()<ept id="p1">](#packaged_task__operator__)</ept>, the associated asynchronous state is not set to <ph id="ph1">`ready`</ph> until after all thread-local objects in the calling thread have been destroyed.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Typically, threads that are blocked on the associated asynchronous state are not unblocked until the calling thread exits.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__operator_eq"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::operator=</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Transfers the <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept> from a specified object.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>After the operation, <ph id="ph1">`Right`</ph> no longer has an associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__operator__"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::operator()</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Calls the callable object that's stored in the <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept>, atomically stores the returned value, and sets the state to <bpt id="p2">*</bpt>ready<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`packaged_task`</ph> object doesn't have an associated asynchronous state, this method throws a <bpt id="p1">[</bpt>future_error<ept id="p1">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id="ph2">`no_state`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If this method or <bpt id="p1">[</bpt>make_ready_at_thread_exit<ept id="p1">](#packaged_task__make_ready_at_thread_exit_method)</ept> has already been called for a <ph id="ph1">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id="ph2">`future_error`</ph> that has an error code of <ph id="ph3">`promise_already_satisfied`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Otherwise, this operator calls <ph id="ph1">`INVOKE(fn, args..., Ty)`</ph>, where <bpt id="p1">*</bpt>fn<ept id="p1">*</ept> is the callable object that's stored in the associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Any returned value is stored atomically as the returned result of the associated asynchronous state, and the state is set to ready.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>As a result, any threads that are blocked on the associated asynchronous state become unblocked.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__operator_bool"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::operator bool</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Specifies whether the object has an <ph id="ph1">`associated asynchronous state`</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the object has an associated asynchronous state; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__packaged_task_constructor"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::packaged_task Constructor</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A memory allocator.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>allocators&gt;<ept id="p1">](../standard-library/allocators-header.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A function object.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The first constructor constructs a <ph id="ph1">`packaged_task`</ph> object that has no <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The second constructor constructs a <ph id="ph1">`packaged_task`</ph> object and transfers the associated asynchronous state from <ph id="ph2">`Right`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>After the operation, <ph id="ph1">`Right`</ph> no longer has an associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The third constructor constructs a <ph id="ph1">`packaged_task`</ph> object that has a copy of <ph id="ph2">`fn`</ph> stored in its associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The fourth constructor constructs a <ph id="ph1">`packaged_task`</ph> object that has a copy of <ph id="ph2">`fn`</ph> stored in its associated asynchronous state, and uses <ph id="ph3">`alloc`</ph> for memory allocation.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task___dtorpackaged_task_destructor"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::~packaged_task Destructor</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Destroys a <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept> is not <bpt id="p2">*</bpt>ready<ept id="p2">*</ept>, the destructor stores a <bpt id="p3">[</bpt>future_error<ept id="p3">](../standard-library/future-error-class.md)</ept> exception that has an error code of <ph id="ph1">`broken_promise`</ph> as the result in the associated asynchronous state, and any threads that are blocked on the associated asynchronous state become unblocked.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__reset_method"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::reset</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Uses a new <bpt id="p1">*</bpt>associated asynchronous state<ept id="p1">*</ept> to replace the existing associated asynchronous state.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In effect, this method executes <ph id="ph1">`*this = packaged_task(move(fn))`</ph>, where <bpt id="p1">*</bpt>fn<ept id="p1">*</ept> is the function object that's stored in the associated asynchronous state for this object.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Therefore, the state of the object is cleared, and <bpt id="p1">[</bpt>get_future<ept id="p1">](#packaged_task__get_future_method)</ept>, <bpt id="p2">[</bpt>operator()<ept id="p2">](#packaged_task__operator__)</ept>, and <bpt id="p3">[</bpt>make_ready_at_thread_exit<ept id="p3">](#packaged_task__make_ready_at_thread_exit_method)</ept> can be called as if on a newly-constructed object.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__swap_method"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::swap</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Exchanges the associated asynchronous state with that of a specified object.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`packaged_task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="packaged_task__valid_method"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  packaged_task::valid</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Specifies whether the object has an <ph id="ph1">`associated asynchronous state`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the object has an associated asynchronous state; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Header Files Reference<ept id="p1">](../standard-library/cpp-standard-library-header-files.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt><ph id="ph1">\&lt;</ph>future&gt;<ept id="p1">](../standard-library/future.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>