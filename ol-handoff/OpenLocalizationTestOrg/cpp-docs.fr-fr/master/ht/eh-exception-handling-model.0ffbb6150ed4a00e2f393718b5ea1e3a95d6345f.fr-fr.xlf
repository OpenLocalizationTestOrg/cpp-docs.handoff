<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b8bde971e5dc6a5b066a1b25ed8f9492825a0626</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\build\reference\eh-exception-handling-model.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d1a6789ce1b88c8097df43d53ba16bd7ae8ff1ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2146327457ec0824cfb67cb097b7be5f0386d21</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>-EH (Exception Handling Model) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>/EH (Exception Handling Model)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Specifies the kind of exception handling used by the compiler, when to optimize away exception checks, and whether to destroy C++ objects that go out of scope because of an exception.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>/EH<ept id="p1">**</ept> is not specified, the compiler catches both asynchronous structured exceptions and C++ exceptions, but does not destroy C++ objects that go out of scope because of an asynchronous exception.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Arguments</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>a</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The exception-handling model that catches both asynchronous (structured) and synchronous (C++) exceptions.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>s</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The exception-handling model that catches C++ exceptions only and tells the compiler to assume that functions declared as <ph id="ph1">`extern "C"`</ph> may throw an exception.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>c</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If used with <bpt id="p1">**</bpt>s<ept id="p1">**</ept> (<bpt id="p2">**</bpt>/EHsc<ept id="p2">**</ept>), catches C++ exceptions only and tells the compiler to assume that functions declared as <ph id="ph1">`extern "C"`</ph> never throw a C++ exception.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>/EHca<ept id="p1">**</ept> is equivalent to <bpt id="p2">**</bpt>/EHa<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>r</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Tells the compiler to always generate runtime termination checks for all <ph id="ph1">`noexcept`</ph> functions.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By default, runtime checks for <ph id="ph1">`noexcept`</ph> may be optimized away if the compiler determines the function calls only non-throwing functions.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept> compiler option is used to support asynchronous structured exception handling (SEH) with the native C++ <ph id="ph1">`catch(...)`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To implement SEH without specifying <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept>, you may use the <ph id="ph1">`__try`</ph>, <ph id="ph2">`__except`</ph>, and <ph id="ph3">`__finally`</ph> syntax.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Although Windows and Visual C++ support SEH, we strongly recommend that you use ISO-standard C++ exception handling (<bpt id="p1">**</bpt>/EHs<ept id="p1">**</ept> or <bpt id="p2">**</bpt>/EHsc<ept id="p2">**</ept>) because it makes code more portable and flexible.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Nevertheless, in existing code or for particular kinds of programs—for example, in code compiled to support the common language runtime (<bpt id="p1">[</bpt>/clr (Common Language Runtime Compilation)<ept id="p1">](../../build/reference/clr-common-language-runtime-compilation.md)</ept>)—you still might have to use SEH.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Structured Exception Handling (C/C++)<ept id="p1">](../../cpp/structured-exception-handling-c-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Specifying <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept> and trying to handle all exceptions by using <ph id="ph1">`catch(...)`</ph> can be dangerous.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In most cases, asynchronous exceptions are unrecoverable and should be considered fatal.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Catching them and proceeding can cause process corruption and lead to bugs that are hard to find and fix.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>/EHs<ept id="p1">**</ept> or <bpt id="p2">**</bpt>/EHsc<ept id="p2">**</ept>, then your <ph id="ph1">`catch(...)`</ph> clause does not catch asynchronous structured exceptions.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Access violations and managed &lt;xref:System.Exception?displayProperty=fullName&gt; exceptions are not caught, and objects in scope when an asynchronous exception is generated are not destroyed even if the asynchronous exception is handled.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept>, the image may be larger and might perform less well because the compiler does not optimize a <ph id="ph1">`try`</ph> block as aggressively.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It also leaves in exception filters that automatically call the destructors of all local objects even if the compiler does not see any code that can throw a C++ exception.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This enables safe stack unwinding for asynchronous exceptions as well as for C++ exceptions.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When you use <bpt id="p1">**</bpt>/EHs<ept id="p1">**</ept>, the compiler assumes that exceptions can only occur at a <ph id="ph1">`throw`</ph> statement or at a function call.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This allows the compiler to eliminate code for tracking the lifetime of many unwindable objects, and this can significantly reduce code size.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>We recommend that you not link objects compiled by using <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept> together with objects compiled by using <bpt id="p2">**</bpt>/EHs<ept id="p2">**</ept> in the same executable module.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you have to handle an asynchronous exception by using <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept> anywhere in your module, use <bpt id="p2">**</bpt>/EHa<ept id="p2">**</ept> to compile all the code in the module.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can use structured exception handling syntax in the same module as code that's compiled by using <bpt id="p1">**</bpt>/EHs<ept id="p1">**</ept>, but you can’t mix the SEH syntax with <ph id="ph1">`try`</ph>, <ph id="ph2">`throw`</ph>, and <ph id="ph3">`catch`</ph> in the same function.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">**</bpt>/EHa<ept id="p1">**</ept> if you want to catch an exception that's raised by something other than a <ph id="ph1">`throw`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This example generates and catches a structured exception:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/EHc<ept id="p1">**</ept> option requires that <bpt id="p2">**</bpt>/EHs<ept id="p2">**</ept> or <bpt id="p3">**</bpt>/EHa<ept id="p3">**</ept> is specified.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> option implies <bpt id="p2">**</bpt>/EHa<ept id="p2">**</ept> (that is, <bpt id="p3">**</bpt>/clr /EHa<ept id="p3">**</ept> is redundant).</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The compiler generates an error if <bpt id="p1">**</bpt>/EHs[c]<ept id="p1">**</ept> is used after <bpt id="p2">**</bpt>/clr<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Optimizations do not affect this behavior.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When an exception is caught, the compiler invokes the class destructor or destructors for the object or objects that are in the same scope as the exception.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When an exception is not caught, those destructors are not run.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For information about exception handling restrictions under <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept>, see <bpt id="p2">[</bpt>_set_se_translator<ept id="p2">](../../c-runtime-library/reference/set-se-translator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The option can be cleared by using the symbol <bpt id="p1">**</bpt><ph id="ph1">-</ph><ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>/EHsc-<ept id="p1">**</ept> is interpreted as <bpt id="p2">**</bpt>/EHs /EHc-<ept id="p2">**</ept> and is equivalent to <bpt id="p3">**</bpt>/EHs<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/EHr<ept id="p1">**</ept> compiler option forces runtime termination checks in all functions that have a <ph id="ph1">`noexcept`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>By default, runtime checks may be optimized away if the compiler back end determines that a function only calls <bpt id="p1">*</bpt>non-throwing<ept id="p1">*</ept> functions.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Non-throwing functions are any functions that have an attribute that specifies no exceptions may be thrown.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This includes functions marked <ph id="ph1">`noexcept`</ph>, <ph id="ph2">`throw()`</ph>, <ph id="ph3">`__declspec(nothrow)`</ph>, and, when <bpt id="p1">**</bpt>/EHc<ept id="p1">**</ept> is specified, <ph id="ph4">`extern "C"`</ph> functions.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Non-throwing functions also include any that the compiler has determined are non-throwing by inspection.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can explicitly set the default by using <bpt id="p1">**</bpt>/EHr-<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>However, the non-throwing attribute is not a guarantee that no exceptions can be thrown by a function.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Unlike the behavior of a <ph id="ph1">`noexcept`</ph> function, the Visual C++ compiler considers an exception thrown by a function declared using <ph id="ph2">`throw()`</ph>, <ph id="ph3">`__declspec(nothrow)`</ph>, or <ph id="ph4">`extern "C"`</ph> as undefined behavior.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Functions that use these three declaration attributes do not enforce runtime termination checks for exceptions.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>/EHr<ept id="p1">**</ept> option to help you identify this undefined behavior, by forcing the compiler to generate runtime checks for unhandled exceptions that escape a <ph id="ph1">`noexcept`</ph> function.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To set this compiler option in the Visual Studio development environment</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Open the project's <bpt id="p1">**</bpt>Property Pages<ept id="p1">**</ept> dialog box.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Working with Project Properties<ept id="p1">](../../ide/working-with-project-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In the left pane, expand <bpt id="p1">**</bpt>Configuration Properties<ept id="p1">**</ept>, <bpt id="p2">**</bpt>C/C++<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Code Generation<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Modify the <bpt id="p1">**</bpt>Enable C++ Exceptions<ept id="p1">**</ept> property.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Or, set <bpt id="p1">**</bpt>Enable C++ Exceptions<ept id="p1">**</ept> to <bpt id="p2">**</bpt>No<ept id="p2">**</ept>, and then on the <bpt id="p3">**</bpt>Command Line<ept id="p3">**</ept> property page, in the <bpt id="p4">**</bpt>Additional Options<ept id="p4">**</ept> box, add the compiler option.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>To set this compiler option programmatically</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>See &lt;xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A&gt;.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Setting Compiler Options</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Errors and Exception Handling</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Exception Specifications (throw)</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Structured Exception Handling (C/C++)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>