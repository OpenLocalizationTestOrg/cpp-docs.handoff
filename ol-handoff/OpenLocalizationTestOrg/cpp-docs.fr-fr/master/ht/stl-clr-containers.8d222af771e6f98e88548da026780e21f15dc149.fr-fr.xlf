<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c5685051917ac873d8f31c26a9a6fb7aa9ca542f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\stl-clr-containers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4024557be761d81dcc04007207ea935c9eab5164</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d17d53f3846ac2dd953d3df8229015439f49047</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>STL-CLR Containers | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>STL/CLR Containers</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The STL/CLR Library has the same containers that are found in the Standard C++ Library, but it runs within the managed environment of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you are already familiar with the Standard Template Library (STL), STL/CLR is the best way to continue to use the skills that you have already developed while upgrading your code to target the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This document provides an overview of the containers in STL/CLR, such as the requirements for container elements, the types of elements that you can insert into the containers, and ownership issues with the elements in the containers.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Where appropriate, differences between the native Standard Template Library and STL/CLR are mentioned.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Requirements for Container Elements</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>All elements inserted into STL containers must obey certain guidelines.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Requirements for STL/CLR Container Elements<ept id="p1">](../dotnet/requirements-for-stl-clr-container-elements.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Valid Container Elements</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>STL/CLR containers can hold one of two types of elements:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Handles to reference types.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Reference types.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Unboxed value types.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You cannot insert boxed value types into any of the STL/CLR containers.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Handles to Reference Types</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can insert a handle to a reference type into an STL/CLR container.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A handle in C++ that targets the CLR is analogous to a pointer in native C++.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Handle to Object Operator (^)<ept id="p1">](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following example shows how to insert a handle to an Employee object into a <bpt id="p1">[</bpt>cliext::set<ept id="p1">](../dotnet/set-stl-clr.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Reference Types</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It is also possible to insert a reference type (rather than a handle to a reference type) into a STL/CLR container.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The main difference here is that when a container of reference types is deleted, the destructor is called for all elements inside that container.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In a container of handles to reference types, the destructors for these elements would not be called.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example shows how to insert an Employee object into a <ph id="ph1">`cliext::set`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Unboxed Value Types</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can also insert an unboxed value type into an STL/CLR container.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>An unboxed value type is a value type that has not been <bpt id="p1">*</bpt>boxed<ept id="p1">*</ept> into a reference type.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A value type element can be one of the standard value types, such as an <ph id="ph1">`int`</ph>, or it can be a user-defined value type, such as a <ph id="ph2">`value class`</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Classes and Structs<ept id="p1">](../windows/classes-and-structs-cpp-component-extensions.md)</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following example modifies the first example by making the Employee class a value type.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This value type is then inserted into a <ph id="ph1">`cliext::set`</ph> just as in the first example.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If you attempt to insert a handle to a value type into a container, <bpt id="p1">[</bpt>Compiler Error C3225<ept id="p1">](../error-messages/compiler-errors-2/compiler-error-c3225.md)</ept> is generated.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Performance and Memory Implications</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You must consider several factors when determining whether to use handles to reference types or value types as container elements.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you decide to use value types, remember that a copy of the element is made every time an element is inserted into the container.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For small objects, this should not be a problem, but if the objects being inserted are large, performance might suffer.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also, if you are using value types, it is impossible to store one element in multiple containers at the same time because each container would have its own copy of the element.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you decide to use handles to reference types instead, performance might increase because it is not necessary to make a copy of the element when it is inserted in the container.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Also, unlike with value types, the same element can exist in multiple containers.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>However, if you decide to use handles, you must take care to ensure that the handle is valid and that the object it refers to has not been deleted elsewhere in the program.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Ownership Issues with Containers</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Containers in STL/CLR work on value semantics.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Every time you insert an element into a container, a copy of that element is inserted.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If you want to get reference-like semantics, you can insert a handle to an object rather than the object itself.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When you call the clear or erase method of a container of handle objects, the objects that the handles refer to are not freed from memory.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You must either explicitly delete the object, or, because these objects reside on the managed heap, allow the garbage collector to free the memory once it determines that the object is no longer being used.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>C++ Standard Library Reference</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>