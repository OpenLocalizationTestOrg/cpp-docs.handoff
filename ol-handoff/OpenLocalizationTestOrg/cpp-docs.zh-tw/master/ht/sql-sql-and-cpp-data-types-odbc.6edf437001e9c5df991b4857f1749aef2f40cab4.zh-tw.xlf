<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25656ddc0d61a826db100c4f470d478832ac4483</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\data\odbc\sql-sql-and-cpp-data-types-odbc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b0f30ab892dfd746013fc52df31a16b894ec02a4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bf4c6da24d9d482669de37e235d9fbdea2b6933b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>SQL: SQL and C++ Data Types (ODBC) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>SQL: SQL and C++ Data Types (ODBC)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This information applies to the MFC ODBC classes.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you are working with the MFC DAO classes, see the topic "Comparison of Microsoft Jet Database Engine SQL and ANSI SQL" in DAO Help.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following table maps ANSI SQL data types to C++ data types.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This augments the C language information given in Appendix D of the <bpt id="p1">*</bpt>ODBC SDK<ept id="p1">*</ept> <bpt id="p2">*</bpt>Programmer's Reference<ept id="p2">*</ept> on the MSDN Library CD.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The wizards manage most data type mapping for you.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you do not use a wizard, you can use the mapping information to help you write the field exchange code manually.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>ANSI SQL Data Types Mapped to C++ Data Types</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>ANSI SQL data type</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>C++ data type</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>CHAR</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>DECIMAL</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>SMALLINT</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>float</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>long</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>double</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>double</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>VARCHAR</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>LONGVARCHAR</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`CString`</ph> 2</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>BIT</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>BOOL</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>BYTE</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>BINARY</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>VARBINARY</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>LONGVARBINARY</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`CByteArray`</ph> 3</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>DATE</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>,</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>TIME</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>CTime, CString</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>TIMESTAMP</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>CTime, CString</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>ANSI <bpt id="p1">**</bpt>DECIMAL<ept id="p1">**</ept> and <bpt id="p2">**</bpt>NUMERIC<ept id="p2">**</ept> map to <ph id="ph1">`CString`</ph> because <bpt id="p3">**</bpt>SQL_C_CHAR<ept id="p3">**</ept> is the default ODBC transfer type.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Character data beyond 255 characters is truncated by default when mapped to <ph id="ph1">`CString`</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can extend the truncation length by explicitly setting the <ph id="ph1">`nMaxLength`</ph> argument of <ph id="ph2">`RFX_Text`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Binary data beyond 255 characters is truncated by default when mapped to <ph id="ph1">`CByteArray`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can extend the truncation length by explicitly setting the <ph id="ph1">`nMaxLength`</ph> argument of <ph id="ph2">`RFX_Binary`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If you are not using the ODBC cursor library, you might encounter a problem when attempting to update two or more long variable-length fields using the Microsoft SQL Server ODBC driver and the MFC ODBC database classes.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The ODBC types, <bpt id="p1">**</bpt>SQL_LONGVARCHAR<ept id="p1">**</ept> and <bpt id="p2">**</bpt>SQL_LONGVARBINARY<ept id="p2">**</ept>, map to text and image SQL Server types.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CDBException`</ph> is thrown if you update two or more long variable-length fields on the same call to <ph id="ph2">`CRecordset::Update`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Therefore, do not update multiple long columns simultaneously with <ph id="ph1">`CRecordset::Update`</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can update multiple long columns simultaneously with the ODBC API <bpt id="p1">**</bpt>SQLPutData<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can also use the ODBC cursor library, but this is not recommended for drivers, like the SQL Server driver, that support cursors and do not need the cursor library.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you are using the ODBC cursor library with the MFC ODBC database classes and the Microsoft SQL Server ODBC driver, an <bpt id="p1">**</bpt>ASSERT<ept id="p1">**</ept> might occur along with a <ph id="ph1">`CDBException`</ph> if a call to <ph id="ph2">`CRecordset::Update`</ph> follows a call to <ph id="ph3">`CRecordset::Requery`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Instead, call <ph id="ph1">`CRecordset::Close`</ph> and <ph id="ph2">`CRecordset::Open`</ph> rather than <ph id="ph3">`CRecordset::Requery`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Another solution is not to use the ODBC cursor library, because the SQL Server and the SQL Server ODBC driver provide native support for cursors natively and the ODBC cursor library is not needed.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>SQL</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>SQL: Making Direct SQL Calls (ODBC)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>