<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">03f941b9f7e8440384cfcc3b846a0490a6f7784e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\stl-containers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7f7eb4e748f6301620f373099c873fdb7ffff8bd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa04aacd2c70c6f6e932dec35db39eb5e22119a1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>STL Containers | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>STL Containers</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Standard Library provides various type-safe containers for storing collections of related objects.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The containers are class templates; when you declare a container variable, you specify the type of the elements that the container will hold.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Containers can be constructed with initializer lists.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>They have member functions for adding and removing elements and performing other operations.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You iterate over the elements in a container, and access the individual elements by using <bpt id="p1">[</bpt>iterators<ept id="p1">](../standard-library/iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can use iterators explicitly by using their member functions and operators as well as global functions.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can also use them implicitly, for example by using a range-for loop.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Iterators for all STL containers have a common interface but each container defines its own specialized iterators.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Containers can be divided into three categories: sequence containers, associative containers, and container adapters.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Sequence Containers</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Sequence containers maintain the ordering of inserted elements that you specify.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`vector`</ph> container behaves like an array, but can automatically grow as required.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is random access and contiguously stored, and length is highly flexible.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For these reasons and more, <ph id="ph1">`vector`</ph> is the preferred sequence container for most applications.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When in doubt as to what kind of sequence container to use, start by using a vector!</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>vector Class<ept id="p1">](../standard-library/vector-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`array`</ph> container has some of the strengths of <ph id="ph2">`vector`</ph>, but the length is not as flexible.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>array Class<ept id="p1">](../standard-library/array-class-stl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`deque`</ph> (double-ended queue) container allows for fast insertions and deletions at the beginning and end of the container.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It shares the random-access and flexible-length advantages of <ph id="ph1">`vector`</ph>, but is not contiguous.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>deque Class<ept id="p1">](../standard-library/deque-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`list`</ph> container is a doubly linked list that enables bidirectional access, fast insertions, and fast deletions anywhere in the container, but you cannot randomly access an element in the container.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>list Class<ept id="p1">](../standard-library/list-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`forward_list`</ph> container is a singly linked list—the forward-access version of <ph id="ph2">`list`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>forward_list Class<ept id="p1">](../standard-library/forward-list-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Associative Containers</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In associative containers, elements are inserted in a pre-defined order—for example, as sorted ascending.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are also available.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The associative containers can be grouped into two subsets: maps and sets.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`map`</ph>, sometimes referred to as a dictionary, consists of a key/value pair.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The key is used to order the sequence, and the value is associated with that key.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">`map`</ph> might contain keys that represent every unique word in a text and corresponding values that represent the number of times that each word appears in the text.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The unordered version of <ph id="ph1">`map`</ph> is <ph id="ph2">`unordered_map`</ph>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>map Class<ept id="p1">](../standard-library/map-class.md)</ept> and <bpt id="p2">[</bpt>unordered_map Class<ept id="p2">](../standard-library/unordered-map-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`set`</ph> is just an ascending container of unique elements—the value is also the key.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The unordered version of <ph id="ph1">`set`</ph> is <ph id="ph2">`unordered_set`</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>set Class<ept id="p1">](../standard-library/set-class.md)</ept> and <bpt id="p2">[</bpt>unordered_set Class<ept id="p2">](../standard-library/unordered-set-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`map`</ph> and <ph id="ph2">`set`</ph> only allow one instance of a key or element to be inserted into the container.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If multiple instances of elements are required, use <ph id="ph1">`multimap`</ph> or <ph id="ph2">`multiset`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The unordered versions are <ph id="ph1">`unordered_multimap`</ph> and <ph id="ph2">`unordered_multiset`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>multimap Class<ept id="p1">](../standard-library/multimap-class.md)</ept>, <bpt id="p2">[</bpt>unordered_multimap Class<ept id="p2">](../standard-library/unordered-multimap-class.md)</ept>, <bpt id="p3">[</bpt>multiset Class<ept id="p3">](../standard-library/multiset-class.md)</ept>, and <bpt id="p4">[</bpt>unordered_multiset Class<ept id="p4">](../standard-library/unordered-multiset-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Ordered maps and sets support bi-directional iterators, and their unordered counterparts support forward iterators.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Iterators<ept id="p1">](../standard-library/iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Heterogeneous Lookup in Associative Containers (C++14)</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The ordered associative containers (map, multimap, set and multiset) now support heterogeneous lookup, which means that you are no longer required to pass the exact same object type as the key or element in member functions such as <ph id="ph1">`find()`</ph> and <ph id="ph2">`lower_bound()`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Instead, you can pass any type for which an overloaded <ph id="ph1">`operator&lt;`</ph> is defined that enables comparison to the key type.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Heterogenous lookup is enabled on an opt-in basis when you specify the <ph id="ph1">`std::less&lt;&gt;`</ph> or <ph id="ph2">`std::greater&lt;&gt;`</ph> "diamond functor" comparator when declaring the container variable, as shown here:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If you use the default comparator, then the container behaves exactly as it did in C++11 and earlier.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example shows how to overload <ph id="ph1">`operator&lt;`</ph> in order to enable users of a <ph id="ph2">`std::set`</ph> to do lookups simply by passing in a small string that can be compared to each object's <ph id="ph3">`BigObject::id`</ph> member.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following member functions in map, multimap, set and multiset have been overloaded to support heterogeneous lookup:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>find</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>count</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>lower_bound</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>upper_bound</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>equal_range</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Container Adapters</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A container adapter is a variation of a sequence or associative container that restricts the interface for simplicity and clarity.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Container adapters do not support iterators.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`queue`</ph> container follows FIFO (first in, first out) semantics.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The first element <bpt id="p1">*</bpt>pushed<ept id="p1">*</ept>—that is, inserted into the queue—is the first to be <bpt id="p2">*</bpt>popped<ept id="p2">*</ept>—that is, removed from the queue.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>queue Class<ept id="p1">](../standard-library/queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`priority_queue`</ph> container is organized such that the element that has the highest value is always first in the queue.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>priority_queue Class<ept id="p1">](../standard-library/priority-queue-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`stack`</ph> container follows LIFO (last in, first out) semantics.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The last element pushed on the stack is the first element popped.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>stack Class<ept id="p1">](../standard-library/stack-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Because container adapters do not support iterators, they cannot be used with the STL algorithms.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Algorithms<ept id="p1">](../standard-library/algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Requirements for Container Elements</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In general, elements inserted into an STL container can be of just about any object type if they are copyable.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Movable-only elements—for example, those such as <ph id="ph1">`vector&lt;unique_ptr&lt;T&gt;&gt;`</ph> that are created by using <ph id="ph2">`unique_ptr&lt;&gt;`</ph> will work as long as you don't call member functions that attempt to copy them.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The destructor is not permitted to throw an exception.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Ordered associative containers—described earlier in this article—must have a public comparison operator defined.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>(By default, the operator is <ph id="ph1">`operator&lt;`</ph>, but even types that don't work with <ph id="ph2">`operator&lt;`</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Some operations on containers might also require a public default constructor and a public equivalence operator.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, the unordered associative containers require support for equality and hashing.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Accessing Container Elements</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The elements of containers are accessed by using iterators.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Iterators<ept id="p1">](../standard-library/iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can also use <bpt id="p1">[</bpt>range-based for loops<ept id="p1">](../cpp/range-based-for-statement-cpp.md)</ept> to iterate over STL collections.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Comparing containers</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>All containers overload the operator== for comparing two containers of the same type that have the same element type.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can use == to compare a vector<ph id="ph1">\&lt;</ph>string&gt; to another vector<ph id="ph2">\&lt;</ph>string&gt;, but you cannot use it to compare a vector<ph id="ph3">\&lt;</ph>string&gt; to a list<ph id="ph4">\&lt;</ph>string&gt; or a vector<ph id="ph5">\&lt;</ph>string&gt; to a vector<ph id="ph6">\&lt;</ph>char*&gt;.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In C++98/03 you can use <bpt id="p1">[</bpt>std::equal<ept id="p1">](http://msdn.microsoft.com/Library/56533afd-b696-40a0-8fa9-d366539e49ae)</ept> or <bpt id="p2">[</bpt>std::mismatch<ept id="p2">](http://msdn.microsoft.com/Library/a9fe78f3-9a86-44dc-9400-0c2ed1083323)</ept> to compare dissimilar container types and/or element types.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In C++11 you can also use <bpt id="p1">[</bpt>std::is_permutation<ept id="p1">](http://msdn.microsoft.com/Library/3384e786-e210-4648-b2bc-3896b5e14f1f)</ept>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>But in all these cases the functions assume that the containers are the same length.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the second range is shorter than the first, then undefined behavior results.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the second range is longer, results can still be incorrect because the comparison never continues past the end of the first range.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Comparing dissimilar containers (C++14)</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In C++14 and later, you can compare dissimilar containers and/or dissimilar elements types by using one of the <bpt id="p1">[</bpt>std::equal<ept id="p1">](http://msdn.microsoft.com/Library/56533afd-b696-40a0-8fa9-d366539e49ae)</ept>, <bpt id="p2">[</bpt>std::mismatch<ept id="p2">](http://msdn.microsoft.com/Library/a9fe78f3-9a86-44dc-9400-0c2ed1083323)</ept>, or <bpt id="p3">[</bpt>std::is_permutation<ept id="p3">](http://msdn.microsoft.com/Library/3384e786-e210-4648-b2bc-3896b5e14f1f)</ept> function overloads that take two complete ranges.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>These overloads enable you to compare containers with different lengths.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>These overloads are much less susceptible to user error, and are optimized to return false in constant time when containers of dissimilar lengths are compared.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend you use these overloads unless (1) you have a very clear reason not to, or (2) you are using a <bpt id="p1">[</bpt>std::list<ept id="p1">](../standard-library/list-class.md)</ept> container, which does not benefit from the dual-range optimizations.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Containers</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C++ Standard Library Reference</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>sample container&gt;</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Thread Safety in the C++ Standard Library</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>