<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">501eff5223218ddd922d4f30f856f8964990d996</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\build\reference\optimization-best-practices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e3875c8e29337f1eb01fc16f5131cc7df602db46</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae68b4cb4da0258ccb8f832d04bcfaff1b8bc690</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Optimization Best Practices | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Optimization Best Practices</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This document describes some best practices for optimization in Visual C++.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The following topics are discussed:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Compiler and Linker Options</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Profile-Guided Optimization</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Which Level of Optimization Should I Use?</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Floating Point Switches</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Optimization Declspecs</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Optimization Pragmas</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>__restrict and <ph id="ph1">\_</ph>_assume</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Intrinsic Support</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Compiler and Linker Options</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Profile-Guided Optimization</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Visual C++ supports profile-guided optimization (PGO).</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This optimization uses profile data from past executions of an instrumented version of an application to drive later optimization of the application.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using PGO can be time consuming, so it may not be something that every developer uses, but we do recommend using PGO for the final release build of a product.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Profile-Guided Optimizations<ept id="p1">](../../build/reference/profile-guided-optimizations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In addition, Whole Program Optimization (also knows as Link Time Code Generation) and the <bpt id="p1">**</bpt>/O1<ept id="p1">**</ept> and <bpt id="p2">**</bpt>/O2<ept id="p2">**</ept> optimizations has been improved.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In general, an application compiled with one of these options will be faster than the same application compiled with an earlier compiler.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/GL (Whole Program Optimization)<ept id="p1">](../../build/reference/gl-whole-program-optimization.md)</ept> and <bpt id="p2">[</bpt>/O1, /O2 (Minimize Size, Maximize Speed)<ept id="p2">](../../build/reference/o1-o2-minimize-size-maximize-speed.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Which Level of Optimization Should I Use?</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If at all possible, final release builds should be compiled with Profile Guided Optimizations.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If it is not possible to build with PGO, whether due to insufficient infrastructure for running the instrumented builds or not having access to scenarios, then we suggest building with Whole Program Optimization.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/Gy<ept id="p1">**</ept> switch is also very useful.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It generates a separate COMDAT for each function, giving the linker more flexibility when it comes to removing unreferenced COMDATs and COMDAT folding.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The only downside to using <bpt id="p1">**</bpt>/Gy<ept id="p1">**</ept> is that it can have a minor effect on build time.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Therefore, it is generally recommended to use it.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/Gy (Enable Function-Level Linking)<ept id="p1">](../../build/reference/gy-enable-function-level-linking.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For linking in 64-bit environments, it is recommended to use the <bpt id="p1">**</bpt>/OPT:REF,ICF<ept id="p1">**</ept> linker option, and in 32-bit environments, <bpt id="p2">**</bpt>/OPT:REF<ept id="p2">**</ept> is recommended.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/OPT (Optimizations)<ept id="p1">](../../build/reference/opt-optimizations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It is also strongly recommended to generate debug symbols, even with optimized release builds.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It doesn’t effect the generated code, and it makes it a lot easier to debug your application, if need be.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Floating Point Switches</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/Op<ept id="p1">**</ept> compiler option has been removed, and the following four compiler options dealing with floating point optimizations have been added:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>/fp:precise</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This is the default recommendation and should be used in most cases.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>/fp:fast</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Recommended if performance is of the utmost importance, for example in games.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This will result in the fastest performance.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>/fp:strict</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Recommended if precise floating-point exceptions and IEEE behavior is desired.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This will result in the slowest performance.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>/fp:except[-]</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Can be used in conjunction with <bpt id="p1">**</bpt>/fp:strict<ept id="p1">**</ept> or <bpt id="p2">**</bpt>/fp:precise<ept id="p2">**</ept>, but not <bpt id="p3">**</bpt>/fp:fast<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>/fp (Specify Floating-Point Behavior)<ept id="p1">](../../build/reference/fp-specify-floating-point-behavior.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Optimization Declspecs</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In this section we will look at two declspecs that can be used in programs to help performance: <ph id="ph1">`__declspec(restrict)`</ph> and <ph id="ph2">`__declspec(noalias)`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict`</ph> declspec can only be applied to function declarations that return a pointer, such as</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict`</ph> declspec is used on functions that return unaliased pointers.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This keyword is used for the C-Runtime Library implementation of <ph id="ph1">`malloc`</ph> since it will never return a pointer value that is already in use in the current program (unless you are doing something illegal, such as using memory after it has been freed).</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`restrict`</ph> declspec gives the compiler more information for performing compiler optimizations.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>One of the hardest things for a compiler to determine is what pointers alias other pointers, and using this information greatly helps the compiler.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It is worth pointing out that this is a promise to the compiler, not something that the compiler will verify.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If your program uses this <ph id="ph1">`restrict`</ph> declspec inappropriately, your program may have incorrect behavior.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>restrict<ept id="p1">](../../cpp/restrict.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`noalias`</ph> declspec is also applied only to functions, and indicates that the function is a semi-pure function.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A semi-pure function is one that references or modifies only locals, arguments, and first-level indirections of arguments.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This declspec is a promise to the compiler, and if the function references globals or second-level indirections of pointer arguments then the compiler may generate code that breaks the application.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>noalias<ept id="p1">](../../cpp/noalias.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Optimization Pragmas</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>There are also several useful pragmas for helping optimize code.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The first one we’ll discuss is <ph id="ph1">`#pragma optimize`</ph>:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set a given optimization level on a function-by-function basis.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is ideal for those rare occasions where your application crashes when a given function is compiled with optimization.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can use this to turn off optimizations for a single function:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>optimize<ept id="p1">](../../preprocessor/optimize.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Inlining is one of the most important optimizations that the compiler performs and here we talk about a couple of the pragmas that help modify this behavior.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is useful for specifying whether or not you want the application to be able to inline a recursive call.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>By default it is off.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For shallow recursion of small functions you may to turn this on.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>inline_recursion<ept id="p1">](../../preprocessor/inline-recursion.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Another useful pragma for limiting the depth of inlining is <ph id="ph1">`#pragma inline_depth`</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is typically useful in situations where you’re trying to limit the size of a program or function.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>inline_depth<ept id="p1">](../../preprocessor/inline-depth.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>__restrict and <ph id="ph1">\_</ph>_assume</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>There are a couple of keywords in Visual C++ that can help performance: <bpt id="p1">[</bpt>__restrict<ept id="p1">](../../cpp/extension-restrict.md)</ept> and <bpt id="p2">[</bpt>__assume<ept id="p2">](../../intrinsics/assume.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>First, it should be noted that <ph id="ph1">`__restrict`</ph> and <ph id="ph2">`__declspec(restrict)`</ph> are two different things.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>While they are somewhat related, their semantics are different.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>is a type qualifier, like <ph id="ph1">`const`</ph> or <ph id="ph2">`volatile`</ph>, but exclusively for pointer types.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A pointer that is modified with <ph id="ph1">`__restrict`</ph> is referred to as a <bpt id="p1">*</bpt>__restrict pointer<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>A __restrict pointer is a pointer that can only be accessed through the <ph id="ph1">\_</ph>_restrict pointer.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In other words, another pointer cannot be used to access the data pointed to by the <ph id="ph1">\_</ph>_restrict pointer.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>can be a powerful tool for the Visual C++ optimizer, but use it with great care.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If used improperly, the optimizer might perform an optimization that would break your application.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`__restrict`</ph> keyword replaces the <bpt id="p1">**</bpt>/Oa<ept id="p1">**</ept> switch from previous versions.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">`__assume,`</ph> a developer can tell the compiler to make assumptions about the value of some variable.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example <ph id="ph1">`__assume(a &lt; 5);`</ph> tells the optimizer that at that line of code the variable <ph id="ph2">`a`</ph> is less than 5.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Again this is a promise to the compiler.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`a`</ph> is actually 6 at this point in the program then the behavior of the program after the compiler has optimized may not be what you would expect.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>is most useful prior to switch statements and/or conditional expressions.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are some limitations to <ph id="ph1">`__assume`</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>First, like <ph id="ph1">`__restrict`</ph>, it is only a suggestion, so the compiler is free to ignore it.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Also, <ph id="ph1">`__assume`</ph> currently works only with variable inequalities against constants.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>It does not propagate symbolic inequalities, for example, assume(a &lt; b).</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Intrinsic Support</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Intrinsics are function calls where the compiler has intrinsic knowledge about the call, and rather than calling a function in a library, it emits code for that function.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The header file intrin.h located at &lt;Installation_Directory&gt;\VC\include\intrin.h contains all of the available intrinsics for each of the three supported platforms (x86, x64, and ARM).</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Intrinsics give the programmer the ability to go deep into the code without having to use assembly.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>There are several benefits to using intrinsics:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Your code is more portable.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Several of the intrinsics are available on multiple CPU architectures.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Your code is easier to read, since the code is still written in C/C++.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Your code gets the benefit of compiler optimizations.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>As the compiler gets better, the code generation for the intrinsics improves.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiler Intrinsics<ept id="p1">](../../intrinsics/compiler-intrinsics.md)</ept> and <bpt id="p2">[</bpt>Benefits of Using Intrinsics<ept id="p2">](http://msdn.microsoft.com/en-us/57af8920-527f-44af-a741-a07cbe80bf02)</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>There is a performance hit associated with using exceptions.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Some restrictions are introduced when using try blocks that inhibit the compiler from performing certain optimizations.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>On x86 platforms there is additional performance degradation from try blocks due to additional state information that must be generated during code execution.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>On the 64-bit platforms, try blocks do not degrade performance as much, but once an exception is thrown, the process of finding the handler and unwinding the stack can be expensive.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Therefore, it is recommended to avoid introducing try/catch blocks into code that does not really need it.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If you must use exceptions, use synchronous exceptions if possible.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Structured Exception Handling (C/C++)<ept id="p1">](../../cpp/structured-exception-handling-c-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Lastly, throw exceptions for exceptional cases only.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Using exceptions for general control flow will likely make performance suffer.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Optimizing Your Code</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>