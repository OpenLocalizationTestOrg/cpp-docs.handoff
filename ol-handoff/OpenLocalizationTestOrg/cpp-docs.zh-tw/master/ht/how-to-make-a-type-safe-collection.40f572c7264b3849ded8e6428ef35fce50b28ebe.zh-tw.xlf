<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">847a2cff1939e3fa2cc681efee937c373db6bfce</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\how-to-make-a-type-safe-collection.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c18aa40a30470410346dacd87b21c28891d702b6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">72145791d95ee17544e11f3848ded7329b1af0c9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>How to: Make a Type-Safe Collection | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>How to: Make a Type-Safe Collection</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This article explains how to make type-safe collections for your own data types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Topics include:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Using template-based classes for type safety</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Implementing helper functions</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Using nontemplate collection classes</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The Microsoft Foundation Class Library provides predefined type-safe collections based on C++ templates.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Because they are templates, these classes help provide type safety and ease of use without the type-casting and other extra work involved in using a nontemplate class for this purpose.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The MFC sample <bpt id="p1">[</bpt>COLLECT<ept id="p1">](../visual-cpp-samples.md)</ept> demonstrates the use of template-based collection classes in an MFC application.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In general, use these classes any time you write new collections code.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Using Template-Based Classes for Type Safety</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>To use template-based classes</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Declare a variable of the collection class type.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#7</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Call the member functions of the collection object.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#8</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If necessary, implement the <bpt id="p1">[</bpt>helper functions<ept id="p1">](../mfc/reference/collection-class-helpers.md)</ept> and <bpt id="p2">[</bpt>SerializeElements<ept id="p2">](../mfc/reference/collection-class-helpers.md#serializeelements)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For information on implementing these functions, see <bpt id="p1">[</bpt>Implementing Helper Functions<ept id="p1">](#_core_implementing_helper_functions)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This example shows the declaration of a list of integers.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The first parameter in step 1 is the type of data stored as elements of the list.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The second parameter specifies how the data is to be passed to and returned from member functions of the collection class, such as <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> and <ph id="ph1">`GetAt`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Implementing Helper Functions</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The template-based collection classes <ph id="ph1">`CArray`</ph>, <ph id="ph2">`CList`</ph>, and <ph id="ph3">`CMap`</ph> use five global helper functions that you can customize as needed for your derived collection class.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For information on these helper functions, see <bpt id="p1">[</bpt>Collection Class Helpers<ept id="p1">](../mfc/reference/collection-class-helpers.md)</ept> in the <bpt id="p2">*</bpt>MFC Reference<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Implementation of the serialization function is necessary for most uses of the template-based collection classes.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Serializing Elements</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CArray`</ph>, <ph id="ph2">`CList`</ph>, and <ph id="ph3">`CMap`</ph> classes call <ph id="ph4">`SerializeElements`</ph> to store collection elements to or read them from an archive.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The default implementation of the <ph id="ph1">`SerializeElements`</ph> helper function does a bitwise write from the objects to the archive, or a bitwise read from the archive to the objects, depending on whether the objects are being stored in or retrieved from the archive.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Override <ph id="ph1">`SerializeElements`</ph> if this action is not appropriate.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If your collection stores objects derived from <ph id="ph1">`CObject`</ph> and you use the <ph id="ph2">`IMPLEMENT_SERIAL`</ph> macro in the implementation of the collection element class, you can take advantage of the serialization functionality built into <ph id="ph3">`CArchive`</ph> and <ph id="ph4">`CObject`</ph>:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#9</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The overloaded insertion operators for <ph id="ph1">`CArchive`</ph> call <ph id="ph2">`CObject::Serialize`</ph> (or an override of that function) for each <bpt id="p1">**</bpt>CPerson<ept id="p1">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Using Nontemplate Collection Classes</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>MFC also supports the collection classes introduced with MFC version 1.0.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>These classes are not based on templates.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>They can be used to contain data of the supported types <ph id="ph1">`CObject*`</ph>, <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept>, <ph id="ph2">`DWORD`</ph>, and <ph id="ph3">`CString`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can use these predefined collections (such as <ph id="ph1">`CObList`</ph>) to hold collections of any objects derived from <ph id="ph2">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>MFC also provides other predefined collections to hold primitive types such as <bpt id="p1">**</bpt>UINT<ept id="p1">**</ept> and void pointers (<ph id="ph1">`void`</ph>*).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In general, however, it is often useful to define your own type-safe collections to hold objects of a more specific class and its derivatives.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Note that doing so with the collection classes not based on templates is more work than using the template-based classes.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>There are two ways to create type-safe collections with the nontemplate collections:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Use the nontemplate collections, with type casting if necessary.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This is the easier approach.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Derive from and extend a nontemplate type-safe collection.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To use the nontemplate collections with type casting</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Use one of the nontemplate classes, such as <ph id="ph1">`CWordArray`</ph>, directly.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, you can create a <ph id="ph1">`CWordArray`</ph> and add any 32-bit values to it, then retrieve them.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>There is nothing more to do.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You just use the predefined functionality.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can also use a predefined collection, such as <ph id="ph1">`CObList`</ph>, to hold any objects derived from <ph id="ph2">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CObList`</ph> collection is defined to hold pointers to <ph id="ph2">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>When you retrieve an object from the list, you may have to cast the result to the proper type since the <ph id="ph1">`CObList`</ph> functions return pointers to <ph id="ph2">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For example, if you store <ph id="ph1">`CPerson`</ph> objects in a <ph id="ph2">`CObList`</ph> collection, you have to cast a retrieved element to be a pointer to a <ph id="ph3">`CPerson`</ph> object.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example uses a <ph id="ph1">`CObList`</ph> collection to hold <ph id="ph2">`CPerson`</ph> objects:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#10</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This technique of using a predefined collection type and casting as necessary may be adequate for many of your collection needs.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you need further functionality or more type safety, use a template-based class, or follow the next procedure.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>To derive and extend a nontemplate type-safe collection</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Derive your own collection class from one of the predefined nontemplate classes.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>When you derive your class, you can add type-safe wrapper functions to provide a type-safe interface to existing functions.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, if you derived a list from <ph id="ph1">`CObList`</ph> to hold <ph id="ph2">`CPerson`</ph> objects, you might add the wrapper functions <ph id="ph3">`AddHeadPerson`</ph> and <ph id="ph4">`GetHeadPerson`</ph>, as shown below.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#11</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>These wrapper functions provide a type-safe way to add and retrieve <ph id="ph1">`CPerson`</ph> objects from the derived list.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can see that for the <ph id="ph1">`GetHeadPerson`</ph> function, you are simply encapsulating the type casting.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You can also add new functionality by defining new functions that extend the capabilities of the collection rather than just wrapping existing functionality in type-safe wrappers.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the article <bpt id="p1">[</bpt>Deleting All Objects in a CObject Collection<ept id="p1">](../mfc/deleting-all-objects-in-a-cobject-collection.md)</ept> describes a function to delete all the objects contained in a list.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This function could be added to the derived class as a member function.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Collections</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>