<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">20bc7bbf0f07bf6ac55061cc3790eb38e2c4fafb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\using-cpp-interop-implicit-pinvoke.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f3ac6fb4cb6b59c061d9421b814198853598ecaa</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a33366bc377daf833f83743da997ca4cc6ffc482</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Using C++ Interop (Implicit PInvoke) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Using C++ Interop (Implicit PInvoke)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Unlike other .NET languages, Visual C++ has interoperability support that allows managed and unmanaged code to exist in the same application and even in the same file (with the <bpt id="p1">[</bpt>managed, unmanaged<ept id="p1">](../preprocessor/managed-unmanaged.md)</ept> pragmas).</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This allows Visual C++ developers to integrate .NET functionality into existing Visual C++ applications without disturbing the rest of the application.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can also call unmanaged functions from a managed compiland using <bpt id="p1">[</bpt>dllexport, dllimport<ept id="p1">](../cpp/dllexport-dllimport.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Implicit PInvoke is useful when you do not need to specify how function parameters will be marshaled, or any of the other details that can be specified when explicitly calling DllImportAttribute.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Visual C++ provides two ways for managed and unmanaged functions to interoperate:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Using Explicit PInvoke in C++ (DllImport Attribute)</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Explicit PInvoke is supported by the .NET Framework and is available in most .NET languages.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>But as its name implies, C++ Interop is specific to Visual C++.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>C++ Interop</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>C++ Interop is recommended over explicit PInvoke because it provides better type safety, is typically less tedious to implement, is more forgiving if the unmanaged API is modified, and makes performance enhancements possible that are not possible with explicit PInvoke.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, C++ Interop is not possible if the unmanaged source code is not available or when compiling with <bpt id="p1">**</bpt>/clr:safe<ept id="p1">**</ept> (see <bpt id="p2">[</bpt>Pure and Verifiable Code (C++/CLI)<ept id="p2">](../dotnet/pure-and-verifiable-code-cpp-cli.md)</ept> for more information).</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>C++ COM Interop</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The interoperability features supported by Visual C++ offer a particular advantage over other .NET languages when it comes to interoperating with COM components.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Instead of being limited to the restrictions of the .NET Framework <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](http://msdn.microsoft.com/Library/ec0a8d63-11b3-4acd-b398-da1e37e97382)</ept>, such as limited support for data types and the mandatory exposure of every member of every COM interface, C++ Interop allows COM components to be accessed at will and does not require separate interop assemblies.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Using COM from .NET<ept id="p1">](http://msdn.microsoft.com/en-us/03976661-6278-4227-a6c1-3b3315502c15)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Blittable Types</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For unmanaged APIs that use simple, intrinsic types (see <bpt id="p1">[</bpt>Blittable and Non-Blittable Types<ept id="p1">](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)</ept>), no special coding is required because these data types have the same representation in memory, but more complex data types require explicit data marshaling.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>How to: Call Native DLLs from Managed Code Using PInvoke<ept id="p1">](../dotnet/how-to-call-native-dlls-from-managed-code-using-pinvoke.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In This Section</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>How to: Marshal ANSI Strings Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>How to: Marshal Unicode Strings Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>How to: Marshal COM Strings Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>How to: Marshal Structures Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>How to: Marshal Arrays Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>How to: Marshal Callbacks and Delegates By Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>How to: Marshal Embedded Pointers Using C++ Interop</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How to: Access Characters in a System::String</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>How to: Convert char * String to System::Byte Array</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>How to: Convert System::String to wchar_t* or char</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>How to: Convert System::String to Standard String</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>How to: Convert Standard String to System::String</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>How to: Obtain a Pointer to Byte Array</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>How to: Load Unmanaged Resources into a Byte Array</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>How to: Modify Reference Class in a Native Function</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>How to: Determine if an Image is Native or CLR</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>How to: Add Native DLL to Global Assembly Cache</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>How to: Hold Reference to Value Type in Native Type</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>How to: Hold Object Reference in Unmanaged Memory</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>How to: Detect /clr Compilation</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>How to: Convert Between System::Guid and _GUID</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>How to: Specify an out Parameter</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How to: Use a Native Type in a /clr Compilation</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>How to: Declare Handles in Native Types</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>How to: Wrap Native Class for Use by C</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For information on using delegates in an interop scenario, see <bpt id="p1">[</bpt>delegate  (C++ Component Extensions)<ept id="p1">](../windows/delegate-cpp-component-extensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Calling Native Functions from Managed Code</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>