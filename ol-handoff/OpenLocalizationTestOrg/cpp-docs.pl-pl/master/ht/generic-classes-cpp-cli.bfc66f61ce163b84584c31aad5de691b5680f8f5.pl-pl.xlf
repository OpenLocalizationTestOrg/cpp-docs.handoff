<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pl-pl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e8ed3e87449d176a9217e2a4a34aa2990d477216</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\windows\generic-classes-cpp-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">113b417d16a2ea5e461141d204f02045d8b58b9d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eca857fb46bc4e88a9c6727b701f81b9adfe8dbc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Generic Classes (C++-CLI) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generic Classes (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A generic class is declared using the following form:</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In the above syntax, the following terms are used:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>(optional)</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Additional declarative information.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information on attributes and attribute classes, see Attributes.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>class-key</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Either <ph id="ph1">`class`</ph> or</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-parameter-identifier(s)<ept id="p1">*</ept>,</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Comma-separated list of identifiers specifying the names of the type parameters.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>constraint-clauses</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A list (not comma-separated) of <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clauses specifying the constraints for the type parameters.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Takes the form:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-parameter-identifier<ept id="p1">*</ept>  <ph id="ph1">`:`</ph>  <bpt id="p2">*</bpt>constraint-list<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>constraint-list</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> *</bpt>class-or-interface<ept id="p1">*</ept>[<ph id="ph1">`,`</ph> <bpt id="p2">*</bpt>...<ept id="p2">*</ept>]</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>accessibility-modifiers</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Accessibility modifiers for the generic class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For the <ph id="ph1">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>, the only allowed modifier is <ph id="ph2">`private`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For the common language runtime, the allowed modifiers are <ph id="ph1">`private`</ph> and <ph id="ph2">`public`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>identifier</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The name of the generic class, any valid C++ identifier.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>modifiers<ept id="p1">*</ept> (optional)</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Allowed modifiers include <ph id="ph1">`sealed`</ph> and <bpt id="p1">**</bpt>abstract<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>base-list</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A list that contains the one base class and any implemented interfaces, all separated by commas.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>class-body</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The body of the class, containing fields, member functions, etc.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>declarators</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Declarations of any variables of this type.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example: <ph id="ph1">`^`</ph><bpt id="p1">*</bpt>identifier<ept id="p1">*</ept>[<ph id="ph2">`,`</ph> ...]</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can declare generic classes such as these (note that the keyword <bpt id="p1">**</bpt>class<ept id="p1">**</ept> may be used instead of <bpt id="p2">**</bpt>typename<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`ItemType`</ph>, <ph id="ph2">`KeyType`</ph> and <ph id="ph3">`ValueType`</ph> are unknown types that are specified at the point where the type.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>is a constructed type of the generic type <ph id="ph1">`HashTable&lt;KeyType, ValueType&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A number of different constructed types can be constructed from a single generic type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Constructed types constructed from generic classes are treated like any other ref class type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Both value types (either built-in types such as <ph id="ph1">`int`</ph> or <ph id="ph2">`double`</ph>, or user-defined value types) and reference types may be used as a generic type argument.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The syntax within the generic definition is the same regardless.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Syntactically, the unknown type is treated as if it were a reference type.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>However, the runtime is able to determine that if the type actually used is a value type and substitute the appropriate generated code for direct access to members.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Value types used as generic type arguments are not boxed and so do not suffer the performance penalty associated with boxing.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The syntax used within the body of the generic should be <bpt id="p1">**</bpt>T^<ept id="p1">**</ept> and '<bpt id="p2">**</bpt><ph id="ph1">-&gt;</ph><ept id="p2">**</ept>' instead of '<bpt id="p3">**</bpt>.<ept id="p3">**</ept>'.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Any use of <bpt id="p1">[</bpt>ref new, gcnew<ept id="p1">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept> for the type parameter will be appropriately interpreted by the runtime as the simple creation of a value type if the type argument is a value type.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can also declare a generic class with <bpt id="p1">[</bpt>Constraints on Generic Type Parameters (C++/CLI)<ept id="p1">](../windows/constraints-on-generic-type-parameters-cpp-cli.md)</ept> on the types that can be used for the type parameter.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the following example any type used for <ph id="ph1">`ItemType`</ph> must implement the <ph id="ph2">`IItem`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Attempting to use <ph id="ph1">`int`</ph>, for example, which does not implement <ph id="ph2">`IItem`</ph>, would produce a compile-time error because the type argument does not satisfy the constraint.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Generic classes in the same namespace cannot be overloaded by only changing the number or the types of type parameters.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>However, if each class lives in a different namespace, they can be overloaded.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For example, consider the following two classes, <ph id="ph1">`MyClass`</ph> and <ph id="ph2">`MyClass&lt;ItemType&gt;`</ph>, in the namespaces <ph id="ph3">`A`</ph> and <ph id="ph4">`B`</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The two classes can then be overloaded in a third namespace C:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The base class and base interfaces cannot be type parameters.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>However, the base class can involve the type parameter as an argument, as in the following case:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Constructors and destructors are executed once for each object instance (as usual); static constructors are executed once for each constructed type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Fields in Generic Classes</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This section demonstrates the use of instance and static fields in generic classes.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Instance variables of a generic class can have types and variable initializers that include any type parameters from the enclosing class.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In the following example, three different instances of the generic class, MyClass<ph id="ph1">\&lt;</ph>ItemType&gt;, are created by using the appropriate type arguments (<ph id="ph2">`int`</ph>, <bpt id="p1">**</bpt>double<ept id="p1">**</ept>, and <bpt id="p2">**</bpt>string<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Static Variables</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>On the creation of a new generic type, new instances of any static variables are created and any static constructor for that type is executed.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Static variables can use any type parameters from the enclosing class.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example demonstrates using static fields and a static constructor within a generic class.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Methods in Generic Classes</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Methods in generic classes can be generic themselves; non-generic methods will be implicitly parameterized by the class type parameter.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following special rules apply to methods within generic classes:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Methods in generic classes can use type parameters as parameters, return types, or local variables.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Methods in generic classes can use open or closed constructed types as parameters, return types, or local variables.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Non-Generic Methods in Generic Classes</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Methods in generic classes that have no additional type parameters are usually referred to as non-generic although they are implicitly parameterized by the enclosing generic class.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The signature of a non-generic method can include one or more type parameters of the enclosing class, either directly or in an open constructed type.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The body of such methods can also use these type parameters.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example declares a non-generic method, <ph id="ph1">`ProtectData`</ph>, inside a generic class, <ph id="ph2">`MyClass&lt;ItemType&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The method uses the class type parameter <ph id="ph1">`ItemType`</ph> in its signature in an open constructed type.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Generic Methods in Generic Classes</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can declare generic methods in both generic and non-generic classes.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The non-generic method is still generic in the sense that it is parameterized by the class's type parameter, but it has no additional type parameters.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>All types of methods in generic classes can be generic, including static, instance, and virtual methods.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The following example demonstrates declaring and using generic methods within generic classes:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Using Nested Types in Generic Classes</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Just as with ordinary classes, you can declare other types inside a generic class.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The nested class declaration is implicitly parameterized by the type parameters of the outer class declaration.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Thus, a distinct nested class is defined for each constructed outer type.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, in the declaration,</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The type Outer<ph id="ph1">\&lt;</ph>int&gt;::Inner is not the same as the type Outer<ph id="ph2">\&lt;</ph>double&gt;::Inner.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>As with generic methods in generic classes, additional type parameters can be defined for the nested type.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If you use the same type parameter names in the inner and outer class, the inner type parameter will hide the outer type parameter.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Since there is no way to refer to the outer type parameter, the compiler will produce a warning in this situation.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>When constructed nested generic types are named, the type parameter for the outer type is not included in the type parameter list for the inner type, even though the inner type is implicitly parameterized by the outer type's type parameter.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the above case, a name of a constructed type would be Outer<ph id="ph1">\&lt;</ph>int&gt;::Inner<ph id="ph2">\&lt;</ph>string&gt;.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The following example demonstrates building and reading a linked list using nested types in generic classes.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Properties, Events, Indexers and Operators in Generic Classes</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Properties, events, indexers and operators can use the type parameters of the enclosing generic class as return values, parameters, or local variables, such as when <ph id="ph1">`ItemType`</ph> is a type parameter of a class:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Properties, events, indexers and operators cannot themselves be parameterized.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>This example shows declarations of an instance property within a generic class.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The next example shows a generic class with an event.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Generic Structs</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The rules for declaring and using generic structs are the same as those for generic classes, except for the differences noted in in the Visual C++ language reference.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following example declares a generic struct, <ph id="ph1">`MyGenStruct`</ph>, with one field, <ph id="ph2">`myField`</ph>, and assigns values of different types (<ph id="ph3">`int`</ph>, <bpt id="p1">**</bpt>double<ept id="p1">**</ept>, <bpt id="p2">**</bpt>String^<ept id="p2">**</ept>) to this field.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Generics</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>