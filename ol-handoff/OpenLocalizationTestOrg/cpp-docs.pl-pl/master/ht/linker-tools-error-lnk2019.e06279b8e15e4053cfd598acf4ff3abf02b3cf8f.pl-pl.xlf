<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pl-pl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">86b43f2688b6e1dbfb39dfec681ca9adafd2c093</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\error-messages\tool-errors\linker-tools-error-lnk2019.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">71e4fa09dcae88353c258a56651597f431f81004</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1c56976bc8a325a7ee8d98bb41aa1b9820dcd6e9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Linker Tools Error LNK2019 | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Linker Tools Error LNK2019</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>unresolved external symbol 'symbol' referenced in function 'function'</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The linker could not find a definition for external symbol "<ph id="ph1">`symbol`</ph>" used in function "<ph id="ph2">`function`</ph>".</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>There are many issues that can cause this error.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic will help you identify the cause and find a solution.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>symbol<ept id="p1">*</ept> is the name the compiler uses for a function or global variable.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>external symbol<ept id="p1">*</ept> is the name used to refer to a symbol that is defined in a different source or object file.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The linker must <bpt id="p1">*</bpt>resolve<ept id="p1">*</ept>, or find the definition for, the external symbol for every function or global variable used by each compiled file when it is linked into an application or DLL.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If the linker can't find a matching definition for an external symbol in any of the linked files, it generates LNK2019.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This error can occur if the object or library file that has the definition of a symbol is not included in the build.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>It can also occur if the symbol name the linker searches for does not match the name of the symbol in the library or object file that defines it.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This can happen if the name in the calling code is misspelled, uses different capitalization, uses a different calling convention, or specifies different parameters.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Code that uses C++ linkage uses <bpt id="p1">[</bpt>Name Decoration<ept id="p1">](../../error-messages/tool-errors/name-decoration.md)</ept>, also known as <bpt id="p2">*</bpt>name-mangling<ept id="p2">*</ept>, to encode extra information about a variable or function's type and calling convention in the symbol name.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>decorated name<ept id="p1">*</ept> is the name the linker searches for to resolve external symbols.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Because the type information becomes part of the symbol's decorated name, LNK2019 can result if the declaration of the external symbol where it is used does not match the declaration of the symbol where it is defined.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To help you find the cause of the error, the error message shows you both the "friendly name," the name used in source code, and the decorated name (in parentheses) for the unresolved external symbol.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You don't need to know how to translate the decorated name to be able to compare it with other decorated names.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Common issues</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Here are some common problems that cause LNK2019:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The object file or library that contains the definition of the symbol is not linked.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In Visual Studio, verify that the source file that contains the definition is built and linked as part of your project.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>On the command line, verify that the source file that contains the definition is compiled, and that the resulting object file is included in the list of files to link.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The declaration of the symbol is not spelled the same as the definition of the symbol.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Verify the correct spelling and capitalization is used in both the declaration and the definition, and wherever the symbol is used or called.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A function is used but the type or number of the parameters do not match the function definition.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The function declaration must match the definition.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Verify that the function call matches the declaration, and that the declaration matches the definition.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Code that invokes template functions must also have matching template function declarations that include the same template parameters as the definition.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For an example of a template declaration mismatch, see sample LNK2019e.cpp in the Examples section.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A function or variable is declared but not defined.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This usually means a declaration exists in a header file, but no matching definition is implemented.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For member functions or static data members, the implementation must include the class scope selector.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Missing Function Body or Variable<ept id="p1">](../../error-messages/tool-errors/missing-function-body-or-variable.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The calling convention is different between the function declaration and the function definition.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Calling conventions (<bpt id="p1">[</bpt>__cdecl<ept id="p1">](../../cpp/cdecl.md)</ept>, <bpt id="p2">[</bpt>__stdcall<ept id="p2">](../../cpp/stdcall.md)</ept>, <bpt id="p3">[</bpt>__fastcall<ept id="p3">](../../cpp/fastcall.md)</ept>, or <bpt id="p4">[</bpt>__vectorcall<ept id="p4">](../../cpp/vectorcall.md)</ept>) are encoded as part of the decorated name.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Verify that the calling convention is the same.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A symbol is defined in a C file, but declared without using extern "C" in a C++ file.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Symbols defined in a file that is compiled as C have different decorated names than symbols declared in a C++ file unless you use an <bpt id="p1">[</bpt>extern "C"<ept id="p1">](../../cpp/using-extern-to-specify-linkage.md)</ept> modifier.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Verify that the declaration matches the compilation linkage for each symbol.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Similarly, if you define a symbol in a C++ file that will be used by a C program, use <ph id="ph1">`extern "C"`</ph> in the definition.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A symbol is defined as static and then later referenced outside the file.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, <bpt id="p1">[</bpt>global constants<ept id="p1">](../../error-messages/tool-errors/global-constants-in-cpp.md)</ept> have <ph id="ph1">`static`</ph> linkage.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>To get around this limitation, you can include the <ph id="ph1">`const`</ph> initializations in a header file and include that header in your .cpp files, or you can make the variable non-constant and use a constant reference to access it.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A static member of a class is not defined.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A static class member must have a unique definition, or it will violate the one-definition rule.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A static class member that cannot be defined inline must be defined in one source file by using its fully-qualified name.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If it is not defined at all, the linker generates LNK2019.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A build dependency is only defined as a project dependency in the solution.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In earlier versions of <ph id="ph1">[!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)]</ph>, this level of dependency was sufficient.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>However, starting with Visual Studio 2010, <ph id="ph1">[!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)]</ph> requires a <bpt id="p1">[</bpt>project-to-project reference<ept id="p1">](/visualstudio/ide/managing-references-in-a-project)</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If your project does not have a project-to-project reference, you may receive this linker error.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Add a project-to-project reference to fix it.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>You build a console application by using settings for a Windows application<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If the error message is similar to <bpt id="p1">**</bpt>unresolved external symbol WinMain referenced in function<ept id="p1">**</ept><ph id="ph1">`function_name`</ph>, link by using <bpt id="p2">**</bpt>/SUBSYSTEM:CONSOLE<ept id="p2">**</ept> instead of <bpt id="p3">**</bpt>/SUBSYSTEM:WINDOWS<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information about this setting, and for instructions on how to set this property in Visual Studio, see <bpt id="p1">[</bpt>/SUBSYSTEM (Specify Subsystem)<ept id="p1">](../../build/reference/subsystem-specify-subsystem.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You use different compiler options for function inlining in different source files.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Using inlined functions defined in .cpp files and mixing function inlining compiler options in different source files can cause LNK2019.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Function Inlining Problems<ept id="p1">](../../error-messages/tool-errors/function-inlining-problems.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You use automatic variables outside their scope.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Automatic (function scope) variables can only be used in the scope of that function.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>These variables can't be declared <ph id="ph1">`extern`</ph> and used in other source files.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Automatic (Function Scope) Variables<ept id="p1">](../../error-messages/tool-errors/automatic-function-scope-variables.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You call instrinsic functions or pass argument types to intrinsic functions that are not supported on your target architecture.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, if you use an AVX2 intrinsic, but do not specify the <bpt id="p1">[</bpt>/ARCH:AVX2<ept id="p1">](../../build/reference/arch-x86.md)</ept> compiler option, the compiler assumes that the intrinsic is an external function.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Instead of generating an inline instruction, the compiler generates a call to an external symbol with the same name as the intrinsic.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When the linker tries to find the definition of this missing function, it generates LNK2019.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Verify that you only use intrinsics and types supported by your target architecture.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You mix code that uses native wchar_t with code that doesn't.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>C++ language conformance work that was done in Visual C++ 2005 made <ph id="ph1">`wchar_t`</ph> a native type by default.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You must use the <bpt id="p1">[</bpt>/Zc:wchar_t-<ept id="p1">](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md)</ept> compiler option to generate code compatible with library and object files compiled by using earlier versions of Visual C++.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If not all files have been compiled by using the same <bpt id="p1">**</bpt>/Zc:wchar_t<ept id="p1">**</ept> settings, type references may not resolve to compatible types.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Verify that <ph id="ph1">`wchar_t`</ph> types in all library and object files are compatible, either by updating the types that are used, or by using consistent <bpt id="p1">**</bpt>/Zc:wchar_t<ept id="p1">**</ept> settings when you compile.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information about possible causes and solutions for LNK2019, see the Stack Overflow question <bpt id="p1">[</bpt>What is an undefined reference/unresolved external symbol error and how do I fix it?<ept id="p1">](http://stackoverflow.com/q/12573816/2002113)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Diagnosis tools</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It can be difficult to tell why the linker can't find a particular symbol definition.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Often the problem is that you have not included the code in your build, or build options have created different decorated names for external symbols.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>There are several tools and options that can help you diagnose a LNK2019 error.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>/VERBOSE<ept id="p1">](../../build/reference/verbose-print-progress-messages.md)</ept> linker option can help you determine which files the linker references.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This can help you verify whether the file that contains the definition of the symbol is included in your build.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>/EXPORTS<ept id="p1">](../../build/reference/dash-exports.md)</ept> and <bpt id="p2">[</bpt>/SYMBOLS<ept id="p2">](../../build/reference/symbols.md)</ept> options of the DUMPBIN utility can help you discover which symbols are defined in your .dll and object or library files.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Verify that the exported decorated names match the decorated names the linker searches for.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The UNDNAME utility can show you the equivalent undecorated external symbol for a decorated name.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Here are several examples of code that causes a LNK2019 error, together with information about how to fix the error.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A symbol is declared but not defined</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following sample generates LNK2019 because an external symbol is declared but not defined:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Here is another example:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`i`</ph> and <ph id="ph2">`g`</ph> are not defined in one of the files in the build, the linker generates LNK2019.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can fix the errors by including the source code file that contains the definitions as part of the compilation.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Alternatively, you can pass to the linker .obj files or .lib files that contain the definitions.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A static data member is declared but not defined</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>LNK2019 can also occur when a static data member is declared but not defined.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following sample generates LNK2019, and shows how to fix it.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Declaration parameters do not match definition</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Code that invokes template functions must have matching template function declarations.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Declarations must include the same template parameters as the definition.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following sample generates LNK2019 on a user-defined operator, and shows how to fix it.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Inconsistent wchar_t type definitions</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The following sample creates a DLL that has an export that uses <ph id="ph1">`WCHAR`</ph>, which resolves to <ph id="ph2">`wchar_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The following sample uses the DLL in the previous sample, and generates LNK2019 because the types unsigned short* and WCHAR<ph id="ph1">\*</ph> are not the same.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>To resolve this error, change <ph id="ph1">`unsigned short`</ph> to <ph id="ph2">`wchar_t`</ph> or <ph id="ph3">`WCHAR`</ph>, or compile LNK2019g.cpp by using <bpt id="p1">**</bpt>/Zc:wchar_t-<ept id="p1">**</ept>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>