<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pl-pl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">daec7b53b4e542ef5ef1e38e8a0d9135b72d90bc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\algorithm.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84ad7f70466a84a6bc7186ed7e9b990648f7edc4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1526e245f871746e8b91690944aebf0d4eaf6c8f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>algorithm<ph id="ph2">&amp;gt;</ph> | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>algorithm<ph id="ph2">&amp;gt;</ph></source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Defines Standard Template Library (STL) container template functions that perform algorithms.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The STL algorithms are generic because they can operate on a variety of data structures.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The data structures that they can operate on include not only the STL container classes such as <ph id="ph1">`vector`</ph> and <ph id="ph2">`list`</ph>, but also program-defined data structures and arrays of elements that satisfy the requirements of a particular algorithm.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>STL algorithms achieve this level of generality by accessing and traversing the elements of a container indirectly through iterators.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>STL algorithms process iterator ranges that are typically specified by their beginning or ending positions.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The ranges referred to must be valid in the sense that all pointers in the ranges must be dereferenceable and, within the sequences of each range, the last position must be reachable from the first by incrementation.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The STL algorithms extend the actions supported by the operations and member functions of each STL container and allow working, for example, with different types of container objects at the same time.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Two suffixes have been used to convey information about the purpose of the algorithms.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`_if`</ph> suffix indicates that the algorithm is used with function objects operating on the values of the elements rather than on the values of the elements themselves.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`find_if`</ph> algorithm looks for elements whose values satisfy the criterion specified by a function object, and the <ph id="ph2">`find`</ph> algorithm searches for a particular value.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The _copy suffix indicates that the algorithm not only manipulates the values of the elements but also copies the modified values into a destination range.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`reverse`</ph> algorithm reverses the order of the elements within a range, and the <ph id="ph2">`reverse_copy`</ph> algorithm also copies the result into a destination range.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>STL algorithms are often classified into groups that indicate something about their purpose or requirements.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These include modifying algorithms that change the value of elements as compared with non-modifying algorithms that do not.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Mutating algorithms change the order of elements, but not the values of their elements.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Removing algorithms can eliminate elements from a range or a copy of a range.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Sorting algorithms reorder the elements in a range in various ways and sorted range algorithms only act on algorithms whose elements have been sorted in a particular way.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The STL numeric algorithms that are provided for numerical processing have their own header file <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>numeric&gt;<ept id="p1">](../standard-library/numeric.md)</ept>, and function objects and adaptors are defined in the header <bpt id="p2">[</bpt><ph id="ph2">\&lt;</ph>functional&gt;<ept id="p2">](../standard-library/functional.md)</ept> Function objects that return Boolean values are known as predicates.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The default binary predicate is the comparison <ph id="ph1">`operator&lt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In general, the elements being ordered need to be less than comparable so that, given any two elements, it can be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This results in an ordering among the nonequivalent elements.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Functions</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>adjacent_find<ept id="p1">](../standard-library/algorithm-functions.md#adjacent_find)</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Searches for two adjacent elements that are either equal or satisfy a specified condition.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>all_of<ept id="p1">](../standard-library/algorithm-functions.md#all_of)</ept></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is present at each element in the given range.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>any_of<ept id="p1">](../standard-library/algorithm-functions.md#any_of)</ept></source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is present at least once in the specified range of elements.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>binary_search<ept id="p1">](../standard-library/algorithm-functions.md#binary_search)</ept></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Tests whether there is an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>copy<ept id="p1">](../standard-library/algorithm-functions.md#copy)</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>copy_backward<ept id="p1">](../standard-library/algorithm-functions.md#copy_backward)</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>copy_if<ept id="p1">](../standard-library/algorithm-functions.md#copy_if)</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Copy all elements in a given range that test <ph id="ph1">`true`</ph> for a specified condition</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>copy_n<ept id="p1">](../standard-library/algorithm-functions.md#copy_n)</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Copies a specified number of elements.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>count<ept id="p1">](../standard-library/algorithm-functions.md#count)</ept></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in a range whose values match a specified value.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>count_if<ept id="p1">](../standard-library/algorithm-functions.md#count_if)</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in a range whose values match a specified condition.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>equal<ept id="p1">](../standard-library/algorithm-functions.md#equal)</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Compares two ranges element by element either for equality or equivalence in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>equal_range<ept id="p1">](../standard-library/algorithm-functions.md#equal_range)</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Finds a pair of positions in an ordered range, the first less than or equivalent to the position of a specified element and the second greater than the element's position, where the sense of equivalence or ordering used to establish the positions in the sequence may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>fill<ept id="p1">](../standard-library/algorithm-functions.md#fill)</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Assigns the same new value to every element in a specified range.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>fill_n<ept id="p1">](../standard-library/algorithm-functions.md#fill_n)</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a specified number of elements in a range starting with a particular element.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>find<ept id="p1">](../standard-library/algorithm-functions.md#find)</ept></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Locates the position of the first occurrence of an element in a range that has a specified value.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>find_end<ept id="p1">](../standard-library/algorithm-functions.md#find_end)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Looks in a range for the last subsequence that is identical to a specified sequence or that is equivalent in a sense specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>find_first_of<ept id="p1">](../standard-library/algorithm-functions.md#find_first_of)</ept></source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Searches for the first occurrence of any of several values within a target range or for the first occurrence of any of several elements that are equivalent in a sense specified by a binary predicate to a specified set of the elements.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>find_if<ept id="p1">](../standard-library/algorithm-functions.md#find_if)</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Locates the position of the first occurrence of an element in a range that satisfies a specified condition.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>find_if_not<ept id="p1">](../standard-library/algorithm-functions.md#find_if_not)</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Returns the first element in the indicated range that does not satisfy a condition.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>for_each<ept id="p1">](../standard-library/algorithm-functions.md#for_each)</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Applies a specified function object to each element in a forward order within a range and returns the function object.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>generate<ept id="p1">](../standard-library/algorithm-functions.md#generate)</ept></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Assigns the values generated by a function object to each element in a range.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>generate_n<ept id="p1">](../standard-library/algorithm-functions.md#generate_n)</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Assigns the values generated by a function object to a specified number of element is a range and returns to the position one past the last assigned value.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>includes<ept id="p1">](../standard-library/algorithm-functions.md#includes)</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Tests whether one sorted range contains all the elements contained in a second sorted range, where the ordering or equivalence criterion between elements may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>inplace_merge<ept id="p1">](../standard-library/algorithm-functions.md#inplace_merge)</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Combines the elements from two consecutive sorted ranges into a single sorted range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_heap<ept id="p1">](../standard-library/algorithm-functions.md#is_heap)</ept></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range form a heap.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_heap_until<ept id="p1">](../standard-library/algorithm-functions.md#is_heap_until)</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the specified range forms a heap until the last element.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_partitioned<ept id="p1">](../standard-library/algorithm-functions.md#is_partitioned)</ept></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if all the elements in the given range that test <ph id="ph2">`true`</ph> for a condition come before any elements that test <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_permutation<ept id="p1">](../standard-library/algorithm-functions.md#is_permutation)</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Determines whether the elements in a given range form a valid permutation.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_sorted<ept id="p1">](../standard-library/algorithm-functions.md#is_sorted)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range are in sorted order.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is_sorted_until<ept id="p1">](../standard-library/algorithm-functions.md#is_sorted_until)</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the elements in the specified range are in sorted order.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>iter_swap<ept id="p1">](../standard-library/algorithm-functions.md#iter_swap)</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Exchanges two values referred to by a pair of specified iterators.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>lexicographical_compare<ept id="p1">](../standard-library/algorithm-functions.md#lexicographical_compare)</ept></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Compares element by element between two sequences to determine which is lesser of the two.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>lower_bound<ept id="p1">](../standard-library/algorithm-functions.md#lower_bound)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Finds the position of the first element in an ordered range that has a value greater than or equivalent to a specified value, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>make_heap<ept id="p1">](../standard-library/algorithm-functions.md#make_heap)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Converts elements from a specified range into a heap in which the first element is the largest and for which a sorting criterion may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max<ept id="p1">](../standard-library/algorithm-functions.md#max)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Compares two objects and returns the larger of the two, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_element<ept id="p1">](../standard-library/algorithm-functions.md#max_element)</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of largest element in a specified range where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>merge<ept id="p1">](../standard-library/algorithm-functions.md#merge)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Combines all the elements from two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>min<ept id="p1">](../standard-library/algorithm-functions.md#min)</ept></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Compares two objects and returns the lesser of the two, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>min_element<ept id="p1">](../standard-library/algorithm-functions.md#min_element)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of smallest element in a specified range where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>minmax<ept id="p1">](../standard-library/algorithm-functions.md#minmax)</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Compares two input parameters and returns them as a pair, in order of least to greatest.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>minmax_element<ept id="p1">](../standard-library/algorithm-functions.md#minmax_element)</ept></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Performs the work performed by <bpt id="p1">[</bpt>min_element<ept id="p1">](../standard-library/algorithm-functions.md#min_element)</ept> and <bpt id="p2">[</bpt>max_element<ept id="p2">](../standard-library/algorithm-functions.md#max_element)</ept> in one call.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>mismatch<ept id="p1">](../standard-library/algorithm-functions.md#mismatch)</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Compares two ranges element by element either for equality or equivalent in a sense specified by a binary predicate and locates the first position where a difference occurs.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>alg<ph id="ph2">&amp;gt;</ph> move<ept id="p1">](../standard-library/algorithm-functions.md#alg_move)</ept></source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Move elements associated with a specified range.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>move_backward<ept id="p1">](../standard-library/algorithm-functions.md#move_backward)</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Moves the elements of one iterator to another.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The move starts with the last element in a specified range, and ends with the first element in that range.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>next_permutation<ept id="p1">](../standard-library/algorithm-functions.md#next_permutation)</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>none_of<ept id="p1">](../standard-library/algorithm-functions.md#none_of)</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> when a condition is never present among elements in the given range.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>nth_element<ept id="p1">](../standard-library/algorithm-functions.md#nth_element)</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Partitions a range of elements, correctly locating the <bpt id="p1">*</bpt>n<ept id="p1">*</ept>th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partial_sort<ept id="p1">](../standard-library/algorithm-functions.md#partial_sort)</ept></source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Arranges a specified number of the smaller elements in a range into a nondescending order or according to an ordering criterion specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partial_sort_copy<ept id="p1">](../standard-library/algorithm-functions.md#partial_sort_copy)</ept></source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range into a destination range where the source elements are ordered by either less than or another specified binary predicate.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partition<ept id="p1">](../standard-library/algorithm-functions.md#partition)</ept></source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partition_copy<ept id="p1">](../standard-library/algorithm-functions.md#partition_copy)</ept></source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Copies elements for which a condition is <ph id="ph1">`true`</ph> to one destination, and for which the condition is <ph id="ph2">`false`</ph> to another.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The elements must come from a specified range.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partition_point<ept id="p1">](../standard-library/algorithm-functions.md#partition_point)</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Returns the first element in the given range that does not satisfy the condition.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The elements are sorted so that those that satisfy the condition come before those that do not.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>pop_heap<ept id="p1">](../standard-library/algorithm-functions.md#pop_heap)</ept></source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Removes the largest element from the front of a heap to the next-to-last position in the range and then forms a new heap from the remaining elements.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>prev_permutation<ept id="p1">](../standard-library/algorithm-functions.md#prev_permutation)</ept></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>push_heap<ept id="p1">](../standard-library/algorithm-functions.md#push_heap)</ept></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Adds an element that is at the end of a range to an existing heap consisting of the prior elements in the range.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>random_shuffle<ept id="p1">](../standard-library/algorithm-functions.md#random_shuffle)</ept></source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Rearranges a sequence of <bpt id="p1">*</bpt>N<ept id="p1">*</ept> elements in a range into one of <bpt id="p2">*</bpt>N<ept id="p2">*</ept>!</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>possible arrangements selected at random.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>remove<ept id="p1">](../standard-library/algorithm-functions.md#remove)</ept></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Eliminates a specified value from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>remove_copy<ept id="p1">](../standard-library/algorithm-functions.md#remove_copy)</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range to a destination range, except that elements of a specified value are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>remove_copy_if<ept id="p1">](../standard-library/algorithm-functions.md#remove_copy_if)</ept></source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range to a destination range, except that satisfying a predicate are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>remove_if<ept id="p1">](../standard-library/algorithm-functions.md#remove_if)</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Eliminates elements that satisfy a predicate from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>replace<ept id="p1">](../standard-library/algorithm-functions.md#replace)</ept></source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Examines each element in a range and replaces it if it matches a specified value.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>replace_copy<ept id="p1">](../standard-library/algorithm-functions.md#replace_copy)</ept></source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Examines each element in a source range and replaces it if it matches a specified value while copying the result into a new destination range.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>replace_copy_if<ept id="p1">](../standard-library/algorithm-functions.md#replace_copy_if)</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Examines each element in a source range and replaces it if it satisfies a specified predicate while copying the result into a new destination range.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>replace_if<ept id="p1">](../standard-library/algorithm-functions.md#replace_if)</ept></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Examines each element in a range and replaces it if it satisfies a specified predicate.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>reverse<ept id="p1">](../standard-library/algorithm-functions.md#reverse)</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements within a range.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>reverse_copy<ept id="p1">](../standard-library/algorithm-functions.md#reverse_copy)</ept></source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements within a source range while copying them into a destination range</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>rotate<ept id="p1">](../standard-library/algorithm-functions.md#rotate)</ept></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Exchanges the elements in two adjacent ranges.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>rotate_copy<ept id="p1">](../standard-library/algorithm-functions.md#rotate_copy)</ept></source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Exchanges the elements in two adjacent ranges within a source range and copies the result to a destination range.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>search<ept id="p1">](../standard-library/algorithm-functions.md#search)</ept></source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Searches for the first occurrence of a sequence within a target range whose elements are equal to those in a given sequence of elements or whose elements are equivalent in a sense specified by a binary predicate to the elements in the given sequence.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>search_n<ept id="p1">](../standard-library/algorithm-functions.md#search_n)</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Searches for the first subsequence in a range that of a specified number of elements having a particular value or a relation to that value as specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>set_difference<ept id="p1">](../standard-library/algorithm-functions.md#set_difference)</ept></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to one sorted source range, but not to a second sorted source range, into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>set_intersection<ept id="p1">](../standard-library/algorithm-functions.md#set_intersection)</ept></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to both sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>set_symmetric_difference<ept id="p1">](../standard-library/algorithm-functions.md#set_symmetric_difference)</ept></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to one, but not both, of the sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>set_union<ept id="p1">](../standard-library/algorithm-functions.md#set_union)</ept></source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Unites all of the elements that belong to at least one of two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sort<ept id="p1">](../standard-library/algorithm-functions.md#sort)</ept></source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>shuffle<ept id="p1">](../standard-library/algorithm-functions.md#std__shuffle)</ept></source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Shuffles (rearranges) elements for a given range using a random number generator.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sort_heap<ept id="p1">](../standard-library/algorithm-functions.md#sort_heap)</ept></source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Converts a heap into a sorted range.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>stable_partition<ept id="p1">](../standard-library/algorithm-functions.md#stable_partition)</ept></source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it, preserving the relative order of equivalent elements.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>stable_sort<ept id="p1">](../standard-library/algorithm-functions.md#stable_sort)</ept></source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate and preserves the relative ordering of equivalent elements.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>swap<ept id="p1">](../standard-library/algorithm-functions.md#swap)</ept></source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Exchanges the values of the elements between two types of objects, assigning the contents of the first object to the second object and the contents of the second to the first.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>swap_ranges<ept id="p1">](../standard-library/algorithm-functions.md#swap_ranges)</ept></source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Exchanges the elements of one range with the elements of another, equal sized range.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>transform<ept id="p1">](../standard-library/algorithm-functions.md#transform)</ept></source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Applies a specified function object to each element in a source range or to a pair of elements from two source ranges and copies the return values of the function object into a destination range.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unique<ept id="p1">](../standard-library/algorithm-functions.md#unique)</ept></source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Removes duplicate elements that are adjacent to each other in a specified range.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unique_copy<ept id="p1">](../standard-library/algorithm-functions.md#unique_copy)</ept></source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Copies elements from a source range into a destination range except for the duplicate elements that are adjacent to each other.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>upper_bound<ept id="p1">](../standard-library/algorithm-functions.md#upper_bound)</ept></source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Finds the position of the first element in an ordered range that has a value that is greater than a specified value, where the ordering criterion may be specified by a binary predicate.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Header Files Reference<ept id="p1">](../standard-library/cpp-standard-library-header-files.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Thread Safety in the C++ Standard Library<ept id="p1">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>C++ Standard Library Reference<ept id="p1">](../standard-library/cpp-standard-library-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>