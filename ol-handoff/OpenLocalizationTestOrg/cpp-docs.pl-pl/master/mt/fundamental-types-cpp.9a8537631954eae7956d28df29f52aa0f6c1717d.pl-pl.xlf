<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pl-pl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6c9df7a9fd66fbcb709692eb44086b4290e222f9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\fundamental-types-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">665364f0840078095bffd462da2441da4b8212c2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3fe474dc7c68ed84eecde762dc971e72d6f4f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Fundamental Types  (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Fundamental Types  (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Fundamental types in C++ are divided into three categories: integral, floating point, and void.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Integral types are capable of handling whole numbers.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Floating point types are capable of specifying values that may have fractional parts.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>void<ept id="p1">](../cpp/void-cpp.md)</ept> type describes an empty set of values.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>No variable of type <ph id="ph1">`void`</ph> can be specified — it is used primarily to declare functions that return no values or to declare generic pointers to untyped or arbitrarily typed data.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Any expression can be explicitly converted or cast to type <ph id="ph1">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, such expressions are restricted to the following uses:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An expression statement.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Expressions<ept id="p1">](../cpp/expressions-cpp.md)</ept>, for more information.)</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The left operand of the comma operator.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Comma Operator<ept id="p1">](../cpp/comma-operator.md)</ept> for more information.)</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The second or third operand of the conditional operator (<ph id="ph1">`? :`</ph>).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Expressions with the Conditional Operator<ept id="p1">](../cpp/conditional-operator-q.md)</ept> for more information.)</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following table explains the restrictions on type sizes.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>These restrictions are independent of the Microsoft implementation.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Fundamental Types of the C++ Language</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Contents</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Integral</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`char`</ph> is an integral type that usually contains members of the basic execution character set — By default, this is ASCII in Microsoft C++.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The C++ compiler treats variables of type <ph id="ph1">`char`</ph>, <ph id="ph2">`signed`</ph> <ph id="ph3">`char`</ph>, and <ph id="ph4">`unsigned`</ph> <ph id="ph5">`char`</ph> as having different types.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Variables of type <ph id="ph1">`char`</ph> are promoted to <ph id="ph2">`int`</ph> as if they are type <ph id="ph3">`signed`</ph> <ph id="ph4">`char`</ph> by default, unless the /J compilation option is used.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In this case they are treated as type <ph id="ph1">`unsigned`</ph> <ph id="ph2">`char`</ph> and are promoted to <ph id="ph3">`int`</ph> without sign extension.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`bool`</ph> is an integral type that can have one of the two values <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Its size is unspecified.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`short`</ph> <ph id="ph2">`int`</ph> (or simply <ph id="ph3">`short`</ph>) is an integral type that is larger than or equal to the size of type <ph id="ph4">`char`</ph>, and shorter than or equal to the size of type <ph id="ph5">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Objects of type <ph id="ph1">`short`</ph> can be declared as <ph id="ph2">`signed`</ph> <ph id="ph3">`short`</ph> or <ph id="ph4">`unsigned short`</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>is a synonym for <ph id="ph1">`short`</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`int`</ph> is an integral type that is larger than or equal to the size of type <ph id="ph2">`short`</ph> <ph id="ph3">`int`</ph>, and shorter than or equal to the size of type <ph id="ph4">`long`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Objects of type <ph id="ph1">`int`</ph> can be declared as <ph id="ph2">`signed`</ph> <ph id="ph3">`int`</ph> or <ph id="ph4">`unsigned`</ph> <ph id="ph5">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>is a synonym for <ph id="ph1">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`__int16`</ph>, <ph id="ph2">`__int32`</ph>,</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Sized integer <ph id="ph1">`__int``n`</ph>, where <ph id="ph2">`n`</ph> is the size, in bits, of the integer variable.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`__int16`</ph>, <ph id="ph2">`__int32`</ph> and <ph id="ph3">`__int64`</ph> are Microsoft-specific keywords.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Not all types are available on all architectures.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>is not supported.)</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`long`</ph> (or <ph id="ph2">`long`</ph> <ph id="ph3">`int`</ph>) is an integral type that is larger than or equal to the size of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Objects of type <ph id="ph1">`long`</ph> can be declared as <ph id="ph2">`signed`</ph> <ph id="ph3">`long`</ph> or <ph id="ph4">`unsigned`</ph> <ph id="ph5">`long`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>is a synonym for <ph id="ph1">`long`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Larger than an unsigned <ph id="ph1">`long`</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Objects of type <ph id="ph1">`long long`</ph> can be declared as <ph id="ph2">`signed`</ph> <ph id="ph3">`long long`</ph> or <ph id="ph4">`unsigned`</ph> <ph id="ph5">`long long`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>is a synonym for <ph id="ph1">`long long`</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>,</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A variable of type <ph id="ph1">`wchar_t`</ph> designates a wide-character or multibyte character type.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`wchar_t`</ph> is a native type, but you can use <bpt id="p1">[</bpt>/Zc:wchar_t-<ept id="p1">](../build/reference/zc-wchar-t-wchar-t-is-native-type.md)</ept> to make <ph id="ph2">`wchar_t`</ph> a typedef for <ph id="ph3">`unsigned short`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`__wchar_t`</ph> type is a Microsoft-specific synonym for the native <ph id="ph2">`wchar_t`</ph> type.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Use the L prefix before a character or string literal to designate the wide-character type.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Floating point</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`float`</ph> is the smallest floating point type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`double`</ph> is a floating point type that is larger than or equal to type <ph id="ph2">`float`</ph>, but shorter than or equal to the size of type <ph id="ph3">`long`</ph> <ph id="ph4">`double`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Microsoft specific: The representation of <ph id="ph1">`long double`</ph> and <ph id="ph2">`double`</ph> is identical.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`long double`</ph> and <ph id="ph2">`double`</ph> are separate types.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`long`</ph> <ph id="ph2">`double`</ph> is a floating point type that is larger than or equal to type <ph id="ph3">`double`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following table lists the amount of storage required for fundamental types in Microsoft C++.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Sizes of Fundamental Types</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Size</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`char`</ph>, <ph id="ph2">`unsigned char`</ph>, <ph id="ph3">`signed char`</ph>,</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>1 byte</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`short`</ph>, <ph id="ph2">`unsigned short`</ph>, <ph id="ph3">`wchar_t`</ph>,</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>2 bytes</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`__int32`</ph>, <ph id="ph2">`int`</ph>, <ph id="ph3">`unsigned int`</ph>, <ph id="ph4">`long`</ph>,</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>4 bytes</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`__int64`</ph>, <ph id="ph2">`long double`</ph>,</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>8 bytes</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Data Type Ranges<ept id="p1">](../cpp/data-type-ranges.md)</ept> for a summary of the range of values of each type.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more information about type conversion, see <bpt id="p1">[</bpt>Standard Conversions<ept id="p1">](../cpp/standard-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Data Type Ranges</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>