<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">97367431081c46e5e1d299e76f7d471bb760a4b0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\reference\concurrency-namespace-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa5269f9df2fe76ac23ec312ad62988d08a1335b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f8b06e484d1d3c697e65ae58ffe138326f057068</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>concurrency namespace functions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>concurrency namespace functions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Alloc</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>CreateResourceManager</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>DisableTracing</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>EnableTracing</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Free</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>GetExecutionContextId</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>GetOSVersion</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>GetProcessorCount</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>GetProcessorNodeCount</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>GetSchedulerId</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Trace_agents_register_name</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>asend</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>cancel_current_task</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>clear</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>create_async</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>create_task</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>get_ambient_scheduler</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>internal_assign_iterators</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>interruption_point</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>is_current_task_group_canceling</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>make_choice</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>make_greedy_join</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>make_join</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>make_task</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>parallel_buffered_sort</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>parallel_for</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>parallel_for_each</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>parallel_invoke</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>parallel_radixsort</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>parallel_reduce</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>parallel_sort</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>parallel_transform</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>receive</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>run_with_cancellation_token</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>send</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>set_ambient_scheduler</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>set_task_execution_resources</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>swap</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>task_from_exception</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>task_from_result</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>try_receive</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>wait</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>when_all</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>when_any</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Alloc</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Allocates a block of memory of the size specified from the Concurrency Runtime Caching Suballocator.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The number of bytes of memory to allocate.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A pointer to newly allocated memory.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about which scenarios in your application could benefit from using the Caching Suballocator, see <bpt id="p1">[</bpt>Task Scheduler<ept id="p1">](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>asend</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>An asynchronous send operation, which schedules a task to propagate the data to the target block.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The type of the data to be sent.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the target to which data is sent.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A reference to the data to be sent.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>if the message was accepted before the method returned, <ph id="ph1">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Message Passing Functions<ept id="p1">](../../../parallel/concrt/message-passing-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>cancel_current_task</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Cancels the currently executing task.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This function can be called from within the body of a task to abort the task's execution and cause it to enter the <ph id="ph1">`canceled`</ph> state.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It is not a supported scenario to call this function if you are not within the body of a <ph id="ph1">`task`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Doing so will result in undefined behavior such as a crash or a hang in your application.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>clear</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Clears the concurrent queue, destroying any currently enqueued elements.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This method is not concurrency-safe.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>create_async</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Creates a Windows Runtime asynchronous construct based on a user supplied lambda or function object.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The return type of <ph id="ph1">`create_async`</ph> is one of either <ph id="ph2">`IAsyncAction^`</ph>, <ph id="ph3">`IAsyncActionWithProgress&lt;TProgress&gt;^`</ph>, <ph id="ph4">`IAsyncOperation&lt;TResult&gt;^`</ph>, or <ph id="ph5">`IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^`</ph> based on the signature of the lambda passed to the method.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The lambda or function object from which to create a Windows Runtime asynchronous construct.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>An asynchronous construct represented by an IAsyncAction^, IAsyncActionWithProgress<ph id="ph1">\&lt;</ph>TProgress&gt;^, IAsyncOperation<ph id="ph2">\&lt;</ph>TResult&gt;^, or an IAsyncOperationWithProgress<ph id="ph3">\&lt;</ph>TResult, TProgress&gt;^.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The interface returned depends on the signature of the lambda passed into the function.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The return type of the lambda determines whether the construct is an action or an operation.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Lambdas that return void cause the creation of actions.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Lambdas that return a result of type <ph id="ph1">`TResult`</ph> cause the creation of operations of TResult.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The lambda may also return a <ph id="ph1">`task&lt;TResult&gt;`</ph> which encapsulates the aysnchronous work within itself or is the continuation of a chain of tasks that represent the asynchronous work.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In this case, the lambda itself is executed inline, since the tasks are the ones that execute asynchronously, and the return type of the lambda is unwrapped to produce the asynchronous construct returned by <ph id="ph1">`create_async`</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This implies that a lambda that returns a task<ph id="ph1">\&lt;</ph>void&gt; will cause the creation of actions, and a lambda that returns a task<ph id="ph2">\&lt;</ph>TResult&gt; will cause the creation of operations of TResult.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The lambda may take either zero, one or two arguments.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The valid arguments are <ph id="ph1">`progress_reporter&lt;TProgress&gt;`</ph> and <ph id="ph2">`cancellation_token`</ph>, in that order if both are used.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A lambda without arguments causes the creation of an asynchronous construct without the capability for progress reporting.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A lambda that takes a progress_reporter<ph id="ph1">\&lt;</ph>TProgress&gt; will cause <ph id="ph2">`create_async`</ph> to return an asynchronous construct which reports progress of type TProgress each time the <ph id="ph3">`report`</ph> method of the progress_reporter object is called.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A lambda that takes a cancellation_token may use that token to check for cancellation, or pass it to tasks that it creates so that cancellation of the asynchronous construct causes cancellation of those tasks.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If the body of the lambda or function object returns a result (and not a task<ph id="ph1">\&lt;</ph>TResult&gt;), the lamdba will be executed asynchronously within the process MTA in the context of a task the Runtime implicitly creates for it.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IAsyncInfo::Cancel`</ph> method will cause cancellation of the implicit task.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If the body of the lambda returns a task, the lamba executes inline, and by declaring the lambda to take an argument of type <ph id="ph1">`cancellation_token`</ph> you can trigger cancellation of any tasks you create within the lambda by passing that token in when you create them.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You may also use the <ph id="ph1">`register_callback`</ph> method on the token to cause the Runtime to invoke a callback when you call <ph id="ph2">`IAsyncInfo::Cancel`</ph> on the async operation or action produced..</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This function is only available to Windows Store apps.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>CreateResourceManager</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Returns an interface that represents the singleton instance of the Concurrency Runtime's Resource Manager.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The Resource Manager is responsible for assigning resources to schedulers that want to cooperate with each other.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`IResourceManager`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Multiple subsequent calls to this method will return the same instance of the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Each call to the method increments a reference count on the Resource Manager, and must be matched with a call to the <bpt id="p1">[</bpt>IResourceManager::Release<ept id="p1">](http://msdn.microsoft.com/en-us/5d1356ec-fbd3-4284-a361-1e9e20bbb522)</ept> method when your scheduler is done communicating with the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unsupported_os<ept id="p1">](unsupported-os-class.md)</ept> is thrown if the operating system is not supported by the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>create_task</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Creates a PPL <bpt id="p1">[</bpt>task<ept id="p1">](http://msdn.microsoft.com/en-us/5389e8a5-5038-40b6-844a-55e9b58ad35f)</ept> object.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>can be used anywhere you would have used a task constructor.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>It is provided mainly for convenience, because it allows use of the <ph id="ph1">`auto`</ph> keyword while creating tasks.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The type of the parameter from which the task is to be constructed.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The parameter from which the task is to be constructed.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This could be a lambda or function object, a <ph id="ph1">`task_completion_event`</ph> object, a different <ph id="ph2">`task`</ph> object, or a Windows::Foundation::IAsyncInfo interface if you are using tasks in your Windows Store app.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>A new task of type <ph id="ph1">`T`</ph>, that is inferred from <ph id="ph2">`_Param`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The first overload behaves like a task constructor that takes a single parameter.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The second overload associates the cancellation token provided with the newly created task.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you use this overload you are not allowed to pass in a different <ph id="ph1">`task`</ph> object as the first parameter.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The type of the returned task is inferred from the first parameter to the function.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Param`</ph> is a <ph id="ph2">`task_completion_event&lt;T&gt;`</ph>, a <ph id="ph3">`task&lt;T&gt;`</ph>, or a functor that returns either type <ph id="ph4">`T`</ph> or <ph id="ph5">`task&lt;T&gt;`</ph>, the type of the created task is <ph id="ph6">`task&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In a Windows Store app, if <ph id="ph1">`_Param`</ph> is of type Windows::Foundation::IAsyncOperation<ph id="ph2">\&lt;</ph>T&gt;^ or Windows::Foundation::IAsyncOperationWithProgress<ph id="ph3">\&lt;</ph>T,P&gt;^, or a functor that returns either of those types, the created task will be of type <ph id="ph4">`task&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Param`</ph> is of type Windows::Foundation::IAsyncAction^ or Windows::Foundation::IAsyncActionWithProgress<ph id="ph2">\&lt;</ph>P&gt;^, or a functor that returns either of those types, the created task will have type <ph id="ph3">`task&lt;void&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>DisableTracing</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Disables tracing in the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This function is deprecated because ETW tracing is unregistered by default.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>If tracing was correctly disabled, <ph id="ph1">`S_OK`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>If tracing was not previously initiated, <ph id="ph1">`E_NOT_STARTED`</ph> is returned</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>EnableTracing</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Enables tracing in the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This function is deprecated because ETW tracing is now on by default.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>If tracing was correctly initiated, <ph id="ph1">`S_OK`</ph> is returned; otherwise, <ph id="ph2">`E_NOT_STARTED`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Free</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Releases a block of memory previously allocated by the <ph id="ph1">`Alloc`</ph> method to the Concurrency Runtime Caching Suballocator.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>A pointer to memory previously allocated by the <ph id="ph1">`Alloc`</ph> method which is to be freed.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If the parameter <ph id="ph1">`_PAllocation`</ph> is set to the value <ph id="ph2">`NULL`</ph>, this method will ignore it and return immediately.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>For more information about which scenarios in your application could benefit from using the Caching Suballocator, see <bpt id="p1">[</bpt>Task Scheduler<ept id="p1">](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>get_ambient_scheduler</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>GetExecutionContextId</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier that can be assigned to an execution context that implements the <ph id="ph1">`IExecutionContext`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>A unique identifier for an execution context.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Use this method to obtain an identifier for your execution context before you pass an <ph id="ph1">`IExecutionContext`</ph> interface as a parameter to any of the methods offered by the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>GetOSVersion</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Returns the operating system version.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>An enumerated value representing the operating system.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unsupported_os<ept id="p1">](unsupported-os-class.md)</ept> is thrown if the operating system is not supported by the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>GetProcessorCount</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Returns the number of hardware threads on the underlying system.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The number of hardware threads.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unsupported_os<ept id="p1">](unsupported-os-class.md)</ept> is thrown if the operating system is not supported by the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>GetProcessorNodeCount</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Returns the number of NUMA nodes or processor packages on the underlying system.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The number of NUMA nodes or processor packages.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If the system contains more NUMA nodes than processor packages, the number of NUMA nodes is returned, otherwise, the number of processor packages is returned.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unsupported_os<ept id="p1">](unsupported-os-class.md)</ept> is thrown if the operating system is not supported by the Concurrency Runtime.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>GetSchedulerId</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier that can be assigned to a scheduler that implements the <ph id="ph1">`IScheduler`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A unique identifier for a scheduler.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Use this method to obtain an identifier for your scheduler before you pass an <ph id="ph1">`IScheduler`</ph> interface as a parameter to any of the methods offered by the Resource Manager.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>internal_assign_iterators</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>interruption_point</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Creates an interruption point for cancellation.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>If a cancellation is in progress in the context where this function is called, this will throw an internal exception that aborts the execution of the currently executing parallel work.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If cancellation is not in progress, the function does nothing.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You should not catch the internal cancellation exception thrown by the <ph id="ph1">`interruption_point()`</ph> function.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The exception will be caught and handled by the runtime, and catching it may cause your program to behave abnormally.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>is_current_task_group_canceling</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Returns an indication of whether the task group which is currently executing inline on the current context is in the midst of an active cancellation (or will be shortly).</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Note that if there is no task group currently executing inline on the current context, <ph id="ph1">`false`</ph> will be returned.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>if the task group which is currently executing is canceling, <ph id="ph1">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Cancellation<ept id="p1">](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation)</ept>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>make_choice</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`choice`</ph> messaging block from an optional <ph id="ph2">`Scheduler`</ph> or <ph id="ph3">`ScheduleGroup`</ph> and two or more input sources.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The message block type of the first source.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The message block type of the second source.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object within which the propagation task for the <ph id="ph2">`choice`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The first source.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The second source.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Additional sources.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ScheduleGroup`</ph> object within which the propagation task for the <ph id="ph2">`choice`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object used is implied by the schedule group.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`choice`</ph> message block with two or more input sources.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>make_greedy_join</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`greedy multitype_join`</ph> messaging block from an optional <ph id="ph2">`Scheduler`</ph> or <ph id="ph3">`ScheduleGroup`</ph> and two or more input sources.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The message block type of the first source.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The message block type of the second source.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object within which the propagation task for the <ph id="ph2">`multitype_join`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The first source.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The second source.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Additional sources.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ScheduleGroup`</ph> object within which the propagation task for the <ph id="ph2">`multitype_join`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object used is implied by the schedule group.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`greedy multitype_join`</ph> message block with two or more input sources.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>make_join</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`non_greedy multitype_join`</ph> messaging block from an optional <ph id="ph2">`Scheduler`</ph> or <ph id="ph3">`ScheduleGroup`</ph> and two or more input sources.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The message block type of the first source.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The message block type of the second source.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object within which the propagation task for the <ph id="ph2">`multitype_join`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The first source.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The second source.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Additional sources.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ScheduleGroup`</ph> object within which the propagation task for the <ph id="ph2">`multitype_join`</ph> messaging block is scheduled.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Scheduler`</ph> object used is implied by the schedule group.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`non_greedy multitype_join`</ph> message block with two or more input sources.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>make_task</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>A factory method for creating a <ph id="ph1">`task_handle`</ph> object.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The type of the function object that will be invoked to execute the work represented by the <ph id="ph1">`task_handle`</ph> object.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The function that will be invoked to execute the work represented by the <ph id="ph1">`task_handle`</ph> object.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This may be a lambda functor, a pointer to a function, or any object that supports a version of the function call operator with the signature <ph id="ph1">`void operator()()`</ph>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`task_handle`</ph> object.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>This function is useful when you need to create a <ph id="ph1">`task_handle`</ph> object with a lambda expression, because it allows you to create the object without knowing the true type of the lambda functor.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>parallel_buffered_sort</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order, or according to an ordering criterion specified by a binary predicate, in parallel.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This function is semantically similar to <ph id="ph1">`std::sort`</ph> in that it is a compare-based, unstable, in-place sort except that it needs <ph id="ph2">`O(n)`</ph> additional space, and requires default initialization for the elements being sorted.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The iterator type of the input range.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The type of an STL compatible memory allocator.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The type of the binary comparator.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>An instance of an STL compatible memory allocator.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>A user-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <ph id="ph1">`true`</ph> when satisfied and <ph id="ph2">`false`</ph> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>This comparator function must impose a strict weak ordering on pairs of elements from the sequence.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The mimimum size of a chunk that will be split into two for parallel execution.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>All overloads require <ph id="ph1">`n * sizeof(T)`</ph> additional space, where <ph id="ph2">`n`</ph> is the number of elements to be sorted, and <ph id="ph3">`T`</ph> is the element type.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>In most cases parallel_buffered_sort will show an improvement in performance over <bpt id="p1">[</bpt>parallel_sort<ept id="p1">](concurrency-namespace-functions.md)</ept>, and you should use it over parallel_sort if you have the memory available.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>If you do not supply a binary comparator <ph id="ph1">`std::less`</ph> is used as the default, which requires the element type to provide the operator <ph id="ph2">`operator&lt;()`</ph>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>If you do not supply an allocator type or instance, the STL memory allocator <ph id="ph1">`std::allocator&lt;T&gt;`</ph> is used to allocate the buffer.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The algorithm divides the input range into two chunks and successively divides each chunk into two sub-chunks for execution in parallel.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The optional argument <ph id="ph1">`_Chunk_size`</ph> can be used to indicate to the algorithm that it should handles chunks of size &lt; <ph id="ph2">`_Chunk_size`</ph> serially.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>parallel_for</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>iterates over a range of indices and executes a user-supplied function at each iteration, in parallel.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The type of the index being used for the iteration.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The type of the function that will be executed at each iteration.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The type of the partitioner that is used to partition the supplied range.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The first index to be included in the iteration.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The index one past the last index to be included in the iteration.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The value by which to step when iterating from <ph id="ph1">`first`</ph> to <ph id="ph2">`last`</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The step must be positive.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>invalid_argument<ept id="p1">](../../../standard-library/invalid-argument-class.md)</ept> is thrown if the step is less than 1.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The function to be executed at each iteration.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>This may be a lambda expression, a function pointer, or any object that supports a version of the function call operator with the signature <ph id="ph1">`void operator()(``_Index_type``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>A reference to the partitioner object.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The argument can be one of <ph id="ph1">`const`</ph><bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept><ph id="ph2">`&amp;`</ph>, <ph id="ph3">`const`</ph><bpt id="p2">[</bpt>static_partitioner<ept id="p2">](static-partitioner-class.md)</ept><ph id="ph4">`&amp;`</ph>, <ph id="ph5">`const`</ph><bpt id="p3">[</bpt>simple_partitioner<ept id="p3">](simple-partitioner-class.md)</ept><ph id="ph6">`&amp;`</ph> or <bpt id="p4">[</bpt>affinity_partitioner<ept id="p4">](affinity-partitioner-class.md)</ept><ph id="ph7">`&amp;`</ph> If an <bpt id="p5">[</bpt>affinity_partitioner<ept id="p5">](affinity-partitioner-class.md)</ept> object is used, the reference must be a non-const l-value reference, so that the algorithm can store state for future loops to re-use.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>parallel_for_each</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>applies a specified function to each element within a range, in parallel.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>It is semantically equivalent to the <ph id="ph1">`for_each`</ph> function in the <ph id="ph2">`std`</ph> namespace, except that iteration over the elements is performed in parallel, and the order of iteration is unspecified.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The argument <ph id="ph1">`_Func`</ph> must support a function call operator of the form <ph id="ph2">`operator()(T)`</ph> where the parameter <ph id="ph3">`T`</ph> is the item type of the container being iterated over.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The type of the iterator being used to iterate over the container.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The type of the function that will be applied to each element within the range.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>An iterator addressing the position of the first element to be included in parallel iteration.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>An iterator addressing the position one past the final element to be included in parallel iteration.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>A user-defined function object that is applied to each element in the range.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>A reference to the partitioner object.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The argument can be one of <ph id="ph1">`const`</ph><bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept><ph id="ph2">`&amp;`</ph>, <ph id="ph3">`const`</ph><bpt id="p2">[</bpt>static_partitioner<ept id="p2">](static-partitioner-class.md)</ept><ph id="ph4">`&amp;`</ph>, <ph id="ph5">`const`</ph><bpt id="p3">[</bpt>simple_partitioner<ept id="p3">](simple-partitioner-class.md)</ept><ph id="ph6">`&amp;`</ph> or <bpt id="p4">[</bpt>affinity_partitioner<ept id="p4">](affinity-partitioner-class.md)</ept><ph id="ph7">`&amp;`</ph> If an <bpt id="p5">[</bpt>affinity_partitioner<ept id="p5">](affinity-partitioner-class.md)</ept> object is used, the reference must be a non-const l-value reference, so that the algorithm can store state for future loops to re-use.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept> will be used for the overload without an explicit partitioner.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>For iterators that do not support random access, only <bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept> is supported.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>parallel_invoke</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Executes the function objects supplied as parameters in parallel, and blocks until they have finished executing.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Each function object could be a lambda expression, a pointer to function, or any object that supports the function call operator with the signature <ph id="ph1">`void operator()()`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The type of the first function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The type of the second function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The type of the third function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The type of the fourth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The type of the fifth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The type of the sixth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The type of the seventh function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>The type of the eighth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The type of the ninth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The type of the tenth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The first function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>The second function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>The third function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The fourth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>The fifth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The sixth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The seventh function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The eighth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The ninth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The tenth function object to be executed in parallel.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Note that one or more of the function objects supplied as parameters may execute inline on the calling context.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If one or more of the function objects passed as parameters to this function throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to <ph id="ph1">`parallel_invoke`</ph>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>parallel_radixsort</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Arranges elements in a specified range into an non descending order using a radix sorting algorithm.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>This is a stable sort function which requires a projection function that can project elements to be sorted into unsigned integer-like keys.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Default initialization is required for the elements being sorted.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The iterator type of the input range.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The type of an STL compatible memory allocator.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The type of the projection function.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>An instance of an STL compatible memory allocator.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>A user-defined projection function object that converts an element into an integral value.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>The mimimum size of a chunk that will be split into two for parallel execution.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>All overloads require <ph id="ph1">`n * sizeof(T)`</ph> additional space, where <ph id="ph2">`n`</ph> is the number of elements to be sorted, and <ph id="ph3">`T`</ph> is the element type.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>An unary projection functor with the signature <ph id="ph1">`I _Proj_func(T)`</ph> is required to return a key when given an element, where <ph id="ph2">`T`</ph> is the element type and <ph id="ph3">`I`</ph> is an unsigned integer-like type.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>If you do not supply a projection function, a default projection function which simply returns the element is used for integral types.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The function will fail to compile if the element is not an integral type in the absence of a projection function.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>If you do not supply an allocator type or instance, the STL memory allocator <ph id="ph1">`std::allocator&lt;T&gt;`</ph> is used to allocate the buffer.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The algorithm divides the input range into two chunks and successively divides each chunk into two sub-chunks for execution in parallel.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>The optional argument <ph id="ph1">`_Chunk_size`</ph> can be used to indicate to the algorithm that it should handles chunks of size &lt; <ph id="ph2">`_Chunk_size`</ph> serially.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>parallel_reduce</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Computes the sum of all elements in a specified range by computing successive partial sums, or computes the result of successive partial results similarly obtained from using a specified binary operation other than sum, in parallel.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>is semantically similar to <ph id="ph1">`std::accumulate`</ph>, except that it requires the binary operation to be associative, and requires an identity value instead of an initial value.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The iterator type of input range.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The type of the symmetric reduction function.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>This must be a function type with signature <ph id="ph1">`_Reduce_type _Sym_fun(_Reduce_type, _Reduce_type)`</ph>, where _Reduce_type is the same as the identity type and the result type of the reduction.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>For the third overload, this should be consistent with the output type of <ph id="ph1">`_Range_reduce_fun`</ph>.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The type that the input will reduce to, which can be different from the input element type.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>The return value and identity value will has this type.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The type of the range reduction function.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>This must be a function type with signature <ph id="ph1">`_Reduce_type _Range_fun(_Forward_iterator, _Forward_iterator, _Reduce_type)`</ph>, _Reduce_type is the same as the identity type and the result type of the reduction.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the range to be reduced.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the element that is one position beyond the final element in the range to be reduced.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The identity value <ph id="ph1">`_Identity`</ph> is of the same type as the result type of the reduction and also the <ph id="ph2">`value_type`</ph> of the iterator for the first and second overloads.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>For the third overload, the identity value must have the same type as the result type of the reduction, but can be different from the <ph id="ph1">`value_type`</ph> of the iterator.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>It must have an appropriate value such that the range reduction operator <ph id="ph1">`_Range_fun`</ph>, when applied to a range of a single element of type <ph id="ph2">`value_type`</ph> and the identity value, behaves like a type cast of the value from type <ph id="ph3">`value_type`</ph> to the identity type.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The symmetric function that will be used in the second of the reduction.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Refer to Remarks for more information.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>The function that will be used in the first phase of the reduction.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Refer to Remarks for more information.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The result of the reduction.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>To perform a parallel reduction, the function divides the range into chunks based on the number of workers available to the underlying scheduler.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>The reduction takes place in two phases, the first phase performs a reduction within each chunk, and the second phase performs a reduction between the partial results from each chunk.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The first overload requires that the iterator's <ph id="ph1">`value_type`</ph>, <ph id="ph2">`T`</ph>, be the same as the identity value type as well as the reduction result type.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The element type T must provide the operator <ph id="ph1">`T T::operator + (T)`</ph> to reduce elements in each chunk.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The same operator is used in the second phase as well.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The second overload also requires that the iterator's <ph id="ph1">`value_type`</ph> be the same as the identity value type as well as the reduction result type.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The supplied binary operator <ph id="ph1">`_Sym_fun`</ph> is used in both reduction phases, with the identity value as the initial value for the first phase.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>For the third overload, the identity value type must be the same as the reduction result type, but the iterator's <ph id="ph1">`value_type`</ph> may be different from both.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The range reduction function <ph id="ph1">`_Range_fun`</ph> is used in the first phase with the identity value as the initial value, and the binary function <ph id="ph2">`_Sym_reduce_fun`</ph> is applied to sub results in the second phase.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>parallel_sort</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Arranges the elements in a specified range into a nondescending order, or according to an ordering criterion specified by a binary predicate, in parallel.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>This function is semantically similar to <ph id="ph1">`std::sort`</ph> in that it is a compare-based, unstable, in-place sort.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The iterator type of the input range.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The type of the binary comparison functor.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position of the first element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>A random-access iterator addressing the position one past the final element in the range to be sorted.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>A user-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>A binary predicate takes two arguments and returns <ph id="ph1">`true`</ph> when satisfied and <ph id="ph2">`false`</ph> when not satisfied.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>This comparator function must impose a strict weak ordering on pairs of elements from the sequence.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The mimimum size of a chunk that will be split into two for parallel execution.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The first overload uses the the binary comparator <ph id="ph1">`std::less`</ph>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The second overloaded uses the supplied binary comparator that should have the signature <ph id="ph1">`bool _Func(T, T)`</ph> where <ph id="ph2">`T`</ph> is the type of the elements in the input range.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The algorithm divides the input range into two chunks and successively divides each chunk into two sub-chunks for execution in parallel.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The optional argument <ph id="ph1">`_Chunk_size`</ph> can be used to indicate to the algorithm that it should handles chunks of size &lt; <ph id="ph2">`_Chunk_size`</ph> serially.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>parallel_transform</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Applies a specified function object to each element in a source range, or to a pair of elements from two source ranges, and copies the return values of the function object into a destination range, in parallel.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>This functional is semantically equivalent to <ph id="ph1">`std::transform`</ph>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The type of the first or only input iterator.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The type of the output iterator.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The type of the unary functor to be executed on each element in the input range.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The type of second input iterator.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The type of the binary functor executed pairwise on elements from the two source ranges.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the first or only source range to be operated on.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position one past the final element in the first or only source range to be operated on.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position of the first element in the destination range.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>A user-defined unary function object that is applied to each element in the source range.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>A reference to the partitioner object.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The argument can be one of <ph id="ph1">`const`</ph><bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept><ph id="ph2">`&amp;`</ph>, <ph id="ph3">`const`</ph><bpt id="p2">[</bpt>static_partitioner<ept id="p2">](static-partitioner-class.md)</ept><ph id="ph4">`&amp;`</ph>, <ph id="ph5">`const`</ph><bpt id="p3">[</bpt>simple_partitioner<ept id="p3">](simple-partitioner-class.md)</ept><ph id="ph6">`&amp;`</ph> or <bpt id="p4">[</bpt>affinity_partitioner<ept id="p4">](affinity-partitioner-class.md)</ept><ph id="ph7">`&amp;`</ph> If an <bpt id="p5">[</bpt>affinity_partitioner<ept id="p5">](affinity-partitioner-class.md)</ept> object is used, the reference must be a non-const l-value reference, so that the algorithm can store state for future loops to re-use.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the position of the first element in the second source range to be operated on.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>A user-defined binary function object that is applied pairwise, in a forward order, to the two source ranges.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the position one past the final element in the destination range that is receiving the output elements transformed by the function object.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept> will be used for the overloads without an explicit partitioner argument.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>For iterators that do not support random access, only <bpt id="p1">[</bpt>auto_partitioner<ept id="p1">](auto-partitioner-class.md)</ept> is supported.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The overloads that take the argument <ph id="ph1">`_Unary_op`</ph> transform the input range into the output range by applying the unary functor to each element in the input range.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>must support the function call operator with signature <ph id="ph1">`operator()(T)`</ph> where <ph id="ph2">`T`</ph> is the value type of the range being iterated over.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The overloads that take the argument <ph id="ph1">`_Binary_op`</ph> transform two input ranges into the output range by applying the binary functor to one element from the first input range and one element from the second input range.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>must support the function call operator with signature <ph id="ph1">`operator()(T, U)`</ph> where <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph> are value types of the two input iterators.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Parallel Algorithms<ept id="p1">](../../../parallel/concrt/parallel-algorithms.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>receive</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>A general receive implementation, allowing a context to wait for data from exactly one source and filter the values that are accepted.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The payload type.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the source from which data is expected.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The maximum time for which the method should for the data, in milliseconds.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>A filter function which determines whether messages should be accepted.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>A value from the source, of the payload type.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>If the parameter <ph id="ph1">`_Timeout`</ph> has a value other than the constant <ph id="ph2">`COOPERATIVE_TIMEOUT_INFINITE`</ph>, the exception <bpt id="p1">[</bpt>operation_timed_out<ept id="p1">](operation-timed-out-class.md)</ept> is thrown if the specified amount of time expires before a message is received.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>If you want a zero length timeout, you should use the <bpt id="p1">[</bpt>try_receive<ept id="p1">](concurrency-namespace-functions.md)</ept> function, as opposed to calling <ph id="ph1">`receive`</ph> with a timeout of <ph id="ph2">`0`</ph> (zero), as it is more efficient and does not throw exceptions on timeouts.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Message Passing Functions<ept id="p1">](../../../parallel/concrt/message-passing-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>run_with_cancellation_token</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Executes a function object immediately and synchronously in the context of a given cancellation token.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The type of the function object that will be invoked.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>The function object which will be executed.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>This object must support the function call operator with a signature of void(void).</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The cancellation token which will control implicit cancellation of the function object.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`cancellation_token::none()`</ph> if you want the function execute without any possibility of implicit cancellation from a parent task group being canceled.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Any interruption points in the function object will be triggered when the <ph id="ph1">`cancellation_token`</ph> is canceled.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The explicit token <ph id="ph1">`_Ct`</ph> will isolate this <ph id="ph2">`_Func`</ph> from parent cancellation if the parent has a different token or no token.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>send</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>A synchronous send operation, which waits until the target either accepts or declines the message.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The payload type.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the target to which data is sent.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>A reference to the data to be sent.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>if the message was accepted, <ph id="ph1">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Message Passing Functions<ept id="p1">](../../../parallel/concrt/message-passing-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>set_ambient_scheduler</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>set_task_execution_resources</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Restricts the execution resources used by the Concurrency Runtime internal worker threads to the affinity set specified.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>It is valid to call this method only before the Resource Manager has been created, or between two Resource Manager lifetimes.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>It can be invoked multiple times as long as the Resource Manager does not exist at the time of invocation.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>After an affinity limit has been set, it remains in effect until the next valid call to the <ph id="ph1">`set_task_execution_resources`</ph> method.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The affinity mask provided need not be a subset of the process affinity mask.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The process affinity will be updated if necessary.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>The affinity mask that the Concurrency Runtime worker threads are to be restricted to.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Use this method on a system with greater than 64 hardware threads only if you want to limit the Concurrency Runtime to a subset of the current processor group.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In general, you should use the version of the method that accepts an array of group affinities as a parameter, to restrict affinity on machines with greater than 64 hardware threads.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The number of <ph id="ph1">`GROUP_AFFINITY`</ph> entries in the array specified by the parameter <ph id="ph2">`_PGroupAffinity`</ph>.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">`GROUP_AFFINITY`</ph> entries.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The method will throw an <bpt id="p1">[</bpt>invalid_operation<ept id="p1">](invalid-operation-class.md)</ept> exception if a Resource Manager is present at the time it is invoked, and an <bpt id="p2">[</bpt>invalid_argument<ept id="p2">](../../../standard-library/invalid-argument-class.md)</ept> exception if the affinity specified results in an empty set of resources.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The version of the method that takes an array of group affinities as a parameter should only be used on operating systems with version Windows 7 or higher.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Otherwise, an <bpt id="p1">[</bpt>invalid_operation<ept id="p1">](invalid-operation-class.md)</ept> exception is thrown.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Programatically modifying the process affinity after this method has been invoked will not cause the Resource Manager to re-evaluate the affinity it is restricted to.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Therefore, all changes to process affinity should be made before calling this method.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>swap</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Exchanges the elements of two <ph id="ph1">`concurrent_vector`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The data type of the elements stored in the concurrent vectors.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The allocator type of the concurrent vectors.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The concurrent vector whose elements are to be exchanged with those of the concurrent vector <ph id="ph1">`_B`</ph>.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>The concurrent vector providing the elements to be swapped, or the vector whose elements are to be exchanged with those of the concurrent vector <ph id="ph1">`_A`</ph>.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The template function is an algorithm specialized on the container class <ph id="ph1">`concurrent_vector`</ph> to execute the member function <ph id="ph2">`_A`</ph>.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>concurrent_vector::swap<ept id="p1">](concurrent-vector-class.md#swap)</ept>( <ph id="ph1">`_B`</ph>).</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>These are instances of the partial ordering of function templates by the compiler.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>When template functions are overloaded in such a way that the match of the template with the function call is not unique, then the compiler will select the most specialized version of the template function.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The general version of the template function, <ph id="ph1">`template &lt;class T&gt; void swap(T&amp;, T&amp;)`</ph>, in the algorithm class works by assignment and is a slow operation.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>The specialized version in each container is much faster as it can work with the internal representation of the container class.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>This method is not concurrency-safe.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>You must ensure that no other threads are performing operations on either of the concurrent vectors when you call this method.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>task_from_exception</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>task_from_result</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>Trace_agents_register_name</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Associates the given name to the message block or agent in the ETW trace.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>The type of the object.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>This is typically a message block or an agent.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>A pointer to the message block or agent that is being named in the trace.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The name for the given object.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>try_receive</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>A general try-receive implementation, allowing a context to look for data from exactly one source and filter the values that are accepted.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the data is not ready, the method will return false.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The payload type</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the source from which data is expected.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>A reference to a location where the result will be placed.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>A filter function which determines whether messages should be accepted.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`bool`</ph> value indicating whether or not a payload was placed in <ph id="ph2">`_value`</ph>.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Message Passing Functions<ept id="p1">](../../../parallel/concrt/message-passing-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>wait</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>Pauses the current context for a specified amount of time.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>The number of milliseconds the current context should be paused for.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`_Milliseconds`</ph> parameter is set to the value <ph id="ph2">`0`</ph>, the current context should yield execution to other runnable contexts before continuing.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>If this method is called on a Concurrency Runtime scheduler context, the scheduler will find a different context to run on the underlying resource.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Because the scheduler is cooperative in nature, this context cannot resume exactly after the number of milliseconds specified.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>If the scheduler is busy executing other tasks that do not cooperatively yield to the scheduler, the wait period could be indefinite.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>when_all</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Creates a task that will complete successfully when all of the tasks supplied as arguments complete successfully.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The type of the input iterator.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The position of the first element in the range of elements to be combined into the resulting task.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>The position of the first element beyond the range of elements to be combined into the resulting task.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>A task that completes sucessfully when all of the input tasks have completed successfully.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>If the input tasks are of type <ph id="ph1">`T`</ph>, the output of this function will be a <ph id="ph2">`task&lt;std::vector&lt;T&gt;&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>If the input tasks are of type <ph id="ph1">`void`</ph> the output task will also be a <ph id="ph2">`task&lt;void&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>is a non-blocking function that produces a <ph id="ph1">`task`</ph> as its result.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">[</bpt>task::wait<ept id="p1">](task-class.md#wait)</ept>, it is safe to call this function in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA (Application STA) thread.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <bpt id="p1">[</bpt>task::get<ept id="p1">](task-class.md#get)</ept> or <ph id="ph1">`task::wait`</ph> on that task.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism<ept id="p1">](../../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>when_any</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The type of the input iterator.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The position of the first element in the range of elements to be combined into the resulting task.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>The position of the first element beyond the range of elements to be combined into the resulting task.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The cancellation token which controls cancellation of the returned task.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>If you do not provide a cancellation token, the resulting task will receive the cancellation token of the task that causes it to complete.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>A task that completes successfully when any one of the input tasks has completed successfully.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>If the input tasks are of type <ph id="ph1">`T`</ph>, the output of this function will be a <ph id="ph2">`task&lt;std::pair&lt;T, size_t&gt;&gt;&gt;`</ph>, where the first element of the pair is the result of the completing task, and the second element is the index of the task that finished.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>If the input tasks are of type <ph id="ph1">`void`</ph> the output is a <ph id="ph2">`task&lt;size_t&gt;`</ph>, where the result is the index of the completing task.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>is a non-blocking function that produces a <ph id="ph1">`task`</ph> as its result.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">[</bpt>task::wait<ept id="p1">](task-class.md#wait)</ept>, it is safe to call this function in a <ph id="ph1">[!INCLUDE[win8_appname_long](../../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA (Application STA) thread.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism<ept id="p1">](../../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>concurrency Namespace</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>