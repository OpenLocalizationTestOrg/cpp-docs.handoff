<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ace9230f434545fdea532d4e42ae044bd202acab</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\vector-bool-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9436e6a02ed01219407a5a20e472f0d478b66f5b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c76669e6c01ba54e9b989b8db12e20c23f228a4a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>vector<ph id="ph1">&amp;lt;</ph>bool<ph id="ph2">&amp;gt;</ph> Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>vector<ph id="ph1">&amp;lt;</ph>bool<ph id="ph2">&amp;gt;</ph> Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`vector&lt;bool&gt;`</ph> class is a partial specialization of <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept> for elements of type <ph id="ph2">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It has an allocator for the underlying type that's used by the specialization, which provides space optimization by storing one <ph id="ph1">`bool`</ph> value per bit.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This class template specialization behaves like vector, except for the differences explained in this article.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Operations that deal with the <ph id="ph1">`bool`</ph> type correspond to values in the container storage.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`allocator_traits::construct`</ph> is not used to construct these values.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>const_pointer<ept id="p1">](#vector_lt_bool_gt___const_pointer)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A typedef to a <ph id="ph1">`const_iterator`</ph> that can serve as a constant pointer to a Boolean element of the <ph id="ph2">`vector&lt;bool&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>const_reference<ept id="p1">](#vector_lt_bool_gt___const_reference)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A typedef for <ph id="ph1">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>After initialization, it does not observe updates to the original value.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>pointer<ept id="p1">](#vector_lt_bool_gt___pointer)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A typedef to an <ph id="ph1">`iterator`</ph> that can serve as a pointer to a Boolean element of the <ph id="ph2">`vector&lt;bool&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>flip<ept id="p1">](#vector_lt_bool_gt___flip)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Reverses all bits in the <ph id="ph1">`vector&lt;bool&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>swap<ept id="p1">](#vector_lt_bool_gt___swap)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Exchanges the elements of two <ph id="ph1">`vector&lt;bool&gt;`</ph>s.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>operator&amp;#91;&amp;#93;<ept id="p1">](#vector_lt_bool_gt___operator_at)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Returns a simulated reference to the <ph id="ph1">`vector&lt;bool&gt;`</ph> element at a specified position.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Functions the same as the unspecialized <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept>::at function, except that it uses the proxy class <bpt id="p2">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt;::reference<ept id="p2">](#vector_lt_bool_gt___reference_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Also see <bpt id="p1">[</bpt>operator&amp;#91;&amp;#93;<ept id="p1">](#vector_lt_bool_gt___operator_at)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Functions the same as the unspecialized <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept>::front function, except that it uses the proxy class <bpt id="p2">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt;::reference<ept id="p2">](#vector_lt_bool_gt___reference_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Also see <bpt id="p1">[</bpt>operator&amp;#91;&amp;#93;<ept id="p1">](#vector_lt_bool_gt___operator_at)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Functions the same as the unspecialized <bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept>::back function, except that it uses the proxy class <bpt id="p2">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt;::reference<ept id="p2">](#vector_lt_bool_gt___reference_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Also see <bpt id="p1">[</bpt>operator&amp;#91;&amp;#93;<ept id="p1">](#vector_lt_bool_gt___operator_at)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Proxy Class</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt; reference Class<ept id="p1">](#vector_lt_bool_gt___reference_class)</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A class that acts as a proxy to simulate <ph id="ph1">`bool&amp;`</ph> behavior, and whose objects can provide references to elements (single bits) within a <ph id="ph2">`vector&lt;bool&gt;`</ph> object.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header<ept id="p1">**</ept>: <ph id="ph1">\&lt;</ph>vector&gt;</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> std</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___const_pointer"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::const_pointer</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A type that describes an object that can serve as a constant pointer to a Boolean element of the sequence contained by the <ph id="ph1">`vector&lt;bool&gt;`</ph> object.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___const_reference"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::const_reference</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A type that describes an object that can serve as a constant reference to a Boolean element of the sequence contained by the <ph id="ph1">`vector&lt;bool&gt;`</ph> object.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information and code examples, see <bpt id="p1">[</bpt>vector<ph id="ph1">&amp;lt;</ph>bool<ph id="ph2">&amp;gt;</ph>::reference::operator=<ept id="p1">](#vector_lt_bool_gt___reference_operator_eq)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___flip"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::flip</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Reverses all bits in a <ph id="ph1">`vector&lt;bool&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___operator_at"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::operator[]</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Returns a simulated reference to the <ph id="ph1">`vector&lt;bool&gt;`</ph> element at a specified position.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The position of the <ph id="ph1">`vector&lt;bool&gt;`</ph> element.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt;::reference<ept id="p1">](#vector_lt_bool_gt___reference_class)</ept> or <bpt id="p2">[</bpt>vector<ph id="ph2">\&lt;</ph>bool&gt;::const_reference<ept id="p2">](#vector_lt_bool_gt___const_reference)</ept> object that contains the value of the indexed element.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If the position specified is greater than or equal to the size of the container, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If you compile with <ph id="ph1">`_ITERATOR_DEBUG_LEVEL`</ph> set, a run-time error occurs if you attempt to access an element outside the bounds of the vector.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Checked Iterators<ept id="p1">](../standard-library/checked-iterators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This code example shows the correct use of <ph id="ph1">`vector&lt;bool&gt;::operator[]`</ph> and two common coding mistakes, which are commented out.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>These mistakes cause errors because the address of the <ph id="ph1">`vector&lt;bool&gt;::reference`</ph> object that <ph id="ph2">`vector&lt;bool&gt;::operator[]`</ph> returns cannot be taken.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___pointer"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::pointer</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A type that describes an object that can serve as a pointer to a Boolean element of the sequence contained by the <ph id="ph1">`vector&lt;bool&gt;`</ph> object.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___reference_class"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::reference Class</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`vector&lt;bool&gt;::reference`</ph> class is a proxy class provided by the <bpt id="p1">[</bpt>vector<ph id="ph2">\&lt;</ph>bool&gt; Class<ept id="p1">](../standard-library/vector-bool-class.md)</ept> to simulate <ph id="ph3">`bool&amp;`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A simulated reference is required because C++ does not natively allow direct references to bits.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`vector&lt;bool&gt;`</ph> uses only one bit per element, which can be referenced by using this proxy class.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, the reference simulation is not complete because certain assignments are not valid.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, because the address of the <ph id="ph1">`vector&lt;bool&gt;::reference`</ph> object cannot be taken, the following code that uses <bpt id="p1">[</bpt>vector<ph id="ph2">\&lt;</ph>bool&gt;::operator&amp;#91;&amp;#93;<ept id="p1">](#vector_lt_bool_gt___operator_at)</ept> is not correct:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___reference_flip"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::reference::flip</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Inverts the Boolean value of a referenced <bpt id="p1">[</bpt>vector<ph id="ph1">\&lt;</ph>bool&gt;<ept id="p1">](../standard-library/vector-bool-class.md)</ept> element.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___reference_operator_bool"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::reference::operator bool</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Provides an implicit conversion from <ph id="ph1">`vector&lt;bool&gt;::reference`</ph> to <ph id="ph2">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>```  operator bool() const;</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>reference&amp; operator=(const reference&amp; Right);</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>reference&amp; operator=(bool Val);</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="vector_lt_bool_gt___swap"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  vector<ph id="ph1">\&lt;</ph>bool&gt;::swap</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Static member function that exchanges two elements of Boolean vectors ( <ph id="ph1">`vector&lt;bool&gt;`</ph>) by using the proxy class <bpt id="p1">[</bpt>vector<ph id="ph2">\&lt;</ph>bool&gt;::reference<ept id="p1">](#vector_lt_bool_gt___reference_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The element to be exchanged with the <ph id="ph1">`Right`</ph> element.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The element to be exchanged with the <ph id="ph1">`Left`</ph> element.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This overload supports the special proxy requirements of <ph id="ph1">`vector&lt;bool&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>vector<ept id="p1">](../standard-library/vector-class.md)</ept>::swap has the same functionality as the single-argument overload of <ph id="ph1">`vector&lt;bool&gt;::swap()`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread Safety in the C++ Standard Library<ept id="p1">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>C++ Standard Library Reference<ept id="p1">](../standard-library/cpp-standard-library-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>