<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b0d346861e2862d214b0149fa4d302ff6dd1fbbe</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\unordered-map-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d19fda7634850ed127161e9f55fb0b8784540ddc</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1aec27ef1a64fa26566ea575c508e31e0af5168b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>unordered_map Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>unordered_map Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The template class describes an object that controls a varying-length sequence of elements of type <ph id="ph1">`std::pair&lt;const Key, Ty&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The sequence is weakly ordered by a hash function, which partitions the sequence into an ordered set of subsequences called buckets.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Within each bucket a comparison function determines whether any pair of elements has equivalent ordering.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Each element stores two objects, a sort key and a value.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The sequence is represented in a way that permits lookup, insertion, and removal of an arbitrary element with a number of operations that can be independent of the number of elements in the sequence (constant time), at least when all buckets are of roughly equal length.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the worst case, when all of the elements are in one bucket, the number of operations is proportional to the number of elements in the sequence (linear time).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Moreover, inserting an element invalidates no iterators, and removing an element invalidates only those iterators which point at the removed element.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The key type.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The mapped type.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The hash function object type.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The equality comparison function object type.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The allocator class.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Type Definition</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::allocator_type<ept id="p1">](#unordered_map__allocator_type)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The type of an allocator for managing storage.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::const_iterator<ept id="p1">](#unordered_map__const_iterator)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The type of a constant iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::const_local_iterator<ept id="p1">](#unordered_map__const_local_iterator)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The type of a constant bucket iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::const_pointer<ept id="p1">](#unordered_map__const_pointer)</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The type of a constant pointer to an element.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::const_reference<ept id="p1">](#unordered_map__const_reference)</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The type of a constant reference to an element.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::difference_type<ept id="p1">](#unordered_map__difference_type)</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The type of a signed distance between two elements.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::hasher<ept id="p1">](#unordered_map__hasher)</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The type of the hash function.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::iterator<ept id="p1">](#unordered_map__iterator)</ept></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The type of an iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::key_equal<ept id="p1">](#unordered_map__key_equal)</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The type of the comparison function.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::key_type<ept id="p1">](#unordered_map__key_type)</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The type of an ordering key.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::local_iterator<ept id="p1">](#unordered_map__local_iterator)</ept></source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The type of a bucket iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::mapped_type<ept id="p1">](#unordered_map__mapped_type)</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The type of a mapped value associated with each key.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::pointer<ept id="p1">](#unordered_map__pointer)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The type of a pointer to an element.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::reference<ept id="p1">](#unordered_map__reference)</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The type of a reference to an element.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::size_type<ept id="p1">](#unordered_map__size_type)</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The type of an unsigned distance between two elements.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::value_type<ept id="p1">](#unordered_map__value_type)</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The type of an element.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Member Function</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::at<ept id="p1">](#unordered_map__at)</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Finds an element with the specified key.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::begin<ept id="p1">](#unordered_map__begin)</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Designates the beginning of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::bucket<ept id="p1">](#unordered_map__bucket)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Gets the bucket number for a key value.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::bucket_count<ept id="p1">](#unordered_map__bucket_count)</ept></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Gets the number of buckets.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::bucket_size<ept id="p1">](#unordered_map__bucket_size)</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Gets the size of a bucket.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::cbegin<ept id="p1">](#unordered_map__cbegin)</ept></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Designates the beginning of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::cend<ept id="p1">](#unordered_map__cend)</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Designates the end of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::clear<ept id="p1">](#unordered_map__clear)</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Removes all elements.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::count<ept id="p1">](#unordered_map__count)</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Finds the number of elements matching a specified key.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::emplace<ept id="p1">](#unordered_map__emplace)</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Adds an element constructed in place.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::emplace_hint<ept id="p1">](#unordered_map__emplace_hint)</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Adds an element constructed in place, with hint.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::empty<ept id="p1">](#unordered_map__empty)</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Tests whether no elements are present.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::end<ept id="p1">](#unordered_map__end)</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Designates the end of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::equal_range<ept id="p1">](#unordered_map__equal_range)</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Finds range that matches a specified key.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::erase<ept id="p1">](#unordered_map__erase)</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Removes elements at specified positions.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::find<ept id="p1">](#unordered_map__find)</ept></source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Finds an element that matches a specified key.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::get_allocator<ept id="p1">](#unordered_map__get_allocator)</ept></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Gets the stored allocator object.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::hash_function<ept id="p1">](#unordered_map__hash_function)</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Gets the stored hash function object.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::insert<ept id="p1">](#unordered_map__insert)</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Adds elements.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::key_eq<ept id="p1">](#unordered_map__key_eq)</ept></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Gets the stored comparison function object.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::load_factor<ept id="p1">](#unordered_map__load_factor)</ept></source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Counts the average elements per bucket.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::max_bucket_count<ept id="p1">](#unordered_map__max_bucket_count)</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Gets the maximum number of buckets.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::max_load_factor<ept id="p1">](#unordered_map__max_load_factor)</ept></source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Gets or sets the maximum elements per bucket.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::max_size<ept id="p1">](#unordered_map__max_size)</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Gets the maximum size of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::rehash<ept id="p1">](#unordered_map__rehash)</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Rebuilds the hash table.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::size<ept id="p1">](#unordered_map__size)</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Counts the number of elements.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::swap<ept id="p1">](#unordered_map__swap)</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Swaps the contents of two containers.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::unordered_map<ept id="p1">](#unordered_map__unordered_map)</ept></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Constructs a container object.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::operator[]<ept id="p1">](#unordered_map__operator_at)</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Finds or inserts an element with the specified key.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>unordered_map::operator=<ept id="p1">](#unordered_map__operator_eq)</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Copies a hash table.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The object orders the sequence it controls by calling two stored objects, a comparison function object of type <bpt id="p1">[</bpt>unordered_map::key_equal<ept id="p1">](#unordered_map__key_equal)</ept> and a hash function object of type <bpt id="p2">[</bpt>unordered_map::hasher<ept id="p2">](#unordered_map__hasher)</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>You access the first stored object by calling the member function <bpt id="p1">[</bpt>unordered_map::key_eq<ept id="p1">](#unordered_map__key_eq)</ept><ph id="ph1">`()`</ph>; and you access the second stored object by calling the member function <bpt id="p2">[</bpt>unordered_map::hash_function<ept id="p2">](#unordered_map__hash_function)</ept><ph id="ph2">`()`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Specifically, for all values <ph id="ph1">`X`</ph> and <ph id="ph2">`Y`</ph> of type <ph id="ph3">`Key`</ph>, the call <ph id="ph4">`key_eq()(X, Y)`</ph> returns true only if the two argument values have equivalent ordering; the call <ph id="ph5">`hash_function()(keyval)`</ph> yields a distribution of values of type <ph id="ph6">`size_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Unlike template class <bpt id="p1">[</bpt>unordered_multimap Class<ept id="p1">](../standard-library/unordered-multimap-class.md)</ept>, an object of template class <ph id="ph1">`unordered_map`</ph> ensures that <ph id="ph2">`key_eq()(X, Y)`</ph> is always false for any two elements of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>(Keys are unique.)</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The object also stores a maximum load factor, which specifies the maximum desired average number of elements per bucket.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If inserting an element causes <bpt id="p1">[</bpt>unordered_map::load_factor<ept id="p1">](#unordered_map__load_factor)</ept><ph id="ph1">`()`</ph> to exceed the maximum load factor, the container increases the number of buckets and rebuilds the hash table as needed.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The actual order of elements in the controlled sequence depends on the hash function, the comparison function, the order of insertion, the maximum load factor, and the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>You cannot in general predict the order of elements in the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can always be assured, however, that any subset of elements that have equivalent ordering are adjacent in the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The object allocates and frees storage for the sequence it controls through a stored allocator object of type <bpt id="p1">[</bpt>unordered_map::allocator_type<ept id="p1">](#unordered_map__allocator_type)</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Such an allocator object must have the same external interface as an object of template class <ph id="ph1">`allocator`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Note that the stored allocator object is not copied when the container object is assigned.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> &lt;unordered_map&gt;</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> std</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__allocator_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::allocator_type</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The type of an allocator for managing storage.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The type is a synonym for the template parameter <ph id="ph1">`Alloc`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__at"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::at</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Finds an element in a unordered_map with a specified key value.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The key value to find.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>A reference to the data value of the element found.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If the argument key value is not found, then the function throws an object of class <ph id="ph1">`out_of_range`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__begin"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::begin</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Designates the beginning of the controlled sequence or a bucket.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The bucket number.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The first two member functions return a forward iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The last two member functions return a forward iterator that points at the first element of bucket <ph id="ph1">`nbucket`</ph> (or just beyond the end of an empty bucket).</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__bucket"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::bucket</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Gets the bucket number for a key value.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The key value to map.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The member function returns the bucket number currently corresponding to the key value <ph id="ph1">`keyval`</ph>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__bucket_count"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::bucket_count</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Gets the number of buckets.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The member function returns the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__bucket_size"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::bucket_size</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Gets the size of a bucket</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The bucket number.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The member functions returns the size of bucket number <ph id="ph1">`nbucket`</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__cbegin"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::cbegin</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`const`</ph> iterator that addresses the first element in the range.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`const`</ph> forward-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, <ph id="ph2">`cbegin() == cend()`</ph>).</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>With the return value of <ph id="ph1">`cbegin`</ph>, the elements in the range cannot be modified.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>You can use this member function in place of the <ph id="ph1">`begin()`</ph> member function to guarantee that the return value is <ph id="ph2">`const_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Typically, it's used in conjunction with the <bpt id="p1">[</bpt>auto<ept id="p1">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>In the example, consider <ph id="ph1">`Container`</ph> to be a modifiable (non- <ph id="ph2">`const`</ph>) container of any kind that supports <ph id="ph3">`begin()`</ph> and <ph id="ph4">`cbegin()`</ph>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__cend"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::cend</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`const`</ph> iterator that addresses the location just beyond the last element in a range.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`const`</ph> forward-access iterator that points just beyond the end of the range.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`cend`</ph> is used to test whether an iterator has passed the end of its range.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can use this member function in place of the <ph id="ph1">`end()`</ph> member function to guarantee that the return value is <ph id="ph2">`const_iterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Typically, it's used in conjunction with the <bpt id="p1">[</bpt>auto<ept id="p1">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In the example, consider <ph id="ph1">`Container`</ph> to be a modifiable (non- <ph id="ph2">`const`</ph>) container of any kind that supports <ph id="ph3">`end()`</ph> and <ph id="ph4">`cend()`</ph>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The value returned by <ph id="ph1">`cend`</ph> should not be dereferenced.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__clear"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::clear</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Removes all elements.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The member function calls <bpt id="p1">[</bpt>unordered_map::erase<ept id="p1">](#unordered_map__erase)</ept><ph id="ph1">`(`</ph> <bpt id="p2">[</bpt>unordered_map::begin<ept id="p2">](#unordered_map__begin)</ept><ph id="ph2">`(),`</ph> <bpt id="p3">[</bpt>unordered_map::end<ept id="p3">](#unordered_map__end)</ept><ph id="ph3">`())`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__const_iterator"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::const_iterator</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The type of a constant iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a constant forward iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T1`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__const_local_iterator"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::const_local_iterator</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The type of a constant bucket iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a constant forward iterator for a bucket.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T5`</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__const_pointer"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::const_pointer</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The type of a constant pointer to an element.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a constant pointer to an element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__const_reference"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::const_reference</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The type of a constant reference to an element.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a constant reference to an element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__count"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::count</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Finds the number of elements matching a specified key.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Key value to search for.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The member function returns the number of elements in the range delimited by <bpt id="p1">[</bpt>unordered_map::equal_range<ept id="p1">](#unordered_map__equal_range)</ept><ph id="ph1">`(keyval)`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__difference_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::difference_type</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The type of a signed distance between two elements.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T3`</ph>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__emplace"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::emplace</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Inserts an element constructed in place (no copy or move operations are performed) into an unordered_map.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The arguments forwarded to construct an element to be inserted into the unordered_map unless it already contains an element whose value is equivalently ordered.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`pair`</ph> whose <ph id="ph2">`bool`</ph> component returns true if an insertion was made and false if the <ph id="ph3">`unordered_map`</ph> already contained an element whose key had an equivalent value in the ordering, and whose iterator component returns the address where a new element was inserted or where the element was already located.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>To access the iterator component of a pair <ph id="ph1">`pr`</ph> returned by this member function, use <ph id="ph2">`pr.first`</ph>, and to dereference it, use <ph id="ph3">`*(pr.first)`</ph>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>To access the <ph id="ph1">`bool`</ph> component of a pair <ph id="ph2">`pr`</ph> returned by this member function, use <ph id="ph3">`pr.second`</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>No iterators or references are invalidated by this function.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>If the exception is thrown in the hash function, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>For a code example, see <bpt id="p1">[</bpt>map::emplace<ept id="p1">](../standard-library/map-class.md#map__emplace)</ept>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__emplace_hint"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::emplace_hint</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Inserts an element constructed in place (no copy or move operations are performed), with a placement hint.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The arguments forwarded to construct an element to be inserted into the unordered_map unless the unordered_map already contains that element or, more generally, unless it already contains an element whose key is equivalently ordered.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A hint regarding the place to start searching for the correct point of insertion.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>An iterator to the newly inserted element.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the existing element.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>No references are invalidated by this function.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>If the exception is thrown in the hash function, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>value_type<ept id="p1">](../standard-library/map-class.md#map__value_type)</ept> of an element is a pair, so that the value of an element will be an ordered pair with the first component equal to the key value and the second component equal to the data value of the element.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>For a code example, see <bpt id="p1">[</bpt>map::emplace_hint<ept id="p1">](../standard-library/map-class.md#map__emplace_hint)</ept>.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__empty"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::empty</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Tests whether no elements are present.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The member function returns true for an empty controlled sequence.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__end"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::end</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Designates the end of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The bucket number.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The first two member functions return a forward iterator that points just beyond the end of the sequence.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The last two member functions return a forward iterator that points just beyond the end of bucket <ph id="ph1">`nbucket`</ph>.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__equal_range"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::equal_range</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Finds range that matches a specified key.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Key value to search for.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The member function returns a pair of iterators <ph id="ph1">`X`</ph> such that <ph id="ph2">`[X.first, X.second)`</ph> delimits just those elements of the controlled sequence that have equivalent ordering with <ph id="ph3">`keyval`</ph>.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>If no such elements exist, both iterators are <ph id="ph1">`end()`</ph>.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__erase"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::erase</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Removes an element or a range of elements in a unordered_map from specified positions or removes elements that match a specified key.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Position of the element to be removed.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Position of the first element to be removed.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Position just beyond the last element to be removed.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The key value of the elements to be removed.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>For the first two member functions, a bidirectional iterator that designates the first element remaining beyond any elements removed, or an element that is the end of the map if no such element exists.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>For the third member function, returns the number of elements that have been removed from the unordered_map.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>For a code example, see <bpt id="p1">[</bpt>map::erase<ept id="p1">](../standard-library/map-class.md#map__erase)</ept>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__find"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::find</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Finds an element that matches a specified key.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Key value to search for.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The member function returns <bpt id="p1">[</bpt>unordered_map::equal_range<ept id="p1">](#unordered_map__equal_range)</ept><ph id="ph1">`(keyval).first`</ph>.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__get_allocator"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::get_allocator</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Gets the stored allocator object.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>The member function returns the stored allocator object.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__hash_function"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::hash_function</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Gets the stored hash function object.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The member function returns the stored hash function object.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__hasher"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::hasher</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The type of the hash function.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The type is a synonym for the template parameter <ph id="ph1">`Hash`</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__insert"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::insert</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Inserts an element or a range of elements into an unordered_map.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The value of an element to be inserted into the unordered_map unless it already contains an element whose key is equivalently ordered.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The place to start searching for the correct point of insertion.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Template parameter that specifies the argument type that the unordered_map can use to construct an element of <bpt id="p1">[</bpt>value_type<ept id="p1">](../standard-library/map-class.md#map__value_type)</ept>, and perfect-forwards <ph id="ph1">`Val`</ph> as an argument.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The position of the first element to be copied.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The position just beyond the last element to be copied.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Template function argument that meets the requirements of an <bpt id="p1">[</bpt>input iterator<ept id="p1">](../standard-library/input-iterator-tag-struct.md)</ept> that points to elements of a type that can be used to construct <bpt id="p2">[</bpt>value_type<ept id="p2">](../standard-library/map-class.md#map__value_type)</ept> objects.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>initializer_list<ept id="p1">](../standard-library/initializer-list.md)</ept> from which to copy the elements.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The single-element member functions, (1) and (2), return a <bpt id="p1">[</bpt>pair<ept id="p1">](../standard-library/pair-structure.md)</ept> whose <ph id="ph1">`bool`</ph> component is true if an insertion was made, and false if the unordered_map already contained an element whose key had an equivalent value in the ordering.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The iterator component of the return-value pair points to the newly inserted element if the <ph id="ph1">`bool`</ph> component is true, or to the existing element if the <ph id="ph2">`bool`</ph> component is false.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The single-element-with-hint member functions, (3) and (4), return an iterator that points to the position where the new element was inserted into the unordered_map or, if an element with an equivalent key already exists, to the existing element.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>No iterators, pointers, or references are invalidated by this function.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>During the insertion of just one element, if an exception is thrown but does not occur in the container's hash function, the container's state is not modified.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>If the exception is thrown in the hash function, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>During the insertion of multiple elements, if an exception is thrown, the container is left in an unspecified but valid state.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>To access the iterator component of a <ph id="ph1">`pair``pr`</ph> that's returned by the single-element member functions, use <ph id="ph2">`pr.first`</ph>; to dereference the iterator within the returned pair, use <ph id="ph3">`*pr.first`</ph>, giving you an element.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>To access the <ph id="ph1">`bool`</ph> component, use <ph id="ph2">`pr.second`</ph>.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For an example, see the sample code later in this article.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>value_type<ept id="p1">](../standard-library/map-class.md#map__value_type)</ept> of a container is a typedef that belongs to the container, and for map, <ph id="ph1">`map&lt;K, V&gt;::value_type`</ph> is <ph id="ph2">`pair&lt;const K, V&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The value of an element is an ordered pair in which the first component is equal to the key value and the second component is equal to the data value of the element.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>The range member function (5) inserts the sequence of element values into an unordered_map that corresponds to each element addressed by an iterator in the range <ph id="ph1">`[First, Last)`</ph>; therefore, <ph id="ph2">`Last`</ph> does not get inserted.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The container member function <ph id="ph1">`end()`</ph> refers to the position just after the last element in the container—for example, the statement <ph id="ph2">`m.insert(v.begin(), v.end());`</ph> attempts to insert all elements of <ph id="ph3">`v`</ph> into <ph id="ph4">`m`</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Only elements that have unique values in the range are inserted; duplicates are ignored.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>To observe which elements are rejected, use the single-element versions of <ph id="ph1">`insert`</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The initializer list member function (6) uses an <bpt id="p1">[</bpt>initializer_list<ept id="p1">](../standard-library/initializer-list.md)</ept> to copy elements into the unordered_map.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>For insertion of an element constructed in place—that is, no copy or move operations are performed—see <bpt id="p1">[</bpt>unordered_map::emplace<ept id="p1">](#unordered_map__emplace)</ept> and <bpt id="p2">[</bpt>unordered_map::emplace_hint<ept id="p2">](#unordered_map__emplace_hint)</ept>.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>For a code example, see <bpt id="p1">[</bpt>map::insert<ept id="p1">](../standard-library/map-class.md#map__insert)</ept>.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__iterator"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::iterator</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The type of an iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a forward iterator for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T0`</ph>.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__key_eq"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::key_eq</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Gets the stored comparison function object.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The member function returns the stored comparison function object.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__key_equal"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::key_equal</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The type of the comparison function.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The type is a synonym for the template parameter <ph id="ph1">`Pred`</ph>.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__key_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::key_type</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The type of an ordering key.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The type is a synonym for the template parameter <ph id="ph1">`Key`</ph>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__load_factor"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::load_factor</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Counts the average elements per bucket.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The member function returns <ph id="ph1">`(float)`</ph><bpt id="p1">[</bpt>unordered_map::size<ept id="p1">](#unordered_map__size)</ept><ph id="ph2">`() / (float)`</ph><bpt id="p2">[</bpt>unordered_map::bucket_count<ept id="p2">](#unordered_map__bucket_count)</ept><ph id="ph3">`()`</ph>, the average number of elements per bucket.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__local_iterator"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::local_iterator</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The type of a bucket iterator.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a forward iterator for a bucket.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T4`</ph>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__mapped_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::mapped_type</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The type of a mapped value associated with each key.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The type is a synonym for the template parameter <ph id="ph1">`Ty`</ph>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__max_bucket_count"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::max_bucket_count</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Gets the maximum number of buckets.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The member function returns the maximum number of buckets currently permitted.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__max_load_factor"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::max_load_factor</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Gets or sets the maximum elements per bucket.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The new maximum load factor.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>The first member function returns the stored maximum load factor.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The second member function replaces the stored maximum load factor with <ph id="ph1">`factor`</ph>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__max_size"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::max_size</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Gets the maximum size of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The member function returns the length of the longest sequence that the object can control.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__operator_at"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::operator[]</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Finds or inserts an element with the specified key.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The key value to find or insert.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A reference to the data value of the inserted element.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>If the argument key value is not found, then it is inserted along with the default value of the data type.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`operator[]`</ph> may be used to insert elements into a map <bpt id="p1">*</bpt>m<ept id="p1">*</ept> using <bpt id="p2">*</bpt>m<ept id="p2">*</ept>[_ <bpt id="p3">*</bpt>Key<ept id="p3">*</ept>] = <ph id="ph2">`DataValue`</ph>; where <ph id="ph3">`DataValue`</ph> is the value of the <ph id="ph4">`mapped_type`</ph> of the element with a key value of <ph id="ph5">\_</ph> <bpt id="p4">*</bpt>Key<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>When using <ph id="ph1">`operator[]`</ph> to insert elements, the returned reference does not indicate whether an insertion is changing a pre-existing element or creating a new one.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>The member functions <bpt id="p1">[</bpt>find<ept id="p1">](../standard-library/map-class.md#map__find)</ept> and <bpt id="p2">[</bpt>insert<ept id="p2">](../standard-library/map-class.md#map__insert)</ept> can be used to determine whether an element with a specified key is already present before an insertion.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>The member function determines the iterator <ph id="ph1">`where`</ph> as the return value of <bpt id="p1">[</bpt>unordered_map::insert<ept id="p1">](#unordered_map__insert)</ept><ph id="ph2">`(`</ph> <bpt id="p2">[</bpt>unordered_map::value_type<ept id="p2">](#unordered_map__value_type)</ept><ph id="ph3">`(keyval, Ty())`</ph>.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>(It inserts an element with the specified key if no such element exists.) It then returns a reference to <ph id="ph1">`(*where).second`</ph>.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__operator_eq"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::operator=</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Replaces the elements of this unordered_map using the elements from another unordered_map.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>The unordered_map that the operator function assigns content from.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The first version copies all of the elements from <ph id="ph1">` right`</ph> to this unordered_map.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>The second version moves all of the elements from <ph id="ph1">` right`</ph> to this unordered_map.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Any elements that are in this unordered_map before <ph id="ph1">`operator`</ph>= executes are discarded.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__pointer"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::pointer</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The type of a pointer to an element.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a pointer to an element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__reference"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::reference</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The type of a reference to an element.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The type describes an object that can serve as a reference to an element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__rehash"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::rehash</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Rebuilds the hash table.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>The requested number of buckets.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The member function alters the number of buckets to be at least <ph id="ph1">`nbuckets`</ph> and rebuilds the hash table as needed.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__size"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::size</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Counts the number of elements.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The member function returns the length of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__size_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::size_type</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>The type of an unsigned distance between two elements.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The unsigned integer type describes an object that can represent the length of any controlled sequence.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>It is described here as a synonym for the implementation-defined type <ph id="ph1">`T2`</ph>.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__swap"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::swap</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Swaps the contents of two containers.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The container to swap with.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The member function swaps the controlled sequences between <ph id="ph1">`*this`</ph> and <ph id="ph2">`right`</ph>.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">[</bpt>unordered_map::get_allocator<ept id="p1">](#unordered_map__get_allocator)</ept><ph id="ph1">`() == right.get_allocator()`</ph>, it does so in constant time, it throws an exception only as a result of copying the stored traits object of type <ph id="ph2">`Tr`</ph>, and it invalidates no references, pointers, or iterators that designate elements in the two controlled sequences.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__unordered_map"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::unordered_map</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Constructs a container object.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The allocator object to store.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The comparison function object to store.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The hash function object to store.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The minimum number of buckets.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The container to copy.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The initializer_list that contains the elements to be copied.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>The first constructor specifies a copy of the sequence controlled by <ph id="ph1">`right`</ph>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>The second constructor specifies an empty controlled sequence.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The third constructor inserts the sequence of element values <ph id="ph1">`[first, last)`</ph>.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The fourth constructor specifies a copy of the sequence by moving <ph id="ph1">`right`</ph>.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>All constructors also initialize several stored values.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>For the copy constructor, the values are obtained from <ph id="ph1">`Right`</ph>.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>Otherwise:</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>the minimum number of buckets is the argument <ph id="ph1">`Bucket_count`</ph>, if present; otherwise it is a default value described here as the implementation-defined value <ph id="ph2">`N0`</ph>.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>the hash function object is the argument <ph id="ph1">`Hash`</ph>, if present; otherwise it is <ph id="ph2">`Hash()`</ph>.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The comparison function object is the argument <ph id="ph1">`Comp`</ph>, if present; otherwise it is <ph id="ph2">`Pred()`</ph>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The allocator object is the argument <ph id="ph1">`Al`</ph>, if present; otherwise, it is <ph id="ph2">`Alloc()`</ph>.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="unordered_map__value_type"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  unordered_map::value_type</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>The type of an element.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The type describes an element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>&lt;unordered_map&gt;<ept id="p1">](../standard-library/unordered-map.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Containers<ept id="p1">](../cpp/containers-modern-cpp.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Thread Safety in the C++ Standard Library<ept id="p1">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>C++ Standard Library Reference<ept id="p1">](../standard-library/cpp-standard-library-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>