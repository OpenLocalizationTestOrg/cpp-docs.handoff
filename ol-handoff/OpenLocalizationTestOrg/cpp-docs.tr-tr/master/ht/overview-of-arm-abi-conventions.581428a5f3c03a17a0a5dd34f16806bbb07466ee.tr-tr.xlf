<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1249375bf7de4b5c5a9ebf7ee52f3f65319557ba</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\build\overview-of-arm-abi-conventions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b52e0f58d193c71d62873e35e24e0496500f6f3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c4dd2cee1392da61ee4dd57165e4133143f281fc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Overview of ARM ABI Conventions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Overview of ARM ABI Conventions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The application binary interface (ABI) for code compiled for Windows on ARM processors is based on the standard ARM EABI.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This article highlights key differences between Windows on ARM and the standard.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For more information about the standard ARM EABI, see <bpt id="p1">[</bpt>Application Binary Interface (ABI) for the ARM Architecture<ept id="p1">](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Base Requirements</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Windows on ARM presumes that it is running on an ARMv7 architecture at all times.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Floating-point support in the form of VFPv3-D32 or later must be present in hardware.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The VFP must support both single-precision and double-precision floating-point in hardware.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows runtime does not support emulation of floating-point to enable running on non-VFP hardware.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Advanced SIMD Extensions (NEON) support—this includes both integer and floating-point operations—must also be present in hardware.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>No run-time support for emulation is provided.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Integer divide support (UDIV/SDIV) is strongly recommended but not required.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Platforms that lack integer divide support may incur a performance penalty because these operations have to be trapped and possibly patched.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Endianness</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Windows on ARM executes in little-endian mode.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Both the Visual C++ compiler and the Windows runtime expect little-endian data at all times.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Although the SETEND instruction in the ARM instruction set architecture (ISA) allows even user-mode code to change the current endianness, doing so is discouraged because it's dangerous for an application.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If an exception is generated in big-endian mode, the behavior is unpredictable and may lead to an application fault in user mode, or a bugcheck in kernel mode.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Alignment</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Although Windows enables the ARM hardware to handle misaligned integer accesses transparently, alignment faults still may be generated in some situations.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Follow these rules for alignment:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Half-word-sized (16-bit) and word-sized (32-bit) integer loads and stores do not have to be aligned.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The hardware handles them efficiently and transparently.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Floating-point loads and stores should be aligned.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The kernel handles unaligned loads and stores transparently, but with significant overhead.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Load or store double (LDRD/STRD) and multiple (LDM/STM) operations should be aligned.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The kernel handles most of them transparently, but with significant overhead.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>All uncached memory accesses must be aligned, even for integer accesses.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Unaligned accesses cause an alignment fault.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Instruction Set</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The instruction set for Windows on ARM is strictly limited to Thumb-2.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>All code executed on this platform is expected to start and remain in Thumb mode at all times.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>An attempt to switch into the legacy ARM instruction set may succeed, but if it does, any exceptions or interrupts that occur may lead to an application fault in user mode, or a bugcheck in kernel mode.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A side-effect of this requirement is that all code pointers must have the low bit set.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is so that when they are loaded and branched to via BLX or BX, the processor will remain in Thumb mode and not try to execute the target code as 32-bit ARM instructions.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>IT Instructions</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The use of IT instructions in Thumb-2 code is disallowed except for these specific cases:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The IT instruction can only be used to modify one target instruction.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The target instruction must be a 16-bit instruction.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The target instruction must be one of these:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>16-Bit Opcodes</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Class</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>MOV, MVN</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Move</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Rm != PC, Rd != PC</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>LDR, LDR[S]B, LDR[S]H</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Load from memory</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>But not LDR literal forms</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>STR, STRB, STRH</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Store to memory</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>ADD, ADC, RSB, SBC, SUB</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Add or subtract</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>But not ADD/SUB SP, SP, imm7 forms</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Rm != PC, Rdn != PC, Rdm != PC</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>CMP, CMN</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Compare</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Rm != PC, Rn != PC</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>MUL</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Multiply</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>ASR, LSL, LSR, ROR</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Bit shift</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>AND, BIC, EOR, ORR, TST</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>BX</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Branch to register</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Rm != PC</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although current ARMv7 CPUs cannot report the use of disallowed instruction forms, future generations are expected to.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If these forms are detected, any program that uses them may be terminated with an undefined instruction exception.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>SDIV/UDIV Instructions</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The use of integer divide instructions SDIV and UDIV is fully supported, even on platforms without native hardware to handle them.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The overhead per SDIV or UDIV divide on a Cortex-A9 processor is approximately 80 cycles, in addition to the overall divide time of 20-250 cycles, depending on the inputs.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Integer Registers</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The ARM processor supports 16 integer registers:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Register</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Volatile?</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Role</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>r0</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Parameter, result, scratch register 1</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>r1</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Parameter, result, scratch register 2</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>r2</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Parameter, scratch register 3</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>r3</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Parameter, scratch register 4</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>r4</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>r5</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>r6</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>r7</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>r8</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>r9</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>r10</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>r11</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Frame pointer</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>r12</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Intra-procedure-call scratch register</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>r13 (SP)</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Stack pointer</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>r14 (LR)</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Link register</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>r15 (PC)</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Program counter</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For details about how to use the parameter and return value registers, see the Parameter Passing section in this article.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Windows uses r11 for fast-walking of the stack frame.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For more information, see the Stack Walking section.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Because of this requirement, r11 must point to the topmost link in the chain at all times.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Do not use r11 for general purposes—your code will not generate correct stack walks during analysis.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>VFP Registers</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Windows only supports ARM variants that have VFPv3-D32 coprocessor support.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This means that floating-point registers are always present and can be relied on for parameter passing, and that the full set of 32 registers is available for use.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The VFP registers and their usage are summarized in this table:</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Singles</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Doubles</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Quads</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Volatile?</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Role</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>s0-s3</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>d0-d1</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>q0</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Parameters, result, scratch register</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>s4-s7</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>d2-d3</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>q1</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Parameters, scratch register</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>s8-s11</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>d4-d5</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>q2</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Parameters, scratch register</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>s12-s15</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>d6-d7</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>q3</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Parameters, scratch register</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>s16-s19</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>d8-d9</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>q4</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>s20-s23</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>d10-d11</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>q5</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>s24-s27</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>d12-d13</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>q6</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>s28-s31</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>d14-d15</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>q7</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>d16-d31</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>q8-q15</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The next table illustrates the floating-point status and control register (FPSCR) bitfields:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Volatile?</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Role</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>31-28</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>NZCV</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Status flags</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>27</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>QC</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Cumulative saturation</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>26</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>AHP</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Alternative half-precision control</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>25</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>DN</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Default NaN mode control</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>24</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>FZ</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Flush-to-zero mode control</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>23-22</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>RMode</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Rounding mode control</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>21-20</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Stride</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Vector Stride, must always be 0</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>18-16</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Len</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Vector Length, must always be 0</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>15, 12-8</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>IDE, IXE, etc.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Non-volatile</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Exception trap enable bits, must always be 0</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>7, 4-0</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>IDC, IXC, etc.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Volatile</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Cumulative exception flags</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Floating-Point Exceptions</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Most ARM hardware does not support IEEE floating-point exceptions.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>On processor variants that do have hardware floating-point exceptions, the Windows kernel silently catches the exceptions and implicitly disables them in the FPSCR register.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This ensures normalized behavior across processor variants.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Otherwise, code developed on a platform that doesn't have exception support could receive unexpected exceptions when it's running on a platform that has exception support.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Parameter Passing</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For non-variadic functions, the Windows on ARM ABI follows the ARM rules for parameter passing—this includes the VFP and Advanced SIMD extensions.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>These rules follow the <bpt id="p1">[</bpt>Procedure Call Standard for the ARM Architecture<ept id="p1">](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042c/IHI0042C_aapcs.pdf)</ept>, consolidated with the VFP extensions.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>By default, the first four integer arguments and up to eight floating-point or vector arguments are passed in registers, and additional arguments are passed on the stack.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Arguments are assigned to registers or the stack by using this procedure:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Stage A—Initialization</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Initialization is performed exactly once, before argument processing begins:</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The Next Core Register Number (NCRN) is set to r0.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The VFP registers are marked as unallocated.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The Next Stacked Argument Address (NSAA) is set to the current SP.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>If a function that returns a result in memory is called, then the address for the result is placed in r0 and the NCRN is set to r1.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Stage B—Pre-padding and Extension of Arguments</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>For each argument in the list, the first matching rule from the following list is applied:</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>If the argument is a composite type whose size cannot be statically determined by both the caller and the callee, the argument is copied to memory and replaced by a pointer to the copy.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>If the argument is a byte or 16-bit half-word, then it is zero-extended or sign-extended to a 32-bit full word and treated as a 4-byte argument.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>If the argument is a composite type, its size is rounded up to the nearest multiple of 4.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Stage C—Assignment of Arguments to Registers and Stack</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>For each argument in the list, the following rules are applied in turn until the argument has been allocated:</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>If the argument is a VFP type and there are enough consecutive unallocated VFP registers of the appropriate type, then the argument is allocated to the lowest-numbered sequence of such registers.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>If the argument is a VFP type, all remaining unallocated registers are marked as unavailable.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The NSAA is adjusted upwards until it is correctly aligned for the argument type and the argument is copied to the stack at the adjusted NSAA.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The NSAA is then incremented by the size of the argument.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If the argument requires 8-byte alignment, the NCRN is rounded up to the next even register number.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>If the size of the argument in 32-bit words is not more than r4 minus NCRN, the argument is copied into core registers, starting at the NCRN, with the least significant bits occupying the lower-numbered registers.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The NCRN is incremented by the number of registers used.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>If the NCRN is less than r4 and the NSAA is equal to the SP, the argument is split between core registers and the stack.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The first part of the argument is copied into the core registers, starting at the NCRN, up to and including r3.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The remainder of the argument is copied onto the stack, starting at the NSAA.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The NCRN is set to r4 and the NSAA is incremented by the size of the argument minus the amount passed in registers.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>If the argument requires 8-byte alignment, the NSAA is rounded up to the next 8-byte aligned address.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The argument is copied into memory at the NSAA.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The NSAA is incremented by the size of the argument.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The VFP registers are not used for variadic functions, and Stage C rules 1 and 2 are ignored.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>This means that a variadic function can begin with an optional push {r0-r3} to prepend the register arguments to any additional arguments passed by the caller, and then access the entire argument list directly from the stack.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Integer type values are returned in r0, optionally extended to r1 for 64-bit return values.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>VFP/NEON floating-point or SIMD type values are returned in s0, d0, or q0, as appropriate.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Stack</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The stack must remain 4-byte aligned at all times, and must be 8-byte aligned at any function boundary.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>This is required to support the frequent use of interlocked operations on 64-bit stack variables.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The ARM EABI states that the stack is 8-byte aligned at any public interface.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>For consistency, the Windows on ARM ABI considers any function boundary to be a public interface.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Functions that have to use a frame pointer—for example, functions that call <ph id="ph1">`alloca`</ph> or that change the stack pointer dynamically—must set up the frame pointer in r11 in the function prologue and leave it unchanged until the epilogue.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Functions that do not require a frame pointer must perform all stack updates in the prologue and leave the stack pointer unchanged until the epilogue.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Functions that allocate 4 KB or more on the stack must ensure that each page prior to the final page is touched in order.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>This ensures that no code can “leap over” the guard pages that Windows uses to expand the stack.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Typically, this is done by the <ph id="ph1">`__chkstk`</ph> helper, which is passed the total stack allocation in bytes divided by 4 in r4, and which returns the final stack allocation amount in bytes back in r4.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Red Zone</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The 8-byte area immediately below the current stack pointer is reserved for analysis and dynamic patching.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>This permits carefully generated code to be inserted, which stores 2 registers at [sp, #-8] and temporarily uses them for arbitrary purposes.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The Windows kernel guarantees that those 8 bytes will not be overwritten if an exception or interrupt occurs in both user mode and kernel mode.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Kernel Stack</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The default kernel-mode stack in Windows is three pages (12 KB).</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Be careful not to create functions that have large stack buffers in kernel mode.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>An interrupt could come in with very little stack headroom and cause a stack panic bugcheck.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>C/C++ Specifics</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Enumerations are 32-bit integer types unless at least one value in the enumeration requires 64-bit double-word storage.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>In that case, the enumeration is promoted to a 64-bit integer type.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>is defined to be equivalent to <ph id="ph1">`unsigned short`</ph>, to preserve compatibility with other platforms.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Stack Walking</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Windows code is compiled with frame pointers enabled (<bpt id="p1">[</bpt>/Oy (Frame-Pointer Omission)<ept id="p1">](../build/reference/oy-frame-pointer-omission.md)</ept>) to enable fast stack walking.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Generally, the r11 register points to the next link in the chain, which is an {r11, lr} pair that specifies the pointer to the previous frame on the stack and the return address.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>We recommend that your code also enable frame pointers for improved profiling and tracing.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Exception Unwinding</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Stack unwinding during exception handling is enabled by the use of unwind codes.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The unwind codes are a sequence of bytes stored in the .xdata section of the executable image.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>They describe the operation of the function prologue and epilogue code in an abstract manner, so that the effects of a function’s prologue can be undone in preparation for unwinding to the caller’s stack frame.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The ARM EABI specifies an exception unwinding model that uses unwind codes.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>However, this specification is not sufficient for unwinding in Windows, which must handle cases where the processor is in the middle of the prologue or epilogue of a function.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>For more information about Windows on ARM exception data and unwinding, see <bpt id="p1">[</bpt>ARM Exception Handling<ept id="p1">](../build/arm-exception-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>We recommend that dynamically generated code be described by using dynamic function tables specified in calls to <ph id="ph1">`RtlAddFunctionTable`</ph> and associated functions, so that the generated code can participate in exception handling.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Cycle Counter</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>ARM processors running Windows are required to support a cycle counter, but using the counter directly may cause problems.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>To avoid these issues, Windows on ARM uses an undefined opcode to request a normalized 64-bit cycle-counter value.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>From C or C++, use the <ph id="ph1">`__rdpmccntr64`</ph> intrinsic to emit the appropriate opcode; from assembly, use the <ph id="ph2">`__rdpmccntr64`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Reading the cycle counter takes approximately 60 cycles on a Cortex-A9.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The counter is a true cycle counter, not a clock; therefore, the counting frequency varies with the processor frequency.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>If you want to measure elapsed clock time, use <ph id="ph1">`QueryPerformanceCounter`</ph>.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Common Visual C++ ARM Migration Issues</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>ARM Exception Handling</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>