<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b97761fb86de77cac0a62a58491bdd22443b50bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\this-pointer.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">92bd0a222c0bf683508e27dd5b1373ae89b198b3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6414edb8164b4f55eb0d07edef78354238ddd63f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>this Pointer | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>this Pointer</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is a pointer accessible only within the nonstatic member functions of a <bpt id="p2">**</bpt>class<ept id="p2">**</ept>, <ph id="ph1">`struct`</ph>, or <bpt id="p3">**</bpt>union<ept id="p3">**</ept> type.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It points to the object for which the member function is called.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Static member functions do not have a <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An object's <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is not part of the object itself; it is not reflected in the result of a <ph id="ph1">`sizeof`</ph> statement on the object.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Instead, when a nonstatic member function is called for an object, the address of the object is passed by the compiler as a hidden argument to the function.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, the following function call:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>can be interpreted this way:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The object's address is available from within the member function as the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Most uses of <bpt id="p1">**</bpt>this<ept id="p1">**</ept> are implicit.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>It is legal, though unnecessary, to explicitly use <bpt id="p1">**</bpt>this<ept id="p1">**</ept> when referring to members of the class.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`*this`</ph> is commonly used to return the current object from a member function:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is also used to guard against self-reference:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is nonmodifiable, assignments to <bpt id="p2">**</bpt>this<ept id="p2">**</ept> are not allowed.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Earlier implementations of C++ allowed assignments to <bpt id="p1">**</bpt>this<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Occasionally, the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is used directly â€” for example, to manipulate self-referential data structures, where the address of the current object is required.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Type of the this pointer</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer's type can be modified in the function declaration by the <bpt id="p2">**</bpt>const<ept id="p2">**</ept> and <ph id="ph1">`volatile`</ph> keywords.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To declare a function as having the attributes of one or more of these keywords, add the keyword(s) after the function argument list.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The preceding code declares a member function, <ph id="ph1">`X`</ph>, in which the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is treated as a <bpt id="p2">**</bpt>const<ept id="p2">**</ept> pointer to a <bpt id="p3">**</bpt>const<ept id="p3">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Combinations of <bpt id="p1">*</bpt>cv-mod-list<ept id="p1">*</ept> options can be used, but they always modify the object pointed to by <bpt id="p2">**</bpt>this<ept id="p2">**</ept>, not the <bpt id="p3">**</bpt>this<ept id="p3">**</ept> pointer itself.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Therefore, the following declaration declares function <ph id="ph1">`X`</ph>; the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer is a <bpt id="p2">**</bpt>const<ept id="p2">**</ept> pointer to a <bpt id="p3">**</bpt>const<ept id="p3">**</ept> object:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The type of <bpt id="p1">**</bpt>this<ept id="p1">**</ept> in a member function is described by the following syntax, where <bpt id="p2">*</bpt>cv-qualifier-list<ept id="p2">*</ept> is determined from the member functions declarator and can be <bpt id="p3">**</bpt>const<ept id="p3">**</ept> or <bpt id="p4">**</bpt>volatile<ept id="p4">**</ept> (or both), and <bpt id="p5">*</bpt>class-type<ept id="p5">*</ept> is the name of the class:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>[cv-qualifier-list] class-type<ept id="p1">*</ept>  <bpt id="p2">**</bpt><ph id="ph1">\*</ph> const this<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In other words, <bpt id="p1">**</bpt>this<ept id="p1">**</ept> is always a const pointer; it cannot be reassigned.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> qualifiers used in the member function declaration apply to the class instance pointed to by <bpt id="p2">**</bpt>this<ept id="p2">**</ept> in the scope of that function.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following table explains more about how these modifiers work.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Semantics of this Modifiers</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Modifier</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>const</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Cannot change member data; cannot invoke member functions that are not <bpt id="p1">**</bpt>const<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Member data is loaded from memory each time it is accessed; disables certain optimizations.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It is an error to pass a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> object to a member function that is not <bpt id="p2">**</bpt>const<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Similarly, it is an error to pass a <ph id="ph1">`volatile`</ph> object to a member function that is not <ph id="ph2">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Member functions declared as <bpt id="p1">**</bpt>const<ept id="p1">**</ept> cannot change member data â€” in such functions, the <bpt id="p2">**</bpt>this<ept id="p2">**</ept> pointer is a pointer to a <bpt id="p3">**</bpt>const<ept id="p3">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Constructors and destructors cannot be declared as <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>They can, however, be invoked on <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Keywords</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>