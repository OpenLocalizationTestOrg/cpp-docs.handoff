<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8f62af75f9628b7d2af2395a26da22f90eb53ea8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\crecordset-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">63bf226efbe68d656019818ef05e507b581737a6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0bbd756e7fe7a77e471cbf8d213c0edaa5f02f2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CRecordset Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CRecordset Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Represents a set of records selected from a data source.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>CRecordset::CRecordset</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CRecordset`</ph> object.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Your derived class must provide a constructor that calls this one.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>CRecordset::AddNew</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Prepares for adding a new record.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`Update`</ph> to complete the addition.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>CRecordset::CanAppend</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Returns nonzero if new records can be added to the recordset via the <ph id="ph1">`AddNew`</ph> member function.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>CRecordset::CanBookmark</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset supports bookmarks.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>CRecordset::Cancel</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Cancels an asynchronous operation or a process from a second thread.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>CRecordset::CancelUpdate</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Cancels any pending updates due to an <ph id="ph1">`AddNew`</ph> or <ph id="ph2">`Edit`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>CRecordset::CanRestart</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Returns nonzero if <ph id="ph1">`Requery`</ph> can be called to run the recordset's query again.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>CRecordset::CanScroll</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Returns nonzero if you can scroll through the records.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>CRecordset::CanTransact</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the data source supports transactions.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>CRecordset::CanUpdate</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset can be updated (you can add, update, or delete records).</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>CRecordset::CheckRowsetError</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Called to handle errors generated during record fetching.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>CRecordset::Close</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Closes the recordset and the ODBC <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept> associated with it.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>CRecordset::Delete</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Deletes the current record from the recordset.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You must explicitly scroll to another record after the deletion.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>CRecordset::DoBulkFieldExchange</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Called to exchange bulk rows of data from the data source to the recordset.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Implements bulk record field exchange (Bulk RFX).</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>CRecordset::DoFieldExchange</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Implements record field exchange (RFX).</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>CRecordset::Edit</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Prepares for changes to the current record.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`Update`</ph> to complete the edit.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>CRecordset::FlushResultSet</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Returns nonzero if there is another result set to be retrieved, when using a predefined query.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>CRecordset::GetBookmark</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Assigns the bookmark value of a record to the parameter object.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>CRecordset::GetDefaultConnect</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Called to get the default connection string.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>CRecordset::GetDefaultSQL</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Called to get the default SQL string to execute.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>CRecordset::GetFieldValue</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Returns the value of a field in a recordset.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>CRecordset::GetODBCFieldCount</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Returns the number of fields in the recordset.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>CRecordset::GetODBCFieldInfo</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Returns specific kinds of information about the fields in a recordset.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRecordCount</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Returns the number of records in the recordset.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowsetSize</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Returns the number of records you wish to retrieve during a single fetch.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowsFetched</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Returns the actual number of rows retrieved during a fetch.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowStatus</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Returns the status of the row after a fetch.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>CRecordset::GetSQL</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Gets the SQL string used to select records for the recordset.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>CRecordset::GetStatus</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Gets the status of the recordset: the index of the current record and whether a final count of the records has been obtained.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>CRecordset::GetTableName</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Gets the name of the table on which the recordset is based.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CRecordset::IsBOF</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset has been positioned before the first record.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>There is no current record.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>CRecordset::IsDeleted</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset is positioned on a deleted record.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>CRecordset::IsEOF</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset has been positioned after the last record.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>There is no current record.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldDirty</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the specified field in the current record has been changed.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldNull</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the specified field in the current record is null (has no value).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldNullable</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the specified field in the current record can be set to null (having no value).</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>CRecordset::IsOpen</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Returns nonzero if <ph id="ph1">`Open`</ph> has been called previously.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>CRecordset::Move</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Positions the recordset to a specified number of records from the current record in either direction.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveFirst</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Positions the current record on the first record in the recordset.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Test for <ph id="ph1">`IsBOF`</ph> first.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveLast</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Positions the current record on the last record or on the last rowset.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Test for <ph id="ph1">`IsEOF`</ph> first.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveNext</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Positions the current record on the next record or on the next rowset.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Test for <ph id="ph1">`IsEOF`</ph> first.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>CRecordset::MovePrev</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Positions the current record on the previous record or on the previous rowset.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Test for <ph id="ph1">`IsBOF`</ph> first.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>CRecordset::OnSetOptions</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Called to set options (used on selection) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>CRecordset::OnSetUpdateOptions</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Called to set options (used on update) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>CRecordset::Open</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Opens the recordset by retrieving the table or performing the query that the recordset represents.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>CRecordset::RefreshRowset</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Refreshes the data and status of the specified row(s).</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>CRecordset::Requery</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Runs the recordset's query again to refresh the selected records.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>CRecordset::SetAbsolutePosition</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Positions the recordset on the record corresponding to the specified record number.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>CRecordset::SetBookmark</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Positions the recordset on the record specified by the bookmark.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>CRecordset::SetFieldDirty</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Marks the specified field in the current record as changed.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>CRecordset::SetFieldNull</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Sets the value of the specified field in the current record to null (having no value).</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>CRecordset::SetLockingMode</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Sets the locking mode to "optimistic" locking (the default) or "pessimistic" locking.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Determines how records are locked for updates.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>CRecordset::SetParamNull</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Sets the specified parameter to null (having no value).</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>CRecordset::SetRowsetCursorPosition</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Positions the cursor on the specified row within the rowset.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>CRecordset::SetRowsetSize</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Specifies the number of records you wish to retrieve during a fetch.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>CRecordset::Update</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Completes an <ph id="ph1">`AddNew`</ph> or <ph id="ph2">`Edit`</ph> operation by saving the new or edited data on the data source.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Public Data Members</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>CRecordset::m_hstmt</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Contains the ODBC statement handle for the recordset.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`HSTMT`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>CRecordset::m_nFields</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Contains the number of field data members in the recordset.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`UINT`</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>CRecordset::m_nParams</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Contains the number of parameter data members in the recordset.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Type <ph id="ph1">`UINT`</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>CRecordset::m_pDatabase</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Contains a pointer to the <ph id="ph1">`CDatabase`</ph> object through which the recordset is connected to a data source.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>CRecordset::m_strFilter</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Contains a <ph id="ph1">`CString`</ph> that specifies a Structured Query Language (SQL) <ph id="ph2">`WHERE`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Used as a filter to select only those records that meet certain criteria.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>CRecordset::m_strSort</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Contains a <ph id="ph1">`CString`</ph> that specifies a SQL <ph id="ph2">`ORDER BY`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Used to control how the records are sorted.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Known as "recordsets," <ph id="ph1">`CRecordset`</ph> objects are typically used in two forms: dynasets and snapshots.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>A dynaset stays synchronized with data updates made by other users.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>A snapshot is a static view of the data.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Each form represents a set of records fixed at the time the recordset is opened, but when you scroll to a record in a dynaset, it reflects changes subsequently made to the record, either by other users or by other recordsets in your application.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class <bpt id="p1">[</bpt>CDaoRecordset<ept id="p1">](../../mfc/reference/cdaorecordset-class.md)</ept> instead.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Overview: Database Programming<ept id="p1">](../../data/data-access-programming-mfc-atl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To work with either kind of recordset, you typically derive an application-specific recordset class from <ph id="ph1">`CRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Recordsets select records from a data source, and you can then:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Scroll through the records.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Update the records and specify a locking mode.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Filter the recordset to constrain which records it selects from those available on the data source.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Sort the recordset.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Parameterize the recordset to customize its selection with information not known until run time.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>To use your class, open a database and construct a recordset object, passing the constructor a pointer to your <ph id="ph1">`CDatabase`</ph> object.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Then call the recordset's <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> member function, where you can specify whether the object is a dynaset or a snapshot.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Calling <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> selects data from the data source.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>After the recordset object is opened, use its member functions and data members to scroll through the records and operate on them.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The operations available depend on whether the object is a dynaset or a snapshot, whether it is updatable or read-only (this depends on the capability of the Open Database Connectivity (ODBC) data source), and whether you have implemented bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To refresh records that may have been changed or added since the <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> call, call the object's <bpt id="p2">**</bpt>Requery<ept id="p2">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Call the object's <bpt id="p1">**</bpt>Close<ept id="p1">**</ept> member function and destroy the object when you finish with it.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>In a derived <ph id="ph1">`CRecordset`</ph> class, record field exchange (RFX) or bulk record field exchange (Bulk RFX) is used to support reading and updating of record fields.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>For more information about recordsets and record field exchange, see the articles <bpt id="p1">[</bpt>Overview: Database Programming<ept id="p1">](../../data/data-access-programming-mfc-atl.md)</ept>, <bpt id="p2">[</bpt>Recordset (ODBC)<ept id="p2">](../../data/odbc/recordset-odbc.md)</ept>, <bpt id="p3">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p3">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>, and <bpt id="p4">[</bpt>Record Field Exchange (RFX)<ept id="p4">](../../data/odbc/record-field-exchange-rfx.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For a focus on dynasets and snapshots, see the articles <bpt id="p1">[</bpt>Dynaset<ept id="p1">](../../data/odbc/dynaset.md)</ept> and <bpt id="p2">[</bpt>Snapshot<ept id="p2">](../../data/odbc/snapshot.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>CObject</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> afxdb.h</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>CRecordset::AddNew</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Prepares for adding a new record to the table.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>You must call the <bpt id="p1">[</bpt>Requery<ept id="p1">](#crecordset__requery)</ept> member function to see the newly added record.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The record's fields are initially Null.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>(In database terminology, Null means "having no value" and is not the same as <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> in C++.) To complete the operation, you must call the <bpt id="p2">[</bpt>Update<ept id="p2">](#crecordset__update)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Update<ept id="p1">**</ept> saves your changes to the data source.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you cannot call <ph id="ph1">`AddNew`</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Although class <ph id="ph1">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>prepares a new, empty record using the recordset's field data members.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>After you call <ph id="ph1">`AddNew`</ph>, set the values you want in the recordset's field data members.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>(You do not have to call the <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> member function for this purpose; use <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> only for existing records.) When you subsequently call <bpt id="p3">**</bpt>Update<ept id="p3">**</ept>, changed values in the field data members are saved on the data source.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If you scroll to a new record before you call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>, the new record is lost, and no warning is given.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>If the data source supports transactions, you can make your <ph id="ph1">`AddNew`</ph> call part of a transaction.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>For more information about transactions, see class <bpt id="p1">[</bpt>CDatabase<ept id="p1">](../../mfc/reference/cdatabase-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Note that you should call <bpt id="p1">[</bpt>CDatabase::BeginTrans<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans)</ept> before calling <ph id="ph1">`AddNew`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For dynasets, new records are added to the recordset as the last record.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Added records are not added to snapshots; you must call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> to refresh the recordset.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>It is illegal to call <ph id="ph1">`AddNew`</ph> for a recordset whose <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> member function has not been called.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CDBException`</ph> is thrown if you call <ph id="ph2">`AddNew`</ph> for a recordset that cannot be appended to.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You can determine whether the recordset is updatable by calling <bpt id="p1">[</bpt>CanAppend<ept id="p1">](#crecordset__canappend)</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For more information, see the following articles: <bpt id="p1">[</bpt>Recordset: How Recordsets Update Records (ODBC)<ept id="p1">](../../data/odbc/recordset-how-recordsets-update-records-odbc.md)</ept>, <bpt id="p2">[</bpt>Recordset: Adding, Updating, and Deleting Records (ODBC)<ept id="p2">](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md)</ept>, and <bpt id="p3">[</bpt>Transaction (ODBC)<ept id="p3">](../../data/odbc/transaction-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>See the article <bpt id="p1">[</bpt>Transaction: Performing a Transaction in a Recordset (ODBC)<ept id="p1">](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>CRecordset::CanAppend</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Determines whether the previously opened recordset allows you to add new records.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset allows adding new records; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>will return 0 if you opened the recordset as read-only.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>CRecordset::CanBookmark</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Determines whether the recordset allows you to mark records using bookmarks.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset supports bookmarks; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This function is independent of the <bpt id="p1">**</bpt>CRecordset::useBookmarks<ept id="p1">**</ept> option in the <ph id="ph1">`dwOptions`</ph> parameter of the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>indicates whether the given ODBC driver and cursor type support bookmarks.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::useBookmarks<ept id="p1">**</ept> indicates whether bookmarks will be available, provided they are supported.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Bookmarks are not supported on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>For more information about bookmarks and recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p1">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Scrolling (ODBC)<ept id="p2">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>CRecordset::Cancel</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Requests that the data source cancel either an asynchronous operation in progress or a process from a second thread.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Note that the MFC ODBC classes no longer use asynchronous processing; to perform an asychronous operation, you must directly call the ODBC API function <bpt id="p1">**</bpt>SQLSetConnectOption<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>For more information, see the topic "Executing Functions Asynchronously" in the <bpt id="p1">*</bpt>ODBC SDK Programmer's Guide<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>CRecordset::CancelUpdate</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Cancels any pending updates, caused by an <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> or <bpt id="p2">[</bpt>AddNew<ept id="p2">](#crecordset__addnew)</ept> operation, before <bpt id="p3">[</bpt>Update<ept id="p3">](#crecordset__update)</ept> is called.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>, <ph id="ph1">`AddNew`</ph>, or <bpt id="p2">**</bpt>Update<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>If automatic dirty field checking is enabled, <ph id="ph1">`CancelUpdate`</ph> will restore the member variables to the values they had before <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> or <ph id="ph2">`AddNew`</ph> was called; otherwise, any value changes will remain.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>By default, automatic field checking is enabled when the recordset is opened.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>To disable it, you must specify the <bpt id="p1">**</bpt>CRecordset::noDirtyFieldCheck<ept id="p1">**</ept> in the <ph id="ph1">`dwOptions`</ph> parameter of the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For more information about updating data, see the article <bpt id="p1">[</bpt>Recordset: Adding, Updating, and Deleting Records (ODBC)<ept id="p1">](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>CRecordset::CanRestart</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Determines whether the recordset allows restarting its query (to refresh its records) by calling the <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Nonzero if requery is allowed; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>CRecordset::CanScroll</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Determines whether the recordset allows scrolling.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset allows scrolling; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>For more information about scrolling, see the article <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>CRecordset::CanTransact</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Determines whether the recordset allows transactions.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset allows transactions; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Transaction (ODBC)<ept id="p1">](../../data/odbc/transaction-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>CRecordset::CanUpdate</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Determines whether the recordset can be updated.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset can be updated; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>A recordset might be read-only if the underlying data source is read-only or if you specified <bpt id="p1">**</bpt>CRecordset::readOnly<ept id="p1">**</ept> in the <ph id="ph1">`dwOptions`</ph> parameter when you opened the recordset.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>CRecordset::CheckRowsetError</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Called to handle errors generated during record fetching.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>An ODBC API function return code.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For details, see Remarks.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>This virtual member function handles errors that occur when records are fetched, and is useful during bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>You may want to consider overriding <ph id="ph1">`CheckRowsetError`</ph> to implement your own error handling.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>is called automatically in a cursor navigation operation, such as <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Requery<ept id="p2">**</ept>, or any <bpt id="p3">**</bpt>Move<ept id="p3">**</ept> operation.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>It is passed the return value of the ODBC API function <bpt id="p1">**</bpt>SQLExtendedFetch<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following table lists the possible values for the <ph id="ph1">`nRetCode`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>nRetCode</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>SQL_SUCCESS</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Function completed successfully; no additional information is available.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>SQL_SUCCESS_WITH_INFO</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Function completed successfully, possibly with a nonfatal error.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Additional information can be obtained by calling <bpt id="p1">**</bpt>SQLError<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>SQL_NO_DATA_FOUND</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>All rows from the result set have been fetched.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>SQL_ERROR</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Function failed.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Additional information can be obtained by calling <bpt id="p1">**</bpt>SQLError<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>SQL_INVALID_HANDLE</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Function failed due to an invalid environment handle, connection handle, or statement handle.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>This indicates a programming error.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>No additional information is available from <bpt id="p1">**</bpt>SQLError<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>A function that was started asynchronously is still executing.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Note that by default, MFC will never pass this value to <ph id="ph1">`CheckRowsetError`</ph>; MFC will continue calling <bpt id="p1">**</bpt>SQLExtendedFetch<ept id="p1">**</ept> until it no longer returns <ph id="ph2">`SQL_STILL_EXECUTING`</ph>.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>For more information about <bpt id="p1">**</bpt>SQLError<ept id="p1">**</ept>, see the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>CRecordset::Close</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Closes the recordset.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The ODBC <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept> and all memory the framework allocated for the recordset are deallocated.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Usually after calling <bpt id="p1">**</bpt>Close<ept id="p1">**</ept>, you delete the C++ recordset object if it was allocated with <bpt id="p2">**</bpt>new<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>You can call <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> again after calling <bpt id="p2">**</bpt>Close<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>This lets you reuse the recordset object.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The alternative is to call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#17</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>CRecordset::CRecordset</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CRecordset`</ph> object.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Contains a pointer to a <ph id="ph1">`CDatabase`</ph> object or the value <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>If not <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> and the <ph id="ph1">`CDatabase`</ph> object's <bpt id="p2">**</bpt>Open<ept id="p2">**</ept> member function has not been called to connect it to the data source, the recordset attempts to open it for you during its own <bpt id="p3">**</bpt>Open<ept id="p3">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>If you pass <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, a <ph id="ph1">`CDatabase`</ph> object is constructed and connected for you using the data source information you specified when you derived your recordset class with ClassWizard.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>You can either use <ph id="ph1">`CRecordset`</ph> directly or derive an application-specific class from <ph id="ph2">`CRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>You can use ClassWizard to derive your recordset classes.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A derived class <bpt id="p1">*</bpt>must<ept id="p1">*</ept> supply its own constructor.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>In the constructor of your derived class, call the constructor <ph id="ph1">`CRecordset::CRecordset`</ph>, passing the appropriate parameters along to it.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Pass <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to your recordset constructor to have a <ph id="ph1">`CDatabase`</ph> object constructed and connected for you automatically.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This is a useful shorthand that does not require you to construct and connect a <ph id="ph1">`CDatabase`</ph> object prior to constructing your recordset.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Declaring a Class for a Table (ODBC)<ept id="p1">](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>CRecordset::Delete</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Deletes the current record.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>After a successful deletion, the recordset's field data members are set to a Null value, and you must explicitly call one of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions in order to move off the deleted record.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Once you move off the deleted record, it is not possible to return to it.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>If the data source supports transactions, you can make the <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> call part of a transaction.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Transaction (ODBC)<ept id="p1">](../../data/odbc/transaction-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you cannot call <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>This will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Although class <ph id="ph1">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The recordset must be updatable and there must be a valid record current in the recordset when you call <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept>; otherwise, an error occurs.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>For example, if you delete a record but do not scroll to a new record before you call <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> again, <bpt id="p2">**</bpt>Delete<ept id="p2">**</ept> throws a <bpt id="p3">[</bpt>CDBException<ept id="p3">](../../mfc/reference/cdbexception-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">[</bpt>AddNew<ept id="p1">](#crecordset__addnew)</ept> and <bpt id="p2">[</bpt>Edit<ept id="p2">](#crecordset__edit)</ept>, a call to <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> is not followed by a call to <bpt id="p4">[</bpt>Update<ept id="p4">](#crecordset__update)</ept>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> call fails, the field data members are left unchanged.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>This example shows a recordset created on the frame of a function.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The example assumes the existence of <ph id="ph1">`m_dbCust`</ph>, a member variable of type <ph id="ph2">`CDatabase`</ph> already connected to the data source.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#18</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>CRecordset::DoBulkFieldExchange</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Called to exchange bulk rows of data from the data source to the recordset.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Implements bulk record field exchange (Bulk RFX).</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>CFieldExchange<ept id="p1">](../../mfc/reference/cfieldexchange-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The framework will already have set up this object to specify a context for the field exchange operation.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>When bulk row fetching is implemented, the framework calls this member function to automatically transfer data from the data source to your recordset object.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>If bulk row fetching is not implemented, the framework calls <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must specify the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option of the <ph id="ph2">`dwOptions`</ph> parameter in the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>is available only if you are using a class derived from <ph id="ph1">`CRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>If you have created a recordset object directly from <ph id="ph1">`CRecordset`</ph>, you must call the <bpt id="p1">[</bpt>GetFieldValue<ept id="p1">](#crecordset__getfieldvalue)</ept> member function to retrieve data.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Bulk record field exchange (Bulk RFX) is similar to record field exchange (RFX).</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Data is automatically transferred from the data source to the recordset object.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>However, you cannot call <ph id="ph1">`AddNew`</ph>, <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Delete<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>Update<ept id="p3">**</ept> to transfer changes back to the data source.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Class <ph id="ph1">`CRecordset`</ph> currently does not provide a mechanism for updating bulk rows of data; however, you can write your own functions by using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Note that ClassWizard does not support bulk record field exchange; therefore, you must override <ph id="ph1">`DoBulkFieldExchange`</ph> manually by writing calls to the Bulk RFX functions.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>For more information about these functions, see the topic <bpt id="p1">[</bpt>Record Field Exchange Functions<ept id="p1">](../../mfc/reference/record-field-exchange-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>For related information, see the article <bpt id="p1">[</bpt>Record Field Exchange (RFX)<ept id="p1">](../../data/odbc/record-field-exchange-rfx.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>CRecordset::DoFieldExchange</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Implements record field exchange (RFX).</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>A pointer to a <bpt id="p1">[</bpt>CFieldExchange<ept id="p1">](../../mfc/reference/cfieldexchange-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The framework will already have set up this object to specify a context for the field exchange operation.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>When bulk row fetching is not implemented, the framework calls this member function to automatically exchange data between the field data members of your recordset object and the corresponding columns of the current record on the data source.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>If bulk row fetching is implemented, the framework calls <bpt id="p1">[</bpt>DoBulkFieldExchange<ept id="p1">](#crecordset__dobulkfieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must specify the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option of the <ph id="ph2">`dwOptions`</ph> parameter in the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>is available only if you are using a class derived from <ph id="ph1">`CRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If you have created a recordset object directly from <ph id="ph1">`CRecordset`</ph>, you must call the <bpt id="p1">[</bpt>GetFieldValue<ept id="p1">](#crecordset__getfieldvalue)</ept> member function to retrieve data.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The exchange of field data, called record field exchange (RFX), works in both directions: from the recordset object's field data members to the fields of the record on the data source, and from the record on the data source to the recordset object.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The only action you must normally take to implement <ph id="ph1">`DoFieldExchange`</ph> for your derived recordset class is to create the class with ClassWizard and specify the names and data types of the field data members.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>You might also add code to what ClassWizard writes to specify parameter data members or to deal with any columns you bind dynamically.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Dynamically Binding Data Columns (ODBC)<ept id="p1">](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>When you declare your derived recordset class with ClassWizard, the wizard writes an override of <ph id="ph1">`DoFieldExchange`</ph> for you, which resembles the following example:</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#19</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>For more information about the RFX functions, see the topic <bpt id="p1">[</bpt>Record Field Exchange Functions<ept id="p1">](../../mfc/reference/record-field-exchange-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>For further examples and details about <ph id="ph1">`DoFieldExchange`</ph>, see the article <bpt id="p1">[</bpt>Record Field Exchange: How RFX Works<ept id="p1">](../../data/odbc/record-field-exchange-how-rfx-works.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>For general information about RFX, see the article <bpt id="p1">[</bpt>Record Field Exchange<ept id="p1">](../../data/odbc/record-field-exchange-rfx.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>CRecordset::Edit</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Allows changes to the current record.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>After you call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>, you can change the field data members by directly resetting their values.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The operation is completed when you subsequently call the <bpt id="p1">[</bpt>Update<ept id="p1">](#crecordset__update)</ept> member function to save your changes on the data source.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you cannot call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>This will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Although class <ph id="ph1">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> saves the values of the recordset's data members.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>If you call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>, make changes, then call <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> again, the record's values are restored to what they were before the first <bpt id="p3">**</bpt>Edit<ept id="p3">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to update a column by making it Null (containing no data).</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>To do so, call <bpt id="p1">[</bpt>SetFieldNull<ept id="p1">](#crecordset__setfieldnull)</ept> with a parameter of <bpt id="p2">**</bpt>TRUE<ept id="p2">**</ept> to mark the field Null; this also causes the column to be updated.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>If you want a field to be written to the data source even though its value has not changed, call <bpt id="p1">[</bpt>SetFieldDirty<ept id="p1">](#crecordset__setfielddirty)</ept> with a parameter of <bpt id="p2">**</bpt>TRUE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>This works even if the field had the value Null.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>If the data source supports transactions, you can make the <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> call part of a transaction.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Note that you should call <bpt id="p1">[</bpt>CDatabase::BeginTrans<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans)</ept> before calling <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> and after the recordset has been opened.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Also note that calling <bpt id="p1">[</bpt>CDatabase::CommitTrans<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__committrans)</ept> is not a substitute for calling <bpt id="p2">**</bpt>Update<ept id="p2">**</ept> to complete the <bpt id="p3">**</bpt>Edit<ept id="p3">**</ept> operation.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>For more information about transactions, see class <bpt id="p1">[</bpt>CDatabase<ept id="p1">](../../mfc/reference/cdatabase-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>Depending on the current locking mode, the record being updated may be locked by <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> until you call <bpt id="p2">**</bpt>Update<ept id="p2">**</ept> or scroll to another record, or it may be locked only during the <bpt id="p3">**</bpt>Edit<ept id="p3">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>You can change the locking mode with <bpt id="p1">[</bpt>SetLockingMode<ept id="p1">](#crecordset__setlockingmode)</ept>.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The previous value of the current record is restored if you scroll to a new record before calling <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CDBException`</ph> is thrown if you call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> for a recordset that cannot be updated or if there is no current record.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>For more information, see the articles <bpt id="p1">[</bpt>Transaction (ODBC)<ept id="p1">](../../data/odbc/transaction-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Locking Records (ODBC)<ept id="p2">](../../data/odbc/recordset-locking-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#20</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>CRecordset::FlushResultSet</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Retrieves the next result set of a predefined query (stored procedure), if there are multiple result sets.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Nonzero if there are more result sets to be retrieved; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>You should call <ph id="ph1">`FlushResultSet`</ph> only when you are completely finished with the cursor on the current result set.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Note that when you retrieve the next result set by calling <ph id="ph1">`FlushResultSet`</ph>, your cursor is not valid on that result set; you should call the <bpt id="p1">[</bpt>MoveNext<ept id="p1">](#crecordset__movenext)</ept> member function after calling <ph id="ph2">`FlushResultSet`</ph>.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>If a predefined query uses an output parameter or input/output parameters, you must call <ph id="ph1">`FlushResultSet`</ph> until it returns <ph id="ph2">`FALSE`</ph> (the value 0), in order to obtain these parameter values.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>calls the ODBC API function <ph id="ph1">`SQLMoreResults`</ph>.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`SQLMoreResults`</ph> returns <ph id="ph2">`SQL_ERROR`</ph> or <ph id="ph3">`SQL_INVALID_HANDLE`</ph>, then <ph id="ph4">`FlushResultSet`</ph> will throw an exception.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`SQLMoreResults`</ph>, see the <ph id="ph2">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Your stored procedure needs to have bound fields if you want to call <ph id="ph1">`FlushResultSet`</ph>.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The following code assumes that <ph id="ph1">`COutParamRecordset`</ph> is a <ph id="ph2">`CRecordset`</ph>-derived object based on a predefined query with an input parameter and an output parameter, and having multiple result sets.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Note the structure of the <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept> override.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#21</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#22</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>CRecordset::GetBookmark</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Obtains the bookmark value for the current record.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>A reference to a <bpt id="p1">[</bpt>CDBVariant<ept id="p1">](../../mfc/reference/cdbvariant-class.md)</ept> object representing the bookmark on the current record.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>To determine if bookmarks are supported on the recordset, call <bpt id="p1">[</bpt>CanBookmark<ept id="p1">](#crecordset__canbookmark)</ept>.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>To make bookmarks available if they are supported, you must set the <bpt id="p1">**</bpt>CRecordset::useBookmarks<ept id="p1">**</ept> option in the <ph id="ph1">`dwOptions`</ph> parameter of the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>If bookmarks are unsupported or unavailable, calling <ph id="ph1">`GetBookmark`</ph> will result in an exception being thrown.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Bookmarks are not supported on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>assigns the value of the bookmark for the current record to a <ph id="ph1">`CDBVariant`</ph> object.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>To return to that record at any time after moving to a different record, call <bpt id="p1">[</bpt>SetBookmark<ept id="p1">](#crecordset__setbookmark)</ept> with the corresponding <ph id="ph1">`CDBVariant`</ph> object.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>After certain recordset operations, bookmarks may no longer be valid.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>For example, if you call <ph id="ph1">`GetBookmark`</ph> followed by <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>, you may not be able to return to the record with <ph id="ph2">`SetBookmark`</ph>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt>CDatabase::GetBookmarkPersistence<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence)</ept> to check whether you can safely call <ph id="ph1">`SetBookmark`</ph>.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>For more information about bookmarks and recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p1">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Scrolling (ODBC)<ept id="p2">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>CRecordset::GetDefaultConnect</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>Called to get the default connection string.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CString`</ph> that contains the default connection string.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The framework calls this member function to get the default connection string for the data source on which the recordset is based.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>ClassWizard implements this function for you by identifying the same data source you use in ClassWizard to get information about tables and columns.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>You will probably find it convenient to rely on this default connection while developing your application.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>But the default connection may not be appropriate for users of your application.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>If that is the case, you should reimplement this function, discarding ClassWizard's version.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>For more information about connection strings, see the article <bpt id="p1">[</bpt>Data Source (ODBC)<ept id="p1">](../../data/odbc/data-source-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>CRecordset::GetDefaultSQL</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Called to get the default SQL string to execute.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CString`</ph> that contains the default SQL statement.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The framework calls this member function to get the default SQL statement on which the recordset is based.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>This might be a table name or a SQL <bpt id="p1">**</bpt>SELECT<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>You indirectly define the default SQL statement by declaring your recordset class with ClassWizard, and ClassWizard performs this task for you.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>If you need the SQL statement string for your own use, call <ph id="ph1">`GetSQL`</ph>, which returns the SQL statement used to select the recordset's records when it was opened.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>You can edit the default SQL string in your class's override of <ph id="ph1">`GetDefaultSQL`</ph>.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>For example, you could specify a call to a predefined query using a <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>(Note, however, that if you edit <ph id="ph1">`GetDefaultSQL`</ph>, you also need to modify <ph id="ph2">`m_nFields`</ph> to match the number of columns in the data source.)</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Declaring a Class for a Table (ODBC)<ept id="p1">](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> statement could not be interpreted.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Note that when using a <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> statement, you must not insert whitespace between the curly brace and the <bpt id="p2">**</bpt>CALL<ept id="p2">**</ept> keyword, nor should you insert whitespace before the curly brace or before the <bpt id="p3">**</bpt>SELECT<ept id="p3">**</ept> keyword in a <bpt id="p4">**</bpt>SELECT<ept id="p4">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>CRecordset::GetFieldValue</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Retrieves field data in the current record.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The name of a field.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>varValu<ept id="p1">*</ept>e</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>A reference to a <bpt id="p1">[</bpt>CDBVariant<ept id="p1">](../../mfc/reference/cdbvariant-class.md)</ept> object that will store the field's value.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>The ODBC C data type of the field.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Using the default value, <bpt id="p1">**</bpt>DEFAULT_FIELD_TYPE<ept id="p1">**</ept>, forces <ph id="ph1">`GetFieldValue`</ph> to determine the C data type from the SQL data type, based on the following table.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Otherwise, you can specify the data type directly or choose a compatible data type; for example, you can store any data type into <bpt id="p1">**</bpt>SQL_C_CHAR<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>C data type</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>SQL data type</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>SQL_C_BIT</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>SQL_BIT</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>SQL_C_UTINYINT</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>SQL_TINYINT</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>SQL_C_SSHORT</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>SQL_SMALLINT</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>SQL_C_SLONG</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>SQL_INTEGER</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>SQL_C_FLOAT</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>SQL_REAL</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>SQL_C_DOUBLE</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>SQL_FLOATSQL_DOUBLE</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>SQL_C_TIMESTAMP</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>SQL_DATESQL_TIMESQL_TIMESTAMP</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>SQL_C_CHAR</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>SQL_NUMERICSQL_DECIMALSQL_BIGINTSQL_CHARSQL_VARCHARSQL_LONGVARCHAR</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>SQL_C_BINARY</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>SQL_BINARYSQL_VARBINARYSQL_LONGVARBINARY</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>For more information about ODBC data types, see the topics "SQL Data Types" and "C Data Types" in Appendix D of the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The zero-based index of the field.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>A reference to a <bpt id="p1">[</bpt>CString<ept id="p1">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object that will store the field's value converted to text, regardless of the field's data type.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>You can look up a field either by name or by index.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>You can store the field value in either a <ph id="ph1">`CDBVariant`</ph> object or a <ph id="ph2">`CString`</ph> object.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, the current record is always positioned on the first record in a rowset.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>To use <ph id="ph1">`GetFieldValue`</ph> on a record within a given rowset, you must first call the <bpt id="p1">[</bpt>SetRowsetCursorPosition<ept id="p1">](#crecordset__setrowsetcursorposition)</ept> member function to move the cursor to the desired row within that rowset.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Then call <ph id="ph1">`GetFieldValue`</ph> for that row.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must specify the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option of the <ph id="ph2">`dwOptions`</ph> parameter in the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`GetFieldValue`</ph> to dynamically fetch fields at run time rather than statically binding them at design time.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>For example, if you have declared a recordset object directly from <ph id="ph1">`CRecordset`</ph>, you must use <ph id="ph2">`GetFieldValue`</ph> to retrieve the field data; record field exchange (RFX), or bulk record field exchange (Bulk RFX), is not implemented.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>If you declare a recordset object without deriving from <ph id="ph1">`CRecordset`</ph>, do not have the ODBC Cursor Library loaded.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The cursor library requires that the recordset have at least one bound column; however, when you use <ph id="ph1">`CRecordset`</ph> directly, none of the columns are bound.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The member functions <bpt id="p1">[</bpt>CDatabase::OpenEx<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__openex)</ept> and <bpt id="p2">[</bpt>CDatabase::Open<ept id="p2">](../../mfc/reference/cdatabase-class.md#cdatabase__open)</ept> control whether the cursor library will be loaded.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>calls the ODBC API function <bpt id="p1">**</bpt>SQLGetData<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If your driver outputs the value <bpt id="p1">**</bpt>SQL_NO_TOTAL<ept id="p1">**</ept> for the actual length of the field value, <ph id="ph1">`GetFieldValue`</ph> throws an exception.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>For more information about <bpt id="p1">**</bpt>SQLGetData<ept id="p1">**</ept>, see the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The following sample code illustrates calls to <ph id="ph1">`GetFieldValue`</ph> for a recordset object declared directly from <ph id="ph2">`CRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#23</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Unlike the DAO class <ph id="ph1">`CDaoRecordset`</ph>, <ph id="ph2">`CRecordset`</ph> does not have a <ph id="ph3">`SetFieldValue`</ph> member function.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>If you create an object directly from <ph id="ph1">`CRecordset`</ph>, it is effectively read-only.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>CRecordset::GetODBCFieldCount</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Retrieves the total number of fields in your recordset object.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>The number of fields in the recordset.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>For more information about creating recordsets, see the article <bpt id="p1">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id="p1">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>CRecordset::GetODBCFieldInfo</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Obtains information about the fields in the recordset.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The name of a field.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>A reference to a <ph id="ph1">`CODBCFieldInfo`</ph> structure.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>The zero-based index of the field.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>One version of the function lets you look up a field by name.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The other version lets you look up a field by index.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>For a description about the information returned, see the <bpt id="p1">[</bpt>CODBCFieldInfo<ept id="p1">](../../mfc/reference/codbcfieldinfo-structure.md)</ept> structure.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>For more information about creating recordsets, see the article <bpt id="p1">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id="p1">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRecordCount</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Determines the size of the recordset.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The number of records in the recordset; 0 if the recordset contains no records; or –1 if the record count cannot be determined.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>The record count is maintained as a "high water mark," the highest-numbered record yet seen as the user moves through the records.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The total number of records is only known after the user has moved beyond the last record.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>For performance reasons, the count is not updated when you call <ph id="ph1">`MoveLast`</ph>.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>To count the records yourself, call <ph id="ph1">`MoveNext`</ph> repeatedly until <ph id="ph2">`IsEOF`</ph> returns nonzero.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Adding a record via <bpt id="p1">**</bpt>CRecordset:AddNew<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Update<ept id="p2">**</ept> increases the count; deleting a record via <ph id="ph1">`CRecordset::Delete`</ph> decreases the count.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowsetSize</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Obtains the current setting for the number of rows you wish to retrieve during a given fetch.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>The number of rows to retrieve during a given fetch.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>If you are using bulk row fetching, the default rowset size when the recordset is opened is 25; otherwise, it is 1.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must specify the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option in the <ph id="ph2">`dwOptions`</ph> parameter of the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>To change the setting for the rowset size, call <bpt id="p1">[</bpt>SetRowsetSize<ept id="p1">](#crecordset__setrowsetsize)</ept>.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowsFetched</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Determines how many records were actually retrieved after a fetch.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>The number of rows retrieved from the data source after a given fetch.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>This is useful when you have implemented bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>The rowset size normally indicates how many rows will be retrieved from a fetch; however, the total number of rows in the recordset also affects how many rows will be retrieved in a rowset.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>For example, if your recordset has 10 records with a rowset size setting of 4, then looping through the recordset by calling <ph id="ph1">`MoveNext`</ph> will result in the final rowset having only 2 records.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must specify the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option in the <ph id="ph2">`dwOptions`</ph> parameter of the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>To specify the rowset size, call <bpt id="p1">[</bpt>SetRowsetSize<ept id="p1">](#crecordset__setrowsetsize)</ept>.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#24</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>CRecordset::GetRowStatus</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Obtains the status for a row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The one-based position of a row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>This value can range from 1 to the size of the rowset.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>A status value for the row.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>For details, see Remarks.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>returns a value that indicates either any change in status to the row since it was last retrieved from the data source, or that no row corresponding to <ph id="ph1">`wRow`</ph> was fetched.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The following table lists the possible return values.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Status value</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The row is unchanged.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The row has been updated.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The row has been deleted.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The row has been added.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>The row is unretrievable due to an error.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>There is no row that corresponds to <ph id="ph1">`wRow`</ph>.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>For more information, see the ODBC API function <bpt id="p1">**</bpt>SQLExtendedFetch<ept id="p1">**</ept> in the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>CRecordset::GetStatus</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Determines the index of the current record in the recordset and whether the last record has been seen.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>A reference to a <bpt id="p1">**</bpt>CRecordsetStatus<ept id="p1">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>See the Remarks section for more information.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>attempts to track the index, but under some circumstances this may not be possible.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>GetRecordCount<ept id="p1">](#crecordset__getrecordcount)</ept> for an explanation.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>CRecordsetStatus<ept id="p1">**</ept> structure has the following form:</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The two members of <bpt id="p1">**</bpt>CRecordsetStatus<ept id="p1">**</ept> have the following meanings:</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m_lCurrentRecord<ept id="p1">**</ept> Contains the zero-based index of the current record in the recordset, if known.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>If the index cannot be determined, this member contains <bpt id="p1">**</bpt>AFX_CURRENT_RECORD_UNDEFINED<ept id="p1">**</ept> (–2).</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IsBOF`</ph> is <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept> (empty recordset or attempt to scroll before first record), then <bpt id="p2">**</bpt>m_lCurrentRecord<ept id="p2">**</ept> is set to <bpt id="p3">**</bpt>AFX_CURRENT_RECORD_BOF<ept id="p3">**</ept> (–1).</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>If on the first record, then it is set to 0, second record 1, and so on.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m_bRecordCountFinal<ept id="p1">**</ept> Nonzero if the total number of records in the recordset has been determined.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>Generally this must be accomplished by starting at the beginning of the recordset and calling <ph id="ph1">`MoveNext`</ph> until <ph id="ph2">`IsEOF`</ph> returns nonzero.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>If this member is zero, the record count as returned by <ph id="ph1">`GetRecordCount`</ph>, if not –1, is only a "high water mark" count of the records.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>CRecordset::GetSQL</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Call this member function to get the SQL statement that was used to select the recordset's records when it was opened.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>const<ept id="p1">**</ept> reference to a <ph id="ph1">`CString`</ph> that contains the SQL statement.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>This will generally be a SQL <bpt id="p1">**</bpt>SELECT<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>The string returned by <ph id="ph1">`GetSQL`</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>The string returned by <ph id="ph1">`GetSQL`</ph> is typically different from any string you may have passed to the recordset in the <ph id="ph2">`lpszSQL`</ph> parameter to the <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>This is because the recordset constructs a full SQL statement based on what you passed to <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, what you specified with ClassWizard, what you may have specified in the <bpt id="p2">**</bpt>m_strFilter<ept id="p2">**</ept> and <ph id="ph1">`m_strSort`</ph> data members, and any parameters you may have specified.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>For details about how the recordset constructs this SQL statement, see the article <bpt id="p1">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id="p1">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Call this member function only after calling <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept>.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>CRecordset::GetTableName</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Gets the name of the SQL table on which the recordset's query is based.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>const<ept id="p1">**</ept> reference to a <ph id="ph1">`CString`</ph> that contains the table name, if the recordset is based on a table; otherwise, an empty string.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>is only valid if the recordset is based on a table, not a join of multiple tables or a predefined query (stored procedure).</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>The name is read-only.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Call this member function only after calling <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept>.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>CRecordset::IsBOF</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset has been positioned before the first record.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>There is no current record.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset contains no records or if you have scrolled backward before the first record; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>Call this member function before you scroll from record to record to learn whether you have gone before the first record of the recordset.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>You can also use <ph id="ph1">`IsBOF`</ph> along with <ph id="ph2">`IsEOF`</ph> to determine whether the recordset contains any records or is empty.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>Immediately after you call <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, if the recordset contains no records, <ph id="ph1">`IsBOF`</ph> returns nonzero.When you open a recordset that has at least one record, the first record is the current record and <ph id="ph2">`IsBOF`</ph> returns 0.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>If the first record is the current record and you call <ph id="ph1">`MovePrev`</ph>, <ph id="ph2">`IsBOF`</ph> will subsequently return nonzero.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IsBOF`</ph> returns nonzero and you call <ph id="ph2">`MovePrev`</ph>, an error occurs.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IsBOF`</ph> returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>This example uses <ph id="ph1">`IsBOF`</ph> and <ph id="ph2">`IsEOF`</ph> to detect the limits of a recordset as the code scrolls through the recordset in both directions.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#25</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>CRecordset::IsDeleted</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Determines whether the current record has been deleted.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset is positioned on a deleted record; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>If you scroll to a record and <ph id="ph1">`IsDeleted`</ph> returns <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept> (nonzero), then you must scroll to another record before you can perform any other recordset operations.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The result of <ph id="ph1">`IsDeleted`</ph> depends on many factors, such as your recordset type, whether your recordset is updatable, whether you specified the <bpt id="p1">**</bpt>CRecordset::skipDeletedRecords<ept id="p1">**</ept> option when you opened the recordset, whether your driver packs deleted records, and whether there are multiple users.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>For more information about <bpt id="p1">**</bpt>CRecordset::skipDeletedRecords<ept id="p1">**</ept> and driver packing, see the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you should not call <ph id="ph1">`IsDeleted`</ph>.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>Instead, call the <bpt id="p1">[</bpt>GetRowStatus<ept id="p1">](#crecordset__getrowstatus)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>CRecordset::IsEOF</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the recordset has been positioned after the last record.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>There is no current record.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset contains no records or if you have scrolled beyond the last record; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>Call this member function as you scroll from record to record to learn whether you have gone beyond the last record of the recordset.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>You can also use <ph id="ph1">`IsEOF`</ph> to determine whether the recordset contains any records or is empty.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>Immediately after you call <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, if the recordset contains no records, <ph id="ph1">`IsEOF`</ph> returns nonzero.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>When you open a recordset that has at least one record, the first record is the current record and <ph id="ph1">`IsEOF`</ph> returns 0.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>If the last record is the current record when you call <ph id="ph1">`MoveNext`</ph>, <ph id="ph2">`IsEOF`</ph> will subsequently return nonzero.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IsEOF`</ph> returns nonzero and you call <ph id="ph2">`MoveNext`</ph>, an error occurs.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IsEOF`</ph> returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept>.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldDirty</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Determines whether the specified field data member has been changed since <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> or <bpt id="p2">[</bpt>AddNew<ept id="p2">](#crecordset__addnew)</ept> was called.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>A pointer to the field data member whose status you want to check, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to determine if any of the fields are dirty.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>Nonzero if the specified field data member has changed since calling <ph id="ph1">`AddNew`</ph> or <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>The data in all dirty field data members will be transferred to the record on the data source when the current record is updated by a call to the <bpt id="p1">[</bpt>Update<ept id="p1">](#crecordset__update)</ept> member function of <ph id="ph1">`CRecordset`</ph> (following a call to <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> or <ph id="ph2">`AddNew`</ph>).</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>This member function is not applicable on recordsets that are using bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, then <ph id="ph1">`IsFieldDirty`</ph> will always return <bpt id="p1">**</bpt>FALSE<ept id="p1">**</ept> and will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`IsFieldDirty`</ph> will reset the effects of preceding calls to <bpt id="p1">[</bpt>SetFieldDirty<ept id="p1">](#crecordset__setfielddirty)</ept> since the dirty status of the field is re-evaluated.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`AddNew`</ph> case, if the current field value differs from the pseudo null value, the field status is set dirty.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> case, if the field value differs from the cached value, then the field status is set dirty.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>is implemented through <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>For more information on the dirty flag, see the article <bpt id="p1">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id="p1">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldNull</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the specified field in the current record is Null (has no value).</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>A pointer to the field data member whose status you want to check, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to determine if any of the fields are Null.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>Nonzero if the specified field data member is flagged as Null; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Call this member function to determine whether the specified field data member of a recordset has been flagged as Null.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>(In database terminology, Null means "having no value" and is not the same as <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> in C++.) If a field data member is flagged as Null, it is interpreted as a column of the current record for which there is no value.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>This member function is not applicable on recordsets that are using bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, then <ph id="ph1">`IsFieldNull`</ph> will always return <bpt id="p1">**</bpt>FALSE<ept id="p1">**</ept> and will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>is implemented through <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>CRecordset::IsFieldNullable</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>Returns nonzero if the specified field in the current record can be set to Null (having no value).</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>A pointer to the field data member whose status you want to check, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to determine if any of the fields can be set to a Null value.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Call this member function to determine whether the specified field data member is "nullable" (can be set to a Null value; C++ <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> is not the same as Null, which, in database terminology, means "having no value").</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you cannot call <ph id="ph1">`IsFieldNullable`</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Instead, call the <bpt id="p1">[</bpt>GetODBCFieldInfo<ept id="p1">](#crecordset__getodbcfieldinfo)</ept> member function to determine whether a field can be set to a Null value.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Note that you can always call <ph id="ph1">`GetODBCFieldInfo`</ph>, regardless of whether you have implemented bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>A field that cannot be Null must have a value.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>If you attempt to set a such a field to Null when adding or updating a record, the data source rejects the addition or update, and <bpt id="p1">[</bpt>Update<ept id="p1">](#crecordset__update)</ept> will throw an exception.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>The exception occurs when you call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>, not when you call <bpt id="p2">[</bpt>SetFieldNull<ept id="p2">](#crecordset__setfieldnull)</ept>.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> for the first argument of the function will apply the function only to <bpt id="p2">**</bpt>outputColumn<ept id="p2">**</ept> fields, not <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>For instance, the call</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#26</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>will set only <bpt id="p1">**</bpt>outputColumn<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>; <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields will be unaffected.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>To work on <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields, you must supply the actual address of the individual <bpt id="p2">**</bpt>param<ept id="p2">**</ept> you want to work on, such as:</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#27</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>This means you cannot set all <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>, as you can with <bpt id="p3">**</bpt>outputColumn<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>is implemented through <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>CRecordset::IsOpen</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Determines if the recordset is already open.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset object's <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> or <bpt id="p2">[</bpt>Requery<ept id="p2">](#crecordset__requery)</ept> member function has previously been called and the recordset has not been closed; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>CRecordset::m_hstmt</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>Contains a handle to the ODBC statement data structure, of type <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept>, associated with the recordset.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Each query to an ODBC data source is associated with an <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Do not use <bpt id="p1">**</bpt>m_hstmt<ept id="p1">**</ept> before <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> has been called.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Normally you do not need to access the <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept> directly, but you might need it for direct execution of SQL statements.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ExecuteSQL`</ph> member function of class <ph id="ph2">`CDatabase`</ph> provides an example of using <bpt id="p1">**</bpt>m_hstmt<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>CRecordset::m_nFields</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Contains the number of field data members in the recordset class; that is, the number of columns selected by the recordset from the data source.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The constructor for the recordset class must initialize <ph id="ph1">`m_nFields`</ph> with the correct number.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>If you have not implemented bulk row fetching, ClassWizard writes this initialization for you when you use it to declare your recordset class.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>You can also write it manually.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>The framework uses this number to manage interaction between the field data members and the corresponding columns of the current record on the data source.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>This number must correspond to the number of "output columns" registered in <ph id="ph1">`DoFieldExchange`</ph> or <ph id="ph2">`DoBulkFieldExchange`</ph> after a call to <bpt id="p1">[</bpt>SetFieldType<ept id="p1">](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype)</ept> with the parameter <bpt id="p2">**</bpt>CFieldExchange::outputColumn<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>You can bind columns dynamically, as explained in the article "Recordset: Dynamically Binding Data Columns."</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>If you do so, you must increase the count in <ph id="ph1">`m_nFields`</ph> to reflect the number of RFX or Bulk RFX function calls in your <ph id="ph2">`DoFieldExchange`</ph> or <ph id="ph3">`DoBulkFieldExchange`</ph> member function for the dynamically bound columns.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>For more information, see the articles <bpt id="p1">[</bpt>Recordset: Dynamically Binding Data Columns (ODBC)<ept id="p1">](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p2">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>See the article <bpt id="p1">[</bpt>Record Field Exchange: Using RFX<ept id="p1">](../../data/odbc/record-field-exchange-using-rfx.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>CRecordset::m_nParams</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>Contains the number of parameter data members in the recordset class; that is, the number of parameters passed with the recordset's query.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>If your recordset class has any parameter data members, the constructor for the class must initialize <ph id="ph1">`m_nParams`</ph> with the correct number.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The value of <ph id="ph1">`m_nParams`</ph> defaults to 0.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>If you add parameter data members (which you must do manually) you must also manually add an initialization in the class constructor to reflect the number of parameters (which must be at least as large as the number of '' placeholders in your <bpt id="p1">**</bpt>m_strFilter<ept id="p1">**</ept> or <ph id="ph1">`m_strSort`</ph> string).</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>The framework uses this number when it parameterizes the recordset's query.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>This number must correspond to the number of "params" registered in <ph id="ph1">`DoFieldExchange`</ph> or <ph id="ph2">`DoBulkFieldExchange`</ph> after a call to <bpt id="p1">[</bpt>SetFieldType<ept id="p1">](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype)</ept> with a parameter value of <bpt id="p2">**</bpt>CFieldExchange::inputParam<ept id="p2">**</ept>, <bpt id="p3">**</bpt>CFieldExchange::param<ept id="p3">**</ept>, <bpt id="p4">**</bpt>CFieldExchange::outputParam<ept id="p4">**</ept>, or <bpt id="p5">**</bpt>CFieldExchange::inoutParam<ept id="p5">**</ept>.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>See the articles <bpt id="p1">[</bpt>Recordset: Parameterizing a Recordset (ODBC)<ept id="p1">](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)</ept> and <bpt id="p2">[</bpt>Record Field Exchange: Using RFX<ept id="p2">](../../data/odbc/record-field-exchange-using-rfx.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>CRecordset::m_pDatabase</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Contains a pointer to the <ph id="ph1">`CDatabase`</ph> object through which the recordset is connected to a data source.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>This variable is set in two ways.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Typically, you pass a pointer to an already connected <ph id="ph1">`CDatabase`</ph> object when you construct the recordset object.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>If you pass <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> instead, <ph id="ph1">`CRecordset`</ph> creates a <ph id="ph2">`CDatabase`</ph> object for you and connects it.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>In either case, <ph id="ph1">`CRecordset`</ph> stores the pointer in this variable.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Normally you will not directly need to use the pointer stored in <bpt id="p1">**</bpt>m_pDatabase<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>If you write your own extensions to <ph id="ph1">`CRecordset`</ph>, however, you might need to use the pointer.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>For example, you might need the pointer if you throw your own <ph id="ph1">`CDBException`</ph>s.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Or you might need it if you need to do something using the same <ph id="ph1">`CDatabase`</ph> object, such as running transactions, setting timeouts, or calling the <ph id="ph2">`ExecuteSQL`</ph> member function of class <ph id="ph3">`CDatabase`</ph> to execute SQL statements directly.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>CRecordset::m_strFilter</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>After you construct the recordset object, but before you call its <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> member function, use this data member to store a <ph id="ph1">`CString`</ph> containing a SQL <bpt id="p2">**</bpt>WHERE<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>The recordset uses this string to constrain (or filter) the records it selects during the <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Requery<ept id="p2">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>This is useful for selecting a subset of records, such as "all salespersons based in California" ("state = CA").</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>The ODBC SQL syntax for a <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> clause is</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Note that you do not include the <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> keyword in your string.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>The framework supplies it.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>You can also parameterize your filter string by placing '' placeholders in it, declaring a parameter data member in your class for each placeholder, and passing parameters to the recordset at run time.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>This lets you construct the filter at run time.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Parameterizing a Recordset (ODBC)<ept id="p1">](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>For more information about SQL <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> clauses, see the article <bpt id="p2">[</bpt>SQL<ept id="p2">](../../data/odbc/sql.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>For more information about selecting and filtering records, see the article <bpt id="p1">[</bpt>Recordset: Filtering Records (ODBC)<ept id="p1">](../../data/odbc/recordset-filtering-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#30</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>CRecordset::m_strSort</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>After you construct the recordset object, but before you call its <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> member function, use this data member to store a <ph id="ph1">`CString`</ph> containing a SQL <bpt id="p2">**</bpt>ORDER BY<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>The recordset uses this string to sort the records it selects during the <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Requery<ept id="p2">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>You can use this feature to sort a recordset on one or more columns.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>The ODBC SQL syntax for an <bpt id="p1">**</bpt>ORDER BY<ept id="p1">**</ept> clause is</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>where a sort-specification is an integer or a column name.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>You can also specify ascending or descending order (the order is ascending by default) by appending "ASC" or "DESC" to the column list in the sort string.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>The selected records are sorted first by the first column listed, then by the second, and so on.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>For example, you might order a "Customers" recordset by last name, then first name.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>The number of columns you can list depends on the data source.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>For more information, see the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>Note that you do not include the <bpt id="p1">**</bpt>ORDER BY<ept id="p1">**</ept> keyword in your string.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The framework supplies it.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>For more information about SQL clauses, see the article <bpt id="p1">[</bpt>SQL<ept id="p1">](../../data/odbc/sql.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>For more information about sorting records, see the article <bpt id="p1">[</bpt>Recordset: Sorting Records (ODBC)<ept id="p1">](../../data/odbc/recordset-sorting-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#31</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>CRecordset::Move</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Moves the current record pointer within the recordset, either forward or backward.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>The number of rows to move forward or backward.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>Positive values move forward, toward the end of the recordset.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>Negative values move backward, toward the beginning.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Determines the rowset that <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> will fetch.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>For details, see Remarks.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>If you pass a value of 0 for <ph id="ph1">`nRows`</ph>, <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> refreshes the current record; <bpt id="p2">**</bpt>Move<ept id="p2">**</ept> will end any current <ph id="ph2">`AddNew`</ph> or <bpt id="p3">**</bpt>Edit<ept id="p3">**</ept> mode, and will restore the current record's value before <ph id="ph3">`AddNew`</ph> or <bpt id="p4">**</bpt>Edit<ept id="p4">**</ept> was called.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>When you move through a recordset, you cannot skip deleted records.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>CRecordset::IsDeleted<ept id="p1">](#crecordset__isdeleted)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>When you open a <ph id="ph1">`CRecordset`</ph> with the <bpt id="p1">**</bpt>skipDeletedRecords<ept id="p1">**</ept> option set, <bpt id="p2">**</bpt>Move<ept id="p2">**</ept> asserts if the <ph id="ph2">`nRows`</ph> parameter is 0.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>This behavior prevents the refresh of rows that are deleted by other client applications using the same data.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>See the <ph id="ph1">`dwOption`</ph> parameter in <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> for a description of <bpt id="p2">**</bpt>skipDeletedRecords<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Move<ept id="p1">**</ept> repositions the recordset by rowsets.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>Based on the values for <ph id="ph1">`nRows`</ph> and <ph id="ph2">`wFetchType`</ph>, <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> fetches the appropriate rowset and then makes the first record in that rowset the current record.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>If you have not implemented bulk row fetching, then the rowset size is always 1.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>When fetching a rowset, <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> directly calls the <bpt id="p2">[</bpt>CheckRowsetError<ept id="p2">](#crecordset__checkrowseterror)</ept> member function to handle any errors resulting from the fetch.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Depending on the values you pass, <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> is equivalent to other <ph id="ph1">`CRecordset`</ph> member functions.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>In particular, the value of <ph id="ph1">`wFetchType`</ph> may indicate a member function that is more intuitive and often the preferred method for moving the current record.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The following table lists the possible values for <ph id="ph1">`wFetchType`</ph>, the rowset that <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> will fetch based on <ph id="ph2">`wFetchType`</ph> and <ph id="ph3">`nRows`</ph>, and any equivalent member function corresponding to <ph id="ph4">`wFetchType`</ph>.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>wFetchType</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Fetched rowset</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>Equivalent member function</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>(the default value)</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The rowset starting <ph id="ph1">`nRows`</ph> row(s) from the first row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The next rowset; <ph id="ph1">`nRows`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>MoveNext</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The previous rowset; <ph id="ph1">`nRows`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>MovePrev</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>The first rowset in the recordset; <ph id="ph1">`nRows`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>MoveFirst</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The last complete rowset in the recordset; <ph id="ph1">`nRows`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>MoveLast</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`nRows`</ph> &gt; 0, the rowset starting <ph id="ph2">`nRows`</ph> row(s) from the beginning of the recordset.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`nRows`</ph> &lt; 0, the rowset starting <ph id="ph2">`nRows`</ph> row(s) from the end of the recordset.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`nRows`</ph> = 0, then a beginning-of-file (BOF) condition is returned.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>SetAbsolutePosition</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The rowset starting at the row whose bookmark value corresponds to <ph id="ph1">`nRows`</ph>.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>SetBookmark</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>For foward-only recordsets, <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> is only valid with a value of <ph id="ph1">`SQL_FETCH_NEXT`</ph> for <ph id="ph2">`wFetchType`</ph>.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>Calling <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> throws an exception if the recordset has no records.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>To determine whether the recordset has any records, call <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept> and <bpt id="p2">[</bpt>IsEOF<ept id="p2">](#crecordset__iseof)</ept>.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>If you have scrolled past the beginning or end of the recordset ( <ph id="ph1">`IsBOF`</ph> or <ph id="ph2">`IsEOF`</ph> returns nonzero), calling a <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> function will possibly throw a <ph id="ph3">`CDBException`</ph>.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>For example, if <ph id="ph1">`IsEOF`</ph> returns nonzero and <ph id="ph2">`IsBOF`</ph> does not, then <ph id="ph3">`MoveNext`</ph> will throw an exception, but <ph id="ph4">`MovePrev`</ph> will not.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>If you call <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> while the current record is being updated or added, the updates are lost without warning.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>For related information, see the ODBC API function <bpt id="p1">**</bpt>SQLExtendedFetch<ept id="p1">**</ept> in the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#28</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveFirst</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>Makes the first record in the first rowset the current record.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Regardless of whether bulk row fetching has been implemented, this will always be the first record in the recordset.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>You do not have to call <bpt id="p1">**</bpt>MoveFirst<ept id="p1">**</ept> immediately after you open the recordset.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>At that time, the first record (if any) is automatically the current record.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>This member function is not valid for forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>When you move through a recordset, you cannot skip deleted records.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>IsDeleted<ept id="p1">](#crecordset__isdeleted)</ept> member function for details.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>Calling any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions throws an exception if the recordset has no records.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>To determine whether the recordset has any records, call <ph id="ph1">`IsBOF`</ph> and <ph id="ph2">`IsEOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>If you call any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions while the current record is being updated or added, the updates are lost without warning.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept>.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveLast</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Makes the first record in the last complete rowset the current record.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id="ph1">`MoveLast`</ph> simply moves to the last record in the recordset.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>This member function is not valid for forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>When you move through a recordset, you cannot skip deleted records.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>IsDeleted<ept id="p1">](#crecordset__isdeleted)</ept> member function for details.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>Calling any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions throws an exception if the recordset has no records.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>To determine whether the recordset has any records, call <ph id="ph1">`IsBOF`</ph> and <ph id="ph2">`IsEOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>If you call any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions while the current record is being updated or added, the updates are lost without warning.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept>.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>CRecordset::MoveNext</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>Makes the first record in the next rowset the current record.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id="ph1">`MoveNext`</ph> simply moves to the next record.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>When you move through a recordset, you cannot skip deleted records.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>IsDeleted<ept id="p1">](#crecordset__isdeleted)</ept> member function for details.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Calling any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions throws an exception if the recordset has no records.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>To determine whether the recordset has any records, call <ph id="ph1">`IsBOF`</ph> and <ph id="ph2">`IsEOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>It is also recommended that you call <ph id="ph1">`IsEOF`</ph> before calling <ph id="ph2">`MoveNext`</ph>.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>For example, if you have scrolled past the end of the recordset, <ph id="ph1">`IsEOF`</ph> will return nonzero; a subsequent call to <ph id="ph2">`MoveNext`</ph> would throw an exception.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>If you call any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions while the current record is being updated or added, the updates are lost without warning.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept>.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>CRecordset::MovePrev</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Makes the first record in the previous rowset the current record.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id="ph1">`MovePrev`</ph> simply moves to the previous record.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>This member function is not valid for forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>When you move through a recordset, you cannot skip deleted records.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>IsDeleted<ept id="p1">](#crecordset__isdeleted)</ept> member function for details.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>Calling any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions throws an exception if the recordset has no records.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>To determine whether the recordset has any records, call <ph id="ph1">`IsBOF`</ph> and <ph id="ph2">`IsEOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>It is also recommended that you call <ph id="ph1">`IsBOF`</ph> before calling <ph id="ph2">`MovePrev`</ph>.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>For example, if you have scrolled ahead of the beginning of the recordset, <ph id="ph1">`IsBOF`</ph> will return nonzero; a subsequent call to <ph id="ph2">`MovePrev`</ph> would throw an exception.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>If you call any of the <bpt id="p1">**</bpt>Move<ept id="p1">**</ept> functions while the current record is being updated or added, the updates are lost without warning.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>See the example for <bpt id="p1">[</bpt>IsBOF<ept id="p1">](#crecordset__isbof)</ept>.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>CRecordset::OnSetOptions</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>Called to set options (used on selection) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept> of the ODBC statement whose options are to be set.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`OnSetOptions`</ph> to set options (used on selection) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>The framework calls this member function to set initial options for the recordset.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>(Whereas <ph id="ph1">`OnSetOptions`</ph> is used for selection operations, <ph id="ph2">`OnSetUpdateOptions`</ph> is used for update operations.)</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>Override <ph id="ph1">`OnSetOptions`</ph> to set options specific to the driver or the data source.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>For example, if your data source supports opening for exclusive access, you might override <ph id="ph1">`OnSetOptions`</ph> to take advantage of that ability.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>For more information about cursors, see the article <bpt id="p1">[</bpt>ODBC<ept id="p1">](../../data/odbc/odbc-basics.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>CRecordset::OnSetUpdateOptions</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>Called to set options (used on update) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>HSTMT<ept id="p1">**</ept> of the ODBC statement whose options are to be set.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`OnSetUpdateOptions`</ph> to set options (used on update) for the specified ODBC statement.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>The framework calls this member function after it creates an HSTMT to update records in a recordset.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>(Whereas <ph id="ph1">`OnSetOptions`</ph> is used for selection operations, <ph id="ph2">`OnSetUpdateOptions`</ph> is used for update operations.) <ph id="ph3">`OnSetUpdateOptions`</ph> determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>Override <ph id="ph1">`OnSetUpdateOptions`</ph> to set options of an ODBC statement before that statement is used to access a database.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>For more information about cursors, see the article <bpt id="p1">[</bpt>ODBC<ept id="p1">](../../data/odbc/odbc-basics.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>CRecordset::Open</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>Opens the recordset by retrieving the table or performing the query that the recordset represents.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>Accept the default value, <bpt id="p1">**</bpt>AFX_DB_USE_DEFAULT_TYPE<ept id="p1">**</ept>, or use one of the following values from the <bpt id="p2">**</bpt>enum OpenType<ept id="p2">**</ept>:</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::dynaset<ept id="p1">**</ept> A recordset with bi-directional scrolling.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The membership and ordering of the records are determined when the recordset is opened, but changes made by other users to the data values are visible following a fetch operation.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>Dynasets are also known as keyset-driven recordsets.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::snapshot<ept id="p1">**</ept> A static recordset with bi-directional scrolling.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>The membership and ordering of the records are determined when the recordset is opened; the data values are determined when the records are fetched.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>Changes made by other users are not visible until the recordset is closed and then reopened.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::dynamic<ept id="p1">**</ept> A recordset with bi-directional scrolling.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>Changes made by other users to the membership, ordering, and data values are visible following a fetch operation.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>Note that many ODBC drivers do not support this type of recordset.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::forwardOnly<ept id="p1">**</ept> A read-only recordset with only forward scrolling.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`CRecordset`</ph>, the default value is <bpt id="p1">**</bpt>CRecordset::snapshot<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>The default-value mechanism allows the Visual C++ wizards to interact with both ODBC <ph id="ph1">`CRecordset`</ph> and DAO <ph id="ph2">`CDaoRecordset`</ph>, which have different defaults.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>For more information about these recordset types, see the article <bpt id="p1">[</bpt>Recordset (ODBC)<ept id="p1">](../../data/odbc/recordset-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>For related information, see the article "Using Block and Scrollable Cursors" in the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>If the requested type is not supported, the framework throws an exception.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>A string pointer containing one of the following:</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> pointer.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>The name of a table.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>A SQL <bpt id="p1">**</bpt>SELECT<ept id="p1">**</ept> statement (optionally with a SQL <bpt id="p2">**</bpt>WHERE<ept id="p2">**</ept> or <bpt id="p3">**</bpt>ORDER BY<ept id="p3">**</ept> clause).</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> statement specifying the name of a predefined query (stored procedure).</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>Be careful that you do not insert whitespace between the curly brace and the <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>For more information about this string, see the table and the discussion of ClassWizard's role under Remarks.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>The order of the columns in your result set must match the order of the RFX or Bulk RFX function calls in your <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept> or <bpt id="p2">[</bpt>DoBulkFieldExchange<ept id="p2">](#crecordset__dobulkfieldexchange)</ept> function override.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>A bitmask which can specify a combination of the values listed below.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>Some of these are mutually exclusive.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">**</bpt>none<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::none<ept id="p1">**</ept> No options set.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>This parameter value is mutually exclusive with all other values.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>By default, the recordset can be updated with <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> or <bpt id="p2">[</bpt>Delete<ept id="p2">](#crecordset__delete)</ept> and allows appending new records with <bpt id="p3">[</bpt>AddNew<ept id="p3">](#crecordset__addnew)</ept>.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>Updatability depends on the data source as well as on the <ph id="ph1">`nOpenType`</ph> option you specify.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>Optimization for bulk additions is not available.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>Bulk row fetching will not be implemented.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>Deleted records will not be skipped during recordset navigation.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>Bookmarks are not available.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>Automatic dirty field checking is implemented.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::appendOnly<ept id="p1">**</ept> Do not allow <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> or <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> on the recordset.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>Allow <ph id="ph1">`AddNew`</ph> only.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>This option is mutually exclusive with <bpt id="p1">**</bpt>CRecordset::readOnly<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::readOnly<ept id="p1">**</ept> Open the recordset as read-only.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>This option is mutually exclusive with <bpt id="p1">**</bpt>CRecordset::appendOnly<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::optimizeBulkAdd<ept id="p1">**</ept> Use a prepared SQL statement to optimize adding many records at one time.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Applies only if you are not using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept> to update the recordset.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>The first update determines which fields are marked dirty.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>This option is mutually exclusive with <ph id="ph1">`CRecordset::useMultiRowFetch`</ph>.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>Implement bulk row fetching to allow multiple rows to be retrieved in a single fetch operation.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>This is an advanced feature designed to improve performance; however, bulk record field exchange is not supported by ClassWizard.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>This option is mutually exclusive with <bpt id="p1">**</bpt>CRecordset::optimizeBulkAdd<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>Note that if you specify <ph id="ph1">`CRecordset::useMultiRowFetch`</ph>, then the option <bpt id="p1">**</bpt>CRecordset::noDirtyFieldCheck<ept id="p1">**</ept> will be turned on automatically (double buffering will not be available); on forward-only recordsets, the option <bpt id="p2">**</bpt>CRecordset::useExtendedFetch<ept id="p2">**</ept> will be turned on automatically.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::skipDeletedRecords<ept id="p1">**</ept> Skip all deleted records when navigating through the recordset.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>This will slow performance in certain relative fetches.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>This option is not valid on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>If you call <bpt id="p1">[</bpt>Move<ept id="p1">](#crecordset__move)</ept> with the <ph id="ph1">`nRows`</ph> parameter set to 0, and the <bpt id="p2">**</bpt>CRecordset::skipDeletedRecords<ept id="p2">**</ept> option set, <bpt id="p3">**</bpt>Move<ept id="p3">**</ept> will assert.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt>CRecordset::skipDeletedRecords<ept id="p1">**</ept> is similar to <bpt id="p2">*</bpt>driver packing<ept id="p2">*</ept>, which means that deleted rows are removed from the recordset.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>However, if your driver packs records, then it will skip only those records that you delete; it will not skip records deleted by other users while the recordset is open.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::skipDeletedRecords<ept id="p1">**</ept> will skip rows deleted by other users.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::useBookmarks<ept id="p1">**</ept> May use bookmarks on the recordset, if supported.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>Bookmarks slow data retrieval but improve performance for data navigation.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>Not valid on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p1">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::noDirtyFieldCheck<ept id="p1">**</ept> Turn off automatic dirty field checking (double buffering).</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>This will improve performance; however, you must manually mark fields as dirty by calling the <ph id="ph1">`SetFieldDirty`</ph> and <ph id="ph2">`SetFieldNull`</ph> member functions.Note that double buffering in class <ph id="ph3">`CRecordset`</ph> is similar to double buffering in class <ph id="ph4">`CDaoRecordset`</ph>.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>However, in <ph id="ph1">`CRecordset`</ph>, you cannot enable double buffering on individual fields; you either enable it for all fields or disable it for all fields.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>Note that if you specify the option <ph id="ph1">`CRecordset::useMultiRowFetch`</ph>, then <bpt id="p1">**</bpt>CRecordset::noDirtyFieldCheck<ept id="p1">**</ept> will be turned on automatically; however, <ph id="ph2">`SetFieldDirty`</ph> and <ph id="ph3">`SetFieldNull`</ph> cannot be used on recordsets that implement bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::executeDirect<ept id="p1">**</ept> Do not use a prepared SQL statement.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>For improved performance, specify this option if the <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> member function will never be called.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::useExtendedFetch<ept id="p1">**</ept> Implement <bpt id="p2">**</bpt>SQLExtendedFetch<ept id="p2">**</ept> instead of <bpt id="p3">**</bpt>SQLFetch<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>This is designed for implementing bulk row fetching on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>If you specify the option <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> on a forward-only recordset, then <bpt id="p1">**</bpt>CRecordset::useExtendedFetch<ept id="p1">**</ept> will be turned on automatically.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id="p1">**</ept> The user will allocate storage buffers for the data.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>Use this option in conjunction with <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> if you want to allocate your own storage; otherwise, the framework will automatically allocate the necessary storage.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>Note that specifying <bpt id="p1">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id="p1">**</ept> without specifying <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>Nonzero if the <ph id="ph1">`CRecordset`</ph> object was successfully opened; otherwise 0 if <bpt id="p1">[</bpt>CDatabase::Open<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__open)</ept> (if called) returns 0.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>You must call this member function to run the query defined by the recordset.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>Before calling <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, you must construct the recordset object.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>This recordset's connection to the data source depends on how you construct the recordset before calling <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>If you pass a <bpt id="p1">[</bpt>CDatabase<ept id="p1">](../../mfc/reference/cdatabase-class.md)</ept> object to the recordset constructor that has not been connected to the data source, this member function uses <bpt id="p2">[</bpt>GetDefaultConnect<ept id="p2">](#crecordset__getdefaultconnect)</ept> to attempt to open the database object.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>If you pass <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to the recordset constructor, the constructor constructs a <ph id="ph1">`CDatabase`</ph> object for you, and <bpt id="p2">**</bpt>Open<ept id="p2">**</ept> attempts to connect the database object.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>For details on closing the recordset and the connection under these varying circumstances, see <bpt id="p1">[</bpt>Close<ept id="p1">](#crecordset__close)</ept>.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>Access to a data source through a <ph id="ph1">`CRecordset`</ph> object is always shared.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>Unlike the <ph id="ph1">`CDaoRecordset`</ph> class, you cannot use a <ph id="ph2">`CRecordset`</ph> object to open a data source with exclusive access.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>When you call <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>, a query, usually a SQL <bpt id="p2">**</bpt>SELECT<ept id="p2">**</ept> statement, selects records based on criteria shown in the following table.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>Value of the lpszSQL parameter</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>Records selected are determined by</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>NULL</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>The string returned by <ph id="ph1">`GetDefaultSQL`</ph>.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>SQL table name</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>All columns of the table-list in <ph id="ph1">`DoFieldExchange`</ph> or <ph id="ph2">`DoBulkFieldExchange`</ph>.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>Predefined query (stored procedure) name</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>The columns the query is defined to return.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SELECT<ept id="p1">**</ept> column-list <bpt id="p2">**</bpt>FROM<ept id="p2">**</ept> table-list</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>The specified columns from the specified table(s).</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>Be careful that you do not insert extra whitespace in your SQL string.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>For example, if you insert whitespace between the curly brace and the <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a <bpt id="p2">**</bpt>SELECT<ept id="p2">**</ept> statement, which will result in an exception being thrown.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>Similarly, if your predefined query uses an output parameter, do not insert whitespace between the curly brace and the '' symbol.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>Finally, you must not insert whitespace before the curly brace in a <bpt id="p1">**</bpt>CALL<ept id="p1">**</ept> statement or before the <bpt id="p2">**</bpt>SELECT<ept id="p2">**</ept> keyword in a <bpt id="p3">**</bpt>SELECT<ept id="p3">**</ept> statment.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>The usual procedure is to pass <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> to <bpt id="p2">**</bpt>Open<ept id="p2">**</ept>; in this case, <bpt id="p3">**</bpt>Open<ept id="p3">**</ept> calls <bpt id="p4">[</bpt>GetDefaultSQL<ept id="p4">](#crecordset__getdefaultsql)</ept>.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>If you are using a derived <ph id="ph1">`CRecordset`</ph> class, <bpt id="p1">**</bpt>GetDefaultSQL<ept id="p1">**</ept> gives the table name(s) you specified in ClassWizard.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>You can instead specify other information in the <ph id="ph1">`lpszSQL`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>Whatever you pass, <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> constructs a final SQL string for the query (the string may have SQL <bpt id="p2">**</bpt>WHERE<ept id="p2">**</ept> and <bpt id="p3">**</bpt>ORDER BY<ept id="p3">**</ept> clauses appended to the <ph id="ph1">`lpszSQL`</ph> string you passed) and then executes the query.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>You can examine the constructed string by calling <bpt id="p1">[</bpt>GetSQL<ept id="p1">](#crecordset__getsql)</ept> after calling <bpt id="p2">**</bpt>Open<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>For additional details about how the recordset constructs a SQL statement and selects records, see the article <bpt id="p1">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id="p1">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>The field data members of your recordset class are bound to the columns of the data selected.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>If any records are returned, the first record becomes the current record.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>If you want to set options for the recordset, such as a filter or sort, specify these after you construct the recordset object but before you call <bpt id="p1">**</bpt>Open<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>If you want to refresh the records in the recordset after the recordset is already open, call <bpt id="p1">[</bpt>Requery<ept id="p1">](#crecordset__requery)</ept>.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>For more information, including additional examples, see the articles <bpt id="p1">[</bpt>Recordset (ODBC)<ept id="p1">](../../data/odbc/recordset-odbc.md)</ept>, <bpt id="p2">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id="p2">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>, and <bpt id="p3">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id="p3">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>The following code examples show different forms of the <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> call.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#16</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>CRecordset::RefreshRowset</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>Updates the data and the status for a row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>The one-based position of a row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source>This value can range from zero to the size of the rowset.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>A value indicating how to lock the row after it has been refreshed.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>For details, see Remarks.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>If you pass a value of zero for <ph id="ph1">`wRow`</ph>, then every row in the rowset will be refreshed.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>To use <ph id="ph1">`RefreshRowset`</ph>, you must have implemented bulk row fetching by specifying the <bpt id="p1">**</bpt>CRecordset::useMulitRowFetch<ept id="p1">**</ept> option in the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>calls the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`wLockType`</ph> parameter specifies the lock state of the row after <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept> has executed.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>The following table describes the possible values for <ph id="ph1">`wLockTyp`</ph>e.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>wLockType</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>(the default value)</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>The driver or data source ensures that the row is in the same locked or unlocked state as it was before <ph id="ph1">`RefreshRowset`</ph> was called.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>The driver or data source locks the row exclusively.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>Not all data sources support this type of lock.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>The driver or data source unlocks the row.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>Not all data sources support this type of lock.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>For more information about <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>, see the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve">
          <source>CRecordset::Requery</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>Rebuilds (refreshes) a recordset.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>Nonzero if the recordset was successfully rebuilt; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>If any records are returned, the first record becomes the current record.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>In order for the recordset to reflect the additions and deletions that you or other users are making to the data source, you must rebuild the recordset by calling <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source>If the recordset is a dynaset, it automatically reflects updates that you or other users make to its existing records (but not additions).</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>If the recordset is a snapshot, you must call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> to reflect edits by other users as well as additions and deletions.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source>For either a dynaset or a snapshot, call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> any time you want to rebuild the recordset using a new filter or sort, or new parameter values.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source>Set the new filter or sort property by assigning new values to <bpt id="p1">**</bpt>m_strFilter<ept id="p1">**</ept> and <ph id="ph1">`m_strSort`</ph> before calling <bpt id="p2">**</bpt>Requery<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source>Set new parameters by assigning new values to parameter data members before calling <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source>If the filter and sort strings are unchanged, you can reuse the query, which improves performance.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>If the attempt to rebuild the recordset fails, the recordset is closed.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve">
          <source>Before you call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>, you can determine whether the recordset can be requeried by calling the <ph id="ph1">`CanRestart`</ph> member function.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve">
          <source>does not guarantee that <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> will succeed.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept> only after you have called <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept>.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source>This example rebuilds a recordset to apply a different sort order.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#29</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source>CRecordset::SetAbsolutePosition</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve">
          <source>Positions the recordset on the record corresponding to the specified record number.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve">
          <source>The one-based ordinal position for the current record in the recordset.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>moves the current record pointer based on this ordinal position.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source>This member function is not valid on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>For ODBC recordsets, an absolute position setting of 1 refers to the first record in the recordset; a setting of 0 refers to the beginning-of-file (BOF) position.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>You can also pass negative values to <ph id="ph1">`SetAbsolutePosition`</ph>.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>In this case the recordset's position is evaluated from the end of the recordset.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`SetAbsolutePosition( -1 )`</ph> moves the current record pointer to the last record in the recordset.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>Absolute position is not intended to be used as a surrogate record number.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>Bookmarks are still the recommended way of retaining and returning to a given position, since a record's position changes when preceding records are deleted.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an <bpt id="p1">**</bpt>ORDER BY<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>For more information about recordset navigation and bookmarks, see the articles <bpt id="p1">[</bpt>Recordset: Scrolling (ODBC)<ept id="p1">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p2">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>CRecordset::SetBookmark</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source>Positions the recordset on the record containing the specified bookmark.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source>A reference to a <bpt id="p1">[</bpt>CDBVariant<ept id="p1">](../../mfc/reference/cdbvariant-class.md)</ept> object containing the bookmark value for a specific record.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve">
          <source>To determine if bookmarks are supported on the recordset, call <bpt id="p1">[</bpt>CanBookmark<ept id="p1">](#crecordset__canbookmark)</ept>.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve">
          <source>To make bookmarks available if they are supported, you must set the <bpt id="p1">**</bpt>CRecordset::useBookmarks<ept id="p1">**</ept> option in the <ph id="ph1">`dwOptions`</ph> parameter of the <bpt id="p2">[</bpt>Open<ept id="p2">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source>If bookmarks are unsupported or unavailable, calling <ph id="ph1">`SetBookmark`</ph> will result in an exception being thrown.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source>Bookmarks are not supported on forward-only recordsets.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source>To first retrieve the bookmark for the current record, call <bpt id="p1">[</bpt>GetBookmark<ept id="p1">](#crecordset__getbookmark)</ept>, which saves the bookmark value to a <ph id="ph1">`CDBVariant`</ph> object.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>Later, you can return to that record by calling <ph id="ph1">`SetBookmark`</ph> using the saved bookmark value.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>After certain recordset operations, you should check the bookmark persistence before calling <ph id="ph1">`SetBookmark`</ph>.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve">
          <source>For example, if you retrieve a bookmark with <ph id="ph1">`GetBookmark`</ph> and then call <bpt id="p1">**</bpt>Requery<ept id="p1">**</ept>, the bookmark may no longer be valid.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt>CDatabase::GetBookmarkPersistence<ept id="p1">](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence)</ept> to check whether you can safely call <ph id="ph1">`SetBookmark`</ph>.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source>For more information about bookmarks and recordset navigation, see the articles <bpt id="p1">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id="p1">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id="p2">[</bpt>Recordset: Scrolling (ODBC)<ept id="p2">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source>CRecordset::SetFieldDirty</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve">
          <source>Flags a field data member of the recordset as changed or as unchanged.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve">
          <source>Contains the address of a field data member in the recordset or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, all field data members in the recordset are flagged.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>(C++ <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> is not the same as Null in database terminology, which means "having no value.")</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> **</bpt>TRUE<ept id="p1">**</ept> if the field data member is to be flagged as "dirty" (changed).</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source>Otherwise <bpt id="p1">**</bpt>FALSE<ept id="p1">**</ept> if the field data member is to be flagged as "clean" (unchanged).</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source>Marking fields as unchanged ensures the field is not updated and results in less SQL traffic.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve">
          <source>This member function is not applicable on recordsets that are using bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, then <ph id="ph1">`SetFieldDirty`</ph> will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve">
          <source>The framework marks changed field data members to ensure they will be written to the record on the data source by the record field exchange (RFX) mechanism.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve">
          <source>Changing the value of a field generally sets the field dirty automatically, so you will seldom need to call <ph id="ph1">`SetFieldDirty`</ph> yourself, but you might sometimes want to ensure that columns will be explicitly updated or inserted regardless of what value is in the field data member.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve">
          <source>Call this member function only after you have called <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> or <bpt id="p2">[</bpt>AddNew<ept id="p2">](#crecordset__addnew)</ept>.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> for the first argument of the function will apply the function only to <bpt id="p2">**</bpt>outputColumn<ept id="p2">**</ept> fields, not <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>For instance, the call</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#26</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>will set only <bpt id="p1">**</bpt>outputColumn<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>; <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields will be unaffected.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve">
          <source>To work on <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields, you must supply the actual address of the individual <bpt id="p2">**</bpt>param<ept id="p2">**</ept> you want to work on, such as:</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#27</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve">
          <source>This means you cannot set all <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>, as you can with <bpt id="p3">**</bpt>outputColumn<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source>CRecordset::SetFieldNull</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve">
          <source>Flags a field data member of the recordset as Null (specifically having no value) or as non-Null.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve">
          <source>Contains the address of a field data member in the recordset or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, all field data members in the recordset are flagged.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve">
          <source>(C++ <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> is not the same as Null in database terminology, which means "having no value.")</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve">
          <source>Nonzero if the field data member is to be flagged as having no value (Null).</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>Otherwise 0 if the field data member is to be flagged as non-Null.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve">
          <source>When you add a new record to a recordset, all field data members are initially set to a Null value and flagged as "dirty" (changed).</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve">
          <source>When you retrieve a record from a data source, its columns either already have values or are Null.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve">
          <source>Do not call this member function on recordsets that are using bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, calling <ph id="ph1">`SetFieldNull`</ph> results in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve">
          <source>If you specifically wish to designate a field of the current record as not having a value, call <ph id="ph1">`SetFieldNull`</ph> with <ph id="ph2">`bNull`</ph> set to <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept> to flag it as Null.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve">
          <source>If a field was previously marked Null and you now want to give it a value, simply set its new value.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve">
          <source>You do not have to remove the Null flag with <ph id="ph1">`SetFieldNull`</ph>.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve">
          <source>To determine whether the field is allowed to be Null, call <ph id="ph1">`IsFieldNullable`</ph>.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve">
          <source>Call this member function only after you have called <bpt id="p1">[</bpt>Edit<ept id="p1">](#crecordset__edit)</ept> or <bpt id="p2">[</bpt>AddNew<ept id="p2">](#crecordset__addnew)</ept>.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> for the first argument of the function will apply the function only to <bpt id="p2">**</bpt>outputColumn<ept id="p2">**</ept> fields, not <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>For instance, the call</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#26</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve">
          <source>will set only <bpt id="p1">**</bpt>outputColumn<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>; <bpt id="p3">**</bpt>param<ept id="p3">**</ept> fields will be unaffected.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve">
          <source>To work on <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields, you must supply the actual address of the individual <bpt id="p2">**</bpt>param<ept id="p2">**</ept> you want to work on, such as:</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve">
          <source>NVC_MFCDatabase#27</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve">
          <source>This means you cannot set all <bpt id="p1">**</bpt>param<ept id="p1">**</ept> fields to <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept>, as you can with <bpt id="p3">**</bpt>outputColumn<ept id="p3">**</ept> fields.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve">
          <source>When setting parameters to Null, a call to <ph id="ph1">`SetFieldNull`</ph> before the recordset is opened results in an assertion.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve">
          <source>In this case, call <bpt id="p1">[</bpt>SetParamNull<ept id="p1">](#crecordset__setparamnull)</ept>.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve">
          <source>is implemented through <bpt id="p1">[</bpt>DoFieldExchange<ept id="p1">](#crecordset__dofieldexchange)</ept>.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve">
          <source>CRecordset::SetLockingMode</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve">
          <source>Sets the locking mode to "optimistic" locking (the default) or "pessimistic" locking.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve">
          <source>Determines how records are locked for updates.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source>Contains one of the following values from the <bpt id="p1">**</bpt>enum LockMode<ept id="p1">**</ept>:</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>optimistic<ept id="p1">**</ept> Optimistic locking locks the record being updated only during the call to <bpt id="p2">**</bpt>Update<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>pessimistic<ept id="p1">**</ept> Pessimistic locking locks the record as soon as <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> is called and keeps it locked until the <bpt id="p3">**</bpt>Update<ept id="p3">**</ept> call completes or you move to a new record.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve">
          <source>Call this member function if you need to specify which of two record-locking strategies the recordset is using for updates.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve">
          <source>By default, the locking mode of a recordset is <bpt id="p1">**</bpt>optimistic<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve">
          <source>You can change that to a more cautious <bpt id="p1">**</bpt>pessimistic<ept id="p1">**</ept> locking strategy.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`SetLockingMode`</ph> after you construct and open the recordset object but before you call <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve">
          <source>CRecordset::SetParamNull</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>Flags a parameter as Null (specifically having no value) or as non-Null.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source>The zero-based index of the parameter.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept> (the default value), the parameter is flagged as Null.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>Otherwise, the parameter is flagged as non-Null.</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">[</bpt>SetFieldNull<ept id="p1">](#crecordset__setfieldnull)</ept>, you can call <ph id="ph1">`SetParamNull`</ph> before you have opened the recordset.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve">
          <source>is typically used with predefined queries (stored procedures).</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve">
          <source>CRecordset::SetRowsetCursorPosition</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve">
          <source>Moves the cursor to a row within the current rowset.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source>The one-based position of a row in the current rowset.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source>This value can range from 1 to the size of the rowset.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source>Value indicating how to lock the row after it has been refreshed.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve">
          <source>For details, see Remarks.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve">
          <source>When implementing bulk row fetching, records are retrieved by rowsets, where the first record in the fetched rowset is the current record.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>In order to make another record within the rowset the current record, call <ph id="ph1">`SetRowsetCursorPosition`</ph>.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>For example, you can combine <ph id="ph1">`SetRowsetCursorPosition`</ph> with the <bpt id="p1">[</bpt>GetFieldValue<ept id="p1">](#crecordset__getfieldvalue)</ept> member function to dynamically retrieve the data from any record of your recordset.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>To use <ph id="ph1">`SetRowsetCursorPosition`</ph>, you must have implemented bulk row fetching by specifying the <ph id="ph2">`CRecordset::useMultiRowFetch`</ph> option of the <ph id="ph3">`dwOptions`</ph> parameter in the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>calls the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`wLockType`</ph> parameter specifies the lock state of the row after <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept> has executed.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>The following table describes the possible values for <ph id="ph1">`wLockTyp`</ph>e.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve">
          <source>wLockType</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source>(the default value)</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>The driver or data source ensures that the row is in the same locked or unlocked state as it was before <ph id="ph1">`SetRowsetCursorPosition`</ph> was called.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>The driver or data source locks the row exclusively.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>Not all data sources support this type of lock.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve">
          <source>The driver or data source unlocks the row.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve">
          <source>Not all data sources support this type of lock.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve">
          <source>For more information about <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>, see the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>CRecordset::SetRowsetSize</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve">
          <source>Specifies the number of records you wish to retrieve during a fetch.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source>dwNewRowsetSize</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>The number of rows to retrieve during a given fetch.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve">
          <source>This virtual member function specifies how many rows you wish to retrieve during a single fetch when using bulk row fetching.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve">
          <source>To implement bulk row fetching, you must set the <ph id="ph1">`CRecordset::useMultiRowFetch`</ph> option in the <ph id="ph2">`dwOptions`</ph> parameter of the <bpt id="p1">[</bpt>Open<ept id="p1">](#crecordset__open)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`SetRowsetSize`</ph> without implementing bulk row fetching will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`SetRowsetSize`</ph> before calling <bpt id="p1">**</bpt>Open<ept id="p1">**</ept> to initially set the rowset size for the recordset.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>The default rowset size when implementing bulk row fetching is 25.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>Use caution when calling <ph id="ph1">`SetRowsetSize`</ph>.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source>If you are manually allocating storage for the data (as specified by the <bpt id="p1">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id="p1">**</ept> option of the dwOptions parameter in <bpt id="p2">**</bpt>Open<ept id="p2">**</ept>), you should check whether you need to reallocate these storage buffers after you call <ph id="ph1">`SetRowsetSize`</ph>, but before you perform any cursor navigation operation.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source>To obtain the current setting for the rowset size, call <bpt id="p1">[</bpt>GetRowsetSize<ept id="p1">](#crecordset__getrowsetsize)</ept>.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source>CRecordset::Update</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>Completes an <ph id="ph1">`AddNew`</ph> or <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> operation by saving the new or edited data on the data source.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>Nonzero if one record was successfully updated; otherwise 0 if no columns have changed.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>If no records were updated, or if more than one record was updated, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source>An exception is also thrown for any other failure on the data source.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve">
          <source>Call this member function after a call to the <bpt id="p1">[</bpt>AddNew<ept id="p1">](#crecordset__addnew)</ept> or <bpt id="p2">[</bpt>Edit<ept id="p2">](#crecordset__edit)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve">
          <source>This call is required to complete the <ph id="ph1">`AddNew`</ph> or <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> operation.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve">
          <source>If you have implemented bulk row fetching, you cannot call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>This will result in a failed assertion.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>Although class <ph id="ph1">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id="p1">**</bpt>SQLSetPos<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see the article <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`AddNew`</ph> and <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept> prepare an edit buffer in which the added or edited data is placed for saving to the data source.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Update<ept id="p1">**</ept> saves the data.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source>Only those fields marked or detected as changed are updated.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source>If the data source supports transactions, you can make the <bpt id="p1">**</bpt>Update<ept id="p1">**</ept> call (and its corresponding <ph id="ph1">`AddNew`</ph> or <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept> call) part of a transaction.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>For more information about transactions, see the article <bpt id="p1">[</bpt>Transaction (ODBC)<ept id="p1">](../../data/odbc/transaction-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>If you call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept> without first calling either <ph id="ph1">`AddNew`</ph> or <bpt id="p2">**</bpt>Edit<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Update<ept id="p3">**</ept> throws a <ph id="ph2">`CDBException`</ph>.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve">
          <source>If you call <ph id="ph1">`AddNew`</ph> or <bpt id="p1">**</bpt>Edit<ept id="p1">**</ept>, you must call <bpt id="p2">**</bpt>Update<ept id="p2">**</ept> before you call a <bpt id="p3">**</bpt>Move<ept id="p3">**</ept> operation or before you close either the recordset or the data source connection.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve">
          <source>Otherwise, your changes are lost without notification.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve">
          <source>For details on handling <bpt id="p1">**</bpt>Update<ept id="p1">**</ept> failures, see the article <bpt id="p2">[</bpt>Recordset: How Recordsets Update Records (ODBC)<ept id="p2">](../../data/odbc/recordset-how-recordsets-update-records-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>See the article <bpt id="p1">[</bpt>Transaction: Performing a Transaction in a Recordset (ODBC)<ept id="p1">](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>CObject Class</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve">
          <source>Hierarchy Chart</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve">
          <source>CDatabase Class</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve">
          <source>CRecordView Class</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>