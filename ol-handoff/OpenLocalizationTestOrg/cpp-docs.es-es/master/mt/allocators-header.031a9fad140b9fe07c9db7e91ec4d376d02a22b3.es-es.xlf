<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d0feee1248f661fa03e680052adbb65be355dbe4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\allocators-header.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4d8f2acceb9f3dcb30a4b132ece6c4e176e1dfbc</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">81d1cf3539d08e629c99319fe9dff5b39b5f00d6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>allocators<ph id="ph2">&amp;gt;</ph> | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>allocators<ph id="ph2">&amp;gt;</ph></source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Defines several templates that help allocate and free memory blocks for node-based containers.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">\&lt;</ph>allocators&gt; header provides six allocator templates that can be used to select memory-management strategies for node-based containers.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For use with these templates, it also provides several different synchronization filters to tailor the memory-management strategy to a variety of different multithreading schemes (including none).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Matching a memory management strategy to the known memory usage patterns, and synchronization requirements, of a particular application can often increase the speed or reduce the overall memory requirements of an application.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The allocator templates are implemented with reusable components that can be customized or replaced to provide additional memory-management strategies.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The node-based containers in the Standard C++ library (std::list, std::set, std::multiset, std::map and std::multimap) store their elements in individual nodes.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All the nodes for a particular container type are the same size, so the flexibility of a general-purpose memory manager is not needed.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because the size of each memory block is known at compile time, the memory manager can be much simpler and faster.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When used with containers that are not node-based (such as the Standard C++ library containers std::vector std::deque, and std::basic_string), the alllocator templates will work correctly, but are not likely to provide any performance improvement over the default allocator.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>An allocator is a template class that describes an object that manages storage allocation and freeing for objects and arrays of objects of a designated type.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Allocator objects are used by several container template classes in the Standard C++ library.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The allocators are all templates of this type:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`template&lt;class`</ph> <ph id="ph2">`Type`</ph> <ph id="ph3">`&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>where the template argument <ph id="ph1">`Type`</ph> is the type managed by the allocator instance.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Standard C++ library provides a default allocator, template class <bpt id="p1">[</bpt>allocator<ept id="p1">](../standard-library/allocator-class.md)</ept>, which is defined in <bpt id="p2">[</bpt><ph id="ph1">\&lt;</ph>memory&gt;<ept id="p2">](../standard-library/memory.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">\&lt;</ph>allocators&gt; header provides the following allocators:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_newdel<ept id="p1">](../standard-library/allocator-newdel-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_unbounded<ept id="p1">](../standard-library/allocator-unbounded-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_fixed_size<ept id="p1">](../standard-library/allocator-fixed-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_variable_size<ept id="p1">](../standard-library/allocator-variable-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_suballoc<ept id="p1">](../standard-library/allocator-suballoc-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_chunklist<ept id="p1">](../standard-library/allocator-chunklist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Use an appropriate instantiation of an allocator as the second type argument when creating a container, such as the following code example.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>_List0 allocates nodes with <ph id="ph1">`allocator_chunklist`</ph> and the default synchronization filter.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Use the macro <bpt id="p1">[</bpt>ALLOCATOR_DECL<ept id="p1">](../standard-library/allocators-functions.md#allocator_decl)</ept> to create allocator templates with synchronization filters other than the default:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>_Lst1 allocates nodes with <ph id="ph1">`allocator_chunklist`</ph> and the <bpt id="p1">[</bpt>sync_per_thread<ept id="p1">](../standard-library/sync-per-thread-class.md)</ept> synchronization filter.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A block allocator is a cache or a filter.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A cache is a template class that takes one argument of type std::size_t.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It defines a block allocator that allocates and deallocates memory blocks of a single size.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It must obtain memory using operator <ph id="ph1">`new`</ph>, but it need not make a separate call to operator <ph id="ph2">`new`</ph> for each block.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It may, for example, suballocate from a larger block or cache deallocated blocks for subsequent reallocation.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>With a compiler that cannot compile rebind the value of the std::size_t argument used when the template was instantiated is not necessarily the value of the argument _Sz passed to a cache's member functions allocate and deallocate.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>allocators&gt; provides the following cache templates:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_freelist<ept id="p1">](../standard-library/cache-freelist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_suballoc<ept id="p1">](../standard-library/cache-suballoc-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_chunklist<ept id="p1">](../standard-library/cache-chunklist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A filter is a block allocator that implements its member functions using another block allocator which is passed to it as a template argument.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The most common form of filter is a synchronization filter, which applies a synchronization policy to control access to the member functions of an instance of another block allocator.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>allocators&gt; provides the following synchronization filters:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_none<ept id="p1">](../standard-library/sync-none-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_per_container<ept id="p1">](../standard-library/sync-per-container-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_per_thread<ept id="p1">](../standard-library/sync-per-thread-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_shared<ept id="p1">](../standard-library/sync-shared-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>allocators&gt; also provides the filter <bpt id="p1">[</bpt>rts_alloc<ept id="p1">](../standard-library/rts-alloc-class.md)</ept>, which holds multiple block allocator instances and determines which instance to use for allocation or deallocation at runtime instead of at compile time.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>It is used with compilers that cannot compile rebind.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A synchronization policy determines how an allocator instance handles simultaneous allocation and deallocation requests from multiple threads.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The simplest policy is to pass all requests directly through to the underlying cache object, leaving synchronization management to the user.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A more complex policy could be to use a mutex to serialize access to the underlying cache object.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If a compiler supports compiling both single-threaded and multi-threaded applications, the default synchronization filter for single-threaded applications is <ph id="ph1">`sync_none`</ph>; for all other cases it is <ph id="ph2">`sync_shared`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The cache template <ph id="ph1">`cache_freelist`</ph> takes a max class argument which determines the maximum number of elements to be stored in the free list.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>allocators&gt; provides the following max classes:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_none<ept id="p1">](../standard-library/max-none-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_unbounded<ept id="p1">](../standard-library/max-unbounded-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_fixed_size<ept id="p1">](../standard-library/max-fixed-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_variable_size<ept id="p1">](../standard-library/max-variable-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Macros</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ALLOCATOR_DECL<ept id="p1">](../standard-library/allocators-functions.md#allocator_decl)</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Yields an allocator template class.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CACHE_CHUNKLIST<ept id="p1">](../standard-library/allocators-functions.md#cache_chunklist)</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Yields <ph id="ph1">`stdext::allocators::cache_chunklist&lt;sizeof(Type)&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CACHE_FREELIST<ept id="p1">](../standard-library/allocators-functions.md#cache_freelist)</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Yields <ph id="ph1">`stdext::allocators::cache_freelist&lt;sizeof(Type), max&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CACHE_SUBALLOC<ept id="p1">](../standard-library/allocators-functions.md#cache_suballoc)</ept></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Yields <ph id="ph1">`stdext::allocators::cache_suballoc&lt;sizeof(Type)&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SYNC_DEFAULT<ept id="p1">](../standard-library/allocators-functions.md#sync_default)</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Yields a synchronization filter.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Operators</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>operator!= (<ph id="ph1">\&lt;</ph>allocators&gt;)<ept id="p1">](../standard-library/allocators-operators.md#operator_neq)</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Tests for inequality between allocator objects of a specified class.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>operator== (<ph id="ph1">\&lt;</ph>allocators&gt;)<ept id="p1">](../standard-library/allocators-operators.md#operator_eq_eq)</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Tests for equality between allocator objects of a specified class.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Classes</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_base<ept id="p1">](../standard-library/allocator-base-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Defines the base class and common functions needed to create a user-defined allocator from a synchronization filter.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_chunklist<ept id="p1">](../standard-library/allocator-chunklist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Describes an object that manages storage allocation and freeing for objects using a cache of type <bpt id="p1">[</bpt>cache_chunklist<ept id="p1">](../standard-library/cache-chunklist-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_fixed_size<ept id="p1">](../standard-library/allocator-fixed-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Describes an object that manages storage allocation and freeing for objects of type <ph id="ph1">`Type`</ph> using a cache of type <bpt id="p1">[</bpt>cache_freelist<ept id="p1">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id="p2">[</bpt>max_fixed_size<ept id="p2">](../standard-library/max-fixed-size-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_newdel<ept id="p1">](../standard-library/allocator-newdel-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Implements an allocator that uses <ph id="ph1">`operator delete`</ph> to deallocate a memory block and <ph id="ph2">`operator new`</ph> to allocate a memory block.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_suballoc<ept id="p1">](../standard-library/allocator-suballoc-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Describes an object that manages storage allocation and freeing for objects of type <ph id="ph1">`Type`</ph> using a cache of type <bpt id="p1">[</bpt>cache_suballoc<ept id="p1">](../standard-library/cache-suballoc-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_unbounded<ept id="p1">](../standard-library/allocator-unbounded-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Describes an object that manages storage allocation and freeing for objects of type <ph id="ph1">`Type`</ph> using a cache of type <bpt id="p1">[</bpt>cache_freelist<ept id="p1">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id="p2">[</bpt>max_unbounded<ept id="p2">](../standard-library/max-unbounded-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>allocator_variable_size<ept id="p1">](../standard-library/allocator-variable-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Describes an object that manages storage allocation and freeing for objects of type <ph id="ph1">`Type`</ph> using a cache of type <bpt id="p1">[</bpt>cache_freelist<ept id="p1">](../standard-library/cache-freelist-class.md)</ept> with a length managed by <bpt id="p2">[</bpt>max_variable_size<ept id="p2">](../standard-library/max-variable-size-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_chunklist<ept id="p1">](../standard-library/cache-chunklist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Defines a block allocator that allocates and deallocates memory blocks of a single size.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_freelist<ept id="p1">](../standard-library/cache-freelist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Defines a block allocator that allocates and deallocates memory blocks of a single size.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>cache_suballoc<ept id="p1">](../standard-library/cache-suballoc-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Defines a block allocator that allocates and deallocates memory blocks of a single size.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>freelist<ept id="p1">](../standard-library/freelist-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Manages a list of memory blocks.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_fixed_size<ept id="p1">](../standard-library/max-fixed-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Describes a max class object that limits a <bpt id="p1">[</bpt>freelist<ept id="p1">](../standard-library/freelist-class.md)</ept> object to a fixed maximum length.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_none<ept id="p1">](../standard-library/max-none-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Describes a max class object that limits a <bpt id="p1">[</bpt>freelist<ept id="p1">](../standard-library/freelist-class.md)</ept> object to a maximum length of zero.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_unbounded<ept id="p1">](../standard-library/max-unbounded-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Describes a max class object that does not limit the maximum length of a <bpt id="p1">[</bpt>freelist<ept id="p1">](../standard-library/freelist-class.md)</ept> object.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>max_variable_size<ept id="p1">](../standard-library/max-variable-size-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Describes a max class object that limits a <bpt id="p1">[</bpt>freelist<ept id="p1">](../standard-library/freelist-class.md)</ept> object to a maximum length that is roughly proportional to the number of allocated memory blocks.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>rts_alloc<ept id="p1">](../standard-library/rts-alloc-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The rts_alloc template class describes a <bpt id="p1">[</bpt>filter<ept id="p1">](../standard-library/allocators-header.md)</ept> that holds an array of cache instances and determines which instance to use for allocation and deallocation at runtime instead of at compile time.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_none<ept id="p1">](../standard-library/sync-none-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Describes a synchronization filter that provides no synchronization.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_per_container<ept id="p1">](../standard-library/sync-per-container-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Describes a synchronization filter that provides a separate cache object for each allocator object.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_per_thread<ept id="p1">](../standard-library/sync-per-thread-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Describes a synchronization filter that provides a separate cache object for each thread.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>sync_shared<ept id="p1">](../standard-library/sync-shared-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Describes a synchronization filter that uses a mutex to control access to a cache object that is shared by all allocators.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> <ph id="ph1">\&lt;</ph>allocators&gt;</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> stdext</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Header Files Reference<ept id="p1">](../standard-library/cpp-standard-library-header-files.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>