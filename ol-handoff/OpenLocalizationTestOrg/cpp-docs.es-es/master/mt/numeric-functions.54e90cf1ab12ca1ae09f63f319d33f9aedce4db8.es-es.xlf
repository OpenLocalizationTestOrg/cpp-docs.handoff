<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88c311b28caa80d4c4292888be501feae797ce27</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\numeric-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">551ebeea3ac6a4219d339bdbe27d7d0190f03cec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">30ff7b2685187ff8a4ca7091ea074c3dedee772d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>numeric<ph id="ph2">&amp;gt;</ph> functions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph>numeric<ph id="ph2">&amp;gt;</ph> functions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>accumulate<ept id="p1">](#accumulate)</ept></source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>adjacent_difference<ept id="p1">](#adjacent_difference)</ept></source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>inner_product<ept id="p1">](#inner_product)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>iota<ept id="p1">](#iota)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>partial_sum<ept id="p1">](#partial_sum)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="accumulate"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  accumulate</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Computes the sum of all the elements in a specified range including some initial value by computing successive partial sums or computes the result of successive partial results similarly obtained from using a specified binary operation other than the sum.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the range to be summed or combined according to a specified binary operation.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the last element in the range to be summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>An initial value to which each element is in turn added or combined with according to a specified binary operation.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The binary operation that is to be applied to the each element in the specified range and the result of its previous applications.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The sum of <ph id="ph1">` val`</ph> and all the elements in the specified range for the first template function, or, for the second template function, the result of applying the binary operation specified, instead of the sum operation, to ( <bpt id="p1">*</bpt>PartialResult, <ph id="ph2">\*</ph>Iter<ept id="p1">*</ept>), where <bpt id="p2">*</bpt>PartialResult<ept id="p2">*</ept> is the result of previous applications of the operation and <ph id="ph3">`Iter`</ph> is an iterator pointing to an element in the range.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The initial value insures that there will be a well-defined result when the range is empty, in which case <ph id="ph1">` val`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The binary operation does not need to be associative or commutative.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The result is initialized to the initial value <ph id="ph1">` val`</ph> and then <bpt id="p1">*</bpt>result<ept id="p1">*</ept><ph id="ph2"> = </ph><ph id="ph3">`binary_op`</ph> ( <bpt id="p2">*</bpt>result<ept id="p2">*</ept>, <bpt id="p3">**</bpt><ph id="ph4">\*</ph><ept id="p3">**</ept><ph id="ph5">`Iter`</ph>) is calculated iteratively through the range, where <ph id="ph6">`Iter`</ph> is an iterator pointing to successive element in the range.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The range must be valid and the complexity is linear with the size of the range.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The return type of the binary operator must be convertible to <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> to ensure closure during the iteration.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="adjacent_difference"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  adjacent_difference</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Computes the successive differences between each element and its predecessor in an input range and outputs the results to a destination range or computes the result of a generalized procedure where the difference operation is replaced by another, specified binary operation.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the last element in the input range whose elements are to be differenced with their respective predecessors or where the pair of values is to be operated on by another specified binary operation.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the first element a destination range where the series of differences or the results of the specified operation is to be stored.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The binary operation that is to be applied in the generalized operation replacing the operation of subtraction in the differencing procedure.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the end of the destination range: <ph id="ph1">`result`</ph> + ( <ph id="ph2">` last`</ph><ph id="ph3"> - </ph><ph id="ph4">` first`</ph>).</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The output iterator _ <bpt id="p1">*</bpt>result<ept id="p1">*</ept> is allowed to be the same iterator as the input iterator <bpt id="p2">*</bpt> first,<ept id="p2">*</ept> so that <ph id="ph1">`adjacent_difference`</ph>s may be computed in place.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For a sequence of values <bpt id="p1">*</bpt>a<ept id="p1">*</ept>1, <bpt id="p2">*</bpt>a<ept id="p2">*</ept>2, <bpt id="p3">*</bpt>a<ept id="p3">*</ept>3, in an input range, the first template function stores successive <bpt id="p4">**</bpt>partial_difference<ept id="p4">**</ept>s <bpt id="p5">*</bpt>a<ept id="p5">*</ept>1, <bpt id="p6">*</bpt>a<ept id="p6">*</ept>2 - <bpt id="p7">*</bpt>a<ept id="p7">*</ept>1, a3 – <bpt id="p8">*</bpt>a<ept id="p8">*</ept>2, in the destination range.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For a sequence of values <bpt id="p1">*</bpt>a<ept id="p1">*</ept>1, <bpt id="p2">*</bpt>a<ept id="p2">*</ept>2, <bpt id="p3">*</bpt>a<ept id="p3">*</ept>3, in an input range, the second template function stores successive <bpt id="p4">**</bpt>partial_difference<ept id="p4">**</ept>s <bpt id="p5">*</bpt>a<ept id="p5">*</ept>1, <bpt id="p6">*</bpt>a<ept id="p6">*</ept>2 <ph id="ph1">`binary_op`</ph> <bpt id="p7">*</bpt>a<ept id="p7">*</ept>1, <bpt id="p8">*</bpt>a<ept id="p8">*</ept>3 <ph id="ph2">`binary_op`</ph> <bpt id="p9">*</bpt>a<ept id="p9">*</ept>2, in the destination range.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The binary operation <ph id="ph1">`binary_op`</ph> is not required to be either associative or commutative, because the order of operations applies is completely specified.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="inner_product"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  inner_product</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Computes the sum of the element-wise product of two ranges and adds it to a specified initial value or computes the result of a generalized procedure where the sum and product binary operations are replaced by other specified binary operations.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the first range whose inner product or generalized inner product with the second range is to be computed.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the last element in the first range whose inner product or generalized inner product with the second range is to be computed.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the second range whose inner product or generalized inner product with the first range is to be computed.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>An initial value to which the inner product or generalized inner product between the ranges is to be added.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>binary_op1<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The binary operation that replaces the inner product operation of sum applied to the element-wise products in the generalization of the inner product.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>binary_op2<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The binary operation that replaces the inner product element-wise operation of multiply in the generalization of the inner product.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The first member function returns the sum of the element-wise products and adds to it the specified initial value.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>So for ranges of values <bpt id="p1">*</bpt>a<ept id="p1">*</ept>i and <bpt id="p2">*</bpt>b<ept id="p2">*</ept>i, it returns:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">` val`</ph> + ( <bpt id="p1">*</bpt>a<ept id="p1">*</ept>1 <ph id="ph2">\*</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept>1 ) + ( <bpt id="p3">*</bpt>a<ept id="p3">*</ept>2 <ph id="ph3">\*</ph> <bpt id="p4">*</bpt>b<ept id="p4">*</ept>2 ) +</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>by iteratively replacing <ph id="ph1">` val`</ph> with <ph id="ph2">` val`</ph> + (<ph id="ph3">\*</ph> <bpt id="p1">*</bpt>a<ept id="p1">*</ept>i <ph id="ph4">\*</ph> <ph id="ph5">\*</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept>i ).</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The second member function returns:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><ph id="ph1">` val`</ph> _ <bpt id="p1">*</bpt>Binary_op1<ept id="p1">*</ept> ( <bpt id="p2">*</bpt>a<ept id="p2">*</ept>1 <ph id="ph2">\_</ph> <bpt id="p3">*</bpt>Binary_op2<ept id="p3">*</ept> <bpt id="p4">*</bpt>b<ept id="p4">*</ept>1 ) <ph id="ph3">\_</ph> <bpt id="p5">*</bpt>Binary_op1<ept id="p5">*</ept> ( <bpt id="p6">*</bpt>a<ept id="p6">*</ept>2 <ph id="ph4">\_</ph> <bpt id="p7">*</bpt>Binary_op2<ept id="p7">*</ept> <bpt id="p8">*</bpt>b<ept id="p8">*</ept>2 ) <ph id="ph5">\_</ph> <bpt id="p9">*</bpt>Binary_op1<ept id="p9">*</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>by iteratively replacing <ph id="ph1">` val`</ph> with <ph id="ph2">` val`</ph> _ <bpt id="p1">*</bpt>Binary_op1<ept id="p1">*</ept> (<ph id="ph3">\*</ph> <bpt id="p2">*</bpt>a<ept id="p2">*</ept>i <ph id="ph4">\_</ph> <bpt id="p3">*</bpt>Binary_op2<ept id="p3">*</ept> <ph id="ph5">\*</ph> <bpt id="p4">*</bpt>b<ept id="p4">*</ept>i ).</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The initial value ensures that there will be a well-defined result when the range is empty, in which case <ph id="ph1">` val`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The binary operations do not need to be associative or commutative.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The range must be valid and the complexity is linear with the size of the range.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The return type of the binary operator must be convertible to <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> to ensure closure during the iteration.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="iota"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  iota</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Stores a starting value, beginning with the first element and filling with successive increments of that value ( <ph id="ph1">` value++`</ph>) in each of the elements in the interval <ph id="ph2">`[ first,  last)`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>An input iterator that addresses the first element in the range to be filled.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>An input iterator that addresses the last element in the range to be filled.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The starting value to store in the first element and to successively increment for subsequent elements.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example demonstrates some uses for the <ph id="ph1">`iota`</ph> function by filling a <bpt id="p1">[</bpt>list<ept id="p1">](../standard-library/list.md)</ept> of integers and then filling a <bpt id="p2">[</bpt>vector<ept id="p2">](../standard-library/vector.md)</ept> with the <ph id="ph2">`list`</ph> so that the <bpt id="p3">[</bpt>random_shuffle<ept id="p3">](../standard-library/algorithm-functions.md#random_shuffle)</ept> function can be used.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="partial_sum"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  partial_sum</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Computes a series of sums in an input range from the first element through the <bpt id="p1">*</bpt>i<ept id="p1">*</ept>th element and stores the result of each such sum in the <bpt id="p2">*</bpt>i<ept id="p2">*</ept>th element of a destination range or computes the result of a generalized procedure where the sum operation is replaced by another specified binary operation.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the range to be partially summed or combined according to a specified binary operation.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the last element in the range to be partially summed or combined according to a specified binary operation that is one position beyond the final element actually included in the iterated accumulation.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the first element a destination range where the series of partial sums or the results of the specified operation is to be stored.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The binary operation that is to be applied in the generalized operation replacing the operation of sum in the partial sum procedure.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>An output iterator addressing the end of the destination range: <ph id="ph1">`result`</ph> + ( <ph id="ph2">` last`</ph><ph id="ph3"> - </ph><ph id="ph4">` first`</ph>),</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The output iterator <ph id="ph1">`result`</ph> is allowed to be the same iterator as the input iterator <ph id="ph2">` first`</ph>, so that partial sums may be computed in place.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For a sequence of values <bpt id="p1">*</bpt>a<ept id="p1">*</ept>1, <bpt id="p2">*</bpt>a<ept id="p2">*</ept>2, <bpt id="p3">*</bpt>a<ept id="p3">*</ept>3,  in an input range, the first template function stores successive partial sums in the destination range, where the <bpt id="p4">*</bpt>i<ept id="p4">*</ept>th element is given by (  ( ( <bpt id="p5">*</bpt>a<ept id="p5">*</ept>1 + <bpt id="p6">*</bpt>a<ept id="p6">*</ept>2) + <bpt id="p7">*</bpt>a<ept id="p7">*</ept>3) <bpt id="p8">*</bpt>a<ept id="p8">*</ept>i).</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For a sequence of values <bpt id="p1">*</bpt>a<ept id="p1">*</ept>1, <bpt id="p2">*</bpt>a<ept id="p2">*</ept>2, <bpt id="p3">*</bpt>a<ept id="p3">*</ept>3,  in an input range, the second template function stores successive partial sums in the destination range, where the ith element is given by (  ( ( <bpt id="p4">*</bpt>a<ept id="p4">*</ept>1<ph id="ph1">`binary_op`</ph> <bpt id="p5">*</bpt>a<ept id="p5">*</ept>2 ) <ph id="ph2">`binary_op`</ph> <bpt id="p6">*</bpt>a<ept id="p6">*</ept>3 ) <bpt id="p7">*</bpt>a<ept id="p7">*</ept>i).</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The binary operation <ph id="ph1">`binary_op`</ph> is not required to be either associative or commutative, because the order of operations applies is completely specified.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>numeric&gt;<ept id="p1">](../standard-library/numeric.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>