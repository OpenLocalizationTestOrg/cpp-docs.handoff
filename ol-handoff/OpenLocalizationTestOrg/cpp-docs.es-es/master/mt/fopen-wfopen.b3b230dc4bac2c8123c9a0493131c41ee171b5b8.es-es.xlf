<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">842c4bebea2956e36ea8b0f125913dcca3474c00</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\c-runtime-library\reference\fopen-wfopen.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">868325def10a8f9226984ceebff2f29ae77b75a1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7f4be375f0dcf6b737d1c990160a95ede03c3e34</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>fopen, _wfopen | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>fopen, _wfopen</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Opens a file.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>More-secure versions of these functions that perform additional parameter validation and return error codes are available; see <bpt id="p1">[</bpt>fopen_s, _wfopen_s<ept id="p1">](../../c-runtime-library/reference/fopen-s-wfopen-s.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>File name.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Kind of access that's enabled.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Each of these functions returns a pointer to the open file.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A null pointer value indicates an error.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`filename`</ph> or <ph id="ph2">`mode`</ph> is <ph id="ph3">`NULL`</ph> or an empty string, these functions trigger the invalid parameter handler, which is described in <bpt id="p1">[</bpt>Parameter Validation<ept id="p1">](../../c-runtime-library/parameter-validation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If execution is allowed to continue, these functions return <ph id="ph1">`NULL`</ph> and set <ph id="ph2">`errno`</ph> to <ph id="ph3">`EINVAL`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id="p1">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`fopen`</ph> function opens the file that is specified by <ph id="ph2">`filename`</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>By default, a narrow <ph id="ph1">`filename`</ph> string is interpreted using the ANSI codepage (CP_ACP).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In Windows Desktop applications this can be changed to the OEM codepage (CP_OEMCP) by using the <bpt id="p1">[</bpt>SetFileApisToOEM<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/aa365534\(v=vs.85\).aspx)</ept> function.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>AreFileApisANSI<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/aa363781\(v=vs.85\).aspx)</ept> function to determine whether <ph id="ph1">`filename`</ph> is interpreted using the ANSI or the system default OEM codepage.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_wfopen`</ph> is a wide-character version of <ph id="ph2">`fopen`</ph>; the arguments to <ph id="ph3">`_wfopen`</ph> are wide-character strings.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Otherwise, <ph id="ph1">`_wfopen`</ph> and <ph id="ph2">`fopen`</ph> behave identically.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Just using <ph id="ph1">`_wfopen`</ph> does not affect the coded character set that is used in the file stream.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`fopen`</ph> accepts paths that are valid on the file system at the point of execution; <ph id="ph2">`fopen`</ph> accepts UNC paths and paths that involve mapped network drives as long as the system that executes the code has access to the share or mapped drive at the time of execution.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When you construct paths for <ph id="ph1">`fopen`</ph>, make sure that drives, paths, or network shares will be available in the execution environment.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can use either forward slashes (/) or backslashes (<ph id="ph1">\\</ph>) as the directory separators in a path.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Always check the return value to see whether the pointer is NULL before you perform any additional operations on the file.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If an error occurs, the global variable <ph id="ph1">`errno`</ph> is set and may be used to obtain specific error information.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id="p1">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`fopen`</ph> supports Unicode file streams.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To open a Unicode file, pass a <ph id="ph1">`ccs`</ph> flag that specifies the desired encoding to <ph id="ph2">`fopen`</ph>, as follows.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Allowed values of <ph id="ph1">`encoding`</ph> are <ph id="ph2">`UNICODE`</ph>, <ph id="ph3">`UTF-8`</ph>, and <ph id="ph4">`UTF-16LE`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>When a file is opened in Unicode mode, input functions translate the data that's read from the file into UTF-16 data stored as type <ph id="ph1">`wchar_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Functions that write to a file opened in Unicode mode expect buffers that contain UTF-16 data stored as type <ph id="ph1">`wchar_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If the file is encoded as UTF-8, then UTF-16 data is translated into UTF-8 when it is written, and the file's UTF-8-encoded content is translated into UTF-16 when it is read.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>An attempt to read or write an odd number of bytes in Unicode mode causes a <bpt id="p1">[</bpt>parameter validation<ept id="p1">](../../c-runtime-library/parameter-validation.md)</ept> error.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To read or write data that's stored in your program as UTF-8, use a text or binary file mode instead of a Unicode mode.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You are responsible for any required encoding translation.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If the file already exists and is opened for reading or appending, the Byte Order Mark (BOM), if it present in the file, determines the encoding.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The BOM encoding takes precedence over the encoding that is specified by the <ph id="ph1">`ccs`</ph> flag.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ccs`</ph> encoding is only used when no BOM is present or the file is a new file.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>BOM detection only applies to files that are opened in Unicode mode (that is, by passing the <ph id="ph1">`ccs`</ph> flag).</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following table summarizes the modes that are used for various <ph id="ph1">`ccs`</ph> flags given to <ph id="ph2">`fopen`</ph> and Byte Order Marks in the file.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Encodings Used Based on ccs Flag and BOM</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ccs`</ph> flag</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>No BOM (or new file)</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>BOM: UTF-8</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>BOM: UTF-16</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Files opened for writing in Unicode mode have a BOM written to them automatically.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`mode`</ph> is "<ph id="ph2">`a, ccs=&lt;encoding&gt;`</ph>", <ph id="ph3">`fopen`</ph> first tries to open the file by using both read and write access.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If this succeeds, the function reads the BOM to determine the encoding for the file; if this fails, the function uses the default encoding for the file.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In either case, <ph id="ph1">`fopen`</ph> will then re-open the file by using write-only access.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>(This applies to <ph id="ph1">`a`</ph> mode only, not to <ph id="ph2">`a+`</ph> mode.)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Generic-Text Routine Mappings</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>TCHAR.H routine</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>_UNICODE &amp; _MBCS not defined</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>_MBCS defined</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>_UNICODE defined</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The character string <ph id="ph1">`mode`</ph> specifies the kind of access that is requested for the file, as follows.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Opens for reading.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the file does not exist or cannot be found, the <ph id="ph1">`fopen`</ph> call fails.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Opens an empty file for writing.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If the given file exists, its contents are destroyed.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Opens for writing at the end of the file (appending) without removing the end-of-file (EOF) marker before new data is written to the file.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Creates the file if it does not exist.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Opens for both reading and writing.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The file must exist.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Opens an empty file for both reading and writing.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If the file exists, its contents are destroyed.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Opens for reading and appending.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The appending operation includes the removal of the EOF marker before new data is written to the file.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The EOF marker is not restored after writing is completed.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Creates the file if it does not exist.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When a file is opened by using the <ph id="ph1">`"a"`</ph> access type or the <ph id="ph2">`"a+"`</ph> access type, all write operations occur at the end of the file.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The file pointer can be repositioned by using <ph id="ph1">`fseek`</ph> or <ph id="ph2">`rewind`</ph>, but is always moved back to the end of the file before any write operation is performed.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Therefore, existing data cannot be overwritten.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`"a"`</ph> mode does not remove the EOF marker before it appends to the file.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>After appending has occurred, the MS-DOS TYPE command only shows data up to the original EOF marker and not any data appended to the file.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Before it appends to the file, the <ph id="ph1">`"a+"`</ph> mode does remove the EOF marker.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>After appending, the MS-DOS TYPE command shows all data in the file.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`"a+"`</ph> mode is required for appending to a stream file that is terminated with the CTRL+Z EOF marker.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`"r+"`</ph>, <ph id="ph2">`"w+"`</ph>, or <ph id="ph3">`"a+"`</ph> access type is specified, both reading and writing are enabled (the file is said to be open for "update").</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, when you switch from reading to writing, the input operation must encounter an EOF marker.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If there is no EOF, you must use an intervening call to a file positioning function.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The file positioning functions are <ph id="ph1">`fsetpos`</ph>, <ph id="ph2">`fseek`</ph>, and <ph id="ph3">`rewind`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you switch from writing to reading, you must use an intervening call to either <ph id="ph1">`fflush`</ph> or to a file positioning function.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In addition to the earlier values, the following characters can be appended to <ph id="ph1">`mode`</ph> to specify the translation mode for newline characters.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Open in text (translated) mode.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In this mode, CTRL+Z is interpreted as an EOF character on input.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In files that are opened for reading/writing by using <ph id="ph1">`"a+"`</ph>, <ph id="ph2">`fopen`</ph> checks for a CTRL+Z at the end of the file and removes it, if it is possible.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This is done because using <ph id="ph1">`fseek`</ph> and <ph id="ph2">`ftell`</ph> to move within a file that ends with CTRL+Z may cause <ph id="ph3">`fseek`</ph> to behave incorrectly near the end of the file.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In text mode, carriage return–linefeed combinations are translated into single linefeeds on input, and linefeed characters are translated to carriage return–linefeed combinations on output.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When a Unicode stream-I/O function operates in text mode (the default), the source or destination stream is assumed to be a sequence of multibyte characters.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Therefore, the Unicode stream-input functions convert multibyte characters to wide characters (as if by a call to the <ph id="ph1">`mbtowc`</ph> function).</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For the same reason, the Unicode stream-output functions convert wide characters to multibyte characters (as if by a call to the <ph id="ph1">`wctomb`</ph> function).</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Open in binary (untranslated) mode; translations involving carriage-return and linefeed characters are suppressed.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`t`</ph> or <ph id="ph2">`b`</ph> is not given in <ph id="ph3">`mode`</ph>, the default translation mode is defined by the global variable <bpt id="p1">[</bpt>_fmode<ept id="p1">](../../c-runtime-library/fmode.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`t`</ph> or <ph id="ph2">`b`</ph> is prefixed to the argument, the function fails and returns <ph id="ph3">`NULL`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information about how to use text and binary modes in Unicode and multibyte stream-I/O, see <bpt id="p1">[</bpt>Text and Binary Mode File I/O<ept id="p1">](../../c-runtime-library/text-and-binary-mode-file-i-o.md)</ept> and <bpt id="p2">[</bpt>Unicode Stream I/O in Text and Binary Modes<ept id="p2">](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Enable the commit flag for the associated <ph id="ph1">`filename`</ph> so that the contents of the file buffer are written directly to disk if either <ph id="ph2">`fflush`</ph> or <ph id="ph3">`_flushall`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Reset the commit flag for the associated <ph id="ph1">`filename`</ph> to "no-commit."</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is the default.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It also overrides the global commit flag if you link your program with COMMODE.OBJ.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The global commit flag default is "no-commit" unless you explicitly link your program with COMMODE.OBJ (see <bpt id="p1">[</bpt>Link Options<ept id="p1">](../../c-runtime-library/link-options.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Specifies that the file is not inherited by child processes.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Specifies that caching is optimized for, but not restricted to, sequential access from disk.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Specifies that caching is optimized for, but not restricted to, random access from disk.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Specifies a file as temporary.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If possible, it is not flushed to disk.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Specifies a file as temporary.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>It is deleted when the last file pointer is closed.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Specifies the coded character set to use (<ph id="ph1">`UTF-8`</ph>, <ph id="ph2">`UTF-16LE`</ph>, or <ph id="ph3">`UNICODE`</ph>) for this file.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Leave unspecified if you want ANSI encoding.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Valid characters for the <ph id="ph1">`mode`</ph> string that is used in <ph id="ph2">`fopen`</ph> and <ph id="ph3">`_fdopen`</ph> correspond to <ph id="ph4">`oflag`</ph> arguments that are used in <bpt id="p1">[</bpt>_open<ept id="p1">](../../c-runtime-library/reference/open-wopen.md)</ept> and <bpt id="p2">[</bpt>_sopen<ept id="p2">](../../c-runtime-library/reference/sopen-wsopen.md)</ept>, as follows.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Characters in mode string</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Equivalent <ph id="ph1">`oflag`</ph> value for <ph id="ph2">`_open`</ph><ph id="ph3">/</ph><ph id="ph4">`_sopen`</ph></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_O_WRONLY &amp;#124; _O_APPEND`</ph> (usually <ph id="ph2">`_O_WRONLY &amp;#124; _O_CREAT &amp;#124; _O_APPEND`</ph>)</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_O_RDWR &amp;#124; _O_APPEND`</ph> (usually <ph id="ph2">`_O_RDWR &amp;#124; _O_APPEND &amp;#124; _O_CREAT`</ph> )</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_O_WRONLY`</ph> (usually <ph id="ph2">`_O_WRONLY &amp;#124; _O_CREAT &amp;#124; _O_TRUNC`</ph>)</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_O_RDWR`</ph> (usually <ph id="ph2">`_O_RDWR &amp;#124; _O_CREAT &amp;#124; _O_TRUNC`</ph>)</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>None</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>None</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If you are using <ph id="ph1">`rb`</ph> mode, do not have to port code, and expect to read most of a large file or are not concerned about network performance, you might also consider whether to use memory mapped Win32 files as an option.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Function</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Required header</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>stdio.h&gt;</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph>stdio.h&gt; or <ph id="ph2">\&lt;</ph>wchar.h&gt;</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`_wfopen`</ph> is a Microsoft extension.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For more information about compatibility, see <bpt id="p1">[</bpt>Compatibility<ept id="p1">](../../c-runtime-library/compatibility.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`c`</ph>, <ph id="ph2">`n`</ph>, <ph id="ph3">`t`</ph>, <ph id="ph4">`S`</ph>, <ph id="ph5">`R`</ph>, <ph id="ph6">`T`</ph>, and <ph id="ph7">`D`</ph> <ph id="ph8">`mode`</ph> options are Microsoft extensions for <ph id="ph9">`fopen`</ph> and <ph id="ph10">`_fdopen`</ph> and should not be used where ANSI portability is desired.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following program opens two files.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>It uses <ph id="ph1">`fclose`</ph> to close the first file and <ph id="ph2">`_fcloseall`</ph> to close all remaining files.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The following program creates a file (or overwrites one if it exists), in text mode that has Unicode encoding.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>It then writes two strings into the file and closes the file.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The output is a file named _wfopen_test.xml, which contains the data from the output section.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>.NET Framework Equivalent</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System::IO::File::Open<ept id="p1">](https://msdn.microsoft.com/en-us/library/system.io.file.open.aspx)</ept></source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Stream I/O<ept id="p1">](../../c-runtime-library/stream-i-o.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Interpretation of Multibyte-Character Sequences<ept id="p1">](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>fclose, _fcloseall<ept id="p1">](../../c-runtime-library/reference/fclose-fcloseall.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>_fdopen, _wfdopen<ept id="p1">](../../c-runtime-library/reference/fdopen-wfdopen.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>ferror<ept id="p1">](../../c-runtime-library/reference/ferror.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>_fileno<ept id="p1">](../../c-runtime-library/reference/fileno.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>freopen, _wfreopen<ept id="p1">](../../c-runtime-library/reference/freopen-wfreopen.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>_open, _wopen<ept id="p1">](../../c-runtime-library/reference/open-wopen.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>_setmode<ept id="p1">](../../c-runtime-library/reference/setmode.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>_sopen, _wsopen<ept id="p1">](../../c-runtime-library/reference/sopen-wsopen.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>