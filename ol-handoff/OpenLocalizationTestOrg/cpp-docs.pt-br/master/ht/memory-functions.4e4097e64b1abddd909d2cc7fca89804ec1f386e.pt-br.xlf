<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">60df3a7caba5de741bc636e8b9fd2f4e3ed258ec</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\memory-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b56a67ac370102ae5085828ddd38c0279bee8e25</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4e7e6a1061efaf5bcea1848eb9220e6cea1c2fe3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>memory<ph id="ph1">&amp;gt;</ph> functions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>memory<ph id="ph1">&amp;gt;</ph> functions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>addressof</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>align</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>allocate_shared</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>const_pointer_cast</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>declare_no_pointers</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>declare_reachable</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>default_delete</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>dynamic_pointer_cast</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>get_deleter Function</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>get_pointer_safety</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>get_temporary_buffer</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>make_shared</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>make_unique</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>owner_less</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>return_temporary_buffer</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>static_pointer_cast</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>swap (C++ Standard Library)</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>undeclare_no_pointers</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>undeclare_reachable</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>uninitialized_copy</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>uninitialized_copy_n</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>uninitialized_fill</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>uninitialized_fill_n</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>addressof</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Gets the true address of an object.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The object or function for which to obtain the true address.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The actual address of the object or function referenced by <ph id="ph1">`Val`</ph>, even if an overloaded <ph id="ph2">`operator&amp;()`</ph> exists.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>align</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Fits storage of the given size—aligned by the given alignment specification—into the first possible address of the given storage.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The alignment bound to attempt.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The size in bytes for the aligned storage.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The starting address of the available contiguous storage pool to use.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This parameter is also an output parameter, and will contain the new starting address if the alignment is successful.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`align()`</ph> is unsuccessful, this parameter is not modified.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The total space available to <ph id="ph1">`align()`</ph> to use in creating the aligned storage.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This parameter is also an output parameter, and contains the adjusted space left in the storage buffer after the aligned storage and any associated overhead is subtracted.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`align()`</ph> is unsuccessful, this parameter is not modified.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A null pointer if the requested aligned buffer would not fit into the available space; otherwise, the new value of <ph id="ph1">`Ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The modified <ph id="ph1">`Ptr`</ph> and <ph id="ph2">`Space`</ph> parameters enable you to call <ph id="ph3">`align()`</ph> repeatedly on the same buffer, possibly with different values for <ph id="ph4">`Alignment`</ph> and <ph id="ph5">`Size`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following code snippet shows one use of <ph id="ph1">`align()`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>allocate_shared</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Creates a <ph id="ph1">`shared_ptr`</ph> to objects that are allocated and constructed for a given type by using a specified allocator.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">`shared_ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The allocator used to create objects.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The zero or more arguments that become the objects.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The function creates the object <ph id="ph1">`shared_ptr``&lt;Type&gt;`</ph>, a pointer to <ph id="ph2">`Type(``Args``...)`</ph> as allocated and constructed by <ph id="ph3">`Alloc`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>const_pointer_cast</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Const cast to shared_ptr.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The type controlled by the returned shared pointer.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The type controlled by the argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The template function returns an empty shared_ptr object if <ph id="ph1">`const_cast&lt;Ty*&gt;(sp.get())`</ph> returns a null pointer; otherwise it returns a <bpt id="p1">[</bpt>shared_ptr Class<ept id="p1">](../standard-library/shared-ptr-class.md)</ept><ph id="ph2">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id="ph3">`sp`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`const_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>declare_no_pointers</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size contains no traceable pointers.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Address of first character that no longer contains traceable pointers.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Size of block that starts at <ph id="ph1">` ptr`</ph> that contains no traceable pointers.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The function informs any <ph id="ph1">`garbage collector`</ph> that the range of addresses <ph id="ph2">`[`` ptr``,`</ph> <ph id="ph3">` ptr`</ph> <ph id="ph4">`+`</ph> <ph id="ph5">`_Size``)`</ph> no longer contain traceable pointers.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>(Any pointers to allocated storage must not be dereferenced unless made <ph id="ph1">`reachable`</ph>.)</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>declare_reachable</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Informs garbage collection that the indicated address is to allocated storage and is reachable.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>A pointer to a reachable, allocated, valid storage area.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">` ptr`</ph> is not null, the function informs any garbage collector that <ph id="ph2">` ptr`</ph> is hereafter reachable (points to valid allocated storage).</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>default_delete</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Deletes objects allocated with <ph id="ph1">`operator new`</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Suitable for use with <ph id="ph1">`unique_ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Pointer to the object to delete.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Other</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The type of elements in the array to be deleted.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The template class describes a <ph id="ph1">`deleter`</ph> that deletes scalar objects allocated with <ph id="ph2">`operator new`</ph>, suitable for use with template class <ph id="ph3">`unique_ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>It also has the explicit specialization <ph id="ph1">`default_delete&lt;Type[]&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>dynamic_pointer_cast</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Dynamic cast to shared_ptr.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The type controlled by the returned shared pointer.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The type controlled by the argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The template function returns an empty shared_ptr object if <ph id="ph1">`dynamic_cast&lt;Ty*&gt;(sp.get())`</ph> returns a null pointer; otherwise it returns a <bpt id="p1">[</bpt>shared_ptr Class<ept id="p1">](../standard-library/shared-ptr-class.md)</ept><ph id="ph2">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id="ph3">`sp`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`dynamic_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>get_deleter Function</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Get deleter from shared_ptr.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The type of the deleter.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The type controlled by the shared pointer.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The shared pointer.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The template function returns a pointer to the deleter of type <ph id="ph1">`D`</ph> that belongs to the <bpt id="p1">[</bpt>shared_ptr Class<ept id="p1">](../standard-library/shared-ptr-class.md)</ept> object <ph id="ph2">`sp`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`sp`</ph> has no deleter or if its deleter is not of type <ph id="ph2">`D`</ph> the function returns 0.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>get_pointer_safety</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Returns the type of pointer safety assumed by any garbage collector.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The function returns the type of pointer safety assumed by any automatic <ph id="ph1">`garbage collector`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>get_temporary_buffer</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Allocates temporary storage for a sequence of elements that does not exceed a specified number of elements.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The maximum number of elements requested for which memory is to be allocated.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`pair`</ph> whose first component is a pointer to the memory that was allocated, and whose second component gives the size of the buffer, indicating the largest number of elements that it could store.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The function makes a request for memory and it may not succeed.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If no buffer is allocated, then the function returns a pair, with the second component equal to zero and the first component equal to the null pointer.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This function should only be used for memory that is temporary.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>make_shared</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Creates and returns a <ph id="ph1">`shared_ptr`</ph> that points to the allocated objects that are constructed from zero or more arguments by using the default allocator.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Allocates and constructs both an object of the specified type and a <ph id="ph1">`shared_ptr`</ph> to manage shared ownership of the object, and returns the <ph id="ph2">`shared_ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Zero or more constructor arguments.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The function infers which constructor overload to invoke based on the arguments that are provided.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`make_shared`</ph> as a simple and more efficient way to create an object and a <ph id="ph2">`shared_ptr`</ph> to manage shared access to the object at the same time.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Semantically, these two statements are equivalent:</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>However, the first statement makes two allocations, and if the allocation of the <ph id="ph1">`shared_ptr`</ph> fails after the allocation of the <ph id="ph2">`Example`</ph> object has succeeded, then the unnamed <ph id="ph3">`Example`</ph> object is leaked.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The statement that uses <ph id="ph1">`make_shared`</ph> is simpler because there's only one function call involved.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>It's more efficient because the library can make a single allocation for both the object and the smart pointer.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This is both faster and leads to less memory fragmentation, and there is no chance of an exception on one allocation but not the other.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Performance is improved by better locality for code that references the object and updates the reference counts in the smart pointer.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Consider using <bpt id="p1">[</bpt>make_unique<ept id="p1">](../standard-library/memory-functions.md#make_unique)</ept> if you do not need shared access to the object.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>allocate_shared<ept id="p1">](../standard-library/memory-functions.md#allocate_shared)</ept> if you need to specify a custom allocator for the object.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You can't use <ph id="ph1">`make_shared`</ph> if your object requires a custom deleter, because there is no way to pass the deleter as an argument.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example shows how to create shared pointers to a type by invoking specific constructor overloads.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The example produces this output:</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>make_unique</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Creates and returns a <bpt id="p1">[</bpt>unique_ptr<ept id="p1">](../standard-library/unique-ptr-class.md)</ept> to an object of the specified type, which is constructed by using the specified arguments.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The type of the object that the <ph id="ph1">`unique_ptr`</ph> will point to.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The types of the constructor arguments specified by <ph id="ph1">`Args`</ph>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The arguments to be passed to the constructor of the object of type <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>An array of elements of type <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The number of elements to allocate space for in the new array.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The first overload is used for single objects, the second overload is invoked for arrays, and the third overload prevents the prevents you from specifying an array size in the type argument (make_unique<ph id="ph1">\&lt;</ph>T[N]&gt;); this construction is not supported by the current standard.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When you use <ph id="ph1">`make_unique`</ph> to create a <ph id="ph2">`unique_ptr`</ph> to an array, you have to initialize the array elements separately.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If you are considering this overload, perhaps a better choice is to use a <bpt id="p1">[</bpt>std::vector<ept id="p1">](../standard-library/vector-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`make_unique`</ph> is carefully implemented for exception safety, we recommend that you use <ph id="ph2">`make_unique`</ph> instead of directly calling <ph id="ph3">`unique_ptr`</ph> constructors.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following example shows how to use <ph id="ph1">`make_unique`</ph>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>For more examples, see <bpt id="p1">[</bpt>How to: Create and Use unique_ptr Instances<ept id="p1">](../cpp/how-to-create-and-use-unique-ptr-instances.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>stl_smart_pointers#214</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>When you see error C2280 in connection with a <ph id="ph1">`unique_ptr`</ph>, it is almost certainly because you are attempting to invoke its copy constructor, which is a deleted function.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>owner_less</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Allows ownership-based mixed comparisons of shared and weak pointers.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the left parameter is ordered before right parameter by the member function <ph id="ph2">`owner_before`</ph>.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A shared or weak pointer.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A shared or weak pointer.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The template classes define all their member operators as returning <ph id="ph1">` left``.owner_before(`` right``)`</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>return_temporary_buffer</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Deallocates the temporary memory that was allocated using the <ph id="ph1">`get_temporary_buffer`</ph> template function.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>_Pbuf</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>A pointer to the memory to be deallocated.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This function should only be used for memory that is temporary.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>static_pointer_cast</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Static cast to shared_ptr.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The type controlled by the returned shared pointer.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The type controlled by the argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The argument shared pointer.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The template function returns an empty shared_ptr object if <ph id="ph1">`sp`</ph> is an empty <ph id="ph2">`shared_ptr`</ph> object; otherwise it returns a <bpt id="p1">[</bpt>shared_ptr Class<ept id="p1">](../standard-library/shared-ptr-class.md)</ept><ph id="ph3">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id="ph4">`sp`</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`static_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>swap (C++ Standard Library)</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Swap two shared_ptr or weak_ptr objects.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The type controlled by the left shared/weak pointer.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The type controlled by the right shared/weak pointer.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The left shared/weak pointer.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The right shared/weak pointer.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The template functions call <ph id="ph1">`left.swap(right)`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>undeclare_no_pointers</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size may now contain traceable pointers.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The function informs any <ph id="ph1">`garbage collector`</ph> that the range of addresses <ph id="ph2">`[`` ptr``,`</ph> <ph id="ph3">` ptr`</ph> <ph id="ph4">`+`</ph> <ph id="ph5">`_Size``)`</ph> may now contain <ph id="ph6">`traceable pointers`</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>undeclare_reachable</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Informs a <ph id="ph1">`garbage_collector`</ph> that a specified memory location is not reachable.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Parameter</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>A pointer to the memory address to be declared not reachable.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">` ptr`</ph> is not <ph id="ph2">`null`</ph>, the function informs any <ph id="ph3">`garbage collector`</ph> that <ph id="ph4">` ptr`</ph> is hereafter not <ph id="ph5">`reachable`</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>It returns a <ph id="ph1">`safely derived`</ph> pointer that compares equal to <ph id="ph2">` ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>uninitialized_copy</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Copies objects from a specified source range into an uninitialized destination range.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the first element in the source range.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>An input iterator addressing the last element in the source range.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the first element in the destination range.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the first position beyond the destination range, unless the source range was empty and iterator addresses <bpt id="p1">*</bpt> first.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>This algorithm allows the decoupling of memory allocation from object construction.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The template function effectively executes:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>unless the code throws an exception.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>In that case, all constructed objects are destroyed and the exception is rethrown.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>uninitialized_copy_n</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Creates a copy of a specified number of elements from an input iterator.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The copies are put in a forward iterator.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>An input iterator that refers to the object to copy.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>A signed or unsigned integer type specifying the number of times to copy the object.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>A forward iterator that refers to where the new copies go.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A forward iterator that addresses the first position beyond the destination.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If the source range was empty, the iterator addresses <ph id="ph1">` first`</ph><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The template function effectively executes the following:</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>unless the code throws an exception.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In that case, all constructed objects are destroyed and the exception is rethrown.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>uninitialized_fill</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Copies objects of a specified value into an uninitialized destination range.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the first element in the destination range that is to be initiated.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the last element in the destination range that is to be initiated.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The value to be used to initialize the destination range.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>This algorithm allows the decoupling of memory allocation from object construction.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The template function effectively executes:</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>unless the code throws an exception.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>In that case, all constructed objects are destroyed and the exception is rethrown.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>uninitialized_fill_n</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Copies objects of a specified value into specified number of elements into an uninitialized destination range.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A forward iterator addressing the first element in the destination range to be initiated.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The number of elements to be initialized.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The value to be used to initialize the destination range.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>This algorithm allows the decoupling of memory allocation from object construction.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The template function effectively executes:</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>unless the code throws an exception.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>In that case, all constructed objects are destroyed and the exception is rethrown.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>memory&gt;</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>