<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="cs-cz">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2fdf4b31ae641cc466fbd6529fdcc21c5fbd4b28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\constructors-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8f0836c2943c3dd36c04193c1f6aea0b926bff35</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e0f6cc47d59dc99aa76fc0eb24db25d02e7fe17</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Constructors (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Constructors (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A constructor is a kind of member function that initializes an instance of its class.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A constructor has the same name as the class and no return value.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A constructor can have any number of parameters and a class may have any number of overloaded constructors.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Constructors may have any accessibility, public, protected or private.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If you don't define any constructors, the compiler will generate a default constructor that takes no parameters; you can override this behavior by declaring a default constructor as deleted.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In this topic</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Order of Construction</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Member Lists</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Explicit Constructors</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Default Constructors</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Copy and Move Constructors</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Explicitly Defaulted and Deleted Constructors</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Constructors in Derived Classes</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Virtual Functions in Constructors</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Constructors and Composite Classes</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Delegating Constructors</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Inheriting constructors (C++11)</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Rules for Declaring Constructors</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Default and Copy Constructors</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Explicitly invoking constructors</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Order of Construction</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A constructor performs its work in this order:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It calls base class and member constructors in the order of declaration.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the class is derived from virtual base classes, it initializes the object's virtual base pointers.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If the class has or inherits virtual functions, it initializes the object's virtual function pointers.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Virtual function pointers point to the class's virtual function table to enable correct binding of virtual function calls to code.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It executes any code in its function body.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following example shows the order in which base class and member constructors are called in the constructor for a derived class.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>First, the base constructor is called, then the base-class members are initialized in the order in which they appear in the class declaration, and then the derived constructor is called.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Here's the output:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If a constructor throws an exception, the order of destruction is the reverse of the order of construction:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The code in the body of the constructor function is unwound.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Base class and member objects are destroyed, in the reverse order of declaration.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If the constructor is non-delegating, all fully-constructed base class objects and members are destroyed.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, because the object itself is not fully constructed, the destructor is not run.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Member Lists</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Initialize class members from constructor arguments by using a member initializer list.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This method uses <bpt id="p1">*</bpt>direct initialization<ept id="p1">*</ept>, which is more efficient than using assignment operators inside the constructor body.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Create a Box object:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Explicit Constructors</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If a class has a constructor with a single parameter, or if all parameters except one have a default value, the parameter type can be implicitly converted to the class type.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, if the <ph id="ph1">`Box`</ph> class has a constructor like this:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>It is possible to initialize a Box like this:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Or pass an int to a function that takes a Box:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Such conversions can be useful in some cases, but more often they can lead to subtle but serious errors in your code.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>As a general rule, you should use the <ph id="ph1">`explicit`</ph> keyword on a constructor (and user-defined operators) to prevent this kind of implicit type conversion:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When the constructor is explicit, this line causes a compiler error: <ph id="ph1">`ShippingOrder so(42, 10.8);`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>User-Defined Type Conversions<ept id="p1">](../cpp/user-defined-type-conversions-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Default Constructors</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Default constructors<ept id="p1">*</ept> have no parameters; they follow slightly different rules:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Default constructors are one of the <bpt id="p1">*</bpt>special member functions<ept id="p1">*</ept>; if no constructors are declared in a class, the compiler provides a default constructor:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>When you call a default constructor and try to use parentheses, a warning is issued:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This is an example of the Most Vexing Parse problem.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Because the example expression can be interpreted either as the declaration of a function or as the invocation of a default constructor, and because C++ parsers favor declarations over other things, the expression is treated as a function declaration.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Most Vexing Parse<ept id="p1">](http://en.wikipedia.org/wiki/Most_vexing_parse)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If any non-default constructors are declared, the compiler does not provide a default constructor:</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If a class has no default constructor, an array of objects of that class cannot be constructed by using square-bracket syntax alone.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, given the previous code block, an array of Boxes cannot be declared like this:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>However, you can use a set of initializer lists to initialize an array of Boxes:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Copy and Move Constructors</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>copy constructor<ept id="p1">*</ept> is a special member function that takes as input a reference to an object of the same type, and makes a copy of it.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Copy Constructors and Copy Assignment Operators (C++)<ept id="p1">](../cpp/copy-constructors-and-copy-assignment-operators-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A move is also a special member function constructor moves ownership of an existing object to a new variable without copying the original data.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For more information, see  <bpt id="p1">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id="p1">](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db)</ept> and  <bpt id="p2">[</bpt>Move Constructors and Move Assignment Operators (C++)<ept id="p2">](../cpp/move-constructors-and-move-assignment-operators-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Explicitly Defaulted and Deleted Constructors</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You can explicitly default copy constructors, default constructors, move constructors, copy assignment operators, move assignment operators, and destructors.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can explicitly delete all of the special member functions.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicitly Defaulted and Deleted Functions<ept id="p1">](../cpp/explicitly-defaulted-and-deleted-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Constructors in Derived Classes</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A derived class constructor always calls a base class constructor, so that it can rely on completely constructed base classes before any extra work is done.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The base class constructors are called in order of derivation—for example, if ClassA is derived from ClassB, which is derived from ClassC, the ClassC constructor is called first, then the ClassB constructor, then the ClassA constructor.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If a base class does not have a default constructor, you must supply the base class constructor parameters in the derived class constructor:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Constructors for Classes That Have Multiple Inheritance</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If a class is derived from multiple base classes, the base class constructors are invoked in the order in which they are listed in the declaration of the derived class:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You should expect the following output:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Virtual Functions in Constructors</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>We recommend that you be careful when you call virtual functions in constructors.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Because the base class constructor is always invoked before the derived class constructor, the function that's called in the base constructor is the base class version, not the derived class version.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In the following example, constructing a <ph id="ph1">`DerivedClass`</ph> causes the <ph id="ph2">`BaseClass`</ph> implementation of <ph id="ph3">`print_it()`</ph> to execute before the <ph id="ph4">`DerivedClass`</ph> constructor causes the <ph id="ph5">`DerivedClass`</ph> implementation of <ph id="ph6">`print_it()`</ph> to execute:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Here's the output:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Constructors and Composite Classes</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Classes that contain class-type members are known as <bpt id="p1">*</bpt>composite classes<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When a class-type member of a composite class is created, the constructor is called before the class's own constructor.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When a contained class lacks a default constructor, you must use an initialization list in the constructor of the composite class.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In the earlier <ph id="ph1">`StorageBox`</ph> example, if you change the type of the <ph id="ph2">`m_label`</ph> member variable to a new <ph id="ph3">`Label`</ph> class, you must call both the base class constructor and initialize the <ph id="ph4">`m_label`</ph> variable in the <ph id="ph5">`StorageBox`</ph> constructor:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Delegating Constructors</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>delegating constructor<ept id="p1">*</ept> calls a different constructor in the same class to do some of the work of initialization.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In the following example, the derived class has three constructors—the second constructor delegates to the first, and the third constructor delegates to the second:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Here's the output:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The object created by the constructors is fully initialized as soon as any constructor is finished.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>succeeds, but <ph id="ph1">`DerivedContainer(int int1, int int2)`</ph> fails and the destructor is called.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Output:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Uniform Initialization and Delegating Constructors<ept id="p1">](../cpp/uniform-initialization-and-delegating-constructors.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Inheriting constructors (C++11)</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A derived class can inherit the constructors from a direct base class by using a using declaration as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The using statement brings into scope all constructors from the base class except those that have an identical signature to constructors in the derived class.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In general, it is best to use inheriting constructors when the derived class declares no new data members or constructors.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>A class template can inherit all the constructors from a type argument if that type specifies a base class:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A deriving class cannot inherit from multiple base classes if those base classes have constructors that have an identical signature.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Rules for Declaring Constructors</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A constructor has the same name as its class.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Any number of constructors can be declared, subject to the rules of overloaded functions.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`argument-declaration-list`</ph> may be empty.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>C++ defines two special kinds of constructors, default and copy constructors, described in the following table.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Default and Copy Constructors</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Kind of Construction</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Arguments</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Default constructor</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Can be called with no arguments</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Construct a default object of the class type</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Copy constructor</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Can accept a single argument of reference to same class type</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Copy objects of the class type</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Default constructors can be called with no arguments.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>However, you can declare a default constructor with an argument list, provided all arguments have defaults.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Similarly, copy constructors must accept a single argument of reference to the same class type.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>More arguments can be supplied, provided all subsequent arguments have defaults.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you do not supply any constructors, the compiler attempts to generate a default constructor.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If you do not supply a copy constructor, the compiler attempts to generate one.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>These compiler-generated constructors are considered public member functions.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>An error is generated if you specify a copy constructor with a first argument that is an object and not a reference.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A compiler-generated default constructor sets up the object (initializes vftables and vbtables, as described previously), and it calls the default constructors for base classes and members, but it takes no other action.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Base class and member constructors are called only if they exist, are accessible, and are unambiguous.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>A compiler-generated copy constructor sets up a new object and performs a memberwise copy of the contents of the object to be copied.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If base class or member constructors exist, they are called; otherwise, bitwise copying is performed.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If all base and member classes of a class <ph id="ph1">`type`</ph> have copy constructors that accept a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> argument, the compiler-generated copy constructor accepts a single argument of type <bpt id="p2">**</bpt>const<ept id="p2">**</ept> <ph id="ph2">`type`</ph><bpt id="p3">**</bpt><ph id="ph3">&amp;</ph><ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Otherwise, the compiler-generated copy constructor accepts a single argument of type <ph id="ph1">`type`</ph><bpt id="p1">**</bpt><ph id="ph2">&amp;</ph><ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>You can use a constructor to initialize a <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> object, but the constructor itself cannot be declared as <bpt id="p2">**</bpt>const<ept id="p2">**</ept> or <ph id="ph2">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The only legal storage class for a constructor is <bpt id="p1">**</bpt>inline<ept id="p1">**</ept>; use of any other storage-class modifier, including the <ph id="ph1">`__declspec`</ph> keyword, with a constructor causes a compiler error.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The stdcall calling convention is used on static member functions and global functions declared with the <bpt id="p1">**</bpt>__stdcall<ept id="p1">**</ept> keyword, and that do not use a variable argument list.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">**</bpt>__stdcall<ept id="p1">**</ept> keyword on a non-static member function, such as a constructor, the compiler will use the thiscall calling convention."</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Constructors of base classes are not inherited by derived classes.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>When an object of derived class type is created, it is constructed starting with the base class components; then it moves to the derived class components.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The compiler uses each base class's constructor as that part of the complete object is initialized (except in cases of virtual derivation.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Explicitly invoking constructors</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Constructors can be explicitly called in a program to create objects of a given type.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, to create two <ph id="ph1">`Point`</ph> objects that describe the ends of a line, the following code can be written:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Two objects of type <ph id="ph1">`Point`</ph> are created, passed to the function <ph id="ph2">`DrawLine`</ph>, and destroyed at the end of the expression (the function call).</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Another context in which a constructor is explicitly called is in an initialization:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>An object of type <ph id="ph1">`Point`</ph> is created and initialized using the constructor that accepts two arguments of type <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Objects that are created by calling constructors explicitly, as in the preceding two examples, are unnamed and have a lifetime of the expression in which they are created.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This is discussed in greater detail in <bpt id="p1">[</bpt>Temporary Objects<ept id="p1">](../cpp/temporary-objects.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>It is usually safe to call any member function from within a constructor because the object has been completely set up (virtual tables have been initialized and so on) prior to the execution of the first line of user code.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>However, it is potentially unsafe for a member function to call a virtual member function for an abstract base class during construction or destruction.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Constructors can call virtual functions.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>When virtual functions are called, the function invoked is the function defined for the constructor's own class (or inherited from its bases).</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following example shows what happens when a virtual function is called from within a constructor:</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>When the preceding program is run, the declaration <ph id="ph1">`Derived d`</ph> causes the following sequence of events:</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The constructor for class <ph id="ph1">`Derived`</ph> (<ph id="ph2">`Derived::Derived`</ph>) is called.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Prior to entering the body of the <ph id="ph1">`Derived`</ph> class's constructor, the constructor for class <ph id="ph2">`Base`</ph> (<ph id="ph3">`Base::Base`</ph>) is called.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>calls the function <ph id="ph1">`f`</ph>, which is a virtual function.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Ordinarily, <ph id="ph1">`Derived::f`</ph> would be called because the object <ph id="ph2">`d`</ph> is of type <ph id="ph3">`Derived`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Base::Base`</ph> function is a constructor, the object is not yet of the <ph id="ph2">`Derived`</ph> type, and <ph id="ph3">`Base::f`</ph> is called.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>