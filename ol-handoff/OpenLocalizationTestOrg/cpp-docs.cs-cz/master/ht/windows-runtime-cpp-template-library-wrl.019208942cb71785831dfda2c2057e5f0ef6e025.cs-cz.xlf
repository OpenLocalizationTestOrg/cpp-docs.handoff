<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="cs-cz">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8ce682941018d5a0c166051012e2dd56fe062cd0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\windows\windows-runtime-cpp-template-library-wrl.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0994b0b81d678eb8dc731da4574d71c89228c8b5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edac06f3ab78cb39e795528c38903cef14f0aba1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Windows Runtime C++ Template Library (WRL) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Windows Runtime C++ Template Library (WRL)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[cppwrl](../windows/includes/cppwrl_md.md)]</ph> (<ph id="ph2">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph>) is a template library that provides a low-level way to author and use <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> components.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Benefits</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> enables you to more easily implement and consume Component Object Model (COM) components.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It provides housekeeping techniques like reference-counting to manage the lifetime of objects and testing <ph id="ph1">`HRESULT`</ph> values to determine whether an operation succeeded or failed.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>To successfully use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph>, you must carefully follow these rules and techniques.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[cppwrt](../build/reference/includes/cppwrt_md.md)]</ph> (<ph id="ph2">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph>) is a high-level, language-based way to use <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> components.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Both the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> and <ph id="ph2">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph> simplify the writing of code for the <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> by automatically performing housekeeping tasks on your behalf.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> and <ph id="ph2">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph> provide different benefits.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Here are some reasons you might want to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> instead of <ph id="ph2">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>adds little abstraction over the <ph id="ph1">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> Application Binary Interface (ABI), giving you the ability to control the underlying code to better create or consume <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> APIs.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>represents COM <ph id="ph1">`HRESULT`</ph> values as exceptions.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If you’ve inherited a code base that uses COM, or one that doesn’t use exceptions, you might find that the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> is a more natural way to work with the <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> because you don't have to use exceptions.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> uses <ph id="ph2">`HRESULT`</ph> values and does not throw exceptions.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In addition, the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> uses smart pointers and the RAII pattern to help guarantee that objects are destroyed correctly when your application code throws an exception.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more info about smart pointers and RAII, see <bpt id="p1">[</bpt>Smart Pointers<ept id="p1">](../cpp/smart-pointers-modern-cpp.md)</ept> and <bpt id="p2">[</bpt>Objects Own Resources (RAII)<ept id="p2">](../cpp/objects-own-resources-raii.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The purpose and design of the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> is inspired by the Active Template Library (ATL), which is a set of template-based C++ classes that simplify the programming of COM objects.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> uses standard C++ to wrap the <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>, you can more easily port and interact with many existing COM components written in ATL to the <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you already know ATL, you might find that <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> programming is easier.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Here are some resources that can help you get working with the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> right away.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The Windows Runtime Library (WRL)</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In this Channel 9 video, learn more about how the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> helps you write <ph id="ph2">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> apps and how to author and consume <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> components.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>How to: Activate and Use a Windows Runtime Component</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to initialize the <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> and activate and use a <ph id="ph3">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> component.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>How to: Complete Asynchronous Operations</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to start asynchronous operations and perform work when the operations complete.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>How to: Handle Events</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to subscribe to and handle the events of a <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> object.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Basic Windows Runtime Component</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to create a basic <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> component that adds two numbers.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Also demonstrates how to raise events and use the component from a <ph id="ph1">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> app that uses JavaScript.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Windows Store app using WRL and Media Foundation</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Learn how to create a <ph id="ph1">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> app that uses <bpt id="p1">[</bpt>Microsoft Media Foundation<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/ms694197)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>How to: Create a Classic COM Component</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to create a basic COM component and a basic way to register and consume the COM component from a desktop app.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>How to: Instantiate WRL Components Directly</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Learn how to use the <bpt id="p1">[</bpt>Microsoft::WRL::Make<ept id="p1">](../windows/make-function.md)</ept> and <bpt id="p2">[</bpt>Microsoft::WRL::Details::MakeAndInitialize<ept id="p2">](../windows/makeandinitialize-function.md)</ept> functions to instantiate a component from the module that defines it.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>How to: Use winmdidl.exe and midlrt.exe to create .h files from windows metadata</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Shows how to consume custom Windows Runtime components from WRL by creating an IDL file from the .winmd metadata.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Walkthrough: Connecting Using Tasks and XML HTTP Requests</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Shows how to use the <bpt id="p1">[</bpt>IXMLHTTPRequest2<ept id="p1">](http://msdn.microsoft.com/en-us/bbc11c4a-aecf-4d6d-8275-3e852e309908)</ept> and <bpt id="p2">[</bpt>IXMLHTTPRequest2Callback<ept id="p2">](http://msdn.microsoft.com/en-us/aa4b3f4c-6e28-458b-be25-6cce8865fc71)</ept> interfaces together with tasks to send HTTP GET and POST requests to a web service in a <ph id="ph1">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> app.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Bing Maps Trip Optimizer sample</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Uses the <ph id="ph1">`HttpRequest`</ph> class that's defined in <bpt id="p1">[</bpt>Walkthrough: Connecting Using Tasks and XML HTTP Requests<ept id="p1">](../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md)</ept> in the context of a complete <ph id="ph2">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> app.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Creating a Windows Runtime DLL component with C++ sample</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Shows how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to create an in-process DLL component and consume it from C++/CX, JavaScript, and C#.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>DirectX marble maze game sample</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Demonstrates how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to manage the lifetime of COM components such as DirectX and Media Foundation in the context of a complete 3-D game.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Sending toast notifications from desktop apps sample</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Demonstrates how to use the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to work with toast notifications from a desktop app.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Compared to ATL</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>resembles the Active Template Library (ATL) because you can use it to create small, fast COM objects.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>and ATL also share concepts such as definition of objects in modules, explicit registration of interfaces, and open creation of objects by using factories.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You might be comfortable with <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> if you're familiar with ATL.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>supports the COM functionality that is required for <ph id="ph1">[!INCLUDE[win8_appname_long](../build/includes/win8_appname_long_md.md)]</ph> apps.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Therefore, it differs from the ATL because it omits direct support for COM features such as:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>aggregation</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>stock implementations</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>dual interfaces (<ph id="ph1">`IDispatch`</ph>)</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>standard enumerator interfaces</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>connection points</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>tear-off interfaces</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>OLE embedding</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>ActiveX controls</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>COM+</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Concepts</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>provides types that represent a few basic concepts.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following sections describe those types.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>ComPtr</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ComPtr<ept id="p1">](../windows/comptr-class.md)</ept> is a <bpt id="p2">*</bpt>smart pointer<ept id="p2">*</ept> type that represents the interface that's specified by the template parameter.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`ComPtr`</ph> to declare a variable that can access the members of an object that's derived from the interface.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>automatically maintains a reference count for the underlying interface pointer and releases the interface when the reference count goes to zero.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>RuntimeClass</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RuntimeClass<ept id="p1">](../windows/runtimeclass-class.md)</ept> represents an instantiated class that inherits a set of specified interfaces.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`RuntimeClass`</ph> object can provide a combination of support for one or more <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> COM interfaces, or a weak reference to a component.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Module</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Module<ept id="p1">](../windows/module-class.md)</ept> represents a collection of related objects.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Module`</ph> object manages class factories, which create objects, and registration, which enables other applications to use an object.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Callback</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Callback<ept id="p1">](../windows/callback-function-windows-runtime-cpp-template-library.md)</ept> function creates an object whose member function is an event handler (a callback method).</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`Callback`</ph> function to write asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>EventSource</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EventSource<ept id="p1">](../windows/eventsource-class.md)</ept> is used to manage <bpt id="p2">*</bpt>delegate<ept id="p2">*</ept> event handlers.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> to implement a delegate, and use <ph id="ph2">`EventSource`</ph> to add, remove, and invoke delegates.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>AsyncBase</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>AsyncBase<ept id="p1">](../windows/asyncbase-class.md)</ept> provides virtual methods that represent the <ph id="ph1">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> asynchronous programming model.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Override the members in this class to create a custom class that can start, stop, or check the progress of an asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>FtmBase</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>FtmBase<ept id="p1">](../windows/ftmbase-class.md)</ept> represents a free-threaded marshaler object.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>creates a global interface table (GIT), and helps manage marshaling and proxy objects.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>WeakRef</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>WeakRef<ept id="p1">](../windows/weakref-class.md)</ept> is a smart-pointer type that represents a <bpt id="p2">*</bpt>weak reference<ept id="p2">*</ept>, which references an object that might or might not be accessible.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`WeakRef`</ph> object can be used by only the <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>, and not by classic COM.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`WeakRef`</ph> object typically represents an object whose existence is controlled by an external thread or application.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">`WeakRef`</ph> object can reference a file object.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>When the file is open, the <ph id="ph1">`WeakRef`</ph> is valid and the referenced file is accessible.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>But when the file is closed, the <ph id="ph1">`WeakRef`</ph> is invalid and the file is not accessible.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Class Library Project Template</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Describes how to access the WRL Class Library project template.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This template helps simplify the task of using Visual Studio to create <ph id="ph1">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> components.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Key APIs by Category</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Highlights the primary <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph> types, functions, and macros.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Reference</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Contains reference information for the <ph id="ph1">[!INCLUDE[cppwrl_short](../windows/includes/cppwrl_short_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Quick Reference (Windows Runtime and Visual C++)</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Briefly describes the <ph id="ph1">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph> features that support the <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Using Windows Runtime Components in Visual C++</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Shows how to use <ph id="ph1">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph> to create a basic <ph id="ph2">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> component.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>