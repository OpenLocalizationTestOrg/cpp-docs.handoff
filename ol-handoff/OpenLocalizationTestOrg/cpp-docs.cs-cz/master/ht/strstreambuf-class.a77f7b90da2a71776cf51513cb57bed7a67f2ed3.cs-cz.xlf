<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="cs-cz">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e4a8d73752680121279814a46fd1bffb059ae69f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\strstreambuf-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0094d213bdf37c04f881eac4809d9c64414a4359</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dc0f3848d60ac5adda3d87d60b91cd9bcdb79cfc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>strstreambuf Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>strstreambuf Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Describes a stream buffer that controls the transmission of elements to and from a sequence of elements stored in a <ph id="ph1">`char`</ph> array object.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Depending on how the object is constructed, it can be allocated, extended, and freed as necessary to accommodate changes in the sequence.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>An object of class <ph id="ph1">`strstreambuf`</ph> stores several bits of mode information as its <ph id="ph2">`strstreambuf`</ph> mode.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>These bits indicate whether the controlled sequence:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Has been allocated and needs to be freed eventually.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Is modifiable.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Is extendable by reallocating storage.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Has been frozen and hence needs to be unfrozen before the object is destroyed, or freed (if allocated) by an agency other than the object.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A controlled sequence that is frozen cannot be modified or extended, regardless of the state of these separate mode bits.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The object also stores pointers to two functions that control <ph id="ph1">`strstreambuf`</ph> allocation.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If these are null pointers, the object devises its own method of allocating and freeing storage for the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This class is deprecated.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider using <bpt id="p1">[</bpt>stringbuf<ept id="p1">](../standard-library/sstream-typedefs.md#stringbuf)</ept> or <bpt id="p2">[</bpt>wstringbuf<ept id="p2">](../standard-library/sstream-typedefs.md#wstringbuf)</ept> instead.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Constructors</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>strstreambuf</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Constructs an object of type <ph id="ph1">`strstreambuf`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>freeze</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Causes a stream buffer to be unavailable through stream buffer operations.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>overflow</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A protected virtual function that can be called when a new character is inserted into a full buffer.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>pbackfail</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to put back an element into the input stream, and then make it the current element (pointed to by the next pointer).</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>pcount</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Returns a count of the number of elements written to the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>seekoff</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>seekpos</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>str</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Calls <bpt id="p1">[</bpt>freeze<ept id="p1">](#strstreambuf__freeze)</ept>, and then returns a pointer to the beginning of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>underflow</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A protected virtual function to extract the current element from the input stream.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> <ph id="ph1">\&lt;</ph>strstream&gt;</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> std</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>strstreambuf::freeze</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Causes a stream buffer to be unavailable through stream buffer operations.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`bool`</ph> indicating whether you want the stream to be frozen.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Freezeit`</ph> is true, the function alters the stored <ph id="ph2">`strstreambuf`</ph> mode to make the controlled sequence frozen.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Otherwise, it makes the controlled sequence not frozen.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>str<ept id="p1">](#strstreambuf__str)</ept> implies <ph id="ph1">`freeze`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A frozen buffer will not be freed during <ph id="ph1">`strstreambuf`</ph> destruction.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You must unfreeze the buffer before it is freed to avoid a memory leak.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>strstreambuf::overflow</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A protected virtual function that can be called when a new character is inserted into a full buffer.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The character to insert into the buffer, or <ph id="ph1">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the function cannot succeed, it returns <ph id="ph1">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Otherwise, if _ <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept><ph id="ph1"> == `EOF`</ph>, it returns some value other than <ph id="ph2">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns <ph id="ph1">\_</ph> <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If _ <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept> != <ph id="ph1">`EOF`</ph>, the protected virtual member function tries to insert the element ( <ph id="ph2">`char`</ph>)<ph id="ph3">\_</ph> <bpt id="p2">*</bpt>Meta<ept id="p2">*</ept> into the output buffer.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It can do so in various ways:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If a write position is available, it can store the element into the write position and increment the next pointer for the output buffer.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If the stored strstreambuf mode says the controlled sequence is modifiable, extendable, and not frozen, the function can make a write position available by allocating new for the output buffer.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Extending the output buffer this way also extends any associated input buffer.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>strstreambuf::pbackfail</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to put back an element into the input stream, and then makes it the current element (pointed to by the next pointer).</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The character to insert into the buffer, or <ph id="ph1">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the function cannot succeed, it returns <ph id="ph1">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Otherwise, if _ <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept><ph id="ph1"> == `EOF`</ph>, it returns some value other than <ph id="ph2">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns <ph id="ph1">\_</ph> <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The protected virtual member function tries to put back an element into the input buffer, and then make it the current element (pointed to by the next pointer).</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If _ <bpt id="p1">*</bpt>Meta<ept id="p1">*</ept><ph id="ph1"> == `EOF`</ph>, the element to push back is effectively the one already in the stream before the current element.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Otherwise, that element is replaced by <bpt id="p1">**</bpt>ch<ept id="p1">**</ept> = ( <ph id="ph1">`char`</ph>)<ph id="ph2">\_</ph> <bpt id="p2">*</bpt>Meta<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The function can put back an element in various ways:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If a putback position is available, and the element stored there compares equal to <bpt id="p1">**</bpt>ch<ept id="p1">**</ept>, it can decrement the next pointer for the input buffer.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If a putback position is available, and if the strstreambuf mode says the controlled sequence is modifiable, the function can store <bpt id="p1">**</bpt>ch<ept id="p1">**</ept> into the putback position and decrement the next pointer for the input buffer.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>strstreambuf::pcount</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Returns a count of the number of elements written to the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A count of the number of elements written to the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Specifically, if <bpt id="p1">[</bpt>pptr<ept id="p1">](../standard-library/basic-streambuf-class.md#basic_streambuf__pptr)</ept> is a null pointer, the function returns zero.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns <ph id="ph1">`pptr`</ph> â€“ <bpt id="p1">[</bpt>pbase<ept id="p1">](../standard-library/basic-streambuf-class.md#basic_streambuf__pbase)</ept>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>strstreambuf::seekoff</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The position to seek for relative to <ph id="ph1">`_Way`</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The starting point for offset operations.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>seekdir<ept id="p1">](../standard-library/ios-base-class.md#ios_base__seekdir)</ept> for possible values.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Specifies the mode for the pointer position.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The default is to allow you to modify the read and write positions.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If the function succeeds in altering either or both stream positions, it returns the resultant stream position.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Otherwise, it fails and returns an invalid stream position.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The protected virtual member function endeavors to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For an object of class strstreambuf, a stream position consists purely of a stream offset.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Offset zero designates the first element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The new position is determined as follows:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Way` == `ios_base::beg`</ph>, the new position is the beginning of the stream plus _ <bpt id="p1">*</bpt>Off<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Way` == `ios_base::cur`</ph>, the new position is the current stream position plus _ <bpt id="p1">*</bpt>Off<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Way` == `ios_base::end`</ph>, the new position is the end of the stream plus _ <bpt id="p1">*</bpt>Off<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Which` &amp; </ph><bpt id="p1">**</bpt>ios_base::in<ept id="p1">**</ept> is nonzero and the input buffer exist, the function alters the next position to read in the input buffer.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Which` &amp; </ph><bpt id="p1">**</bpt>ios_base::out<ept id="p1">**</ept> is also nonzero, <ph id="ph2">`_Way`</ph> != <bpt id="p2">**</bpt>ios_base::cur<ept id="p2">**</ept>, and the output buffer exists, the function also sets the next position to write to match the next position to read.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Otherwise, if <ph id="ph1">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function alters the next position to write in the output buffer.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Otherwise, the positioning operation fails.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>strstreambuf::seekpos</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A protected virtual member function that tries to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The position to seek for.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Specifies the mode for the pointer position.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The default is to allow you to modify the read and write positions.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>If the function succeeds in altering either or both stream positions, it returns the resultant stream position.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Otherwise, it fails and returns an invalid stream position.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>To determine if the stream position is invalid, compare the return value with <ph id="ph1">`pos_type(off_type(-1))`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The protected virtual member function endeavors to alter the current positions for the controlled streams.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For an object of class strstreambuf, a stream position consists purely of a stream offset.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Offset zero designates the first element of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The new position is determined by _ <bpt id="p1">*</bpt>Sp<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Which` &amp; </ph><bpt id="p1">**</bpt>ios_base::in<ept id="p1">**</ept> is nonzero and the input buffer exists, the function alters the next position to read in the input buffer.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function also sets the next position to write to match the next position to read.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Otherwise, if <ph id="ph1">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function alters the next position to write in the output buffer.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Otherwise, the positioning operation fails.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>strstreambuf::str</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Calls <bpt id="p1">[</bpt>freeze<ept id="p1">](#strstreambuf__freeze)</ept>, and then returns a pointer to the beginning of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>No terminating null element exists, unless you explicitly insert one.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>strstreambuf::freeze<ept id="p1">](#strstreambuf__freeze)</ept> for a sample that uses <bpt id="p2">**</bpt>str<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>strstreambuf::strstreambuf</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Constructs an object of type <ph id="ph1">`strstreambuf`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>_Allocfunc</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The function used to allocate buffer memory.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Determines the length of the buffer pointed to by <ph id="ph1">`_Getptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Getptr`</ph> is not an argument (first constructor form), a suggested allocation size for the buffers.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>_Freefunc</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The function used to free buffer memory.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>A buffer used for input.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A buffer used for output.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The first constructor stores a null pointer in all the pointers controlling the input buffer, the output buffer, and strstreambuf allocation.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>It sets the stored strstreambuf mode to make the controlled sequence modifiable and extendable.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>It also accepts <ph id="ph1">` count`</ph> as a suggested initial allocation size.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The second constructor behaves like the first, except that it stores _ <bpt id="p1">*</bpt>Allocfunc<ept id="p1">*</ept> as the pointer to the function to call to allocate storage and <ph id="ph1">\_</ph> <bpt id="p2">*</bpt>Freefunc<ept id="p2">*</ept> as the pointer to the function to call to free that storage.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The three constructors:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>also behave like the first, except that <ph id="ph1">`_Getptr`</ph> designates the array object used to hold the controlled sequence.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>(Hence, it must not be a null pointer.) The number of elements <bpt id="p1">*</bpt>N<ept id="p1">*</ept> in the array is determined as follows:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If ( <ph id="ph1">` count`</ph> &gt; 0), then <bpt id="p1">*</bpt>N<ept id="p1">*</ept> is <bpt id="p2">**</bpt>count<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`(`` count`</ph> == 0), then <bpt id="p1">*</bpt>N<ept id="p1">*</ept> is <ph id="ph2">`strlen`</ph>( ( <bpt id="p2">**</bpt>const<ept id="p2">**</ept><ph id="ph3">`char`</ph> *) <ph id="ph4">`_Getptr`</ph> ).</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If ( <ph id="ph1">` count`</ph> &lt; 0), then <bpt id="p1">*</bpt>N<ept id="p1">*</ept> is <bpt id="p2">**</bpt>INT_MAX<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`_Putptr`</ph> is a null pointer, the function establishes just an input buffer by executing:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Otherwise, it establishes both input and output buffers by executing:</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`_Putptr`</ph> must be in the interval [ <ph id="ph2">`_Getptr`</ph>, <ph id="ph3">`_Getptr` + </ph><bpt id="p1">*</bpt>N<ept id="p1">*</ept>].</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Finally, the three constructors:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>all behave the same as:</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>except that the stored mode makes the controlled sequence neither modifiable nor extendable.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>strstreambuf::underflow</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>A protected virtual function to extract the current element from the input stream.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>If the function cannot succeed, it returns <ph id="ph1">`EOF`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns the current element in the input stream, converted as described above.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The protected virtual member function endeavors to extract the current element <bpt id="p1">**</bpt>ch<ept id="p1">**</ept> from the input buffer, then advance the current stream position, and return the element as ( <ph id="ph1">`int`</ph>)( <ph id="ph2">`unsigned``char`</ph>) <bpt id="p2">**</bpt>ch<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>It can do so in only one way: if a read position is available, it takes <bpt id="p1">**</bpt>ch<ept id="p1">**</ept> as the element stored in the read position and advances the next pointer for the input buffer.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>streambuf</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Thread Safety in the C++ Standard Library</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>iostream Programming</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>iostreams Conventions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>