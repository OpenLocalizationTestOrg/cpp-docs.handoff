<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-787e512" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9773d068539a0d6bca6a4b9ef7d0897815cad09e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\cast-notation-and-introduction-of-safe-cast-angles.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d047043f48fa1b0030f97c3376ffe266488ec90</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">69706c2d0aa64e3f331ea0a3ce3d26758a03f13e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Cast Notation and Introduction of safe_cast<ph id="ph1">&amp;lt;&amp;gt;</ph> | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Cast Notation and Introduction of safe_cast</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The cast notation has changed from Managed Extensions for C++ to <ph id="ph1">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Modifying an existing structure is a different and more difficult experience than crafting the initial structure.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>There are fewer degrees of freedom, and the solution tends towards a compromise between an ideal restructuring and what is practicable given the existing structural dependencies.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Language extension is another example.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Back in the early 1990s as Object-Orienting programming became an important paradigm, the need for a type-safe downcast facility in C++ became pressing.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Downcasting is the user-explicit conversion of a base-class pointer or reference to a pointer or reference of a derived class.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Downcasting requires an explicit cast.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The reason is that the actual type of the base class pointer is an aspect of the runtime; the compiler therefore cannot check it.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Or, to rephrase that, a downcast facility, just like a virtual function call, requires some form of dynamic resolution.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This raises two questions:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Why should a downcast be necessary in the Object-Oriented paradigm?</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Isn’t the virtual function mechanism sufficient?</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>That is, why can’t one claim that any need for a downcast (or a cast of any sort) is a design failure?</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Why should support of a downcast be a problem in C++?</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>After all, it is not a problem in object-oriented languages such as Smalltalk (or, subsequently, Java and C#)?</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>What is it about C++ that makes supporting a downcast facility difficult?</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A virtual function represents a type-dependent algorithm common to a family of types.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>(We are not considering interfaces, which are not supported in ISO-C++ but are available in CLR programming and which represent an interesting design alternative).</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The design of that family is typically represented by a class hierarchy in which there is an abstract base class declaring the common interface (the virtual functions) and a set of concrete derived classes which represent the actual family types in the application domain.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Light`</ph> hierarchy in a Computer Generated Imagery (CGI) application domain, for example, will have common attributes such as <ph id="ph2">`color`</ph>, <ph id="ph3">`intensity`</ph>, <ph id="ph4">`position`</ph>, <ph id="ph5">`on`</ph>, <ph id="ph6">`off`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>One can control several lights, by using the common interface without worrying whether a particular light is a spotlight, a directional light, a non-directional light (think of the sun), or perhaps a barn-door light.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In this case, downcasting to a particular light-type to exercise its virtual interface is unnecessary.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In a production environment, however,  speed is essential.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>One might downcast and explicitly invoke each method if by doing so inline execution of the calls can be performed instead of using the virtual mechanism.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>So, one reason to downcast in C++ is to suppress the virtual mechanism in return for a significant gain in runtime performance.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>(Note that the automation of this manual optimization is an active area of research.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, it is more difficult to solve than replacing the explicit use of the <ph id="ph1">`register`</ph> or <ph id="ph2">`inline`</ph> keyword.)</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A second reason to downcast falls out of the dual nature of polymorphism.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>One way to think of polymorphism is being divided into a passive and dynamic pair of forms.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A virtual invocation (and a downcast facility) represents dynamic uses of polymorphism: one is performing an action based on the actual type of the base class pointer at that particular instance in the execution of the program.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Assigning a derived class object to its base class pointer, however, is a passive form of polymorphism; it is using the polymorphism as a transport mechanism.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This is the main use of <ph id="ph1">`Object`</ph>, for example, in pre-generic CLR programming.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When used passively, the base class pointer chosen for transport and storage typically offers an interface that is too abstract.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>, for example, provides roughly five methods through its interface; any more specific behavior requires an explicit downcast.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, if we want to adjust the angle of our spotlight or its rate of fall off, we would have to downcast explicitly.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A virtual interface within a family of sub-types cannot practicably be a superset of all the possible methods of its many children, and so a downcast facility will always be needed within an object-oriented language.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If a safe downcast facility is needed in an object-oriented language, then why did it take C++ so long to add one?</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The problem is in how to make the information as to the run-time type of the pointer available.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the case of a virtual function, the run-time information is set up in two parts by the compiler:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The class object contains an additional virtual table pointer member (either at the beginning or end of the class object; that’s has an interesting history in itself) that addresses the appropriate virtual table.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example, a spotlight object addresses a spotlight virtual table, a directional light, a directional light virtual table, and so on</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Each virtual function has an associated fixed slot in the table, and the actual instance to invoke is represented by the address stored within the table.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, the virtual <ph id="ph1">`Light`</ph> destructor might be associated with slot 0, <ph id="ph2">`Color`</ph> with slot 1, and so on.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This is an efficient if inflexible strategy because it is set up at compile-time and represents a minimal overhead.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The problem, then, is how to make the type information available to the pointer without changing the size of C++ pointers, either by adding a second address or by directly adding some sort of type encoding.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This would not be acceptable to those programmers (and programs) that decide not to use the object-oriented paradigm – which was still the predominant user community.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Another possibility was to introduce a special pointer for polymorphic class types, but this would be confusing, and make it difficult to inter-mix the two, particularly with issues of pointer arithmetic.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It would also not be acceptable to maintain a run-time table that associates each pointer with its currently associated type, and dynamically updating it.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The problem then is a pair of user communities which have different but legitimate programming aspirations.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The solution has to be a compromise between the two communities, allowing each not only their aspiration but the ability to interoperate.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This means that the solutions offered by either side are likely to be infeasible and the solution implemented finally to be less than perfect.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The actual resolution revolves around the definition of a polymorphic class: a polymorphic class is one that contains a virtual function.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A polymorphic class supports a dynamic type-safe downcast.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This solves the maintain-the-pointer-as-address problem because all polymorphic classes contain that additional pointer member to their associated virtual table.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The associated type information, therefore, can be stored in an expanded virtual table structure.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The cost of the type-safe downcast is (almost) localized to users of the facility.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The next issue with the type-safe downcast was its syntax.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Because it is a cast, the original proposal to the ISO-C++ committee used the unadorned cast syntax, as in this example:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>but this was rejected by the committee because it did not allow the user to control the cost of the cast.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the dynamic type-safe downcast has the same syntax as the previously unsafe but static cast notation, then it becomes a substitution, and the user has no ability to suppress the runtime overhead when it is unnecessary and perhaps too costly.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In general, in C++, there is always a mechanism by which to suppress compiler-supported functionality.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, we can turn off the virtual mechanism by either using the class scope operator (<ph id="ph1">`Box::rotate(angle)`</ph>) or by invoking the virtual method through a class object (rather than a pointer or reference of that class).</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This latter suppression is not required by the language but is a quality of implementation issue, similar to the suppression of the construction of a temporary in a declaration of the form:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>So the proposal was taken back for further consideration, and several alternative notations were considered, and the one brought back to the committee was of the form (<ph id="ph1">`?type`</ph>), which indicated its undetermined – that is, dynamic nature.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This gave the user the ability to toggle between the two forms – static or dynamic – but no one was too pleased with it.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>So it was back to the drawing board.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The third and successful notation is the now standard <ph id="ph1">`dynamic_cast&lt;type&gt;`</ph>, which was generalized to a set of four new-style cast notations.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In ISO-C++, <ph id="ph1">`dynamic_cast`</ph> returns <ph id="ph2">`0`</ph> when applied to an inappropriate pointer type, and throws a <ph id="ph3">`std::bad_cast`</ph> exception when applied to a reference type.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In Managed Extensions for C++, applying <ph id="ph1">`dynamic_cast`</ph> to a managed reference type (because of its pointer representation) always returned <ph id="ph2">`0`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>was introduced as an analog to the exception throwing variant of the <ph id="ph1">`dynamic_cast`</ph>, except that it throws <ph id="ph2">`System::InvalidCastException`</ph> if the cast fails.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In the new syntax, <ph id="ph1">`__try_cast`</ph> has been recast as <ph id="ph2">`safe_cast`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Here is the same code fragment in the new syntax:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In the managed world, it is important to allow for verifiable code by limiting the ability of programmers to cast between types in ways that leave the code unverifiable.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This is a critical aspect of the dynamic programming paradigm represented by the new syntax.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For this reason, instances of old-style casts are recast internally as run-time casts, so that, for example:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>On the other hand, because polymorphism provides both an active and a passive mode, it is sometimes necessary to perform a downcast just to gain access to the non-virtual API of a subtype.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This can occur, for example, with the member(s) of a class that want to address any type within the hierarchy (passive polymorphism as a transport mechanism) but for which the actual instance within a particular program context is known.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In this case, having a run-time check of the cast can be an unacceptable overhead.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If the new syntax is to serve as the managed systems programming language, it must provide some means of allowing a compile-time (that is, static) downcast.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>That is why the application of the <ph id="ph1">`static_cast`</ph> notation is allowed to remain a compile-time downcast:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The problem is that there is no way to guarantee that the programmer doing the <ph id="ph1">`static_cast`</ph> is correct and well-intentioned; that is, there is no way to force managed code to be verifiable.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This is a more urgent concern under the dynamic program paradigm than under native, but is not sufficient within a system programming language to disallow the user the ability to toggle between a static and run-time cast.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>There is a performance trap and pitfall in the new syntax, however.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In native programming, there is no difference in performance between the old-style cast notation and the new-style <ph id="ph1">`static_cast`</ph> notation.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>But in the new syntax, the old-style cast notation is significantly more expensive than the use of the new-style <ph id="ph1">`static_cast`</ph> notation.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler internally transforms the use of the old-style notation into a run-time check that throws an exception.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Moreover, it also changes the execution profile of the code because it causes an uncaught exception bringing down the application – perhaps wisely, but the same error would not cause that exception if the <ph id="ph1">`static_cast`</ph> notation were used.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>One might argue this will help prod users into using the new-style notation.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>But only when it fails; otherwise, it will cause programs that use the old-style notation to run significantly slower without a visible understanding of why, similar to the following C programmer pitfalls:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>General Language Changes (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>C-Style Casts with /clr (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>safe_cast</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>