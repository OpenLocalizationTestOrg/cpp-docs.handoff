<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d1bee20d3cf60c7e3871f1ed57e387b240b4c9bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\multiplicative-operators-and-the-modulus-operator.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c4282f06979efa3e5aceea27088b3570d0b56ea</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d40a6b8c1afccc0376b495abc0e27fd897b8dbe4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Multiplicative Operators and the Modulus Operator | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Multiplicative Operators and the Modulus Operator</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The multiplicative operators are:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Multiplication (<bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Division (<bpt id="p1">**</bpt><ph id="ph1">/</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Modulus (remainder from division) (<ph id="ph1">`%`</ph>)</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>These binary operators have left-to-right associativity.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The multiplicative operators take operands of arithmetic types.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The modulus operator (<ph id="ph1">`%`</ph>) has a stricter requirement in that its operands must be of integral type.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>(To get the remainder of a floating-point division, use the run-time function, <bpt id="p1">[</bpt>fmod<ept id="p1">](../c-runtime-library/reference/fmod-fmodf.md)</ept>.) The conversions covered in <bpt id="p2">[</bpt>Standard Conversions<ept id="p2">](standard-conversions.md)</ept> are applied to the operands, and the result is of the converted type.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The multiplication operator yields the result of multiplying the first operand by the second.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The division operator yields the result of dividing the first operand by the second.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The modulus operator yields the remainder given by the following expression, where <bpt id="p1">*</bpt>e1<ept id="p1">*</ept> is the first operand and <bpt id="p2">*</bpt>e2<ept id="p2">*</ept> is the second: <bpt id="p3">*</bpt>e1<ept id="p3">*</ept> – (<bpt id="p4">*</bpt>e1<ept id="p4">*</ept><ph id="ph1"> / </ph><bpt id="p5">*</bpt>e2<ept id="p5">*</ept>) <ph id="ph2">\*</ph> <bpt id="p6">*</bpt>e2<ept id="p6">*</ept>, where both operands are of integral types.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Division by 0 in either a division or a modulus expression is undefined and causes a run-time error.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Therefore, the following expressions generate undefined, erroneous results:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If both operands to a multiplication, division, or modulus expression have the same sign, the result is positive.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Otherwise, the result is negative.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The result of a modulus operation's sign is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Since the conversions performed by the multiplicative operators do not provide for overflow or underflow conditions, information may be lost if the result of a multiplicative operation cannot be represented in the type of the operands after conversion.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In Microsoft C++, the result of a modulus expression is always the same as the sign of the first operand.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the computed division of two integers is inexact and only one operand is negative, the result is the largest integer (in magnitude, disregarding the sign) that is less than the exact value the division operation would yield.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, the computed value of –11 / 3 is –3.666666666.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The result of that integral division is –3.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The relationship between the multiplicative operators is given by the identity (<bpt id="p1">*</bpt>e1<ept id="p1">*</ept><ph id="ph1"> / </ph><bpt id="p2">*</bpt>e2<ept id="p2">*</ept>) <ph id="ph2">\*</ph> <bpt id="p3">*</bpt>e2<ept id="p3">*</ept><ph id="ph3"> + </ph><bpt id="p4">*</bpt>e1<ept id="p4">*</ept><ph id="ph4"> % </ph><bpt id="p5">*</bpt>e2<ept id="p5">*</ept><ph id="ph5"> == </ph><bpt id="p6">*</bpt>e1<ept id="p6">*</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following program demonstrates the multiplicative operators.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Note that either operand of <ph id="ph1">`10 / 3`</ph> must be explicitly cast to type <ph id="ph2">`float`</ph> to avoid truncation so that both operands are of type <ph id="ph3">`float`</ph> before division.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Expressions with Binary Operators</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>C++ Built-in Operators, Precedence and Associativity</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C Multiplicative Operators</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>