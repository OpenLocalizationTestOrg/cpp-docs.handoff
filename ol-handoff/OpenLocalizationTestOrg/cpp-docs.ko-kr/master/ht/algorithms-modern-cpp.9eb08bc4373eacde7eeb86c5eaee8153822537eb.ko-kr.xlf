<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ae1fc794e278d4d54c311a6fd1fbced52a3fd79</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\algorithms-modern-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a8336256bb2a1cf8a08f3e6cf2f4ff6d3c0c729</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">13a5a413f2cce1096950bc31b459b92c6e4af698</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Algorithms (Modern C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Algorithms (Modern C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>For modern C++ programming, we recommend that you use the algorithms in the <bpt id="p1">[</bpt>Standard Template Library<ept id="p1">](../standard-library/cpp-standard-library-reference.md)</ept> (STL).</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Here are some important examples:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>, which is the default traversal algorithm.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>(Also <ph id="ph1">`transform`</ph> for not-in-place semantics.)</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>, which is the default search algorithm.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>, <ph id="ph1">`lower_bound`</ph>, and the other default sorting and searching algorithms.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>To write a comparator, use strict <ph id="ph1">`&lt;`</ph> and use  <bpt id="p1">*</bpt>named lambdas<ept id="p1">*</ept> when you can.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Loops</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When possible, use range-based <ph id="ph1">`for`</ph> loops or algorithm calls, or both, instead of hand-written loops.<ph id="ph2">`copy`</ph>, <ph id="ph3">`transform`</ph>, <ph id="ph4">`count_if`</ph>, <ph id="ph5">`remove_if`</ph>, and others like them are much better than handwritten loops because their intent is obvious and they make it easier to write bug-free code.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Also, many STL algorithms have implementation optimizations that make them more efficient.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Instead of old C++ like this:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Use modern C++ like this:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Range-based for loops</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The range-based <ph id="ph1">`for`</ph> loop is a C++11 language feature, not an STL algorithm.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>But it deserves mention in this discussion about loops.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Range-based <ph id="ph1">`for`</ph> loops are an extension of the <ph id="ph2">`for`</ph> keyword and provide a convenient and efficient way to write loops that iterate over a range of values.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>STL containers, strings, and arrays are ready-made for range-based <ph id="ph1">`for`</ph> loops.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To enable this new iteration syntax for your user-defined type, add the following support:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`begin`</ph> method that returns an iterator to the beginning of the structure and an <ph id="ph2">`end`</ph> method that returns an iterator to the end of the structure.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Support in the iterator for these methods: <ph id="ph1">`operator*`</ph>, <ph id="ph2">`operator!=`</ph>, and <ph id="ph3">`operator++`</ph> (prefix version).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>These methods can be either members or stand-alone functions.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Random Numbers</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It's no secret that the old CRT <ph id="ph1">`rand()`</ph> function has many flaws, which have been discussed at length in the C++ community.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In modern C++, you don't have to deal with those shortcomings—nor do you have to invent your own uniformly distributed random number generator—because the tools for quickly and easily creating them are available in the STL, as shown in <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>random&gt;<ept id="p1">](../standard-library/random.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Welcome Back to C++</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>C++ Language Reference</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>C++ Standard Library</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>