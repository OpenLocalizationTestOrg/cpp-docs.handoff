<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e3bd7fbf1d28dce42a4102dc25e3d510ac80148</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp-conformance-improvements-2017.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">668e4130497ee6d38636235dae68327afdb4264a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49d28e4a3ebae2430b1055310d5737ed73210612</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>C++ compiler conformance improvements | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>C++ conformance improvements in</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>New language features</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>With support for generalized constexpr and NSDMI for aggregates, the compiler is now complete for features added in the C++14 Standard.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Note that the compiler still lacks a few features from the C++11 and C++98 Standards.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>C++11:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Expression SFINAE support in more libraries<ept id="p1">**</ept> The Visual C++ compiler continues to improve its support for expression SFINAE, which is required for template argument deduction and substitution where decltype and constexpr expressions may appear as template parameters.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Expression SFINAE improvements in Visual Studio 2017 RC<ept id="p1">](https://blogs.msdn.microsoft.com/vcblog/2016/06/07/expression-sfinae-improvements-in-vs-2015-update-3)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>C++ 14:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>NSDMI for Aggregates<ept id="p1">**</ept> An aggregate is an array or a class with no user-provided constructor, no private or protected non-static data members, no base classes, and no virtual functions.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Beginning in C++14 aggregates may contain member initializers.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Member initializers and aggregates<ept id="p1">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Extended constexpr<ept id="p1">**</ept> Expressions declared as constexpr are now allowed to contain certain kinds of declarations, if and switch statements, loop statements, and mutation of objects whose lifetime began within the constexpr expression evaluation.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Also, there is no longer a requirement that a constexpr non-static member function be implicitly const.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Relaxing constraints on constexpr functions<ept id="p1">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C++17:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Terse static_assert<ept id="p1">**</ept>  (available with /std:c++latest) In C++17 the message parameter for static_assert is optional.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Extending static_assert, v2<ept id="p1">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>[[fallthrough]] attribute<ept id="p1">**</ept>  (available with /std:c++latest) The [[fallthrough]] attribute can be used in the context of switch statements as a hint to the compiler that the fall-through behavior is intended.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This prevents the compiler from issuing warnings in such cases.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Wording for [[fallthrough]] attribute<ept id="p1">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generalized range-based for loops<ept id="p1">**</ept> (no compiler switch required) Range-based for loops no longer require that begin() and end() return objects of the same type.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This enables end() to return a sentinel object such as used by ranges as defined in the Ranges-V3 proposal.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Generalizing the Range-Based For Loop<ept id="p1">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html)</ept> and the <bpt id="p2">[</bpt>range-v3 library on GitHub<ept id="p2">](https://github.com/ericniebler/range-v3)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For the complete list of conformance improvements up through Visual Studio 2015, Update 3, see <bpt id="p1">[</bpt>Visual C++ What's New 2003 through 2015<ept id="p1">](https://msdn.microsoft.com/en-us/library/mt723604.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Copy-list-initialization</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 correctly raises compiler errors related to object creation using initializer lists that were not caught in Visual Studio 2015 and could lead to crashes or undefined runtime behavior.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>As per N4594 13.3.1.7p1, in copy-list-initialization, the compiler is required to consider an explicit constructor for overload resolution, but must raise an error if that overload is actually chosen.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following two examples compile in Visual Studio 2015 but not in Visual Studio 2017.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To correct the error, use direct initialization:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015, the compiler erroneously treated copy-list-initialization in the same way as regular copy-initialization; it considered only converting constructors for overload resolution.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the following example, Visual Studio 2015 chooses MyInt(23) but Visual Studio 2017 correctly raises the error.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one but raises a different error.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It succeeds in Visual Studio 2015 and fails in Visual Studio 2017 with C2668.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Deprecated typedefs</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 now issues the correct warning for deprecated typedefs that are declared in a class or struct.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example compiles without warnings in Visual Studio 2015 but produces C4996 in Visual Studio 2017.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>constexpr</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 correctly raises an error when the left-hand operand of a conditionally evaluating operation is not valid in a constexpr context.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following code compiles in Visual Studio 2015 but not in Visual Studio 2017:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To correct the error, either declare the array::size() function as constexpr or remove the constexpr qualifier from f.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Class types passed to variadic functions</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2017, classes or structs that are passed to a variadic function such as printf must be trivially copyable.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When passing such objects, the compiler simply makes a bitwise copy and does not call the constructor or destructor.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>To correct the error, you can call a member function that returns a trivially copyable type,</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>or else perform a static cast to convert the object before passing it:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For strings built and managed using CStringW, the provided ‘operator LPCWSTR()’ should be used to cast a CStringW object to the C pointer expected by the format string.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>cv-qualifiers in class construction</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015, the compiler sometimes incorrectly ignores the cv-qualifier when generating a class object via a constructor call.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This can potentially cause a crash or unexpected runtime behavior.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example compiles in Visual Studio 2015 but raises a compiler error in Visual Studio 2017:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To correct the error, declare operator int() as const.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Access checking on qualified names in templates</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Previous versions of the compiler did not perform access checking on qualified names in some template contexts.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This can interfere with expected SFINAE behavior where the substitution is expected to fail due to the inaccessibility of a name.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This could have potentially caused a crash or unexpected behavior at runtime due to the compiler incorrectly calling the wrong overload of the operator.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2017, a compiler error is raised.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The specific error might vary but typically it is "C2672 no matching overloaded function found".</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following code compiles in Visual Studio 2015 but raises an error in Visual Studio 2017:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Missing template argument lists</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015 and earlier, the compiler did not diagnose missing template argument lists when the template appeared in a template parameter list (for example as part of a default template argument or a non-type template parameter).</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This can result in unpredictable behavior, including compiler crashes or unexpected runtime behavior.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following code compiles in Visual Studio 2015 but produces an error in Visual Studio 2017.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Expression-SFINAE</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To support expression-SFINAE, the compiler now parses decltype arguments when the templates are declared rather than instantiated.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Consequently, if a non-dependent specialization is found in the decltype argument, it will not be deferred to instantiation-time and will be processed immediately and any resulting errors will be diagnosed at that time.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example shows such a compiler error that is raised at the point of declaration:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Default initializers for value class members (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015 and earlier, the compiler permitted (but ignored) a default member initializer for a member of a value class.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Default initialization of a value class always zero-initializes the members; a default constructor is not permitted.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2017, default member initializers raise a compiler error, as shown in this example:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Default Indexers (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2015 and earlier, the compiler in some cases misidentified a default property as a default indexer.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It was possible to work around the issue by using the identifier "default" to access the property.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The workaround itself became problematic after default was introduced as a keyword in C++11.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Therefore, in Visual Studio 2017 the bugs that required the workaround were fixed, and the compiler now raises an error when "default" is used to access the default property for a class.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In Visual Studio 2017, you can access both Value properties by their name:</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>