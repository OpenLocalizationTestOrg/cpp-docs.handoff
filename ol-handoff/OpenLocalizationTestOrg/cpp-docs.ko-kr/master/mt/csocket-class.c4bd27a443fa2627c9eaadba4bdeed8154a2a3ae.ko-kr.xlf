<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4d629d8cb5ae6bb39244802e0ac06af3720c06d7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\csocket-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2590f64e18176adf6cc4acf5d93e482b0f8825b8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e8f20d3b1ef3d5e5ea4e16e1623c79c1a1f233dd</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CSocket Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CSocket Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Derives from <ph id="ph1">`CAsyncSocket`</ph>, inherits its encapsulation of the Windows Sockets API, and represents a higher level of abstraction than that of a <ph id="ph2">`CAsyncSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::CSocket<ept id="p1">](#csocket__csocket)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::Attach<ept id="p1">](#csocket__attach)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Attaches a <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle to a <ph id="ph1">`CSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::CancelBlockingCall<ept id="p1">](#csocket__cancelblockingcall)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Cancels a blocking call that is currently in progress.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::Create<ept id="p1">](#csocket__create)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Creates a socket.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::FromHandle<ept id="p1">](#csocket__fromhandle)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a <ph id="ph1">`CSocket`</ph> object, given a <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::IsBlocking<ept id="p1">](#csocket__isblocking)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Determines whether a blocking call is in progress.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Protected Methods</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CSocket::OnMessagePending<ept id="p1">](#csocket__onmessagepending)</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Called to process pending messages while waiting for a blocking call to complete.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CSocket`</ph> works with classes <ph id="ph2">`CSocketFile`</ph> and <ph id="ph3">`CArchive`</ph> to manage the sending and receiving of data.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CSocket`</ph> object also provides blocking, which is essential to the synchronous operation of <ph id="ph2">`CArchive`</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Blocking functions, such as <ph id="ph1">`Receive`</ph>, <ph id="ph2">`Send`</ph>, <ph id="ph3">`ReceiveFrom`</ph>, <ph id="ph4">`SendTo`</ph>, and <ph id="ph5">`Accept`</ph> (all inherited from <ph id="ph6">`CAsyncSocket`</ph>), do not return a <ph id="ph7">`WSAEWOULDBLOCK`</ph> error in <ph id="ph8">`CSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Instead, these functions wait until the operation completes.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Additionally, the original call will terminate with the error <ph id="ph1">`WSAEINTR`</ph> if <ph id="ph2">`CancelBlockingCall`</ph> is called while one of these functions is blocking.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To use a <ph id="ph1">`CSocket`</ph> object, call the constructor, then call <ph id="ph2">`Create`</ph> to create the underlying <ph id="ph3">`SOCKET`</ph> handle (type <ph id="ph4">`SOCKET`</ph>).</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The default parameters of <ph id="ph1">`Create`</ph> create a stream socket, but if you are not using the socket with a <ph id="ph2">`CArchive`</ph> object, you can specify a parameter to create a datagram socket instead, or bind to a specific port to create a server socket.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Connect to a client socket using <ph id="ph1">`Connect`</ph> on the client side and <ph id="ph2">`Accept`</ph> on the server side.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Then create a <ph id="ph1">`CSocketFile`</ph> object and associate it to the <ph id="ph2">`CSocket`</ph> object in the <ph id="ph3">`CSocketFile`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Next, create a <ph id="ph1">`CArchive`</ph> object for sending and one for receiving data (as needed), then associate them with the <ph id="ph2">`CSocketFile`</ph> object in the <ph id="ph3">`CArchive`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When communications are complete, destroy the <ph id="ph1">`CArchive`</ph>, <ph id="ph2">`CSocketFile`</ph>, and <ph id="ph3">`CSocket`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SOCKET`</ph> data type is described in the article <bpt id="p1">[</bpt>Windows Sockets: Background<ept id="p1">](../../mfc/windows-sockets-background.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When you use <ph id="ph1">`CArchive`</ph> with <ph id="ph2">`CSocketFile`</ph> and <ph id="ph3">`CSocket`</ph>, you might encounter a situation where <ph id="ph4">`CSocket::Receive`</ph> enters a loop (by <ph id="ph5">`PumpMessages(FD_READ)`</ph>) waiting for the requested amount of bytes.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This is because Windows sockets allow only one recv call per FD_READ notification, but <ph id="ph1">`CSocketFile`</ph> and <ph id="ph2">`CSocket`</ph> allow multiple recv calls per FD_READ.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If you get an FD_READ when there is no data to read, the application hangs.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you never get another FD_READ, the application stops communicating over the socket.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can resolve this problem as follows.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`OnReceive`</ph> method of your socket class, call <ph id="ph2">`CAsyncSocket::IOCtl(FIONREAD, ...)`</ph> before you call the <ph id="ph3">`Serialize`</ph> method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes).</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the size of the available data is less than needed, wait for all the data to be received and only then start the read operation.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`m_dwExpected`</ph> is the approximate number of bytes that the user expects to receive.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It is assumed that you declare it elsewhere in your code.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>NVC_MFCSocketThread#4<ept id="p2">](../../mfc/reference/codesnippet/cpp/csocket-class_1.cpp)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When using MFC sockets in secondary threads in a statically linked MFC application, you must call <ph id="ph1">`AfxSocketInit`</ph> in each thread that uses sockets to initialize the socket libraries.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`AfxSocketInit`</ph> is called only in the primary thread.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets in MFC<ept id="p1">](../../mfc/windows-sockets-in-mfc.md)</ept>, <bpt id="p2">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p2">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>, <bpt id="p3">[</bpt>Windows Sockets: How Sockets with Archives Work<ept id="p3">](../../mfc/windows-sockets-how-sockets-with-archives-work.md)</ept>, <bpt id="p4">[</bpt>Windows Sockets: Sequence of Operations<ept id="p4">](../../mfc/windows-sockets-sequence-of-operations.md)</ept>, <bpt id="p5">[</bpt>Windows Sockets: Example of Sockets Using Archives<ept id="p5">](../../mfc/windows-sockets-example-of-sockets-using-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CObject<ept id="p1">](../../mfc/reference/cobject-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CAsyncSocket<ept id="p1">](../../mfc/reference/casyncsocket-class.md)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> afxsock.h</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__attach"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::Attach</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Call this member function to attach the <ph id="ph1">`hSocket`</ph> handle to a <ph id="ph2">`CSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Contains a handle to a socket.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle is stored in the object's <bpt id="p2">[</bpt>m_hSocket<ept id="p2">](../../mfc/reference/casyncsocket-class.md#casyncsocket__m_hsocket)</ept> data member.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>NVC_MFCSocketThread#1<ept id="p2">](../../mfc/reference/codesnippet/cpp/csocket-class_2.h)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>NVC_MFCSocketThread#2<ept id="p2">](../../mfc/reference/codesnippet/cpp/csocket-class_3.cpp)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>NVC_MFCSocketThread#3<ept id="p2">](../../mfc/reference/codesnippet/cpp/csocket-class_4.cpp)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__cancelblockingcall"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::CancelBlockingCall</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Call this member function to cancel a blocking call currently in progress.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This function cancels any outstanding blocking operation for this socket.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The original blocking call will terminate as soon as possible with the error <bpt id="p1">**</bpt>WSAEINTR<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the case of a blocking <bpt id="p1">**</bpt>Connect<ept id="p1">**</ept> operation, the Windows Sockets implementation will terminate the blocking call as soon as possible, but it may not be possible for the socket resources to be released until the connection has completed (and then been reset) or timed out.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This is likely to be noticeable only if the application immediately tries to open a new socket (if no sockets are available), or to connect to the same peer.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Canceling any operation other than <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> can leave the socket in an indeterminate state.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If an application cancels a blocking operation on a socket, the only operation that the application can depend on being able to perform on the socket is a call to <bpt id="p1">**</bpt>Close<ept id="p1">**</ept>, although other operations may work on some Windows Sockets implementations.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you desire maximum portability for your application, you must be careful not to depend on performing operations after a cancel.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__create"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::Create</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> member function after constructing a socket object to create the Windows socket and attach it.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A particular port to be used with the socket, or 0 if you want MFC to select a port.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> **</bpt>SOCK_STREAM<ept id="p1">**</ept> or <bpt id="p2">**</bpt>SOCK_DGRAM<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>A pointer to a string containing the network address of the connected socket, a dotted number such as "128.56.22.8".</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Passing the <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> string for this parameter indicates the <bpt id="p2">**</bpt>CSocket<ept id="p2">**</ept> instance should listen for client activity on all network interfaces.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <ph id="ph1">`GetLastError`</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Create<ept id="p1">**</ept> then calls <bpt id="p2">**</bpt>Bind<ept id="p2">**</ept> to bind the socket to the specified address.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following socket types are supported:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SOCK_STREAM<ept id="p1">**</ept> Provides sequenced, reliable, two-way, connection-based byte streams.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Uses Transmission Control Protocol (TCP) for the Internet address family.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SOCK_DGRAM<ept id="p1">**</ept> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Uses User Datagram Protocol (UDP) for the Internet address family.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>To use this option, you must not use the socket with a <ph id="ph1">`CArchive`</ph> object.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept> member function takes a reference to a new, empty <ph id="ph1">`CSocket`</ph> object as its parameter.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>You must construct this object before you call <bpt id="p1">**</bpt>Accept<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Keep in mind that if this socket object goes out of scope, the connection closes.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Do not call <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> for this new socket object.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For more information about stream and datagram sockets, see the articles <bpt id="p1">[</bpt>Windows Sockets: Background<ept id="p1">](../../mfc/windows-sockets-background.md)</ept>, <bpt id="p2">[</bpt>Windows Sockets: Ports and Socket Addresses<ept id="p2">](../../mfc/windows-sockets-ports-and-socket-addresses.md)</ept>, and <bpt id="p3">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p3">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__csocket"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::CSocket</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>After construction, you must call the <bpt id="p1">**</bpt>Create<ept id="p1">**</ept> member function.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__fromhandle"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::FromHandle</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a <ph id="ph1">`CSocket`</ph> object.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Contains a handle to a socket.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A pointer to a <ph id="ph1">`CSocket`</ph> object, or <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> if there is no <ph id="ph2">`CSocket`</ph> object attached to <ph id="ph3">`hSocket`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>When given a <bpt id="p1">**</bpt>SOCKET<ept id="p1">**</ept> handle, if a <ph id="ph1">`CSocket`</ph> object is not attached to the handle, the member function returns <bpt id="p2">**</bpt>NULL<ept id="p2">**</ept> and does not create a temporary object.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__isblocking"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::IsBlocking</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Call this member function to determine if a blocking call is in progress.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Nonzero if the socket is blocking; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="csocket__onmessagepending"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>  CSocket::OnMessagePending</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Override this member function to look for particular messages from Windows and respond to them in your socket.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Nonzero if the message was handled; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This is an advanced overridable.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The framework calls <ph id="ph1">`OnMessagePending`</ph> while the socket is pumping Windows messages to give you an opportunity to deal with messages of interest to your application.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For examples of how you might use <ph id="ph1">`OnMessagePending`</ph>, see the article <bpt id="p1">[</bpt>Windows Sockets: Deriving from Socket Classes<ept id="p1">](../../mfc/windows-sockets-deriving-from-socket-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Windows Sockets: Using Sockets with Archives<ept id="p1">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CAsyncSocket Class<ept id="p1">](../../mfc/reference/casyncsocket-class.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Hierarchy Chart<ept id="p1">](../../mfc/hierarchy-chart.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>CAsyncSocket Class<ept id="p1">](../../mfc/reference/casyncsocket-class.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>CSocketFile Class<ept id="p1">](../../mfc/reference/csocketfile-class.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>